real REFaadaptation=0.000319439;
real REFaalapacien=1;
real REFaalaplaceXnc=1713.48;
real REFaamove=0.070846;
real REFaaRT=280.926;
real REFarrayoFVh=4560.74;
real REFbilap=33.835;
real REFD2=0;
real REFdemo1=1.31154;
real REFdemo=0.136436;
real REFfunct=4;
real REFlapacienprecon=122059;
real REFlapXmat=85.3776;
real REFNSP1P1b=0.046197;
real REFNSP1P1=0.0392512;
real REFNSP1P2=0.0453672;
real REFparareal=1383.27;
real REFRichard=95.9004;
real REFteste=1;
real REFwaferXheatingXlaserXaxi=285;
//  a example to test the level of optimisation
// --------------------------------------------
// PARAM -n 100
include "getARGV.idp"

int nn=getARGV("-n",300);
 mesh Th=square(nn,nn);
verbosity=5;
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function

 problem laplace0(uh,vh,solver=Cholesky,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplace1(uh,vh,solver=CG,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplaceLU(uh,vh,solver=LU,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplaceCrout(uh,vh,solver=Crout,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

real cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap Cholesky " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
uh=0;
cpu=clock() ;
laplace1; // solve the problem plot(uh); // to see the result
cout << "-- lap CG       " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
uh=0;

cpu=clock() ;
laplaceLU; // solve the problem plot(uh); // to see the result
cout << "-- lap LU       " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
uh=0;

cpu=clock() ;
laplaceCrout; // solve the problem plot(uh); // to see the result
cout << "-- lap Crout    " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;

// FFCS: reference value for regression tests
real regtest=uh[].max;

uh=0;

if(HaveUMFPACK){
  problem laplace2(uh,vh,solver="SPARSESOLVER",tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
    + int1d(Th,1)( uh*vh) 
    + int1d(Th,1)( - vh)
    + int2d(Th)( -f*vh )                          //  linear form
    + on(2,3,4,uh=g) ;                      //  boundary condition form

  cpu=clock(); 
  laplace2; // solve the problem plot(uh); // to see the result
  cout << "-- lap UMFPACK  " << nn << "x" << nn << "  : "
       <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
}
else{
  cout << "-- lap UMFPACK  " << nn << "x" << nn << "  : "
       <<  "not available" << endl;
}

//  plot(uh,ps="lap1-cpu.eps",value=true);
mesh Th=square(40,40,flags=3);

fespace Vh(Th,P1nc);
fespace Pdh(Th,P0);
fespace Pch(Th,P1);
fespace Ph(Th,P1dc);
macro grad(u) [dx(u),dy(u)]//
macro Grad(u) [grad(u#1),grad(u#2)]//
macro div(u) (dx(u#1)+dy(u#2))//

Vh u1,u2,v1,v2;
Pdh pd,qd;
Pch pc,qc;
real eps = 1e-8; 
solve Stokes( [u1,u2,pc,pd],[v1,v2,qc,qd])
= int2d(Th) ( (Grad(u):Grad(v)) - pd*div(v) - qd*div(u) + [v1,v2]'*grad(pc) + [u1,u2]'*grad(qc)
   -eps*pc*qc -eps*pd*qd)
+  on(3,u1=(1-x)*x,u2=0)   
+ on(1,2,4,u1=0,u2=0);

plot([u1,u2],wait=1);

Ph p = pd+pc;
plot(p, wait=1);
// Warning we forgot to remove 3 pointer in this exemple
// precon=Precon correct in version 1.26 
verbosity=4;

mesh Th=square(10,10,[10*x,5*y]);
fespace Vh(Th,P1);

Vh u,v;

u=0;
func f= 0;
func g= 5*x+y;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
varf vAA(u,v) =    
   int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int1d(Th,1) ( u*v ) 
  + on(3,4,u=0) ;
int pprc=1;
matrix AA = vAA(Vh,Vh,solver=CG);
func real[int]  Precon(real[int] & xx)
{
 cout << xx[0] << " -----" ;
//  xx[0]=1001;
   
   real[int] xpre = xx;
   if(pprc) xpre = AA^-1*xx;
  return xpre;
};

problem Probem1(u,v,solver=CG,init=i,eps=1.0e-6,precon=Precon) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int1d(Th,1) ( u*v ) 
  + int2d(Th) ( v*f ) 
  + int1d(Th,2) (-5*v)
  + int1d(Th,1) ( (+1-g)*v)
  + on(3,4,u=g)  ;
  
real cpu=clock();
Probem1; // SOLVE THE PROBLEM 1
plot(u);
cout << " CPU = " << clock()-cpu << endl;
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




ofstream ref("ref.edp");





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


cout << "--------- file : aadaptation.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aadaptation.edp";
	real TESTaadaptation=regvalue;
		ref<<"real REFaadaptation="<<TESTaadaptation<<";"<<endl;
};
;
cout << "--------- file : aalapacien.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalapacien.edp";
	real TESTaalapacien=1+err;
		ref<<"real REFaalapacien="<<TESTaalapacien<<";"<<endl;
};
;
cout << "--------- file : aalaplace-nc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalaplace-nc.edp";
	real TESTaalaplaceXnc=u[]'*u[];
		ref<<"real REFaalaplaceXnc="<<TESTaalaplaceXnc<<";"<<endl;
};
;
cout << "--------- file : aamove.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aamove.edp";
	real TESTaamove=u[]'*u[];
		ref<<"real REFaamove="<<TESTaamove<<";"<<endl;
};
;
cout << "--------- file : aaRT.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aaRT.edp";
	real TESTaaRT=u1[]'*u1[];
		ref<<"real REFaaRT="<<TESTaaRT<<";"<<endl;
};
;
cout << "--------- file : arrayoFVh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "arrayoFVh.edp";
	real TESTarrayoFVh=u[]'*u[];
		ref<<"real REFarrayoFVh="<<TESTarrayoFVh<<";"<<endl;
};
;
cout << "--------- file : bilap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "bilap.edp";
	real TESTbilap=xx(0:n)'*xx(0:n);
		ref<<"real REFbilap="<<TESTbilap<<";"<<endl;
};
;
cout << "--------- file : D2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "D2.edp";
	real TESTD2=w[]'*w[];
		ref<<"real REFD2="<<TESTD2<<";"<<endl;
};
;
cout << "--------- file : demo1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo1.edp";
	real TESTdemo1=u[]'*u[];
		ref<<"real REFdemo1="<<TESTdemo1<<";"<<endl;
};
;
cout << "--------- file : demo.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo.edp";
	real TESTdemo=u[]'*u[];
		ref<<"real REFdemo="<<TESTdemo<<";"<<endl;
};
;
cout << "--------- file : funct.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "funct.edp";
	real TESTfunct=myfunction(1.0,3.);
		ref<<"real REFfunct="<<TESTfunct<<";"<<endl;
};
;
cout << "--------- file : lapacienprecon.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lapacienprecon.edp";
	real TESTlapacienprecon=u[]'*u[];
		ref<<"real REFlapacienprecon="<<TESTlapacienprecon<<";"<<endl;
};
;
cout << "--------- file : lap_mat.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lap_mat.edp";
	real TESTlapXmat=u1[]'*u1[];
		ref<<"real REFlapXmat="<<TESTlapXmat<<";"<<endl;
};
;
cout << "--------- file : NSP1P1b.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1b.edp";
	real TESTNSP1P1b=int2d(Th)(square(u1)+square(u2));
		ref<<"real REFNSP1P1b="<<TESTNSP1P1b<<";"<<endl;
};
;
cout << "--------- file : NSP1P1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1.edp";
	real TESTNSP1P1=int2d(Th)(square(u1)+square(u2));
		ref<<"real REFNSP1P1="<<TESTNSP1P1<<";"<<endl;
};
;
cout << "--------- file : NSP1P2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P2.edp";
	real TESTNSP1P2=int2d(Th)(square(u1)+square(u2));
		ref<<"real REFNSP1P2="<<TESTNSP1P2<<";"<<endl;
};
;
cout << "--------- file : parareal.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "parareal.edp";
	real TESTparareal=pu'*pu;
		ref<<"real REFparareal="<<TESTparareal<<";"<<endl;
};
;

 cout << "--------- file : Richard.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "Richard.edp";
	real TESTRichard=hmax;
		ref<<"real REFRichard="<<TESTRichard<<";"<<endl;
};
;

cout << "--------- file : teste.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "teste.edp";
	real TESTteste=P.x;
		ref<<"real REFteste="<<TESTteste<<";"<<endl;
};
;
cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};
;
cout << "--------- file : wafer-heating-laser-axi.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "wafer-heating-laser-axi.edp";
	real TESTwaferXheatingXlaserXaxi=xx'*xx;
		ref<<"real REFwaferXheatingXlaserXaxi="<<TESTwaferXheatingXlaserXaxi<<";"<<endl;
};
;
//  laplace with matrix  
verbosity=10;
mesh Th=square(10,10);
fespace Vh(Th,P1);
Vh u1,u2;
                    
varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(1,2,3,4,u1=1);
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 );

matrix A= a(Vh,Vh,solver=CG); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

Vh bb ,bc,rhs;
bc[]= a(0,Vh);       // to save the
u1=x;
bb[] = bc[] .* u1[];
u1[] = A^-1*bb[];
//plot(u1,cmm="solution = x ",wait=1,value=1);
u1=x*y;
bb[] = bc[] .* u1[];
u1[] = A^-1*bb[];
//plot(u1,cmm="solution = x*y ",wait=1,value=1);
u1=-4;  //  $-\Delta (x^2 + y^2) $
bb[] = B*u1[];
u1= x^2 + y^2 ;
bb[] += bc[] .* u1[];
u1[] = A^-1*bb[];
u2= x^2 + y^2;

cout << "  u1(1,2) =" <<  u1(.1,.2) << " ~= " << u2(.1,.2) 
     << " ==  " << .1^2+.2^2 <<  endl;
plot(u1,cmm="solution = $x^2 + y^2$ ",wait=1,value=1);
real[int] T=1:5;
real[int,int] RR= [ [0,1,0,0,0 ], 
[0,0,1,0,0 ], 
[0,0,0,0,1 ]];
real[int,int] CC= [ [0,1,0,0,0 ], 
[0,1,1,0,0 ], 
[0,2,0,0,1 ],
[0,3,0,0,1 ],
[0,4,0,0,1 ]];

real[int] r(1),ra(1); 
matrix R=RR; 
matrix C=CC;
cout << R << endl;
cout << " T = " << T << endl;

renumbering(R,T,r);
cout << " r= " << r << endl; 
renumbering(C,R,T,ra);
cout << " ra= " << ra << endl; 
cout << C << endl;
assert( C.n==3 && C.m ==3);
assert(ra.n==3 && r.n==3);
verbosity=2;
border aaa(t=0,1){x=t;y=0;};
border bbb(t=0,0.5){x=1;y=t;};
border ccc(t=0,0.5){x=1-t;y=0.5;};
border ddd(t=0.5,1){x=0.5;y=t;};
border eee(t=0.5,1){x=1-t;y=1;};
border fff(t=0,1){x=0;y=1-t;};
mesh Th = buildmesh (aaa(6) + bbb(4) + ccc(4) +ddd(4) + eee(4) + fff(6));
fespace Vh(Th,P1);

Vh u,v,zero;

u=0;
u=0;
zero=0;
func f= 1;
func g= 0;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
problem Probem1(u,v,solver=CG,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(aaa,bbb,ccc,ddd,eee,fff,u=g)  ;
  
real cpu=clock();

for (i=0;i< 5;i++)
{ 
  
  real d = clock();
  Probem1; 
  plot(u,zero,wait=1,ps="Lm"+i+".eps");
  plot(u,zero,wait=1,ps="Lu"+i+".eps");
  Th=adaptmesh(Th,u,inquire=1,err=error);
  cout << " CPU = " << clock()-d << endl;
  error = error * coef;
} ;

 cout << " CPU = " << clock()-cpu << endl;
//  for regtest 
real regvalue=int2d(Th)(u*u);
cout<<"regvalue="<<regvalue<<endl;
real Ks=0.01,
     hg=30,
     thetas=0.3,
     eta = 6.55,
     m = 0.173,
     n = 2/(1-m);
     
     
real z0=215;
real q0=15/3600.;
real dt=60;
real hmax=0;

// $A(h) - \partial h / \partial t - div(K(h)(\nabla(h-y)) = f $ dans $ \Omega$
//  -K(h)(\nabla(h-y)). n = q0 $ sur $ \Gamma_1$
//  h = h_0$ sur $\Gamma_0$
//  + condition initial $d_d$
//   A(h) = h <0 ? C(h) : 0; 
//  


// remarque z == y 
real xmax = 300, ymax=300, x0=60, y0= 215;

border ba(t=0,ymax)   { x=0; y=ymax-t ;label=2;};  // gauche   
   
border bb1(t=x0,0)    { x=t; y=ymax ;label=1;};   // haut     1 
border bb2(t=xmax,x0) { x=t; y=ymax ;label=2;};  // haut   2   
 
border bc1(t=y0,0) { x=xmax; y=ymax-t ;label=2;};  // droite     
border bc2(t=ymax,y0) { x=xmax; y=ymax-t ;label=3;};  // droite  
   
border bd(t=0,xmax)   { x=t; y=0; label=4;};   // bas

int Gamma0=3;
int Gamma1=1;

int nn=20;
int nn1=nn*x0/xmax,nn2=nn-nn1;
int ny1=nn*y0/ymax,ny2=nn-ny1;
plot(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn),wait=1);
mesh Th=buildmesh(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn));
plot(Th,wait=1);

fespace Vh(Th,P1);
Vh h,v,hhh;

macro theta(h) (thetas*(1+((abs(h)/hg))^n)^(-m))//
macro dtheta(h) (m*n*thetas*(1+((abs(h)/hg))^n)^(-m-1)*(((abs(h)/hg))^(n-1))/hg)
//
macro A(h)  ( (h<=0)* dtheta(h) ) 
//
macro K(h) (Ks*((h<=0)*((theta(h)/thetas)^eta)+ (h>0)))
//

Vh hd= -y0+(ymax-y); // bof bof ????
Vh hn=hd,hh;
Vh Ahdt,Kh;

int nbiso=20;
real[int] viso(3+(75+110/2)/5);

{int k=0;
for(int i=-75;i<0;i+=5)
 viso(k++)=i;
 viso(k++)=-0.5;
 viso(k++)=0.;
 viso(k++)=0.5;
for(int i=5;i<=110;i+=5*2)
 viso(k++)=i;
}
/* 
problem Richard(h,v) =
  int2d(Th)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(Th)( Ahdt* hn*v - Kh* dy(v) )
- int1d(Th,Gamma1)(q0*v)
+ on(3,h=(ymax-y)-y0)
;
*/

real pena=1e10;
problem Richard(h,v) =
  int2d(Th)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(Th)( Ahdt* hn*v - Kh* dy(v) )
- int1d(Th,Gamma1)(q0*v)
 +int1d(Th,3)(pena*h*v)-int1d(Th,3)(pena*((ymax-y)-y0)* v)

;


plot(hn,wait=1,cmm=" hd ");

Ahdt=0; Kh=1;
// Richard;
// plot(hd,wait=1,cmm="hd ----");
real temps=0;
for(int i=0;i<100;i++)
{
  string scmm="h + temps "+int(temps)/3600+"h "+ ((temps)%3600/60.) + "mn ";
  for(int k=0;k<3;k++) 
  {
  Kh=K(h);
  Ahdt=A(h)/dt;
  
  cout << " "<< Kh[].min << " " << Kh[].max << endl;
 // plot(Ahdt,fill=1,value=1,wait=1,cmm="Ahdt");
 // plot(Kh,fill=1,value=1,wait=1,cmm="Kh");
 // plot(Kh,wait=1,cmm="Kh");
  Richard;
  cout << " h: min " << h[].min << " max  " << h[].max <<endl;
  hmax=h[].max ;
  // plot(h,wait=0,cmm=scmm,viso=viso);
//  hhh = h <0;
  }
  if(i%10==1) {
  Th=adaptmesh(Th,h,ratio=1.1,nbvx=100000);
//  plot(Th,h,cmm="h ",value=1,wait=1);
  }
 // plot(hhh,wait=1,cmm="h < 0");
  plot(h,wait=0,cmm=scmm,viso=viso,value=1);
//  plot(h,cmm="h ",value=1);
  hn=h;
  temps += dt;
}

cout <<  " hmax = " << hmax << endl;
//int Nh=20;
// d u /dt = cos(t), u= sin(t) + u0
//  avec de methode para reel.
// schema euler explicite 
//   (u,v)' = (v,-u) 
//    u_n+1 - u_n = v_n*dt,  u_n+1 = u_n + v_n*dt
//    v_n+1 - v_n = -u_n*dt,
//   u=cos(t)  u' = - sin(t) = v
//   v=sin(t), v' = cos(t) = u
// ----------------------------
real DT=0.4;
int nbT=50;   // nb de big time step 
int ksub=50;  // nb of small time step 
int Nbig=20;  // max  number of Big iteration
real T0=0;    // initial time
real tol=1e-5; // tolerance 
// ----------------------------------------------------
int nbt=ksub*nbT;
real dt=DT/ksub;
//  array for plotting 
real[int] pt(nbt+1),pT(nbT+1),pu(nbt+1),pU(nbT+1);

//  gros maillage
mesh TH=square(3,3);
// maillage fin
mesh Th=trunc(TH,1,split=1);
fespace VH(TH,P1);
fespace Vh(Th,P1);
int n=2;
int N=2;

func real Norm(real[int] & U)
{
  return sqrt(square(U[10])+square(U[11]));
}
// restriction
func bool h2H(real[int] & u,real[int] & U)
{
 U=0;
 U[10+0]=u[0];
 U[10+1]=u[1];

 return true;
}
//  prolongement
func bool H2h(real[int] & U,real[int] & u)
{
 u=0;
 u[0]=U[10+0];
 u[1]=U[10+1];
 return true;
}

func bool initG(real[int]  & U)
{
  U=0;
  U[10+0]=1;// cos(0)
  U[10+1]=0;// sin(0)
}
// un pas de temps  FIN

func bool  F(real[int]  & u,real[int]  & up)
{
   u[0] = up[0] + up[1]*dt;
   u[1] = up[1] - up[0]*dt;
//   cout << up[0] << " " << up[1] << endl;
   return true;
}

// pas de temps grossier
func bool  G(real[int]  & U,real[int]  & Up)
{
   U[0+10] = Up[0+10] + Up[1+10]*DT;
   U[1+10] = Up[1+10] - Up[0+10]*DT;
//   cout << Up[10] << " " << Up[11] << endl;
   return true;
}

func bool AddGp(real[int]  & U,int I)
{
  pT[I]= T0+I*DT;
  pU[I]=U[10];
  return true;
}
func bool AddFp(real[int]  & u,int I,int i)
{
  pt[I*ksub+i]= T0+I*DT+i*dt;
  pu[I*ksub+i]= u[0];
  return true;
}

Vh ustart[nbT+1],uend[nbT]; // start 
VH Uend[nbT];
VH U0,U1;



real t=T0,T=T0; // temps courant
int it=0,iT=0; 
pt[it]=t;
pT[iT]=T;
initG(U0[]);
AddGp(U0[],iT);
H2h(U0[], ustart[iT][]);

//  initial 
for (int I=0;I<nbT;I++)
  {
    G(U1[],U0[]);
    U0[]=U1[];
    Uend[I][]=U1[];
    H2h(U0[],ustart[I+1][]);
    AddGp(U1[],I+1); 
  }
cout << pT.max << " " << pU.min << " " << pU.max << endl;


real[int] exact(nbt+1),fu(nbt+1);
{
Vh u0,u1; 
u0[]=ustart[0][];
for (int i=0;i<=nbt;i++)
 {
   pt[i]=T0+i*dt;
   exact[i]=cos(pt[i]);
   F(u1[],u0[]);
   u0[]=u1[];
   AddFp(u0[],0,i);
 }
}
fu=pu;
plot([pT,pU],[pt,exact],[pt,fu],wait=1);
// big loop 
for (int K=0;K< Nbig;K++)
{

//  para real loop --

for (int I=0;I<nbT;I++)
 {
    Vh u0,u1;
    u0[]=ustart[I][];
    AddFp(u0[],I,0);
    for (int i=0;i<ksub;i++)
     {
      F(u1[],u0[]);
      u0[]=u1[];
      AddFp(u0[],I,i+1);
     }
    uend[I][]=u0[];
 }

plot([pT,pU],[pt,pu],[pt,exact],cmm="iteration "+K);
 
// update loop  
ustart[K+1]=uend[K];
real err=0;
for (int I=K+1;I<nbT;I++)
 {
   // Attention  pb fin grossier 
   VH U0,U1;
   h2H(ustart[I][],U0[]);
   AddGp(U0[],I); 
   G(U1[],U0[]);
   AddGp(U1[],I+1); 
   U0[]=U1[];
   U1[] -=Uend[I][]; // U1=U1-U1(old)
   err += Norm(U1[]);
   Uend[I][]=U0[]; // save U1 
   Vh u1;
   H2h(U1[],u1[]);
   ustart[I+1][] = u1[]+ uend[I][] ;     
 }

 cout << "\n\n big iteration " <<  K << "  err= " << err << endl;
 if (err < tol) break;
//plot([pT,pU],wait=1,clean=0);

}
plot([pt,pu],[pt,exact],[pt,fu],wait=1,cmm=" final fin");
plot([pT,pU],[pt,exact],[pt,fu],wait=1,cmm=" final grossier");
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


cout << "--------- file : aadaptation.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aadaptation.edp";
	real TESTaadaptation=regvalue;
		cout<<"aadaptation reference value = "<<REFaadaptation
				<<" test value ="<<TESTaadaptation<<endl;
			assert(TESTaadaptation<REFaadaptation*(1+0.1));
				assert(TESTaadaptation>REFaadaptation*(1-0.1));
};
;
cout << "--------- file : aalapacien.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalapacien.edp";
	real TESTaalapacien=1+err;
		cout<<"aalapacien reference value = "<<REFaalapacien
				<<" test value ="<<TESTaalapacien<<endl;
			assert(TESTaalapacien<REFaalapacien*(1+0.00001));
				assert(TESTaalapacien>REFaalapacien*(1-0.00001));
};
;
cout << "--------- file : aalaplace-nc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalaplace-nc.edp";
	real TESTaalaplaceXnc=u[]'*u[];
		cout<<"aalaplace-nc reference value = "<<REFaalaplaceXnc
				<<" test value ="<<TESTaalaplaceXnc<<endl;
			assert(TESTaalaplaceXnc<REFaalaplaceXnc*(1+0.1));
				assert(TESTaalaplaceXnc>REFaalaplaceXnc*(1-0.1));
};
;
cout << "--------- file : aamove.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aamove.edp";
	real TESTaamove=u[]'*u[];
		cout<<"aamove reference value = "<<REFaamove
				<<" test value ="<<TESTaamove<<endl;
			assert(TESTaamove<REFaamove*(1+0.1));
				assert(TESTaamove>REFaamove*(1-0.1));
};
;
cout << "--------- file : aaRT.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aaRT.edp";
	real TESTaaRT=u1[]'*u1[];
		cout<<"aaRT reference value = "<<REFaaRT
				<<" test value ="<<TESTaaRT<<endl;
			assert(TESTaaRT<REFaaRT*(1+0.1));
				assert(TESTaaRT>REFaaRT*(1-0.1));
};
;
cout << "--------- file : arrayoFVh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "arrayoFVh.edp";
	real TESTarrayoFVh=u[]'*u[];
		cout<<"arrayoFVh reference value = "<<REFarrayoFVh
				<<" test value ="<<TESTarrayoFVh<<endl;
			assert(TESTarrayoFVh<REFarrayoFVh*(1+0.1));
				assert(TESTarrayoFVh>REFarrayoFVh*(1-0.1));
};
;
cout << "--------- file : bilap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "bilap.edp";
	real TESTbilap=xx(0:n)'*xx(0:n);
		cout<<"bilap reference value = "<<REFbilap
				<<" test value ="<<TESTbilap<<endl;
			assert(TESTbilap<REFbilap*(1+0.1));
				assert(TESTbilap>REFbilap*(1-0.1));
};
;
cout << "--------- file : D2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "D2.edp";
	real TESTD2=w[]'*w[];
		cout<<"D2 reference value = "<<REFD2
				<<" test value ="<<TESTD2<<endl;
			assert(TESTD2<REFD2+1e-20);
				assert(TESTD2>REFD2-1e-20);
};
;
cout << "--------- file : demo1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo1.edp";
	real TESTdemo1=u[]'*u[];
		cout<<"demo1 reference value = "<<REFdemo1
				<<" test value ="<<TESTdemo1<<endl;
			assert(TESTdemo1<REFdemo1*(1+0.1));
				assert(TESTdemo1>REFdemo1*(1-0.1));
};
;
cout << "--------- file : demo.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo.edp";
	real TESTdemo=u[]'*u[];
		cout<<"demo reference value = "<<REFdemo
				<<" test value ="<<TESTdemo<<endl;
			assert(TESTdemo<REFdemo*(1+0.1));
				assert(TESTdemo>REFdemo*(1-0.1));
};
;
cout << "--------- file : funct.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "funct.edp";
	real TESTfunct=myfunction(1.0,3.);
		cout<<"funct reference value = "<<REFfunct
				<<" test value ="<<TESTfunct<<endl;
			assert(TESTfunct<REFfunct*(1+0.1));
				assert(TESTfunct>REFfunct*(1-0.1));
};
;
cout << "--------- file : lapacienprecon.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lapacienprecon.edp";
	real TESTlapacienprecon=u[]'*u[];
		cout<<"lapacienprecon reference value = "<<REFlapacienprecon
				<<" test value ="<<TESTlapacienprecon<<endl;
			assert(TESTlapacienprecon<REFlapacienprecon*(1+0.1));
				assert(TESTlapacienprecon>REFlapacienprecon*(1-0.1));
};
;
cout << "--------- file : lap_mat.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lap_mat.edp";
	real TESTlapXmat=u1[]'*u1[];
		cout<<"lap_mat reference value = "<<REFlapXmat
				<<" test value ="<<TESTlapXmat<<endl;
			assert(TESTlapXmat<REFlapXmat*(1+0.1));
				assert(TESTlapXmat>REFlapXmat*(1-0.1));
};
;
cout << "--------- file : NSP1P1b.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1b.edp";
	real TESTNSP1P1b=int2d(Th)(square(u1)+square(u2));
		cout<<"NSP1P1b reference value = "<<REFNSP1P1b
				<<" test value ="<<TESTNSP1P1b<<endl;
			assert(TESTNSP1P1b<REFNSP1P1b*(1+0.2));
				assert(TESTNSP1P1b>REFNSP1P1b*(1-0.2));
};
;
cout << "--------- file : NSP1P1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1.edp";
	real TESTNSP1P1=int2d(Th)(square(u1)+square(u2));
		cout<<"NSP1P1 reference value = "<<REFNSP1P1
				<<" test value ="<<TESTNSP1P1<<endl;
			assert(TESTNSP1P1<REFNSP1P1*(1+10));
				assert(TESTNSP1P1>REFNSP1P1*(1-10));
};
;
cout << "--------- file : NSP1P2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P2.edp";
	real TESTNSP1P2=int2d(Th)(square(u1)+square(u2));
		cout<<"NSP1P2 reference value = "<<REFNSP1P2
				<<" test value ="<<TESTNSP1P2<<endl;
			assert(TESTNSP1P2<REFNSP1P2*(1+0.2));
				assert(TESTNSP1P2>REFNSP1P2*(1-0.2));
};
;
cout << "--------- file : parareal.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "parareal.edp";
	real TESTparareal=pu'*pu;
		cout<<"parareal reference value = "<<REFparareal
				<<" test value ="<<TESTparareal<<endl;
			assert(TESTparareal<REFparareal*(1+0.1));
				assert(TESTparareal>REFparareal*(1-0.1));
};
;

 cout << "--------- file : Richard.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "Richard.edp";
	real TESTRichard=hmax;
		cout<<"Richard reference value = "<<REFRichard
				<<" test value ="<<TESTRichard<<endl;
			assert(TESTRichard<REFRichard*(1+0.1));
				assert(TESTRichard>REFRichard*(1-0.1));
};
;

cout << "--------- file : teste.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "teste.edp";
	real TESTteste=P.x;
		cout<<"teste reference value = "<<REFteste
				<<" test value ="<<TESTteste<<endl;
			assert(TESTteste<REFteste*(1+0.1));
				assert(TESTteste>REFteste*(1-0.1));
};
;
cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};
;
cout << "--------- file : wafer-heating-laser-axi.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "wafer-heating-laser-axi.edp";
	real TESTwaferXheatingXlaserXaxi=xx'*xx;
		cout<<"wafer-heating-laser-axi reference value = "<<REFwaferXheatingXlaserXaxi
				<<" test value ="<<TESTwaferXheatingXlaserXaxi<<endl;
			assert(TESTwaferXheatingXlaserXaxi<REFwaferXheatingXlaserXaxi*(1+0.1));
				assert(TESTwaferXheatingXlaserXaxi>REFwaferXheatingXlaserXaxi*(1-0.1));
};
;
int n = 40;
mesh Th=square(n,n,[2*x-1,2*y-1]);
fespace Xh(Th,P2);
Xh x2=x^2,y2=y^2,xy=x*y;
Xh w,ww;

w=dxx(x2); cout << "dxx(x2) " << w[].max << " " << w[].min << endl;
w=dyy(y2); cout << "dyy(y2) " << w[].max << " " << w[].min << endl;
w=dyy(xy); cout << "dyy(xy) " << w[].max << " " << w[].min << endl;

w=dxy(xy); cout << "dxy(xy) " << w[].max << " " << w[].min << endl;
w=dyx(xy); cout << "dyx(xy) " << w[].max << " " << w[].min << endl;
w=dyx(x2); cout << "dyx(x2) " << w[].max << " " << w[].min << endl;
//  for regtest 
real regvalue=int2d(Th)(w*w);
// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(10,10);
fespace Vh2(Th,P2);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=1000;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
solve NS ([u1,u2,p],[v1,v2,q],solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.1;
int nbiter = 5;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.25^(1./nbiter);
nu=1./reylnods;   

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=50;i++)
   {
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
     cout << "CPU " << clock()-s0 << "s " << endl;     
   } 
 
  if (iter>= nbiter) break;
 
  Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],
              abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
// correct pressure sign 
// correct for LU solver a -1r6*p*q term  FH. mars/2018  Thank to armand.favrot@yahoo.fr
real s0=clock();
mesh Th=square(50,50);
fespace Vh2(Th,P1);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;
problem Pu1(u1x,vv,solver=CG) = int2d(Th)( u1x*vv) + int2d(Th)(-vv*u1);
problem Pu2(u2x,vv,solver=CG) = int2d(Th)( u2x*vv) + int2d(Th)(-vv*u2);

up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
solve NS ([u1,u2,p],[v1,v2,q],init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            - (dx(p)*dx(q)+dy(p)*dy(q))*(area/nu) // stabilization term (Change signe and value  jun 2020 FH.)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
            - 1e-6*p*q
			
           )
  + int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],value=1);

dt = 0.1;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.4;
real tol=0.05,coeftol = 0.5^(1./nbiter);
nu=0.01;   

for (iter=0;iter<nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=10;i++)
   { 
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps",value=1);  
     cout << "CPU " << clock()-s0 << "s " << " Th.nv " << Th.nv << endl;     
   } 
 
  if (iter>= nbiter) break;
 
  u1x=0;u1y=0;
  Pu1;Pu2;
  plot([u1x,u2x],wait=1);
  Th=adaptmesh(Th,[u1x,u2x],abserror=0,cutoff=cut,err=tol, inquire=0,nbvx=100000);
  u1=u1;
  u2=u2;
  p=p; 
  plot(Th);
  dt = dt*coefdt;
  if( Th.nv < 1000)
  {
  tol = tol *coeftol;
  cut = cut *coefcut;
  }
}
cout << "CPU " << clock()-s0 << "s " << endl;     
// Profiling script, adapted from
// examples/tutorial/NSUzawaCahouetChabart.edp
// (chosen for the large amount of graphics it displays)

// correct bug in CahuetChabard routine
// sign of pressure correct
// and change Bx, By in Bx' By' (back and forth) in  version>1.18
//  correction in CahouetChabard routine in version 1.26

assert(version>1.18); //  for big bug is non symetric matrix see HISTORY
real s0=clock();
mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;
real[int] pwork(p.n);

int i=0;
real one =1;
varf bx(u1,q) = int2d(Th,qforder=4)( dx(u1)*q );

varf by(u1,q) = int2d(Th,qforder=4)( dy(u1)*q );

varf a(u1,u2)= int2d(Th,qforder=4)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                   +  on(3,u1=1)  +  on(1,2,4,u1=0)  ;


varf vfMass(p,q) = int2d(Th)(p*q);
matrix MassMh=vfMass(Mh,Mh,solver=CG);
p[]=1;
ppp[]= MassMh*p[];
real aire = ppp[].sum;
cout << " area of Omega = " << aire << endl;
Xh bc1; bc1[] = a(0,Xh);
Xh b;

matrix A= a(Xh,Xh,solver=CG);
matrix Bx= bx(Xh,Mh); //  Mh corresponding to line and Xh to column
matrix By= by(Xh,Mh);
Xh bcx=(1-x)*x*4,bcy=0;
Xh b1=0,b2=0;  //  right hand side (0) for Stokes

func real[int] divup(real[int] & pp)
{
   pwork= MassMh*pp;
   cout << " pp moy = " << pwork.sum/aire << " " ;
   pp -= pwork.sum/aire;;
   b = b1; b[]  += Bx'*pp; b[] += bc1[] .*bcx[];
   u1[] = A^-1*b[];
   b = b2; b[]  += By'*pp; b[] += bc1[] .*bcy[];
   u2[] = A^-1*b[];
   ppp[]  =   Bx*u1[];
   ppp[] +=   By*u2[];
   pwork= MassMh*ppp[];
   cout << " moy = " << pwork.sum/aire << endl;
 //   ppp[] -=  pwork.sum/aire;
   return ppp[] ;
};


p=0;q=0;u1=0;v1=0;
//cout << " -------- A = " << A << endl;

LinearCG(divup,p[],q[],eps=1.e-6,nbiter=50);
divup(p[]);

plot([u1,u2],p,wait=0,value=true,coef=0.1);

real dt=0.05, alpha=1/dt;
if ( alpha > 1e30) exit(1);
real xnu=1./400.;
cout << " alpha = " << alpha << " nu = " << xnu << endl;
cout << "------------------------------------------ " << endl;
varf at(u1,u2)=   int2d(Th)( xnu*dx(u1)*dx(u2) + xnu*dy(u1)*dy(u2)  + u1*u2*alpha  )
               +  on(3,u1=1)  +  on(1,2,4,u1=0)  ;

A = at(Xh,Xh,solver=CG);
//cout << " -------- AA = " << AA << endl;

varf  vfconv1(uu,vv)  = int2d(Th,qforder=5) (convect([u1,u2],-dt,u1)*vv*alpha);
varf  vfconv2(v2,v1)  = int2d(Th,qforder=5) (convect([u1,u2],-dt,u2)*v1*alpha);
int idt;
real temps=0;

Mh pprec,prhs;

varf vfLap(p,q)  = int2d(Th)(dx(p)*dx(q) + dy(p)*dy(q) + p*q*1e-3);
matrix LapMh= vfLap(Mh,Mh,solver=Cholesky,factorize=true);

real[int] unMh(pprec.n);
pprec[]=1;
unMh = MassMh*pprec[];



func real[int]  CahouetChabart(real[int] & xx)
{   //  xx = \int (div u) w_i
   //   $ \alpha \Delta^{-1}  + \nu I $
   //   $ \alpha \LapMh ^{-1}  + \nu MassMh^-1 $
   real mxx= unMh'*xx;
   xx -= mxx*Th.area;
   pprec[]= LapMh^-1* xx;
   prhs[] =  MassMh^-1*xx;
   pprec[] = alpha*pprec[]+xnu* prhs[];
//   xx = LapMh*pprec[];
//   pprec[] -= xx.sum;
   return pprec[];
};

Xh up1,up2;
for (idt = 1; idt < 50; idt++)
 {
    up1=u1;
    up2=u2;
   temps += dt;
   cout << " --------- temps " << temps << " \n ";
   b1[] =  vfconv1(0,Xh);
   b2[] =  vfconv2(0,Xh);
   cout << "  min b1 b2  " << b1[].min << " " << b2[].min
        << "  max b1 b2  " << b1[].max << " " << b2[].max << endl;
   LinearCG(divup,p[],q[],eps=-1.e-6,nbiter=50,precon=CahouetChabart);
   divup(p[]);
   real errl2 = sqrt(int2d(Th)( (u1-up1)^2 + (u2-up2)^2 ) );
   cout << " errl2 " << errl2 << endl;
   plot([u1,u2],p,wait=0,value= 1,coef=0.1,cmm="[u1,u2],p || u^n+1 - u^n ]]_L2 ="+errl2);
   if (errl2 < 1e-4) break;
 }
//  -----  
real eps =  0.0001;
real h=1;
real hmin=0.05;
func f = 10.0*x*x*x+y*y*y+h*atan2(eps,sin(5.0*y)-2.0*x);

func fx = 30.0*x*x+h*2.0*eps/pow(sin(5.0*y)-2.0*x,2.0)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0));

func  fy =  3.0*y*y-h*5.0*eps/pow(sin(5.0*y)-2.0*x,2.0)*cos(5.0*y)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0));

func  fxy =  h*(-20.0*eps/pow(sin(5.0*y)-2.0*x,3.0)*cos(5.0*y)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0))
+20.0*eps*eps*eps/pow(sin(5.0*y)-2.0*x,5.0)*cos(5.0*y)/pow(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0),2.0));

func  fxx= 60.0*x+h*(8.0*eps/pow(sin(5.0*y)-2.0*x,3.0)/(1.0+eps*eps/pow(sin(5.0*y)
-2.0*x,2.0))-8.0*eps*eps*eps/pow(sin(5.0*y)-2.0*x,5.0)/pow(1.0+eps*eps/pow(sin(
5.0*y)-2.0*x,2.0),2.0));

func  d = fx*fy - fxy*fxy;
func  fyy= 6.0*y+h*(50.0*eps/pow(sin(5.0*y)-2.0*x,3.0)*pow(cos(5.0*y),2.0)/(1.0+
eps*eps/pow(sin(5.0*y)-2.0*x,2.0))+25.0*eps/pow(sin(5.0*y)-2.0*x,2.0)*sin(5.0*y
)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0))-50.0*eps*eps*eps/pow(sin(5.0*y)-2.0*x
,5.0)*pow(cos(5.0*y),2.0)/pow(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0),2.0));

border cercle(t=0,2*pi){ x=cos(t);y=sin(t);}
mesh Th=buildmesh(cercle(20));
fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P2);
Vh fh=f;
int i;
real coef=10;
for ( i=0;i<5;i++)
 {
 //  Th=adaptmesh(Th,f);
      verbosity=4;
      Th=adaptmesh(Th,fxx*coef,fxy*coef,fyy*coef,IsMetric=1,nbvx=10000,hmin=hmin);

   fh=f;
   Ph e=abs(fh-f);
   Vh dh=(d>0)*2-1;
   plot(Th,fh,dh,wait=1);
   plot(e,fill=1,value=1,wait=1);
   savemesh(Th,"Th"+i+".mesh");
   savemesh(Th,"Thh"+i,[x,y,fh/2]);
 {   ofstream file("Th"+i+".gbb");
   file << "2 1 1 "<< fh[].n << " 2 \n";
   int j;
   for (j=0;j<fh[].n ; j++)  {
     file << fh[][j] << endl; }
 }	
  if(!NoGraphicWindow)  exec("ffmedit `pwd`/Thh"+i);
 }
// Parameters
func f = 1;
func g = 0;

int nMeshAdapt = 5;	//Warning: higher value is time consuming and require `nbvx`>default value in `adaptmesh`

// Mesh
border aaa(t=0, 1){x=t; y=0; label=1;}
border bbb(t=0, 0.5){x=1; y=t; label=2;}
border ccc(t=0, 0.5){x=1-t; y=0.5; label=3;}
border ddd(t=0.5, 1){x=0.5; y=t; label=4;}
border eee(t=0.5, 1){x=1-t; y=1; label=5;}
border fff(t=0, 1){x=0; y=1-t; label=6;}
mesh Th = buildmesh(aaa(6) + bbb(4) + ccc(4) +ddd(4) + eee(4) + fff(6));
mesh Th2 = movemesh(Th,[x+1.1, y]);

// Fespace
fespace Vh(Th, P1);
Vh u, v, zero;

fespace Vh2(Th2, P2);
Vh2 u2, v2;

fespace Vh21(Th2, P1);
Vh21 dxu2, dyu2;

// Initialization
u = 0;
u2 = 0;
zero = 0;

// Problem
int i = 0;
problem Probem1(u, v, solver=CG, init=i, eps=-1.0e-6)
	= int2d(Th)(
		  dx(u)*dx(v)
		+ dy(u)*dy(v)
	) 
	+ int2d(Th)(
		  v*f
	)
	+ on(1, 2, 3, 4, 5, 6, u=g)
	;

problem Probem2(u2, v2, solver=CG, init=i, eps=-1.0e-6)
	= int2d(Th2)(
		  dx(u2)*dx(v2)
		+ dy(u2)*dy(v2)
	)
	+ int2d(Th2)(
		  v2*f
	)
	+ on(1, 2, 3, 4, 5, 6, u2=g)
	;

// Mesh adaptation loop
real cpu=clock();
real error = 0.1;
real coef = 0.1^(1./5.);
for (i = 0; i < 5; i++) { 
	cout << "Iteration " << i << endl;
	real d = clock();
	
	// Solve
	Probem1;
	Probem2;
	
	// Plot
	plot(Th, u, Th2, u2, wait=true);
	
	// Mesh adpatation
	Th = adaptmesh(Th, u, inquire=1, err=error);
	
	dxu2 = dx(u2);
	dyu2 = dy(u2);
	Th2 = adaptmesh(Th2, dxu2, dyu2, inquire=1, err=error, ratio=1.5, hmin=1e-5);

	cout << " CPU = " << clock()-d << endl;
	error = error * coef;
}

cout << " CPU = " << clock()-cpu << endl;

 // routine
func real myfunction(real a,real b)
{
   real z =a+b;
   return z;
};
{
real[int] matx(10),b(10),x(10); 
func real[int] mat(real[int] &x)
{ int i;
  for (i=0;i<x.n;i++)
    matx[i]=(i+1)*x[i];
  matx -= b; // sub the right hand side
  return matx;  // return of global variable ok 
};
func real[int] matId(real[int] &x) { return x;};
b=1; x=0; // set  right hand side and initial gest
LinearCG(mat,x,eps=1.e-6,nbiter=20,precon=matId);
cout << x;
  for (int i=0;i<x.n;i++)
    assert(abs(x[i]*(i+1) - b[i]) < 1e-5);
b=1; x=0; // set  right hand side and initial gest
NLCG(mat,x,eps=1.e-6,nbiter=20,precon=matId);
cout << x;
  for (int i=0;i<x.n;i++)
    assert(abs(x[i]*(i+1) - b[i]) < 1e-5);

};
 cout << myfunction(1.0,3.) << " " << myfunction(1,3)  << endl;
//   a array 
{
border a(t=0,1){x=t;y=0;};
border b(t=0,0.5){x=1;y=t;};
border c(t=0,0.5){x=1-t;y=0.5;};
border d(t=0.5,1){x=0.5;y=t;};
border e(t=0.5,1){x=1-t;y=1;};
border f(t=0,1){x=0;y=1-t;};
mesh th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
plot(th,wait=1,fill=1);

};
cout << (1==2) * 3. + (1==1)*4. << endl;

real [int] tab(10), tab1(10); // 2 array of 10 real 
//  real [int] tab2; //  bug 
tab = 1;  //  set all the array to 1
tab[1]=2;
cout << tab[1] << " " << tab[9] << " size of tab = " << tab.n << endl;
tab1=tab;
tab=tab+tab1;
tab=2*tab+tab1*5;
tab1=2*tab-tab1*5;
tab+=tab;
cout << tab << endl;
cout << tab[1] << " " << tab[9] <<  endl;
real [string] map; //  a dynamique array
cout << "-------------------------------------------------------------" << endl;
x=cos(0.1);
y=1.1;
z=2.1;
cout << z << " ==  " << P << endl;
{real z;
 func f=z+1;
z=1;
cout << " entre z=?" ;
//cin >> z;
cout << " z = " << z << " f=" << f << endl;};
{
mesh Th = square(5,5);
fespace Vh(Th); // P1
Vh uh;
uh=2*x+10*y; //  do P1 interpolation
x=0.5;
y=0.9;
real uhxy=uh; // get the value of uh at point (x,y)= 0.5,0.9
cout << "uh at (0.5,0.9) =" << uhxy << endl; 
};

{
  ofstream f("toto.txt");
  f << "coucou'\n";
};
{
  ofstream f("toto.txt",append);
  f << "add coucou'\n";
};


// no current mesh 

map["1"]=2.0;
map[2]=3.0; //  2 is automaticaly cast to the string "2"

cout << " map[\"1\"] = " << map["1"] << "; "<< endl;
cout << " map[2] = " << map[2] << "; "<< endl;
{
  real a,b,c;
  int i,j,k;  
};
string str,str1;
 str="abc+";
 str1="+abcddddd+";
 str=str + str1;
 str = str + 2 ;
cout << "str=  " << str << "== abc++abcddddd+2;\n";

real  x=3.14,y;
int  i,j;
complex c;

cout << " x = " << x << "\n";

x = 1;y=2;
x=y;

i=0;j=1;

cout << 1 + 3 << "\n";
cout << 10 ^10   << "\n";
cout << 10 ^-10   << "\n";
cout << -10^-2+5   << "== 4.99 \n";
cout << 10^-2+5    << "==  5.01 \n";
cout << "------------------ complex ---- \n" ;
cout << 10-10i   << " \n";
cout << " -1^(1/3) = " << (-1+0i)^(1./3.)   << " \n";
cout << " 8^(1/3)= " << (8)^(1./3.)   << " \n";
cout << " sqrt(-1) = " << sqrt(-1+0i) << " \n";

cout << " ++i =" <<  ++i ;
cout <<  " i=" << i << "\n";
cout << " i++ = "<< i++ << "\n";
cout << " i   = " << i << "\n";
cout << " for (i=0;i<10;i=i+1) \n";

for (int i=0;i<100;i=i+1)
  {
    if (i>=10) break;
    real a=i;
    tab[i] = i*i;
    if (i>5) continue;
    cout << i << " " << tab[i] << "\n";
  };
  
R3 P;
P.x=1;
x=P.x;
cout << P.x << "\n";  
verbosity=4;

mesh Th=square(10,10,[10*x,5*y]);
fespace Vh(Th,P1);

Vh u,v;

u=0;
func f= 0;
func g= 5*x+y;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
// exact solution  is g in this exemple : 
//  remark $dg/dn = -1$ on $Gamma_1$ (lower side)   $n=(0,-1)$ 
//  remark $dg/dn = 5$ on $Gamma_2$ (left side)   $n=(1,0)$ 
//  u + du/dn = g - 1 , because du
// $$ - \Delta u = 0,\quad  u_{|\Gamma_3 \cup \Gamma_4} = g, \frac{\partial u}{\partial n} + u = g-1 \mbox{on}\Gamma_4$$
problem Probem1(u,v,solver=LU,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int1d(Th,1) ( u*v )        //  $ \frac{\partial u}{\partial n} + u  = \ldots $
  + int1d(Th,1) ( (+1-g)*v)    //  $ \ldots  = g-1 $ 
  + int2d(Th) ( v*f )  
  + int1d(Th,2) (-5*v)  //  $ \frac{\partial u}{\partial n} = 5 $ 
  + on(3,4,u=g)  ;
  
real cpu=clock();
Probem1; // SOLVE THE PROBLEM 1
plot(u);
real err= sqrt( int2d(Th)( (u-g)^2) );
cout << "err L^2=" << err <<endl;
assert(err<1e-5); //  check the solution 
cout << " CPU = " << clock()-cpu << endl;
verbosity=1;
mesh Th=square(5,5);
fespace Vh(Th,P1);
Vh u,v;
real[int] X(9);  // array of 9 real
X=5; // fill X with 1
cout << "  norme^2 of X  " <<  sqrt(X' * X) <<  " == 15 \n";
Vh[int] uu(10);  // array of 10 solution 
/*  to do 
mesh[int] aTh(10); // array of 10 meshes 
aTh[1]= square(2,2);
*/ 
int i;
for ( i=0;i<10;i++)
 uu[i]=x+i*y; 

func f= 0;
func g= x*x+y*y*2;
u=0; 
// dcl the problem and solve
solve a(u,v,solver=CG) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(1,2,3,4,u=g+i); 

cout << "-------------------" << endl;  
plot(u);

// exemple de calcul de semi norme H_1
varf  lap(u,v)  = int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v) ); 
matrix A= lap(Vh,Vh);
cout <<  " (semi norme H^1)^2 of u =" << (v[]=A*u[])' * u[] << endl; 
cout <<  " (semi norme H^1)^2 of u =" << int2d(Th)(  dx(u)*dx(u) + dy(u)*dy(u) ) << endl; 

for ( i=0;i<10;i++)
 cout << "|x +"<< i <<"y|_H_1 = " << sqrt((v[]=A*uu[i][])' * uu[i][])  << endl;
// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(20,20);
  Th=adaptmesh(Th,1./20.,IsMetric=1,splitpbedge=1);
fespace Vh2(Th,P1b);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=400;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
solve NS ([u1,u2,p],[v1,v2,q],solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.05;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.5^(1./nbiter);
nu=1./reylnods;   

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=50;i++)
   {
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
     cout << "CPU " << clock()-s0 << "s " << endl;     
   } 
 
  if (iter>= nbiter) break;
   Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],splitpbedge=1,abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
 // routine
func int fi(real  a1)
{
   int i=a1*a1/1;
   return i;
}; 
func real myfunction(real a,real b)
{
   real aa=a;
   real z =fi(aa)+b;
   return z;
};
// appele 
cout << myfunction(1.0,3.) << " " << myfunction(1,3)  << endl;
// simulation of wafer heating by a laser.
/**************************************************************
From:  Fabian Dortu

Materials and Components Analysis group (MCA)
SPDT division

IMEC, Kapeldreef 75, B-3001 Leuven, Belgium
tel: +32/16 28 8774
e-mail: Fabian.Dortu@imec.be <mailto:Fabian.Dortu@imec.be> 
**************************************************************/
// The poisson equation (here the heat equation) is solved in cylindrical coordinates:
//   $ \Delta u = 1/r \partial_r(r \partial_r u) + \partial_{zz} u +  1/r^2 \partial_{\theta^2} u $
// so the variationnal formulation is after integer on the 3d cylinder 
// rotation invariant given $\partial_{\theta} u =0$
//  $ - \Delta u = f $
//  on the 1/2 plan $ \theta =0$ 
//  $ \int r ( \partial_r u \partial_r v + \partial_z u \partial_z v ) = \int r f v  - \int_{\Gamma} r \partial_n u v $  
//  the radial coordinate 'r' is called 'x'.
//  the depth coordinate 'z' is called 'y'.
// The wafer stuck is a rectangle with upper left corner at (0,0)
//  and lower right corner at (radius,-thickness)
// The laser beam it the surface from top to bottom at the center (0,0). 
// The units assumed for the distance is the micrometer (um)


//***********************
//*** User parameters ***
//***********************

real radius=1000;   // the wafer radius (um)
real thick=600;     // the wafer thickness (um)
real thC=1.5e-4;    // the thermal conductivity (W/K/um)
real beamr=2;     // the laser beam radius (in the sens of a gaussian)
real refl=0.55;     // reflection coefficient Air/Silicon
real Eg=1.12;       // Band gap of Silicon (eV)
real En=1.49;       // Energy of laser (eV) - must be greater than Eg.
real I0=1e-2;       // Laser beam intensity (W/um^2)
real alpha=0.2;     // absorption coefficient (um^-1)
func f=I0 * (1-refl) * (En-Eg)/En * alpha * exp(alpha*y) * exp(-x*x/beamr/beamr);
                    // the heat generation function: a laser beam of radius 'beamr'
                    // lateral shape is gaussian.
                    // in depth shape is decreasing exponential because of absorption.
real g=300;          // temperature at right and bottom surfaces (in Kelvin)

//********************************
//*** Geometry/Mesh definition ***
//********************************


//--- less basic mesh ---
border bottom1(t=0,radius/5) {x=t; y=-thick; label=1;}
border bottom2(t=radius/5,radius) {x=t; y=-thick; label=2;}
border right1(t=-thick,0) {x=radius; y=t; label=3;};  // 'right' actually means external surface
border top1(t=radius,radius/5*3) {x=t; y=0; label=4;};
border top2(t=radius/5*3,radius/5) {x=t; y=0; label=5;}
border top3(t=radius/5,0) {x=t; y=0; label=6;};
border left1(t=0,-thick/5) {x=0; y=t; label=7;}; // 'left' actually means center of cylinder
border left2(t=-thick/5,-thick) {x=0; y=t; label=8;}; // 'left' actually means center of cylinder
mesh Th = buildmesh ( bottom1(20) + bottom2(10) + right1(20) + top1(10) + top2(20) + top3(50) + left1(50) + left2(25) );

plot(Th,wait=1,fill=1,ps="wafer_mesh2.eps");
//savemesh(Th,"wafer_stuck.msh");


//**************************
//*** Problem definition ***
//**************************



fespace Vh(Th,P1);
Vh u,v,zero;

u=0;     // The temperature variable.
v=0;     // The weight function.
zero=0;  // used to set initial condition
int i=0; // variable used for mesh reconstruction
real error=0.1, coef=0.1^(1./5.);


//--- Variational Form ----
problem Problem1(u,v,solver=CG,init=i,eps=1.0e-8) =
int2d(Th) ( x*dx(u)*dx(v) + x*dy(u)*dy(v) )
  + int2d(Th) ( -v*x*f/thC )    // the source term = laser heating 
  + on( 1,2,3,u=g ) ;             // fixed temperature at bottom and right surface.



//*************
//*** Solve ***
//*************


real cpu=clock();

cout << "***USER*** " << "Begin solve/adapt iterations" << endl;

for (i=0;i<10;i++)
{
  cout << "***USER*** " << "Iteration number: " << i << endl;
  real d = clock();
  Problem1;
  plot(u,wait=1);
  Th=adaptmesh(Th,u,inquire=1,err=error);
  cout << " CPU = " << clock()-d << endl;

  error = error * coef;
  
} ;

plot(Th,wait=1,bb=[[0,0],[-10,-10]],nbiso=20,ps="adaptedmesh.eps"); // plot the last adapted mesh
plot(u,wait=1,bb=[[0,0],[-10,-10]],nbiso=20,ps="temperature.eps"); // plot the solution


//Plot a cut section at r=0
real[int] xx(10),yy(10);
for (i=0;i<10;i++)
{
  x=0.; y=i/10.; // this line is used by the next one 
  xx[i]=i;
  yy[i]=u; // value of u at point (0. , i/10.)
}

plot([xx,yy],ps="likegnu.eps",wait=true);


cout << " CPU = " << clock()-cpu << endl;
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
// build square $]-1,1[^2$
mesh Th2=square(2,2,[2*x-1,2*y-1]); 
mesh Th=square(100,100,[2*x-1,2*y-1]); 
fespace Wh(Th2,P0edge);
Wh w=0;

fespace Vh(Th,P1);

w[]=0;
w[][6]=1;
Vh u=w;

plot(u,Th2,wait=1);
   savemesh(Th,"mm",[x,y,u*.5]); //  save mm.points and mm.faces file for medit
   // build a mm.bb file 
	{ ofstream file("mm.bb"); 
	file << "2 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << u[][j] << endl; 
    }  
    // call ffmedit command 	
   if(!NoGraphicWindow) exec("ffmedit mm");
    // clean files
    exec("rm mm.bb mm.faces mm.points");
    


//  -----  
real eps =  0.0001;
real h=1;
real hmin=0.000005;
real val=50; 
real coef=50; // err = 1/100
int nbiter=10,firstplot=3;
func f = y*x*x+y*y*y+h*tanh(val*(sin(5.0*y)-2.0*x));
ofstream fff("err.dat");
cout << atanh(1) << endl;
func fx = .0*y*x-0.2E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val;
func fy =  x*x+3.0*y*y+0.5E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val*cos(0.5E1*y);

func  fxy =   2.0*(x*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)+10.0*h*val*val*cos(5.0*y)
		   *sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  fxx= 2.0*(y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-4.0*h*val*val
		*sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  d = fx*fy - fxy*fxy;
func  fyy=(6.0*y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-50.0*h*val*val*
	   pow(cos(5.0*y),2.0)*sinh(val*sin(5.0*y)-2.0*val*x)-25.0*h*val*sin(5.0*y)*cosh(val*
           sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);
           
border cercle(t=0,2*pi){ x=cos(t);y=sin(t);}
mesh Th=buildmesh(cercle(20));

fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P2);
Vh fh=f;
plot(fh,wait=0); //
real err;
for (int i=0;i<nbiter;i++)
{
  //  Th=adaptmesh(Th,f);
  verbosity=4;
  Vh fxxh=fxx, fxyh=fxy, fyyh = fyy;
  cout << " min max f_xx :  " <<  fxxh[].min << " " << fxxh[].max << endl;
  cout << " min max f_yy :  " <<  fyyh[].min << " " << fyyh[].max << endl;
  cout << " min max f_xy :  " <<  fxyh[].min << " " << fxyh[].max << endl;
  Th=adaptmesh(Th,f,err=0.1);
  fh=f;
  err=sqrt(int2d(Th)(square(fh-f)));
  fff  << i<< " " << err << " " << Th.nt << " " << Th.nv <<  endl;  
}
//  for regtest 
real regvalue=err;

mesh Th("torture.msh");
plot(Th,wait=1);
mesh Tb=square(200,40,[1-x*11,y]);
fespace Vb(Tb,P1);
fespace Pb(Tb,P0);
Vb b=chi(Th);
Pb xx=x, yy=y;
plot(b,wait=1);
searchMethod=1;
Vb bb= chi(Th);
bb[]-=b[];
assert( bb[].linfty==0); 	
{ include "funct.edp"; cout << " ---------- \n";  }
{ include "aamove.edp";  }
verbosity=4;
border a(t=0,1){x=t;y=0;label=1;};
border b(t=0,0.5){x=1;y=t;label=1;};
border c(t=0,0.5){x=1-t;y=0.5;label=1;};
border d(t=0.5,1){x=0.5;y=t;label=1;};
border e(t=0.5,1){x=1-t;y=1;label=1;};
border f(t=0,1){x=0;y=1-t;label=1;};
func uu= sin(y*pi)/10;
func vv= cos(x*pi)/10;

mesh Th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
Th=movemesh(Th,[x+uu,y+vv]);
plot(Th,wait=1,fill=1);
fespace Vh(Th,P2);

Vh u,v;

u=0;
func ff= 1;
func gg= 0;
int i=0;
problem Probem1(u,v,solver=LU,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*ff ) 
  + on(1,u=gg)  ;
  
real cpu=clock();
Probem1; // SOLVE THE PROBLEM 1
plot(u,wait=1);
cout << " CPU = " << clock()-cpu << endl;
border aaa(t=0,1){x=t;y=0;label=1;};
border bbb(t=0,0.5){x=1;y=t;label=2;};
border ccc(t=0,0.5){x=1-t;y=0.5;label=3;};
border ddd(t=0.5,1){x=0.5;y=t;label=4;};
border eee(t=0.5,1){x=1-t;y=1;label=5;};
border fff(t=0,1){x=0;y=1-t;label=6;};
mesh Th = buildmesh (aaa(6) + bbb(4) + ccc(4) +ddd(4) + eee(4) + fff(6));
// mesh Th2 = movemesh(Th,[x+1.1,y]);
fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace Vh2(Th,P2);
fespace Vh21(Th,P1);

Vh u,v,zero;
Vh2 u2,v2;
Vh21 dxu2,dyu2;
Ph eh;
u=0;
u2=0;
zero=0;
func f= 1;
func g= 0;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
problem Probem1(u,v,solver=CG,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(1,2,3,4,5,6,u=g)  ;
  
problem Probem2(u2,v2,solver=CG,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u2)*dx(v2) + dy(u2)*dy(v2)) 
  + int2d(Th) ( v2*f ) 
  + on(1,2,3,4,5,6,u2=g)  ;
  
real cpu=clock();

for (i=0;i< 10;i++)
{ 
  
  real d = clock();
  Probem1; 
  Probem2; 
  plot(Th,u,wait=1);
  eh= abs(u-u2);
  plot(Th,eh,fill=1,wait=1);
  
  Th=adaptmesh(Th,u,inquire=1,err=error,anisomax=1e6);
  
  cout << " CPU = " << clock()-d << endl;
  error = error * coef;
} ;

 cout << " CPU = " << clock()-cpu << endl;
load "Element_P1bl"
load "qf11to25"
// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(20,20);
  Th=adaptmesh(Th,1./20.,IsMetric=1,splitpbedge=1);
fespace Vh2(Th,P1bl);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=400;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
QF2 qf31 = tripleQF(qf1pT);
QF2 qf35 = tripleQF(qf5pT);
solve NS ([u1,u2,p],[v1,v2,q],init=i) =
    int2d(Th,qft=qf35)(
             alpha*( u1*v1 + u2*v2) )
    + int2d(Th,qft=qf31)(	     
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th,qft=qf35) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.05;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.5^(1./nbiter);
nu=1./reylnods;   

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=20;i++)
   {
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
     cout << "CPU " << clock()-s0 << "s " << endl;     
   } 
 
  if (iter>= nbiter) break;
   Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],splitpbedge=1,abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
real regtest;// for FFCS regression tests
// exact solution is [x*x,y]  -Delta [x*x,y] = [-2,0]
// This exemple is buggus before version 1.26
{ 
// test of product of same FE
  verbosity = 2;
 mesh Th=square(2,2);
 fespace Vh(Th,P2);
 
 Vh uHx=0;
 Vh uHy=0;
 Vh vHx;
 Vh vHy;
 
 solve  deuxlap([uHx,uHy],[vHx,vHy],solver=CG) =
    int2d(Th)(    dx(uHx)*dx(vHx) + dy(uHx)*dy(vHx)
               +  dx(uHy)*dx(vHy) + dy(uHy)*dy(vHy)  )
    - int2d(Th)( -2* vHx )        
    +  on(1,2,3,4,uHx=x*x,uHy=y);
   // plot(uHx, uHy,wait=1);
    real err2= sqrt( int2d(Th)(square(uHx-x*x)+square(uHy-y)));
    cout << " Error in L2 norme " << err2 << endl ;
    assert(err2 < 1e-10);
}

{ 
// test of product of different  FE
verbosity = 2;
 mesh Th=square(2,2);
 fespace Vh(Th,P2);
 fespace Vh1(Th,P1);
 
 Vh uHx=0;
 Vh1 uHy=0;
 Vh vHx;
 Vh1 vHy;
 
 solve  deuxlap([uHx,uHy],[vHx,vHy],solver=CG) =
    int2d(Th)(    dx(uHx)*dx(vHx) + dy(uHx)*dy(vHx)
               +  dx(uHy)*dx(vHy) + dy(uHy)*dy(vHy)  )
    - int2d(Th)( -2* vHx )        
    +  on(1,2,3,4,uHx=x*x,uHy=y);
   // plot(uHx, uHy,wait=1);
    real err2= sqrt( int2d(Th)(square(uHx-x*x)+square(uHy-y)));
    cout << " Error in L2 norme " << err2 << endl ;
    assert(err2 < 1e-10);
    regtest=err2;
}
//  -----  
real eps =  0.0001;
real h=1;
real hmin=0.000005;
real val=10; 
real coef=50; // err = 1/100
int nbiter=6,firstplot=3;
func f = y*x*x+y*y*y+h*tanh(val*(sin(5.0*y)-2.0*x));

cout << atanh(1) << endl;
func fx = .0*y*x-0.2E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val;
func fy =  x*x+3.0*y*y+0.5E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val*cos(0.5E1*y);

func  fxy =   2.0*(x*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)+10.0*h*val*val*cos(5.0*y)
		   *sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  fxx= 2.0*(y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-4.0*h*val*val
		*sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  d = fx*fy - fxy*fxy;
func  fyy=(6.0*y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-50.0*h*val*val*
	   pow(cos(5.0*y),2.0)*sinh(val*sin(5.0*y)-2.0*val*x)-25.0*h*val*sin(5.0*y)*cosh(val*
           sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);
           
border cercle(t=0,2*pi){ x=cos(t);y=sin(t);}
mesh Th=buildmesh(cercle(20));

fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P2);
Vh fh=f;
plot(fh,wait=0); //

for (int i=0;i<nbiter;i++)
{
  //  Th=adaptmesh(Th,f);
  verbosity=4;
  Vh fxxh=fxx, fxyh=fxy, fyyh = fyy;
  cout << " min max f_xx :  " <<  fxxh[].min << " " << fxxh[].max << endl;
  cout << " min max f_yy :  " <<  fyyh[].min << " " << fyyh[].max << endl;
  cout << " min max f_xy :  " <<  fxyh[].min << " " << fxyh[].max << endl;
  Th=adaptmesh(Th,fxx*coef,fxy*coef,fyy*coef,IsMetric=1,nbvx=10000,hmin=hmin,ratio  = 5, 
	       nbsmooth = 0, omega = 1);
  fh=f;
  Ph e=log10(abs(fh-f));
  Vh dh=(d>0)*2-1;
  plot(Th,fh,dh);
  real[int] vviso(20);
  for (int i=0;i<20;i++)
    vviso[i]=(-20+i)/2.;
  cout << " min max fh " << fh[].min << " " << fh[].max << endl;  
  cout << " min max log(e) " << e[].min << " " << e[].max << endl;  

  if (i>=firstplot) 
    {
      plot(e,fill=1,value=1,wait=0,viso=vviso,cmm="log10(e) err="+1./coef);
      savemesh(Th,"Thh"+i+".mesh");
      savemesh(Th,"Th"+i,[x,y,fh/2]);
      { 
        Vh eh=e;
	ofstream file("Th"+i+".BB");
	file << "2 1 1 "<< fh[].n << " 2 \n";
	int j;
	for (j=0;j<fh[].n ; j++)  {
	  file << eh[][j] << endl; }
      }	
     if(!NoGraphicWindow) exec("ffmedit `pwd`/Th"+i);
    }
}
int n=100,nn=n+10;
real[int] xx(nn),yy(nn);

mesh Th=square(40,40);  // mesh definition of $\Omega$
fespace Vh(Th,P1);      // finite element space
macro laplacien(u,v) (dx(u)*dx(v)+dy(u)*dy(v)) // fin macro 
real f=1;
Vh u,uu,v,vv;

solve bilap([u,uu],[v,vv],solver=sparsesolver,eps=1.0e-6) =
    int2d(Th)(  laplacien(u,vv)+uu*vv //  - Delta u + uu =0 (vv)
    	         + laplacien(uu,v)  )     //  - Delta uu = 1 (v)
    	        
   - int2d(Th)(f*v)
   + on(1,2,3,4,u=0); // => v=0 also on 1,2,3,4
   
plot(u,wait=1);

for (int i=0;i<=n;i++)
 {
   xx[i]=real(i)/n;
   yy[i]=u(0.5,real(i)/n); // value of uh at point (0.5, i/10.) 
 }
 plot([xx(0:n),yy(0:n)],wait=1);

mesh Th=square(10,10);
fespace Vh(Th,P1nc);
Vh u,v;
u=0;
plot(u);
func f= 0;
func g= x*x+y*y*2;
u=0; 
int i=0;
// dcl the problem 
problem a(u,v,solver=CG,init=i) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(1,2,3,4,u=g+i); 
cout << "-------------------" << i << endl;  
i++;
a; //  solve  the problem 
cout << "-------------------" << endl;  
plot(u);
verbosity=4;

mesh Th=square(10,10,[10*x,5*y]);
fespace Vh(Th,RT0);
fespace Rh(Th,RT0Ortho);
fespace Ph(Th,P0);

Vh [u1,u2],[v1,v2];
Rh [r1,r2];
Ph p,q; 
cout << 1. / 2. << endl;
[u1,u2]= [1+x,2+y];
[r1,r2]= [-2-y,1+x];
//  verification of the finite function 
cout << "   [u1,u2]  = ["<< u1(1,2) << "," << u2(1,2) << "]  == [2,4] \n";
cout << "dx([u1,u2]) = ["<< dx(u1)(1,2) << "," << dx(u2)(1,2) << "]  == [1,0] \n";
cout << "dy([u1,u2]) = ["<< dy(u1)(1,2) << "," << dy(u2)(1,2) << "]  == [0,1] \n";
//  verification of the finite function 
cout << "   [r1,r2]  = ["<< r1(1,2) << "," << r2(1,2) << "]  == [-4,2] \n";
cout << "dx([r1,r2]) = ["<< dx(r1)(1,2) << "," << dx(r2)(1,2) << "]  == [0,1] \n";
cout << "dy([r1,r2]) = ["<< dy(r1)(1,2) << "," << dy(r2)(1,2) << "]  == [-1,0] \n";
 
plot(u1,u2,[u1,u2],wait=1);
plot(r1,r2,[r1,r2],wait=1);

problem Probem1(u1,u2,v1,v2,solver=LU,eps=-1.0e-6) =
    int2d(Th)(  u1*v1+u2*v2 + dx(u1)*v1+ u2*dx(v2)) 
  + int2d(Th) ( x*v1+y*v2 + v1 + y*dx(v2) ) 
  
  + on(1,2,3,4,u1=-x,u2=-y)  ;

problem Probem2(p,q,solver=LU,eps=-1.0e-6) =
    int2d(Th)(  p*q ) + int2d(Th) ( q ) 
  ;

cout << " probem 1 \n";
Probem1; // solve problem1
cout << " probem 2 \n";
Probem2; // solve problem2

plot(u1,u2,[u1,u2]);

problem lap(u1,u2,p,v1,v2,q,solver=LU,eps=1.0e-30) =
    int2d(Th)( p*q*1e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
    + int2d(Th) ( q)
   + int1d(Th)( (v1*N.x +v2*N.y)/-2);

cout << " lap RT \n";
    
lap;

plot([u1,u2],wait=1); 
   
plot(p,fill=1,wait=1);    
    
cout << " int2d(Th)(p-0.5) " << int2d(Th)(p-0.5) << "  == 0 " << endl;

cout << " int2d(Th)(x+y) " << int2d(Th)(x+y) << " ==  " << (10*5)*(10+5)/2 <<  endl;
cout << " -------------\n\n " << endl;
macro ffddmbuildZTAZ(prT,pr,Varf)

if (pr#prfe#prmesh#isincomm)
{
pr#prfe#prmesh#tic(pr#tloc)

if (!bpara) {
  assert (Stringification(prT) == Stringification(pr)); /* TODO */
  pr#ncoarsespace=pr#si;
  if (mpiRank(pr#prfe#prmesh#mpicomm) == 0)
    cout << "["+Stringification(pr)+"] CS size = " << pr#ncoarsespace << endl;
  pr#sizelg = sizel;	/* sizelg stores the number of ev for every subdomain */
}
else {
  pr#ncoarsespace = 0; /* coarse space dimension */
  mpiAllReduce(pr#si,pr#ncoarsespace,pr#prfe#prmesh#mpicomm,mpiSUM);
}

if (pr#ncoarsespace > 0)
if (!bpara) {
  pr#prfe#K[int,int] Zm(pr#prfe#Ndofglobal,pr#ncoarsespace);
  int cpt = 0;
  /* the 2 fors loop over the columns of Z subdomainwise */
  for (int jj=0; jj<pr#prfe#prmesh#npart; jj++)
  for (int ii=0; ii < pr#sizelg[jj]; ii++) {
  	pr#prfe#K[int] tmp(pr#prfe#Rih[jj].m); /*tmp(pr#prfe#Rih[jj].m);
    */ tmp = pr#prfe#Rih[jj]'*pr#Z[cpt];
    Zm(:,cpt) = tmp;
    cpt++; /* keeps track of the global numbering of the columns of Z */
  }
  matrix<pr#prfe#K> Zms = Zm;
  matrix<pr#prfe#K> tmp = pr#Aglobal*Zms;
  pr#E = Zms'*tmp;
  set(pr#E,solver=sparsesolver,sym=vsym,commworld=pr#prfe#prmesh#commself,factorize=3);
}
else {
  /* Assemble E on proc 0
     see PhD thesis of P.Jolivet pag 46 and following */
  	
  pr#sizelg = 0;
  mpiAllReduce(sizel,pr#sizelg,pr#prfe#prmesh#mpicomm,mpiSUM); /* sizelg stores the number of ev for every subdomain */
    
  pr#offseti = 0; /* offseti[i]: index of the first ev of the subdomain i in the global numbering of the columns of Z */
  for (int ii=0; ii < pr#prfe#prmesh#npart; ii++)
    pr#offseti[ii] = (ii == 0 ? 0 : pr#offseti[ii-1] + pr#sizelg[ii-1]);

  if (!pr#prfe#prmesh#exclude) {
    pr#sizelgworld = pr#sizelg;
    pr#offsetiworld = pr#offseti;
  }
  else {
    for (int i = 0; i < mpiSize(pr#prfe#prmesh#mpicomm); i++) {
      if (i < pr#prfe#prmesh#pCS) {
        pr#sizelgworld[i] = 0;
        pr#offsetiworld[i] = 0;
      }
      else {
        pr#sizelgworld[i] = pr#sizelg[i-pr#prfe#prmesh#pCS];
        pr#offsetiworld[i] = pr#offseti[i-pr#prfe#prmesh#pCS];	
      }	
    }	
  }
  
  /* PRT */
  prT#ncoarsespace = 0; /* coarse space dimension */
  mpiAllReduce(prT#si,prT#ncoarsespace,prT#prfe#prmesh#mpicomm,mpiSUM);
  if (mpiRank(prT#prfe#prmesh#mpicomm) == 0)
    cout << "["+Stringification(pr)+"] CS size = " << pr#ncoarsespace << " x " << prT#ncoarsespace << endl;

  /* Assemble E on proc 0
     see PhD thesis of P.Jolivet pag 46 and following */

  if (Stringification(prT) == Stringification(pr))
    sizelT = sizel;
  prT#sizelg = 0;
  mpiAllReduce(sizelT,prT#sizelg,prT#prfe#prmesh#mpicomm,mpiSUM); /* sizelg stores the number of ev for every subdomain */

  prT#offseti = 0; /* offseti[i]: index of the first ev of the subdomain i in the global numbering of the columns of Z */
  for (int ii=0; ii < prT#prfe#prmesh#npart; ii++)
    prT#offseti[ii] = (ii == 0 ? 0 : prT#offseti[ii-1] + prT#sizelg[ii-1]);

  if (!prT#prfe#prmesh#exclude) {
    prT#sizelgworld = prT#sizelg;
    prT#offsetiworld = prT#offseti;
  }
  else {
    for (int i = 0; i < mpiSize(prT#prfe#prmesh#mpicomm); i++) {
      if (i < prT#prfe#prmesh#pCS) {
        prT#sizelgworld[i] = 0;
        prT#offsetiworld[i] = 0;
      }
      else {
        prT#sizelgworld[i] = prT#sizelg[i-prT#prfe#prmesh#pCS];
        prT#offsetiworld[i] = prT#offseti[i-prT#prfe#prmesh#pCS];
      }
    }
  }

  pr#prfe#K[int,int] AiZmi(1,1); /* A_i Z_i */
  
  IFMACRO(pr#localmacrominoverlap,1)
  ffddmsetupOperator(localprAug, pr#prfe#Aug, Varf)
  ;
  ENDIFMACRO

  if (!pr#prfe#prmesh#excluded)
    AiZmi.resize(pr#prfegeneo#Dk[mpiRank(pr#prfegeneo#prmesh#commddm)].n,pr#si);
  
  for (int ii=0; ii < pr#si; ii++) {
    IFMACRO(pr#localmacrominoverlap,1)
    pr#prfe#K[int] tmp2 = pr#prfegeneo#interp'*pr#Z[ii];
    pr#prfe#K[int] tmp = localprAug#aRd[mpiRank(pr#prfegeneo#prmesh#commddm)]*tmp2;
    ENDIFMACRO
    IFMACRO(pr#localmacrominoverlap,0)

    IFMACRO(pr#geneofullpattern)
    pr#prfe#K[int] tmp = pr#geneofullpatternOP(pr#Z[ii],1);
    ENDIFMACRO
    IFMACRO(!pr#geneofullpattern)
    pr#prfe#K[int] tmp = pr#aRd[mpiRank(pr#prfe#prmesh#commddm)]*pr#Z[ii];
    ENDIFMACRO

    ENDIFMACRO
    AiZmi(:,ii) = tmp;
  }

  /* step 3 of P.Jolivet thesis (page 47) */
  pr#prfe#K[int,int][int] mrcv(pr#prfegeneo#prmesh#numberIntersection);
  pr#prfe#K[int,int][int] msnd(pr#prfegeneo#prmesh#numberIntersection);

  pr#prfe#K[int,int] Eii(prT#si,pr#si);
  pr#prfe#K[int,int][int] Eij(pr#prfegeneo#prmesh#numberIntersection);

  if (!pr#prfe#prmesh#excluded) {  
	  mpiRequest[int] rq(pr#prfegeneo#prmesh#numberIntersection*2);
	  for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {
	  	msnd[j].resize(pr#prfegeneo#restrictionIntersection[j].n,pr#si);
	  	mrcv[j].resize(pr#prfegeneo#restrictionIntersection[j].n,pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]);
	  	for (int ii=0; ii<pr#si; ii++) {
	      pr#prfe#K[int] tmp = pr#prfegeneo#restrictionIntersection[j]*AiZmi(:,ii);
	      msnd[j](:,ii) = tmp;
	  	}
	  }
	  for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j)
	    Isend(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rq[j*2]),msnd[j]);
	  for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j)
	    Irecv(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rq[j*2+1]),mrcv[j]);
	  for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection*2;++j)
	    int k = mpiWaitAny(rq);

	  /* step 4 of P.Jolivet thesis (page 47) */
	  for (int ii=0; ii < prT#si; ii++)
	  for (int jj=0; jj < pr#si; jj++) {
	    IFMACRO(pr#localmacrominoverlap,1)
	    pr#prfe#K[int] tmp = pr#prfegeneo#interp*AiZmi(:,jj);
	    Eii(ii,jj) = pr#Z[ii]'*tmp;
	    ENDIFMACRO
	    IFMACRO(pr#localmacrominoverlap,0)
	    Eii(ii,jj) = prT#Z[ii]'*AiZmi(:,jj);
	    ENDIFMACRO
	  }
	  
	  /* step 5 of P.Jolivet thesis (page 47) */
	  for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {
	    Eij[j].resize(prT#si,pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]);
	    for (int jj=0; jj < pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]; jj++) {
        IFMACRO(pr#localmacrominoverlap,1)
        pr#prfe#K[int] tmp2(pr#prfegeneo#restrictionIntersection[j].m);
        tmp2 = pr#prfegeneo#restrictionIntersection[j]'*mrcv[j](:,jj);
        pr#prfe#K[int] tmp = pr#prfegeneo#interp*tmp2;
        ENDIFMACRO
        IFMACRO(pr#localmacrominoverlap,0)
        pr#prfe#K[int] tmp(pr#prfegeneo#restrictionIntersection[j].m);
        tmp = pr#prfegeneo#restrictionIntersection[j]'*mrcv[j](:,jj);
        ENDIFMACRO
        for (int ii=0; ii < prT#si; ii++){
          Eij[j](ii,jj) = prT#Z[ii]'*tmp;
        }
      }
    }
  }

  IFMACRO(pr#geneofullpattern)
  pr#prfe#K[int,int][int] Zj(pr#prfegeneo#prmesh#numberIntersection);
  int[int] tabarrayIntersectionflat(1);
  pr#prfe#K[int,int][int] Ekj(1);

  /* on recupere les Zj */
  if (!pr#prfe#prmesh#excluded) {
    mpiRequest[int] rq(pr#prfegeneo#prmesh#numberIntersection*2);
    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {
      msnd[j].resize(pr#prfegeneo#restrictionIntersection[j].n,pr#si);
      mrcv[j].resize(pr#prfegeneo#restrictionIntersection[j].n,pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]);
      for (int ii=0; ii<pr#si; ii++) {
        pr#prfe#K[int] tmp = pr#prfegeneo#restrictionIntersection[j]*pr#Z[ii];
        msnd[j](:,ii) = tmp;
      }
    }
    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j)
      Isend(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rq[j*2]),msnd[j]);
    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j)
      Irecv(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rq[j*2+1]),mrcv[j]);
    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);

    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {
      Zj[j].resize(pr#prfegeneo#restrictionIntersection[j].n,pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]);
      for (int jj=0; jj < pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]; jj++) {
        Zj[j](:,jj) = mrcv[j](:,jj);
      }
    }

    /* on envoie aux voisins sa liste des voisins */
    int[int] tabnumberIntersection(pr#prfegeneo#prmesh#numberIntersection);
    int[int][int] tabarrayIntersection(pr#prfegeneo#prmesh#numberIntersection);
    for (int i=0;i<pr#prfegeneo#prmesh#numberIntersection; i++)
      tabarrayIntersection[i].resize(1000);

    mpiRequest[int] rqt(4*pr#prfegeneo#prmesh#numberIntersection);
    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {
      Isend(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rqt[4*j]),pr#prfegeneo#prmesh#numberIntersection);
      Isend(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rqt[4*j+1]),pr#prfegeneo#prmesh#arrayIntersection);
    }
    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {
      Irecv(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rqt[4*j+2]),tabnumberIntersection[j]);
      Irecv(processor(pr#prfegeneo#prmesh#arrayIntersection[j],pr#prfegeneo#prmesh#commddm,rqt[4*j+3]),tabarrayIntersection[j]);
    }
    for(int j=0;j<4*pr#prfegeneo#prmesh#numberIntersection;++j)
      int k = mpiWaitAny(rqt);

    int tabarrayIntersectionsum = 0;
    int[int] tablgsum(pr#prfegeneo#prmesh#numberIntersection);
    int[int][int] taboffset(pr#prfegeneo#prmesh#numberIntersection);
    int mylgsum = 0;
    int[int] myoffset(pr#prfegeneo#prmesh#numberIntersection);
    for (int j=0; j<pr#prfegeneo#prmesh#numberIntersection; j++) {
      tabarrayIntersection[j].resize(tabnumberIntersection[j]);
      tabarrayIntersectionsum += tabarrayIntersection[j].n;
      mylgsum += pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]];
      myoffset[j] = (j == 0 ? 0 : myoffset[j-1] + pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j-1]]);
      taboffset[j].resize(tabarrayIntersection[j].n);
      for (int i=0; i<tabarrayIntersection[j].n; i++) {
        tablgsum[j] += pr#sizelg[tabarrayIntersection[j][i]];
        taboffset[j][i] = (i == 0 ? 0 : taboffset[j][i-1] + pr#sizelg[tabarrayIntersection[j][i-1]]);
      }
    }

    /* on calcule Si Zj et on envoie aux k */
    mpiRequest[int] rq2(pr#prfegeneo#prmesh#numberIntersection*2);

    for(int k=0;k<pr#prfegeneo#prmesh#numberIntersection;++k) {
      msnd[k].resize(pr#prfegeneo#restrictionIntersection[k].n, mylgsum);
      mrcv[k].resize(pr#prfegeneo#restrictionIntersection[k].n, tablgsum[k]);
    }

    for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j) {

      for (int jj=0; jj<pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]; jj++) {
        pr#prfe#K[int] tmp(pr#prfegeneo#restrictionIntersection[j].m);
        tmp = pr#prfegeneo#restrictionIntersection[j]'*Zj[j](:,jj);

        pr#prfe#K[int] tmp2 = pr#geneofullpatternOP(tmp,1);

        /* k == i */
        for (int kk=0; kk < prT#si; kk++){
          Eij[j](kk,jj) += prT#Z[kk]'*tmp2;
        }

        for(int k=0;k<pr#prfegeneo#prmesh#numberIntersection;++k) {
          msnd[k](:,myoffset[j]+jj) = pr#prfegeneo#restrictionIntersection[k]*tmp2;
        }
      }
    }

    for(int k=0;k<pr#prfegeneo#prmesh#numberIntersection;++k)
      Isend(processor(pr#prfegeneo#prmesh#arrayIntersection[k],pr#prfegeneo#prmesh#commddm,rq2[2*k]),msnd[k]);

    for(int k=0;k<pr#prfegeneo#prmesh#numberIntersection;++k)
      Irecv(processor(pr#prfegeneo#prmesh#arrayIntersection[k],pr#prfegeneo#prmesh#commddm,rq2[2*k+1]),mrcv[k]);

    for(int j=0;j<2*pr#prfegeneo#prmesh#numberIntersection;++j)
      int k = mpiWaitAny(rq2);

    /* on calcule Zk Si Zj */
    int[int] tabtmp(tabarrayIntersectionsum);

    int cpt = 0;
    for(int i=0;i<pr#prfegeneo#prmesh#numberIntersection;++i)
    for (int j=0; j<tabarrayIntersection[i].n; j++)
      tabtmp[cpt++] = tabarrayIntersection[i][j];
    Unique(tabtmp,tabarrayIntersectionflat);

    Ekj.resize(mpiSize(pr#prfegeneo#prmesh#commddm));

    cpt = 0;
    for(int i=0;i<pr#prfegeneo#prmesh#numberIntersection;++i) {
      pr#prfe#K[int] tmp(pr#prfegeneo#restrictionIntersection[i].m);
      for (int j=0; j<tabarrayIntersection[i].n; j++) {
        if (Ekj[tabarrayIntersection[i][j]].n != prT#si) {
          Ekj[tabarrayIntersection[i][j]].resize(prT#si,pr#sizelg[tabarrayIntersection[i][j]]);
          Ekj[tabarrayIntersection[i][j]] = 0;
        }
        for (int jj=0; jj<pr#sizelg[tabarrayIntersection[i][j]]; jj++) {
          tmp = pr#prfegeneo#restrictionIntersection[i]'*mrcv[i](:,taboffset[i][j]+jj);

          for (int kk=0; kk < prT#si; kk++){
            Ekj[tabarrayIntersection[i][j]](kk,jj) += prT#Z[kk]'*tmp;
          }
        }
        cpt++;
      }
    }
  }
  ENDIFMACRO

  IFMACRO(!pr#geneofullpattern)
  int fullnumberIntersection = pr#prfegeneo#prmesh#numberIntersection;
  int[int] fullarrayIntersection = pr#prfegeneo#prmesh#arrayIntersection;
  ENDIFMACRO
  IFMACRO(pr#geneofullpattern)
  int fullnumberIntersection = pr#prfegeneo#prmesh#numberIntersection + tabarrayIntersectionflat.n;
  int[int] fullarrayIntersection = [pr#prfegeneo#prmesh#arrayIntersection,tabarrayIntersectionflat];
  ENDIFMACRO

  if(!pr#prfe#prmesh#binexactCS) {
  
  /* send Eij to processor p in commCS which assembles them inside E */

  int locnpart = pr#prfe#prmesh#npart/pr#prfe#prmesh#pCS;
  locnpart += pr#prfe#prmesh#npart-locnpart*pr#prfe#prmesh#pCS > mpiRank(pr#prfe#prmesh#mpicomm);

  func int rkrdd(int i) {return i*pr#prfe#prmesh#pCS+mpiRank(pr#prfe#prmesh#mpicomm);};
  func int rkr(int i) {return pr#prfe#prmesh#exclude*pr#prfe#prmesh#pCS+rkrdd(i);};

  func int rks(int i) {return i%pr#prfe#prmesh#pCS;};

  int[int] tabnumberIntersection(locnpart);
  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS) {
    mpiRequest[int] rqt(locnpart-(!pr#prfe#prmesh#excluded));
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      Irecv(processor(rkr(i),pr#prfe#prmesh#mpicomm,rqt[i-!pr#prfe#prmesh#excluded]),tabnumberIntersection[i]);
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      int k = mpiWaitAny(rqt);
  }
  else if (!pr#prfe#prmesh#excluded) {
    mpiRequest rqt;
    Isend(processor(rks(mpiRank(pr#prfe#prmesh#mpicomm)),pr#prfe#prmesh#mpicomm,rqt),fullnumberIntersection);
    mpiWait(rqt);
  }

  int[int][int] tabarrayIntersection(locnpart); /* i: global numbering of neighbouring subdomains of proc i */

  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS) {
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      tabarrayIntersection[i].resize(tabnumberIntersection[i]);
    mpiRequest[int] rqt(locnpart-(!pr#prfe#prmesh#excluded));
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      Irecv(processor(rkr(i),pr#prfe#prmesh#mpicomm,rqt[i-!pr#prfe#prmesh#excluded]),tabarrayIntersection[i]);
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      int k = mpiWaitAny(rqt);
  }
  else if (!pr#prfe#prmesh#excluded) {
    mpiRequest rqt;
    Isend(processor(rks(mpiRank(pr#prfe#prmesh#mpicomm)),pr#prfe#prmesh#mpicomm,rqt),fullarrayIntersection);
    mpiWait(rqt);
  }

  int nbij = 0;
  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS)
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      nbij += tabnumberIntersection[i];
  
  pr#prfe#K[int,int][int] tabEij(nbij); /* big vector of full matrices for the blocks Eij */
  pr#prfe#K[int,int][int] tabEii(locnpart); /* big vector of full matrices for the blocks Eii */
  
  /* commCS procs resize tabEii and receive Eii blocks */
  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS) {
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      tabEii[i].resize(prT#sizelg[rkrdd(i)],pr#sizelg[rkrdd(i)]);
    mpiRequest[int] rqt(locnpart-(!pr#prfe#prmesh#excluded));
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      Irecv(processor(rkr(i),pr#prfe#prmesh#mpicomm,rqt[i-!pr#prfe#prmesh#excluded]),tabEii[i]);
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
      int k = mpiWaitAny(rqt);
  }
  else if (!pr#prfe#prmesh#excluded) {
    mpiRequest rqt;
    Isend(processor(rks(mpiRank(pr#prfe#prmesh#mpicomm)),pr#prfe#prmesh#mpicomm,rqt),Eii);
    mpiWait(rqt);
  }

  /* commCS procs resize tabEij and receive Eij blocks */
  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS) {
  	int cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
    for (int j=0; j < tabnumberIntersection[i]; j++) {
      tabEij[cpt].resize(prT#sizelg[rkrdd(i)],pr#sizelg[tabarrayIntersection[i][j]]);
      cpt++;   
    }
	mpiRequest[int] rqt(nbij);
	cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++)
    for (int j=0; j < tabnumberIntersection[i]; j++) {
      Irecv(processor(rkr(i),pr#prfe#prmesh#mpicomm,rqt[cpt]),tabEij[cpt]);
      cpt++;
    }
    for (int i=0; i < nbij; i++)
      int k = mpiWaitAny(rqt);
  }
  else if (!pr#prfe#prmesh#excluded) {
    mpiRequest[int] rqt(fullnumberIntersection);
    for (int i=0; i < pr#prfegeneo#prmesh#numberIntersection; i++)
      Isend(processor(rks(mpiRank(pr#prfe#prmesh#mpicomm)),pr#prfe#prmesh#mpicomm,rqt[i]),Eij[i]);
    IFMACRO(pr#geneofullpattern)
    for (int i=0; i < fullnumberIntersection-pr#prfegeneo#prmesh#numberIntersection; i++)
      Isend(processor(rks(mpiRank(pr#prfe#prmesh#mpicomm)),pr#prfe#prmesh#mpicomm,rqt[pr#prfegeneo#prmesh#numberIntersection+i]),Ekj[tabarrayIntersectionflat[i]]);
    ENDIFMACRO
    for (int i=0; i < fullnumberIntersection; i++)
      int k = mpiWaitAny(rqt);
  }

  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS) { /* fill E0 with Eii and Eij */
    int[int] offsetl(locnpart);
    for (int i = 0; i < locnpart; i++)
      offsetl[i] = (i == 0 ? 0 : offsetl[i-1] + pr#sizelg[rkrdd(i-1)]);

    int[int] offsetc(locnpart);
    for (int i = 0; i < locnpart; i++)
      offsetl[i] = (i == 0 ? 0 : offsetl[i-1] + pr#sizelg[rkrdd(i-1)]);

    pr#E0.resize(offsetl[locnpart-1] + pr#sizelg[rkrdd(locnpart-1)], pr#ncoarsespace);
    pr#E0 = 0;

    if (!pr#prfe#prmesh#excluded) {
      int k = mpiRank(pr#prfe#prmesh#mpicomm);
      /* block Epp */
      for (int jj=0; jj< pr#sizelg[mpiRank(pr#prfe#prmesh#mpicomm)]; jj++)
        pr#E0(0:prT#sizelg[k]-1,pr#offseti[k]+jj) = Eii(:,jj);

      /* blocks Epj */
      for(int j=0;j<pr#prfegeneo#prmesh#numberIntersection;++j)
      for (int jj=0; jj< pr#sizelg[pr#prfegeneo#prmesh#arrayIntersection[j]]; jj++)
        pr#E0(0:prT#sizelg[k]-1,pr#offseti[pr#prfegeneo#prmesh#arrayIntersection[j]]+jj) = Eij[j](:,jj);

      IFMACRO(pr#geneofullpattern)
      for(int j=0;j<fullnumberIntersection-pr#prfegeneo#prmesh#numberIntersection;++j)
      for (int jj=0; jj< pr#sizelg[fullarrayIntersection[pr#prfegeneo#prmesh#numberIntersection+j]]; jj++)
        pr#E0(0:prT#sizelg[k]-1,pr#offseti[fullarrayIntersection[pr#prfegeneo#prmesh#numberIntersection+j]]+jj) += Ekj[tabarrayIntersectionflat[j]](:,jj);
      ENDIFMACRO
    }
    
    int cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < locnpart; i++) {
    	/* blocks Eii */
      for (int jj=0; jj< pr#sizelg[rkrdd(i)]; jj++)
        pr#E0(offsetl[i]:offsetl[i]+prT#sizelg[rkrdd(i)]-1,pr#offseti[rkrdd(i)]+jj) = tabEii[i](:,jj);
      /* blocks Eij */
      for(int j=0;j<tabnumberIntersection[i];++j) {
        for (int jj=0; jj< pr#sizelg[tabarrayIntersection[i][j]]; jj++)
          pr#E0(offsetl[i]:offsetl[i]+prT#sizelg[rkrdd(i)]-1,pr#offseti[tabarrayIntersection[i][j]]+jj) += tabEij[cpt](:,jj);
        cpt++;
      }	
    }

    pr#E = pr#E0;
    IFMACRO(pr#CSwithpetsc)
    Mat pr#petsctmp(pr#E.n,communicator = pr#prfe#prmesh#commCS);
    pr#petsctmp = pr#E;
    pr#petscE = pr#petsctmp;
    MatDestroy(pr#petsctmp);
    pr#E.resize(1,1);
    ENDIFMACRO
    pr#E0.resize(1,1);
    IFMACRO(!pr#CSwithpetsc)
    int[int] Rl(offsetl[locnpart-1] + pr#sizelg[rkrdd(locnpart-1)]);
    for (int i = 0; i < locnpart; i++)
    for (int jj=0; jj< pr#sizelg[rkrdd(i)]; jj++)
      Rl[offsetl[i]+jj] = pr#offseti[rkrdd(i)]+jj;
    int[int] Rlc = (0:Rl.n-1);
    pr#prfe#K[int] Rlk(Rl.n);
    Rlk = 1;
    matrix<pr#prfe#K> mRl = [Rlc,Rl,Rlk];
    mRl.resize(Rl.n, pr#ncoarsespace);
    pr#E.resize(Rl.n, pr#ncoarsespace);
    pr#E = mRl'*pr#E;
    ENDIFMACRO
  }

  IFMACRO(!pr#CSwithpetsc)
  if (!pr#prfe#prmesh#binexactCS)
  if (Stringification(prT) == Stringification(pr))
  if (mpiRank(pr#prfe#prmesh#mpicomm) < pr#prfe#prmesh#pCS)
    set(pr#E,solver="MUMPS",sym=vsym,commworld=pr#prfe#prmesh#commCS,master=-1,factorize=3);
  ENDIFMACRO
  }
  else {
      
  NewMacro localmacroinexact pr#prfe#prmesh#minexactgeneoCS EndMacro
  IFMACRO (localmacroinexact,1)
  
  ffddmsetupsuper(pr)

  int[int][int] inisuperwithoverlap(pr#prfe#prmesh#listofsupers.n);
  int[int]inisuperwithoverlapsize(pr#prfe#prmesh#listofsupers.n);
  inisuperwithoverlapsize = 0;
  for (int i=0; i<inisuperwithoverlap.n; i++)
    inisuperwithoverlap[i].resize(1000);
  
  mpiRequest[int] rq(2*(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper)+2*pr#prfe#prmesh#issuper*(pr#prfe#prmesh#insuperwithoverlap.n-!pr#prfe#prmesh#excluded));
  int cpt = 0;
  if (pr#prfe#prmesh#issuper) {  
    for (int i=!pr#prfe#prmesh#excluded;i<pr#prfe#prmesh#insuperwithoverlap.n;i++) {
      Isend(processor(pr#prfe#prmesh#insuperwithoverlap[i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rq[cpt++]),pr#prfe#prmesh#insuperwithoverlap.n);
      Isend(processor(pr#prfe#prmesh#insuperwithoverlap[i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rq[cpt++]),pr#prfe#prmesh#insuperwithoverlap);
    }
  }
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper) {
      Irecv(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rq[cpt++]),inisuperwithoverlapsize[is]);
      Irecv(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rq[cpt++]),inisuperwithoverlap[is]);
    }
  }
  for (int i=0;i < cpt;i++)
    int k = mpiWaitAny(rq);

  for (int is=0;is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (pr#prfe#prmesh#issuper && pr#prfe#prmesh#mysuperrank == isuper) {
      inisuperwithoverlap[is].resize(pr#prfe#prmesh#insuperwithoverlap.n);
      inisuperwithoverlap[is] = pr#prfe#prmesh#insuperwithoverlap;
    }
    else
      inisuperwithoverlap[is].resize(inisuperwithoverlapsize[is]);
  }

  int[int][int] indicesofneighbors(pr#prfe#prmesh#listofsupers.n);
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    indicesofneighbors[is].resize(pr#prfe#prmesh#arrayIntersection.n);
    cpt = 0;
    for (int i=0; i<pr#prfe#prmesh#arrayIntersection.n; i++)
    for (int j=0; j<inisuperwithoverlap[is].n;j++)
    if (pr#prfe#prmesh#arrayIntersection[i] == inisuperwithoverlap[is][j])
      indicesofneighbors[is][cpt++] = i;
    indicesofneighbors[is].resize(cpt);
  }

  int[int][int] neighbors(pr#prfe#prmesh#listofsupers.n);
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    neighbors[is].resize(indicesofneighbors[is].n);
    for (int i=0;i<indicesofneighbors[is].n;i++)
      neighbors[is][i] = pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][i]];
  }
  
  int[int] tabnumberIntersection(pr#prfe#prmesh#insuperwithoverlap.n); /* i: number of neighbours of processor i */
  int[int][int] tabarrayIntersection(pr#prfe#prmesh#insuperwithoverlap.n);
  if (pr#prfe#prmesh#issuper)
  for (int i=!pr#prfe#prmesh#excluded; i<pr#prfe#prmesh#insuperwithoverlap.n; i++)
    tabarrayIntersection[i].resize(1000);
  
  mpiRequest[int] rqt(2*(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper)+2*pr#prfe#prmesh#issuper*(pr#prfe#prmesh#insuperwithoverlap.n-!pr#prfe#prmesh#excluded));
  
  cpt = 0;
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper) {
      Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqt[cpt++]),neighbors[is].n);
      Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqt[cpt++]),neighbors[is]);
    }
    else {
      for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++) {
        Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqt[cpt++]),tabnumberIntersection[i]);
        Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqt[cpt++]),tabarrayIntersection[i]);
      }
    }
  }
  
  for (int i=0;i < cpt;i++)
    int k = mpiWaitAny(rqt);
  
  if (pr#prfe#prmesh#issuper)
  for (int i=!pr#prfe#prmesh#excluded; i<pr#prfe#prmesh#insuperwithoverlap.n; i++)
    tabarrayIntersection[i].resize(tabnumberIntersection[i]);
    
  int nbrqmpiexcl = 0;
  
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != pr#prfe#prmesh#listofsupers[is])
      nbrqmpiexcl += indicesofneighbors[is].n;
  } 
  
  int is = 0;
  int nbij = 0;
  
  if (pr#prfe#prmesh#issuper) {  
    for (int i=0; i< pr#prfe#prmesh#listofsupers.n; i++)
    if (pr#prfe#prmesh#listofsupers[i] == pr#prfe#prmesh#mysuperrank)
      is = i;
    
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
      nbij += tabnumberIntersection[i];
  }
  
  mpiRequest[int] rqs(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper+nbrqmpiexcl+pr#prfe#prmesh#issuper*(inisuperwithoverlap[is].n-!pr#prfe#prmesh#excluded+nbij));
  cpt = 0;
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper)
    Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqs[cpt++]),Eii);
  }
    
  int cptmpi = 0;
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    for(int j=0;j<indicesofneighbors[is].n;++j) {
      if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper) {
        Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqs[pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper+cptmpi++]),Eij[indicesofneighbors[is][j]]);
      }
    }
  }

  pr#prfe#K[int,int][int] tabEij(nbij); /* big vector of full matrices for the blocks Sij */
  pr#prfe#K[int,int][int] tabEii(inisuperwithoverlap[is].n); /* big vector of full matrices for the blocks Sii */
  
  if (pr#prfe#prmesh#issuper) {
      
    int isuper = pr#prfe#prmesh#mysuperrank;
    
    /* on proc 0 resize tabSii and receive Sii blocks */
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++) {
      tabEii[i].resize(pr#sizelg[inisuperwithoverlap[is][i]],pr#sizelg[inisuperwithoverlap[is][i]]);
      Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqs[pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper+nbrqmpiexcl+i-!pr#prfe#prmesh#excluded]),tabEii[i]);
    }
    
    /* on proc 0 resize tabSij and receive Sij blocks */
    int cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
    for (int j=0; j < tabnumberIntersection[i]; j++) {
      tabEij[cpt].resize(pr#sizelg[inisuperwithoverlap[is][i]],pr#sizelg[tabarrayIntersection[i][j]]);
      Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqs[pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper+nbrqmpiexcl+inisuperwithoverlap[is].n-!pr#prfe#prmesh#excluded+cpt]),tabEij[cpt]);
      cpt++;
    }
  }

  for (int i=0; i<pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper+nbrqmpiexcl+pr#prfe#prmesh#issuper*(inisuperwithoverlap[is].n-!pr#prfe#prmesh#excluded+nbij); i++)
    int k = mpiWaitAny(rqs);
  
  if (pr#prfe#prmesh#issuper) {
    
    int isuper = pr#prfe#prmesh#mysuperrank;
    
    /* fill E0 with Eii and Eij */
    pr#E0.resize(pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].n,pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].n);
    pr#E0 = 0;
    
    if (!pr#prfe#prmesh#excluded) {
      /* block E00 */
      for (int jj=0; jj< pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]; jj++)
        pr#E0(pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]:pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]-1,
        pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+jj) = Eii(:,jj);
      /* blocks E0j */          
      for(int j=0;j<indicesofneighbors[is].n;++j)
      for (int jj=0; jj< pr#sizelg[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]; jj++)
        pr#E0(pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]:pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]-1,
        pr#superlocalnuminv[pr#offseti[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]]+jj) = Eij[j](:,jj);    
    }
    
    cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++) {
      /* blocks Eii */
      for (int jj=0; jj< pr#sizelg[inisuperwithoverlap[is][i]]; jj++)
        pr#E0(pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]:pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]+pr#sizelg[inisuperwithoverlap[is][i]]-1,
        pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]+jj) = tabEii[i](:,jj);
      /* blocks Eij */
      for(int j=0;j<tabnumberIntersection[i];++j) {
        for (int jj=0; jj< pr#sizelg[tabarrayIntersection[i][j]]; jj++) {
          pr#E0(pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]:pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]+pr#sizelg[inisuperwithoverlap[is][i]]-1,
          pr#superlocalnuminv[pr#offseti[tabarrayIntersection[i][j]]]+jj) = tabEij[cpt](:,jj);
        }
        cpt++;
      }	
    }
    
    if (pr#prfe#prmesh#binexactgeneoCS == 1) {
      
      pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)] = pr#E0;
    
    /*
    matrix E0s = E0;
    pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)] = pr#RsuperCS*E0s;
    pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)] = pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)]*pr#RsuperCS';
    */
    
      pr#superaR[mpiRank(pr#prfe#prmesh#commsuper)] = pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)];
    
      set(pr#superaR[mpiRank(pr#prfe#prmesh#commsuper)],solver=sparsesolver,commworld=pr#prfe#prmesh#supercommself,factorize=3);
    }
    else {
      pr#E = pr#E0;
      pr#E0.resize(1,1);
      pr#E = pr#prfe#superDih[mpiRank(pr#prfe#prmesh#commsuper)]*pr#E;
      pr#E = pr#RsuperCS'*pr#E;
      pr#E = pr#E*pr#RsuperCS;
      set(pr#E,solver="MUMPS",sym=vsym,commworld=pr#prfe#prmesh#commsuper,master=-1,factorize=3);
    }
  }

  ENDIFMACRO
  ;
  }
    
}
pr#prfe#prmesh#toc(pr#tloc,"building E",pr#tbuildE)
}

// EOM

macro ffddmgeneosetup(pr,Varf)

pr#bCM = 0;

if (pr#prfe#prmesh#isincomm)
{
pr#corr = ffddmcorrection;

int nev = ffddmnu;

IFMACRO(pr#withhpddm)
string prefix = Stringification(pr)+"_";
set(pr#hpddmOP,sparams="-hpddm_"+prefix+"geneo_threshold "+ffddmtau+" -hpddm_"+prefix+"geneo_nu "+nev, prefix=prefix);

pr#prfe#prmesh#tic(pr#tloc)

IFMACRO(!pr#algebraic)
{
  Varf(vN,pr#prfe#prmesh#Thi,pr#prfe#Vhi)
  pr#matN = vN(pr#prfe#Vhi,pr#prfe#Vhi,sym=vsym,tgv=vtgv,solver=GMRES);
}
ENDIFMACRO
AttachCoarseOperator(pr#prfe#prmesh#commddm, pr#hpddmOP, A = pr#matN);

pr#prfe#prmesh#toc(pr#tloc,"building E",pr#tbuildE)

ENDIFMACRO

IFMACRO(!pr#withhpddm)

if (!bpara)
  pr#Z.resize(nev*pr#prfe#prmesh#npart);
else if (!pr#prfe#prmesh#excluded)
  pr#Z.resize(nev);

pr#si=0;
pr#prfe#prmesh#tic(pr#tloc)

int[int] sizel(pr#prfe#prmesh#npart);
int[int] sizelT(pr#prfe#prmesh#npart);

for(int i=0;i<pr#prfe#prmesh#npart;++i)
if ((!pr#prfe#prmesh#excluded) && ((!bpara) || (i == mpiRank(pr#prfe#prmesh#commddm)))) {
	pr#prfe#prmesh#Thi=pr#prfe#prmesh#aTh[i];

	matrix<pr#prfe#K> weightedTmp;

	weightedTmp=pr#aR[i]*pr#prfe#Dih[i];

  matrix<pr#prfe#K> weighted;

  weighted=pr#prfe#Dih[i]*weightedTmp;

  /*
  pr#prfe#K[int] dofsinoverlap(pr#prfe#Dk[i].n);
  dofsinoverlap = 1;
  pr#prfe#update(dofsinoverlap,false);
  for [j,bj: dofsinoverlap] bj = abs(bj) > 1;

  matrix<pr#prfe#K> Movl = dofsinoverlap;

  weighted = weighted*Movl;
  weighted = Movl*weighted;
  */

  IFMACRO(!pr#algebraic)
  {
    if (pr#prfe#prmesh#overlap > 0) {
      Varf(vN,pr#prfe#prmesh#Thi,pr#prfe#Vhi)
      pr#matN = vN(pr#prfe#Vhi,pr#prfe#Vhi,sym=vsym,tgv=vtgv,solver=GMRES);
    }
  }
  ENDIFMACRO

  if (ffddminertia) {
    nev = ffddmnu;
    matrix<pr#prfe#K> NA = pr#matN-ffddmtau*weighted;
    int[int] info(40);
    set(NA,solver = sparsesolver,sym=1,commworld=pr#prfe#prmesh#commself,factorize=3,info=info);
    int ninertia = info[11];
    if (pr#verbosity >= 1 && ninertia > nev) cout << "["+Stringification(pr)+"] " << nev << " Warning: inertia = " << ninertia << ", maximum number of eigenvectors too low (" << nev << ", from -ffddm_geneo_nu) in subdomain " << i << endl;
    nev = min(nev,ninertia);
    if (pr#verbosity >= 10) cout << "["+Stringification(pr)+"] " << nev << " eigenvectors will be computed in subdomain " << i << endl;
  }

  set(pr#matN,solver = sparsesolver,sym=1,commworld=pr#prfe#prmesh#commself);

  pr#prfe#K[int,int] eV(pr#prfe#Dk[i].n,nev);
  pr#prfe#K[int] ev(nev);

  int kk = EigenValue(pr#matN,weighted,sym=1,value=ev,rawvector=eV,ncv=max(20,3*nev));

  IFMACRO(!pr#superalgebraic)
  pr#matN.clear;
  ENDIFMACRO

  int nok = 0;

  for(int j=0;j<nev;++j) {
    if (j == 0 || ffddmtau == 0 || real(ev[j]) < ffddmtau) {
      /*if (mpirank == 0) cout << i << " " << pr#si << " " << ev[j] << endl;*/
      pr#Z[pr#si].resize(pr#prfe#Dk[i].n);
      pr#Z[pr#si] = pr#prfe#Dk[i].*eV(:,j);
      if (pr#Z[pr#si].sum < 0) pr#Z[pr#si] *= -1;
      pr#si+=1;
      nok+=1;
    }
  }

  sizel[i] = nok;	/* number of ev for subdomain i */
}
if (bseq)
  pr#prfe#prmesh#Thi = pr#prfe#prmesh#Thglob;

pr#prfe#prmesh#toc(pr#tloc,"local eigenvalue problems",pr#teigenv)

ffddmbuildZTAZ(pr,pr,Varf)

ENDIFMACRO
}
// EOM

macro ffddmdtnsetup(pr,Varf,lambdamax)

pr#bCM = 0;

if (pr#prfe#prmesh#isincomm)
{
pr#corr = ffddmcorrection; /* Correction scheme used */

int nev = ffddmnu; /* Maximum number of eigenvectors per subdomain */

IFMACRO(pr#withhpddm)
string prefix = Stringification(pr)+"_";
set(pr#hpddmOP,sparams="-hpddm_"+prefix+"geneo_threshold "+ffddmtau+" -hpddm_"+prefix+"geneo_nu "+nev, prefix=prefix);

pr#prfe#prmesh#tic(pr#tloc)

IFMACRO(!pr#algebraic)
{
  Varf(vN,pr#prfe#prmesh#Thi,pr#prfe#Vhi)
  pr#matN = vN(pr#prfe#Vhi,pr#prfe#Vhi,sym=vsym,tgv=vtgv,solver=GMRES);
}
ENDIFMACRO

varf vmass(def(u),def(v)) = pr#prfe#prmesh#intbN(pr#prfe#prmesh#Thi,ffddminterfacelabel)(pr#prfe#mdef(u)'*pr#prfe#mdef(v));
matrix<pr#prfe#K> mmass = vmass(pr#prfe#Vhi,pr#prfe#Vhi);

AttachCoarseOperator(pr#prfe#prmesh#commddm, pr#hpddmOP, A = pr#matN, B = mmass, pattern = pr#aRd[mpiRank(pr#prfe#prmesh#commddm)]);

pr#prfe#prmesh#toc(pr#tloc,"building E",pr#tbuildE)

ENDIFMACRO

IFMACRO(!pr#withhpddm)

if (!bpara) /* If sequential */
  pr#Z.resize(nev*pr#prfe#prmesh#npart);
else if (!pr#prfe#prmesh#excluded)
  pr#Z.resize(nev);

pr#si=0;
pr#prfe#prmesh#tic(pr#tloc) /* For timings */

int[int] sizel(pr#prfe#prmesh#npart);
int[int] sizelT(pr#prfe#prmesh#npart);

for(int i=0;i<pr#prfe#prmesh#npart;++i) /* Loop over the subdomains */
if ((!pr#prfe#prmesh#excluded) && ((!bpara) || (i == mpiRank(pr#prfe#prmesh#commddm)))) { /* If subdomain assigned to this processor */
	pr#prfe#prmesh#Thi=pr#prfe#prmesh#aTh[i]; /* Local mesh */

  /* Start DtN part */

  varf vv(pr#prfe#mdef(u), pr#prfe#mdef(v)) = on(ffddminterfacelabel, pr#prfe#mdef(u) = pr#prfe#minit(1)); /* Mark interface */
  real[int] b10 = vv(0,pr#prfe#Vhi,tgv=1);
  int ndof10 = 0, ndofint = 0; /* Set up interface and interior DOFs */
  for (int j=0;j<b10.n;j++) {
    if (b10[j] != 0) {
      ndof10++;
      b10[j] = ndof10; /* Enumerate interface DOFs */
    }
    else {
      ndofint++;
      b10[j] = -ndofint; /* Enumerate interior DOFs (using negative index) */
    }
  }

   /* For restriction operators */
  int[int] Ii(ndof10),Ji(ndof10);
  pr#prfe#K[int] Ki(ndof10);
  int[int] Iiint(ndofint),Jiint(ndofint);
  pr#prfe#K[int] Kiint(ndofint);
  for (int j=0;j<b10.n;j++) {
    if (b10[j] > 0) {
      Ji[b10[j]-1] = j;
      Ii[b10[j]-1] = b10[j]-1;
      Ki[b10[j]-1] = 1;
    }
    else {
      Jiint[-b10[j]-1] = j;
      Iiint[-b10[j]-1] = -b10[j]-1;
      Kiint[-b10[j]-1] = 1;
    }
  }

   /* Restriction operators */
  matrix<pr#prfe#K> R10 = [Ii,Ji,Ki];
  matrix<pr#prfe#K> Rint = [Iiint,Jiint,Kiint];

  R10.resize(ndof10,pr#prfe#Vhi.ndof);
  Rint.resize(ndofint,pr#prfe#Vhi.ndof);

  IFMACRO(!pr#algebraic)
  {
    if (pr#prfe#prmesh#overlap > 0) {
      Varf(vN,pr#prfe#prmesh#Thi,pr#prfe#Vhi)
      pr#matN = vN(pr#prfe#Vhi,pr#prfe#Vhi,sym=vsym,tgv=vtgv,solver=GMRES);
    }
  }
  ENDIFMACRO

   /* Local stiffness matrices */
  matrix<pr#prfe#K> A10t = R10*pr#matN;
  matrix<pr#prfe#K> A10 = A10t*R10';

  matrix<pr#prfe#K> Aintt = Rint*pr#matN;
  matrix<pr#prfe#K> Aint = Aintt*Rint';
  set(Aint,solver=sparsesolver,commworld=pr#prfe#prmesh#commself);

   /* Transfer operators as part of the Schur complement */
  matrix<pr#prfe#K> Aint10t = Rint*pr#matN;
  matrix<pr#prfe#K> Aint10 = Aint10t*R10';

  matrix<pr#prfe#K> A10intt = R10*pr#matN;
  matrix<pr#prfe#K> A10int = A10intt*Rint';

  /* Interface mass matrix */
  varf vmass(pr#prfe#mdef(u),pr#prfe#mdef(v)) = pr#prfe#prmesh#intbN(pr#prfe#prmesh#Thi,ffddminterfacelabel)(pr#prfe#mdef(u)'*pr#prfe#mdef(v));
  matrix<pr#prfe#K> mmass = vmass(pr#prfe#Vhi,pr#prfe#Vhi);
  matrix<pr#prfe#K> mmass10t = R10*mmass;
  matrix<pr#prfe#K> mmass10 = mmass10t*R10';
  set(mmass10,solver=sparsesolver,commworld=pr#prfe#prmesh#commself);

  /* Set up for interface eigenvectors and eigenvalues */
  pr#prfe#K[int,int] eVC(ndof10,nev);
  pr#prfe#K[int] ev(nev);

  pr#prfe#K[int] tmp(pr#prfe#Vhi.ndof); /* For extension of eigenfunction */

  pr#prfe#K[int] vinta(ndofint), vintb(ndofint);
  pr#prfe#K[int] v10a(ndof10), v10b(ndof10);

  int cptA = 0, cptB = 0;

  /* Left-hand side of the generalised eigenproblem */
  func pr#prfe#K[int] FA(pr#prfe#K[int] & u) {
	  vinta = Aint10*u;
	  vintb = Aint^-1*vinta;
	  v10a = A10int*vintb;
	  v10b = A10*u;
	  v10b -=  v10a;
	  cptA++;
	  return v10b;
	}

  /* Right-hand side of the generalised eigenproblem */
	func pr#prfe#K[int] FB(pr#prfe#K[int] & u) {
	  cptB++;
	  v10a = mmass10*u;
	  return v10a;
	}

  /* Solve for right-hand side of generalised eigenproblem */
	func pr#prfe#K[int] FB1(pr#prfe#K[int] & u) {
	  cptB++;
	  v10a = mmass10^-1*u;
	  return v10a;
	}

  int ncv = max(2*nev+1,100);

  int kk = complexEigenValue(ndof10,A=FA,B=FB,B1=FB1,value=ev,rawvector=eVC,which="SR",mode=2,ncv=ncv,tol=0.001);

  int nok = 0;

  for(int j=0;j<nev;++j)
  {
    if(j<kk && (real(ev[j]) < lambdamax)) /* Criterion 4.3 of Lea's paper */
    {
    /* cout << "Eigenvalue " << i << "," << nok << " " << ev[j] << endl; */
    /* Retain eigenfuntion on interface */
    tmp = R10'*eVC(:,j);
     /* Extend eigenfunctions into the domain */
    pr#prfe#K[int] tmp2 = Aint10*eVC(:,j);
    pr#prfe#K[int] tmp3 = Aint^-1*tmp2;
    tmp3 *= -1;
    tmp += Rint'*tmp3;
    /* Now tmp is as in Definition 4.4 of Lea's paper.*/

    pr#Z[pr#si].resize(pr#prfe#Dk[i].n);
    pr#Z[pr#si]= tmp .* pr#prfe#Dk[i];

    pr#si+=1;
    nok+=1;
    }
  }

  sizel[i] = nok;	/* number of ev for subdomain i */
}
if (bseq)
  pr#prfe#prmesh#Thi = pr#prfe#prmesh#Thglob;

pr#prfe#prmesh#toc(pr#tloc,"local eigenvalue problems",pr#teigenv)

ffddmbuildZTAZ(pr,pr,Varf)

ENDIFMACRO
}
// EOM
func meshS buildmeshS(meshL & TL,int orientation,int minsurf)
{
	int withp=0;
if(withp) plot(TL,wait=1);

//  calcul du barycentre de TL;
real lg=int1d(TL)(1.);
R3 B(int1d(TL)(x)/lg, int1d(TL)(y)/lg, int1d(TL)(z)/lg);
if(verbosity>2) cout <<" Barycenter: " <<  B << endl; 

R3 NL(int1d(TL,qforder=1)((Tl^(P-B)).x),int1d(TL)((Tl^(P-B)).y),int1d(TL)((Tl^(P-B)).z));

NL /= NL.l2;
if(verbosity) cout << " NL = "<< NL << endl;
R3 U0 = (B-TL(0).P);
R3 V = U0^NL; V /=V.l2;
R3 U = V^NL ;
if(verbosity>5)  cout << " det = " << det(U,V,NL) << " == "  <<  1 << endl; 
assert(abs(det(U,V,NL)-1)< 1e-6); 
if(verbosity>2) cout << " New Frame : "<< U << " , " << V << " , "  << NL << endl; 
real bu = U'*B, bv=V'*B, bn = NL'*B; 
meshL TLm = movemeshL(TL,transfo=[U'*P-bu,V'*P-bv,NL'*P-bn]);
meshL TL0 = movemeshL(TL,transfo=[U'*P-bu,V'*P-bv,0]);
fespace VLm(TLm,P1); VLm zLm = z;  
fespace VL0(TL0,P1); VL0 zL0; zL0[]= zLm[];  
mesh Th = buildmesh(TL0,fixeborder=1);
real[int] bb(4);
boundingbox(Th,bb);
if(verbosity>5) cout << " bb = "<< bb << endl; 
real lTh = max(bb[1]-bb[0],bb[3]-bb[2]); // lg characteristic  of Th
if(withp) plot(Th,TLm,wait=1);
fespace V2(Th,P1); 
V2 g=zL0;
real ginf =g[].linfty;
if(verbosity>5) cout << " ginf "<< ginf << " " << lTh << endl; 
real errf =  0.1*g[].linfty/lTh;// err  fixe point 
real errN =  1e-6*g[].linfty/lTh;// err newton..
V2 u=0,v,up;
macro grad(u) [dx(u),dy(u)]//
int[int] labs=labels(Th);
int nbiter = 100;
if( minsurf == 0 || ginf < 1e-3*lTh)  nbiter = 1; 
for(int i=0; i< nbiter; ++i)
{
    up[]=u[];
	solve Pb(u,v) = int2d(Th)( (dx(u)*dx(v) + dy(u)*dy(v) )
	/ sqrt( 1+ (dx(up)*dx(up) + dy(up)*dy(up) )) )
	+on(labs,u=g);	
	real area = int2d(Th)( sqrt(1+ (dx(u)*dx(u) + dy(u)*dy(u) )));
	up[] -= u[]; 
	real err= up[].linfty ;
	if(verbosity) cout << i << " fixed point, surface = "<< area<< " err infty  = " << err << "/" << errf << endl;
	if(withp) plot(u, dim=3,fill=3, cmm=i+" area="+area+" err= "+err);
	if(err<errf) break; 
}
// iteration de newton

macro DJ(u,v) int2d(Th) ( grad(u)'*grad(v)/ sqrt(1+ grad(u)'*grad(u)) ) //
macro D2J(u,v,w) int2d(Th) ( grad(w)'*grad(v)/ sqrt(1+ grad(u)'*grad(u)) 
      - (grad(u)'*grad(w))*(grad(u)'*grad(v)) / (1+ grad(u)'*grad(u))^1.5  ) //

for(int i=0; i< nbiter-1; ++i)
 {  up[]=u[];
	solve PbNewton(u,v) = D2J(up,u,v) - D2J(up,up,v) + DJ(up,v) 
	+on(labs,u=g);	
	real area = int2d(Th)( sqrt(1+ (dx(u)*dx(u) + dy(u)*dy(u) )));
	up[] -= u[]; 
	real err= up[].linfty ;
	if(verbosity) cout << i << " Newton surface = "<< area<< " err infty = "  << err << "/" << errN << endl;
	if(withp) plot(u, dim=3,fill=3, cmm=i+" area="+area+" err= "+err);
	if(err<errN) break; 
}
// MOVE = B+U*x+V*y+NL*z
meshS Ths=movemesh23(Th,transfo=[
	                B.x+U.x*x+V.x*y+NL.x*u, 
	                B.y+U.y*x+V.y*y+NL.y*u,
		        B.z+U.z*x+V.z*y+NL.z*u],
			orientation=orientation);
if(withp) plot(Ths,TL,wait=1);  
return Ths;
}


func meshS buildmeshSminsurf(meshL & TL,int orientation)
{return buildmeshS(TL,orientation,1);}
func meshS buildmeshSLap(meshL & TL,int orientation)
{return buildmeshS(TL,orientation,0);}


int nbmaxS=0,nbmax;
real[int,int] Strouhal(2,100),  Strouhal3(3,3); 
real[int]  mxdrag(4), mxdragi(3); 
real[int]  mxlift(4), mxlifti(3); 
func real t1MaxO2(real c0,real c1,real c2)
{
  return  (1./2.)*(c0-c2)/(c0-2.*c1+c2);
}
func real MaxO2(real c0,real c1,real c2)
{
  return  -(1./8)*(c0^2-8.*c0*c1-2.*c0*c2-8.*c2*c1+16.*c1^2+c2^2)/(c0-2.*c1+c2);
}

func real AddMaxO2(real Cd,int i,real[int] &Maxd,real[int] & Maxdi)
{
    assert(Maxdi.n ==3 && Maxd.n > 3); 
    if( i <=1) // init ...
    {
        Maxdi = -1e100; 
        Maxd  = -1e100;        
        Maxd[0] =-1000;      
    }
    Maxdi[i%3] = Cd;
    if( Maxdi.min > -1e50) 
    {
      int i0=(i+1)%3, i1=(i+2)%3, i2=(i)%3; 
      if( (Maxdi[i0] < Maxdi[i1]) & (Maxdi[i1] > Maxdi[i2])  )
        { // new max 
          int j = Maxd[0]+1+1000;
          Maxd[j] = MaxO2(Maxdi[i0],Maxdi[i1],Maxdi[i2]);
          Maxd[0] = j%(Maxd.n-1)-1000;
         if(mpirank==0 && verbosity>5)
           cout << " max " << " " << Cd << " "  << i << " " << j << " " << Maxd[j] 
                << i0 << " " << i1 << " " << i2 
                << " "  << Maxdi[i0]  << " " << Maxdi[i1]  << " "<< Maxdi[i2]  << endl;
        } 
    }
}
func real  AddStrouhal(int i,real t,real v)
{
  real s=-1; 
  int i3 = i%3;
  Strouhal3(0,i3)= t;
  Strouhal3(1,i3)= v;
  if( i>10) 
  {
    int i2 = (i-1)%3;
    int i1 = (i-2)%3;
    if(Strouhal3(1,i1) < Strouhal3(1,i2) & Strouhal3(1,i2) > Strouhal3(1,i3) )
    {
        real dt = t- Strouhal3(0,i2);
        real t2 = Strouhal3(0,i2);
        int ii = nbmaxS%Strouhal.m;
        real tm = t2+dt*t1MaxO2(Strouhal3(1,i1),Strouhal3(1,i2),Strouhal3(1,i3));
        real fm = MaxO2(Strouhal3(1,i1),Strouhal3(1,i2),Strouhal3(1,i3));
        Strouhal(0,ii) =tm;
        Strouhal(1,ii) =fm;
         ++nbmaxS;
       // if(mpirank==0) cout << ii << " "  << " " << Strouhal3(0,i1) << " < " << Strouhal3(0,i2) << " >  " << Strouhal3(0,i3) << endl; 
    }
  }
  if(nbmaxS > 3)
        {
           int ii = (nbmaxS-1)%Strouhal.m;
           int jj = (nbmaxS-4)%Strouhal.m;
           real per = (Strouhal(0,ii)-Strouhal(0,jj))/3.;
        //   if(mpirank==0) cout << "zzzz  " << ii << " " << jj << " " << per << endl;
           s= 1/per;             
        }
  return s; 
}

// MPIGMRSmacro.idp  file..  version 0.1
// include in MPIGMRES.edp file ..
// Frederic Hecht 2010 
// LGPL licence 
// Author Frederic.Hecht@upmc.fr
// ------------------------------- 

//  macro to def // send-recv message 
// -----------------------------------

/******************************************************************/ 
func real  maxM(matrix & A)
  {
  	int[int] I(1),J(1);
  	real[int] C(1);
  	[I,J,C] =A;
  	return C.max ;
  }
  
/******************************************************************/   
macro  InitU(n,Vh,Th,aTh,U)
Vh[int] U(n);
for(int j=0;j<n;++j)
  {  
  	 Th=aTh[j];
  	 U[j]=0;
  }
//EOM

/******************************************************************/ 
macro   ISendRecvAny(comm,jpart,Si,Ri)
{ /* sorry no Irecv of complex objet ...*/
  int n= jpart.n,nn=n+n;
  if(vdebug) cout << mpirank << " --ISendRecvAny " << n << endl;
  mpiRequest[int] rq(nn);
  
  for (int j=0;j<n;++j)
    Irecv(processor(jpart[j],comm,rq[j]),Ri[j]);
  if(vdebug) cout << mpirank << " ++ISendRecvAny " << n << endl;
  
  for (int j=0;j<n;++j)
    Isend(processor(jpart[j],comm,rq[n+j]),Si[j]);
for (int j=0;j<nn;++j)
  {
  int k= mpiWaitAny(rq);
  if(vdebug)
    cout << " ++ISendRecvAny wait: get " << k << endl;
  }
}
//EOM

/******************************************************************/ 
macro   SendRecvAny(comm,jpart,Si,Ri)
{  
 	int n= jpart.n;
 	for (int j=0;j<n;++j)
       processor(comm,jpart[j]) << Si[j];
    cout << " ** wait revc " << endl;
 	for (int j=0;j<n;++j)
       processor(comm,jpart[j]) >> Ri[j];
}
// EOM 

/******************************************************************/ 
macro CheckUV(comm,jpart,Si,Ri)
{
	 	int n= jpart.n;
  		int[int] rn(n),sn(n),in(n);
 		for (int j=0;j<n;++j) 
 		  { sn[j]= Si[j][].n;		  	  
 		   processor(jpart[j],comm) << sn[j];
 		   processor(jpart[j],comm) << ipart;
 		  }
 		 for (int j=0;j<n;++j) 
 		   processor(jpart[j],comm) >> rn[j];
 		 for (int j=0;j<n;++j) 
 		   processor(jpart[j],comm) >> in[j];

 		 int err=0;
 		 for (int j=0;j<n;++j) 
 		  { 
 		   int rj=Ri[j][].n;
 		   err += rj != rn[j];
 		   cout << rj << " s ========= r " << rn[j] << "      " << ipart << " <->  " << in[j] << " " << err << endl;  
 		   
 		  }
 	     assert(err==0);
}//EOM

/******************************************************************/ 
macro   SendRecvUV(comm,jpart,Si,Ri)
{
 	int n= jpart.n;
	mpiRequest[int] rq(n);
    for (int j=0;j<n;++j)
       Irecv(processor(jpart[j],comm,rq[j]), Ri[j][]);
       
 	for (int j=0;j<n;++j)
       processor(jpart[j],comm) << Si[j][];
  /* 	for (int j=0;j<n;++j)
       processor(jpart[j],comm) >> Ri[j][];*/
 
    for (int j=0;j<n;++j)
	   int k= mpiWaitAny(rq);
}
// EOF 

   /* Trick  */
 
/**********************************************************/
macro BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug) 
/**********************************************************/

int[int] jpart(mpiSize(comm)); /*  list of jpart */
mesh[int] aThij(1); 
mesh Thi,Thii;
Thi=Thg;
Thii=Thg;
fespace Vhi(Thi,P1); /**/
Vhi pii;  

{
 int npart = mpiSize(comm);
 fespace Phg(Thii,P0);
 fespace Vhg(Thii,P1);

  int njpart=0;
  int ipart= mpiRank(comm);
    /* a good trick : int#mesh =  */
  func  intmesh= int2d;
  func  intmesh3=int3d;
  /* end trick */ 
int dplot1 =0;
int vdebug1 = vdebug;
Phg  part;
mesh Thin;
/* build the partitioning ...  */
{    
 part=0; 
 if(npart>1 && ipart==0)
   metisdual(part[],Thg,npart); 
   
 broadcast(processor(0,comm),part[]);
  
} /* build ...  */


if(vdebug>10&& mpirank==0 && !NoGraphicWindow)
  plot(part,fill=1,cmm="dual",wait=1);

/* overlapping partition  */
Vhi unssd; 
int nnn = sizeoverlaps*2;/* to be sure exact in thii */
 
{
 int[int] n2o(1);
 Phg suppi= abs(part-ipart)<0.1; 
                      /* boolean function 1 in the subdomain 0 elswhere  */
 Thin=trunc(Thg,suppi>0,label=10,renum=false); /* non-overlapping mesh, interfaces have label 10 */
 AddLayers(Thg,suppi[],nnn,unssd[]);    /* see above ! suppi and unssd are modified   */
 unssd[] *= nnn;  /*  to put value nnn a 0   */
 /*   build a local mesh of thii such that all compuation of the unit partition are  */
 /*   exact in thii  */
 Thii=trunc(Thg,unssd> 0.001 ,label=10,new2old=n2o,renum=false); /* overlapping mesh, interfaces have label 10  */
 unssd= unssd;/* put on Thii*/
 real[int] p=part[];
 part=0.; part[]=p(n2o);  

 real nnn0 = nnn - sizeoverlaps +  0.001   ;
 Thi=trunc(Thii,unssd>nnn0 ,label=10,renum=false); /* overlapping mesh, interfaces have label 10 */

}
 settt 


 int npij=npart;
 Vhi[int] pij(npij);/* local partition of unit + pii  */
 
 

 { /*
   construction of the partition of the unit,
    let phi_i P1 FE function 1 on Thin and zero ouside of Thi and positive
    the partition is build with  
  $$  p_i = phi_i/ \sum phi_i 
    
    to build the partition of one domain i
    we nned to find all j such that supp(phi_j) \cap supp(phi_j) is not empty
    <=> int phi_j
 */
 

 {  
   /* find all j  mes (supp(p_j) \cap supp(p_i)) >0   */
   /* compute all phi_j on Thii  */
   /*  remark supp p_i include in Thi  */
   /*   */
   fespace Phii(Thii,P0);
   fespace Vhii(Thii,P1);
   Vhi sumphi=0;
   jpart=0;
   njpart=0;
   if(ipart==0) 
     cout <<" sizeoverlaps=" << sizeoverlaps << " " << " nnn = " << nnn<< endl;
  if(dplot1) plot(unssd,wait=1,cmm=" bbbb");

   pii= max(unssd-sizeoverlaps,0.)/sizeoverlaps;
   if(RAS) pii[]=pii[] ? 1. : 0.;  
   if(dplot1) plot(pii,wait=1,cmm=" 0000 max="+pii[].max);
   sumphi[] +=  pii[];
   if(dplot1) plot(sumphi,wait=1,cmm=" summ 0000");
   Vhii phii=0;
   real epsmes=1e-10*Thii.mesure;
   /*cout <<  " epsmes = " << epsmes <<endl;*/
   for (int i=0;i<npart;++i)
     if(i != ipart ) 
       { 
	    Phii suppii=abs(i-part)<0.2; 
	    if(suppii[].max > 0.5) 
	    {
	     AddLayers(Thii,suppii[],sizeoverlaps,phii[]);
	     if(RAS)  
	       { phii[]=phii[] ? 1. : 0.;
	        if(dplot1) plot(phii,wait=1,cmm=" RAS ij");

	      }
	 	 assert(phii[].min >= -1e-10);
	     real interij = int#mesh(Thi)(  phii); 
	     if(interij>epsmes) 
	       {  
		     pij[njpart]=abs(phii);	 
		     if(vdebug1>2) cout << " ***** " << int#mesh(Thi)(real(pij[njpart])<0) << " " <<pij[njpart][].min << " " << phii[].min << endl;
		     assert(int#mesh(Thi)(real(pij[njpart])<0) ==0);
		     if(dplot1)  plot(pij[njpart],wait=1,cmm=" j = "+ i + " " + njpart);
		     sumphi[] += pij[njpart][]; 
		     if(dplot1)  plot(sumphi,wait=1,cmm=" sum j = "+ i + " " + njpart);
		     jpart[njpart++]=i;
	       }}}
    
    
    
   if(dplot1) plot(sumphi,wait=1,dim=3,cmm="sum ",fill=1 );
   pii[]=pii[] ./ sumphi[];
   for (int j=0;j<njpart;++j)
     pij[j][] = pij[j][] ./ sumphi[];
   jpart.resize(njpart);
    for (int j=0;j<njpart;++j)
     assert(pij[j][].max<=1);
   {
     cout << ipart << " number of jpart " << njpart << " : ";
     for (int j=0;j<njpart;++j)
       cout << jpart[j] << " ";
  	cout << endl;
   }
   sumphi[]=pii[];
   for (int j=0;j<njpart;++j)
     sumphi[]+= pij[j][];
   if(vdebug1>2)  
     cout << " sum min " <<sumphi[].min << " " << sumphi[].max << endl;
   assert(sumphi[].min> 1.-1e-6 && sumphi[].max< 1.+1e-6);  
   /*  verification  */
 }}/* (Thii is remove here)  */
  /* end of the construction of the local partition of the unity ... */
  /* on Thi ...   */
  /* ----------------------------------------------------------------- */
if(mpiRank(comm)==0) cout << " *** end build partition " << endl;

/*  computation of  number of intersection .. */
/* ------------------------------------------ */

/* here  pii and the pij is the locate partition of the unite on  */
/* Thi ( mesh with overlap ).... */
/*Thi=splitmesh(Thi,2); */
if(dplot1 ) 
  { plot(Thi,pii,wait=1); 
    for(int j=0;j<njpart;++j)
      plot(pij[j],cmm=" j="+j ,wait=1); } 
      
/*  Partition of the unity on Thi ..  */
/* computation of message.  */
/* all j> we have to recive  */
/* data on intersection of the support of pij[0] and pij[j] */
settt 


  
 aThij.resize(njpart);
/* construction of the mesh intersect i,j part  */
for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(Thi,pij[jp]>1e-6,label=10,renum=false); /* mesh of the supp of pij  */
}
if(mpiRank(comm)==0) cout << " *** end build mesh  intersection  " << endl;
// EOM 
macro defPk1(i,j) i j // 
macro defPk2(i,j) [i j,i#1 j]// 
macro defPk3(i,j) [i j,i#1 j,i#2 j]// 
macro defPk4(i,j) [i j,i#1 j,i#2 j,i#3 j]// 
macro defPk5(i,j) [i j,i#1 j,i#2 j,i#3 j, i#4 j]// 
macro Times1(i) i  // 
macro Times2(i) [i,i]// 
macro Times3(i) [i,i,i]// 
macro Times4(i) [i,i,i,i]// 
macro Times5(i) [i,i,i,i,i]// 
macro  InitUdef(n,Vh,Th,aTh,U,N)
Vh[int] defPk#N(U,)(n);
for(int j=0;j<n;++j)
  {  
  	 Th=aTh[j];
  	 defPk#N(U,[j])=Times#N(0.);
  }
//EOM


/******************************************************************/ 
macro BuildTransferMat2(ipart,mesh,Pk,N,U2V,Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,Pii,vdebug)
/******************************************************************/ 
/* construction of transfert  matrix  
mesh: mesh or mesh3
Pk : the Pk def 
N : the number of componant
Whi: the FE space on Thi (def here)
Whij: the array of FE on each intersection 
Thij: the mesh variable to change Whij mesh
aThij: the array of intersect mesh with Thi

jpart[j]: the j th Sub Domain intersecting Thi
*/


matrix[int] sMj(jpart.n), rMj(jpart.n); /* M of send to j  */
fespace Whi(Thi,Pk);
mesh Thij=Thi;
fespace Whij(Thij,Pk);/*  */
 matrix Pii; 
{
 
 int njpart= jpart.n; /* njpart:  number of intersection which */
  Whi defPk#N(wpii,)=Times#N(pii);
  Pii = wpii[];
  for(int jp=0;jp<njpart;++jp)
    {
      int j=jpart[jp];
      Thij = aThij[jp];
      if(vdebug>99)savemesh(Thij,"Th-"+j+"--"+ipart+".mesh");
      int [int] U2Vdata=[0];
      matrix I = interpolate(Whij,Whi,U2Vc=U2Vdata); /* Whji <- Whi  */
      sMj[jp] = I*Pii;  /* Whi -> s Whij   */
      rMj[jp] = interpolate(Whij,Whi,t=1,U2Vc=U2Vdata);   /* Whji -> Whi  */
      if(vdebug>10) {
      {Whi defPk#N(uuu,)=Times#N(1); Whij defPk#N(vvv,)=Times#N(-1);
       cout << vvv[].n <<"+=" << I.n << "x" << I.m << "*" << uuu[].n << endl;
       vvv[]+=I*uuu[]; cout << jp << " %%% " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}
      {Whi  defPk#N(uuu,)=Times#N(1); Whij defPk#N(vvv,)=Times#N(-1) ;
       vvv[]+=rMj[jp]'*uuu[]; cout << jp << " ### " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}}
    }}
if(ipart==0) cout << " *** end build transfert matrix " << endl;
settt 

/* alloc array of send and recv data ..  */

InitUdef(jpart.n,Whij,Thij,aThij,Usend,N)  /* initU(n,Vh,Th,aTh,U) */
InitUdef(jpart.n,Whij,Thij,aThij,Vrecv,N) /* ... */
if(ipart==0) cout << " *** end init  data for send/revc  " << endl;
// 
/******************************************************************/ 
macro BuildTransferMat(ipart,mesh,Pk,N,U2V,Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)
 BuildTransferMat2(ipart,mesh,Pk,N,U2V,Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,Pii,vdebug)
 //
/******************************************************************/ 


/******************************************************************/ 
// usage uplot is  allu or [allu,allu1] :
macro PLOTMPIALLU(mesh,Pk,defPk, Th, u, uplot, plotparm)
{ int ver=verbosity;
  verbosity=2;
  if(NoGraphicWindow==0)
  {
  if(mpirank==0)
    {
      mesh Thi=Th;
      mesh[int] ath(mpisize);
      fespace Xh(Thi,Pk);
      Xh[int] defPk(allu,)(mpisize);
      allu[0][]=u;
      ath[0]=Th;
      mpiRequest[int] rq(mpisize);
      for(int i= 1; i <mpisize;++i)
	   Irecv(processor(i,rq[i]),ath[i]);
      for (int i=1;i<mpisize;++i)
       	int k= mpiWaitAny(rq);
      for (int i=1;i<mpisize;++i)
	   { Thi=ath[i];
	     Irecv(processor(i,rq[i]),allu[i][]);}
      for (int i=1;i<mpisize;++i)
       	int k= mpiWaitAny(rq); 
      plot(uplot,plotparm);
    }
  else
    {
      processor(0)<<Th;
      processor(0)<<u;
    }
  mpiBarrier(mpiCommWorld);
  }
  verbosity=ver;
  return true;
}
//EOM ...
/******************************************************************/ 

// Usage:
/* 
  extract the list of degre of freedom of 2d finite elemnt
    on connect boundary given by a list of label or on label
   the list is sort in direction of the +/- tangent 
   the  orientation 1: direct or -1 clockwise
   The parameter are: 
   - labs : int[int] ou int  to defined the boundary (in)
   - Wh  the fespace                                 (in)
   - int[int]  doflabs  (resize array)               (out)  
   - int orient : orientation of the border direct (1) or in direct -1 (in)
*/
macro ExtractDofsonBorder(labs,Wh,doflabs,orient)
{
mesh Th=Wh.Th;
fespace VhExtractDofsonBorder(Th,P1);
VhExtractDofsonBorder abslabs,onlon,atest;
real lenborder = int1d(Th,labs,qfe=qf1pElump)(1.);
if( lenborder >0) 
{
if(orient)
solve Pbabciss(abslabs,atest,solver=GMRES) 
= int2d(Th,qft=qf1pTlump)(abslabs*atest*1e-8/area)
  +  int1d(Th,labs,qfe=qf1pElump)([dx(abslabs),dy(abslabs)]'*[-N.y,+N.x]*atest)
  -  int1d(Th,labs,qfe=qf1pElump)(orient*atest);
  else abslabs= 1.; /* no sorting*/ 
  real abslabsmax = abs(2*abslabs[].max);
  varf vlabsneg(u,v) = on(labs,u=abslabs-abslabsmax);
  if(0)  plot(abslabs,wait=1);
  real[int] absc=vlabsneg(0,Wh);
  doflabs.resize(Wh.ndof);
  doflabs=0:Wh.ndof-1;
  sort(absc,doflabs);
  absc= absc? 1:0;
  doflabs.resize(absc.sum+0.5);
}
else 
 doflabs.resize(0);	
} 
//
load "medit"
include "getARGV.idp"

func f= 1. ; // right hand side function
func g=0.; ; // boundary condition function
func u0= 0;
real dt=getARGV("-dt",0.01);
int nn=getARGV("-n",10);
int imax=getARGV("-niter",10);
int op=getARGV("-op",1);
int pplot=getARGV("-plot",0);

mesh Th2D=square(nn,nn);
int[int] refm=[1,1,2,1,3,1,4,1];
int[int] refu=[0,1];
mesh3 Th=buildlayers(Th2D,nn,zbound=[0.,1.],labelmid=refm,labelup=refu,labeldown=refu);


// to slip integral on each processor 
// set a region number of a processor number 
real ccc = mpisize/real(Th.nt) ;
if(op) Th=change(Th,fregion= min(mpisize-1,int(nuTriangle* ccc+1e-10)));
else Th=change(Th,fregion=0);
int reg= op ? mpirank : 0;
//  end of trick
cout << "  *** Th: vol " << Th.mesure << "  " << int3d(Th,reg)(1.) << endl;
fespace Vh(Th,P2) ; // P1 FE space
Vh uh=u0 ; // unkown and test function.


real temps=clock();

real time1,time2,time6;
time1=clock();

// compute only on region number = processor number 
varf vlaplace(uh,vh) = // definition de problem
      int3d(Th,reg)( uh*vh+ dt*(dx(uh)*dx(vh) + dy(uh)*dy(vh)+ dz(uh)*dz(vh)) ) // bil. form
    + int3d(Th,reg)( dt*vh*f) + on(1,uh=g) ;
varf vmasse(u,v) = int3d(Th,reg)(u*v);
varf von1(uh,vh) = on(1,uh=1) ;

matrix AA = vlaplace(Vh,Vh,tgv=ttgv) ;
time1=clock()-time1;
// reduce the matrice to get the full matrice 
// warning the tgv number is now mpisize*tgv for B.C.
varf vffullpattern(u,v) = int2d(Th,qforder=1)(u*v);
matrix A=vffullpattern(Vh,Vh); 
time6=clock();
if(op) mpiAllReduce(AA,A,mpiCommWorld,mpiSUM);
else A=AA;

time6 = clock()-time6;
time2=clock();
set(A,solver=sparsesolver,tgv=ttgv) ; // factorize
time2=clock()-time2;

real time3=clock();
matrix M = vmasse(Vh,Vh);
time3=clock()-time3;

real [int] b(A.n),bb(A.n) ;
real[int] bcl= vlaplace(0,Vh,tgv=ttgv) ; // The B.C vector   
real[int] Gamma = von1(0,Vh,tgv=1);  // 

real time4=0,time5=0;

for(int i=0 ;i<imax;i++)
{

real time4tmp=clock();
bb = M*uh[];
bb += bcl ; 

time4=time4+(clock()-time4tmp);
real time6tmp=clock();
if(op) mpiAllReduce(bb,b,mpiCommWorld,mpiSUM);
else b=bb;
time6=time6+(clock()-time6tmp);
real time5tmp=clock();
uh[] = A^-1*b ; // resolution
time5=time5+(clock()-time5tmp);
	if(mpirank==0)
        cout << "  -- time " << (i+1)*dt << " ||uh|| " << uh[].linfty << " ||b|| " << b.linfty << endl;

}
//savesol("Heat-Time-"+imax+"-nn-"+nn+"-superludist.sol",Th,uh);
//savemesh(Th,"Heat-Time-"+imax+"-nn-"+nn+"-superludist.mesh");
cout << "Time resolution " << clock()-temps << endl;
if( mpirank==0 && pplot) medit("Heat",Th,uh);
cout << "======================================" << endl;
cout << " CPU TIME :                  " << endl;
cout << " matrix A                    " << time1 << endl;
cout << " factorization               " << time2 << endl;
cout << " mass matrix                 " << time3 << endl;
cout << " RHS  (Matrix vector Product with mass matrix)  " << endl;
cout << "                             " << time4/imax << endl;
cout << " solving                     " << time5/imax  << endl;
cout << " MpiReduce                   " << time6  << endl;
cout << " all                         " << clock()-temps << endl;
cout << "======================================" << endl;




// MPIGMRSmacro.idp  file..  version 0. 
// include in MPIGMRES.edp file ..
// Frederic Hecht 2010 
// LGPL licence 
// Author Frederic.Hecht@upmc.fr
// ------------------------------- 

//  macro to def // send-recv message 
// -----------------------------------


func real  maxM(matrix & A)
  {
  	int[int] I(1),J(1);
  	real[int] C(1);
  	[I,J,C] =A;
  	return C.max ;
  }
  
  
macro  InitU(n,Vh,Th,aTh,U)
Vh[int] U(n);
for(int j=0;j<n;++j)
  {  
  	 Th=aTh[j];
  	 U[j]=0;
  }
//EOM


macro   ISendRecvAny(comm,jpart,Si,Ri)
{ /* sorry no Irecv of complex objet ...*/
  int n= jpart.n,nn=n+n;
  if(vdebug) cout << mpirank << " --ISendRecvAny " << n << endl;
  mpiRequest[int] rq(nn);
  
  for (int j=0;j<n;++j)
    Irecv(processor(jpart[j],comm,rq[j]),Ri[j]);
  if(vdebug) cout << mpirank << " ++ISendRecvAny " << n << endl;
  
  for (int j=0;j<n;++j)
    Isend(processor(jpart[j],comm,rq[n+j]),Si[j]);
for (int j=0;j<nn;++j)
  {
  int k= mpiWaitAny(rq);
  if(vdebug)
    cout << " ++ISendRecvAny wait: get " << k << endl;
  }
}
//EOM


macro   SendRecvAny(comm,jpart,Si,Ri)
{  verbosity=200;
 	int n= jpart.n;
 	for (int j=0;j<n;++j)
       processor(comm,jpart[j]) << Si[j];
    cout << " ** wait revc " << endl;
 	for (int j=0;j<n;++j)
       processor(comm,jpart[j]) >> Ri[j];
}
// EOM 


macro CheckUV(comm,jpart,Si,Ri)
{
	    int ipart=mpiRank(comm);
	 	int n= jpart.n;
  		int[int] rn(n),sn(n),in(n);
 		for (int j=0;j<n;++j) 
 		  { sn[j]= Si[j][].n;		  	  
 		   processor(jpart[j],comm) << sn[j];
 		   processor(jpart[j],comm) << ipart;
 		  }
 		 for (int j=0;j<n;++j) 
 		   processor(jpart[j],comm) >> rn[j];
 		 for (int j=0;j<n;++j) 
 		   processor(jpart[j],comm) >> in[j];

 		 int err=0;
 		 for (int j=0;j<n;++j) 
 		  { 
 		   int rj=Ri[j][].n;
 		   err += rj != rn[j];
 		   cout << rj << " s ========= r " << rn[j] << "      " << ipart << " <->  " << in[j] << " " << err << endl;  
 		   
 		  }
 	     assert(err==0);
}//EOM


macro   SendRecvUV(comm,jpart,Si,Ri)
{
 	int n= jpart.n;
	mpiRequest[int] rq(n);
    for (int j=0;j<n;++j)
       Irecv(processor(jpart[j],comm,rq[j]), Ri[j][]);
       
 	for (int j=0;j<n;++j)
       processor(jpart[j],comm) << Si[j][];
  /* 	for (int j=0;j<n;++j)
       processor(jpart[j],comm) >> Ri[j][];*/
 
    for (int j=0;j<n;++j)
	   int k= mpiWaitAny(rq);
}
// EOF 


// file create:  awk -f gsl.awk  gsl_list  > ff_gsl_awk.hpp 
load "gsl"
gslrng ffrng;
 gslabortonerror=0; 
cout << "gsl_cdf_ugaussian_P(0.55) =  " << gslcdfugaussianP(0.55)  << endl; 
cout << "gsl_cdf_ugaussian_Q(0.55) =  " << gslcdfugaussianQ(0.55)  << endl; 
cout << "gsl_cdf_ugaussian_Pinv(0.55) =  " << gslcdfugaussianPinv(0.55)  << endl; 
cout << "gsl_cdf_ugaussian_Qinv(0.55) =  " << gslcdfugaussianQinv(0.55)  << endl; 
cout << "gsl_cdf_gaussian_P(0.55, 0.55) =  " << gslcdfgaussianP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_gaussian_Q(0.55, 0.55) =  " << gslcdfgaussianQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_gaussian_Pinv(0.55, 0.55) =  " << gslcdfgaussianPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_gaussian_Qinv(0.55, 0.55) =  " << gslcdfgaussianQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_gamma_P(0.55,0.55,0.55) =  " << gslcdfgammaP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gamma_Q(0.55,0.55,0.55) =  " << gslcdfgammaQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gamma_Pinv(0.55,0.55,0.55) =  " << gslcdfgammaPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gamma_Qinv(0.55,0.55,0.55) =  " << gslcdfgammaQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_cauchy_P(0.55, 0.55) =  " << gslcdfcauchyP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_cauchy_Q(0.55, 0.55) =  " << gslcdfcauchyQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_cauchy_Pinv(0.55, 0.55) =  " << gslcdfcauchyPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_cauchy_Qinv(0.55, 0.55) =  " << gslcdfcauchyQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_laplace_P(0.55, 0.55) =  " << gslcdflaplaceP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_laplace_Q(0.55, 0.55) =  " << gslcdflaplaceQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_laplace_Pinv(0.55, 0.55) =  " << gslcdflaplacePinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_laplace_Qinv(0.55, 0.55) =  " << gslcdflaplaceQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_rayleigh_P(0.55, 0.55) =  " << gslcdfrayleighP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_rayleigh_Q(0.55, 0.55) =  " << gslcdfrayleighQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_rayleigh_Pinv(0.55, 0.55) =  " << gslcdfrayleighPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_rayleigh_Qinv(0.55, 0.55) =  " << gslcdfrayleighQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_chisq_P(0.55, 0.55) =  " << gslcdfchisqP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_chisq_Q(0.55, 0.55) =  " << gslcdfchisqQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_chisq_Pinv(0.55, 0.55) =  " << gslcdfchisqPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_chisq_Qinv(0.55, 0.55) =  " << gslcdfchisqQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_exponential_P(0.55, 0.55) =  " << gslcdfexponentialP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_exponential_Q(0.55, 0.55) =  " << gslcdfexponentialQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_exponential_Pinv(0.55, 0.55) =  " << gslcdfexponentialPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_exponential_Qinv(0.55, 0.55) =  " << gslcdfexponentialQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_exppow_P(0.55,0.55,0.55) =  " << gslcdfexppowP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_exppow_Q(0.55,0.55,0.55) =  " << gslcdfexppowQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_tdist_P(0.55, 0.55) =  " << gslcdftdistP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_tdist_Q(0.55, 0.55) =  " << gslcdftdistQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_tdist_Pinv(0.55, 0.55) =  " << gslcdftdistPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_tdist_Qinv(0.55, 0.55) =  " << gslcdftdistQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_fdist_P(0.55,0.55,0.55) =  " << gslcdffdistP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_fdist_Q(0.55,0.55,0.55) =  " << gslcdffdistQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_fdist_Pinv(0.55,0.55,0.55) =  " << gslcdffdistPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_fdist_Qinv(0.55,0.55,0.55) =  " << gslcdffdistQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_beta_P(0.55,0.55,0.55) =  " << gslcdfbetaP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_beta_Q(0.55,0.55,0.55) =  " << gslcdfbetaQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_beta_Pinv(0.55,0.55,0.55) =  " << gslcdfbetaPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_beta_Qinv(0.55,0.55,0.55) =  " << gslcdfbetaQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_flat_P(0.55,0.55,0.55) =  " << gslcdfflatP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_flat_Q(0.55,0.55,0.55) =  " << gslcdfflatQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_flat_Pinv(0.55,0.55,0.55) =  " << gslcdfflatPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_flat_Qinv(0.55,0.55,0.55) =  " << gslcdfflatQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_lognormal_P(0.55,0.55,0.55) =  " << gslcdflognormalP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_lognormal_Q(0.55,0.55,0.55) =  " << gslcdflognormalQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_lognormal_Pinv(0.55,0.55,0.55) =  " << gslcdflognormalPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_lognormal_Qinv(0.55,0.55,0.55) =  " << gslcdflognormalQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel1_P(0.55,0.55,0.55) =  " << gslcdfgumbel1P(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel1_Q(0.55,0.55,0.55) =  " << gslcdfgumbel1Q(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel1_Pinv(0.55,0.55,0.55) =  " << gslcdfgumbel1Pinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel1_Qinv(0.55,0.55,0.55) =  " << gslcdfgumbel1Qinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel2_P(0.55,0.55,0.55) =  " << gslcdfgumbel2P(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel2_Q(0.55,0.55,0.55) =  " << gslcdfgumbel2Q(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel2_Pinv(0.55,0.55,0.55) =  " << gslcdfgumbel2Pinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_gumbel2_Qinv(0.55,0.55,0.55) =  " << gslcdfgumbel2Qinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_weibull_P(0.55,0.55,0.55) =  " << gslcdfweibullP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_weibull_Q(0.55,0.55,0.55) =  " << gslcdfweibullQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_weibull_Pinv(0.55,0.55,0.55) =  " << gslcdfweibullPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_weibull_Qinv(0.55,0.55,0.55) =  " << gslcdfweibullQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_pareto_P(0.55,0.55,0.55) =  " << gslcdfparetoP(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_pareto_Q(0.55,0.55,0.55) =  " << gslcdfparetoQ(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_pareto_Pinv(0.55,0.55,0.55) =  " << gslcdfparetoPinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_pareto_Qinv(0.55,0.55,0.55) =  " << gslcdfparetoQinv(0.55,0.55,0.55)  << endl; 
cout << "gsl_cdf_logistic_P(0.55, 0.55) =  " << gslcdflogisticP(0.55, 0.55)  << endl; 
cout << "gsl_cdf_logistic_Q(0.55, 0.55) =  " << gslcdflogisticQ(0.55, 0.55)  << endl; 
cout << "gsl_cdf_logistic_Pinv(0.55, 0.55) =  " << gslcdflogisticPinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_logistic_Qinv(0.55, 0.55) =  " << gslcdflogisticQinv(0.55, 0.55)  << endl; 
cout << "gsl_cdf_binomial_P(0,0.55,0) =  " << gslcdfbinomialP(0,0.55,0)  << endl; 
cout << "gsl_cdf_binomial_Q(0,0.55,0) =  " << gslcdfbinomialQ(0,0.55,0)  << endl; 
cout << "gsl_cdf_poisson_P(0, 0.55) =  " << gslcdfpoissonP(0, 0.55)  << endl; 
cout << "gsl_cdf_poisson_Q(0, 0.55) =  " << gslcdfpoissonQ(0, 0.55)  << endl; 
cout << "gsl_cdf_geometric_P(0, 0.55) =  " << gslcdfgeometricP(0, 0.55)  << endl; 
cout << "gsl_cdf_geometric_Q(0, 0.55) =  " << gslcdfgeometricQ(0, 0.55)  << endl; 
cout << "gsl_cdf_negative_binomial_P(0,0.55,0.55) =  " << gslcdfnegativebinomialP(0,0.55,0.55)  << endl; 
cout << "gsl_cdf_negative_binomial_Q(0,0.55,0.55) =  " << gslcdfnegativebinomialQ(0,0.55,0.55)  << endl; 
cout << "gsl_cdf_pascal_P(0,0.55,0) =  " << gslcdfpascalP(0,0.55,0)  << endl; 
cout << "gsl_cdf_pascal_Q(0,0.55,0) =  " << gslcdfpascalQ(0,0.55,0)  << endl; 
cout << "gsl_ran_bernoulli_pdf(0, 0.55) =  " << gslranbernoullipdf(0, 0.55)  << endl; 
cout << "gsl_ran_beta(ffrng,0.55,0.55) =  " << gslranbeta(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_beta_pdf(0.55,0.55,0.55) =  " << gslranbetapdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_binomial_pdf(0,0.55,0) =  " << gslranbinomialpdf(0,0.55,0)  << endl; 
cout << "gsl_ran_exponential(ffrng, 0.55) =  " << gslranexponential(ffrng, 0.55)  << endl; 
cout << "gsl_ran_exponential_pdf(0.55, 0.55) =  " << gslranexponentialpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_exppow(ffrng,0.55,0.55) =  " << gslranexppow(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_exppow_pdf(0.55,0.55,0.55) =  " << gslranexppowpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_cauchy(ffrng, 0.55) =  " << gslrancauchy(ffrng, 0.55)  << endl; 
cout << "gsl_ran_cauchy_pdf(0.55, 0.55) =  " << gslrancauchypdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_chisq(ffrng, 0.55) =  " << gslranchisq(ffrng, 0.55)  << endl; 
cout << "gsl_ran_chisq_pdf(0.55, 0.55) =  " << gslranchisqpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_erlang(ffrng,0.55,0.55) =  " << gslranerlang(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_erlang_pdf(0.55,0.55,0.55) =  " << gslranerlangpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_fdist(ffrng,0.55,0.55) =  " << gslranfdist(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_fdist_pdf(0.55,0.55,0.55) =  " << gslranfdistpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_flat(ffrng,0.55,0.55) =  " << gslranflat(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_flat_pdf(0.55,0.55,0.55) =  " << gslranflatpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_gamma(ffrng,0.55,0.55) =  " << gslrangamma(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_gamma_int(ffrng, 0) =  " << gslrangammaint(ffrng, 0)  << endl; 
cout << "gsl_ran_gamma_pdf(0.55,0.55,0.55) =  " << gslrangammapdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_gamma_mt(ffrng,0.55,0.55) =  " << gslrangammamt(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_gamma_knuth(ffrng,0.55,0.55) =  " << gslrangammaknuth(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_gaussian(ffrng, 0.55) =  " << gslrangaussian(ffrng, 0.55)  << endl; 
cout << "gsl_ran_gaussian_ratio_method(ffrng, 0.55) =  " << gslrangaussianratiomethod(ffrng, 0.55)  << endl; 
cout << "gsl_ran_gaussian_ziggurat(ffrng, 0.55) =  " << gslrangaussianziggurat(ffrng, 0.55)  << endl; 
cout << "gsl_ran_gaussian_pdf(0.55, 0.55) =  " << gslrangaussianpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_ugaussian(ffrng) =  " << gslranugaussian(ffrng)  << endl; 
cout << "gsl_ran_ugaussian_ratio_method(ffrng) =  " << gslranugaussianratiomethod(ffrng)  << endl; 
cout << "gsl_ran_ugaussian_pdf(0.55) =  " << gslranugaussianpdf(0.55)  << endl; 
cout << "gsl_ran_gaussian_tail(ffrng,0.55,0.55) =  " << gslrangaussiantail(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_gaussian_tail_pdf(0.55,0.55,0.55) =  " << gslrangaussiantailpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_ugaussian_tail(ffrng, 0.55) =  " << gslranugaussiantail(ffrng, 0.55)  << endl; 
cout << "gsl_ran_ugaussian_tail_pdf(0.55, 0.55) =  " << gslranugaussiantailpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_landau(ffrng) =  " << gslranlandau(ffrng)  << endl; 
cout << "gsl_ran_landau_pdf(0.55) =  " << gslranlandaupdf(0.55)  << endl; 
cout << "gsl_ran_geometric_pdf(0, 0.55) =  " << gslrangeometricpdf(0, 0.55)  << endl; 
cout << "gsl_ran_gumbel1(ffrng,0.55,0.55) =  " << gslrangumbel1(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_gumbel1_pdf(0.55,0.55,0.55) =  " << gslrangumbel1pdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_gumbel2(ffrng,0.55,0.55) =  " << gslrangumbel2(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_gumbel2_pdf(0.55,0.55,0.55) =  " << gslrangumbel2pdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_logistic(ffrng, 0.55) =  " << gslranlogistic(ffrng, 0.55)  << endl; 
cout << "gsl_ran_logistic_pdf(0.55, 0.55) =  " << gslranlogisticpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_lognormal(ffrng,0.55,0.55) =  " << gslranlognormal(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_lognormal_pdf(0.55,0.55,0.55) =  " << gslranlognormalpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_logarithmic_pdf(0, 0.55) =  " << gslranlogarithmicpdf(0, 0.55)  << endl; 
cout << "gsl_ran_negative_binomial_pdf(0,0.55,0.55) =  " << gslrannegativebinomialpdf(0,0.55,0.55)  << endl; 
cout << "gsl_ran_pascal_pdf(0,0.55,0) =  " << gslranpascalpdf(0,0.55,0)  << endl; 
cout << "gsl_ran_pareto(ffrng,0.55,0.55) =  " << gslranpareto(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_pareto_pdf(0.55,0.55,0.55) =  " << gslranparetopdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_poisson_pdf(0, 0.55) =  " << gslranpoissonpdf(0, 0.55)  << endl; 
cout << "gsl_ran_rayleigh(ffrng, 0.55) =  " << gslranrayleigh(ffrng, 0.55)  << endl; 
cout << "gsl_ran_rayleigh_pdf(0.55, 0.55) =  " << gslranrayleighpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_rayleigh_tail(ffrng,0.55,0.55) =  " << gslranrayleightail(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_rayleigh_tail_pdf(0.55,0.55,0.55) =  " << gslranrayleightailpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_ran_tdist(ffrng, 0.55) =  " << gslrantdist(ffrng, 0.55)  << endl; 
cout << "gsl_ran_tdist_pdf(0.55, 0.55) =  " << gslrantdistpdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_laplace(ffrng, 0.55) =  " << gslranlaplace(ffrng, 0.55)  << endl; 
cout << "gsl_ran_laplace_pdf(0.55, 0.55) =  " << gslranlaplacepdf(0.55, 0.55)  << endl; 
cout << "gsl_ran_levy(ffrng,0.55,0.55) =  " << gslranlevy(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_weibull(ffrng,0.55,0.55) =  " << gslranweibull(ffrng,0.55,0.55)  << endl; 
cout << "gsl_ran_weibull_pdf(0.55,0.55,0.55) =  " << gslranweibullpdf(0.55,0.55,0.55)  << endl; 
cout << "gsl_sf_airy_Ai(0.55, 0) =  " << gslsfairyAi(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Bi(0.55, 0) =  " << gslsfairyBi(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Ai_scaled(0.55, 0) =  " << gslsfairyAiscaled(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Bi_scaled(0.55, 0) =  " << gslsfairyBiscaled(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Ai_deriv(0.55, 0) =  " << gslsfairyAideriv(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Bi_deriv(0.55, 0) =  " << gslsfairyBideriv(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Ai_deriv_scaled(0.55, 0) =  " << gslsfairyAiderivscaled(0.55, 0)  << endl; 
cout << "gsl_sf_airy_Bi_deriv_scaled(0.55, 0) =  " << gslsfairyBiderivscaled(0.55, 0)  << endl; 
cout << "gsl_sf_airy_zero_Ai(0) =  " << gslsfairyzeroAi(0)  << endl; 
cout << "gsl_sf_airy_zero_Bi(0) =  " << gslsfairyzeroBi(0)  << endl; 
cout << "gsl_sf_airy_zero_Ai_deriv(0) =  " << gslsfairyzeroAideriv(0)  << endl; 
cout << "gsl_sf_airy_zero_Bi_deriv(0) =  " << gslsfairyzeroBideriv(0)  << endl; 
cout << "gsl_sf_bessel_J0(0.55) =  " << gslsfbesselJ0(0.55)  << endl; 
cout << "gsl_sf_bessel_J1(0.55) =  " << gslsfbesselJ1(0.55)  << endl; 
cout << "gsl_sf_bessel_Jn(0, 0.55) =  " << gslsfbesselJn(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_Y0(0.55) =  " << gslsfbesselY0(0.55)  << endl; 
cout << "gsl_sf_bessel_Y1(0.55) =  " << gslsfbesselY1(0.55)  << endl; 
cout << "gsl_sf_bessel_Yn(0, 0.55) =  " << gslsfbesselYn(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_I0(0.55) =  " << gslsfbesselI0(0.55)  << endl; 
cout << "gsl_sf_bessel_I1(0.55) =  " << gslsfbesselI1(0.55)  << endl; 
cout << "gsl_sf_bessel_In(0, 0.55) =  " << gslsfbesselIn(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_I0_scaled(0.55) =  " << gslsfbesselI0scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_I1_scaled(0.55) =  " << gslsfbesselI1scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_In_scaled(0, 0.55) =  " << gslsfbesselInscaled(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_K0(0.55) =  " << gslsfbesselK0(0.55)  << endl; 
cout << "gsl_sf_bessel_K1(0.55) =  " << gslsfbesselK1(0.55)  << endl; 
cout << "gsl_sf_bessel_Kn(0, 0.55) =  " << gslsfbesselKn(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_K0_scaled(0.55) =  " << gslsfbesselK0scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_K1_scaled(0.55) =  " << gslsfbesselK1scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_Kn_scaled(0, 0.55) =  " << gslsfbesselKnscaled(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_j0(0.55) =  " << gslsfbesselj0(0.55)  << endl; 
cout << "gsl_sf_bessel_j1(0.55) =  " << gslsfbesselj1(0.55)  << endl; 
cout << "gsl_sf_bessel_j2(0.55) =  " << gslsfbesselj2(0.55)  << endl; 
cout << "gsl_sf_bessel_jl(0, 0.55) =  " << gslsfbesseljl(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_y0(0.55) =  " << gslsfbessely0(0.55)  << endl; 
cout << "gsl_sf_bessel_y1(0.55) =  " << gslsfbessely1(0.55)  << endl; 
cout << "gsl_sf_bessel_y2(0.55) =  " << gslsfbessely2(0.55)  << endl; 
cout << "gsl_sf_bessel_yl(0, 0.55) =  " << gslsfbesselyl(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_i0_scaled(0.55) =  " << gslsfbesseli0scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_i1_scaled(0.55) =  " << gslsfbesseli1scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_i2_scaled(0.55) =  " << gslsfbesseli2scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_il_scaled(0, 0.55) =  " << gslsfbesselilscaled(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_k0_scaled(0.55) =  " << gslsfbesselk0scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_k1_scaled(0.55) =  " << gslsfbesselk1scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_k2_scaled(0.55) =  " << gslsfbesselk2scaled(0.55)  << endl; 
cout << "gsl_sf_bessel_kl_scaled(0, 0.55) =  " << gslsfbesselklscaled(0, 0.55)  << endl; 
cout << "gsl_sf_bessel_Jnu(0.55, 0.55) =  " << gslsfbesselJnu(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_Ynu(0.55, 0.55) =  " << gslsfbesselYnu(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_Inu_scaled(0.55, 0.55) =  " << gslsfbesselInuscaled(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_Inu(0.55, 0.55) =  " << gslsfbesselInu(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_Knu_scaled(0.55, 0.55) =  " << gslsfbesselKnuscaled(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_Knu(0.55, 0.55) =  " << gslsfbesselKnu(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_lnKnu(0.55, 0.55) =  " << gslsfbessellnKnu(0.55, 0.55)  << endl; 
cout << "gsl_sf_bessel_zero_J0(0) =  " << gslsfbesselzeroJ0(0)  << endl; 
cout << "gsl_sf_bessel_zero_J1(0) =  " << gslsfbesselzeroJ1(0)  << endl; 
cout << "gsl_sf_bessel_zero_Jnu(0.55, 0) =  " << gslsfbesselzeroJnu(0.55, 0)  << endl; 
cout << "gsl_sf_clausen(0.55) =  " << gslsfclausen(0.55)  << endl; 
cout << "gsl_sf_hydrogenicR_1(0.55, 0.55) =  " << gslsfhydrogenicR1(0.55, 0.55)  << endl; 
cout << "gsl_sf_dawson(0.55) =  " << gslsfdawson(0.55)  << endl; 
cout << "gsl_sf_debye_1(0.55) =  " << gslsfdebye1(0.55)  << endl; 
cout << "gsl_sf_debye_2(0.55) =  " << gslsfdebye2(0.55)  << endl; 
cout << "gsl_sf_debye_3(0.55) =  " << gslsfdebye3(0.55)  << endl; 
cout << "gsl_sf_debye_4(0.55) =  " << gslsfdebye4(0.55)  << endl; 
cout << "gsl_sf_debye_5(0.55) =  " << gslsfdebye5(0.55)  << endl; 
cout << "gsl_sf_debye_6(0.55) =  " << gslsfdebye6(0.55)  << endl; 
cout << "gsl_sf_dilog(0.55) =  " << gslsfdilog(0.55)  << endl; 
cout << "gsl_sf_multiply(0.55, 0.55) =  " << gslsfmultiply(0.55, 0.55)  << endl; 
cout << "gsl_sf_ellint_Kcomp(0.55, 0) =  " << gslsfellintKcomp(0.55, 0)  << endl; 
cout << "gsl_sf_ellint_Ecomp(0.55, 0) =  " << gslsfellintEcomp(0.55, 0)  << endl; 
cout << "gsl_sf_ellint_Pcomp(0.55,0.55,0) =  " << gslsfellintPcomp(0.55,0.55,0)  << endl; 
cout << "gsl_sf_ellint_Dcomp(0.55, 0) =  " << gslsfellintDcomp(0.55, 0)  << endl; 
cout << "gsl_sf_ellint_F(0.55,0.55,0) =  " << gslsfellintF(0.55,0.55,0)  << endl; 
cout << "gsl_sf_ellint_E(0.55,0.55,0) =  " << gslsfellintE(0.55,0.55,0)  << endl; 
cout << "gsl_sf_ellint_RC(0.55,0.55,0) =  " << gslsfellintRC(0.55,0.55,0)  << endl; 
cout << "gsl_sf_erfc(0.55) =  " << gslsferfc(0.55)  << endl; 
cout << "gsl_sf_log_erfc(0.55) =  " << gslsflogerfc(0.55)  << endl; 
cout << "gsl_sf_erf(0.55) =  " << gslsferf(0.55)  << endl; 
cout << "gsl_sf_erf_Z(0.55) =  " << gslsferfZ(0.55)  << endl; 
cout << "gsl_sf_erf_Q(0.55) =  " << gslsferfQ(0.55)  << endl; 
cout << "gsl_sf_hazard(0.55) =  " << gslsfhazard(0.55)  << endl; 
cout << "gsl_sf_exp(0.55) =  " << gslsfexp(0.55)  << endl; 
cout << "gsl_sf_exp_mult(0.55, 0.55) =  " << gslsfexpmult(0.55, 0.55)  << endl; 
cout << "gsl_sf_expm1(0.55) =  " << gslsfexpm1(0.55)  << endl; 
cout << "gsl_sf_exprel(0.55) =  " << gslsfexprel(0.55)  << endl; 
cout << "gsl_sf_exprel_2(0.55) =  " << gslsfexprel2(0.55)  << endl; 
cout << "gsl_sf_exprel_n(0, 0.55) =  " << gslsfexpreln(0, 0.55)  << endl; 
cout << "gsl_sf_expint_E1(0.55) =  " << gslsfexpintE1(0.55)  << endl; 
cout << "gsl_sf_expint_E2(0.55) =  " << gslsfexpintE2(0.55)  << endl; 
cout << "gsl_sf_expint_En(0, 0.55) =  " << gslsfexpintEn(0, 0.55)  << endl; 
cout << "gsl_sf_expint_E1_scaled(0.55) =  " << gslsfexpintE1scaled(0.55)  << endl; 
cout << "gsl_sf_expint_E2_scaled(0.55) =  " << gslsfexpintE2scaled(0.55)  << endl; 
cout << "gsl_sf_expint_En_scaled(0, 0.55) =  " << gslsfexpintEnscaled(0, 0.55)  << endl; 
cout << "gsl_sf_expint_Ei(0.55) =  " << gslsfexpintEi(0.55)  << endl; 
cout << "gsl_sf_expint_Ei_scaled(0.55) =  " << gslsfexpintEiscaled(0.55)  << endl; 
cout << "gsl_sf_Shi(0.55) =  " << gslsfShi(0.55)  << endl; 
cout << "gsl_sf_Chi(0.55) =  " << gslsfChi(0.55)  << endl; 
cout << "gsl_sf_expint_3(0.55) =  " << gslsfexpint3(0.55)  << endl; 
cout << "gsl_sf_Si(0.55) =  " << gslsfSi(0.55)  << endl; 
cout << "gsl_sf_Ci(0.55) =  " << gslsfCi(0.55)  << endl; 
cout << "gsl_sf_atanint(0.55) =  " << gslsfatanint(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_m1(0.55) =  " << gslsffermidiracm1(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_0(0.55) =  " << gslsffermidirac0(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_1(0.55) =  " << gslsffermidirac1(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_2(0.55) =  " << gslsffermidirac2(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_int(0, 0.55) =  " << gslsffermidiracint(0, 0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_mhalf(0.55) =  " << gslsffermidiracmhalf(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_half(0.55) =  " << gslsffermidirachalf(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_3half(0.55) =  " << gslsffermidirac3half(0.55)  << endl; 
cout << "gsl_sf_fermi_dirac_inc_0(0.55, 0.55) =  " << gslsffermidiracinc0(0.55, 0.55)  << endl; 
cout << "gsl_sf_lngamma(0.55) =  " << gslsflngamma(0.55)  << endl; 
cout << "gsl_sf_gamma(0.55) =  " << gslsfgamma(0.55)  << endl; 
cout << "gsl_sf_gammastar(0.55) =  " << gslsfgammastar(0.55)  << endl; 
cout << "gsl_sf_gammainv(0.55) =  " << gslsfgammainv(0.55)  << endl; 
cout << "gsl_sf_taylorcoeff(0, 0.55) =  " << gslsftaylorcoeff(0, 0.55)  << endl; 
cout << "gsl_sf_fact(0) =  " << gslsffact(0)  << endl; 
cout << "gsl_sf_doublefact(0) =  " << gslsfdoublefact(0)  << endl; 
cout << "gsl_sf_lnfact(0) =  " << gslsflnfact(0)  << endl; 
cout << "gsl_sf_lndoublefact(0) =  " << gslsflndoublefact(0)  << endl; 
cout << "gsl_sf_lnchoose(0, 0) =  " << gslsflnchoose(0, 0)  << endl; 
cout << "gsl_sf_choose(0, 0) =  " << gslsfchoose(0, 0)  << endl; 
cout << "gsl_sf_lnpoch(0.55, 0.55) =  " << gslsflnpoch(0.55, 0.55)  << endl; 
cout << "gsl_sf_poch(0.55, 0.55) =  " << gslsfpoch(0.55, 0.55)  << endl; 
cout << "gsl_sf_pochrel(0.55, 0.55) =  " << gslsfpochrel(0.55, 0.55)  << endl; 
cout << "gsl_sf_gamma_inc_Q(0.55, 0.55) =  " << gslsfgammaincQ(0.55, 0.55)  << endl; 
cout << "gsl_sf_gamma_inc_P(0.55, 0.55) =  " << gslsfgammaincP(0.55, 0.55)  << endl; 
cout << "gsl_sf_gamma_inc(0.55, 0.55) =  " << gslsfgammainc(0.55, 0.55)  << endl; 
cout << "gsl_sf_lnbeta(0.55, 0.55) =  " << gslsflnbeta(0.55, 0.55)  << endl; 
cout << "gsl_sf_beta(0.55, 0.55) =  " << gslsfbeta(0.55, 0.55)  << endl; 
cout << "gsl_sf_beta_inc(0.55,0.55,0.55) =  " << gslsfbetainc(0.55,0.55,0.55)  << endl; 
cout << "gsl_sf_gegenpoly_1(0.55, 0.55) =  " << gslsfgegenpoly1(0.55, 0.55)  << endl; 
cout << "gsl_sf_gegenpoly_2(0.55, 0.55) =  " << gslsfgegenpoly2(0.55, 0.55)  << endl; 
cout << "gsl_sf_gegenpoly_3(0.55, 0.55) =  " << gslsfgegenpoly3(0.55, 0.55)  << endl; 
cout << "gsl_sf_gegenpoly_n(0,0.55,0.55) =  " << gslsfgegenpolyn(0,0.55,0.55)  << endl; 
cout << "gsl_sf_hyperg_0F1(0.55, 0.55) =  " << gslsfhyperg0F1(0.55, 0.55)  << endl; 
cout << "gsl_sf_hyperg_1F1_int(0,0,0.55) =  " << gslsfhyperg1F1int(0,0,0.55)  << endl; 
cout << "gsl_sf_hyperg_1F1(0.55,0.55,0.55) =  " << gslsfhyperg1F1(0.55,0.55,0.55)  << endl; 
cout << "gsl_sf_hyperg_U_int(0,0,0.55) =  " << gslsfhypergUint(0,0,0.55)  << endl; 
cout << "gsl_sf_hyperg_U(0.55,0.55,0.55) =  " << gslsfhypergU(0.55,0.55,0.55)  << endl; 
cout << "gsl_sf_hyperg_2F0(0.55,0.55,0.55) =  " << gslsfhyperg2F0(0.55,0.55,0.55)  << endl; 
cout << "gsl_sf_laguerre_1(0.55, 0.55) =  " << gslsflaguerre1(0.55, 0.55)  << endl; 
cout << "gsl_sf_laguerre_2(0.55, 0.55) =  " << gslsflaguerre2(0.55, 0.55)  << endl; 
cout << "gsl_sf_laguerre_3(0.55, 0.55) =  " << gslsflaguerre3(0.55, 0.55)  << endl; 
cout << "gsl_sf_laguerre_n(0,0.55,0.55) =  " << gslsflaguerren(0,0.55,0.55)  << endl; 
cout << "gsl_sf_lambert_W0(0.55) =  " << gslsflambertW0(0.55)  << endl; 
cout << "gsl_sf_lambert_Wm1(0.55) =  " << gslsflambertWm1(0.55)  << endl; 
cout << "gsl_sf_legendre_Pl(0, 0.55) =  " << gslsflegendrePl(0, 0.55)  << endl; 
cout << "gsl_sf_legendre_P1(0.55) =  " << gslsflegendreP1(0.55)  << endl; 
cout << "gsl_sf_legendre_P2(0.55) =  " << gslsflegendreP2(0.55)  << endl; 
cout << "gsl_sf_legendre_P3(0.55) =  " << gslsflegendreP3(0.55)  << endl; 
cout << "gsl_sf_legendre_Q0(0.55) =  " << gslsflegendreQ0(0.55)  << endl; 
cout << "gsl_sf_legendre_Q1(0.55) =  " << gslsflegendreQ1(0.55)  << endl; 
cout << "gsl_sf_legendre_Ql(0, 0.55) =  " << gslsflegendreQl(0, 0.55)  << endl; 
cout << "gsl_sf_legendre_Plm(0,0,0.55) =  " << gslsflegendrePlm(0,0,0.55)  << endl; 
cout << "gsl_sf_legendre_sphPlm(0,0,0.55) =  " << gslsflegendresphPlm(0,0,0.55)  << endl; 
//cout << "gsl_sf_legendre_array_size(0, 0) =  " << gslsflegendrearraysize(0, 0)  << endl; 
cout << "gsl_sf_conicalP_half(0.55, 0.55) =  " << gslsfconicalPhalf(0.55, 0.55)  << endl; 
cout << "gsl_sf_conicalP_mhalf(0.55, 0.55) =  " << gslsfconicalPmhalf(0.55, 0.55)  << endl; 
cout << "gsl_sf_conicalP_0(0.55, 0.55) =  " << gslsfconicalP0(0.55, 0.55)  << endl; 
cout << "gsl_sf_conicalP_1(0.55, 0.55) =  " << gslsfconicalP1(0.55, 0.55)  << endl; 
cout << "gsl_sf_conicalP_sph_reg(0,0.55,0.55) =  " << gslsfconicalPsphreg(0,0.55,0.55)  << endl; 
cout << "gsl_sf_conicalP_cyl_reg(0,0.55,0.55) =  " << gslsfconicalPcylreg(0,0.55,0.55)  << endl; 
cout << "gsl_sf_legendre_H3d_0(0.55, 0.55) =  " << gslsflegendreH3d0(0.55, 0.55)  << endl; 
cout << "gsl_sf_legendre_H3d_1(0.55, 0.55) =  " << gslsflegendreH3d1(0.55, 0.55)  << endl; 
cout << "gsl_sf_legendre_H3d(0,0.55,0.55) =  " << gslsflegendreH3d(0,0.55,0.55)  << endl; 
cout << "gsl_sf_log(0.55) =  " << gslsflog(0.55)  << endl; 
cout << "gsl_sf_log_abs(0.55) =  " << gslsflogabs(0.55)  << endl; 
cout << "gsl_sf_log_1plusx(0.55) =  " << gslsflog1plusx(0.55)  << endl; 
cout << "gsl_sf_log_1plusx_mx(0.55) =  " << gslsflog1plusxmx(0.55)  << endl; 
cout << "gsl_sf_pow_int(0.55, 0) =  " << gslsfpowint(0.55, 0)  << endl; 
cout << "gsl_sf_psi_int(0) =  " << gslsfpsiint(0)  << endl; 
cout << "gsl_sf_psi(0.55) =  " << gslsfpsi(0.55)  << endl; 
cout << "gsl_sf_psi_1piy(0.55) =  " << gslsfpsi1piy(0.55)  << endl; 
cout << "gsl_sf_psi_1_int(0) =  " << gslsfpsi1int(0)  << endl; 
cout << "gsl_sf_psi_1(0.55) =  " << gslsfpsi1(0.55)  << endl; 
cout << "gsl_sf_psi_n(0, 0.55) =  " << gslsfpsin(0, 0.55)  << endl; 
cout << "gsl_sf_synchrotron_1(0.55) =  " << gslsfsynchrotron1(0.55)  << endl; 
cout << "gsl_sf_synchrotron_2(0.55) =  " << gslsfsynchrotron2(0.55)  << endl; 
cout << "gsl_sf_transport_2(0.55) =  " << gslsftransport2(0.55)  << endl; 
cout << "gsl_sf_transport_3(0.55) =  " << gslsftransport3(0.55)  << endl; 
cout << "gsl_sf_transport_4(0.55) =  " << gslsftransport4(0.55)  << endl; 
cout << "gsl_sf_transport_5(0.55) =  " << gslsftransport5(0.55)  << endl; 
cout << "gsl_sf_sin(0.55) =  " << gslsfsin(0.55)  << endl; 
cout << "gsl_sf_cos(0.55) =  " << gslsfcos(0.55)  << endl; 
cout << "gsl_sf_hypot(0.55, 0.55) =  " << gslsfhypot(0.55, 0.55)  << endl; 
cout << "gsl_sf_sinc(0.55) =  " << gslsfsinc(0.55)  << endl; 
cout << "gsl_sf_lnsinh(0.55) =  " << gslsflnsinh(0.55)  << endl; 
cout << "gsl_sf_lncosh(0.55) =  " << gslsflncosh(0.55)  << endl; 
cout << "gsl_sf_angle_restrict_symm(0.55) =  " << gslsfanglerestrictsymm(0.55)  << endl; 
cout << "gsl_sf_angle_restrict_pos(0.55) =  " << gslsfanglerestrictpos(0.55)  << endl; 
cout << "gsl_sf_zeta_int(0) =  " << gslsfzetaint(0)  << endl; 
cout << "gsl_sf_zeta(0.55) =  " << gslsfzeta(0.55)  << endl; 
cout << "gsl_sf_zetam1(0.55) =  " << gslsfzetam1(0.55)  << endl; 
cout << "gsl_sf_zetam1_int(0) =  " << gslsfzetam1int(0)  << endl; 
cout << "gsl_sf_hzeta(0.55, 0.55) =  " << gslsfhzeta(0.55, 0.55)  << endl; 
cout << "gsl_sf_eta_int(0) =  " << gslsfetaint(0)  << endl; 
cout << "gsl_sf_eta(0.55) =  " << gslsfeta(0.55)  << endl; 
load "scotch"
load "metis"

/*# beginPartition #*/
macro ffddmbuildDmeshf(prmesh, Th, partdof, sizeoverlaps)
if (prmesh#isincomm)
{	
  prmesh#tic(prmesh#tdecompi)
  if (!prmesh#excluded) {
    int backup = searchMethod;
    searchMethod = 1;

    int ssplit = max(prmesh#inexactCSsplit,1);

    prmesh#overlap = sizeoverlaps*ssplit;

    if (prmesh#npart == 1) {
      if (ffddmsplit*ssplit == 1)
        prmesh#Thi = Th;
      else
        prmesh#Thi=trunc(Th,1,split=ssplit*ffddmsplit);                 /* freefem's trick, formal definition*/

      prmesh#aTh[0]=prmesh#Thi;
      real[int] one(prmesh#VhiP1.ndof);
      one=1.;
      prmesh#RihP1[0]=one;
      prmesh#DP1[0]=1.;
    }
    else 
    for(int ii=0;ii<prmesh#npart;++ii)
    if ((!bpara) || (ii == mpiRank(prmesh#commddm))) {
      
      int[int] arrayIntersectioni;
      
      int numberIntersectioni = 0;
      
      prmesh#meshN overlapName=Th;
      fespace VhGlobalff(overlapName, P1);
      fespace PhGlobalff(overlapName, P0);
      PhGlobalff part;
      part[]=partdof;
      
      PhGlobalff supp = abs(part - ii) < 0.1;
      VhGlobalff suppSmooth;
      AddLayers(overlapName, supp[], (sizeoverlaps == 0) + sizeoverlaps * 2, suppSmooth[]);
      {   
        prmesh#meshN neighbors = trunc(overlapName, suppSmooth > 0.001 && (suppSmooth < 0.999));
        fespace Oh(neighbors, P0);
        Oh partOverlap = part;
        
        Unique(partOverlap[], arrayIntersectioni);          
        
      }
      
      prmesh#VhiP1[int] partitionIntersectioni(arrayIntersectioni.n);
      prmesh#partitionIntersectionbasei.resize(arrayIntersectioni.n);

      IFMACRO(!prmesh#partcubes)
      if(ffddmsplit>1) {
        overlapName = trunc(overlapName, suppSmooth > 0.001, split = ffddmsplit, label=9999);
        supp = abs(part - ii) < 0.1;
        suppSmooth = 0;
        AddLayers(overlapName, supp[], (sizeoverlaps == 0) + 2 * sizeoverlaps, suppSmooth[]);
      }
      ENDIFMACRO

      prmesh#Thi = trunc(overlapName, suppSmooth > 0.001, split=ssplit);
      overlapName = trunc(overlapName, suppSmooth > 0.001, label=9999);

      supp = supp;
      suppSmooth = suppSmooth;

      prmesh#meshN borderName;
      if (sizeoverlaps > 0) {

        IFMACRO(prmesh#partcubes,1)
        prmesh#Thi=trunc(overlapName, abs(part - ii) < 0.1, label = 9999);
        real lx, ly, lz, ux, uy, uz;
        lx = ly = lz = 1e+30;
        ux = uy = uz = -1.e+30;
        int[int] labs(6), labsi(6);
        labs = 0;

        for (int ii=0; ii<prmesh#Thi.nbe; ii++) {
          for (int jj=0; jj < dimension; jj++){
            lx = min(lx,prmesh#Thi.be(ii)[jj].x); ux = max(ux,prmesh#Thi.be(ii)[jj].x);
            ly = min(ly,prmesh#Thi.be(ii)[jj].y); uy = max(uy,prmesh#Thi.be(ii)[jj].y);
            IFMACRO(dimension,3)
            lz = min(lz,prmesh#Thi.be(ii)[jj].z); uz = max(uz,prmesh#Thi.be(ii)[jj].z);
            ENDIFMACRO
          }
        }

        int samex, samey, samez;

        for (int ii=0; ii<prmesh#Thi.nbe; ii++) {
          IFMACRO(dimension,2)
          samex = (prmesh#Thi.be(ii)[0].x == prmesh#Thi.be(ii)[1].x);
          samey = (prmesh#Thi.be(ii)[0].y == prmesh#Thi.be(ii)[1].y);
          ENDIFMACRO
          IFMACRO(dimension,3)
          samex = (prmesh#Thi.be(ii)[0].x == prmesh#Thi.be(ii)[1].x) && (prmesh#Thi.be(ii)[1].x == prmesh#Thi.be(ii)[2].x);
          samey = (prmesh#Thi.be(ii)[0].y == prmesh#Thi.be(ii)[1].y) && (prmesh#Thi.be(ii)[1].y == prmesh#Thi.be(ii)[2].y);
          samez = (prmesh#Thi.be(ii)[0].z == prmesh#Thi.be(ii)[1].z) && (prmesh#Thi.be(ii)[1].z == prmesh#Thi.be(ii)[2].z);
          ENDIFMACRO
          if (prmesh#Thi.be(ii).label != 9999) {
                 if (samex && prmesh#Thi.be(ii)[0].x == lx) labs[0] = prmesh#Thi.be(ii).label;
            else if (samex && prmesh#Thi.be(ii)[0].x == ux) labs[1] = prmesh#Thi.be(ii).label;
            else if (samey && prmesh#Thi.be(ii)[0].y == ly) labs[2] = prmesh#Thi.be(ii).label;
            else if (samey && prmesh#Thi.be(ii)[0].y == uy) labs[3] = prmesh#Thi.be(ii).label;
            IFMACRO(dimension,3)
            else if (samez && prmesh#Thi.be(ii)[0].z == lz) labs[4] = prmesh#Thi.be(ii).label;
            else if (samez && prmesh#Thi.be(ii)[0].z == uz) labs[5] = prmesh#Thi.be(ii).label;
            ENDIFMACRO
          }
        }
        IFMACRO(dimension,2)
        real p0x = prmesh#Thi(prmesh#Thi[0][0]).x, p0y = prmesh#Thi(prmesh#Thi[0][0]).y;
        real p1x = prmesh#Thi(prmesh#Thi[0][1]).x, p1y = prmesh#Thi(prmesh#Thi[0][1]).y;
        real p2x = prmesh#Thi(prmesh#Thi[0][2]).x, p2y = prmesh#Thi(prmesh#Thi[0][2]).y;
        real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2),sqrt((p2x-p0x)^2+(p2y-p0y)^2));
        ENDIFMACRO
        IFMACRO(dimension,3)
        real p0x = prmesh#Thi(prmesh#Thi.be(0)[0]).x, p0y = prmesh#Thi(prmesh#Thi.be(0)[0]).y, p0z = prmesh#Thi(prmesh#Thi.be(0)[0]).z;
        real p1x = prmesh#Thi(prmesh#Thi.be(0)[1]).x, p1y = prmesh#Thi(prmesh#Thi.be(0)[1]).y, p1z = prmesh#Thi(prmesh#Thi.be(0)[1]).z;
        real p2x = prmesh#Thi(prmesh#Thi.be(0)[2]).x, p2y = prmesh#Thi(prmesh#Thi.be(0)[2]).y, p2z = prmesh#Thi(prmesh#Thi.be(0)[2]).z;
        real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2+(p1z-p0z)^2), sqrt((p2x-p0x)^2+(p2y-p0y)^2+(p2z-p0z)^2));
        ENDIFMACRO

        h /= ffddmsplit;

        lx -= h*sizeoverlaps*(!labs[0]); ly -= h*sizeoverlaps*(!labs[2]); lz -= h*sizeoverlaps*(!labs[4]);
        ux += h*sizeoverlaps*(!labs[1]); uy += h*sizeoverlaps*(!labs[3]); uz += h*sizeoverlaps*(!labs[5]);

        labsi = labs ? labs : ffddmcubelabels;

        IFMACRO(dimension,2)
        int[int] L = [labsi[2],labsi[1],labsi[3],labsi[0]];
        prmesh#Thi = square(rint((ux-lx)/h),rint((uy-ly)/h),[x*(ux-lx)+lx,y*(uy-ly)+ly],label=L);
        ENDIFMACRO
        IFMACRO(dimension,3)
        include "cube.idp"
        int[int] NN=[rint((ux-lx)/h), rint((uy-ly)/h), rint((uz-lz)/h)];
        real [int,int] BB=[[lx,ux],[ly,uy],[lz,uz]];
        int [int,int] L=[[labsi[0],labsi[1]],[labsi[2],labsi[3]],[labsi[4],labsi[5]]];
        prmesh#Thi = Cube(NN,BB,L);
        ENDIFMACRO

        lx -= h*(!labs[0]); ly -= h*(!labs[2]); lz -= h*(!labs[4]);
        ux += h*(!labs[1]); uy += h*(!labs[3]); uz += h*(!labs[5]);

        labsi = labs ? labs : (abs(ffddminterfacelabel) + 1) * 100;

        IFMACRO(dimension,2)
        int[int] Lb = [labsi[2],labsi[1],labsi[3],labsi[0]];
        borderName = square(rint((ux-lx)/h),rint((uy-ly)/h),[x*(ux-lx)+lx,y*(uy-ly)+ly],label=Lb);
        ENDIFMACRO
        IFMACRO(dimension,3)
        int[int] NNb=[rint((ux-lx)/h), rint((uy-ly)/h), rint((uz-lz)/h)];
        real [int,int] BBb=[[lx,ux],[ly,uy],[lz,uz]];
        int [int,int] Lb=[[labsi[0],labsi[1]],[labsi[2],labsi[3]],[labsi[4],labsi[5]]];
        borderName = Cube(NNb,BBb,Lb);
        ENDIFMACRO

        fespace PhborderName(borderName,P0);
        fespace Phii(prmesh#Thi,P0);
        matrix Riiborder = interpolate(Phii, PhborderName);
        Phii parti = 1;
        PhborderName partborder;
        partborder[] = Riiborder'*parti[];
        borderName = trunc(borderName, partborder==0, label = (abs(ffddminterfacelabel) + 1) * 100);

        overlapName = prmesh#Thi;
        supp = abs(part - ii) < 0.1;
        suppSmooth = 0;

        parti = part;
        prmesh#partloc.resize(Phii.ndof);
        prmesh#partloc = parti[];
        ENDIFMACRO

        IFMACRO(!prmesh#partcubes)
        prmesh#Thi = trunc(prmesh#Thi, suppSmooth> 0.501, label = ffddminterfacelabel);
        if (prmesh#Thi.nt != overlapName.nt)
          borderName = trunc(overlapName, (suppSmooth > (sizeoverlaps - 0.999) / (2 * sizeoverlaps)) && (suppSmooth < 0.501), label = (abs(ffddminterfacelabel) + 1) * 100);
        ENDIFMACRO
      }
      else {
        fespace fP0(prmesh#Thi,P0);
        fP0 part0 = part;
        prmesh#Thi = trunc(prmesh#Thi, abs(part - ii) < 0.1, label = ffddminterfacelabel);
        borderName = trunc(overlapName, suppSmooth < 0.999, label = (abs(ffddminterfacelabel) + 1) * 100);
      }
      
      prmesh#VhiP1 khi;
      if (sizeoverlaps > 0) {
        khi = max(suppSmooth*2 - 1.0, 0.) ;
        if(usedARGV("-steep") != -1)
        khi = khi > 0.001 ? 1.0 : 0.0;

        else if (usedARGV("-raspart") != -1) {
          VhGlobalff phir;
          PhGlobalff suppP0 = abs(ii - part) < 0.1;
          varf vSuppi(u,v) = prmesh#intN(overlapName,qforder=1)(suppP0*v);
          phir[] = vSuppi(0,VhGlobalff);
          phir = phir > 0.;
          khi = phir;
        }
      }
      else {
        khi[] = 1.;
      }
      
      prmesh#VhiP1 sum = khi;
      VhGlobalff phi = 0, phibase = 0;
      
      /*real eps=int2d(overlapName)(1.);*/
      real eps = prmesh#intN(overlapName)(1.0);
      real[int] epsn(arrayIntersectioni.n);
      if(bpara){ /* version for very ugly meshes, not implemented yet for bseq*/        
        mpiRequest[int] rqn(2*arrayIntersectioni.n);
        for(int j=0;j<arrayIntersectioni.n;++j)
        Isend(processor(arrayIntersectioni[j],prmesh#commddm,rqn[j*2]),eps);
        for(int j=0;j<arrayIntersectioni.n;++j)
        Irecv(processor(arrayIntersectioni[j],prmesh#commddm,rqn[j*2+1]),epsn[j]);
        for(int j=0;j<2*arrayIntersectioni.n;++j) {
          int k = mpiWaitAny(rqn);
        }
      }    
      for(int i = 0; i < arrayIntersectioni.n; ++i) {
        PhGlobalff suppPartition = abs(arrayIntersectioni[i] - part) < 0.1;
        
        PhGlobalff suppP0;
        suppP0[] = suppPartition[];
        if (sizeoverlaps > 0) {
          AddLayers(overlapName, suppPartition[], sizeoverlaps, phi[]);
          phibase[] = phi[];

          if(usedARGV("-steep") != -1)
            phi = phi > 0.001 ? 1.0 : 0.0;
          else if (usedARGV("-raspart") != -1) {
            VhGlobalff phir;
            varf vSuppi(u,v) = prmesh#intN(overlapName,qforder=1)(suppP0*v);
            phir[] = vSuppi(0,VhGlobalff);
            phir = phir > 0.;
            phi = phir;
          }
        }
        else {
          VhGlobalff phir;
          varf vSuppi(u,v) = prmesh#intN(overlapName,qforder=1)(suppP0*v);
          phir[] = vSuppi(0,VhGlobalff);
          phir = phir > 0.;
          phi = phir;
          phibase[] = phi[];
        }
        
        /*real intersection=prmesh#intN(overlapName)(phibase)/eps;*/
        /*if(arrayIntersectioni[i] <=1)*/
        real epsi=0;
        if(bpara){ /* version for very ugly meshes, not implemented yet for bseq */
          epsi = min(eps,epsn[i]);
        }
        else{
          epsi = eps;	
        }   
        real intersection;
        if (prmesh#overlap > 0)
          intersection = prmesh#intN(overlapName)(phibase) / epsi;
        else {
          partitionIntersectioni[numberIntersectioni] = phi;
          intersection = partitionIntersectioni[numberIntersectioni][].max;
        }
        if( intersection>1e-6)
        {
          partitionIntersectioni[numberIntersectioni] = phi;
          
          prmesh#partitionIntersectionbasei[numberIntersectioni] = phibase;
          
          sum[] += partitionIntersectioni[numberIntersectioni][];
          arrayIntersectioni[numberIntersectioni++] = arrayIntersectioni[i];
        }
        
      }
      
      khi[] = khi[] ./= sum[];

      overlapName = prmesh#minimalMesh;
      if(numberIntersectioni != arrayIntersectioni.n)
      arrayIntersectioni.resize(numberIntersectioni);  
      
      /* PoU for inexactsplit > 1 */
      if (prmesh#inexactCSsplit > 1) {
        
        fespace Phi(prmesh#Thi,P0);
        Phi suppP0i = abs(ii - part) < 0.1;
        varf vSuppii(u,v) = prmesh#intN(prmesh#Thi,qforder=1)(suppP0i*v);
        prmesh#VhiP1 phiri;
        phiri[] = vSuppii(0,prmesh#VhiP1);
        phiri = phiri > 0.; 
        
        prmesh#VhiP1 sumi = phiri;
        
        for(int i = 0; i < arrayIntersectioni.n; ++i) {    
          Phi suppP0n = abs(arrayIntersectioni[i] - part) < 0.1;
          varf vSuppin(u,v) = prmesh#intN(prmesh#Thi,qforder=1)(suppP0n*v);
          prmesh#VhiP1 phirn;
          phirn[] = vSuppin(0,prmesh#VhiP1);
          phirn = phirn > 0.; 
          sumi[] += phirn[];  
        }   
        
        khi[] = phiri[] ./= sumi[];      
      }
      
      if (bpara) {
        prmesh#numberIntersection = numberIntersectioni;
        prmesh#arrayIntersection.resize(prmesh#numberIntersection);
        prmesh#arrayIntersection = arrayIntersectioni;
      }
      
      if(!bnoGlob)
      {
        fespace prmesh#VhglobP1(prmesh#Thglob,P1);
        prmesh#RihP1[ii]=interpolate(prmesh#VhiP1,prmesh#VhglobP1);
        
        
        int[int] I(1),J(1);
        real[int] Kc(1);
        [I,J,Kc] = prmesh#RihP1[ii];
        for (int i=0;i<Kc.n;i++)
        if (Kc[i] > 0.99)
        Kc[i] = 1.;
        prmesh#RihP1[ii] = [I,J,Kc];
        
        prmesh#RihP1[ii].thresholding(1e-10);
        prmesh#RihP1[ii].resize(prmesh#VhiP1.ndof,prmesh#VhglobP1.ndof);
      }	
      
      prmesh#aTh[ii]=prmesh#Thi;
      prmesh#aThborder[ii]=trunc(borderName,1,split=ssplit);

      if (bpara && prmesh#overlap == 0) {
        IFMACRO(prmesh#mminoverlap,1)
        fespace prmesh#PhAugP0(prmesh#AugThi,P0);
        prmesh#PhAugP0 phaug = part;
        prmesh#partAug.resize(prmesh#PhAugP0.ndof);
        prmesh#partAug = phaug[];
        ENDIFMACRO
        IFMACRO(prmesh#mminoverlap,0)
        cout << "["+Stringification(prmesh)+"] ffddmbuildDmesh PB: you need to define macro \""+Stringification(prmesh)+"mminoverlap\" to 1 when using overlap=0, e.g. by adding \"-D"+Stringification(prmesh)+"mminoverlap=1\" to the command line" << endl;
        assert(0);
        ENDIFMACRO
        ;
      }

      prmesh#DP1[ii] = khi;

      if (!bnopartloc) {
        fespace Phii0(prmesh#Thi,P0);
        Phii0 prmesh#p0 = part;
        prmesh#partloc.resize(Phii0.ndof);
        prmesh#partloc = prmesh#p0[];
      }
    }
    searchMethod = backup;
  }

  if (bseq)
  prmesh#Thi = prmesh#Thglob;

  prmesh#toc(prmesh#tdecompi,"",prmesh#tdecomp)
} 
//EOM

macro ffddminitDmeshf(prmesh,comm)
IFMACRO(!prmesh#meshinit)

IFMACRO(((!prmesh#dim)&(dimension,2))|(prmesh#dim,2))
NewMacro prmesh#meshN()mesh EndMacro             /* two-dimensional problem  */
NewMacro prmesh#intN()int2d EndMacro             /* two-dimensional integral */
NewMacro prmesh#intbN()int1d EndMacro            /* one-dimensional integral */
NewMacro prmesh#minimalMesh()square(1,1) EndMacro
ENDIFMACRO

IFMACRO(((!prmesh#dim)&(dimension,3))|(prmesh#dim,3))
NewMacro prmesh#meshN()mesh3 EndMacro            /* three-dimensional problem  */
NewMacro prmesh#intN()int3d EndMacro             /* three-dimensional integral */
NewMacro prmesh#intbN()int2d EndMacro            /* two-dimensional integral   */
NewMacro prmesh#minimalMesh()cube(1,1,1) EndMacro
ENDIFMACRO

IFMACRO(((!prmesh#dim)&(dimension,3S))|(prmesh#dim,3S))
NewMacro prmesh#meshN()meshS EndMacro            /* three-dimensional surface problem */
NewMacro prmesh#intN()int2d EndMacro
NewMacro prmesh#intbN()int1d EndMacro
NewMacro prmesh#minimalMesh()square3(1,1,[x,y,z]) EndMacro
ENDIFMACRO

IFMACRO(((!prmesh#dim)&(dimension,3L))|(prmesh#dim,3L))
NewMacro prmesh#meshN()meshL EndMacro            /* three-dimensional line problem */
NewMacro prmesh#intN()int1d EndMacro
NewMacro prmesh#intbN()int0d EndMacro
NewMacro prmesh#minimalMesh()Sline(2,[x,y,z]) EndMacro
ENDIFMACRO

int prmesh#npart = ffddmnpart;

/*int prmesh#verbosity = ffddmverbosity;*/

real prmesh#tdecompi;
real prmesh#tdecomp = 0;

NewMacro prmesh#tic(tim) tim = mpiWtime(); EndMacro
NewMacro prmesh#toc(tim,msg,totaltime)
if (prmesh#isincomm)
{
  tim = mpiWtime() - tim;
  
  real ttimeg = 0;
  mpiAllReduce(tim,ttimeg,prmesh#mpicomm,mpiMAX);
  if ((mpiRank(prmesh#mpicomm) == 0) /*&& (prmesh#verbosity > 0)*/ && (msg != ""))
  cout << "["+Stringification(prmesh)+"] timings - " << msg << " : " << ttimeg << " s" << endl;
  totaltime += ttimeg;
  
  /*totaltime += tim;*/
}
EndMacro

NewMacro prmesh#toccomm(tim,msg,totaltime,comm)
if (prmesh#isincomm)
{
  tim = mpiWtime() - tim;
  
  real ttimeg = 0;
  mpiAllReduce(tim,ttimeg,comm,mpiMAX);
  if ((mpiRank(comm) == 0) && (msg != ""))
  cout << "["+Stringification(prmesh)+"] timings - " << msg << " : " << ttimeg << " s" << endl;
  totaltime += ttimeg;
  
  /*totaltime += tim;*/
}
EndMacro

prmesh#meshN prmesh#Thi = prmesh#minimalMesh;

fespace prmesh#VhiP1(prmesh#Thi,P1);

prmesh#VhiP1[int] prmesh#partitionIntersectionbasei(0);

int prmesh#overlap = 0;

int prmesh#numberIntersection = 0;

int[int] prmesh#arrayIntersection(0);

prmesh#meshN prmesh#Thglob = prmesh#minimalMesh;

matrix[int] prmesh#RihP1(prmesh#npart);
prmesh#VhiP1[int] prmesh#DP1(prmesh#npart);

NewMacro prmesh#mpicomm()comm EndMacro

int[int] prmesh#procddm = [mpirank];
int[int] prmesh#procCS = [mpirank];

int prmesh#isincomm = (mpiRank(comm) >= 0);

int prmesh#excluded = !prmesh#isincomm;

if (prmesh#isincomm) {
  int[int] globranks(mpiSize(comm));
  int myglobrank = mpirank;
  
  mpiAllgather(myglobrank,globranks,comm);
  
  if ((prmesh#pCS > 1) && (mpiRank(comm) < prmesh#pCS)) {
    prmesh#procCS.resize(prmesh#pCS);
    for (int i=0; i<prmesh#pCS;i++)
    prmesh#procCS[i] = globranks[i];
  }
  
  if (!prmesh#exclude) {
    prmesh#procddm.resize(mpiSize(comm));
    if (mpiSize(comm) > 1)
    for (int i=0; i<mpiSize(comm);i++)
    prmesh#procddm[i] = globranks[i];
    else
    prmesh#procddm = [mpirank];
  }
  else {
    prmesh#procddm.resize(mpiSize(comm)-prmesh#pCS);
    if (mpiSize(comm) > 1)
    for (int i=0; i<mpiSize(comm)-prmesh#pCS;i++)
    prmesh#procddm[i] = globranks[i+prmesh#pCS];
    else
    prmesh#procddm = [mpirank];
    if (mpiRank(comm) < prmesh#pCS)
    prmesh#excluded = 1;
  }
}

mpiGroup prmesh#grpddm(prmesh#procddm);
mpiComm prmesh#commddm(mpiCommWorld,prmesh#grpddm);
mpiGroup prmesh#grpCS(prmesh#procCS);
mpiComm prmesh#commCS(mpiCommWorld,prmesh#grpCS);

int[int] prmesh#procself = [mpiRank(mpiCommWorld)];
mpiGroup prmesh#grpself(prmesh#procself);
mpiComm prmesh#commself(mpiCommWorld,prmesh#grpself);

/*  Domain decomposition data structures */
prmesh#meshN[int] prmesh#aTh(prmesh#npart);        /* sequence of ovr. meshes */
prmesh#meshN[int] prmesh#aThborder(prmesh#npart);

real[int] prmesh#partAug(1);
real[int] prmesh#partloc(1);

NewMacro prmesh#meshinit()1 EndMacro
ENDIFMACRO
// EOM

macro ffddmpartf(prmesh,Th,res)
{
  prmesh#tic(prmesh#tdecompi)
  
  fespace prmesh#Ph0(Th,P0);
  prmesh#Ph0 upart;                                  /* piecewise constant function */
  int[int] lpart(prmesh#Ph0.ndof);                       /* giving the decomposition */
  
  if (bpara){
    if (!prmesh#excluded && mpiRank(prmesh#commddm)==0 && (prmesh#npart != mpiSize(prmesh#commddm))) {
      cout << "bpara option PB: npart==" << prmesh#npart << " != mpiSize(commddm)==" << mpiSize(prmesh#commddm) << endl;
      assert(prmesh#npart == mpiSize(prmesh#commddm));
    }
  }
  
  if(!prmesh#excluded) {
    if (prmesh#npart == 1) {
      upart[] = 0.; 
    }
    else if(ffddmpartitioner != 0) {
      if(ffddmpartitioner == 2) {
        if (mpiRank(prmesh#commddm) == 0) {
          scotch(lpart,Th,prmesh#npart);
          for(int i=0;i<lpart.n;++i)
          upart[][i]=lpart[i];    
        }   
        broadcast(processor(0, prmesh#commddm), upart[]);
      }
      else {
        if (mpiRank(prmesh#commddm) == 0) {
          metisdual(lpart,Th,prmesh#npart);
          for(int i=0;i<lpart.n;++i)
          upart[][i]=lpart[i];
        }   
        broadcast(processor(0, prmesh#commddm), upart[]);
      }
    }
    else {
      IFMACRO (!prmesh#simple)
      if (mpiRank(prmesh#commddm) == 0)
      cout << "["+Stringification(prmesh)+"] partitioner option PB: you must declare a \'"+Stringification(prmesh)+"simple\' partitioning macro when using ffddmpartitioner = 0" << endl;
      assert(0);
      ENDIFMACRO
      IFMACRO (prmesh#simple)
      prmesh#simple(prmesh#Ph0, upart, prmesh#commddm)
      ENDIFMACRO
    }    	
    
    if (ffddmbplot && (mpiRank(prmesh#commddm) == 0 && ffddmverbosity >= 5)) {
      if (ffddmbffplot)
      plot(upart,wait=0,cmm="partition",value=1,fill=1);
      if (ffddmbmedit)
      medit("partition",Th,upart);
    }
    
    res.resize(upart[].n);
    res = upart[];
  }
  
  prmesh#toc(prmesh#tdecompi,"",prmesh#tdecomp)
}
// EOM

macro ffddminitDfespacef(prfe,prmsh,scalar,udef,uinit,mPk,udefpart,uinitpart,mPkP0)
IFMACRO(!prfe#feinit)
NewMacro prfe#prmesh()prmsh EndMacro

NewMacro prfe#K scalar EndMacro
NewMacro prfe#mdef udef EndMacro
NewMacro prfe#minit uinit EndMacro

NewMacro prfe#mdefpart udefpart EndMacro
NewMacro prfe#minitpart uinitpart EndMacro

NewMacro prfe#fPk mPk EndMacro
NewMacro prfe#fPkP0 mPkP0 EndMacro

fespace prfe#Vhi(prmsh#Thi,prfe#fPk);

fespace prfe#Vhglob(prmsh#Thglob,prfe#fPk);

prfe#K[int][int] prfe#Dk(prmsh#npart);

matrix<prfe#K>[int] prfe#Rih(prmsh#npart);               /* local restriction operators  */
matrix<prfe#K>[int] prfe#Dih(prmsh#npart);               /* partition of unity operators */

matrix<prfe#K>[int] prfe#restrictionIntersection(0);

/* communication buffers */
prfe#K[int][int] prfe#rcv(0);
prfe#K[int][int] prfe#snd(0);

int prfe#Ndofglobal = 0;

IFMACRO(prmsh#buildAug,1)
matrix prfe#Auginterp;
ENDIFMACRO

/* Update u_i = R_i sum_j (R_j' u_j)
   if (scale) u_i = R_i sum_j (R_j' D_j u_j)
   using communication buffers in the overlap */
func int prfe#update(scalar[int] vv, bool scale)
{
  if (!prmsh#excluded)
  {
    if (scale)
      vv = vv .* prfe#Dk[mpiRank(prmsh#commddm)];
    mpiRequest[int] rq(prmsh#numberIntersection*2);
    for(int j=0;j<prmsh#numberIntersection;++j)
      prfe#snd[j] = prfe#restrictionIntersection[j]*vv;
    for(int j=0;j<prmsh#numberIntersection;++j)
      Isend(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2]),prfe#snd[j]);
    for(int j=0;j<prmsh#numberIntersection;++j)
      Irecv(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2+1]),prfe#rcv[j]);
    for(int j=0;j<prmsh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);
    for(int j=0;j<prmsh#numberIntersection;++j)
      vv += prfe#restrictionIntersection[j]'*prfe#rcv[j];
  }
  return 0;
}

func int prfe#updatematrix(matrix<scalar>& m, bool scale)
{
  if (!prmsh#excluded)
  {
    matrix<scalar>[int] rest(prmsh#arrayIntersection.n);
    matrix<scalar>[int] restSend(prmsh#arrayIntersection.n);

    mpiRequest[int] rq(prmsh#numberIntersection*2);
    for(int j=0;j<prmsh#numberIntersection;++j) {
      restSend[j] = m;
      IFMACRO(prfe#K,real)
      renumbering(restSend[j],prfe#restrictionIntersection[j],eps=-1);
      ENDIFMACRO
      IFMACRO(prfe#K,complex)
      matrix restreal = prfe#restrictionIntersection[j].re;
      renumbering(restSend[j],restreal,eps=-1);
      ENDIFMACRO
      Isend(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2]),restSend[j]);
    }
    for(int j=0;j<prmsh#numberIntersection;++j)
      Irecv(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2+1]),rest[j]);
    for(int j=0;j<prmsh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);
    for(int j=0;j<prmsh#numberIntersection;++j) {
      matrix<scalar> extens = prfe#restrictionIntersection[j]'*rest[j];
      extens = extens*prfe#restrictionIntersection[j];
      m = m + extens;
    }
  }
  return 0;
}

func int prfe#updatematrix(scalar[int,int]& m, bool scale)
{
  if (!prmsh#excluded)
  {
    scalar[int,int][int] rest(prmsh#arrayIntersection.n);
    scalar[int,int][int] restSend(prmsh#arrayIntersection.n);

    mpiRequest[int] rq(prmsh#numberIntersection*2);
    for(int jj=0;jj<prmsh#numberIntersection;++jj) {
      int[int] tI(1), tJ(1);
      scalar[int] tK(1);
      [tI,tJ,tK] = prfe#restrictionIntersection[jj];
      if (tK[tK.n-1] == 0) tJ.resize(tJ.n-1);
      restSend[jj].resize(tJ.n, tJ.n);
      rest[jj].resize(tJ.n, tJ.n);
      for [i,j,aij : restSend[jj]] aij = m(tJ[i],tJ[j]);
      Isend(processor(prmsh#arrayIntersection[jj],prmsh#commddm,rq[jj*2]),restSend[jj]);
    }
    for(int jj=0;jj<prmsh#numberIntersection;++jj)
      Irecv(processor(prmsh#arrayIntersection[jj],prmsh#commddm,rq[jj*2+1]),rest[jj]);
    for(int jj=0;jj<prmsh#numberIntersection*2;++jj)
      int k = mpiWaitAny(rq);
    for(int jj=0;jj<prmsh#numberIntersection;++jj) {
      int[int] tI(1), tJ(1);
      scalar[int] tK(1);
      [tI,tJ,tK] = prfe#restrictionIntersection[jj];
      if (tK[tK.n-1] == 0) tJ.resize(tJ.n-1);
      for [i,j,aij : rest[jj]] m(tJ[i],tJ[j]) += aij;
    }
  }
  return 0;
}

IFMACRO (prfe#myscalprod)
prfe#myscalprod
ENDIFMACRO
IFMACRO (!prfe#myscalprod)
func scalar prfe#scalprod(scalar[int] va, scalar[int] vb)
{
  scalar res = 0;
  if(prmsh#isincomm) {
    /*prmsh#tic(prfe#tloc)*/
    scalar resi = 0;
    if (!bpara) {
      resi = va '* vb;
    }
    else if (!prmsh#excluded){
      scalar[int] sa = va .* prfe#Dk[mpiRank(prmsh#commddm)];
      resi = sa '* vb;
    }
    mpiAllReduce(resi,res,prmsh#mpicomm,mpiSUM);
    /*prmsh#toc(prfe#tloc,"",prfe#tscalprod)*/
  }
  return res;
}
ENDIFMACRO

NewMacro prfe#mplot(u,s)
  if (prmsh#isincomm) {
    if (ffddmbplot) {	
      fespace VhP1(prmsh#Thglob,P1);
      VhP1 solplot;
      if (!bpara) {
        if (mpiRank(prmsh#mpicomm) == 0)
        solplot = u;
      }
      else if (!prmsh#excluded){   
        prmsh#VhiP1 v = u;
        v[] = prmsh#DP1[mpiRank(prmsh#commddm)][].*v[];
        VhP1 tmp;
        tmp[] = prmsh#RihP1[mpiRank(prmsh#commddm)]'*v[];
        solplot[] = 0;
        mpiReduce(tmp[],solplot[],processor(0,prmsh#commddm),mpiSUM);
      }
      if (mpiRank(prmsh#commddm) == 0) {
        if (ffddmbmedit)
        medit(s,prmsh#Thglob,solplot);
        if (ffddmbffplot)
        plot(solplot,dim=3,wait=0,cmm=s, value =1,fill=1,nbiso=ffddmnbiso);     
      }
    }
  }
EndMacro

NewMacro prfe#buildtransferfromVhi(VhName,Pknew)
IFMACRO(!prfe#transferMat#VhName#init)
IFMACRO(prfe#K,real)
load "PETSc"
ENDIFMACRO
IFMACRO(prfe#K,complex)
load "PETSc-complex"
ENDIFMACRO
include "macro_ddm.idp"
Mat<prfe#K> prfe#transferMat#VhName;
matrix<prfe#K> prfe#transferMat#VhName#restrict;
ENDIFMACRO

if (prmsh#isincomm)
{
assert(!bnopartloc);
fespace prfe#Phtransfer(prmsh#Thi,P0);
prfe#Phtransfer partkP0;
partkP0[] = prmsh#partloc;
prmsh#meshN Ths = trunc(prmsh#Thi, abs(partkP0 - mpirank) < 1e-2);
reconstructDmesh(Ths)
Mat<prfe#K> Mats;
createMat(Ths, Mats, prfe#fPk)

matrix<prfe#K> At(VhName.ndof, VhName.ndof);
Mat<prfe#K> Matt(At);

prmsh#meshN Thtarget = VhName.Th;

transferMat(Ths, prfe#fPk, Mats, Thtarget, Pknew, Matt, prfe#transferMat#VhName)

fespace prfe#Vhitransfer(Ths,prfe#fPk);
matrix R = interpolate(prfe#Vhitransfer,prfe#Vhi);
prfe#transferMat#VhName#restrict = R;
}

IFMACRO(!prfe#transferMat#VhName#init)
NewMacro prfe#transferMat#VhName#init()1 EndMacro
ENDIFMACRO
EndMacro

NewMacro prfe#transferfromVhi(ui,VhName,Pknew,res)
IFMACRO(!prfe#transferMat#VhName#init)
prfe#buildtransferfromVhi(VhName,Pknew)
ENDIFMACRO

if (prmsh#isincomm)
{
prfe#K[int] rui = prfe#transferMat#VhName#restrict*ui[];
res[] = prfe#transferMat#VhName*rui;
}
EndMacro

NewMacro prfe#feinit()1 EndMacro
ENDIFMACRO
// EOM

macro ffddmbuildDfespacef(prfe,prmsh,scalar,udef,uinit,mPk,udefpart,uinitpart,mPkP0)

ffddminitDfespacef(prfe,prmsh,scalar,udef,uinit,mPk,udefpart,uinitpart,mPkP0)

prfe#Ndofglobal = prfe#Vhglob.ndof;

if (!bpara && ffddmverbosity)
cout << "["+Stringification(prfe)+"] (seqddm) ndof = " << prfe#Ndofglobal << endl;

if (prmsh#isincomm && !prmsh#excluded)
{
  for(int ii=0;ii<prmsh#npart;++ii)
  if ((!bpara) || (ii == mpiRank(prmsh#commddm))) {
    prmsh#Thi = prmsh#aTh[ii];
    fespace Vhipart(prmsh#Thi,prfe#fPkP0);
    Vhipart udefpart(utmp) = uinitpart(prmsh#DP1[ii]);

    Vhipart udefpart(usum);
    if (prmsh#overlap == 0){
      utmp[] = 1;
      usum[] = 1;
    }
    
    if (bpara) {
      int backup = searchMethod;
      searchMethod = 1;
      prfe#rcv.resize(prmsh#numberIntersection);
      prfe#snd.resize(prmsh#numberIntersection);
      prfe#restrictionIntersection.resize(prmsh#numberIntersection);
      for(int i=0;i<prmsh#numberIntersection;++i) {
          matrix R;
          int[int] n2o(1);
          if (prmsh#overlap > 0) {

            IFMACRO(prmsh#partcubes,1)
            fespace Phii(prmsh#Thi,P0);
            Phii parti;
            parti[] = prmsh#partloc;
            prmsh#meshN meshIntersection = trunc(prmsh#Thi, abs(parti - prmsh#arrayIntersection[i]) < 0.1);
            real lx, ly, lz, ux, uy, uz;
            lx = ly = lz = 1e+30;
            ux = uy = uz = -1.e+30;
            for (int ii=0; ii < meshIntersection.nbe; ii++)
            for (int jj=0; jj < dimension; jj++){
              lx = min(lx,meshIntersection.be(ii)[jj].x); ux = max(ux,meshIntersection.be(ii)[jj].x);
              ly = min(ly,meshIntersection.be(ii)[jj].y); uy = max(uy,meshIntersection.be(ii)[jj].y);
              IFMACRO(dimension,3)
              lz = min(lz,meshIntersection.be(ii)[jj].z); uz = max(uz,meshIntersection.be(ii)[jj].z);
              ENDIFMACRO
            }

            IFMACRO(dimension,2)
            real p0x = prmsh#Thi(prmsh#Thi[0][0]).x, p0y = prmsh#Thi(prmsh#Thi[0][0]).y;
            real p1x = prmsh#Thi(prmsh#Thi[0][1]).x, p1y = prmsh#Thi(prmsh#Thi[0][1]).y;
            real p2x = prmsh#Thi(prmsh#Thi[0][2]).x, p2y = prmsh#Thi(prmsh#Thi[0][2]).y;
            real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2),sqrt((p2x-p0x)^2+(p2y-p0y)^2));
            lx -= h*prmsh#overlap; ly -= h*prmsh#overlap;
            ux += h*prmsh#overlap; uy += h*prmsh#overlap;
            meshIntersection = trunc(prmsh#Thi, (x>=lx)&&(x<=ux)&&(y>=ly)&&(y<=uy), new2old = n2o, label=9999);
            ENDIFMACRO
            IFMACRO(dimension,3)
            real p0x = prmsh#Thi(prmsh#Thi.be(0)[0]).x, p0y = prmsh#Thi(prmsh#Thi.be(0)[0]).y, p0z = prmsh#Thi(prmsh#Thi.be(0)[0]).z;
            real p1x = prmsh#Thi(prmsh#Thi.be(0)[1]).x, p1y = prmsh#Thi(prmsh#Thi.be(0)[1]).y, p1z = prmsh#Thi(prmsh#Thi.be(0)[1]).z;
            real p2x = prmsh#Thi(prmsh#Thi.be(0)[2]).x, p2y = prmsh#Thi(prmsh#Thi.be(0)[2]).y, p2z = prmsh#Thi(prmsh#Thi.be(0)[2]).z;
            real h = min(sqrt((p1x-p0x)^2+(p1y-p0y)^2+(p1z-p0z)^2), sqrt((p2x-p0x)^2+(p2y-p0y)^2+(p2z-p0z)^2));
            lx -= h*prmsh#overlap; ly -= h*prmsh#overlap; lz -= h*prmsh#overlap;
            ux += h*prmsh#overlap; uy += h*prmsh#overlap; uz += h*prmsh#overlap;
            meshIntersection = trunc(prmsh#Thi, (x>=lx)&&(x<=ux)&&(y>=ly)&&(y<=uy)&&(z>=lz)&&(z<=uz), new2old = n2o, label=9999);
            ENDIFMACRO

            ENDIFMACRO

            IFMACRO(!prmsh#partcubes)
            prmsh#meshN meshIntersection = trunc(prmsh#Thi, (prmsh#partitionIntersectionbasei[i] > 1.0e-6), new2old = n2o, label=9999);
            ENDIFMACRO

            fespace WhIntersection(meshIntersection, prfe#fPk);
            int[int] renum = restrict(WhIntersection, prfe#Vhi,n2o);
            int[int] Ic = (0:WhIntersection.ndof-1);
            real[int] Kc(WhIntersection.ndof);
            Kc = 1;
            R = [Ic,renum,Kc];
            R.resize(WhIntersection.ndof, prfe#Vhi.ndof);
          }
          else {
            IFMACRO(prmsh#mminoverlap,1)
            matrix RP1 = interpolate(prmsh#VhiP1,prmsh#AugVhiP1);
            prmsh#AugVhiP1 partaugP1;
            partaugP1[] = RP1'*prmsh#partitionIntersectionbasei[i][];
            prmsh#meshN meshIntersection = trunc(prmsh#AugThi, (partaugP1 > 1.0e-6), new2old = n2o);
            fespace prfe#PhAugP0(prmsh#AugThi,P0);
            prfe#PhAugP0 paug;
            paug[] = prmsh#partAug;
            paug = abs(paug-prmsh#arrayIntersection[i]) < 0.1;
            prmsh#meshN meshNeighbor = trunc(prmsh#AugThi, paug > 0.001, label=-10);

            fespace WhIntersection(meshIntersection, prfe#fPkP0);

            fespace WhNeighbor(meshNeighbor, prfe#fPkP0);

            matrix Rn = interpolate(WhNeighbor,prfe#AugVhi,inside=true);

            varf vneighbor(udef(u),udef(v)) = on(-10, udef(u) = uinit(1));
            real[int] bbord = vneighbor(0,WhNeighbor,tgv=1);
            real[int] bbordaug = Rn'*bbord;

            int[int] renum = restrict(WhIntersection, prfe#AugVhi, n2o);

            WhIntersection udefpart(utmpi);

            matrix RR = interpolate(prfe#Vhi,prfe#AugVhi);

            varf vbord(udef(u),udef(v)) = on(ffddminterfacelabel, udef(u) = uinit(1));
            real[int] bmybord = vbord(0,prfe#Vhi,tgv=1);
            real[int] bmybordaug = RR'*bmybord;

            for [i,bi: utmpi[]] bi = (bbordaug[renum[i]] > 0.999 && bmybordaug[renum[i]] > 0.999 ? 1 : 0);

            int[int] rest(WhIntersection.ndof);
            int ninter = 0;
            for (int j=0; j<WhIntersection.ndof; j++)
            if (utmpi[][j] > 0.999)
              rest[ninter++] = renum[j];
            rest.resize(ninter);
            if (ninter > 0){
            int[int] Ic(1);
            if (ninter > 1)
              Ic = (0:ninter-1);
            real[int] Kc(ninter);
            Kc = 1;
            matrix Raug = [Ic,rest,Kc];
            Raug.resize(ninter, prfe#AugVhi.ndof);
            R = Raug*RR';
            usum[] += R'*Kc;
            }
            else {
              R.resize(0, prfe#AugVhi.ndof);
            }
            ENDIFMACRO
            IFMACRO(prmsh#mminoverlap,0)
            cout << "["+Stringification(prfe)+"] ffddmbuildDfespace PB: you need to define macro \""+Stringification(prmsh)+"mminoverlap\" to 1 when using overlap=0, e.g. by adding \"-D"+Stringification(prmsh)+"mminoverlap=1\" to the command line" << endl;
            assert(0);
            ENDIFMACRO
          }

        /*cout << mpirank << " " << prmsh#arrayIntersection[i] << " " << R.n << " " << R.m << endl;*/
        prfe#restrictionIntersection[i] = R;
        prfe#rcv[i].resize(prfe#restrictionIntersection[i].n);
        prfe#snd[i].resize(prfe#restrictionIntersection[i].n);
      }
      searchMethod = backup;
    }

    if (prmsh#overlap == 0)
      utmp[] = utmp[] ./= usum[];

    prfe#Dk[ii].resize(Vhipart.ndof);
    IFMACRO(prfe#K,complex)
    prfe#Dk[ii].re = utmp[];
    ENDIFMACRO
    IFMACRO(prfe#K,real)
    prfe#Dk[ii] = utmp[];
    ENDIFMACRO
    matrix Dihreal = utmp[];
    Dihreal.thresholding(1e-10);
    prfe#Dih[ii] = Dihreal;

    if(!bnoGlob) {
      matrix Rihreal=interpolate(prfe#Vhi,prfe#Vhglob);
      int[int] I(1),J(1);
      real[int] Kc(1);
      [I,J,Kc] = Rihreal;
      for (int i=0;i<Kc.n;i++)
      if (Kc[i] > 0.99)
      Kc[i] = 1.;
      Rihreal = [I,J,Kc];    
      Rihreal.thresholding(1e-10);
      prfe#Rih[ii] = Rihreal;
      prfe#Rih[ii].resize(prfe#Vhi.ndof, prfe#Vhglob.ndof);
    }
    
    if (bseq)
      prmsh#Thi = prmsh#Thglob;
    
    if (bpara)
    {
      func ftest = x+y;
      prfe#Vhi<prfe#K> prfe#mdef(uu), prfe#mdef(vv) = prfe#minit(0.);
      
      uu[] = 1.;
      
      vv[] = prfe#Dk[ii];
      
      prfe#K[int][int] rcv(prmsh#numberIntersection);
      prfe#K[int][int] snd(prmsh#numberIntersection);
      
      mpiRequest[int] rq(prmsh#numberIntersection*2);
      
      
      for(int j=0;j<prmsh#numberIntersection;++j)
      {
        rcv[j].resize(prfe#restrictionIntersection[j].n);
        snd[j].resize(prfe#restrictionIntersection[j].n);
        snd[j] = prfe#restrictionIntersection[j]*vv[];
      }
      
      for(int j=0;j<prmsh#numberIntersection;++j)
      Isend(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2]),snd[j]);
      for(int j=0;j<prmsh#numberIntersection;++j)
      Irecv(processor(prmsh#arrayIntersection[j],prmsh#commddm,rq[j*2+1]),rcv[j]);
      
      for(int j=0;j<prmsh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);
      
      for(int j=0;j<prmsh#numberIntersection;++j)
      vv[] += prfe#restrictionIntersection[j]'*rcv[j];
      
      uu[] -= vv[];
      
      if (uu[].linfty > 1.e-8)
      cout << "["+Stringification(prfe)+"] Probleme partition de l'unite : uu[].linfty = " << uu[].linfty << endl;
    }    
    
    if (bpara){
      /* To count the total number of dofs (inspired from statistics hpddm) */
      int ndofglobi=0;
      int[int] table(prfe#Vhi.ndof);
      /* table to label dofs */
      table = ii;
      for(int j=0;j<prmsh#numberIntersection;++j){ /* loop on the neighbors */
        prfe#K[int] C(1);
        int[int] I(1), J(1);
        [I, J, C] = prfe#restrictionIntersection[j]; /* now J is the restrictionIntersection[j] of hpddm */
        if (C[C.n-1] == 0) {
          I.resize(C.n-1);
          J.resize(C.n-1);
          C.resize(C.n-1);
        }
        
        for (int k=0;k<J.n;k++) /* loop on the neighbor dofs */
        table[J[k]] = max(table[J[k]], prmsh#arrayIntersection[j]);
      } 	
      for[i,tablei: table]{ /* syntax for c++ loops */
        if(tablei<=ii) ndofglobi++;
      }
      prfe#Ndofglobal = 0;
      mpiReduce(ndofglobi, prfe#Ndofglobal, processor(0,prmsh#commddm), mpiSUM);
      
      if (ffddmverbosity && mpiRank(prmsh#commddm) == 0)
      cout << "["+Stringification(prfe)+"] (paraddm) ndof = " << prfe#Ndofglobal << endl;
    }	
    
  }
}
// EOM

macro ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
IFMACRO(prmesh#buildAug,1)
ffddmbuildDfespacef(prfe#Aug,prmesh#Aug,scalar,def,init,Pk,defpart,initpart,Pkpart)
ENDIFMACRO
ffddmbuildDfespacef(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
IFMACRO(prmesh#buildAug,1)
if (bseq)
  prfe#Auginterp = interpolate(prfe#AugVhi,prfe#Vhglob);
else if (bpara)
  prfe#Auginterp = interpolate(prfe#Vhi,prfe#AugVhi);
prfe#Auginterp.thresholding(1e-10);
ENDIFMACRO
// EOM

macro ffddmbuildDfespace(prfe,prmesh,scalar,def,init,Pk)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,def,init,Pk)
// EOM

macro ffddmbuildDfespaceAug(prfe,prmesh,scalar,def,init,Pk)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,def,init,Pk)
// EOM

macro ffddmbuildDfespaceEdgeAug(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildDmesh(prmesh,Th,comm)
if ((mpirank == 0) && ffddmverbosity)
cout << "["+Stringification(prmesh)+"] Building decomposition from mesh of " << Th.nt << " elements" << endl;

int prmesh#inexactCSsplit = 0;
int prmesh#binexactCS = 0;
int prmesh#binexactgeneoCS = 0;
int prmesh#pCS = ffddmpCS;
int prmesh#exclude = ffddmexclude;
ffddminitDmeshf(prmesh,comm)

if (!bnoGlob)
if  (prmesh#inexactCSsplit <= 1) {
  if (ffddmsplit == 1)
    prmesh#Thglob = Th;
  else
    prmesh#Thglob = trunc(Th,1,split=ffddmsplit);
}
else 
  prmesh#Thglob = trunc(Th,1,split=prmesh#inexactCSsplit*ffddmsplit);

IFMACRO(!prmesh#mminoverlap)
NewMacro prmesh#mminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
IFMACRO(prmesh#mminoverlap,1)
NewMacro prmesh#buildAug()1 EndMacro
ENDIFMACRO
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()0 EndMacro
ENDIFMACRO

IFMACRO(prmesh#buildAug,1)
int prmesh#AuginexactCSsplit = 0;
int prmesh#AugbinexactCS = 0;
int prmesh#AugbinexactgeneoCS = 0;
int prmesh#AugpCS = ffddmpCS;
int prmesh#Augexclude = ffddmexclude;
IFMACRO(!prmesh#Augmminoverlap)
NewMacro prmesh#Augmminoverlap()0 EndMacro
ENDIFMACRO
ffddminitDmeshf(prmesh#Aug,comm)

prmesh#AugThglob = prmesh#Thglob;
IFMACRO (!prmesh#AugbuildAug)
NewMacro prmesh#AugbuildAug()0 EndMacro
ENDIFMACRO
ENDIFMACRO

{
  real[int] locpartition;
  ffddmpartf(prmesh,Th,locpartition)
  
  IFMACRO(prmesh#buildAug,1)
  ffddmbuildDmeshf(prmesh#Aug,Th,locpartition,(ffddmoverlap+1))
  ENDIFMACRO

  ffddmbuildDmeshf(prmesh,Th,locpartition,ffddmoverlap)
}
// EOM

macro ffddmbuildDmeshNested(prmesh,Thc,sp,comm)
if ((mpirank == 0) && !bpara)
cout << "["+Stringification(prmesh)+"] ffddmbuildDmeshNested PB: two-level nested mesh decomposition is to be used only in parallel mode" << endl;
assert(bpara);
if ((mpirank == 0) && ffddmverbosity)
cout << "["+Stringification(prmesh)+ "] Building two-level decomposition from coarse mesh of " << Thc.nt << " elements, with splitting parameter " << sp << endl << "["+Stringification(prmesh)+"] Setting binexactCS = 1, pCS = mpisize, exclude = 0" << endl;

int prmesh#inexactCSsplit = sp;
int prmesh#binexactCS = 1;
int prmesh#binexactgeneoCS = 0;
NewMacro prmesh#minexactCS 1 EndMacro
int prmesh#pCS = ffddmpCS;
int prmesh#exclude = ffddmexclude;

int prmesh#CoarseinexactCSsplit = 1;
int prmesh#CoarsebinexactCS = 0;
int prmesh#CoarsebinexactgeneoCS = 0;
int prmesh#CoarsepCS = ffddmpCS;
int prmesh#Coarseexclude = ffddmexclude;

ffddminitDmeshf(prmesh,comm)

if (!bnoGlob)
if  (prmesh#inexactCSsplit <= 1) {
  if (ffddmsplit == 1)
    prmesh#Thglob = Thc;
  else
    prmesh#Thglob = trunc(Thc,1,split=ffddmsplit);
}
else 
  prmesh#Thglob = trunc(Thc,1,split=prmesh#inexactCSsplit*ffddmsplit);

ffddminitDmeshf(prmesh#Coarse,comm)

IFMACRO(!prmesh#mminoverlap)
NewMacro prmesh#mminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#Coarsemminoverlap)
NewMacro prmesh#Coarsemminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()0 EndMacro
ENDIFMACRO
IFMACRO(!prmesh#CoarsebuildAug)
NewMacro prmesh#CoarsebuildAug()0 EndMacro
ENDIFMACRO

{
  real[int] partition;
  ffddmpartf(prmesh,Thc,partition)
  ffddmbuildDmeshf(prmesh#Coarse,Thc,partition,ffddmoverlap)
  ffddmbuildDmeshf(prmesh,Thc,partition,ffddmoverlap)
}
// EOM

macro ffddmbuildDmeshAug(prmesh,Th,comm)
IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()1 EndMacro
ENDIFMACRO
ffddmbuildDmesh(prmesh,Th,comm)
// EOM

macro ffddmbuildDmeshpartcubes(prmesh,Th,comm)
IFMACRO(!prmesh#buildAug)
NewMacro prmesh#partcubes()1 EndMacro
ENDIFMACRO
ffddmbuildDmesh(prmesh,Th,comm)
// EOM

macro ffddmbuildDmeshpartcubesauto(prmesh,N,B,L,comm)
IFMACRO(!prmesh#buildAug)
NewMacro prmesh#partcubes()1 EndMacro
ENDIFMACRO

int prmesh#inexactCSsplit = 0;
int prmesh#binexactCS = 0;
int prmesh#binexactgeneoCS = 0;
int prmesh#pCS = ffddmpCS;
int prmesh#exclude = ffddmexclude;

int prmesh#cubesnpart, prmesh#cubesnx=0, prmesh#cubesny=0, prmesh#cubesnz=0;

{
  int p = mpiSize(comm);

  real nnx = pow(p * N[0]^2 / N[1] / N[2], 1./3.);
  real nny = nnx * N[1] / N[0];
  real nnz = nnx * N[2] / N[0];
  nnx = ceil(nnx); nny = ceil(nny); nnz = ceil(nnz);

  /* try to find the best cuboid partitioning for this number of cores : */
  for (int ii=0; ii<4; ii++)
  for (int jj=0; jj<4; jj++)
  for (int kk=0; kk<4; kk++) {
    int ni = nnx-ii, nj = nny-jj, nk = nnz-kk;
    if (ni*nj*nk <= p && ni*nj*nk > prmesh#cubesnx * prmesh#cubesny * prmesh#cubesnz) {
      prmesh#cubesnx = ni; prmesh#cubesny = nj; prmesh#cubesnz = nk;
    }
  }
  p = prmesh#cubesnx * prmesh#cubesny * prmesh#cubesnz;

  if (mpiRank(comm) == 0) cout << "The domain will be decomposed in " << prmesh#cubesnx << " x " << prmesh#cubesny << " x " << prmesh#cubesnz << " cubic subdomains" << endl;
  if (mpiRank(comm) == 0 && (p != mpiSize(comm)))
    cout << "WARNING: the cuboid decomposition will only use " << p << " of the " << mpiSize(comm) << " available cores" << endl;
  prmesh#cubesnpart = p;
}

/* define sub-communicator if we are not using all cores */
int[int] prmesh#Icubesauto = (0:prmesh#cubesnpart-1);
mpiGroup prmesh#grpcubesauto(prmesh#Icubesauto);
mpiComm prmesh#commcubesauto(comm,prmesh#grpcubesauto);

ffddminitDmeshf(prmesh,prmesh#commcubesauto)

IFMACRO(!prmesh#mminoverlap)
NewMacro prmesh#mminoverlap()0 EndMacro
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
IFMACRO(prmesh#mminoverlap,1)
NewMacro prmesh#buildAug()1 EndMacro
ENDIFMACRO
ENDIFMACRO

IFMACRO(!prmesh#buildAug)
NewMacro prmesh#buildAug()0 EndMacro
ENDIFMACRO

IFMACRO(prmesh#buildAug,1)
int prmesh#AuginexactCSsplit = 0;
int prmesh#AugbinexactCS = 0;
int prmesh#AugbinexactgeneoCS = 0;
int prmesh#AugpCS = ffddmpCS;
int prmesh#Augexclude = ffddmexclude;
IFMACRO(!prmesh#Augmminoverlap)
NewMacro prmesh#Augmminoverlap()0 EndMacro
ENDIFMACRO
ffddminitDmeshf(prmesh#Aug,prmesh#commcubesauto)

prmesh#AugThglob = prmesh#Thglob;
IFMACRO (!prmesh#AugbuildAug)
NewMacro prmesh#AugbuildAug()0 EndMacro
ENDIFMACRO
ENDIFMACRO

if (prmesh#isincomm)
{
  int nx = prmesh#cubesnx, ny = prmesh#cubesny, nz = prmesh#cubesnz;
  int zx = nx - (N[0]%nx), zy = ny - (N[1]%ny), zz = nz - (N[2]%nz);
  int px = ceil(1.*N[0]/nx), py = ceil(1.*N[1]/ny), pz = ceil(1.*N[2]/nz);

  if (mpiRank(prmesh#commcubesauto) == 0) cout << "Subdomain size " << px+1 << " x " << py+1 << " x " << pz+1 << endl;

  int boundzl = mpiRank(prmesh#commcubesauto) / ( nx * ny );
  int nr = mpiRank(prmesh#commcubesauto) - boundzl * nx * ny;
  int boundyl = nr / nx;
  int boundxl = nr % nx;

  boundxl *= px; boundyl *= py; boundzl *= pz;

  int boundzu = (mpiRank(prmesh#commcubesauto) / ( nx * ny ) < nz - 1 ? boundzl + pz - 1 : N[2]-1);
  int boundyu = (nr / nx < ny - 1 ? boundyl + py - 1 : N[1] - 1);
  int boundxu = (nr % nx < nx - 1 ? boundxl + px - 1 : N[0] - 1);

  boundxl = max(0,boundxl-3*ffddmoverlap); boundxu = min(N[0]-1,boundxu+3*ffddmoverlap);
  boundyl = max(0,boundyl-3*ffddmoverlap); boundyu = min(N[1]-1,boundyu+3*ffddmoverlap);
  boundzl = max(0,boundzl-3*ffddmoverlap); boundzu = min(N[2]-1,boundzu+3*ffddmoverlap);

  int nbnx = boundxu-boundxl+1;
  int nbny = boundyu-boundyl+1;
  int nbnz = boundzu-boundzl+1;

  /* truncate global grid around the subdomain before partitioning to avoid defining the full grid */
  real h = (B(0,1)-B(0,0))/N[0];
  int[int] NN=[nbnx,nbny,nbnz];

  real [int,int] BB=[[B(0,0)+boundxl*h,B(0,0)+(boundxu+1)*h],[B(1,0)+boundyl*h,B(1,0)+(boundyu+1)*h],[B(2,0)+boundzl*h,B(2,0)+(boundzu+1)*h]];
  int [int,int] LL=[[L(0,0)+100*(boundxl!=0),L(0,1)+100*(boundxu!=N[0]-1)],[L(1,0)+100*(boundyl!=0),L(1,1)+100*(boundyu!=N[1]-1)],[L(2,0)+100*(boundzl!=0),L(2,1)+100*(boundzu!=N[2]-1)]];

  mesh3 Thtcube = Cube(NN,BB,LL);

  func int partcube(int ii, int jj, int kk) {
    return min(kk / pz, int(nz-1))*nx*ny + min(jj / py, int(ny-1))*nx + min(ii / px, int(nx-1));
  }

  fespace prmesh#Phgcube(Thtcube,P0);
  prmesh#Phgcube partglob;

  /* define the regular partitioning as a P0 function on Th */
  partglob=partcube(floor((x-B(0,0))/(B(0,1)-B(0,0))*N[0]), floor((y-B(1,0))/(B(1,1)-B(1,0))*N[1]), floor((z-B(2,0))/(B(2,1)-B(2,0))*N[2]));

  ffddmbuildDmeshf(prmesh,Thtcube,partglob[],ffddmoverlap)
}
// EOM

macro ffddmbuildDfespaceEdgeNested(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
ffddmbuildDfespaceEdge(prfe#Coarse,prmesh#Coarse,scalar,def,init,Pk,defpart,initpart,Pkpart)
ffddmbuildDfespaceEdge(prfe,prmesh,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildDfespaceNested(prfe,prmesh,scalar,def,init,Pk)
ffddmbuildDfespaceEdgeNested(prfe,prmesh,scalar,def,init,Pk,def,init,Pk)
// EOM

macro ffddmbuild(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildDmesh(pr,Th,comm)
ffddmbuildDfespace(pr,pr,scalar,def,init,Pk)
// EOM

macro ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,Pkpart,comm)
ffddmbuildDmesh(pr,Th,comm)
ffddmbuildDfespaceEdge(pr,pr,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildEdgeNested(pr,Thc,sp,scalar,def,init,Pk,defpart,initpart,Pkpart,comm)
ffddmbuildDmeshNested(pr,Thc,sp,comm)
ffddmbuildDfespaceEdgeNested(pr,pr,scalar,def,init,Pk,defpart,initpart,Pkpart)
// EOM

macro ffddmbuildNested(pr,Thc,sp,scalar,def,init,Pk,comm)
ffddmbuildEdgeNested(pr,Thc,sp,scalar,def,init,Pk,def,init,Pk,comm)
// EOM

macro ffddmbuildEdgeAug(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
IFMACRO(!pr#buildAug)
NewMacro pr#buildAug()1 EndMacro
ENDIFMACRO
ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm) // EOM

macro ffddmbuildAug(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildEdgeAug(pr,Th,scalar,def,init,Pk,def,init,Pk,comm) // EOM

/*
macro ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
if ((mpirank == 0) && ffddmverbosity)
cout << "Building decomposition from mesh of " << Th.nt << " elements" << endl;
int pr#inexactCSsplit = 0;
int pr#binexactCS = 0;
int pr#pCS = ffddmpCS;
int pr#exclude = ffddmexclude;
ffddminitf(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)

IFMACRO(pr#buildAug,1)
int pr#AuginexactCSsplit = 0;
int pr#AugbinexactCS = 0;
int pr#AugpCS = ffddmpCS;
int pr#Augexclude = ffddmexclude;
ffddminitf(pr#Aug,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
pr#Augverbosity = pr#verbosity;
ENDIFMACRO

{
real[int] partition;
ffddmpartf(pr,Th,partition)
ffddmbuildf(pr,Th,partition)

IFMACRO(pr#buildAug,1)
ffddmoverlap += 1;
ffddmbuildf(pr#Aug,Th,partition)
ffddmoverlap -= 1;
ENDIFMACRO
}

IFMACRO(pr#buildAug,1)
if (bseq)
pr#Auginterp = interpolate(pr#AugVhi,pr#Vhglob);
else if (bpara)
pr#Auginterp = interpolate(pr#Vhi,pr#AugVhi);
ENDIFMACRO
// EOM

macro ffddmbuild(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildEdge(pr,Th,scalar,def,init,Pk,def,init,Pk,comm) // EOM

macro ffddmbuildaugEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
NewMacro pr#buildAug()1 EndMacro
ffddmbuildEdge(pr,Th,scalar,def,init,Pk,defpart,initpart,PkP0,comm) // EOM

macro ffddmbuildaug(pr,Th,scalar,def,init,Pk,comm)
ffddmbuildaugEdge(pr,Th,scalar,def,init,Pk,def,init,Pk,comm) // EOM

macro ffddmbuildNestedEdge(pr,Thc,sp,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
if ((mpirank == 0) && !bpara)
cout << "ffddmbuildNestedEdge PB: two-level nested mesh decomposition is to be used only in parallel mode" << endl;
assert(bpara);
if ((mpirank == 0) && ffddmverbosity)
cout << "Building nested decomposition from coarse mesh of " << Thc.nt << " elements, with splitting parameter " << sp << endl << "Setting binexactCS = 1, pCS = mpisize, exclude = 0 for prefix \""+Stringification(pr)+"\"" << endl;

int pr#inexactCSsplit = sp;
int pr#binexactCS = 1;
NewMacro pr#minexactCS 1 EndMacro
int pr#pCS = ffddmpCS;
int pr#exclude = ffddmexclude;

int pr#CoarseinexactCSsplit = 1;
int pr#CoarsebinexactCS = 0;
int pr#CoarsepCS = ffddmpCS;
int pr#Coarseexclude = ffddmexclude;

ffddminitf(pr#Coarse,Thc,scalar,def,init,Pk,defpart,initpart,PkP0,comm)
ffddminitf(pr,Thc,scalar,def,init,Pk,defpart,initpart,PkP0,comm)

{
real[int] partition;
ffddmpartf(pr,Thc,partition)
ffddmbuildf(pr#Coarse,Thc,partition)
ffddmbuildf(pr,Thc,partition)
}

pr#Coarseverbosity = 1;

// EOM

macro ffddmbuildNested(pr,Thc,sp,scalar,def,init,Pk,comm) ffddmbuildNestedEdge(pr,Thc,sp,scalar,def,init,Pk,def,init,Pk,comm) // EOM
*/
load "medit"
// ! basic functions to build regular mesh of a cube
/*
  mesh3   Cube(NN,BB,L);
    --   build the surface mesh of a 3d box 
    where: for exqmple:
  int[int]  NN=[nx,ny,nz]; //  the number of seg in the 3 direction
  real [int,int]  BB=[[xmin,xmax],[ymin,ymax],[zmin,zmax]]; // bounding bax  
  int [int,int]  L=[[1,2],[3,4],[5,6]]; // the label of the 6 face left,right, front, back, down, right
*/
func mesh3 Cube(int[int] & NN,real[int,int] &BB ,int[int,int] & L)
{    
  //  first  build the 6 faces of the hex.
  real x0=BB(0,0),x1=BB(0,1);
  real y0=BB(1,0),y1=BB(1,1);
  real z0=BB(2,0),z1=BB(2,1);
  
  int nx=NN[0],ny=NN[1],nz=NN[2];
  mesh Thx = square(nx,ny,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
  
  int[int] rup=[0,L(2,1)],  rdown=[0,L(2,0)], 
    rmid=[1,L(1,0),  2,L(0,1),  3, L(1,1),  4, L(0,0) ];
  mesh3 Th=buildlayers(Thx,nz,   zbound=[z0,z1], 
		       labelmid=rmid,   labelup = rup,
		       labeldown = rdown);
  
  return Th;
}
func mesh3 Cube(int Nx,int Ny,int Nz)
{
  int[int] NN=[Nx,Ny,Nz];
  real [int,int]  BB=[[0,1],[0,1],[0,1]];	
  int[int,int] LL=[[1,2],[3,4],[5,6]]; 
  return Cube(NN,BB,LL);
} 
 

  
// --- begin  meshes  building --------------
real[int] theta(nbsd+1),cost(nbsd),sint(nbsd);

for (int i=0;i<nbsd;i++)
 {
  real t=i*2*pi/nbsd;
  theta[i]= t;
  theta[i+1]= (i+1)*2*pi/nbsd;
  cost[i]=cos(t);
  sint[i]=sin(t);
 }


border g1(t=0,1){x=cost[0]*t;y=sint[0]*t;label=1;};
border g2(t=0,1){x=cost[1]*t;y=sint[1]*t;label=1;};
border g3(t=0,1){x=cost[2]*t;y=sint[2]*t;label=1;};
border g4(t=0,1){x=cost[3]*t;y=sint[3]*t;label=1;};

border e12(t=theta[0],theta[1]){x=cos(t);y=sin(t);label=labext;};
border e23(t=theta[1],theta[2]){x=cos(t);y=sin(t);label=labext;};
border e34(t=theta[2],theta[3]){x=cos(t);y=sin(t);label=labext;};
border e41(t=theta[3],theta[4]){x=cos(t);y=sin(t);label=labext;};

 int Ng = 5;
 int Ne = 5 ;

plot(g1(Ng)+g2(Ng)+g3(Ng)+g4(Ng) + e12(Ne) + e23(Ne)+ e34(Ne) + e41(Ne) ,wait=1);

mesh Tha = buildmesh( g1(Ng)+g2(Ng)+g3(Ng)+g4(Ng) + e12(Ne) + e23(Ne)+ e34(Ne) + e41(Ne) );

int [int] regi(4);
for (int i=0;i<4;i++)
  {
    real tt = (theta[i]+theta[i+1])*0.5;
    regi[i]=Tha(0.5*cos(tt),0.5*sin(tt)).region;
  }


Tha=adaptmesh(Tha,meshsize*3,IsMetric=1,thetamax=60,nbvx=100000);
Tha=adaptmesh(Tha,meshsize*1.5,IsMetric=1,thetamax=60,nbvx=100000);
Tha=adaptmesh(Tha,meshsize,IsMetric=1,thetamax=60,nbvx=100000);

macro ffddmgeneofullsetup(pr,fgeneoA1,fgeneoB)

pr#bCM = 0;

if (pr#prfe#prmesh#isincomm)
{
NewMacro pr#geneofullpattern()1 EndMacro
func pr#geneofullpatternOP = fgeneoB;

pr#corr = ffddmcorrection;

int nev = ffddmnu;

IFMACRO(!pr#withhpddm)

if (!bpara)
  pr#Z.resize(nev*pr#prfe#prmesh#npart);
else if (!pr#prfe#prmesh#excluded)
  pr#Z.resize(nev);

pr#si=0;
pr#prfe#prmesh#tic(pr#tloc)

int[int] sizel(pr#prfe#prmesh#npart);
int[int] sizelT(pr#prfe#prmesh#npart);

for(int i=0;i<pr#prfe#prmesh#npart;++i)
if ((!pr#prfe#prmesh#excluded) && ((!bpara) || (i == mpiRank(pr#prfe#prmesh#commddm)))) {
	pr#prfe#prmesh#Thi=pr#prfe#prmesh#aTh[i];

  pr#prfe#K[int,int] eV(pr#prfe#Dk[i].n,nev);
	pr#prfe#K[int] ev(nev);

  int[int] done(pr#prfe#prmesh#numberIntersection);
  done = 0;

  pr#prfe#K[int] buffi((1+pr#prfe#prmesh#numberIntersection)*pr#prfe#Dk[i].n);
  pr#prfe#K[int] buffo((1+pr#prfe#prmesh#numberIntersection)*pr#prfe#Dk[i].n);

  int cptB = 0;
  func pr#prfe#K[int] ffullgeneoB(pr#prfe#K[int] &u) {
    cptB++;
    pr#prfe#K[int] Du = pr#prfe#Dk[i] .* u;
    mpiRequest[int] rq(2*pr#prfe#prmesh#numberIntersection);
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      pr#prfe#snd[j] = pr#prfe#restrictionIntersection[j]*Du;
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      Isend(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rq[j*2]),pr#prfe#snd[j]);    
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j])
      Irecv(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rq[j*2+1]),pr#prfe#rcv[j]);

    for(int j=0;j<pr#prfe#prmesh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq);

    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j] && pr#prfe#rcv[j][0] == 1e+30)
      done[j] = 1;

    mpiRequest[int] rq2(2*pr#prfe#prmesh#numberIntersection);

    int cpt = 1;
    buffi(0:pr#prfe#Dk[i].n-1) = Du;
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j]) {
      buffi(cpt*pr#prfe#Dk[i].n:(cpt+1)*pr#prfe#Dk[i].n-1) = pr#prfe#restrictionIntersection[j]'*pr#prfe#rcv[j];
      cpt++;
    }

    buffo = fgeneoB(buffi, cpt);

    cpt = 1;
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j]) {
      pr#prfe#snd[j] = pr#prfe#restrictionIntersection[j]*buffo(cpt*pr#prfe#Dk[i].n:(cpt+1)*pr#prfe#Dk[i].n-1);
      cpt++;
    }

    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j])
      Isend(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rq2[j*2]),pr#prfe#snd[j]);    
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      Irecv(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rq2[j*2+1]),pr#prfe#rcv[j]);

    for(int j=0;j<pr#prfe#prmesh#numberIntersection*2;++j)
      int k = mpiWaitAny(rq2);

    pr#prfe#K[int] res = buffo(0:pr#prfe#Dk[i].n-1);
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      res += pr#prfe#restrictionIntersection[j]'*pr#prfe#rcv[j];
    res = pr#prfe#Dk[i] .* res;
    return res;
  }

  NewMacro localmacroK pr#prfe#K EndMacro
  IFMACRO(localmacroK,real)
  int kk = EigenValue(pr#prfe#Dk[i].n, A1=fgeneoA1, B=ffullgeneoB, mode=3, sym=1, tol=1e-1,sigma=0,value=ev,rawvector=eV,ncv=max(20,2*nev));
  ENDIFMACRO
  IFMACRO(localmacroK,complex)
  int kk = complexEigenValue(pr#prfe#Dk[i].n, A1=fgeneoA1, B=ffullgeneoB, mode=3, tol=1e-3,sigma=0,value=ev,rawvector=eV,ncv=max(20,3*nev));
  ENDIFMACRO

  int nok = 0;

  for(int j=0;j<nev;++j) {
    if (j == 0 || ffddmtau == 0 || real(ev[j]) < ffddmtau) {
      /*if (mpirank == 0) cout <<  i << " " << pr#si << " " << ev[j] << endl;*/
      pr#Z[pr#si].resize(pr#prfe#Dk[i].n);
      pr#Z[pr#si] = pr#prfe#Dk[i].*eV(:,j);
      if (pr#Z[pr#si].sum < 0) pr#Z[pr#si] *= -1;
      pr#si+=1;
      nok+=1;
    }
  }

  sizel[i] = nok;	/* number of ev for subdomain i */
  
  mpiRequest[int] rqd(pr#prfe#prmesh#numberIntersection);

  for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    pr#prfe#snd[j][0] = 1e+30;
  for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    Isend(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rqd[j]),pr#prfe#snd[j]);

  int wit = 0;
  while (done.min == 0) {
    mpiRequest[int] rq(pr#prfe#prmesh#numberIntersection);  
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j])
      Irecv(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rq[j]),pr#prfe#rcv[j]);

    if (wit++ == 0)
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      int k = mpiWaitAny(rqd);
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      int k = mpiWaitAny(rq);

    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j] && pr#prfe#rcv[j][0] == 1e+30)
      done[j] = 1;

    int cpt = 0;
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j]) {
      buffi(cpt*pr#prfe#Dk[i].n:(cpt+1)*pr#prfe#Dk[i].n-1) = pr#prfe#restrictionIntersection[j]'*pr#prfe#rcv[j];
      cpt++;
    }

    if (cpt) buffo = fgeneoB(buffi,cpt);

    cpt = 0;
    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j]) {
      pr#prfe#snd[j] = pr#prfe#restrictionIntersection[j]*buffo(cpt*pr#prfe#Dk[i].n:(cpt+1)*pr#prfe#Dk[i].n-1);
      cpt++;
    }

    mpiRequest[int] rq2(pr#prfe#prmesh#numberIntersection);

    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
    if (!done[j])
      Isend(processor(pr#prfe#prmesh#arrayIntersection[j],pr#prfe#prmesh#commddm,rq2[j]),pr#prfe#snd[j]);    

    for(int j=0;j<pr#prfe#prmesh#numberIntersection;++j)
      int k = mpiWaitAny(rq2);
  }
}

pr#prfe#prmesh#toc(pr#tloc,"local eigenvalue problems",pr#teigenv)

ffddmbuildZTAZ(pr,pr,null)

ENDIFMACRO
}
// EOM

macro ffddmSPsetup(SP,prA,prBtilde,prCtilde,Ctildei)

matrix SP#Btildei, SP#localBlocki;

/* matrix-vector product with local Schur complement */
func real[int] SP#Simatvec(real[int] &l) {
  real[int] t1 = SP#Btildei'*l;
  real[int] t2 = prA#aR[mpiRank(prA#prfe#prmesh#commddm)]^-1*t1;
  real[int] t3 = SP#Btildei*t2;
  real[int] t4 = Ctildei * l;
  t3 += t4;
  return t3;
}

/* inverse of local Schur complement through the solution of the augmented sparse local saddle point system */ 
func real[int] SP#Sisolve(real[int] &l) {
  real[int] bi(prA#prfe#Vhi.ndof + prCtilde#prfe#Vhi.ndof);
  bi(prA#prfe#Vhi.ndof:bi.n-1) = -l; 
  real[int] ui = SP#localBlocki^-1*bi;
  return ui(prA#prfe#Vhi.ndof:bi.n-1);
}

/* distributed matrix-vector product with B from prA#prfe#Vhi to prCtilde#prfe#Vhi */
func real[int] SP#Bmatvec(real[int] &l) {
  real[int] Dltilde(prA#prfe#AugVhi.ndof);
  /* go from prA#prfe#Vhi to prA#prfe#AugVhi: */
  if (!prA#prfe#prmesh#excluded) {
    real[int] Dl = prA#prfe#Dk[mpiRank(prA#prfe#prmesh#commddm)].*l; /* multiplty by PoU */
    Dltilde = prA#prfe#Auginterp'*Dl; /* extend */
    prA#prfe#Augupdate(Dltilde,false); /* sum */
  }
  real[int] res = prBtilde#A(Dltilde);
  return res;
}

/* distributed matrix-vector product with B^T from prCtilde#prfe#Vhi to prA#prfe#Vhi */
func real[int] SP#BTmatvec(real[int] &l) {
  real[int] BTtilde = prBtilde#AT(l); /* B^T */
  real[int] res(prA#prfe#Vhi.ndof);
  if (!prA#prfe#prmesh#excluded) res = prA#prfe#Auginterp*BTtilde; /* restrict from prA#prfe#AugVhi to prA#prfe#Vhi */
  return res;
}

/* matrix-vector product with S_1 defined as custom operator for prefix S1tilde */
NewMacro SP#S1tildemyA
func real[int] SP#S1tildeA(real[int] &l)
{ 
  real[int] s(l.n);
  s = 0;
  
  prA#prfe#prmesh#Augtic(SP#S1tildetmvi)
  
  if (!prA#prfe#prmesh#Augexcluded){ 
    s = SP#Simatvec(l);
    prCtilde#prfe#update(s,false);
    prCtilde#prfe#update(s,true);
  }
  prA#prfe#prmesh#Augtoc(SP#S1tildetmvi,"",SP#S1tildetmv)
  
  return s;
}
EndMacro

/* one-level preconditioner M_{S_1,1}^-1 defined as custom preconditioner for prefix S1tilde */
NewMacro SP#S1tildemyPREC1
func real[int] SP#S1tildePREC1(real[int] &l)
{
  real[int] s(l.n);
  s = 0;

  prA#prfe#prmesh#Augtic(SP#S1tildetpreci)

  if (!prA#prfe#prmesh#Augexcluded){
  	real[int] aux = l;
    if(SP#S1tildeprec == "soras")
    aux = aux .* prCtilde#prfe#Dk[mpiRank(prA#prfe#prmesh#Augcommddm)];

    s = SP#Sisolve(aux);

    if(SP#S1tildeprec != "asm"){
      prCtilde#prfe#update(s,true);
    }
    else{
			prCtilde#prfe#update(s,false);
			prCtilde#prfe#update(s,true);
    }
  }
  prA#prfe#prmesh#Augtoc(SP#S1tildetpreci,"",SP#S1tildetprec)

  return s;
}
EndMacro

/* operator (I + M_{S_1}^-1 S_0) for the solution of eq. (25) to apply N_S^-1
   defined as custom operator for prefix NStilde */
NewMacro SP#NStildemyA
func real[int] SP#NStildeA(real[int] &u) {
  prA#prfe#prmesh#Augtic(SP#NStildetmvi)
  real[int] res(u.n);

  /* recall that S_0 = B R_0^T (R_0 A R_0^T)^-1 R_0 B^T */

  real[int] BTu = SP#BTmatvec(u); /* B^T */

  real[int] R0TA01R0BTu = prA#Q(BTu); /* Q = R_0^T (R_0 A R_0^T)^-1 R_0 */

  /* extend from prA#prfe#Vhi to prA#prfe#AugVhi : */
  real[int] El(prA#prfe#AugVhi.ndof);
  if (!prA#prfe#prmesh#excluded) {
    real[int] Dl = prA#prfe#Dk[mpiRank(prA#prfe#prmesh#commddm)].*R0TA01R0BTu; /* multiplty by PoU */
    El = prA#prfe#Auginterp'*Dl; /* extend */
    prA#prfe#Augupdate(El,false); /* sum */
  }

  real[int] BR0TA01R0BTu = prBtilde#A(El); /* B */

  real[int] MS11 = SP#S1tildePREC(BR0TA01R0BTu); /* M_{S_1}^-1 */
  res = u + MS11;
  prA#prfe#prmesh#Augtoc(SP#NStildetmvi,"",SP#NStildetmv)
  return res;
}
EndMacro

/* matrix-vector product with Schur complement S = C + B A^-1 B^T for step 3 of Algorithm 2
   defined as custom operator for prefix SP */
NewMacro SP#myA
func real[int] SP#A(real[int] &l) 
{
  prA#prfe#prmesh#Augtic(SP#tmvi)
  real[int] BTl(prA#prfe#Vhi.ndof), s(prA#prfe#Vhi.ndof), x0(prA#prfe#Vhi.ndof);

  BTl = SP#BTmatvec(l); /* B^T */

  x0 = 0;
  s = prA#fGMRES(x0, BTl, gtol, 100, "right"); /* A^-1 */

  real[int] res = SP#Bmatvec(s); /* B */

  res += prCtilde#A(l); /* + C */

  prA#prfe#prmesh#Augtoc(SP#tmvi,"",SP#tmv)
  return res;
}
EndMacro

/* matrix-vector product with N_S^-1 (Algorithm 1, i.e. solve eq. (25))
   defined as custom preconditioner for prefix SP */
NewMacro SP#myPREC
func real[int] SP#PREC(real[int] &G) {
  prA#prfe#prmesh#Augtic(SP#tpreci)
  real[int] Gprime(G.n), res(G.n);

  /* solve (I + M_{S_1}^-1 S_0) P = M_{S_1}^-1 G */
  Gprime = SP#S1tildePREC(G);
  res = SP#NStildefGMRES(res, Gprime, 1.e-2, 100, "right");

  prA#prfe#prmesh#Augtoc(SP#tpreci,"",SP#tprec)
  return res;
}
EndMacro

ffddmsetupinit(SP#S1tilde,prCtilde#prfe); /* define Operator for S_1 (S1tildeA with one-level preconditioner S1tildePREC1) */
SP#S1tildeprec = "soras";

ffddmsetupinit(SP#NStilde,prCtilde#prfe); /* define operator for N_S (NStildeA = I + M_{S_1}^-1 S_0, no preconditioner) */
SP#NStildeprec = "none";
SP#NStildeverbosity = 1;

ffddmsetupinit(SP,prCtilde#prfe); /* define Operator for S (SPA = S := C + B A^-1 B^T with preconditioner SPPREC = N_S^-1) */

/* build Btildei and localBlocki : */
prA#prfe#prmesh#Augtic(SP#tfactoi)
if (!prA#prfe#prmesh#excluded) {
  SP#Btildei = prBtilde#aRd[mpiRank(prA#prfe#prmesh#commddm)]*prA#prfe#Auginterp'; /* Btilde_i of eq. (9) */

  matrix mC = -Ctildei;
  SP#localBlocki = [[prA#aR[mpiRank(prA#prfe#prmesh#commddm)],0],[SP#Btildei,mC]];
  set(SP#localBlocki,solver=sparsesolver,sym=1,factorize=3,commworld=mpiCommSelf);
}
prA#prfe#prmesh#Augtoc(SP#tfactoi,"",SP#tfacto)

/* local contribution to lhs sum of eigenvalue problem (18) for Arpack ;
   blocking forward-backward substitutions for A_i^{-1} for mu right-hand sides to accelerate computations,
   as we will also have input vectors from neighboring subdomains */
func real[int] SP#Simatvecblock(real[int] &l, int mu) {
  real[int] res(l.n);
  real[int] buffi(prA#prfe#Vhi.ndof * mu), buffo(prA#prfe#Vhi.ndof * mu);
  for (int i=0; i < mu; i++)
    buffi(i*prA#prfe#Vhi.ndof:(i+1)*prA#prfe#Vhi.ndof-1) = SP#Btildei'*l(i*prCtilde#prfe#Vhi.ndof:(i+1)*prCtilde#prfe#Vhi.ndof-1);

  buffo = prA#aR[mpiRank(prA#prfe#prmesh#commddm)]^-1*buffi;

  for (int i=0; i < mu; i++) {
    real[int] t1 = SP#Btildei*buffo(i*prA#prfe#Vhi.ndof:(i+1)*prA#prfe#Vhi.ndof-1);
    /*
    real[int] t2 = prCtilde#prfe#Dk[mpiRank(prA#prfe#prmesh#commddm)].*l(i*prCtilde#prfe#Vhi.ndof:(i+1)*prCtilde#prfe#Vhi.ndof-1);
    real[int] t3 = CtildeaRd[mpiRank(prA#prfe#prmesh#commddm)]*t2;
    res(i*prCtilde#prfe#Vhi.ndof:(i+1)*prCtilde#prfe#Vhi.ndof-1) = t1 + t3;
    */
    real[int] t2 = Ctildei*l(i*prCtilde#prfe#Vhi.ndof:(i+1)*prCtilde#prfe#Vhi.ndof-1);
    res(i*prCtilde#prfe#Vhi.ndof:(i+1)*prCtilde#prfe#Vhi.ndof-1) = t1 + t2;
    
  }
  return res;
}

/* build the second level of M_{S_1}^-1 (section 3.2.2) ;
   Sisolve corresponds to the inverse of rhs of eigenvalue problem (18) for Arpack ;
   Simatvecblock corresponds to the local Schur complement, i.e. the local contribution
   to the S_1 sum -- and to the lhs sum of (18) */
ffddmgeneofullsetup(SP#S1tilde,SP#Sisolve,SP#Simatvecblock);

SP#S1tildecorr = "BNN";

/******************* Block version (prefix 'Block') with preconditioner P eq. (28) *******************/
NewMacro SP#Blockmyscalprod
func real SP#Blockscalprod(real[int]& va, real[int]& vb) 
{
  real resf = prA#prfe#scalprod(va(0:prA#prfe#Vhi.ndof-1),vb(0:prA#prfe#Vhi.ndof-1));
  real resb = prCtilde#prfe#scalprod(va(prA#prfe#Vhi.ndof:va.n-1),vb(prA#prfe#Vhi.ndof:va.n-1));
  return resf+resb;
}
EndMacro

ffddminitDfespacef(SP#Block, prA#prfe#prmesh#Aug, real, def, init, P1, def, init, P1)

NewMacro SP#BlockmyA
func real[int] SP#BlockA(real[int] &u) 
{
  real[int] res(u.n);
  res(0:prA#prfe#Vhi.ndof-1) = prA#A(u(0:prA#prfe#Vhi.ndof-1));
  res(prA#prfe#Vhi.ndof:u.n-1) = -prCtilde#A(u(prA#prfe#Vhi.ndof:u.n-1));

  real[int] r1 = SP#BTmatvec(u(prA#prfe#Vhi.ndof:u.n-1));

  res(0:prA#prfe#Vhi.ndof-1) += r1;
  
  real[int] r2 = SP#Bmatvec(u(0:prA#prfe#Vhi.ndof-1));
  
  res(prA#prfe#Vhi.ndof:u.n-1) += r2;

  return res;
}
EndMacro

NewMacro SP#BlockmyPREC1
func real[int] SP#BlockPREC1(real[int] &u) 
{
  real[int] res(u.n), resb(u.n);

  resb(0:prA#prfe#Vhi.ndof-1) = prA#PREC(u(0:prA#prfe#Vhi.ndof-1));

  resb(prA#prfe#Vhi.ndof:u.n-1) = -SP#PREC(u(prA#prfe#Vhi.ndof:u.n-1));

  real[int] r2 = SP#Bmatvec(resb(0:prA#prfe#Vhi.ndof-1));

  real[int] s2(r2.n);

  s2 = SP#PREC(r2);

  resb(prA#prfe#Vhi.ndof:u.n-1) += s2;

  res(0:prA#prfe#Vhi.ndof-1) = (resb(0:prA#prfe#Vhi.ndof-1));
  res(prA#prfe#Vhi.ndof:u.n-1) = (resb(prA#prfe#Vhi.ndof:u.n-1));

  real[int] r1 = SP#BTmatvec(resb(prA#prfe#Vhi.ndof:u.n-1));

  real[int] s1(r1.n);

  s1 = prA#PREC(r1);

  res(0:prA#prfe#Vhi.ndof-1) -= s1;

  return res;
}
EndMacro

ffddmsetupinit(SP#Block,SP#Block);
SP#Blockprec = "ras";
//
func real c00(real c) { real a=c; 
	
	if(abs(4*a-round(4*a))<1e-13) a=round(a*4)/4.;
	return a;  }

func bool  CC(string t,real[int] & v)
{
	cout << "\n  double "<< t<< "[] = ";
	string s = "{ ";
	for(int i=0; i< v.n; ++i)
	{
	   cout << s << c00(v[i]) ; 
	   s = ", " ;
   }
   cout << " }; \n";
   return 1; 
}

func bool  CC(string t,int[int] & v)
{
	cout << "\n  int "<< t<< "[] = ";
	string s = "{ ";
	for(int i=0; i< v.n; ++i)
	{
	   cout << s << v[i] ; 
	   s = ", " ;
   }
   cout << " }; \n";
   return 1; 
}

func bool  CC(string t,real[int,int] & v)
{
	cout << "\n  double "<< t<< "[]["<<v.n<<"] = ";
	string s = "{\n";
	for(int j=0; j< v.m; ++j)
	{
	   cout << s;
	   s=",\n";
	   string ss = "\t\t{ ";
	   for(int i=0; i< v.n; ++i)
	   {
	   cout << ss << c00(v(i,j)) ; 
	   ss = ", " ;
       }
	   cout << " } /* "<< j << " */ " ;
    }
   cout << " }; \n";
   return 1; 
}
func bool  CC(string t,int[int,int] & v)
{
	cout << "\n  int "<< t<< "[]["<<v.n<<"] = ";
	string s = "{\n";
	for(int j=0; j< v.m; ++j)
	{
	   cout << s;
	   s=",\n";
	   string ss = "\t\t{ ";
	   for(int i=0; i< v.n; ++i)
	   {
	   cout << ss << (v(i,j)) ; 
	   ss = ", " ;
       }
	   cout << " } /* "<< j << " */ " ;
    }
   cout << " }; \n";
   return 1; 
}
func int [int,int] renum(int [int,int] & v,int[int] &I,int[int] &J)
{
  int [int,int] w(I.n,J.n);
  w=0; 
  for(int i=0; i<I.n;++i)
  for(int j=0; j<J.n;++j)
  {
	  int iv = I[i];
	  int jv= J[j];
	  if( iv >=0 && jv>=0)
      w(i,j) = v(iv,jv);
 }
  return w; 
}

func int [int,int] renum1(int [int,int] & v,int[int] &I,int[int] &J)
{
  int [int,int] w(I.n,J.n);
  w=0; 
  for(int i=0; i<I.n;++i)
  for(int j=0; j<J.n;++j)
  {
	  int iv = I[i];
	  int jv= J[j];
	  if( iv >=0 && jv>=0)
      w(iv,jv) = v(i,j);
 }
  return w; 
}

func int [int] renum(int [int] & v,int[int] &I)
{
  int [int] w(I.n);
  w=0; 
  for(int i=0; i<I.n;++i)
  {
	  int iv = I[i];
	  if( iv >=0 )
      w(i) = v(iv);
 }
  return w; 
}

func int [int] renum1(int [int] & v,int[int] &I)
{
  int [int] w(I.n);
  w=0; 
  for(int i=0; i<I.n;++i)
  {
	  int iv = I[i];
	  if( iv >=0 )
      w(iv) = v(i);
 }
  return w; 
}

func bool  CCt(string t,real[int,int] & v)
{ real[int,int] vt = v';
   CC(t,vt); 
}
func bool  CCt(string t,int[int,int] & v)
{ int[int,int] vt = v';
   CC(t,vt); 
}
/*
  a function do movemesh add some laplacien smoothing before movemesh
    Th mesh, 
    lab the array of label with fixe diplacement  on boundary
    ux,uy the x,y movevement (P1 fespace on Th)
    nstep : max number of laplacien smoothing
*/
func mesh movemeshsmooth(mesh & Th,int[int] &lab,real[int] &ux,real[int] &uy,int nstep)
{
fespace WWWWWh(Th,P1); 
WWWWWh u,v;
WWWWWh uo,vo;
u[]=ux;
v[]=uy; 
uo[]=ux;
vo[]=uy; 
varf vmass(u,v) = int2d(Th)(u*v/area);
varf vmass1(u,v) = int2d(Th)(v/area);
varf vonu(u,v) = on(lab,u=uo);
varf vonv(u,v) = on(lab,u=vo);
matrix Mg = vmass(WWWWWh,WWWWWh);
real[int] Dii =  vmass1(0,WWWWWh);
real[int] D1(Dii.n); D1=1;
D1 = D1 ./ Dii;  
int step ;
for(step= 0; step < nstep; ++ step)
{
	real[int] um=Mg*u[];
	um ./= Dii; 
	um += vonu(0,WWWWWh,tgv=1);
	real[int] vm=Mg*v[];
	vm ./= Dii; 
	vm += vonv(0,WWWWWh,tgv=1);
	u[] -= um;
	v[] -= vm;
	
	real err = u[].linfty + v[].linfty ;
	u[]=um;
	v[]=vm; 
	if(verbosity>5) cout << " err  "<< err << " " << step <<  endl;

	if(verbosity>9999){
		if(verbosity>99999) plot([u,v], wait=1);
	    mesh Thm= movemesh(Th,[u,v]);
	    plot(Thm,Th);
     }
	if(err < 1e-6) break; 
}
return movemesh(Th,[u,v]);
}
/*
// For test ... 
//  smothing before move mesh
mesh Th=square(3,3);
int[int] lab=[1,2,3,4]; 
Th=adaptmesh(Th,0.1,IsMetric=1);
fespace Vh(Th,P1); 

Vh u=x,v=y;
verbosity=10; 
Th=movemeshsmooth(Th,lab,u[],v[],100);
*/
NewMacro DMMDeffuncAndGlobals(prefix,comm,jpart,Whi,Vhc,Pknbcomp,Ai,vPbC,onG10,Pii,Usend,Vrecv,U2V)
/*
    
*/

int prefix#rgmres=0;
int prefix#kiter=-1;
/*  the global name user... */
/*
  jpart,njpart : partition 
  Usend, Vrecv : buffer
  Ai , Bi 
  rMj, sMj : matrices
  
  onG10:  tgv only on DDM s Gamma and not on Gamma
*/
/*----  for coarse  solver ... */


matrix prefix#AC,prefix#Rci,prefix#Pci;/**/
{
int[int] Sigma11=U2V;   
prefix#Pci=   interpolate(Whi,VhC,U2Vc=Sigma11);
prefix#Rci =  prefix#Pci'*Pii; 
/*Rci=   interpolate(Whi,VhC,t=1,U2Vc=Sigma11(0:Pknbcomp-1));
Pci =  Pii*Rci'; */
}

/*----End of Global Def -------------*/

/*-----------------*/
/*-----------------*/


func bool prefix#Update(real[int] &ui, real[int] &vi)
{
  for(int j=0;j<jpart.n;++j)
    Usend[j][]=sMj[j]*ui; 
   SendRecvUV(comm,jpart,Usend,Vrecv)
     vi = Pii*ui;
   for(int j=0;j<jpart.n;++j)
     vi += rMj[j]*Vrecv[j][]; 
   return true;
}
/*-----------------*/
/*-----------------*/
/*-----------------*/
 
func bool  prefix#CoarseSolve(real[int]& V,real[int]& U,mpiComm& comm)
{
    if(prefix#AC.n==0 && mpiRank(comm)==0)
      prefix#AC = vPbC(VhC,VhC,solver=sparsesolver);
   /*  solvibg the coarse probleme */
   real[int] Uc(prefix#Rci.n),Bc(Uc.n); 
   Uc= prefix#Rci*U;
   mpiReduce(Uc,Bc,processor(0,comm),mpiSUM);
   if(mpiRank(comm)==0) 
      Uc = prefix#AC^-1*Bc;
    broadcast(processor(0,comm),Uc);
   V = prefix#Pci*Uc;
}

/*-----------------*/
/*-----------------*/
/*-----------------*/

func real[int] prefix#DJ(real[int]& U)
{ 
  ++prefix#kiter;
  real[int] V(U.n); 
  V =  Ai*U;
  V = onG10 ? 0.: V;  
  return V; 
}

func real[int] prefix#PDJ(real[int]& U) /* C1*/
{ 
  real[int] V(U.n); 
  
  real[int] b= onG10 ? 0. :  U; 
  V =  Ai^-1*b;	
  prefix#Update(V,U);
  return U; 
}

func real[int] prefix#PDJC(real[int]& U) /**/ 
{ /* Precon  C1= Precon , C2  precon Coarse
   Idea : F. Nataf. 
     0 ~  (I-C1A)(I-C2A) => I ~  - C1AC2A +C1A +C2A 
     New Prec P= C1+C2 - C1AC2   = C1(I- A C2) +C2
   (  C1(I- A C2) +C2 ) Uo 
     V =  - C2*Uo
  .... */
  real[int] V(U.n); 
  prefix#CoarseSolve(V,U,comm);
  V = -V; /*  -C2*Uo  */
  U  += Ai*V; /* U =  (I-A C2) Uo */
  real[int] b= onG10 ? 0. :  U; 
  U =  Ai^-1*b;	/*  ( C1( I -A C2) Uo */
  V = U -V; /**/
  prefix#Update(V,U);
  return U; 
}

/*-----------------*/
/*-----------------*/
/*-----------------*/

func real[int] prefix#PDJC2(real[int]& U) /*  bogus ???? */
{ /* Precon  C1= precon Coarse C2  precon Precon
   Idea : F. Nataf. 
      0 ~  (I C1A)(I-C2A) => I ~  - C1AC2A +C1A +C2A 
      New Prec P= C1+C2 - C1AC2   = C1(I- A C2) +C2
      (  C1(I- A C2) +C2 ) Uo 
      V =  - C2*Uo
      .... 
      V = - C2 Uo 
      W = Uo + A V 
      V + C1 W  
      */
  real[int] V(U.n);
  real[int] b= onG10 ? 0. :  U; 
  V =  Ai^-1*b;	
  b=U; 
  
  V = -V; 
  prefix#Update(V,U);
  U  += Ai*V;  

  prefix#CoarseSolve(U,b,comm);
  V = U -V;   
  prefix#Update(V,U);
  return U; 
}
/*-----------------*/
/*-----------------*/
/*-----------------*/

 func real[int] prefix#DJ0(real[int]& U)
{ 
  ++prefix#kiter;
  real[int] V(U.n); 
  real[int] b= onG10 .* U;
  b  = onG10 ? b : Bi ;  
  V = Ai^-1*b;	
  prefix#Update(V,U);
  V -= U;
   return V; 
}

/*-----------------*/
/*-----------------*/
/*-----------------*/

func bool  prefix#CheckUpdate()
{ /* verification.....*/

  Whi defPk#Pknbcomp(u,) =Times#Pknbcomp(1),defPk#Pknbcomp(v,);
  prefix#Update(u[],v[]);
  u[]-=v[];
  if(mpirank==0 || (u[].linfty>1e-6)) 
     cout << "CheckUpdate  " << u[].linfty << " rank: " << mpirank <<endl;
  if(u[].linfty>1e-6) plot(u,cmm="bug ????");
  assert( u[].linfty<1e-6); 
  
  return 1; }

func bool prefix#Saveff(string sff,real epss,int ksplit,int nloc,int sizeoverlaps)
{  if(sff != "")
  {
    ofstream ff(sff+".txt",append);
    cout << " ++++  " ;
    cout  << mpirank <<"/" <<  mpisize << " k=" <<  ksplit << " n= " << nloc << " " 
           << sizeoverlaps << " it=  " << prefix#kiter  ;  
    for (int i=1; i<ittt;++i)	
      cout << " " << ttt[i]-ttt[i-1] << " ";
    cout << epss << " " << Ai.nbcoef << " " << Ai.n << endl;
    
    /*
      1 mpirank
      2 mpisize 
      3 ksplit 
      4 nloc
      5 sizeoverlaps
      6 kiter
      7 mesh & part build  
      8 build the partion 
      9 build mesh, transfere , and the fine mesh .. 
      10 build the matrix,  the trans matrix, factorizatioon 
      11 GMRES 
    */
    ff   << mpirank << " " << mpisize << " " << sPk << " " ;
    ff <<  ksplit << " " << nloc << " " << sizeoverlaps << " " << prefix#kiter  ;  
    for (int i=1; i<ittt;++i)	
      ff << " " << ttt[i]-ttt[i-1] << " ";
    ff << epss << " " << Ai.nbcoef << " " << Ai.n << " " << gmres << endl;
    
  }
  return 1;
}
//
/*-----------------*/
/*-----------------*/
/*-----------------*/
/*-----------------*/
/*-----------------*/


NewMacro prefix#DDMSolver(Bi,u,v,gmres,epss,vdebug) 
{
 settt
 int ipart=mpiRank(comm);
 if(gmres==1)
  {
   prefix#rgmres=MPIAffineGMRES(prefix#DJ0,u[],veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
   real[int] b= onG10 .* u[];
   b  = onG10 ? b : Bi ;
   v[] = Ai^-1*b;	
   prefix#Update(v[],u[]);
  }
else if(gmres==2)
  prefix#rgmres= MPILinearGMRES(prefix#DJ,precon=prefix#PDJ,u[],Bi,veps=epss,nbiter=1000,comm=comm,
                         dimKrylov=100,verbosity=ipart ? 0: 50);
else if(gmres==3)
  prefix#rgmres= MPILinearGMRES(prefix#DJ,precon=prefix#PDJC,u[],Bi,veps=epss,nbiter=1000,comm=comm,
                          dimKrylov=100,verbosity=ipart ? 0: 50);
else if(gmres==4)
   prefix#rgmres= MPILinearGMRES(prefix#DJ,precon=prefix#PDJC2,u[],Bi,veps=epss,nbiter=1000,comm=comm,
                          dimKrylov=100,verbosity=ipart ? 0: 50);
else /*algo Shwarz for demo */
   for(int iter=0;iter <100; ++iter)
     {
       prefix#kiter=iter;
       real[int] b= onG10 .* u[];
       b  = onG10 ? b : Bi ;
       v[] = Ai^-1*b;	
       b=v[];
       prefix#Update(v[],u[]);
       if(vdebug) plotMPIall(Thi,u[],"u-"+iter);
        b -= u[];
       
       real err = b.l1;
       real umax = u[].max;
       real[int] aa=[err,umax], bb(2);
       mpiAllReduce(aa,bb,comm,mpiMAX);
       real errg = bb[0];
       real umaxg = bb[1];
       
       if(ipart==0)
	     cout << ipart << " " << iter << " err = " << errg << " u. max  " << umaxg << endl;
       if(errg< 1e-10 ) break;
     }
     prefix#Update(u[],v[]);  
 
if(vdebug) plotMPIall(Thi,v[],"u-final");
 u[]=v[];
 settt
}
EndMacro  /*prefix#DDMSolver*/

EndMacro



macro buildcobramesh(meshname)
{

int m11 = max(1., sec1/sec3 * nloc);
int m12 = max(1., 2*(radius-height)*sin(angle/npangler/2)/sec3 * nloc);
int m13 = max(1., sec2/sec3 * nloc);
int m14 = max(1., 2*radius*sin(angle/npangleR/2)/sec3 * nloc);
int m15 = max(1., 1.*nloc);
int m2 = max(1., height/sec3 * nloc);
int mmextz = max(1., distz/sec3 * nloc);
int mmz = max(1., width/sec3 * nloc);
int mmextx = max(1.,(height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))/sec3 * nloc);
int mmexty = max(1.,(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3 + distx+distx)/sec3 * nloc);

border b11 (t=0, sec1){x=t;y=0;label=labmetal;}
border b12 (t=0, 2*(radius-height)*sin(angle/npangler/2); i){
	real l = 2*(radius-height)*sin(angle/npangler/2);
	real xpos = sec1;
	real ypos = 0;
	for (int j=0; j<i; j++) {
      xpos+=cos(angle/npangler/2+(j*angle/npangler))*l;
	  ypos-=sin(angle/npangler/2+(j*angle/npangler))*l;
	}
	x = xpos + cos(angle/npangler/2+(i*angle/npangler))*t;
	y = ypos - sin(angle/npangler/2+(i*angle/npangler))*t;

	label=labmetal;
}
border b13 (t=0, sec2){	
	real xpos = sec1+(radius-height)*sin(angle);
	real ypos = (radius-height)*cos(angle)-(radius-height);
	
	x=xpos+t*cos(angle);
	y=ypos-t*sin(angle);
	
	label=labmetal;
}

border b14 (t=0, 2*radius*sin(angle/npangleR/2); i){
	real xpos = sec1+(radius-height)*sin(angle)+sec2*cos(angle);
	real ypos = (radius-height)*cos(angle)-(radius-height)-sec2*sin(angle);
	
	real l2 = 2*radius*sin(angle/npangleR/2);
	for (int j=0; j<i; j++) {
      xpos+=cos(angle-(angle/npangleR/2+(j*angle/npangleR)))*l2;
	  ypos-=sin(angle-(angle/npangleR/2+(j*angle/npangleR)))*l2;
	}
	x = xpos + cos(angle-(angle/npangleR/2+(i*angle/npangleR)))*t;
	y = ypos - sin(angle-(angle/npangleR/2+(i*angle/npangleR)))*t;
	
	label=labmetal;
}

border b15 (t=0, sec3){
	x=sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+t;
	y=(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle);
	label=labmetal;
}

border b2 (t=0, height){
	x=sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3;
	y=(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)+t;
	label=labo;
}

border b21 (t=sec1, 0){
	x=t;
	y=height;
	label=labmetal;
}

border b22 (t=2*radius*sin(angle/npangleR/2), 0; i){
	real xpos = sec1;
	real ypos = height;
	
	real l2 = 2*radius*sin(angle/npangleR/2);
	for (int j=0; j<i; j++) {
      xpos+=cos(angle/npangleR/2+(j*angle/npangleR))*l2;
	  ypos-=sin(angle/npangleR/2+(j*angle/npangleR))*l2;
	}
	x = xpos + cos(angle/npangleR/2+(i*angle/npangleR))*t;
	y = ypos - sin(angle/npangleR/2+(i*angle/npangleR))*t;
	
	label=labmetal;
}

border b23 (t=sec2, 0){
	x=sec1+radius*sin(angle)+t*cos(angle);
	y=height+radius*cos(angle)-radius-t*sin(angle);
	label=labmetal;
}

border b24 (t=2*(radius-height)*sin(angle/npangler/2), 0; i){
	real l = 2*(radius-height)*sin(angle/npangler/2);
	real xpos = sec1+radius*sin(angle)+sec2*cos(angle);
	real ypos = height+radius*cos(angle)-radius-sec2*sin(angle);
	for (int j=0; j<i; j++) {
      xpos+=cos(angle-(angle/npangler/2+(j*angle/npangler)))*l;
	  ypos-=sin(angle-(angle/npangler/2+(j*angle/npangler)))*l;
	}
	x = xpos + cos(angle-(angle/npangler/2+(i*angle/npangler)))*t;
	y = ypos - sin(angle-(angle/npangler/2+(i*angle/npangler)))*t;

	label=labmetal;
}

border b25 (t=sec3, 0){
	x=sec1+radius*sin(angle)+sec2*cos(angle)+(radius-height)*sin(angle)+t;
	y=height+radius*cos(angle)-radius-sec2*sin(angle)-(radius-height)+(radius-height)*cos(angle);
	label=labmetal;
}

border b3 (t=height, 0){
	x=0; 
	y=t;
	label=labi;
}

border ext1 (t=height+disty,(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty) {
	x=-distx;
	y=t;
	label = labextxm;
}

border ext2 (t=-distx, sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3 + distx) {
	x=t;
	y= (radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty;
	label = labextym;
}

border ext3 (t=(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,height+disty) {
	x=sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3 + distx;
	y=t;
	label = labextxM;
}

border ext4 (t=sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3 + distx, -distx) {
	x=t;
	y=height+disty;
	label = labextyM;
}


int[int] tm12(npangler);
tm12 = m12;

int[int] tm14(npangleR);
tm14 = m14;

/*
plot((b11(m11)+b12(tm12)+b13(m13)+b14(tm14)+b15(m15)+b2(m2)+b25(m15)+b24(tm12)+b23(m13)+b22(tm14)+b21(m11)+b3(m2)+ext1(mmextx)+ext2(mmexty)+ext3(mmextx)+ext4(mmexty)));
*/

mesh Th2 = buildmesh(b11(m11)+b12(tm12)+b13(m13)+b14(tm14)+b15(m15)+b2(m2)+b25(m15)+b24(tm12)+b23(m13)+b22(tm14)+b21(m11)+b3(m2)+ext1(mmextx)+ext2(mmexty)+ext3(mmextx)+ext4(mmexty),fixedborder=1);

fespace Uh2(Th2,P0);

Uh2 reg = region;

int regint2d = reg(0.1*height,0.1*height);
int regext2d = reg(-0.1*height,-0.1*height);

/*cout << regint2d << " " << regext2d << endl;*/

/*
plot(Th2);
*/

mesh3[int] meshtab(3);

int[int] lup = [regint2d,labextzm,regext2d,labextzm];
int[int] ldown = [regint2d,labtomerge,regext2d,labtomerge];
int[int] lmid = [labi,labtomerge,labo,labtomerge,labmetal,labtomerge,labextxm,labextxm,labextxM,labextxM,labextym,labextym,labextyM,labextyM];
int[int] lregion = [regint2d,regext,regext2d,regext];

meshtab[0] = buildlayers( Th2, mmextz, zbound = [ -distz, 0 ], labelup=ldown,labeldown=lup,labelmid=lmid,region=lregion);

lup = [regint2d,labextzM,regext2d,labextzM];

meshtab[2] = buildlayers( Th2, mmextz, zbound = [ width, width+distz ], labelup=lup,labeldown=ldown,labelmid=lmid,region=lregion);

int[int] lupint = [regint2d,labmetal,regext2d,labtomerge];
int[int] ldownint = [regint2d,labmetal,regext2d,labtomerge];
int[int] lmidint = [labi,labi,labo,labo,labmetal,labmetal,labextxm,labextxm,labextxM,labextxM,labextym,labextym,labextyM,labextyM];
int[int] lregionint = [regint2d,regint,regext2d,regext];

meshtab[1] = buildlayers( Th2, mmz, zbound = [ 0, width ], labelup=lupint,labeldown=ldownint,labelmid=lmidint,region=lregionint);

meshname = gluemesh(meshtab,labtodel=labtomerge);
} // EOM



macro PLOTMPIALL(mesh,Pk, Th, u, plotparm)
{ int ver=verbosity;
  verbosity=0;
  if(NoGraphicWindow==0)
  { 
  if(mpirank==0)
    {
      mesh Thi=Th;
      mesh[int] ath(mpisize);
      fespace Xh(Thi,Pk);
      Xh[int] uh(mpisize);
      if(Xh.ndof != u.n)
      {
      cout << " BUG : ndof " <<  Xh.ndof << " size u " << u.n << endl ;
      assert(Xh.ndof == u.n);
       }
      uh[0][]=u;
      ath[0]=Th;
      mpiRequest[int] rq(mpisize-1),rq1(mpisize-1);
      for(int i= 1; i <mpisize;++i)
	   Irecv(processor(i,rq[i-1]),ath[i]);
      for (int i=1;i<mpisize;++i)
       	int k= mpiWaitAny(rq);
      for (int i=1;i<mpisize;++i)
	   { Thi=ath[i];
	     Irecv(processor(i,rq1[i-1]),uh[i][]);}
      for (int i=1;i<mpisize;++i)
       	int k= mpiWaitAny(rq1); 
      plot(uh,plotparm);
    }
  else
    {
     mpiRequest rq;   
     Isend(processor(0,rq),Th); 
     mpiWait(rq);
     Isend(processor(0,rq),u); 
     mpiWait(rq); 
    }
  mpiBarrier(mpiCommWorld);
  }
  verbosity=ver;
  return true;
}
//EOM ...
load "medit"
load "mmg"
// 2 basic functions to build surface mesh 
/*  Usage:
  meshS   SurfaceHex(N,B,L,orient);
  --   build the surface mesh of a 3d box 
  where: for example:
    int[int]  N=[nx,ny,nz]; //  the number of seg in the 3 direction
    real [int,int]  B=[[xmin,xmax],[ymin,ymax],[zmin,zmax]]; // bounding bax  
    int [int,int]  L=[[1,2],[3,4],[5,6]]; // the label of the 6 face left,right, front, back, down, right
    orient the global orientation of the surface 1 extern (-1 intern)


  func meshS Sphere(real R,real h,int L,int orient);
  -- build a surface mesh of a sphere with 1 mapping (spheriale coordinate) 
     where R is  the raduis, 
     h is the mesh size  of  the shpere
     L is the label the the sphere
     orient the global orientation of the surface 1 extern (-1 intern

  func  meshS Icosahedron (int orientation)
   -- build a Icosahedron meshS with given orientation.
      with a region number go from 1  to 20 corresponding to the 20 faces

  func meshS Sphere20(real R,int N,int orient);
  -- build a sphere  mesh form a Isocaedron with each traingle subdivide by N^2
      with a region number go from 1  to 20 corresponding to the 20 faces
     orient the global orientation of the surface 1 extern (-1 intern

*/
func meshS SurfaceHex(int[int] & N,real[int,int] &B ,int[int,int] & L,int orientation)
{
    real x0=B(0,0),x1=B(0,1);
    real y0=B(1,0),y1=B(1,1);
    real z0=B(2,0),z1=B(2,1);
    
    int nx=N[0],ny=N[1],nz=N[2];
    
    mesh Thx = square(ny,nz,[y0+(y1-y0)*x,z0+(z1-z0)*y]);
    mesh Thy = square(nx,nz,[x0+(x1-x0)*x,z0+(z1-z0)*y]);
    mesh Thz = square(nx,ny,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
    
    int[int] refx=[0,L(0,0)],refX=[0,L(0,1)];   //  Xmin, Ymax faces labels renumbering 
    int[int] refy=[0,L(1,0)],refY=[0,L(1,1)];   //  Ymin, Ymax faces labesl renumbering 
    int[int] refz=[0,L(2,0)],refZ=[0,L(2,1)];   //  Zmin, Zmax faces labels renumbering 
    
    meshS Thx0 = movemesh23(Thx,transfo=[x0,x,y],orientation=-orientation,region=refx);
    meshS Thx1 = movemesh23(Thx,transfo=[x1,x,y],orientation=+orientation,region=refX);
    meshS Thy0 = movemesh23(Thy,transfo=[x,y0,y],orientation=+orientation,region=refy);
    meshS Thy1 = movemesh23(Thy,transfo=[x,y1,y],orientation=-orientation,region=refY);
    meshS Thz0 = movemesh23(Thz,transfo=[x,y,z0],orientation=-orientation,region=refz);
    meshS Thz1 = movemesh23(Thz,transfo=[x,y,z1],orientation=+orientation,region=refZ);
    meshS Th= Thx0+Thx1+Thy0+Thy1+Thz0+Thz1;
    return Th;
}
func meshS Ellipsoide (real RX,real RY,real RZ,real h,int L,real Ox,real Oy,real Oz,int orientation)
{
  mesh  Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
  //  a parametrization of a sphere 
  func f1 =RX*cos(x)*cos(y)+Ox;
  func f2 =RY*cos(x)*sin(y)+Oy;
  func f3 =RZ*sin(x)+Oz;
  //    partiel derivative 
  func f1x= -RX*sin(x)*cos(y);   
  func f1y= -RX*cos(x)*sin(y);
  func f2x= -RY*sin(x)*sin(y);
  func f2y= +RY*cos(x)*cos(y);
  func f3x=-RZ*cos(x);
  func f3y=0;
  // the metric on the sphere  $  M = DF^t DF $
  func m11=f1x^2+f2x^2+f3x^2;
  func m21=f1x*f1y+f2x*f2y+f3x*f3y;
  func m22=f1y^2+f2y^2+f3y^2;
  
  func perio=[[4,y],[2,y],[1,x],[3,x]];  // to store the periodic condition 
  real hh=h;// hh  mesh size on unite sphere
  real vv= 1/square(hh);
  Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
  Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
  Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
  Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
  int[int] ref=[0,L];  
  meshS  ThS= movemesh23(Th,transfo=[f1,f2,f3],orientation=orientation,reftri=ref);
  ThS=mmgs(ThS,hmin=h,hmax=h,hgrad=2.);
  return ThS;
}
 
func meshS Ellipsoide (real RX,real RY,real RZ,real h,int L,int orientation)
{ 
 return Ellipsoide (RX,RY,RZ,h,L,0.,0.,0.,orientation);
}

func meshS Sphere(real R,real h,int L,int orientation)
{

  return Ellipsoide(R,R,R,h,L,orientation);
}

func meshS Sphere(real R,real h,int L,real Ox,real Oy,real Oz,int orientation)
{

  return Ellipsoide(R,R,R,h,L,Ox,Oy,Oz,orientation);
}

func meshS Icosahedron (int orientation,int wplot)
{
	
//===================================================================================
//Angles utiles
//===================================================================================
real tan3pi10 = sqrt(25.+10.*sqrt(5.))/5.;//3pi/10 angle entre deux aretes du pentagone
real sin3pi10 = (sqrt(5)+1)/4;//3pi/10 angle entre deux aretes du pentagone
real cos3pi10 = sqrt(10-2*sqrt(5))/4;//3pi/10 angle entre deux aretes du pentagone

real cosdiedre = sqrt(5)/3; //angle diedre de l'icosaedre -pi/2
real sindiedre = 2./3; //angle diedre de l'icosaedre -pi/2

real cosico = tan3pi10/sqrt(3); //angle entre une face de la pyramide pentagonale par rapport à l'horizontale
real sinico = sqrt(1-square(cosico)); //angle entre une face de la pyramide pentagonale par rapport à l'horizontale

real sin2pi5 = sqrt(10+2*sqrt(5))/4; //2pi/5 angle pour la rotation des aretes du pentagone
real cos2pi5 = (sqrt(5)-1)/4; //2pi/5 angle pour la rotation des aretes du pentagone

real cosicod = cosdiedre*cosico+sindiedre*sinico;//angle diedre -pi/2 - ico
real sinicod = sindiedre*cosico-cosdiedre*sinico;//angle diedre -pi/2 - ico


real sinpi3 = sqrt(3)/2; //angle du triangle equilateral

int n = 1;

real sinpi5 = cos3pi10;//pi/5 angle de décalage entre deux demi icosaedre
real cospi5 = sin3pi10;//pi/5 angle de décalage entre deux demi icosaedre

real tanpi10 = sqrt(25.-10.*sqrt(5.))/5.;//pi/10 
real h = 0.5*sqrt(3-square(tanpi10));//hauteur du prisme d'ordre 5;

//=================================================================================
//Construction du triangle equilateral en 2D
//=================================================================================
border a(t=0,1){x=t; y=0; label =1;};
border b(t=1,0.5){x=t; y=sqrt(3)*(1-t); label =2;};
border c(t=0.5,0){x=t; y=sqrt(3)*(t); label =3;};
mesh Triangle= buildmesh(a(n)+b(n)+c(n)); //traingle equilateral
if(wplot>2) plot (cmm="Triangle",Triangle,wait=1);

func f = 1;


meshS Triangle3 = movemesh23(Triangle,transfo=[x,0,y]);//trianglesup
if(wplot>2) plot (cmm="Triangle3",Triangle3,wait=1); 

meshS TriangleS = change(fregion=1,movemeshS(Triangle3,transfo=[x,sinico*y+cosico*z,-cosico*y+sinico*z]));//rotation de -(pi - diedre) par rapport à l'axe des x pour former une face de la pyramide pentagonale
if(wplot>2) plot (cmm="TriangleS",TriangleS,wait=1);
//medit("face pyramide pentagonale",TriangleS);

meshS TriangleI = change(fregion=2,movemeshS(TriangleS,transfo=[x,-cosdiedre*y+sindiedre*z,-sindiedre*y-cosdiedre*z],orientation=-1));//triangle inf rotation de l'angle diedre par rapport au triangle sup
if(wplot>2) plot (cmm="TriangleI",TriangleI,wait=1);

meshS Triangles = TriangleI+TriangleS;

if(wplot>1) plot (cmm="Triangles",Triangles,wait=1);
//medit("face pyramide pentagonale + face antiprisme d'ordre 5",Triangles);

meshS T1 = change(movemeshS(Triangles,transfo=[x-0.5,y-sinpi3*cosico,z],orientation=1),fregion = region);//translation pour que la figure soit sur le bord du pentagone
meshS T2 = change(movemeshS(T1,transfo=[cos2pi5*x-sin2pi5*y,sin2pi5*x+cos2pi5*y,z],orientation=1),fregion = region+2);;
meshS T3 = change(movemeshS(T2,transfo=[cos2pi5*x-sin2pi5*y,sin2pi5*x+cos2pi5*y,z]),fregion = region+2);;
meshS T4 = change(movemeshS(T3,transfo=[cos2pi5*x-sin2pi5*y,sin2pi5*x+cos2pi5*y,z]),fregion = region+2);;
meshS T5 = change(movemeshS(T4,transfo=[cos2pi5*x-sin2pi5*y,sin2pi5*x+cos2pi5*y,z]),fregion = region+2);;

meshS Tdemi= T1+T2+T3+T4+T5;//moitié de l'icosaedre
meshS Tdemi0 = movemeshS(Tdemi,transfo=[x,y,z+0.5*h]);//moitié supérieure
meshS Tdemi1 = movemeshS(Tdemi0,transfo=[x,y,-z]);//moitié inférieure
meshS Tdemi1rot = change(movemeshS(Tdemi1,transfo=[cospi5*x-sinpi5*y,sinpi5*x+cospi5*y,z],orientation=-1),fregion = region+10);//rotation de la moitié inférieure pour les emboiter
meshS Ticosaedre = Tdemi0+Tdemi1rot;
//Ticosaedre=trunc(Ticosaedre,1,split=5);
if(wplot) plot(Ticosaedre,wait=1);
//cout << regions(Ticosaedre) << endl; 
return Ticosaedre;
}

func  meshS Icosahedron (int orientation)
{
 return Icosahedron(orientation,0);
}
func meshS Sphere20 (real R,int N,int orientation,int wplot)
{// Isocaedre regulier !!!!  Thank G. Vergez ..
meshS Ticosaedre = Icosahedron(orientation,wplot);
Ticosaedre=trunc(Ticosaedre,1,split=N);
if(wplot) plot(cmm="Icosaedre",Ticosaedre,wait=1);

//=================================================================================
//Construction de la sphere 3D
//=================================================================================
func metric =dist(x,y,z)/R;
meshS Th = movemeshS(Ticosaedre,transfo=[x/metric,y/metric,z/metric]); 
if(wplot) plot (cmm="Th",Th,wait=1);
return Th;
}

func meshS Sphere20 (real R,int N,int orientation)
{
  return Sphere20(R,N,orientation,0);
}

/*  test: 
 load "tetgen" 
  {   
    real hs = 0.1;  // mesh size on sphere 
    int[int]  N=[20,20,20];
    real [int,int]  B=[[-1,1],[-1,1],[-1,1]];
    int [int,int]  L=[[1,2],[3,4],[5,6]];
    
    ////////////////////////////////
    meshS ThH = 
	(N,B,L,1);
    meshS ThS =Sphere(0.5,hs,7,1); // "gluing" surface meshs to tolat boundary meshes
    cout << " xxxx" << ThH.nv << " " << ThS.nv << endl;
    
    meshS ThHS=ThH+ThS;
    savemesh(ThHS,"Hex-Sphere.mesh");
    exec("ffmedit Hex-Sphere.mesh;rm Hex-Sphere.mesh");
    
    real voltet=(hs^3)/6.;
    cout << " voltet = " << voltet << endl;
    real[int] domaine = [0,0,0,1,voltet,0,0,0.7,2,voltet];
  
    mesh3 Th = tetg(ThHS,switch="pqaAAYYQ",nbofregions=2,regionlist=domaine);    
    medit("Cube-With-Ball",Th);
  }

*/
// --------------------------------------------------------------------------
// Definition of Kinematics Operators
// --------------------------------------------------------------------------
// notation ...\hfilll
//
// all 2x2 symetric matrix [[a11,a12], [a21,a22]  are see as an array \hfilll
// [a11,a22,a12] .. \hfilll
//  the strain(d) = $ \varepsilon(d) =  (\nabla d + {}^t(\nabla d)/2 $  matrix is \hfilll
//  we always use the differential notation \hfilll
// so   $F(y)$ is a fonction ; when $ dy \mapsto dF(y,dy)$ is the Frechet differentiel \hfilll
// add  second Frechet differentiel is $ (dy,ddy)  \mapsto ddF(y,dy,ddy)$ \hfilll

// --------------------------------------------------------------------------
// the vector displacement parameter d = [d1,d2] \hfilll
macro Strain2(d) 
[ 
dx(d[0]), 
dy(d[1]), 
dy(d[0])+dx(d[1])  
] //EOM 

// --------------------------------------------------------------------------
// definition of C(d)  = $ {}^t F F$   and 2 differentiel
// with  , with $F = Id + \nabla d$ where $Id$ is the identity matrix 
macro C2(d)
[
1. + 2.*dx(d[0]) + dx(d[0])*dx(d[0]) + dx(d[1])*dx(d[1]) ,
1. + 2.*dy(d[1]) + dy(d[0])*dy(d[0]) + dy(d[1])*dy(d[1]) , 
 dy(d[0]) + dx(d[1])  + dx(d[0])*dy(d[0]) + dx(d[1])*dy(d[1]) 
] //
macro dC2(d,dd)
[
 2.*dx((dd)[0]) + 2.*dx((dd)[0])*dx(d[0]) + 2.*dx((dd)[1])*dx(d[1]) ,
 2.*dy((dd)[1]) + 2.*dy((dd)[0])*dy(d[0]) + 2.*dy((dd)[1])*dy(d[1]) , 
 dy((dd)[0]) + dx((dd)[1])  + dx((dd)[0])*dy(d[0]) + dx((dd)[1])*dy(d[1]) 
                        + dx(d[0])*dy((dd)[0]) + dx(d[1])*dy((dd)[1]) 
] //
macro ddC2(dd,ddd)
[
  2.*dx((dd)[0])*dx((ddd)[0]) + 2.*dx((dd)[1])*dx((ddd)[1]) ,
  2.*dy((dd)[0])*dy((ddd)[0]) + 2.*dy((dd)[1])*dy((ddd)[1]) , 
    dx((dd)[0])*dy((ddd)[0]) + dx((dd)[1])*dy((ddd)[1]) 
  + dx((ddd)[0])*dy((dd)[0]) + dx((ddd)[1])*dy((dd)[1]) 
] //

// --------------------------------------------------------------------------
// definition of the 3 invariant I[0], I[1], I[2]in 2d 
// so the value is an array size 3 . 
// I2C (I (C) 2d ..) 
// 
//  I[0] = trace(C) +1 
//  I[1] = (trace(C)^2 - trace(C^2) )/2
//  I[2] = det(C) 
//   ************** BIZARRE FH ***********************

macro I2C(C) 
[
  C[0] + C[1] + 1., 
  C[0]*C[1] + C[1] + C[0] - C[2]*C[2],
  C[0]*C[1] - C[2]*C[2]
] //EOM

macro dI2C(C,dC) 
 [ 
   dC[0] + dC[1] , 
   dC[0]*C[1] + dC[1] + dC[0] - 2.*dC[2]*C[2] + C[0]*dC[1], 
   dC[0]*C[1] + C[0]*dC[1] - 2.*C[2]*dC[2]
 ] // 

macro  ddI2C(dC,ddC) 
[ 
   0.*dC[0]*ddC[0] , 
   dC[0]*ddC[1]  - 2.*dC[2]*ddC[2] + ddC[0]*dC[1], 
   dC[0]*ddC[1] + ddC[0]*dC[1] - 2.*ddC[2]*dC[2] 
 ] // 
 

macro I2d(d) I2C(C2(d))  //
macro dI2d(d,dd)  dI2C( C2(d) , dC2(d,(dd)) ) //
macro ddI2d(d,dd,ddd)  ( ddI2C( dC2(d,(dd)),dC2(d,(ddd))  ) + dI2C( C2(d) , ddC2((dd),(ddd)) ) ) //
macro W2d(d) W(I2d(d)) //
macro dW2d(d,dd)  dW( I2d(d) , dI2d(d,(dd))  ) //
macro ddW2d(d,dd,ddd)  
(  ddW( I2d(d) , dI2d(d,(dd)) ,dI2d(d,(ddd)) )  + dW( I2d(d) , ddI2d(d,(dd),(ddd)) ) ) //



 
load "medit"
load "MUMPS_mpi"

include "getARGV.idp"// to process command line options

include "ffddm_parameters.idp"

include "ffddm_partitioning.idp"

include "ffddm_coarsemeshCS.idp"

include "ffddm_geneoCS.idp"

include "ffddm_functions.idp"

include "ffddm_geneoCS_3rdlvl.idp"

include "ffddm_geneoCS_saddlepoint.idp"

func string removespaces(string& str) {
	string res = "";
	for (int i = 0; i < str.size; i++)
	if (str(i:i) != " " && str(i:i) != "\t" && str(i:i) != "\n")
		res = res + str(i:i);
	return res;
}

macro ffddmsetupPrecondinit(pr)
IFMACRO(!pr#setupprecondinit)

IFMACRO(pr#localmacroaug,1)
matrix pr#CSinterp;
ENDIFMACRO

matrix<pr#prfe#K> pr#AglobEprec;
matrix<pr#prfe#K>[int] pr#aR(pr#prfe#prmesh#npart);       /* local (ras or Robin) matrices (for the preconditioner) */
matrix<pr#prfe#K> pr#aRdEprec;

string pr#prec = "none";

int pr#bCM = 0;

string pr#corr = "none";

matrix<pr#prfe#K> pr#E;
pr#prfe#K[int,int] pr#E0(1,1);
matrix<pr#prfe#K> pr#ZCM,pr#ZCMi,pr#ECM;

int pr#si;

int[int] pr#sizelg(pr#prfe#prmesh#npart), pr#offseti(pr#prfe#prmesh#npart);

int[int] pr#sizelgworld(mpiSize(pr#prfe#prmesh#mpicomm)), pr#offsetiworld(mpiSize(pr#prfe#prmesh#mpicomm));

int pr#ncoarsespace = 0;

pr#prfe#K[int][int] pr#Z(0);

int pr#nbiter = 0;

pr#prfe#K[int][int] pr#RitzValues(0),pr#RitzHarmonicValues(0);

ffddmgeneratePrecondfunctions(pr,pr#prfe)

NewMacro pr#setupprecondinit()1 EndMacro
ENDIFMACRO
// EOM

macro ffddmsetupOperatorinit(pr,preffe,preffe2)
IFMACRO(!pr#setupoperatorinit)

IFMACRO(pr#bem,1)
NewMacro pr#Tmatrix() HMatrix EndMacro
ENDIFMACRO
IFMACRO(!pr#bem)
NewMacro pr#Tmatrix() matrix EndMacro
ENDIFMACRO

NewMacro pr#localmacroaug preffe#prmesh#buildAug EndMacro

NewMacro pr#prfe()preffe EndMacro
NewMacro pr#prfe2()preffe2 EndMacro
int pr#isrect = Stringification(preffe) != Stringification(preffe2);

NewMacro pr#fromVhi(ui,VhName,res)
if (preffe#prmesh#isincomm)
{
	string str = Stringification(VhName);
	string svhglob = Stringification(preffe#Vhglob);
	string svhi = Stringification(preffe#Vhi);
	string svhaug = Stringification(preffe#AugVhi);
	string svhcoarse = Stringification(pr#VhCoarse);
	str = removespaces(str);
	svhglob = removespaces(svhglob);
	svhi = removespaces(svhi);
	svhaug = removespaces(svhaug);
	svhcoarse = removespaces(svhcoarse);
		
	if (bseq) {
		assert(ui.n == preffe#Vhglob.ndof);
		if (str == svhglob) {
			res = ui;
		}
		else if (str == svhi) {
			res = ui;	
		}
		else if (str == svhaug) {
			assert(0);
			IFMACRO(pr#localmacroaug,0)
			cout << "you need to use ffddmbuildaug" << endl;
			assert(0);
			ENDIFMACRO
			IFMACRO(pr#localmacroaug,1)
			res = preffe#Auginterp*ui;
			ENDIFMACRO
		}
		else if (str == svhcoarse) {
			IFMACRO(pr#localmacroaug,0)
			cout << "you need to use ffddmbuildaug" << endl;
			assert(0);
			ENDIFMACRO
			IFMACRO(pr#localmacroaug,1)
			res = pr#CSinterp*ui;
			ENDIFMACRO
		}		
		else {
			cout << "***** TODO *****" << endl;
			assert(0);
		}
	}
	else {
		assert(ui.n == preffe#Vhi.ndof);
		if (str == svhi) {
			res = ui;
		}
		else if (str == svhaug) {
			IFMACRO(pr#localmacroaug,0)
			cout << "you need to use ffddmbuildaug" << endl;
			assert(0);
			ENDIFMACRO
			IFMACRO(pr#localmacroaug,1)
			preffe#K[int] tmp = ui .* preffe#Dk[mpiRank(preffe#prmesh#commddm)];
			res = preffe#Auginterp'*tmp;
			preffe#Augupdate(res,false);
			ENDIFMACRO
		}
		else if (str == svhcoarse) {
			IFMACRO(pr#localmacroaug,0)
			cout << "you need to use ffddmbuildaug" << endl;
			assert(0);
			ENDIFMACRO
			IFMACRO(pr#localmacroaug,1)
			preffe#K[int] tmp(res.n);
 			if (!preffe#prmesh#excluded) {
				preffe#K[int] ls = ui .* preffe#Dk[mpiRank(preffe#prmesh#commddm)];
			    tmp = pr#CSinterp*ls;
			}
			else
				tmp = 0;
			res = 0;
			mpiReduce(tmp,res,processor(0,preffe#prmesh#mpicomm),mpiSUM);
			if (mpiRank(preffe#prmesh#mpicomm) < preffe#prmesh#pCS)
		  	broadcast(processor(0,preffe#prmesh#commCS),res);
		  	ENDIFMACRO
		}
		else {
			preffe#K[int] inttmp(VhName.ndof);
			inttmp = 0;
			if (!preffe#prmesh#excluded) {
				IFMACRO(preffe#K,complex)
				matrix Mintr = interpolate(preffe#Vhi,VhName);
				matrix<complex> Mint = Mintr;
				ENDIFMACRO
				IFMACRO(preffe#K,real)
				matrix Mint = interpolate(preffe#Vhi,VhName);
				ENDIFMACRO
				preffe#K[int] inttmp2 = ui .* preffe#Dk[mpiRank(preffe#prmesh#commddm)];
				inttmp = Mint'*inttmp2;
			}
			mpiAllReduce(inttmp,res,preffe#prmesh#mpicomm,mpiSUM);
		}
	}
}
EndMacro

real pr#tdirect = 0, pr#teigenv = 0, pr#tbuildE = 0, pr#ttotal = 0;
real pr#tgmresi, pr#tpreci, pr#tmvi, pr#tfactoi, pr#ttotali;
real pr#tgmres = 0, pr#tprec = 0, pr#tmv = 0, pr#tfacto =0;
real pr#tscalprod = 0;
real pr#tloc = 0, pr#tglob = 0;
real pr#tcsi, pr#tcs = 0;
real pr#ttotalelapsed = mpiWtime();

NewMacro pr#writesummary
if (preffe#prmesh#isincomm)
{
  real[int] timings = [preffe#prmesh#tdecomp,pr#tfacto,pr#tbuildE,pr#tgmres,pr#tmv,pr#tprec,pr#tcs,pr#teigenv,pr#tdirect];
  real[int] timingsg(timings.n);
  timingsg = 0;
  mpiAllReduce(timings,timingsg,preffe#prmesh#mpicomm,mpiMAX);
  if (mpiRank(preffe#prmesh#mpicomm) == 0) {
    cout << "["+Stringification(pr)+"] timings - decomp and partition : " << timingsg[0] << endl;
    cout << "["+Stringification(pr)+"] timings - assembly and factorization local matrices : " << timingsg[1] << endl;
    cout << "["+Stringification(pr)+"] timings - assembly and factorization coarse problem : " << timingsg[2] << endl;
    cout << "["+Stringification(pr)+"] timings - GMRES : " << timingsg[3] << endl;
    cout << "["+Stringification(pr)+"] timings - MV : " << timingsg[4] << endl;
    cout << "["+Stringification(pr)+"] timings - PREC : " << timingsg[5] << endl;
    cout << "["+Stringification(pr)+"] timings - COARSE SOLVE : " << timingsg[6] << endl;
    /*cout << "timings - scalprod : " << timingsg[7] << endl;*/
    cout << "["+Stringification(pr)+"] timings - total_sum : " << timingsg[3]+timingsg[0]+timingsg[1]+timingsg[2]+timingsg[7]+timingsg[8] << endl;
    cout << "["+Stringification(pr)+"] timings - total elapsed wall time : " << mpiWtime()-pr#ttotalelapsed << endl;
  }
  pr#tgmres = 0; pr#tmv = 0; pr#tprec = 0; pr#tcs = 0; pr#tscalprod = 0;
}
EndMacro

int pr#verbosity = ffddmverbosity;

int pr#bdirect = ffddmbdirect;

pr#Tmatrix<preffe#K> pr#Aglobal;
matrix<preffe#K>[int] pr#aRd(preffe#prmesh#npart);      /* local Dirichlet matrices for parallel matrix vector product */
matrix<preffe#K> pr#matN;

IFMACRO((pr#withhpddm)|(pr#withpetsc))
if (!bpara){
	if (mpiRank(preffe#prmesh#mpicomm) == 0)
		cout << "["+Stringification(pr)+"] Error: HPDDM/PETSc is to be used only in parallel mode" << endl;
	assert(bpara);
}

int[int][int] pr#intersectionhpddm(1 + preffe#prmesh#numberIntersection);
{
  pr#intersectionhpddm[0].resize(preffe#prmesh#arrayIntersection.n);
  pr#intersectionhpddm[0] = preffe#prmesh#arrayIntersection;
  preffe#K[int] CC;
  int[int] II;
  for (int j=0; j<preffe#prmesh#numberIntersection;j++) {
    [II, pr#intersectionhpddm[1 + j], CC] = preffe#restrictionIntersection[j];
    if (CC[CC.n-1] == 0)
      pr#intersectionhpddm[1 + j].resize(CC.n-1);
  }
}
ENDIFMACRO

IFMACRO(pr#withhpddm)
load "hpddm"
pr#aRd[mpiRank(preffe#prmesh#commddm)].resize(preffe#Dk[mpiRank(preffe#prmesh#commddm)].n, preffe#Dk[mpiRank(preffe#prmesh#commddm)].n);
IFMACRO(preffe#K,real)
schwarz<preffe#K> pr#hpddmOP(pr#aRd[mpiRank(preffe#prmesh#commddm)], pr#intersectionhpddm, preffe#Dk[mpiRank(preffe#prmesh#commddm)], scaled = false, communicator = preffe#prmesh#commddm);
ENDIFMACRO
IFMACRO(preffe#K,complex)
real[int] pr#hpddmDk = preffe#Dk[mpiRank(preffe#prmesh#commddm)].re;
schwarz<preffe#K> pr#hpddmOP(pr#aRd[mpiRank(preffe#prmesh#commddm)], pr#intersectionhpddm, pr#hpddmDk, scaled = false, communicator = preffe#prmesh#commddm);
ENDIFMACRO
set(pr#hpddmOP,sparams="-hpddm_"+Stringification(pr)+"_verbosity "+pr#verbosity+" -hpddm_"+Stringification(pr)+"_schwarz_method " +ffddmprecond, prefix=Stringification(pr)+"_");
if (preffe#prmesh#inexactCSsplit == 1)
  set(pr#hpddmOP,sparams="-hpddm_"+Stringification(pr)+"_reuse_preconditioner 1", prefix=Stringification(pr)+"_");
ENDIFMACRO

IFMACRO((pr#withpetsc)|(pr#CSwithpetsc))
IFMACRO(preffe#K,real)
load "PETSc"
ENDIFMACRO
IFMACRO(preffe#K,complex)
load "PETSc-complex"
ENDIFMACRO
ENDIFMACRO

IFMACRO(pr#withpetsc)
pr#aRd[mpiRank(preffe#prmesh#commddm)].resize(preffe#Dk[mpiRank(preffe#prmesh#commddm)].n, preffe#Dk[mpiRank(preffe#prmesh#commddm)].n);
IFMACRO(preffe#K,real)
real[int] pr#petscDk = preffe#Dk[mpiRank(preffe#prmesh#commddm)];
ENDIFMACRO
IFMACRO(preffe#K,complex)
real[int] pr#petscDk = preffe#Dk[mpiRank(preffe#prmesh#commddm)].re;
ENDIFMACRO
Mat<preffe#K> pr#petscOP(pr#aRd[mpiRank(preffe#prmesh#commddm)], pr#intersectionhpddm, pr#petscDk, communicator = preffe#prmesh#commddm);
ENDIFMACRO

IFMACRO(pr#CSwithpetsc)
Mat<preffe#K> pr#petscE(0,communicator = preffe#prmesh#commCS);
ENDIFMACRO

NewMacro pr#localmacrominoverlap() preffe#prmesh#mminoverlap EndMacro

IFMACRO(!pr#prfegeneo)
IFMACRO(pr#localmacrominoverlap,0)
NewMacro pr#prfegeneo() preffe EndMacro
ENDIFMACRO

IFMACRO(pr#localmacrominoverlap,1)
NewMacro pr#prfegeneo() preffe#Aug EndMacro
ENDIFMACRO
ENDIFMACRO

ffddmgenerateOperatorfunctions(pr,preffe)

ffddmsetupPrecondinit(pr)

NewMacro pr#setupoperatorinit()1 EndMacro
ENDIFMACRO
// EOM


macro ffddmsetupOperatorBeminit(pr,preffe)
NewMacro pr#bem()1 EndMacro
ffddmsetupOperatorinit(pr,preffe,preffe)
// EOM

macro ffddmsetupinit(pr,preffe)
ffddmsetupOperatorinit(pr,preffe,preffe)
// EOM

macro ffddmsetupOperatorRect(pr,preffe,preffe2,Varf)

ffddmsetupOperatorinit(pr,preffe,preffe2)

if (preffe#prmesh#isincomm)
{	
	preffe#prmesh#tic(pr#tfactoi)

	IFMACRO(pr#bem,1)
	if (!preffe#prmesh#excluded) {
	  Varf(vaglobal,preffe#prmesh#Thglob,preffe#Vhglob)
	  pr#Aglobal = vaglobal(preffe#Vhglob,preffe#Vhglob,commworld=pr#prfe#prmesh#commddm);
	}
	ENDIFMACRO

	IFMACRO(!pr#bem)
  if (pr#bdirect || bseq) {
    IFMACRO(pr#myOperator)
    pr#myOperator(pr#Aglobal, preffe#prmesh#Thglob, preffe#Vhglob)
    ENDIFMACRO
    IFMACRO(!pr#myOperator)
    Varf(vaglobal,preffe#prmesh#Thglob,preffe#Vhglob)
    pr#Aglobal = vaglobal(preffe#Vhglob,preffe2#Vhglob,sym=vsym*(!pr#isrect),tgv=vtgvelim);
    ENDIFMACRO
  }
  
  preffe#K[int] rhsFull(1), rhs(1);
 
  for(int i = 0;i<preffe#prmesh#npart;++i)
  if ((!preffe#prmesh#excluded) && ((!bpara) || (i == mpiRank(preffe#prmesh#commddm)))) {
  	     
    preffe#prmesh#Thi = preffe#prmesh#aTh[i];

	NewMacro localmacroaug preffe#prmesh#buildAug EndMacro
  	IFMACRO(localmacroaug,1)
  	preffe#prmesh#AugThi = preffe#prmesh#AugaTh[i];
  	ENDIFMACRO
  	IFMACRO(localmacroaug,0)
    preffe#prmesh#meshN preffe#prmesh#AugThi = preffe#prmesh#Thi + preffe#prmesh#aThborder[i]; /* local mesh augmented of one layer to define local Dirichlet matrices without the global matrix*/
    fespace preffe#AugVhi(preffe#prmesh#AugThi, preffe#fPk);
    int[int] n2o = (0:preffe#prmesh#Thi.nt-1);
    int[int] renum = restrict(preffe#Vhi, preffe#AugVhi,n2o);
    int[int] Ic = (0:preffe#Vhi.ndof-1);
    real[int] Kc(preffe#Vhi.ndof);
    Kc = 1;
    matrix preffe#Auginterp = [Ic,renum,Kc];
    preffe#Auginterp.resize(preffe#Vhi.ndof, preffe#AugVhi.ndof);
    ENDIFMACRO

    if (bpara)
    {
      if (preffe#prmesh#overlap > 0) {

        IFMACRO(!pr#myOperator)
        Varf(vPb, preffe#prmesh#AugThi, preffe#AugVhi)
        ENDIFMACRO

        if (!pr#isrect) {
          IFMACRO(pr#myOperator)
          pr#myOperator(pr#aRd[i], preffe#prmesh#AugThi, preffe#AugVhi)
          ENDIFMACRO
          IFMACRO(!pr#myOperator)
          if (preffe#prmesh#inexactCSsplit > 1)
            pr#aRd[i] = vPb(preffe#AugVhi, preffe#AugVhi,sym=vsym,tgv=vtgvelim,solver=GMRES);
          else
            pr#aRd[i] = vPb(preffe#AugVhi, preffe#AugVhi,sym=vsym,tgv=vtgv,solver=GMRES);
          ENDIFMACRO
          renumbering(pr#aRd[i], preffe#Auginterp, eps=-1);
        }
        else {
          ;
          IFMACRO(!pr#myOperator)
          matrix<preffe#K> Auginterp2;
          fespace AugVhi2(preffe2#prmesh#AugThi, preffe2#fPk);
          int[int] n2o = (0:preffe2#prmesh#Thi.nt-1);
          int[int] renum = restrict(preffe2#Vhi, AugVhi2,n2o);
          int[int] Ic = (0:preffe2#Vhi.ndof-1);
          preffe#K[int] Kc(preffe2#Vhi.ndof);
          Kc = 1;
          Auginterp2 = [Ic,renum,Kc];
          Auginterp2.resize(preffe2#Vhi.ndof, AugVhi2.ndof);
          matrix<preffe#K> Auginterp1 = preffe#Auginterp;

          pr#aRd[i] = vPb(preffe#AugVhi, AugVhi2,sym=0,tgv=vtgv,solver=GMRES);

          matrix<preffe#K> tmp = pr#aRd[i]*Auginterp1';
          pr#aRd[i] = Auginterp2*tmp;
          ENDIFMACRO
        }

        IFMACRO(pr#withhpddm)
        ChangeOperator(pr#hpddmOP,pr#aRd[mpiRank(preffe#prmesh#commddm)]);
        ENDIFMACRO
        IFMACRO(pr#withpetsc)
        Mat<preffe#K> mat(pr#aRd[mpiRank(preffe#prmesh#commddm)], pr#intersectionhpddm, pr#petscDk, communicator = preffe#prmesh#commddm);
        pr#petscOP = mat;
        ENDIFMACRO
      }
      else {
        ;
        IFMACRO(!pr#myOperator)
        Varf(vN,preffe#prmesh#Thi,preffe#Vhi)
        pr#matN = vN(preffe#Vhi,preffe2#Vhi,sym=vsym*(!pr#isrect),tgv=vtgv,solver=GMRES);
        ENDIFMACRO
        IFMACRO(pr#myOperator)
        pr#myOperator(pr#matN, preffe#prmesh#Thi, preffe#Vhi)
        ENDIFMACRO
        IFMACRO(pr#withhpddm)
        ChangeOperator(pr#hpddmOP,pr#matN);
        ENDIFMACRO
        IFMACRO(pr#withpetsc)
        Mat<preffe#K> mat(pr#matN, pr#intersectionhpddm, pr#petscDk, communicator = preffe#prmesh#commddm);
        pr#petscOP = mat;
        ENDIFMACRO
      }
    }
    
  }
  if (bseq)
    preffe#prmesh#Thi = preffe#prmesh#Thglob;
  ENDIFMACRO

  preffe#prmesh#toc(pr#tfactoi,"",pr#tfacto)
}
//EOM

macro ffddmsetupOperator(pr,preffe,Varf)
ffddmsetupOperatorRect(pr,preffe,preffe,Varf)
//EOM

macro ffddmsetupOperatorBem(pr,preffe,Varf)
ffddmsetupOperatorBeminit(pr,preffe)
ffddmsetupOperator(pr,preffe,Varf)
//EOM

macro ffddmsetupPrecond(pr,VarfPrec)

pr#prec = ffddmprecond;

if (pr#prfe#prmesh#isincomm)
{	
	pr#prfe#prmesh#tic(pr#tfactoi)
  
  pr#prfe#K[int] rhsFull(1), rhs(1);
 
  for(int i = 0;i<pr#prfe#prmesh#npart;++i)
  if ((!pr#prfe#prmesh#excluded) && ((!bpara) || (i == mpiRank(pr#prfe#prmesh#commddm)))) {
  	     
    if (pr#verbosity > 1 && !bpara) cout << "["+Stringification(pr)+"] Domain :" << i << "/" << pr#prfe#prmesh#npart << endl;

		IFMACRO((!VarfPrec)&(!pr#myPrecond))
		if (bseq) cout << "Error in ffddmsetupPrecond: you need to provide the varf macro for the preconditioner in sequential mode" << endl;
		assert(!bseq);
		pr#aR[i] = pr#aRd[i];
		ENDIFMACRO
		IFMACRO((VarfPrec)|(pr#myPrecond))
		pr#prfe#prmesh#Thi = pr#prfe#prmesh#aTh[i];

		if (pr#prfe#prmesh#Thi.nt > 0) {
		  if (pr#prec == "oras" || pr#prec == "soras"){
		    IFMACRO(!pr#bem)
		    IFMACRO(pr#myPrecond)
		    pr#myPrecond(pr#aR[i], pr#prfe#prmesh#Thi, pr#prfe#Vhi)
		    ENDIFMACRO
		    IFMACRO(!pr#myPrecond)
		    VarfPrec(RobinInt,pr#prfe#prmesh#Thi,pr#prfe#Vhi)
		    if (pr#prfe#prmesh#inexactCSsplit > 1)
		      pr#aR[i] = RobinInt(pr#prfe#Vhi,pr#prfe#Vhi,sym=vsym,tgv=vtgvelim,solver=GMRES);
		    else
		      pr#aR[i] = RobinInt(pr#prfe#Vhi,pr#prfe#Vhi,sym=vsym,tgv=vtgv,solver=GMRES);
		    ENDIFMACRO
		    ENDIFMACRO
		    IFMACRO(pr#bem,1)
		    cout << "TODO" << endl;
		    assert(0);
		    ENDIFMACRO
		  }
		  else if (pr#prec == "ras" || pr#prec == "asm") {
		    NewMacro localmacroaug pr#prfe#prmesh#buildAug EndMacro
		    IFMACRO(localmacroaug,1)
		    pr#prfe#prmesh#AugThi = pr#prfe#prmesh#AugaTh[i];
		    ENDIFMACRO
		    IFMACRO(localmacroaug,0)
		    pr#prfe#prmesh#meshN pr#prfe#prmesh#AugThi = pr#prfe#prmesh#Thi + pr#prfe#prmesh#aThborder[i]; /* local mesh augmented of one layer to define local Dirichlet matrices without the global matrix*/
		    fespace pr#prfe#AugVhi(pr#prfe#prmesh#AugThi, pr#prfe#fPk);
		    int[int] n2o = (0:pr#prfe#prmesh#Thi.nt-1);
		    int[int] renum = restrict(pr#prfe#Vhi, pr#prfe#AugVhi,n2o);
		    int[int] Ic = (0:pr#prfe#Vhi.ndof-1);
		    real[int] Kc(pr#prfe#Vhi.ndof);
		    Kc = 1;
		    matrix pr#prfe#Auginterp = [Ic,renum,Kc];
		    pr#prfe#Auginterp.resize(pr#prfe#Vhi.ndof, pr#prfe#AugVhi.ndof);
		    ENDIFMACRO

		    IFMACRO(!pr#bem)
		    IFMACRO(pr#myPrecond)
		    pr#myPrecond(pr#aR[i], pr#prfe#prmesh#AugThi, pr#prfe#AugVhi)
		    ENDIFMACRO
		    IFMACRO(!pr#myPrecond)
		    VarfPrec(vPb, pr#prfe#prmesh#AugThi, pr#prfe#AugVhi)
		    if (pr#prfe#prmesh#inexactCSsplit > 1)
		      pr#aR[i] = vPb(pr#prfe#AugVhi, pr#prfe#AugVhi,sym=vsym,tgv=vtgvelim,solver=GMRES);
		    else
		      pr#aR[i] = vPb(pr#prfe#AugVhi, pr#prfe#AugVhi,sym=vsym,tgv=vtgv,solver=GMRES);
		    ENDIFMACRO
		    ENDIFMACRO
		    IFMACRO(pr#bem,1)
		    VarfPrec(vPb, pr#prfe#prmesh#AugThi, pr#prfe#AugVhi)
		    pr#Tmatrix<pr#prfe#K> Hloc = vPb(pr#prfe#AugVhi, pr#prfe#AugVhi,commworld=pr#prfe#prmesh#commself);
		    pr#prfe#K[int,int] mdense(pr#prfe#AugVhi.ndof, pr#prfe#AugVhi.ndof);
		    mdense = Hloc;
		    pr#aR[i] = mdense;
		    ENDIFMACRO

		    renumbering(pr#aR[i], pr#prfe#Auginterp, eps=-1);
		  }
		  else if (pr#prec != "none")
		    assert(0);
		}
		ENDIFMACRO
		IFMACRO((!pr#withhpddm)&(!pr#withpetsc))
		set(pr#aR[i],solver = sparsesolver,sym=vsym,commworld=pr#prfe#prmesh#commself,factorize=3);
		ENDIFMACRO
  }
  if (bseq)
    pr#prfe#prmesh#Thi = pr#prfe#prmesh#Thglob;
		
  pr#prfe#prmesh#toc(pr#tfactoi,"",pr#tfacto)
}
//EOM

macro ffddmsetup(pr,preffe,Varf,VarfPrec)
ffddmsetupOperator(pr,preffe,Varf)
ffddmsetupPrecond(pr,VarfPrec)
// EOM

macro ffddmbuildrhs(pr,Varfrhs,rhs)
if (pr#prfe#prmesh#isincomm)
{
	if (pr#bdirect || bseq)
	{
		{
			Varfrhs(vaglobalrhs,pr#prfe#prmesh#Thglob,pr#prfe#Vhglob)
			rhs.resize(pr#prfe#Vhglob.ndof);
			rhs = vaglobalrhs(0,pr#prfe#Vhglob,tgv=vtgvelim);
		}
	}
	
	if (bpara && !pr#prfe#prmesh#excluded)
	{ 
		
		pr#prfe#prmesh#Thi = pr#prfe#prmesh#aTh[mpiRank(pr#prfe#prmesh#commddm)];
		
		rhs.resize(pr#prfe#Vhi.ndof); 
		
		Varfrhs(vPbrhs, pr#prfe#prmesh#Thi, pr#prfe#Vhi)
		rhs = vPbrhs(0,pr#prfe#Vhi,tgv=vtgvelim);
		
		pr#prfe#update(rhs, pr#prfe#prmesh#overlap > 0);
	}
}
// EOM

macro ffddmset(pr,param,value)
pr#param = value;
// EOM

macro ffddmplot(pr,sol,msg)
pr#mplot(sol,msg)
// EOM
macro ffddmcoarsemeshsetupinit(pr,Thc)
IFMACRO(!pr#coarsemeshsetupinit)

pr#bCM = 1;

pr#prfe#prmesh#meshN pr#ThCoarse = pr#prfe#prmesh#minimalMesh;
fespace pr#VhCoarse(pr#ThCoarse,pr#prfe#fPk); /* fespace on the coarse mesh */

if (pr#prfe#prmesh#isincomm) {
  if (!pr#prfe#prmesh#binexactCS) {
    pr#ThCoarse = Thc;
    pr#ncoarsespace = pr#VhCoarse.ndof;
    
    if (!bpara) {
      matrix Zc = interpolate(pr#prfe#Vhglob,pr#VhCoarse); /* ZCM=R0^T */
      Zc.thresholding(1.e-10);
      pr#ZCM = Zc; /* (from real to 'complex' matrix for FreeFem) */    
    }
    else if (!pr#prfe#prmesh#excluded){
      matrix Zci = interpolate(pr#prfe#Vhi,pr#VhCoarse);
      Zci.thresholding(1.e-10);
      pr#ZCMi = Zci;
    }
    NewMacro localmacroaug pr#prfe#prmesh#buildAug EndMacro
    IFMACRO(localmacroaug,1)
    if (bseq) {
      pr#CSinterp = interpolate(pr#VhCoarse,pr#prfe#Vhglob);
    }
    else if (!pr#prfe#prmesh#excluded) {
      pr#CSinterp = interpolate(pr#VhCoarse,pr#prfe#Vhi);
    }
    ENDIFMACRO
  }
  else if (!pr#prfe#prmesh#excluded){
    NewMacro localmacroinexact pr#prfe#prmesh#minexactCS EndMacro
    IFMACRO (localmacroinexact,1)
    matrix Zci = interpolate(pr#prfe#Vhi,pr#prfe#CoarseVhi);
    Zci.thresholding(1.e-10);
    pr#ZCMi = Zci;
    pr#ncoarsespace = pr#prfe#CoarseNdofglobal;
    ENDIFMACRO
    ;
  }
  
  if (!pr#prfe#prmesh#excluded && pr#verbosity && (mpiRank(pr#prfe#prmesh#commddm) == 0))
  cout << "["+Stringification(pr)+"] Coarse space dimension: " << pr#ncoarsespace << endl;
}

NewMacro pr#coarsemeshsetupinit()1 EndMacro
ENDIFMACRO
// EOM

macro ffddmcoarsemeshsetup(pr,Thc,VarfEprec,VarfA)
ffddmcoarsemeshsetupinit(pr,Thc)
if (pr#prfe#prmesh#isincomm)
{
pr#corr = ffddmcorrection;
  
pr#prfe#prmesh#tic(pr#tloc)

if(bseq) {
  IFMACRO(VarfA)
  VarfA(vaglobalEprec,pr#prfe#prmesh#Thglob,pr#prfe#Vhglob)
  pr#AglobEprec = vaglobalEprec(pr#prfe#Vhglob,pr#prfe#Vhglob,sym=vsym,tgv=vtgvelim);
  ENDIFMACRO
  ;
}
else if (!pr#prfe#prmesh#excluded) {
  int i = mpiRank(pr#prfe#prmesh#commddm);
  
  IFMACRO(VarfA)
  pr#prfe#prmesh#Thi = pr#prfe#prmesh#aTh[i];
  
  NewMacro localmacroaug pr#prfe#prmesh#buildAug EndMacro
  IFMACRO(localmacroaug,1)
  pr#prfe#prmesh#AugThi = pr#prfe#prmesh#AugaTh[i];
  ENDIFMACRO
  IFMACRO(localmacroaug,0)
  pr#prfe#prmesh#meshN pr#prfe#prmesh#AugThi = pr#prfe#prmesh#Thi + pr#prfe#prmesh#aThborder[i]; /* local mesh augmented of one layer to define local Dirichlet matrices without the global matrix*/
  fespace pr#prfe#AugVhi(pr#prfe#prmesh#AugThi, pr#prfe#fPk);
  int[int] n2o = (0:pr#prfe#prmesh#Thi.nt-1);
  int[int] renum = restrict(pr#prfe#Vhi, pr#prfe#AugVhi,n2o);
  int[int] Ic = (0:pr#prfe#Vhi.ndof-1);
  real[int] Kc(pr#prfe#Vhi.ndof);
  Kc = 1;
  matrix pr#prfe#Auginterp = [Ic,renum,Kc];
  pr#prfe#Auginterp.resize(pr#prfe#Vhi.ndof, pr#prfe#AugVhi.ndof);
  ENDIFMACRO   

  VarfA(vPb, pr#prfe#prmesh#AugThi, pr#prfe#AugVhi)
  pr#aRdEprec = vPb(pr#prfe#AugVhi, pr#prfe#AugVhi, sym=vsym,tgv=vtgvelim);
  
  pr#prfe#K[int] rhsFull(pr#prfe#AugVhi.ndof);
  pr#prfe#K[int] rhs(pr#prfe#Vhi.ndof);
  
  renumbering(pr#aRdEprec, pr#prfe#Auginterp, rhsFull, rhs, eps=-1);
  ENDIFMACRO
}

if (!pr#prfe#prmesh#binexactCS) {
  {
    IFMACRO(!pr#bem)
    VarfEprec(cvaglobalEprec,pr#ThCoarse,pr#VhCoarse)
    /*if (mpirank < pr#prfe#prmesh#pCS || !bpara)*/
    if (mpirank == 0 || !bpara) {
      pr#ECM = cvaglobalEprec(pr#VhCoarse,pr#VhCoarse,sym=vsym,tgv=vtgv,solver=GMRES);  /* this is A_{eps,0} of Euan paper */
      /*pr#ECM.thresholding(1.e-10);*/
    }
    ENDIFMACRO
    /*
    IFMACRO(pr#bem,1)
    pr#Tmatrix<pr#prfe#K> Hloc = VarfEprec(pr#VhCoarse, pr#VhCoarse);
    pr#prfe#K[int,int] mdense(pr#VhCoarse.ndof, pr#VhCoarse.ndof);
    mdense = Hloc;
    pr#ECM = mdense;
    ENDIFMACRO
    */
  }

  if (bseq || mpirank < pr#prfe#prmesh#pCS) {
    set(pr#ECM,solver=sparsesolver,sym=vsym,commworld=pr#prfe#prmesh#commCS,master=0,factorize=3); /* -1 */
  }
}
	
IFMACRO(pr#withhpddm)
AttachCoarseOperator(pr#prfe#prmesh#commddm, pr#hpddmOP, pr#Q);
ENDIFMACRO

pr#prfe#prmesh#toc(pr#tloc,"building E",pr#tbuildE)
} // EOM
macro ffddmbuildSuper(pr,Th,nsup,scalar,def,init,Pk)

int pr#nsuper = nsup;

int pr#superchunksize = (mpisize-ffddmexclude*nsup)/nsup;

/* supers = (0 2 4) (1 3 5) */

int pr#issuper = mpirank < nsup;
int pr#mysuper = mpirank%nsup;
int pr#mysuperrank = pr#mysuper;

int[int] pr#insuperinterior(pr#superchunksize);
if (pr#superchunksize == 1)
  pr#insuperinterior[0] = mpirank;
else {
    for (int i=0; i<pr#superchunksize;i++)
      pr#insuperinterior[i] = pr#mysuperrank+nsup*i;
}

func int pr#superrankof(int r) {
  return r%nsup;
}

func int pr#rankofsuper(int r) {
  return r;
}

int[int] procsuper(nsup);
for (int i=0;i<nsup;i++)
procsuper[i] = i;


/* supers = (0 1 2) (3 4 5) */

/*
int pr#issuper = (mpirank%pr#superchunksize == 0);
int pr#mysuper = pr#superchunksize*(mpirank/pr#superchunksize);
int pr#mysuperrank = pr#mysuper/pr#superchunksize;

int[int] pr#insuperinterior(pr#superchunksize);
if (pr#superchunksize == 1)
  pr#insuperinterior[0] = mpirank;
else
  pr#insuperinterior = (mpirank:mpirank+pr#superchunksize-1);

func int pr#superrankof(int r) {
  return r/pr#superchunksize;
}

func int pr#rankofsuper(int r) {
  return r*pr#superchunksize;
}

int[int] procsuper(nsup);
for (int i=0;i<nsup;i++)
procsuper[i] = i*pr#superchunksize;
*/

mpiGroup grpsuper(procsuper);
mpiComm pr#commsuper(mpiCommWorld,grpsuper);

fespace pr#Phglob(Th,P0);
pr#Phglob partsuper, part;

int[int] lpart(Th.nt);
if (mpirank == 0)
if (nsup > 1)
  metisdual(lpart,Th,pr#nsuper);
else
  lpart = 0;
if (pr#issuper) {
  broadcast(processor(0, pr#commsuper), lpart);
  for(int i=0;i<lpart.n;++i)
  partsuper[][i]=lpart[i];
}

ffddmnpart = nsup;

IFMACRO(!pr#supersimple)
NewMacro pr#supersimple(Phglob, upart, pr#commsuper)
upart[] = partsuper[];
EndMacro
ENDIFMACRO

int backexclude = ffddmexclude;
ffddmexclude = 0;

ffddmbuildDmesh(pr#super,Th,pr#commsuper)

ffddmexclude = backexclude;

ffddminitDfespacef(pr#super,pr#super,scalar,def,init,Pk,def,init,Pk)

if (pr#issuper){
  pr#super#meshN Thsuper = trunc(Th,partsuper == pr#mysuperrank);
  int[int] mylpart(Thsuper.nt);
  if (pr#superchunksize > 1 )
    metisdual(mylpart,Thsuper,pr#superchunksize);
  else
    mylpart = 0;
  
  fespace Phsuper(Thsuper,P0);
  Phsuper partsuper;

  for(int i=0;i<mylpart.n;++i)
  partsuper[][i]=pr#insuperinterior[mylpart[i]];
  
  matrix Rsuper = interpolate(Phsuper,pr#Phglob);
  pr#Phglob tmp;
  tmp[] = Rsuper'*partsuper[];
  mpiReduce(tmp[], part[], processor(0,pr#commsuper), mpiSUM);
}

broadcast(processor(0,mpiCommWorld),part[]);

IFMACRO(!pr#simple)
NewMacro pr#simple(Phglob, upart, comm)
upart[] = part[];
EndMacro
ENDIFMACRO

int backpCS = ffddmpCS;
ffddmpCS = nsup;
ffddmnpart = mpisize-ffddmexclude*nsup;

ffddmbuild(pr,Th,scalar,def,init,Pk,mpiCommWorld)

ffddmpCS = backpCS;

NewMacro pr#minexactgeneoCS()1 EndMacro
pr#binexactCS = 1;

int[int] pr#listofsupers(pr#arrayIntersection.n+1);
{
  int[int] tmp(pr#arrayIntersection.n+1);
  for (int i=0; i < pr#arrayIntersection.n; i++) {
    tmp[i] = pr#superrankof(pr#arrayIntersection[i]);
  }
  tmp[tmp.n-1] = pr#mysuperrank;
  Unique(tmp,pr#listofsupers);
  pr#listofsupers.sort;
}

int[int] pr#neighborsofsuper(1000);
int[int] pr#insuperwithoverlap(0);

/* equivalent de pr#superrestrictionIntersection, mais juste les ranks, pas les dofs*/
int[int][int] pr#superrestrictionIntersectionranks(pr#nsuper);
for (int i=0;i<pr#nsuper;i++)
pr#superrestrictionIntersectionranks[i].resize(0);

if (pr#issuper) {
  int nc = 0;
  for (int ci=0; ci < pr#insuperinterior.n; ci++) {
    int i = pr#insuperinterior[ci];
    /* faire un gatherv ici */
    /* neighbors est la liste des petits voisins de notre petit sous domaine i (qui appartient a notre super) */
    int[int] neighbors(0);
    if (!pr#excluded && i == mpirank) {
      neighbors.resize(pr#arrayIntersection.n);
      neighbors = pr#arrayIntersection;
    }
    else {
      int nn;
      processor(i+pr#exclude*pr#pCS) >> nn;
      neighbors.resize(nn);
      processor(i+pr#exclude*pr#pCS) >> neighbors;
    }
    for(int j=0;j<neighbors.n;++j)
    if (pr#superrankof(neighbors[j]) != pr#mysuperrank) {
      pr#neighborsofsuper[nc++] = neighbors[j];
      int superr = pr#superrankof(neighbors[j]);
      int currsize = pr#superrestrictionIntersectionranks[superr].n;
      pr#superrestrictionIntersectionranks[superr].resize(currsize+2);
      /* on met notre petit sous domaine i dans la liste de l'overlap avec superr */
      pr#superrestrictionIntersectionranks[superr][currsize] = i;
      /* on met le petit sous domaine voisin de i qui appartient a superr dans la liste de l'overlap avec superr */
      pr#superrestrictionIntersectionranks[superr][currsize+1] = neighbors[j];
    }
  }

  pr#neighborsofsuper.resize(nc);
  int[int] tmp(nc);
  Unique(pr#neighborsofsuper, tmp);
  pr#neighborsofsuper.resize(tmp.n);
  pr#neighborsofsuper = tmp;
  
  pr#insuperwithoverlap.resize(pr#neighborsofsuper.n+pr#insuperinterior.n);
  pr#insuperwithoverlap(0:pr#insuperinterior.n-1) = pr#insuperinterior;
  if (pr#insuperwithoverlap.n >pr#insuperinterior.n)
    pr#insuperwithoverlap(pr#insuperinterior.n:pr#insuperwithoverlap.n-1) = pr#neighborsofsuper;
  
  tmp.resize(pr#neighborsofsuper.n);
  pr#superarrayIntersection.resize(tmp.n);
  for (int i=0; i<pr#neighborsofsuper.n;i++)
  tmp[i] = pr#superrankof(pr#neighborsofsuper[i]);
  Unique(tmp, pr#superarrayIntersection);
  pr#supernumberIntersection = pr#superarrayIntersection.n;
  
}
else {
  /* on n'est pas un super domaine : on envoie notre liste de petits voisins a notre super */
  processor(pr#mysuper) << pr#arrayIntersection.n;
  processor(pr#mysuper) << pr#arrayIntersection;
}
// EOM

macro ffddmsetupsuperinit(pr,preffe)
matrix<preffe#K> pr#RsuperCS;
int[int] pr#superlocalnuminv(0);
NewMacro pr#superalgebraic()1 EndMacro
ffddmsetupinit(pr#super,preffe#super)
// EOM 

macro ffddmsetupsuper(pr)

if (pr#prfe#prmesh#issuper) {
  /*
  broadcast(processor(0,pr#prfe#prmesh#commsuper),pr#E);
  */
  
  pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].resize(pr#ncoarsespace);
  pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)] = 0;
  
  int[int] localnum(pr#ncoarsespace);
  int nloc = 0;
  
  for (int j=0; j<pr#prfe#prmesh#insuperwithoverlap.n; j++){
    int ng = pr#prfe#prmesh#insuperwithoverlap[j];
    for (int k=0; k<pr#sizelg[ng];k++) {
      if (pr#prfe#prmesh#superrankof(ng) == pr#prfe#prmesh#mysuperrank)
      pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)][nloc] = 1;
      localnum[nloc++] = pr#offseti[ng]+k;
    }
  }
  
  pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].resize(nloc);
  pr#prfe#superDih[mpiRank(pr#prfe#prmesh#commsuper)] = pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)];  
  
  localnum.resize(nloc);
  
  int[int] I(nloc);
  pr#superlocalnuminv.resize(pr#ncoarsespace);
  pr#prfe#K[int] K(nloc);
  I = (0:nloc-1);
  K = 1;
  for (int j=0; j<nloc; j++)
  pr#superlocalnuminv[localnum[j]] = j;
  
  if (localnum.max != pr#ncoarsespace-1) {
    I.resize(nloc+1);  
    localnum.resize(nloc+1);
    K.resize(nloc+1);
    I[nloc] = 0;
    localnum[nloc] = pr#ncoarsespace-1;
    K[nloc] = 0;
  }
  
  /* matrice de restriction au super domaine, dans la numerotation de E */
  pr#RsuperCS = [I,localnum,K];
  pr#RsuperCS.thresholding(1e-10);
  
  /*
  pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)] = pr#RsuperCS*pr#E;
  pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)] = pr#superaRd[mpiRank(pr#prfe#prmesh#commsuper)]*pr#RsuperCS';
  */
  
  /*
  La ou dans superrestrictionIntersectionranks il y avait des ranks(petits sous domaines),
  dans superrestrictionIntersection il y a des dofs de E, en numerotation locale de super
  (la correspondance locale-globale est donnee par localnum et superlocalnuminv)
  */
  pr#prfe#superrestrictionIntersection.resize(pr#prfe#prmesh#supernumberIntersection);
  for (int i=0;i < pr#prfe#prmesh#supernumberIntersection;i++) {
    int[int] uniqueranks(1);
    Unique(pr#prfe#superrestrictionIntersectionranks[pr#prfe#prmesh#superarrayIntersection[i]],uniqueranks);
    uniqueranks.sort;
    int[int] restIntersection(0);
    for (int j=0;j<uniqueranks.n;j++) {
      int size = pr#sizelg[uniqueranks[j]];
      int offset = pr#offseti[uniqueranks[j]];
      restIntersection.resize(restIntersection.n+size);
      for (int k=0; k<size;k++)
      restIntersection[restIntersection.n-size+k] = pr#superlocalnuminv[offset+k];
    }
    int nn =restIntersection.n;
    int[int] I(nn),J(nn);
    pr#prfe#K[int] K(nn);
    I = (0:nn-1);
    K=1;
    J = restIntersection;
    if (J.max != pr#RsuperCS.n-1) {
      I.resize(I.n+1);  
      J.resize(J.n+1);
      K.resize(K.n+1);
      I[I.n-1] = 0;
      J[J.n-1] = pr#RsuperCS.n-1;
      K[K.n-1] = 0;
    }
    pr#prfe#superrestrictionIntersection[i] = [I,J,K];
    pr#prfe#superrestrictionIntersection[i].thresholding(1.e-10);
  }
  pr#prfe#superrcv.resize(pr#prfe#prmesh#supernumberIntersection);
  pr#prfe#supersnd.resize(pr#prfe#prmesh#supernumberIntersection);
  for(int j=0;j<pr#prfe#prmesh#supernumberIntersection;++j) {
    pr#prfe#superrcv[j].resize(pr#prfe#superrestrictionIntersection[j].n);
    pr#prfe#supersnd[j].resize(pr#prfe#superrestrictionIntersection[j].n);
  }
  
}
// EOM

macro ffddmgeneosetupsuper(pr)
{    
  /*
  assemblage de la matrice de Neumann:
  pour chaque super domaine avec overlap auquel on appartient (sorted):
  si on appartient au super sans overlap
  - on envoie la restriction de la matrice de Neumann du petit sous domaine a chaque petit voisin
  on recoit la restriction des matrices de Neumann de chacun des voisins qui appartiennent au super sans overlap
  on fait la somme -> S
  on fait Szi = S Zi
  on envoie Szi a nos voisins qui appartiennent au super avec overlap
  on fait Sii = Zi' S Zi
  on fait Sij = Zi' Szj
  on envoie Sij au super
  */
      
  pr#prfe#prmesh#supertic(pr#supertloc)
  pr#prfe#prmesh#tic(pr#tloc)
  
  matrix<pr#prfe#K>[int] restNeumann(pr#prfe#prmesh#arrayIntersection.n);
  matrix<pr#prfe#K>[int] restNeumannSend(pr#prfe#prmesh#arrayIntersection.n);
  
  mpiRequest[int] rqn(pr#prfe#prmesh#arrayIntersection.n*2);
  for (int i=0; i<pr#prfe#prmesh#arrayIntersection.n; i++) {
    /*
    matrix rest = pr#prfe#restrictionIntersection[i]*pr#matN;
    rest = rest*pr#prfe#restrictionIntersection[i]';
    */
    restNeumannSend[i] = pr#matN;
    
    NewMacro localmacroK pr#prfe#K EndMacro
    IFMACRO(localmacroK,real)
    renumbering(restNeumannSend[i],pr#prfe#restrictionIntersection[i],eps=-1);
    ENDIFMACRO

    IFMACRO(localmacroK,complex)
    matrix restreal = pr#prfe#restrictionIntersection[i].re;
    renumbering(restNeumannSend[i],restreal,eps=-1);
    ENDIFMACRO
 
 Isend(processor(pr#prfe#prmesh#arrayIntersection[i],pr#prfe#prmesh#commddm,rqn[i]),restNeumannSend[i]);
  }
  for (int i=0; i<pr#prfe#prmesh#arrayIntersection.n; i++)
    Irecv(processor(pr#prfe#prmesh#arrayIntersection[i],pr#prfe#prmesh#commddm,rqn[pr#prfe#prmesh#arrayIntersection.n+i]),restNeumann[i]);
  for (int i=0; i<pr#prfe#prmesh#arrayIntersection.n*2; i++)
    int k = mpiWaitAny(rqn);
        
  int[int][int] inisuperwithoverlap(pr#prfe#prmesh#listofsupers.n);
  int[int]inisuperwithoverlapsize(pr#prfe#prmesh#listofsupers.n);
  inisuperwithoverlapsize = 0;
  for (int i=0; i<inisuperwithoverlap.n; i++)
    inisuperwithoverlap[i].resize(1000);
  
  mpiRequest[int] rq(2*(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper)+2*pr#prfe#prmesh#issuper*(pr#prfe#prmesh#insuperwithoverlap.n-!pr#prfe#prmesh#excluded));
  int cpt = 0;
  if (pr#prfe#prmesh#issuper) {  
    for (int i=!pr#prfe#prmesh#excluded;i<pr#prfe#prmesh#insuperwithoverlap.n;i++) {
      Isend(processor(pr#prfe#prmesh#insuperwithoverlap[i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rq[cpt++]),pr#prfe#prmesh#insuperwithoverlap.n);
      Isend(processor(pr#prfe#prmesh#insuperwithoverlap[i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rq[cpt++]),pr#prfe#prmesh#insuperwithoverlap);
    }
  }
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper) {
      Irecv(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rq[cpt++]),inisuperwithoverlapsize[is]);
      Irecv(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rq[cpt++]),inisuperwithoverlap[is]);
    }
  }
  for (int i=0;i < cpt;i++)
    int k = mpiWaitAny(rq);

  for (int is=0;is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (pr#prfe#prmesh#issuper && pr#prfe#prmesh#mysuperrank == isuper) {
      inisuperwithoverlap[is].resize(pr#prfe#prmesh#insuperwithoverlap.n);
      inisuperwithoverlap[is] = pr#prfe#prmesh#insuperwithoverlap;
    }
    else
      inisuperwithoverlap[is].resize(inisuperwithoverlapsize[is]);
  }
  
  int[int][int] indicesofneighbors(pr#prfe#prmesh#listofsupers.n);
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    indicesofneighbors[is].resize(pr#prfe#prmesh#arrayIntersection.n);
    cpt = 0;
    for (int i=0; i<pr#prfe#prmesh#arrayIntersection.n; i++)
    for (int j=0; j<inisuperwithoverlap[is].n;j++)
    if (pr#prfe#prmesh#arrayIntersection[i] == inisuperwithoverlap[is][j])
      indicesofneighbors[is][cpt++] = i;
    indicesofneighbors[is].resize(cpt);
  }
  
  int[int][int] neighbors(pr#prfe#prmesh#listofsupers.n);
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    neighbors[is].resize(indicesofneighbors[is].n);
    for (int i=0;i<indicesofneighbors[is].n;i++)
      neighbors[is][i] = pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][i]];
  }
  
  int[int] tabnumberIntersection(pr#prfe#prmesh#insuperwithoverlap.n); /* i: number of neighbours of processor i */
  int[int][int] tabarrayIntersection(pr#prfe#prmesh#insuperwithoverlap.n);
  if (pr#prfe#prmesh#issuper)
  for (int i=!pr#prfe#prmesh#excluded; i<pr#prfe#prmesh#insuperwithoverlap.n; i++)
    tabarrayIntersection[i].resize(1000);
  
  mpiRequest[int] rqt(2*(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper)+2*pr#prfe#prmesh#issuper*(pr#prfe#prmesh#insuperwithoverlap.n-!pr#prfe#prmesh#excluded));
  
  cpt = 0;
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper) {
      Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqt[cpt++]),neighbors[is].n);
      Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqt[cpt++]),neighbors[is]);
    }
    else {
      for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++) {
        Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqt[cpt++]),tabnumberIntersection[i]);
        Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqt[cpt++]),tabarrayIntersection[i]);
      }
    }
  }
  
  for (int i=0;i < cpt;i++)
    int k = mpiWaitAny(rqt); 
  
  if (pr#prfe#prmesh#issuper)
  for (int i=!pr#prfe#prmesh#excluded; i<pr#prfe#prmesh#insuperwithoverlap.n; i++)
    tabarrayIntersection[i].resize(tabnumberIntersection[i]);
  
  int cptmpi = 0;
  
  int nbrqmpi = 0;
  int nbrqmpiexcl = 0;
  
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    nbrqmpi += indicesofneighbors[is].n;
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != pr#prfe#prmesh#listofsupers[is])
      nbrqmpiexcl += indicesofneighbors[is].n;
  }
    
  pr#prfe#K[int,int][int] mrcv(nbrqmpi);
  pr#prfe#K[int,int][int] msnd(nbrqmpi);
  
  mpiRequest[int] rqszi(2*nbrqmpi);
  
  pr#prfe#K[int,int][int] Sii(pr#prfe#prmesh#listofsupers.n);
  for (int i=0; i<pr#prfe#prmesh#listofsupers.n; i++)
    Sii[i].resize(pr#si,pr#si);
  
  if (!pr#prfe#prmesh#excluded) {
    for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++)
    {
      int isuper = pr#prfe#prmesh#listofsupers[is];
      
      int[int] indicesofinteriorneighbors(pr#prfe#prmesh#arrayIntersection.n);
      int cpt = 0;
      for (int i=0; i<pr#prfe#prmesh#arrayIntersection.n; i++)
      if (pr#prfe#prmesh#superrankof(pr#prfe#prmesh#arrayIntersection[i]) == isuper) {
        indicesofinteriorneighbors[cpt++] = i;
      }
      indicesofinteriorneighbors.resize(cpt);
      
      matrix<pr#prfe#K> SumNeumann;
      if (pr#prfe#prmesh#mysuperrank == isuper)
        SumNeumann = pr#matN;
      for(int cj=0;cj<indicesofinteriorneighbors.n;++cj) {
        int j = indicesofinteriorneighbors[cj];
        matrix<pr#prfe#K> extens = pr#prfe#restrictionIntersection[j]'*restNeumann[j];
        extens = extens*pr#prfe#restrictionIntersection[j];
        SumNeumann = SumNeumann+extens;
      }
      
      pr#prfe#K[int,int] Szi(pr#matN.n,pr#si);
      for (int ii=0; ii < pr#si; ii++) {
        pr#prfe#K[int] tmp(SumNeumann.n);
        tmp = SumNeumann*pr#Z[ii];
        Szi(:,ii) = tmp;
      }
      
      for (int ii=0; ii < pr#si; ii++)
      for (int jj=0; jj < pr#si; jj++) {
        Sii[is](ii,jj) = pr#Z[ii]'*Szi(:,jj);
      }

      for(int j=0;j<indicesofneighbors[is].n;++j) {
        msnd[cptmpi].resize(pr#prfe#restrictionIntersection[indicesofneighbors[is][j]].n,pr#si);
        mrcv[cptmpi].resize(pr#prfe#restrictionIntersection[indicesofneighbors[is][j]].n, pr#sizelg[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]);
        for (int ii=0; ii<pr#si; ii++) {
          pr#prfe#K[int] tmp(pr#prfe#restrictionIntersection[indicesofneighbors[is][j]].n);
          tmp = pr#prfe#restrictionIntersection[indicesofneighbors[is][j]]*Szi(:,ii);
          msnd[cptmpi](:,ii) = tmp;
        }
        Isend(processor(pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]],pr#prfe#prmesh#commddm,rqszi[2*cptmpi]),msnd[cptmpi]);
        Irecv(processor(pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]],pr#prfe#prmesh#commddm,rqszi[2*cptmpi+1]),mrcv[cptmpi]);
        cptmpi++;
      }
    }
    
    for (int i=0; i<2*cptmpi; i++)
    int k = mpiWaitAny(rqszi);
  }
    
  mpiRequest[int] rqsii(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper);
  cpt = 0;
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper)
    Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqsii[cpt++]),Sii[is]);
  }
  
  for (int i=0;i < cpt;i++)
  int k = mpiWaitAny(rqsii);  
  
  pr#prfe#K[int,int][int] Sij(nbrqmpi);
  
  mpiRequest[int] rqsij(nbrqmpiexcl);
  cptmpi = 0;
  int cptmpiexcl = 0;
  int myindexinsij = -1;
  for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++) {
    int isuper = pr#prfe#prmesh#listofsupers[is];
    if (pr#prfe#prmesh#issuper && pr#prfe#prmesh#mysuperrank == isuper)
      myindexinsij = cptmpi;
    for(int j=0;j<indicesofneighbors[is].n;++j) {
      Sij[cptmpi].resize(pr#si,pr#sizelg[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]);
      for (int jj=0; jj < pr#sizelg[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]; jj++) {
        pr#prfe#K[int] tmp(pr#prfe#restrictionIntersection[indicesofneighbors[is][j]].m);
        tmp = pr#prfe#restrictionIntersection[indicesofneighbors[is][j]]'*mrcv[cptmpi](:,jj);
        for (int ii=0; ii < pr#si; ii++){
          Sij[cptmpi](ii,jj) = pr#Z[ii]'*tmp;
        }
      }
      if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != isuper) {
        Isend(processor(pr#prfe#prmesh#rankofsuper(isuper),pr#prfe#prmesh#mpicomm,rqsij[cptmpiexcl]),Sij[cptmpi]);  
        cptmpiexcl++;
      }
      cptmpi++;
    }
  }
  
  for (int i=0; i<nbrqmpiexcl; i++)
    int k = mpiWaitAny(rqsij);
  
  if (pr#prfe#prmesh#issuper) {
    int is = -1;
    for (int i=0; i< pr#prfe#prmesh#listofsupers.n; i++)
    if (pr#prfe#prmesh#listofsupers[i] == pr#prfe#prmesh#mysuperrank)
      is = i;
    
    int isuper = pr#prfe#prmesh#mysuperrank;
    
    int nbij = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
    nbij += tabnumberIntersection[i];
    
    pr#prfe#K[int,int][int] tabSij(nbij); /* big vector of full matrices for the blocks Sij */
    pr#prfe#K[int,int][int] tabSii(inisuperwithoverlap[is].n); /* big vector of full matrices for the blocks Sii */
    
    /* on proc 0 resize tabSii and receive Sii blocks */
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
      tabSii[i].resize(pr#sizelg[inisuperwithoverlap[is][i]],pr#sizelg[inisuperwithoverlap[is][i]]);
    mpiRequest[int] rqtii(inisuperwithoverlap[is].n-!pr#prfe#prmesh#excluded);
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
      Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqtii[i-!pr#prfe#prmesh#excluded]),tabSii[i]);
    for (int i = 0; i < inisuperwithoverlap[is].n-!pr#prfe#prmesh#excluded; i++)
      int k = mpiWaitAny(rqtii);
    
    /* on proc 0 resize tabSij and receive Sij blocks */
    int cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
    for (int j=0; j < tabnumberIntersection[i]; j++) {
      tabSij[cpt].resize(pr#sizelg[inisuperwithoverlap[is][i]],pr#sizelg[tabarrayIntersection[i][j]]);
      cpt++;   
    }
    mpiRequest[int] rqtij(nbij);
    cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++)
    for (int j=0; j < tabnumberIntersection[i]; j++) {
      Irecv(processor(inisuperwithoverlap[is][i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rqtij[cpt]),tabSij[cpt]);
      cpt++;
    }
    for (int i=0; i < nbij; i++)
      int k = mpiWaitAny(rqtij);
    
    /* fill S0 with Sii and Sij */
    pr#prfe#K[int,int] S0(pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].n,pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].n);
    S0 = 0;
    
    if (!pr#prfe#prmesh#excluded) {
      /* block S00 */
      for (int jj=0; jj< pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]; jj++)
        S0(pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]:pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]-1,
        pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+jj) = Sii[is](:,jj);
      /* blocks S0j */          
      for(int j=0;j<indicesofneighbors[is].n;++j)
      for (int jj=0; jj< pr#sizelg[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]; jj++)
        S0(pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]:pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]-1,
        pr#superlocalnuminv[pr#offseti[pr#prfe#prmesh#arrayIntersection[indicesofneighbors[is][j]]]]+jj) = Sij[myindexinsij+j](:,jj);    
    }
    
    cpt = 0;
    for (int i = !pr#prfe#prmesh#excluded; i < inisuperwithoverlap[is].n; i++) {
      /* blocks Sii */
      for (int jj=0; jj< pr#sizelg[inisuperwithoverlap[is][i]]; jj++)
        S0(pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]:pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]+pr#sizelg[inisuperwithoverlap[is][i]]-1,
        pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]+jj) = tabSii[i](:,jj);
      /* blocks Sij */
      for(int j=0;j<tabnumberIntersection[i];++j) {
        for (int jj=0; jj< pr#sizelg[tabarrayIntersection[i][j]]; jj++) {
          S0(pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]:pr#superlocalnuminv[pr#offseti[inisuperwithoverlap[is][i]]]+pr#sizelg[inisuperwithoverlap[is][i]]-1,
          pr#superlocalnuminv[pr#offseti[tabarrayIntersection[i][j]]]+jj) = tabSij[cpt](:,jj);
        }
        cpt++;
      }	
    }
    
    pr#supermatN = S0;
    /*
    matrix S0s = S0;
    pr#supermatN = pr#RsuperCS*S0s;
    pr#supermatN = pr#supermatN*pr#RsuperCS';
    */
  }
  
  pr#prfe#prmesh#supertoc(pr#supertloc,"assembling super Neumann matrices",pr#supertbuildE)
  
  ffddmgeneosetup(pr#super,null)
  
  pr#prfe#prmesh#toc(pr#tloc,"",pr#tbuildE)
}
// EOM
 // for gestion of FreeFem++ argument and in version 3.10-1 FH
 // F. Hecht 
 // Usage:  getARGV(n,defaultvalue) // get the fist used default valeu
 //  or     getARGV(after,defaultvalue) // get the arg after after 
 // the type of delfaut value given the return type: int,double, string
 // Modif version 3.54-2  Jan 2018 (add ones include)
 IFMACRO(!getARGVidp)
 macro getARGVidp 1 //
 
 
 func int usedARGV(int n)
{
  int k=1,ii=1,kk=1,ret=-1;
  for(int i=1;i<ARGV.n;++i)
   {
   // cout <<i<< " "<< ARGV[i] << " " <<(ARGV[i]=="-v") << " " << kk << "==" 
   //      << n << " " << ARGV[i].rfind("dp") << " " <<ARGV[i].length-2  << endl;
        
       if(ARGV[i]=="-v") i++;
       else if(ARGV[i]=="-fglut") i++;
       else if(ARGV[i]=="-ffg") i++;
       else if(ARGV[i]=="-glut") i++;
       else if(ARGV[i]=="-f") i++;
       else if(ARGV[i]=="-nw") ii;
       else if(ARGV[i]=="-wait") ii;
       else if(ARGV[i]=="-ne") ii;
       else if(ARGV[i]=="-cd") ii;
       //else if(ARGV[i].rfind(".edp")==ARGV[i].length-4 ) ii;
       else if(i==1) ii;
       else if(kk++==n) {ret=i;}
      // else cout << " +++ \n";
     }
   //  cout << ret << endl;
    return ret;
}

func int usedARGV(string after)
{
  int ret=-1;
  for(int i=ARGV.n-1;i>=0;--i)        
       if(ARGV[i]==after) { ret=++i; break;}
  if(ARGV.n<ret) ret=-1;
  return ret;
}

func int getARGV(int n,int default)
{
   int d=default;
   int k=usedARGV(n);
   if(k>0) d=strtol(ARGV[k]);
    return d;
}
func real getARGV(int n,real default)
{
   real d=default;
   int k=usedARGV(n);
   if(k>0) d=strtod(ARGV[k]);
   return d;
}
func string getARGV(int n,string default)
{
   string d=default;
   int k=usedARGV(n);
   if(k>0) d=ARGV[k];
    return d;
}

func int getARGV(string after,int default)
{
   int d=default;
   int k=usedARGV(after);
   if(k>0) d=strtol(ARGV[k]);
    return d;
}
func real getARGV(string after,real default)
{
   real d=default;
   int k=usedARGV(after);
   if(k>0) d=strtod(ARGV[k]);
   return d;
}
func string getARGV(string after,string default)
{
   string d=default;
   int k=usedARGV(after);
   if(k>0) d=ARGV[k];
    return d;
}

/*
cout << getARGV(1,100) << endl;
cout << getARGV(2,200.) << endl;
cout << getARGV(3,"300.000") << endl;
cout << getARGV("-n"," xxx") << endl;
*/
ENDIFMACRO
//  example to build a mesh a cone 
func mesh3 BuildBall(real RR,real h,int lab)
{
border Taxe(t=-RR,RR){x=t;y=0;label=0;}
border CC(t=0,pi){x=RR*cos(t);y=RR*sin(t);label=lab;}
mesh Th2=buildmesh(  Taxe(2*RR/h)+ CC(pi*RR/h) ) ;

int MaxLayersT=(int(2*pi*RR/h)/4)*4;
func zminT = 0;
func zmaxT = 2*pi;
func fx= y*cos(z);// / max( abs(cos(z) ), abs(sin(z)));
func fy= y*sin(z);// / max( abs(cos(z) ), abs(sin(z)));
func fz= x;
mesh3 Th=buildlayers(Th2,coef= min(max(.01,y/RR*1.3),1.) , MaxLayersT,zbound=[zminT,zmaxT],transfo=[fx,fy,fz],facemerge=1);
return Th;
}
func mesh3 BuildAxiOx(mesh &Th2,real h)
{
real[int] bb(4);
boundingbox(Th2,bb);
if(verbosity>4) cout << bb << endl;
real RR = bb[3]; 
// cone using buildlayers with a triangle 
int MaxLayersT=(int(2*pi*RR/h)/4)*4;
func zminT = 0;
func zmaxT = 2*pi;
func fx= y*cos(z);// / max( abs(cos(z) ), abs(sin(z)));
func fy= y*sin(z);// / max( abs(cos(z) ), abs(sin(z)));
func fz= x;
mesh3 Th=buildlayers(Th2,coef= min(max(.01,y/RR*1.3),1.) , MaxLayersT,zbound=[zminT,zmaxT],transfo=[fx,fy,fz],facemerge=1);
return Th;
}
macro ffddmgenerateOperatorfunctions(pr,preffe)
IFMACRO (pr#myA)
pr#myA
ENDIFMACRO
IFMACRO (!pr#myA)
func preffe#K[int] pr#A(preffe#K[int] &u)
{
  /* Matrix vector product with the global matrix */
  preffe#K[int] res(pr#isrect ? pr#prfe2#Vhi.ndof : u.n);
  if (preffe#prmesh#isincomm) {
    preffe#prmesh#tic(pr#tmvi)
    if (!bpara)
    res = pr#Aglobal*u;
    else if (!preffe#prmesh#excluded){
      IFMACRO(pr#bem,1)
      int mrhs = u.n / pr#prfe#Vhi.ndof; /* multi rhs */
      preffe#K[int] ug(preffe#Vhglob.ndof*mrhs), scaledug(preffe#Vhglob.ndof*mrhs);
      ug = 0; scaledug = 0;
      for (int i=0; i<mrhs; i++) {
        preffe#K[int] scaledu = preffe#Dih[mpiRank(preffe#prmesh#commddm)]*u(i*pr#prfe#Vhi.ndof:(i+1)*pr#prfe#Vhi.ndof-1);
        scaledug(i*preffe#Vhglob.ndof:(i+1)*preffe#Vhglob.ndof-1) = preffe#Rih[mpiRank(preffe#prmesh#commddm)]'*scaledu;
      }
      mpiAllReduce(scaledug,ug,preffe#prmesh#commddm,mpiSUM);
      preffe#K[int] resg = pr#Aglobal*ug;
      for (int i=0; i<mrhs; i++) {
        res(i*pr#prfe#Vhi.ndof:(i+1)*pr#prfe#Vhi.ndof-1) = preffe#Rih[mpiRank(preffe#prmesh#commddm)]*resg(i*preffe#Vhglob.ndof:(i+1)*preffe#Vhglob.ndof-1);
      }
      ENDIFMACRO

      IFMACRO(!pr#bem)
      if (preffe#prmesh#overlap > 0) {
        res = pr#aRd[mpiRank(preffe#prmesh#commddm)]*u;
        pr#prfe2#update(res,true);
      }
      else {
        res = pr#matN*u;
        pr#prfe2#update(res,false);
      }
      ENDIFMACRO
    }
    preffe#prmesh#toc(pr#tmvi,"",pr#tmv)
  }
  return res;
}

func preffe#K[int] pr#AT(preffe#K[int] &u)
{
  /* Matrix vector product with the transpose of the global matrix */
  preffe#K[int] res(pr#isrect ? pr#prfe#Vhi.ndof : u.n);
  IFMACRO(!pr#bem)
  if (preffe#prmesh#isincomm) {
    preffe#prmesh#tic(pr#tmvi)
    if (!bpara)
    res = pr#Aglobal'*u;
    else if (!preffe#prmesh#excluded){
      if (preffe#prmesh#overlap > 0) {
        res = pr#aRd[mpiRank(preffe#prmesh#commddm)]'*u;
        pr#prfe#update(res,true);
      }
      else {
        res = pr#matN'*u;
        pr#prfe#update(res,false);
      }
    }
    preffe#prmesh#toc(pr#tmvi,"",pr#tmv)
  }
  ENDIFMACRO
  IFMACRO(pr#bem,1)
  if (mpirank == 0) cout << "TODO" << endl;
  assert(0);
  ENDIFMACRO
  return res;
}
ENDIFMACRO

func preffe#K[int] pr#directsolve(preffe#K[int]& rhs)
{
  preffe#K[int] res(rhs.n);

  IFMACRO(pr#bem,1)
  if (mpirank == 0)
    cout << "No way to use a direct solver for BEM for now !" << endl;
  assert(0);
  ENDIFMACRO

  IFMACRO(!pr#bem)
  preffe#prmesh#tic(pr#tloc)

  if (preffe#prmesh#isincomm) {
    if (!bpara) {
      set(pr#Aglobal,solver = sparsesolver,commworld=preffe#prmesh#commself);
      res = pr#Aglobal^-1*rhs;
    }
    else if (!preffe#prmesh#excluded) {
      matrix<preffe#K> matloc;
      if (preffe#prmesh#overlap > 0) {
        matloc = preffe#Dih[mpiRank(preffe#prmesh#commddm)]*pr#aRd[mpiRank(preffe#prmesh#commddm)];
        matloc = preffe#Rih[mpiRank(preffe#prmesh#commddm)]'*matloc;
      }
      else
        matloc = preffe#Rih[mpiRank(preffe#prmesh#commddm)]'*pr#matN;
      matloc = matloc*preffe#Rih[mpiRank(preffe#prmesh#commddm)];
      set(matloc,solver = sparsesolver,commworld=preffe#prmesh#commddm,master=-1);
      preffe#K[int] scaledrhs = preffe#Dih[mpiRank(preffe#prmesh#commddm)]*rhs;
      preffe#K[int] scaledrhsg(preffe#Vhglob.ndof);
      scaledrhsg = preffe#Rih[mpiRank(preffe#prmesh#commddm)]'*scaledrhs;
      preffe#K[int] resg = matloc^-1*scaledrhsg;
      res = preffe#Rih[mpiRank(preffe#prmesh#commddm)]*resg;
    }
  }
  
  preffe#prmesh#toc(pr#tloc,"direct solver",pr#tdirect)
  ENDIFMACRO
  
  return res;
}
// EOM

macro ffddmgeneratePrecondfunctions(pr,preffe)  

  func preffe#K[int] pr#AEprec(preffe#K[int] &x)
  {
    preffe#K[int] res(x.n);
    if (preffe#prmesh#isincomm) {
      IFMACRO(!pr#bem)
      if (!bpara) {
        if (pr#AglobEprec.n > 0)
          res = pr#AglobEprec*x;
        else
          res = pr#Aglobal*x;
      }
      else if (!preffe#prmesh#excluded){
        if (pr#aRdEprec.n > 0)
          res = pr#aRdEprec*x;
        else
          res = pr#aRd[mpiRank(preffe#prmesh#commddm)]*x;
        pr#prfe#update(res,true);
      }
      ENDIFMACRO
      IFMACRO(pr#bem,1)
      res = pr#A(x);
      ENDIFMACRO
    }
    return res;
  }   

  func preffe#K[int] pr#Q(preffe#K[int] &l, int mrhs)      /* Q = Z*E^-1*Z^T */
  {
    preffe#K[int] res(l.n);
    res=0.;
    if (preffe#prmesh#isincomm) {
      if(pr#bCM){
        preffe#K[int] vaux(1), tmp(1), zaux(1);
        
        /* Z^T l */
        if (!bpara) {
          vaux.resize(pr#ncoarsespace); tmp.resize(pr#ncoarsespace); zaux.resize(pr#ncoarsespace);
          vaux = pr#ZCM'*l;
        }
        else if (!preffe#prmesh#binexactCS){
          vaux.resize(pr#ncoarsespace); tmp.resize(pr#ncoarsespace); zaux.resize(pr#ncoarsespace);
          if (!preffe#prmesh#excluded) {
            preffe#K[int] ls = l .* preffe#Dk[mpiRank(preffe#prmesh#commddm)]; /* Z = sum_i D_i Z_i */
            tmp = pr#ZCMi'*ls;
          }
          else
          tmp = 0;
          vaux = 0;
          mpiReduce(tmp,vaux,processor(0,preffe#prmesh#mpicomm),mpiSUM);
        }
        else {
          NewMacro localmacroinexact preffe#prmesh#minexactCS EndMacro
          IFMACRO (localmacroinexact,1)
          vaux.resize(mrhs*preffe#CoarseVhi.ndof); tmp.resize(mrhs*preffe#CoarseVhi.ndof); zaux.resize(mrhs*preffe#CoarseVhi.ndof);
          if (!preffe#prmesh#excluded) {
            for (int m=0; m<mrhs; m++)
              tmp(m*preffe#CoarseVhi.ndof:(m+1)*preffe#CoarseVhi.ndof-1) = pr#ZCMi'*l(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1);
          }
          /*exchange(pr#Addmc,tmp,scaled=true);*/
          for (int m=0; m<mrhs; m++)
            pr#prfe#Coarseupdate(tmp(m*preffe#CoarseVhi.ndof:(m+1)*preffe#CoarseVhi.ndof-1),true);
          ENDIFMACRO
          ;
        }
        
        if (!preffe#prmesh#binexactCS) {
          if (!bpara || mpiRank(preffe#prmesh#mpicomm) < preffe#prmesh#pCS) {
            preffe#prmesh#tic(pr#tcsi)
            if (mpiRank(preffe#prmesh#mpicomm) == 0)
            zaux = pr#ECM^-1*vaux;
            else {
              preffe#K[int] dumx(pr#ECM.n), dumb(pr#ECM.n);
              dumx = pr#ECM^-1*dumb;	
            }
            preffe#prmesh#toccomm(pr#tcsi,"",pr#tcs,preffe#prmesh#commCS)
          }
          
          if (bpara)   
          broadcast(processor(0,preffe#prmesh#mpicomm),zaux);    
          
          if (!bpara) {
            res = pr#ZCM*zaux;
          }
          else if (!preffe#prmesh#excluded) {
            res = pr#ZCMi*zaux;
          }
        }
        else {
          NewMacro localmacroinexact preffe#prmesh#minexactCS EndMacro
          IFMACRO (localmacroinexact,1)
          preffe#K[int] solc(mrhs*preffe#CoarseVhi.ndof);
          solc = 0;
          preffe#prmesh#tic(pr#tcsi)
          /*
          DestroyRecycling(Addmc);
          DDM(Addmc, tmp, solc, O=Optc);
          solc = 0;
          */
          
          /*DDM(pr#Addmc, tmp, solc, O=pr#Optc);*/
          solc = pr#CoarsefGMRES(solc, tmp, ffddminexactCStol, ffddmmaxit, ffddmvariant);
          preffe#prmesh#toc(pr#tcsi,"",pr#tcs)
          if (!preffe#prmesh#excluded)
          for (int m=0; m<mrhs; m++)
            res(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1) = pr#ZCMi*solc(m*preffe#CoarseVhi.ndof:(m+1)*preffe#CoarseVhi.ndof-1);
          ENDIFMACRO
          ;	  
        }	
      }
      else{
        
        preffe#K[int] vaux(pr#ncoarsespace), zaux(pr#ncoarsespace);
        
        /* Z^T l */
        if (!bpara) {
          int cpt = 0;
          for (int jj=0; jj<preffe#prmesh#npart; jj++) {
            preffe#K[int] tmp(preffe#Rih[jj].n);
            tmp = preffe#Rih[jj]*l;
            for (int ii=0; ii < pr#sizelg[jj]; ii++) {
              vaux[cpt]=pr#Z[cpt]'*tmp;
              cpt++;
            }
          }
          zaux=pr#E^-1*vaux;
          cpt = 0;
          /* the 2 fors loop over the columns of Z subdomainwise */
          for (int jj=0; jj<preffe#prmesh#npart; jj++)
          for (int ii=0; ii < pr#sizelg[jj]; ii++) {
            preffe#K[int] tmp(preffe#Rih[jj].m);
            tmp = preffe#Rih[jj]'*pr#Z[cpt];
            res += zaux[cpt]*tmp;
            cpt++; /* keeps track of the global numbering of the columns of Z */
            /* we multiply 'column by element' */
          }
        }
        else {
          preffe#K[int] tmp(pr#si);
          for (int i=0;i<pr#si;i++)
          tmp[i]=pr#Z[i]'*l; /* local vector Z'_i l_i */
          if(!preffe#prmesh#binexactCS) {
            IFMACRO(pr#CSwithpetsc)
            if (mpiRank(preffe#prmesh#mpicomm) < preffe#prmesh#pCS)
              preffe#prmesh#tic(pr#tcsi)
              tmp = pr#petscE^-1*tmp;
              preffe#prmesh#toccomm(pr#tcsi,"",pr#tcs,preffe#prmesh#commCS)
            ENDIFMACRO
            IFMACRO(!pr#CSwithpetsc)
            mpiGatherv(tmp,vaux,processor(0,preffe#prmesh#mpicomm),pr#sizelgworld,pr#offsetiworld);
            /* mpiGatherv puts together inside vaux the local vectors (whose sizes are in sizelg) */
            if (mpiRank(preffe#prmesh#mpicomm) < preffe#prmesh#pCS) {
              preffe#prmesh#tic(pr#tcsi)
              if (mpiRank(preffe#prmesh#mpicomm) == 0)
              zaux = pr#E^-1*vaux;
              else {
                preffe#K[int] dumx(pr#E.n), dumb(pr#E.n);
                dumx = pr#E^-1*dumb;
              }
              preffe#prmesh#toccomm(pr#tcsi,"",pr#tcs,preffe#prmesh#commCS)
            }
            mpiScatterv(zaux,tmp,processor(0,preffe#prmesh#mpicomm),pr#sizelgworld,pr#offsetiworld);
            ENDIFMACRO
            /* inverse of mpiGatherv, cut the global zaux into the local tmp[i] */
            for (int i=0;i<pr#si;i++) {
              res += tmp[i]*pr#Z[i];
            }
            /* sum_j R_i Z_j zaux_j */
          }
          else {
            NewMacro localmacroinexact preffe#prmesh#minexactgeneoCS EndMacro
            IFMACRO (localmacroinexact,1)
            
            mpiRequest[int] rq(pr#prfe#prmesh#listofsupers.n-pr#prfe#prmesh#issuper+pr#prfe#prmesh#issuper*(pr#prfe#prmesh#insuperwithoverlap.n-!pr#prfe#prmesh#excluded));
            int cpt = 0;
            pr#prfe#K[int][int] tres(pr#prfe#prmesh#insuperwithoverlap.n);
            for (int is=0; is < pr#prfe#prmesh#listofsupers.n; is++)
            if (!pr#prfe#prmesh#issuper || pr#prfe#prmesh#mysuperrank != pr#prfe#prmesh#listofsupers[is])
              Isend(processor(pr#prfe#prmesh#rankofsuper(pr#prfe#prmesh#listofsupers[is]),pr#prfe#prmesh#mpicomm,rq[cpt++]),tmp);
            if (pr#prfe#prmesh#issuper) {
              vaux.resize(pr#prfe#superDk[mpiRank(pr#prfe#prmesh#commsuper)].n);
              if (!pr#prfe#prmesh#excluded)
                vaux(pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]:pr#superlocalnuminv[pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]]+pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]-1) = tmp;
              for (int i=!pr#prfe#prmesh#excluded; i < pr#prfe#prmesh#insuperwithoverlap.n; i++) {
                tres[i].resize(pr#sizelg[pr#prfe#prmesh#insuperwithoverlap[i]]);              
                Irecv(processor(pr#prfe#prmesh#insuperwithoverlap[i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rq[cpt++]),tres[i]);
              }
            }
            for (int i=0;i < cpt;i++)
              int k = mpiWaitAny(rq);
            
            if (pr#prfe#prmesh#issuper)
            for (int i=!pr#prfe#prmesh#excluded; i < pr#prfe#prmesh#insuperwithoverlap.n; i++)
              vaux(pr#superlocalnuminv[pr#offseti[pr#prfe#prmesh#insuperwithoverlap[i]]]:pr#superlocalnuminv[pr#offseti[pr#prfe#prmesh#insuperwithoverlap[i]]]+pr#sizelg[pr#prfe#prmesh#insuperwithoverlap[i]]-1) = tres[i];         
            
            if (preffe#prmesh#issuper) {
              preffe#prmesh#tic(pr#tcsi)
              
              if (preffe#prmesh#binexactgeneoCS) {
                preffe#K[int] solc(vaux.n);
                solc = 0;
                solc = pr#superfGMRES(solc, vaux, ffddminexactCStol, ffddmmaxit, ffddmvariant);
                solc = solc .* preffe#superDk[mpiRank(preffe#prmesh#commsuper)];
                vaux.resize(pr#ncoarsespace);
                vaux = pr#RsuperCS'*solc;
              }
              else {
                preffe#K[int] tmp = vaux .* preffe#superDk[mpiRank(preffe#prmesh#commsuper)];
                preffe#K[int] tmp2(pr#RsuperCS.m);
                tmp2 = pr#RsuperCS'*tmp;
                vaux.resize(pr#ncoarsespace);
                vaux = pr#E^-1*tmp2;
                /*
                tmp = pr#RsuperCS*vaux;
                tmp = tmp .* preffe#superDk[mpiRank(preffe#prmesh#commsuper)];
                vaux = pr#RsuperCS'*tmp;
                */
              }
              
              preffe#prmesh#toccomm(pr#tcsi,"",pr#tcs,preffe#prmesh#commsuper)
            }
            
            if (pr#prfe#prmesh#issuper) {
              if (!pr#prfe#prmesh#excluded)
                tmp = vaux(pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]:pr#offseti[mpiRank(pr#prfe#prmesh#commddm)]+pr#sizelg[mpiRank(pr#prfe#prmesh#commddm)]-1);
              mpiRequest[int] rq(pr#prfe#prmesh#insuperinterior.n-!pr#prfe#prmesh#excluded);
              pr#prfe#K[int][int] tres(pr#prfe#prmesh#insuperinterior.n);
              for (int i=!pr#prfe#prmesh#excluded; i < pr#prfe#prmesh#insuperinterior.n; i++) {
                tres[i].resize(pr#sizelg[pr#prfe#prmesh#insuperinterior[i]]);
                tres[i] = vaux(pr#offseti[pr#prfe#prmesh#insuperinterior[i]]:pr#offseti[pr#prfe#prmesh#insuperinterior[i]]+pr#sizelg[pr#prfe#prmesh#insuperinterior[i]]-1);
              }
              for (int i=!pr#prfe#prmesh#excluded; i < pr#prfe#prmesh#insuperinterior.n; i++) {
                Isend(processor(pr#prfe#prmesh#insuperinterior[i]+pr#prfe#prmesh#pCS*pr#prfe#prmesh#exclude,pr#prfe#prmesh#mpicomm,rq[i-!pr#prfe#prmesh#excluded]),tres[i]);
              }
              for (int i=0;i < pr#prfe#prmesh#insuperinterior.n-!pr#prfe#prmesh#excluded;i++)
                int k = mpiWaitAny(rq);
            }
            else {
              mpiRequest rq;
              Irecv(processor(pr#prfe#prmesh#mysuper,pr#prfe#prmesh#mpicomm,rq),tmp);
              mpiWait(rq);
            }

            for (int i=0;i<pr#si;i++) {
              res += tmp[i]*pr#Z[i];
            }
            /* sum_j R_i Z_j zaux_j */
            ENDIFMACRO
            ;
          }
          pr#prfe#update(res,false); /* recover the Z_j zaux_j (in the overlap) computed by neighbouring subdomains */
        }
      }
    }
    return res;
}

func preffe#K[int] pr#Q(preffe#K[int] &l)      /* Q = Z*E^-1*Z^T */
{
  return pr#Q(l, 1);
}

IFMACRO (pr#myPREC1)
pr#myPREC1
ENDIFMACRO
IFMACRO (!pr#myPREC1)
func preffe#K[int] pr#PREC1(preffe#K[int] &l, int mrhs)
{
  /* Application of the 1 level preconditioner
  M^{-1}*y = \sum Ri^T*Di*Ai^{-1}*Ri*y
  Ri restriction operators, Ai local matrices */
  
  preffe#K[int] s(l.n);
  s = 0;
  
  if (preffe#prmesh#isincomm) {
    preffe#prmesh#tic(pr#tpreci)
    
    if (pr#prec == "none") {
      s = l;
    }
    else {
      if (!bpara) {
        assert(mrhs == 1);
        for(int i=0; i<preffe#prmesh#npart; ++i)  {
          preffe#K[int] bi(preffe#Rih[i].n);
          bi = preffe#Rih[i]*l;           /* restricts rhs */
          if(pr#prec == "soras")
          bi = bi .* preffe#Dk[i];
          preffe#K[int] ui = pr#aR[i] ^-1 * bi;  /* local solves */
          if(pr#prec != "asm")
          ui = ui .* preffe#Dk[i];                      /* partition of unity */
          s += preffe#Rih[i]'*ui;                  /* prolongation */
        }
      }
      else if (!preffe#prmesh#excluded){
        preffe#K[int] aux = l;
        if(pr#prec == "soras")
        for (int m=0; m<mrhs; m++)
          aux(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1) = aux(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1) .* preffe#Dk[mpiRank(preffe#prmesh#commddm)];
        /* s = aR[mpirank]^-1 * l; */
        s = pr#aR[mpiRank(preffe#prmesh#commddm)]^-1 * aux;
        if(pr#prec != "asm"){
          for (int m=0; m<mrhs; m++)
            pr#prfe#update(s(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1),true);
        }
        else{
          for (int m=0; m<mrhs; m++) {
            pr#prfe#update(s(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1),false);
            pr#prfe#update(s(m*preffe#Vhi.ndof:(m+1)*preffe#Vhi.ndof-1),true);
          }
        }       
      }
    }
    preffe#prmesh#toc(pr#tpreci,"",pr#tprec)
  }
  return s;
}

func preffe#K[int] pr#PREC1(preffe#K[int] &l)
{
  int mrhs = 1;
  if (preffe#prmesh#isincomm) {
    int ndof = bpara ? preffe#Dk[mpiRank(preffe#prmesh#commddm)].n : preffe#Vhglob.ndof;
    assert(l.n%ndof == 0);
    mrhs = l.n/ndof;
  }
  return pr#PREC1(l, mrhs);
}
ENDIFMACRO

func preffe#K[int] pr#PREC2level(preffe#K[int] &l)
{
  preffe#K[int] ltemp(l.n);
  ltemp = 0;
  if (preffe#prmesh#isincomm) {
    
    preffe#prmesh#tic(pr#tpreci)
    
    preffe#K[int] Ql;
    preffe#K[int] aux;
    
    /* Q */
    if (pr#corr == "AD" || pr#corr == "ADEF1" || pr#corr == "ADEF2" || pr#corr == "BNN" || pr#corr == "RBNN1")   {
      Ql.resize(l.n);
      Ql = pr#Q(l);
    }
    
    /* P */
    if (pr#corr == "ADEF1" || pr#corr == "BNN" || pr#corr == "RBNN1") {
      aux.resize(l.n);
      if (pr#bCM)
      aux = pr#AEprec(Ql);
      else
      aux = pr#A(Ql);
      ltemp = l-aux; 
    }
    else
    ltemp = l; 
    
    preffe#prmesh#toc(pr#tpreci,"",pr#tprec)
    
    /* M^-1 */
    preffe#K[int] s(l.n);
    s = pr#PREC1(ltemp);
    
    preffe#prmesh#tic(pr#tpreci)

    /* P^T */
    if (pr#corr == "ADEF2" || pr#corr == "BNN" || pr#corr == "RBNN1" || pr#corr == "RBNN2") {
      if (pr#bCM)
      ltemp = pr#AEprec(s);
      else
      ltemp = pr#A(s);
      aux.resize(l.n);
      aux = pr#Q(ltemp);
      ltemp = s-aux;
    }
    else
    ltemp = s;    
    
    /* + Q */
    if (pr#corr == "AD" || pr#corr == "ADEF1" || pr#corr == "ADEF2" || pr#corr == "BNN") 
    ltemp += Ql;
    
    preffe#prmesh#toc(pr#tpreci,"",pr#tprec)
  }
  return ltemp;
}

/*
func preffe#K[int] pr#PRECTEST(preffe#K[int] &l)
{
   preffe#K[int] res(l.n),x0(l.n);
   IFMACRO (pr#minexactCS,1)
   x0 = 0;
   res = pr#CoarsefGMRES(x0, l, 1.e-6, 5, "right");
   ENDIFMACRO
   return res;
}
*/

func preffe#K[int] pr#PRECTEST(preffe#K[int] &l)
{
  /*
   preffe#K[int] dd = pr#aRd[0].diag;
   dd = 1./dd;
   dd = l.*dd;
   return dd;
   */
   return l;
}

/*
func preffe#K[int] pr#PRECTEST(preffe#K[int] &l)
{
   preffe#K[int] res(l.n);
   preffe#K[int] ls = l .* preffe#Dk[mpiRank(preffe#prmesh#commddm)];
   preffe#K[int] tmp = pr#ZCMi'*ls;
   
   IFMACRO (preffe#prmesh#minexactCS,1)
   preffe#K[int] rr = pr#CoarsePREC1(tmp);
   res = pr#ZCMi*rr;
   ENDIFMACRO

   return res;
}
*/

/* CMCG */
/*
func pr#K[int] pr#PRECTEST(pr#K[int] &l)
{
  if (cpt%2 >3) {
  Vhi<pr#K> pr#mdef(u0),pr#mdef(ucmcg);
  u0[] = 0;
  ffcmcgrhs(Vhi,Thi,ThAugmented,l,u0,ucmcg)
  cpt++;
  return ucmcg[];
  }
  else{
    cpt++;
    return pr#PREC1(l);
  }
}
*/

IFMACRO (pr#myPREC)
pr#myPREC
ENDIFMACRO
IFMACRO (!pr#myPREC)
func preffe#K[int] pr#PREC(preffe#K[int] &l)
{
	if (pr#corr == "test")
	  return pr#PRECTEST(l);
    else if (pr#corr == "none")
      return pr#PREC1(l);
    else
      return pr#PREC2level(l);
}
ENDIFMACRO

func preffe#K[int] pr#fGMRES(preffe#K[int]& x0, preffe#K[int]& rhs, real eps, int maxit, string sprec)
{	
  if (preffe#prmesh#isincomm) {
    preffe#prmesh#tic(pr#tgmresi)
    
    preffe#K[int] uni(x0.n);
    
    int dim = min(maxit,ffddmrestart);

    IFMACRO(pr#withhpddmkrylov)
    load "hpddm"
    if (!preffe#prmesh#excluded) {
      uni = x0;
      IterativeMethod(pr#A, rhs,uni, precon = pr#PREC, sparams = "-hpddm_tol "+eps+" -hpddm_variant "+(preffe#prmesh#binexactCS ? "flexible" : sprec)+" -hpddm_gmres_restart "+dim+" -hpddm_max_it "+maxit+(mpirank == 0 ? " -hpddm_verbosity "+pr#verbosity : "")+" -hpddm_orthogonalization mgs",communicator = preffe#prmesh#mpicomm);
    }
    else
    IterativeMethod(pr#A, uni,uni, precon = pr#PREC, sparams = "-hpddm_tol "+eps+" -hpddm_variant "+(preffe#prmesh#binexactCS ? "flexible" : sprec)+" -hpddm_gmres_restart "+dim+" -hpddm_max_it "+maxit+(mpirank == 0 ? " -hpddm_verbosity "+pr#verbosity : "")+" -hpddm_orthogonalization mgs",communicator = preffe#prmesh#mpicomm);
    ENDIFMACRO
    
    IFMACRO(pr#withhpddm)
    uni = x0;
    real[int] timings(1);
    string prefix = Stringification(pr)+"_";
    set(pr#hpddmOP, sparams = "-hpddm_"+prefix+"schwarz_method "+pr#prec+" -hpddm_"+prefix+"tol "+eps+" -hpddm_"+prefix+"variant "+(preffe#prmesh#binexactCS ? "flexible" : sprec)+" -hpddm_"+prefix+"gmres_restart "+dim+" -hpddm_"+prefix+"max_it "+maxit+" -hpddm_"+prefix+"verbosity "+pr#verbosity+" -hpddm_"+prefix+"orthogonalization mgs", prefix=prefix);
    if (pr#corr == "AD")
      set(pr#hpddmOP, sparams = "-hpddm_"+prefix+"schwarz_coarse_correction additive", prefix=prefix);
    else if (pr#corr == "BNN")
      set(pr#hpddmOP, sparams = "-hpddm_"+prefix+"schwarz_coarse_correction balanced", prefix=prefix);
    else if (pr#corr == "ADEF1")
      set(pr#hpddmOP, sparams = "-hpddm_"+prefix+"schwarz_coarse_correction deflated", prefix=prefix);
    
    if (pr#prec == "oras" || pr#prec == "soras")
      DDM(pr#hpddmOP,rhs,uni,O=pr#aR[mpiRank(preffe#prmesh#commddm)],communicator=preffe#prmesh#commddm,timing=timings);
    else
      DDM(pr#hpddmOP,rhs,uni,communicator=preffe#prmesh#commddm,timing=timings);
    
    /*
    real[int] timingsg(timings.n);
    mpiAllReduce(timings,timingsg,mpiCommWorld,mpiMAX);
    */
    pr#tgmres -= timings[0];
    pr#tfacto += timings[0];
    ENDIFMACRO

    IFMACRO(pr#withpetsc)
    uni = x0;
    uni = pr#petscOP^-1*rhs;
    ENDIFMACRO

    IFMACRO((!pr#withhpddm)&(!pr#withhpddmkrylov)&(!pr#withpetsc))
    preffe#K[int,int] Hn(dim+2,dim+1);     /* Hessenberg matrix */
    Hn = 0.;

    IFMACRO(pr#withritz)
    preffe#K[int,int] Hessenberg(dim+2,dim+1);     /* copy of Hessenberg matrix for Ritz values/harmonics */
    Hessenberg=0.;
    pr#RitzValues.resize(dim+1);
    for (int i=0;i<dim+1;i++)
      pr#RitzValues[i].resize(i+1);
    pr#RitzHarmonicValues.resize(dim+1);
    for (int i=0;i<dim+1;i++)
      pr#RitzHarmonicValues[i].resize(i+1);
    ENDIFMACRO

    preffe#K[int,int] rot(2,dim+2);
    rot = 0.;
    preffe#K[int] g(dim+1),g1(dim+1);
    g = 0.;  g1 = 0.;
    
    preffe#K[int] ri(x0.n),zi(x0.n),vi(x0.n),wi(x0.n),x0i(x0.n);
    preffe#K[int][int] Vi(dim+1), Vpi(dim+1);
    for (int i=0;i<dim+1;i++){
      Vi[i].resize(x0.n);
      Vpi[i].resize(x0.n);
    }

    real normb = 0;
    
    if (!preffe#prmesh#excluded) {
      wi = rhs;
      for [i,bi: wi] bi = (abs(bi) > 1.e+20 ? 0 : bi);
    }
    
    if (sprec == "right")
      normb = sqrt(real(pr#prfe#scalprod(wi,wi)));
    else{
      vi = pr#PREC(wi);
      normb = sqrt(real(pr#prfe#scalprod(vi,vi)));
    }
    if (normb < 1.e-20 || eps < 0) normb = 1.;

    real relres = 0;
    
    pr#nbiter = 1;
    
    x0i = x0;
    
    while (pr#nbiter <= maxit) {
      
      if (pr#corr=="ADEF2" || pr#corr=="RBNN1" || pr#corr=="RBNN2")
        /* TODO handle restart */
        x0i = pr#Q(rhs);
      
      ri = pr#A(x0i);

      if (!preffe#prmesh#excluded)
        ri -= rhs;
      ri *= -1.0;
      
      if (sprec == "right")
        zi = ri;
      else
        zi = pr#PREC(ri);
      
      g[0] = sqrt(real(pr#prfe#scalprod(zi,zi)));
      
      if(abs(g[0])/normb < abs(eps)) {
          if (pr#verbosity && (mpiRank(preffe#prmesh#mpicomm)==0)) {
            cout << "["+Stringification(pr)+"] GMRES has converged in 0 iteration " << endl;
            cout << "["+Stringification(pr)+"] The relative residual is " +  abs(g[0])/normb << endl;
          }
          pr#nbiter = 0;
          uni = x0;
          break;
      }

      Vi[0]=1/g[0]*zi;           /* first basis vector */
      
      for(int it=0; it<dim; it++) {
        if (sprec == "right") {
          Vpi[it] = pr#PREC(Vi[it]);
          vi=Vpi[it];
          wi=pr#A(vi);
        }
        else {
          vi=pr#A(Vi[it]);
          wi = pr#PREC(vi);
        }

        for(int i=0; i<it+1; i++) {
          Hn(i,it) = pr#prfe#scalprod(wi,Vi[i]);
          IFMACRO(pr#withritz)
          Hessenberg(i,it)=Hn(i,it);
          ENDIFMACRO
          wi -=  conj(Hn(i,it))*Vi[i];
        }
        Hn(it+1,it) = sqrt(real(pr#prfe#scalprod(wi,wi)));
        IFMACRO(pr#withritz)
        Hessenberg(it+1,it)=Hn(it+1,it);
        ENDIFMACRO
        preffe#K aux = Hn(it+1,it);
        Vi[it+1]=1/aux*wi;

        IFMACRO(pr#withritz)
        load "lapack"
        preffe#K[int,int] Hnb1=Hessenberg(0:it,0:it);
        preffe#K[int,int] subHn=Hessenberg(0:it+1,0:it);
        preffe#K[int,int] Hnb1trans=Hnb1';
        preffe#K[int,int] subHntrans=subHn';
        preffe#K[int,int] Hnprod = subHntrans*subHn;
        preffe#K[int,int] Hnbinv = Hnb1trans^-1;
        preffe#K[int,int] S = Hnbinv*Hnprod;
        preffe#K[int] ritzharmonicvalues(it+1);
        preffe#K[int,int] ritzharmonicvectors(it+1,it+1);
        IFMACRO(preffe#K,complex)
        zgeev(S,pr#RitzHarmonicValues[it],ritzharmonicvectors);
        ENDIFMACRO
        IFMACRO(preffe#K,real)
        dgeev(S,pr#RitzHarmonicValues[it],ritzharmonicvectors);
        ENDIFMACRO
        pr#RitzHarmonicValues[it].im *= -1;
        preffe#K[int,int] Hnb2=Hessenberg(0:it,0:it);
        preffe#K[int] ritzvalues(it+1);
        preffe#K[int,int] ritzvectors(it+1,it+1);
        IFMACRO(preffe#K,complex)
        zgeev(Hnb2,pr#RitzValues[it],ritzvectors);
        ENDIFMACRO
        IFMACRO(preffe#K,real)
        dgeev(Hnb2,pr#RitzValues[it],ritzvectors);
        ENDIFMACRO
        pr#RitzValues[it].im *= -1;
        ENDIFMACRO

        for(int i=0; i<it; i++){ 	 /* QR decomposition of Hn */
          preffe#K aa = conj(rot(0,i))*Hn(i,it)+conj(rot(1,i))*Hn(i+1,it);
          preffe#K bb = -rot(1,i)*Hn(i,it)+rot(0,i)*Hn(i+1,it);
          Hn(i,it) = aa;
          Hn(i+1,it) = bb;
        }

        preffe#K sq = sqrt( conj(Hn(it,it))*Hn(it,it) + Hn(it+1,it)*Hn(it+1,it) );

        rot(0,it) = Hn(it,it)/sq;
        rot(1,it) = Hn(it+1,it)/sq;

        Hn(it,it) = conj(rot(0,it))*Hn(it,it)+conj(rot(1,it))*Hn(it+1,it);
        Hn(it+1,it) =  0.;
        g[it+1] = -rot(1,it)*g[it];
        g[it] = conj(rot(0,it))*g[it];

        preffe#K[int] y(it+1);     	/* Reconstruct the solution */
        for(int i=it; i>=0; i--) {
          g1[i] = g[i];
          for(int j=i+1; j<it+1; j++){
            g1[i] = g1[i]-Hn(i,j)*y[j];
          }
          y[i]=g1[i]/Hn(i,i);
        }

        uni = x0i;
        for(int i=0;i<it+1;i++){
          if (sprec == "right")
            uni= uni+ conj(y[i])*Vpi[i];
          else
            uni= uni+ conj(y[i])*Vi[i];
        }

        real relerr = 0;
        relres = abs(g[it+1]);

        /*
        if (pr#bdirect){
          if (!bpara) {
            pr#ver[] = uni[] - pr#uglob[];
            relerr = pr#ver[].l2/pr#uglob[].l2;
          }
          else {
            if (!preffe#prmesh#excluded) {
              vi[] = preffe#Rih[mpiRank(preffe#prmesh#commddm)] * pr#uglob[];
              vi[] -= uni[];
            }
            relerr = sqrt(real(pr#prfe#scalprod(vi[],vi[])));
            relerr /= pr#uglob[].l2;
          }
        }
        */

        if (pr#verbosity >= 3 && (mpiRank(preffe#prmesh#mpicomm)==0)) {
          if (pr#bdirect)
            cout << "["+Stringification(pr)+"] It: "<< pr#nbiter << " Residual = " << relres << " Rel res = " << relres/normb <<  " Relative L2 Error =  "<< relerr <<  endl;
          else
            cout << "["+Stringification(pr)+"] It: "<< pr#nbiter << " Residual = " << relres << " Rel res = " << relres/normb << endl;
        }

        if (pr#verbosity >= 10){
          IFMACRO(preffe#defplot)
          preffe#Vhi<preffe#K> def(unih);
          unih[] = uni;
          preffe#mplot(preffe#defplot(unih), "["+Stringification(pr)+"] Approximate solution at step " + pr#nbiter)
          ENDIFMACRO
          ;
        }

        if(relres/normb < abs(eps)) {
          if (pr#verbosity && (mpiRank(preffe#prmesh#mpicomm)==0)) {
            cout << "["+Stringification(pr)+"] GMRES has converged in " + (pr#nbiter) + " iterations " << endl;
            cout << "["+Stringification(pr)+"] The relative residual is " +  relres/normb << endl;
          }
          break;
        }
        pr#nbiter++;
        if (pr#nbiter > maxit)
          break;
      }
      if(relres/normb < abs(eps) || pr#nbiter > maxit)
        break;

      x0i = uni;
      if (pr#verbosity && (mpiRank(preffe#prmesh#mpicomm)==0))
        cout << "["+Stringification(pr)+"] GMRES restart(" + dim +")" << endl;
    }
    if(relres/normb >= abs(eps))
    if (pr#verbosity && (mpiRank(preffe#prmesh#mpicomm)==0)) {
      cout << "["+Stringification(pr)+"] GMRES did not converge in " + maxit + " iterations " << endl;
      cout << "["+Stringification(pr)+"] The relative residual is " +  relres/normb << endl;
    }
    ENDIFMACRO
    preffe#prmesh#toc(pr#tgmresi,"",pr#tgmres)
    return uni;
  }
  else
    return x0; /* dummy, not in comm */
}
/*# finGMRESsolve #*/

// EOM

include "macro_ddm.idp"

macro partitionSubstructuring(meshName, interfaceNb, globalName, PhGlobal, part, s, ndofSkeleton, BC, comm, fakeInterface, labDirichlet)
        meshName = trunc(globalName, abs(part - mpiRank(comm)) < 0.1, label = fakeInterface);
        fespace VhGlobal(globalName, P1);
        PhGlobal supp = abs(part - mpiRank(comm)) < 0.1;
        VhGlobal suppSmooth;
        AddLayers(globalName, supp[], 2, suppSmooth[]);
        ndofSkeleton.resize(1);
        ndofSkeleton[0].resize(0);
        {
            int[int] n2o;
            meshN neighbors = trunc(globalName, suppSmooth > 0.001, new2old = n2o);
            int[int] partOverlap(n2o.n);
            for[i, v : n2o] partOverlap[i] = part[][v];
            Unique(partOverlap, ndofSkeleton[0], remove = mpiRank(comm));
        }
        VhGlobal[int] partitionIntersection(ndofSkeleton[0].n);
        if(s > 1) {
            globalName = trunc(globalName, suppSmooth > 0.001, split = s, label = fakeInterface);
            supp = abs(part - mpiRank(comm)) < 0.1;
            suppSmooth = 0;
            AddLayers(globalName, supp[], 2, suppSmooth[]);
            meshName = trunc(meshName, 1, split = s);
        }
        globalName = trunc(globalName, suppSmooth > 0.501, label = fakeInterface);
        real eps = intN(globalName)(1.0);
        real[int] epsTab(ndofSkeleton[0].n);
        mpiRequest[int] rq(2 * ndofSkeleton[0].n);
        for(int j = 0; j < ndofSkeleton[0].n; ++j)
            Irecv(processor(ndofSkeleton[0][j], comm, rq[j]), epsTab[j]);
        for(int j = 0; j < ndofSkeleton[0].n; ++j)
            Isend(processor(ndofSkeleton[0][j], comm, rq[ndofSkeleton[0].n + j]), eps);
        VhGlobal phi = 0;
        part = part;
        int numberIntersection = 0;
        for(int k = 0; k < 2 * ndofSkeleton[0].n; ++k)
            mpiWaitAny(rq);
        for(int i = 0; i < ndofSkeleton[0].n; ++i) {
            PhGlobal suppPartition = abs(ndofSkeleton[0][i] - part) < 0.1;
            AddLayers(globalName, suppPartition[], 1, phi[]);
            if(intN(globalName)(phi) / min(eps, epsTab[i]) > 1.0e-10) {
                partitionIntersection[numberIntersection] = phi;
                ndofSkeleton[0][numberIntersection++] = ndofSkeleton[0][i];
            }
        }
        if(numberIntersection != ndofSkeleton[0].n)
            ndofSkeleton[0].resize(numberIntersection);
        Wh def(interface);
        varf vPbInterface(def(u), def(v)) = on(fakeInterface, BC(u, 1.0)) + on(labDirichlet, BC(u, 0.0));
        interface[] = vPbInterface(0, Wh, tgv = 1);
        matrix[int] R(ndofSkeleton[0].n);

        for(int i = 0; i < ndofSkeleton[0].n; ++i) {
            meshN meshIntersection = trunc(globalName, (part == mpiRank(comm) || part == ndofSkeleton[0][i]) && partitionIntersection[i] > 1e-6, label = fakeInterface);
            fespace WhIntersection(meshIntersection, Pk);
            R[i] = interpolate(WhIntersection, Wh, inside = 1);
        }
        buildSkeleton(interface[], R, ndofSkeleton, interface = interfaceNb, redundancy = getARGV("-redundancy", 1), communicator = comm);// EOM

macro buildSubstructuringWithPartitioning(Th, interfaceNb, userPartitioning, fakeInterface, labDirichlet, labNeumann, s, intersection, P, BC, comm, excluded)
{
    real timing = mpiWtime();
    fespace WhLocal(Th, Pk);
    if(mpiSize(comm) > 1 && !excluded) {
        meshN ThGlobal = Th;
        fespace PhGlobal(ThGlobal, P0);
        PhGlobal partGlobal;
        if(userPartitioning.n != PhGlobal.ndof) {
            if(mpiRank(comm) == 0) {
                if(verbosity > 0)
                    cout.scientific << " --- global mesh of " << ThGlobal.nt << " elements (prior to refinement) partitioned with " << Stringification(partitioner);
                timing = mpiWtime();
                partitionerSeq(partGlobal[], ThGlobal, mpiSize(comm));
            }
            partitionerPar(partGlobal[], ThGlobal, comm, mpiSize(comm));
            if(mpiRank(comm) == 0 && verbosity > 0)
                cout.scientific << " (in " << mpiWtime() - timing << ")" << endl;
            timing = mpiWtime();
        }
        else {
            partGlobal[] = userPartitioning;
            broadcast(processor(0, comm), partGlobal[]);
        }
        partitionSubstructuring(Th, interfaceNb, ThGlobal, PhGlobal, partGlobal, s, intersection, BC, comm, fakeInterface, labDirichlet)
    }
    else if(mpiSize(comm) == 1) {
        if(s > 1)
            Th = trunc(Th, 1, split = s);
        Wh def(interface);
        varf vPbInterface(def(u), def(v)) = on(labNeumann, BC(u, 1.0)) + on(labDirichlet, BC(u, 0.0));
        interface[] = vPbInterface(0, Wh, tgv = 1);
        interfaceNb.resize(Wh.ndof);
        int j = 0;
        for(int i = 0; i < Wh.ndof; ++i) {
            if(interface[][i] > 0.9)
                interfaceNb[j++] = i;
        }
        interfaceNb.resize(j);
    }
    mpiBarrier(mpiCommWorld);
    if(verbosity > 0 && mpirank == 0) cout.scientific << " --- partition of unity built (in " << mpiWtime() - timing << ")" << endl;
}// EOM

macro buildSubstructuring(Th, interfaceNb, fakeInterface, labDirichlet, labNeumann, s, intersection, P, BC, comm, excluded)
{
    real[int] emptyArray(0);
    buildSubstructuringWithPartitioning(Th, interfaceNb, emptyArray, fakeInterface, labDirichlet, labNeumann, s, intersection, P, BC, comm, excluded)
}// EOM
verbosity = 0;
int ffddmverbosity = getARGV("-ffddm_verbosity", 5);
/*
if (mpirank != 0)
  mverbosity = 0;
*/

string ffddmprecond = getARGV("-ffddm_schwarz_method", "ras");
string ffddmvariant = getARGV("-ffddm_variant", "right"); // right(default) or left preconditioning
int ffddmrestart = getARGV("-ffddm_gmres_restart",200);
int ffddmmaxit = getARGV("-ffddm_max_it", 200);
real ffddmtol = getARGV("-ffddm_tol", 1.e-6);
real ffddminexactCStol = getARGV("-ffddm_inexactCS_tol", 1.e-1);
int ffddmnu = getARGV("-ffddm_geneo_nu", 20); // number of local eigenvectors to compute for DtN CS (choice criterion 4.3 of Lea's paper is applied to these computed eigenvectors unless -noLea is activated)
real ffddmtau = getARGV("-ffddm_geneo_threshold",0.5);
if (usedARGV("-ffddm_geneo_nu") > -1 && usedARGV("-ffddm_geneo_threshold") <= -1)
  ffddmtau = 0;
int ffddminertia = usedARGV("-ffddm_geneo_threshold") > -1 && usedARGV("-ffddm_geneo_no_inertia") <= -1;
if (ffddminertia && usedARGV("-ffddm_geneo_nu") <= -1)
  ffddmnu = 500;

string ffddmcorrection = getARGV("-ffddm_schwarz_coarse_correction", "ADEF1"); // for 2 level preconditioner

int ffddmexclude = getARGV("-ffddm_master_exclude", 0);
int ffddmpCS = getARGV("-ffddm_master_p", 1);

int ffddminterfacelabel = 10;
int[int] ffddmcubelabels = [10,10,10,10,10,10];

/*
int binexactCS = usedARGV("-inexactCS") > -1 ? 1 : 0;
int inexactCSsplit = getARGV("-inexactCS_split", 1);
if (binexactCS) {
  exclude = 0;
  pCS = mpisize; 
}
*/

/*
if (!bCS) {
  exclude = 0;
  pCS = 0;
}
*/

int ffddmoverlap = getARGV("-ffddm_overlap", 1);
int ffddmsplit = getARGV("-ffddm_split", 1);
int ffddmpartitioner = getARGV("-ffddm_partitioner", 1); // 0: simple, 1: metis, 2: scotch
int ffddmbmedit = usedARGV("-ffddm_medit") > -1 ? 1 : 0;
int ffddmbffplot = usedARGV("-ffddm_disable_plots") > -1 ? 0 : 1;
int ffddmbplot = (ffddmbmedit || ffddmbffplot) && !NoGraphicWindow;
int ffddmnbiso = getARGV("-ffddm_nbiso", 20);
int ffddmbdirect = usedARGV("-direct") > -1 ? 1 : 0;
int ffddmnpart = getARGV("-seqddm", -1);
int bpara = 0;
int bseq = 1;
if (ffddmnpart <= 0) {
  bseq = 0;
  bpara = 1;
  ffddmnpart = mpisize-ffddmexclude*ffddmpCS;
}

int bnoGlob = usedARGV("-noGlob") > -1 ? 1 : 0;
int bnoGlobwithpartloc = usedARGV("-noGlobwithpartloc") > -1 ? 1 : 0;
int bnopartloc = bnoGlob;
bnoGlob = bnoGlob || bnoGlobwithpartloc;

//if (abs(ffddmsplit)>1) bnoGlob = 1;
if (bseq || ffddmbplot || ffddmbdirect)
  assert(!bnoGlob);
  
real vtgv = -1;//1.e+30;
real vtgvelim = -1;//-2;
int vsym = 0;//
//macro msym GMRES//CG//EOM

/*
if (binexactCS) {
  assert(bCS && bCM && bpara);
}
*/

/*
macro simple(PhGlobal, part, comm)
{
	part = 1;
}
// EOM
*/

/*
real diam;
macro bbN(boundingMesh, overshoot, ThGlobal)
            real[int] bb(4);
            boundingbox(bb, boundingMesh);
            diam = sqrt((bb(1) - bb(0))^2 + (bb(3) - bb(2))^2);
            bb(0) -= overshoot;
            bb(1) += overshoot;
            bb(2) -= overshoot;
            bb(3) += overshoot;

            ThGlobal = mtrunc(ThGlobal, (x >= bb(0) && x <= bb(1) && y >= bb(2) && y <= bb(3)));// EOM
*/
         

IFMACRO(!macroDDMidp)
macro macroDDMidp()1// EOM
include "getARGV.idp"
IFMACRO(!partitioner)
macro partitioner()metis// EOM
ENDIFMACRO
IFMACRO(partitioner,metis)
load "metis"
macro partitionerSeq(part, Th, size){ if(size <= 1) part = 0; else metisdual(part, Th, size); }// EOM
macro partitionerPar(part, Th, comm, size)broadcast(processor(0, comm), part)// EOM
ENDIFMACRO
IFMACRO(partitioner,scotch)
load "scotch"
macro partitionerSeq(part, Th, size){ if(size <= 1) part = 0; else scotch(part, Th, size); }// EOM
macro partitionerPar(part, Th, comm, size)broadcast(processor(0, comm), part)// EOM
ENDIFMACRO
IFMACRO(partitioner,parmetis)
load "parmetis"
macro partitionerSeq(part, Th, size)// EOM
macro partitionerPar(part, Th, comm, size)parmetis(part, Th, size, communicator = comm, worker = getARGV("-parmetis_worker", 1))// EOM
ENDIFMACRO
IFMACRO(!partitionerSeq)
cout << "The macro 'partitioner' must be set to 'metis', 'scotch', or 'parmetis'" << endl;
exit(1);
ENDIFMACRO
IFMACRO(dimension,2)
macro meshN()mesh// EOM             // two-dimensional problem
macro intN()int2d// EOM             // two-dimensional integral
macro intN1()int1d// EOM            // one-dimensional integral
macro readmeshN()readmesh// EOM     // two-dimensional problem
macro defVel(uP)[uP, uP#Y]// EOM    // two-dimensional velocity for convect/advect
ENDIFMACRO
IFMACRO(dimension,3)
macro meshN()mesh3// EOM            // three-dimensional problem
macro intN()int3d// EOM             // three-dimensional integral
macro intN1()int2d// EOM            // two-dimensional integral
macro readmeshN()readmesh3// EOM    // three-dimensional problem
macro defVel(uP)[uP, uP#Y, uP#Z]// EOM // three-dimensional velocity for convect/advect
ENDIFMACRO
IFMACRO(dimension,3S)
macro meshN()meshS// EOM            // three-dimensional surface problem
macro intN()int2d// EOM             // two-dimensional integral
macro intN1()int1d// EOM            // one-dimensional integral
macro intNxN()int2dx2d// EOM        // two-dimensional integral for BEM
ENDIFMACRO
IFMACRO(dimension,3L)
macro meshN()meshL// EOM            // three-dimensional line problem
macro intN()int1d// EOM             // one-dimensional integral
macro intN1()int0d// EOM            // zero-dimensional integral
macro intNxN()int1dx1d// EOM        // one-dimensional integral for BEM
ENDIFMACRO

macro plotDmesh(Th, params)
if(!NoGraphicWindow || usedARGV("-fglut") != -1) {
    fespace PhPlotPrivate(Th, P0);
    PhPlotPrivate plt;
    if(Th.nt)
        plt[] = mpirank;
NewMacro defPlt#Th(uPrivate)uPrivate EndMacro
    plotMPI(Th, plt, P0, defPlt#Th, real, params)
}//

macro plotD(Th, uPrivate, params)
if(!NoGraphicWindow || usedARGV("-fglut") != -1) {
    fespace VhPlotPrivate(Th, P1);
    VhPlotPrivate plt;
    if(Th.nt)
        plt = uPrivate;
NewMacro defPlt#Th(vPrivate)vPrivate EndMacro
    plotMPI(Th, plt, P1, defPlt#Th, real, params)
}//

macro plotMPI(Th, uPrivate, Pk, def, K, params)
if(!NoGraphicWindow || usedARGV("-fglut") != -1) {
IFMACRO(!meshN)
    NewMacro meshN()mesh EndMacro
ENDIFMACRO
IFMACRO(!def)
    NewMacro def(i)i EndMacro
ENDIFMACRO
    meshN ThCurrent = Th;
    fespace XhPlotPrivate(ThCurrent, Pk);
    XhPlotPrivate<K> def(uSend);
    if(ThCurrent.nt)
        def(uSend) = uPrivate;
    if(mpirank == 0) {
        meshN[int] meshTab(mpisize);
        XhPlotPrivate<K>[int] def(uTab)(mpisize);
        if(ThCurrent.nt)
            uTab[0][] = uSend[];
        meshTab[0] = ThCurrent;
        mpiRequest[int] rq(mpisize - 1);
        for(int i = 1; i < mpisize; ++i)
            Irecv(processor(i, mpiCommWorld, rq[i - 1]), meshTab[i]);
        mpiWaitAll(rq);
        for(int i = 1; i < mpisize; ++i) {
            ThCurrent = meshTab[i];
            if(ThCurrent.nt)
                Irecv(processor(i, mpiCommWorld, rq[i - 1]), uTab[i][]);
        }
        mpiWaitAll(rq);
        plot(def(uTab), params);
    }
    else {
        mpiRequest[int] rq(2);
        Isend(processor(0, rq[0]), ThCurrent);
        if(ThCurrent.nt)
            Isend(processor(0, rq[1]), uSend[]);
        mpiWaitAll(rq);
    }
}// EOM

macro partitionPrivate(meshName, borderName, globalName, PhGlobalPrivate, VhGlobalPrivate, part, rank, size, s, overlap, level, prolongation, D, P, intersection, comm, fakeInterface, PkPart, defPart, initPart, bs) {
    int backupSM = searchMethod;
    searchMethod = 1;
    assert(level >= 1);
IFMACRO(!privateCreatePartition)
IFMACRO(!privateCreateMat)
    intersection.resize(1);
    intersection[0].resize(0);
    PhGlobalPrivate supp;
    VhGlobalPrivate suppSmooth;
    {
        int constant = rank;
        for[i, value : supp[]] value = abs(part[][i] - constant) < 0.1;
        AddLayers(globalName, supp[], 2 * overlap, suppSmooth[]);
        int[int] n2o;
        meshN neighbors;
        bool connected = false;
        for[i, value : suppSmooth[]] if(abs(value - 0.5) < 0.5) connected = true;
        if(!connected)
            n2o.resize(0);
        else
            neighbors = trunc(globalName, suppSmooth > 0.001 && suppSmooth < 0.999, new2old = n2o);
        int[int] partOverlap(n2o.n);
        for[i, value : n2o] partOverlap[i] = part[][value];
        Unique(partOverlap, intersection[0], remove = constant);
        if(s > 1 && level <= 1) {
            globalName = trunc(globalName, suppSmooth > 0.001, split = s);
            supp = abs(part - constant) < 0.1;
            suppSmooth = 0;
            AddLayers(globalName, supp[], 2 * overlap, suppSmooth[]);
        }
    }
    int[int] n2oGlobalPrivate, n2oNeighbor;
IFMACRO(!privateDmesh#CartesianPartitioning)
    globalName = trunc(globalName, suppSmooth > 0.001, label = 9999, new2old = n2oGlobalPrivate);
ENDIFMACRO
    real eps = globalName.measure;
    real[int] epsTab(intersection[0].n);
    mpiRequest[int] rq(2 * intersection[0].n);
    if(mpiSize(comm) == size) {
        for(int j = 0; j < intersection[0].n; ++j)
            Irecv(processor(intersection[0][j], comm, rq[j]), epsTab[j]);
        for(int j = 0; j < intersection[0].n; ++j)
            Isend(processor(intersection[0][j], comm, rq[intersection[0].n + j]), eps);
    }
    else
        epsTab = 1.0e+30;
    suppSmooth = suppSmooth;
IFMACRO(!privateDmesh#N2O)
    meshName[level - 1] = trunc(globalName, suppSmooth > 0.501, label = fakeInterface, new2old = n2oNeighbor);
IFMACRO(privateDmesh#CartesianPartitioning)
    real[int] bb(2 * dimension);
    boundingbox(meshName[level - 1], bb);
    meshName[level - 1] = trunc(globalName, x > bb[0] && x < bb[1] && y > bb[2] && y < bb[3]
IFMACRO(dimension,3)
                                                                                             && z > bb[4] && z < bb[5]
ENDIFMACRO
                                                                                                                      , label = fakeInterface);
    globalName = meshName[level - 1];
    n2oNeighbor = 0:globalName.nt - 1;
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateDmesh#N2O)
    meshName[level - 1] = trunc(globalName, suppSmooth > 0.501, label = fakeInterface, new2old = privateDmesh#N2O);
IFMACRO(privateDmesh#CartesianPartitioning)
    real[int] bb(2 * dimension);
    boundingbox(meshName[level - 1], bb);
    meshName[level - 1] = trunc(globalName, x > bb[0] && x < bb[1] && y > bb[2] && y < bb[3]
IFMACRO(dimension,3)
                                                                                             && z > bb[4] && z < bb[5]
ENDIFMACRO
                                                                                                                      , label = fakeInterface, new2old = privateDmesh#N2O);
    globalName = meshName[level - 1];
    n2oNeighbor = 0:globalName.nt - 1;
ENDIFMACRO
IFMACRO(!privateDmesh#CartesianPartitioning)
    {
        int[int] backup = privateDmesh#N2O;
        int[int] new = n2oGlobalPrivate(privateDmesh#N2O);
        privateDmesh#N2O.resize(new.n);
        privateDmesh#N2O = new;
        n2oNeighbor.resize(backup.n);
        n2oNeighbor = backup;
    }
ENDIFMACRO
ENDIFMACRO
    if(level > 1) {
        prolongation.resize(level - 1);
        if(s > 1) {
            meshN globalNameRefined = globalName;
            for(int i = level - 1; i > 0; --i) {
                globalNameRefined = trunc(globalNameRefined, 1, split = s);
                meshName[i - 1] = trunc(globalNameRefined, suppSmooth > 0.501, label = fakeInterface);
                fespace WhLocalRefinedPrivate(meshName[i - 1], P);
                fespace WhLocalCoarsePrivate(meshName[i], P);
                prolongation[i - 1] = interpolate(WhLocalRefinedPrivate, WhLocalCoarsePrivate);
            }
        }
        else
            for(int i = level - 1; i > 0; --i)
                meshName[i - 1] = meshName[i];
    }
    if(!removeZeros && (fakeInterface != -111111 || overlap != 1)) {
        if(suppSmooth[].min < 0.501) {
            supp = supp;
            borderName[level - 1] = trunc(globalName, (suppSmooth > (overlap - 0.999) / real(2 * overlap)) && (suppSmooth < 0.501), label = (abs(fakeInterface) + 1) * 100);
            if(s > 1)
                for(int i = level - 2; i >= 0; --i) {
                    borderName[i] = trunc(borderName[i + 1], 1, split = s, label = (abs(fakeInterface) + 1) * 100);
                    meshN tempRefined = meshName[i] + borderName[i];
                    fespace PhRefinedPrivate(tempRefined, P0);
                    PhRefinedPrivate suppRefined = supp;
                    fespace VhBorderRefinedPrivate(borderName[i], P1);
                    VhBorderRefinedPrivate suppBorder = suppRefined;
                    borderName[i] = trunc(borderName[i], suppBorder > 0.01);
                }
            else
                for(int i = level - 2; i >= 0; --i)
                    borderName[i] = borderName[i + 1];
        }
    }
    fespace VhLocalPrivate(meshName[level - 1], P1);
IFMACRO(!privateDmesh#meshName)
NewMacro privateDmesh#meshName#intersectionDef()partitionIntersectionTab EndMacro
    real[int][int] partitionIntersectionTab(1 + intersection[0].n);
    privateDmesh#meshName#intersectionDef[0].resize(intersection[0].n);
ENDIFMACRO
IFMACRO(privateBuildDmesh)
    privateDmesh#meshName#intersectionDef.resize(1 + intersection[0].n);
    privateDmesh#meshName#intersectionDef[0].resize(intersection[0].n);
ENDIFMACRO
    VhLocalPrivate khi = max(2 * suppSmooth - 1.0, 0.0);
    VhLocalPrivate sum;
    sum[] = khi[];
    VhGlobalPrivate phi;
    if(n2oGlobalPrivate.n == globalName.nt && s == 1) {
        real[int] restrictionPart(n2oGlobalPrivate.n);
        restrictionPart = part[](n2oGlobalPrivate);
        part = 0.0;
        part[] = restrictionPart;
    }
    else
        part = part;
    n2oGlobalPrivate.resize(0);
    int numberIntersection = 0;
    {
        int[int] restriction = restrict(VhLocalPrivate, VhGlobalPrivate, n2oNeighbor);
        n2oNeighbor.resize(0);
        mpiWaitAll(rq);
        for(int i = 0; i < intersection[0].n; ++i) {
            PhGlobalPrivate suppPartition = abs(part - intersection[0][i]) < 0.1;
            AddLayers(globalName, suppPartition[], overlap, phi[]);
            if(min(eps, epsTab[i]) > 0.0) {
                if(intN(globalName, qforder = 2)(phi) / min(eps, epsTab[i]) > 1.0e-10) {
                    privateDmesh#meshName#intersectionDef[1 + numberIntersection].resize(restriction.n);
                    privateDmesh#meshName#intersectionDef[1 + numberIntersection] = phi[](restriction);
                    if(!trueRestrict)
                        sum[] += privateDmesh#meshName#intersectionDef[1 + numberIntersection];
                    intersection[0][numberIntersection++] = intersection[0][i];
                }
            }
        }
    }
    if(numberIntersection != intersection[0].n) {
        intersection[0].resize(numberIntersection);
        privateDmesh#meshName#intersectionDef.resize(1 + numberIntersection);
    }
    intersection.resize(1 + level * numberIntersection);
ENDIFMACRO
IFMACRO(privateCreateMat)
    assert(level == 1);
    int numberIntersection = privateDmesh#meshName#intersectionDef.n - 1;
    intersection.resize(1 + level * numberIntersection);
    intersection[0].resize(numberIntersection);
    intersection[0] = lround(privateDmesh#meshName#intersectionDef[0]);
    fespace VhLocalPrivate(meshName[level - 1], P1);
IFMACRO(privateDmesh#N2O)
IFMACRO(privateDmesh#Original)
IFMACRO(privateDmesh#Restriction)
    {
        fespace WhLocalPrivate(meshName[level - 1], P);
        fespace WhOriginalPrivate(privateDmesh#Original, P);
        privateDmesh#Restriction.resize(WhOriginalPrivate.ndof);
        privateDmesh#Restriction = restrict(WhLocalPrivate, WhOriginalPrivate, privateDmesh#N2O);
    }
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateBuildDmesh)
    privateDmesh#meshName#intersectionDef[0].resize(numberIntersection);
    for[i, value : intersection[0]] privateDmesh#meshName#intersectionDef[0][i] = value;
ENDIFMACRO
    meshN[int] meshIntersection(numberIntersection);
IFMACRO(!privateCreateMat)
    int[int][int] n2oIntersection(0);
    if(trueRestrict && mpiSize(comm) == size && removeZeros)
        n2oIntersection.resize(numberIntersection);
ENDIFMACRO
    for(int j = 0; j < (s == 1 ? 1 : level); ++j) {
        for(int i = 0; i < numberIntersection; ++i) {
            int[int] n2o;
            VhLocalPrivate partitionIntersection;
            partitionIntersection[] = privateDmesh#meshName#intersectionDef[1 + i];
            meshIntersection[i] = trunc(meshName[j], partitionIntersection > 1.0e-6, new2old = n2o, label = 9999);
IFMACRO(privateDmesh#CartesianPartitioning)
            real[int] bb(2 * dimension);
            boundingbox(meshIntersection[i], bb);
            meshIntersection[i] = trunc(meshName[j], x > bb[0] && x < bb[1] && y > bb[2] && y < bb[3]
IFMACRO(dimension,3)
                                                                                                      && z > bb[4] && z < bb[5]
ENDIFMACRO
                                                                                                                               , new2old = n2o, label = 9999);
ENDIFMACRO
IFMACRO(!privateCreateMat)
            if(j == 0 && trueRestrict && mpiSize(comm) == size && removeZeros) {
                n2oIntersection[i].resize(n2o.n);
                n2oIntersection[i] = n2o;
            }
            if(!removeZeros)
ENDIFMACRO
            {
IFMACRO(vectorialfe)
                fespace singleComponentWhPrivate(meshName[j], vectorialfe);
                fespace WhIntersectionPrivate(meshIntersection[i], vectorialfe);
ENDIFMACRO
IFMACRO(!vectorialfe)
                fespace singleComponentWhPrivate(meshName[j], P);
                fespace WhIntersectionPrivate(meshIntersection[i], P);
ENDIFMACRO
                intersection[1 + i + j * numberIntersection] = restrict(WhIntersectionPrivate, singleComponentWhPrivate, n2o);
            }
        }
    }
IFMACRO(!privateCreateMat)
    if(s == 1 && level > 1 && !removeZeros)
        for(int j = 1; j < level; ++j)
            for(int i = 0; i < numberIntersection; ++i) {
                intersection[1 + i + j * numberIntersection].resize(intersection[1 + i].n);
                intersection[1 + i + j * numberIntersection] = intersection[1 + i];
            }
    for(int i = 0; i < level - 1; ++i) {
        fespace VhRefinedPrivate(meshName[i], P1);
        fespace PhRefinedPrivate(meshName[i], P0);
        PhRefinedPrivate partRefined = part;
        PhRefinedPrivate supp = abs(partRefined - rank) < 0.1;
        varf vSupp(uPrivate, vPrivate) = intN(meshName[i], qforder = 1)(supp * vPrivate);
        VhRefinedPrivate khiL;
        khiL[] = vSupp(0, VhRefinedPrivate);
        khiL = khiL > 0.0;
        VhRefinedPrivate sum = khiL;
        for(int j = 0; j < numberIntersection; ++j) {
            supp = abs(partRefined - intersection[0][j]) < 0.1;
            VhRefinedPrivate phiL;
            phiL[] = vSupp(0, VhRefinedPrivate);
            phiL = phiL > 0.0;
            sum[] += phiL[];
        }
        khiL[] ./= sum[];
        fespace WhRefinedPrivate(meshName[i], PkPart);
        WhRefinedPrivate defPart(func2vec);
        defPart(func2vec) = initPart(khiL);
        D[i].resize(WhRefinedPrivate.ndof);
        D[i] = func2vec[];
    }
    if(!trueRestrict)
        khi[] ./= sum[];
    else {
        khi = abs(part - rank) < 0.1;
        VhLocalPrivate sigma = part;
        for(int i = 0; i < numberIntersection; ++i) {
            if(rank < intersection[0][i]) {
                for[j, value : khi[]] {
                    if(value > 0.9 && abs(sigma[][j] - intersection[0][i]) < 0.1)
                        value = 0.0;
                }
            }
        }
    }
    if(trueRestrict && mpiSize(comm) == size && removeZeros) {
        assert(level == 1);
        meshN ThIntersection;
        mpiRequest[int] rq(2 * numberIntersection);
        int[int] skip(0);
        {
            fespace PhIntersectionPrivate(ThIntersection, P0);
            PhIntersectionPrivate[int] recv(numberIntersection);
            PhIntersectionPrivate[int] send(numberIntersection);
            for(int i = 0; i < numberIntersection; ++i) {
                ThIntersection = meshIntersection[i];
                Irecv(processor(intersection[0][i], comm, rq[i]), recv[i][]);
                send[i] = khi;
                Isend(processor(intersection[0][i], comm, rq[numberIntersection + i]), send[i][]);
            }
            real[int] tmpRemove(meshName[0].nt);
            int[int] n2oRemove;
IFMACRO(!privateDmesh#N2O)
            meshName[0] = trunc(meshName[0], khi > 1.0e-6, label = 9999, new2old = n2oRemove);
ENDIFMACRO
IFMACRO(privateDmesh#N2O)
            {
                int[int] n2oFilter;
                meshName[0] = trunc(meshName[0], khi > 1.0e-6, label = 9999, new2old = n2oRemove);
                n2oFilter.resize(n2oRemove.n);
                n2oFilter = privateDmesh#N2O(n2oRemove);
                privateDmesh#N2O.resize(n2oFilter.n);
                privateDmesh#N2O = n2oFilter;
            }
ENDIFMACRO
            khi = khi;
            fespace PhLocalPrivate(meshName[0], P0);
            for(int k = 0; k < 2 * numberIntersection; ++k) {
                int i = mpiWaitAny(rq);
                if(i < numberIntersection) {
                    ThIntersection = meshIntersection[i];
                    PhIntersectionPrivate intersection = send[i] > 1.0e-6 && recv[i] > 1.0e-6;
                    if(intersection[].l2 > 1.0e-6) {
                        tmpRemove = 0.0;
                        tmpRemove(n2oIntersection[i]) = intersection[];
                        PhLocalPrivate afterTrunc;
                        afterTrunc[] = tmpRemove(n2oRemove);
                        meshIntersection[i] = trunc(meshName[0], afterTrunc > 1.0e-6, label = 9999, new2old = n2oIntersection[i]);
                    }
                    else {
                        skip.resize(skip.n + 1);
                        skip[skip.n - 1] = i;
                    }
                }
            }
        }
        skip.sort;
        real[int][int] recv(numberIntersection);
        real[int][int] send(numberIntersection);
        int j = 0;
        for(int i = 0; i < numberIntersection; ++i) {
            bool skipped = false;
            if(j < skip.n) {
                if(skip[j] == i) {
                    ++j;
                    skipped = true;
                }
            }
            if(!skipped) {
                recv[i].resize(meshIntersection[i].nv);
                Irecv(processor(intersection[0][i], comm, rq[i]), recv[i]);
                fespace VhIntersectionPrivate(meshIntersection[i], P1);
                int[int] restriction = restrict(VhIntersectionPrivate, VhLocalPrivate, n2oIntersection[i]);
                send[i].resize(meshIntersection[i].nv);
                send[i] = khi[](restriction);
                Isend(processor(intersection[0][i], comm, rq[numberIntersection + i]), send[i]);
            }
        }
        mpiWaitAll(rq);
        intersection.resize(1 + numberIntersection - skip.n);
        j = 0;
        for(int i = 0; i < numberIntersection; ++i) {
            bool skipped = false;
            if(j < skip.n) {
                if(skip[j] == i) {
                    ++j;
                    skipped = true;
                }
            }
            if(!skipped) {
IFMACRO(vectorialfe)
                fespace singleComponentWhPrivate(meshName[0], vectorialfe);
                fespace WhIntersectionPrivate(meshIntersection[i], vectorialfe);
ENDIFMACRO
IFMACRO(!vectorialfe)
                fespace singleComponentWhPrivate(meshName[0], P);
                fespace WhIntersectionPrivate(meshIntersection[i], P);
ENDIFMACRO
                intersection[1 + i - j] = restrict(WhIntersectionPrivate, singleComponentWhPrivate, n2oIntersection[i]);
                fespace VhIntersectionPrivate(meshIntersection[i], P1);
                int[int] restriction = restrict(VhIntersectionPrivate, VhLocalPrivate, n2oIntersection[i]);
                privateDmesh#meshName#intersectionDef[1 + i - j].resize(VhLocalPrivate.ndof);
                privateDmesh#meshName#intersectionDef[1 + i - j] = 0.0;
                privateDmesh#meshName#intersectionDef[1 + i - j](restriction) = recv[i];
                intersection[0][i - j] = intersection[0][i];
            }
        }
        numberIntersection -= skip.n;
        intersection[0].resize(numberIntersection);
        privateDmesh#meshName#intersectionDef.resize(1 + numberIntersection);
        privateDmesh#meshName#intersectionDef[0].resize(numberIntersection);
        for[i, value : intersection[0]] privateDmesh#meshName#intersectionDef[0][i] = value;
        if(fakeInterface != -111111 || overlap != 1) {
            PhGlobalPrivate suppPartition = khi > 0.1;
            AddLayers(globalName, suppPartition[], 1, phi[]);
            borderName[0] = trunc(globalName, phi > 0.001 && phi < 0.501, label = (abs(fakeInterface) + 1) * 100);
        }
    }
ENDIFMACRO
IFMACRO(vectorialfe)
    if(bs > 1)
        for(int i = 0; i < intersection.n - 1; ++i) {
            int n = intersection[1 + i].n;
            intersection[1 + i].resize(n * bs);
            for(int j = n - 1; j != -1; --j)
                for(int k = bs - 1; k != -1; --k)
                    intersection[1 + i][j * bs + k] = intersection[1 + i][j] * bs + k;
        }
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateCreatePartition)
    fespace VhLocalPrivate(meshName[level - 1], P1);
IFMACRO(!privateCreateMat)
    VhLocalPrivate khi;
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateCreateMat)
    VhLocalPrivate khi;
    khi[] = privateDmesh#meshName#khiDef[0];
ENDIFMACRO
    fespace WhPartPrivate(meshName[level - 1], PkPart);
    WhPartPrivate defPart(func2vec);
    D[level - 1].resize(WhPartPrivate.ndof);
    if((WhPartPrivate.ndof % meshName[level - 1].nt) == 0 && WhPartPrivate.ndof != meshName[level - 1].nv) {
        int constant = rank;
IFMACRO(privateCreateMat)
        fespace PhLocalPrivate(meshName[level - 1], P0);
        PhLocalPrivate partLocal;
        partLocal[] = privateDmesh#meshName#khiDef[1];
        defPart(func2vec) = initPart(abs(partLocal - constant) < 0.1);
ENDIFMACRO
IFMACRO(!privateCreateMat)
        defPart(func2vec) = initPart(abs(part - constant) < 0.1);
ENDIFMACRO
    }
    else if(WhPartPrivate.ndof == meshName[level - 1].nv && (WhPartPrivate.ndof % meshName[level - 1].nt) != 0)
        func2vec[] = khi[];
    else
        defPart(func2vec) = initPart(khi);
    D[level - 1] = func2vec[];
IFMACRO(privateDmesh#PostProcessD)
    privateDmesh#PostProcessD(D[level - 1]);
ENDIFMACRO
IFMACRO(!privateCreatePartition)
IFMACRO(!privateCreateMat)
IFMACRO(privateBuildDmesh)
    fespace PhLocalPrivate(meshName[level - 1], P0);
    PhLocalPrivate partLocal;
    partLocal = part;
    privateDmesh#meshName#khiDef[1].resize(partLocal[].n);
    privateDmesh#meshName#khiDef[1] = partLocal[];
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
    searchMethod = backupSM;
}// EOM

macro saveDmesh(ThName, name)
IFMACRO(privateDmesh#ThName)
{
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(dimension,3)
savemesh(ThName, name + "_" + mpiRank(ThName#Comm) + "_" + mpiSize(ThName#Comm) + ".meshb");
ENDIFMACRO
IFMACRO(dimension,2)
savemesh(ThName, name + "_" + mpiRank(ThName#Comm) + "_" + mpiSize(ThName#Comm) + ".msh");
ENDIFMACRO
ofstream khi(name + "_" + mpiRank(ThName#Comm) + "_" + mpiSize(ThName#Comm) + ".khi");
khi << privateDmesh#ThName#khi << endl;
khi << privateDmesh#ThName#intersection << endl;
IFMACRO(ThName#N2O)
khi << ThName#N2O << endl;
ENDIFMACRO
}
ENDIFMACRO
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
EndMacro

macro loadDmesh(ThName, name)
IFMACRO(!privateDmesh#ThName)
NewMacro privateDmesh#ThName()privateDmesh#ThName EndMacro
NewMacro privateDmesh#ThName#khi()privateDmesh#ThName#khiDef EndMacro
NewMacro privateDmesh#ThName#intersection()privateDmesh#ThName#intersectionDef EndMacro
real[int][int] privateDmesh#ThName#khi(2);
real[int][int] privateDmesh#ThName#intersection;
ENDIFMACRO
{
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(dimension,3)
ThName = readmesh3(name + "_" + mpiRank(ThName#Comm) + "_" + mpiSize(ThName#Comm) + ".meshb");
ENDIFMACRO
IFMACRO(dimension,2)
ThName = readmesh(name + "_" + mpiRank(ThName#Comm) + "_" + mpiSize(ThName#Comm) + ".msh");
ENDIFMACRO
privateDmesh#ThName#khi.resize(2);
privateDmesh#ThName#khi[0].resize(ThName.nv);
privateDmesh#ThName#khi[1].resize(ThName.nt);
if(mpiSize(ThName#Comm) > 1) {
    ifstream khi(name + "_" + mpiRank(ThName#Comm) + "_" + mpiSize(ThName#Comm) + ".khi");
    int m;
    khi >> m;
    assert(m == 2);
    khi >> privateDmesh#ThName#khi[0];
    khi >> privateDmesh#ThName#khi[1];
    khi >> m;
    privateDmesh#ThName#intersection.resize(m);
    for(int j = 0; j < m; ++j) {
        int n;
        khi >> n;
        privateDmesh#ThName#intersection[j].resize(n);
        for[i, value : privateDmesh#ThName#intersection[j]]
            khi >> value;
    }
IFMACRO(ThName#N2O)
    ThName#N2O.resize(ThName.nt);
    khi >> ThName#N2O;
ENDIFMACRO
}
else {
    privateDmesh#ThName#khi[0] = 1.0;
    privateDmesh#ThName#khi[1] = 1.0;
IFMACRO(ThName#N2O)
    ThName#N2O.resize(ThName.nt);
    ThName#N2O = 0:ThName.nt - 1;
ENDIFMACRO
}
}
EndMacro

macro buildDmesh(ThName)
IFMACRO(!privateDmesh#ThName)
NewMacro privateDmesh#ThName()privateDmesh#ThName EndMacro
NewMacro privateDmesh#ThName#khi()privateDmesh#ThName#khiDef EndMacro
NewMacro privateDmesh#ThName#intersection()privateDmesh#ThName#intersectionDef EndMacro
real[int][int] privateDmesh#ThName#khi(2);
real[int][int] privateDmesh#ThName#intersection;
ENDIFMACRO
{
IFMACRO(!meshN)
IFMACRO(dimension,3)
NewMacro meshN()mesh3 EndMacro     /* three-dimensional problem             */
NewMacro intN()int3d EndMacro      /* three-dimensional integral            */
ENDIFMACRO
IFMACRO(dimension,3S)
NewMacro meshN()meshS EndMacro     /* three-dimensional surface problem     */
NewMacro intN()int2d EndMacro      /* two-dimensional integral              */
ENDIFMACRO
IFMACRO(dimension,3L)
NewMacro meshN()meshL EndMacro     /* three-dimensional line problem        */
NewMacro intN()int1d EndMacro      /* one-dimensional integral              */
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro      /* two-dimensional problem               */
NewMacro intN()int2d EndMacro      /* two-dimensional integral              */
ENDIFMACRO
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
NewMacro privateBuildDmesh()1 EndMacro
int[int][int] intersection;
NewMacro privateDmesh#ThTab()privateDmesh#ThName EndMacro
NewMacro privateDmesh#ThTab#khi()privateDmesh#ThName#khiDef EndMacro
NewMacro privateDmesh#ThTab#intersection()privateDmesh#ThName#intersectionDef EndMacro
IFMACRO(ThName#N2O)
NewMacro privateDmesh#N2O()ThName#N2O EndMacro
IFMACRO(ThName#RefinementFactor)
exit(10); /* not currently implemented */
ENDIFMACRO
ENDIFMACRO
IFMACRO(ThName#UserPartitioning)
IFMACRO(ThName#RefinementFactor)
exit(11); /* not currently implemented */
ENDIFMACRO
buildWithPartitioning(ThName, ThName#UserPartitioning, 1, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm);
ENDIFMACRO
IFMACRO(ThName#Periodicity)
IFMACRO(ThName#RefinementFactor)
exit(12); /* not currently implemented */
ENDIFMACRO
IFMACRO(ThName#Overlap)
assert(ThName#Overlap > 0);
meshN privateBorder;
int privateS = 1;
buildOverlapPeriodic(ThName, privateBorder, -111111, privateS, ThName#Overlap, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm, false, ThName#Periodicity)
ENDIFMACRO
IFMACRO(!ThName#Overlap)
buildPeriodic(ThName, 1, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm, ThName#Periodicity);
ENDIFMACRO
ENDIFMACRO
IFMACRO(!ThName#UserPartitioning)
IFMACRO(!ThName#Periodicity)
IFMACRO(ThName#CartesianPartitioning)
IFMACRO(!dimension)
NewMacro dimension()2 EndMacro
ENDIFMACRO
NewMacro privateDmesh#CartesianPartitioning() EndMacro
IFMACRO(ThName#RefinementFactor)
exit(13); /* not currently implemented */
ENDIFMACRO
IFMACRO(removeZeros,true)
exit(103); /* not currently implemented */
ENDIFMACRO
IFMACRO(trueRestrict,true)
exit(103); /* not currently implemented */
ENDIFMACRO
ENDIFMACRO
IFMACRO(!ThName#RefinementFactor)
int privateS = 1;
ENDIFMACRO
IFMACRO(ThName#RefinementFactor)
int privateS = ThName#RefinementFactor;
ENDIFMACRO
IFMACRO(ThName#Overlap)
assert(ThName#Overlap > 0);
meshN privateBorder;
buildOverlap(ThName, privateBorder, -111111, privateS, ThName#Overlap, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm, false);
ENDIFMACRO
IFMACRO(!ThName#Overlap)
build(ThName, privateS, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm);
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
}
EndMacro

macro reconstructDmesh(ThName)
IFMACRO(!privateDmesh#ThName)
NewMacro privateDmesh#ThName()privateDmesh#ThName EndMacro
NewMacro privateDmesh#ThName#khi()privateDmesh#ThName#khiDef EndMacro
NewMacro privateDmesh#ThName#intersection()privateDmesh#ThName#intersectionDef EndMacro
real[int][int] privateDmesh#ThName#khi(2);
real[int][int] privateDmesh#ThName#intersection;
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
if(ThName#Comm) {
IFMACRO(!dimension)
    NewMacro dimension()2 EndMacro
ENDIFMACRO
IFMACRO(!meshN)
    NewMacro meshN()mesh EndMacro
    NewMacro intN()int2d EndMacro
ENDIFMACRO
    int[int] neighbors;
    {
        real[int] bb(2 * dimension);
        boundingbox(ThName, bb);
        real[int] bbAll(2 * dimension * mpiSize(ThName#Comm));
        mpiAllgather(bb, bbAll, ThName#Comm);
        real hmax;
        {
            real tmp = ThName.hmax;
            mpiAllReduce(tmp, hmax, ThName#Comm, mpiMAX);
        }
        int between = 0;
        int size = mpiSize(ThName#Comm);
        int rank = mpiRank(ThName#Comm);
        for(int i = 0; i < size; ++i) {
            if(i != rank &&
IFMACRO(dimension,2)
            !(bbAll[1 + 4 * i] < bb[0] - hmax
              || bbAll[0 + 4 * i] > bb[1] + hmax
              || bbAll[3 + 4 * i] < bb[2] - hmax
              || bbAll[2 + 4 * i] > bb[3] + hmax)
ENDIFMACRO
IFMACRO(dimension,3)
            !(bbAll[1 + 6 * i] < bb[0] - hmax
              || bbAll[0 + 6 * i] > bb[1] + hmax
              || bbAll[3 + 6 * i] < bb[2] - hmax
              || bbAll[2 + 6 * i] > bb[3] + hmax
              || bbAll[5 + 6 * i] < bb[4] - hmax
              || bbAll[4 + 6 * i] > bb[5] + hmax)
ENDIFMACRO
                                                 ) {
                neighbors.resize(neighbors.n + 1);
                neighbors[neighbors.n - 1] = i;
            }
        }
    }
    reconstructDmeshWithNeighbors(ThName, neighbors)
}
EndMacro
macro reconstructDmeshWithNeighbors(ThName, neighborsName)
IFMACRO(!privateDmesh#ThName)
NewMacro privateDmesh#ThName()privateDmesh#ThName EndMacro
NewMacro privateDmesh#ThName#khi()privateDmesh#ThName#khiDef EndMacro
NewMacro privateDmesh#ThName#intersection()privateDmesh#ThName#intersectionDef EndMacro
real[int][int] privateDmesh#ThName#khi(2);
real[int][int] privateDmesh#ThName#intersection;
ENDIFMACRO
{
IFMACRO(!ThName#Comm)
    NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
    real[int] part;
    {
        if(verbosity > 0)
            mpiBarrier(ThName#Comm);
        real timerReconstruction = mpiWtime();
        varf vG(uPrivate, vPrivate) = on(labels(ThName), uPrivate = 1.0);
        fespace VhGammaPrivate(ThName, P1);
        VhGammaPrivate gamma;
        gamma[] = vG(0, VhGammaPrivate, tgv = -1);
        meshN[int] ThTab(neighborsName.n + 2);
        neighborsName.sort;
        int between = 0;
        int rank = mpiRank(ThName#Comm);
        for(int i = 0; i < neighborsName.n; ++i)
            if(neighborsName[i] > rank) {
                between = i;
                break;
            }
        if(neighborsName.n)
            if(neighborsName[neighborsName.n - 1] < rank)
                between = neighborsName.n;
        mpiRequest[int] rqRecv(neighborsName.n);
        for[i, value : neighborsName]
            Irecv(processor(value, ThName#Comm, rqRecv[i]), ThTab[i + (i >= between)]);
IFMACRO(!ThName#Overlap)
        ThTab[between] = trunc(ThName, gamma > 0.01, label = -111112);
ENDIFMACRO
IFMACRO(ThName#Overlap)
        ThTab[between] = ThName;
ENDIFMACRO
        mpiRequest[int] rqSend(neighborsName.n);
        for[i, value : neighborsName]
IFMACRO(!ThName#Overlap)
            Isend(processor(value, ThName#Comm, rqSend[i]), ThTab[between]);
ENDIFMACRO
IFMACRO(ThName#Overlap)
            Isend(processor(value, ThName#Comm, rqSend[i]), ThName);
ENDIFMACRO
IFMACRO(!ThName#Overlap)
        ThTab[neighborsName.n + 1] = trunc(ThName, gamma < 0.01, label = -111112);
ENDIFMACRO
        mpiWaitAll(rqRecv);
IFMACRO(dimension,3)
        ThName = gluemesh(ThTab);
        ThName = change(ThName, rmlfaces = -111112);
ENDIFMACRO
IFMACRO(dimension,2)
        ThName = gluemesh(ThTab, labtodel = -111112);
ENDIFMACRO
        part.resize(ThName.nt);
        int m = 0;
        for(int i = 0; i < between; ++i) {
            part(m:m + ThTab[i].nt - 1) = neighborsName[i];
            m += ThTab[i].nt;
        }
        part(m:m + ThTab[between].nt - 1) = rank;
        m += ThTab[between].nt;
        for(int i = between; i < neighborsName.n; ++i) {
            part(m:m + ThTab[i + 1].nt - 1) = neighborsName[i];
            m += ThTab[i + 1].nt;
        }
        if(m != ThName.nt)
            part(m:ThName.nt - 1) = rank;
        mpiWaitAll(rqSend);
        if(verbosity > 0) {
            mpiBarrier(ThName#Comm);
            if(mpiRank(ThName#Comm) == 0)
                cout.scientific << " --- distributed mesh reconstructed (in " << mpiWtime() - timerReconstruction << ")" << endl;
        }
    }
    NewMacro privateBuildDmesh()1 EndMacro
    NewMacro privateReconstructDmesh()1 EndMacro
    int[int][int] intersection;
    NewMacro privateDmesh#ThTab()privateDmesh#ThName EndMacro
    NewMacro privateDmesh#ThTab#khi()privateDmesh#ThName#khiDef EndMacro
    NewMacro privateDmesh#ThTab#intersection()privateDmesh#ThName#intersectionDef EndMacro
IFMACRO(ThName#N2O)
    NewMacro privateDmesh#N2O()ThName#N2O EndMacro
ENDIFMACRO
IFMACRO(ThName#Overlap)
    meshN ThBorder;
    buildOverlapWithPartitioning(ThName, ThBorder, part, -111111, 1, ThName#Overlap, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm, false);
ENDIFMACRO
IFMACRO(!ThName#Overlap)
    buildWithPartitioning(ThName, part, 1, intersection, privateDmesh#ThName#khi[0], P1, ThName#Comm);
ENDIFMACRO
}
EndMacro
macro initializeDmesh(NewName)
IFMACRO(!privateDmesh#NewName)
NewMacro privateDmesh#NewName()privateDmesh#NewName EndMacro
NewMacro privateDmesh#NewName#khi()privateDmesh#NewName#khiDef EndMacro
NewMacro privateDmesh#NewName#intersection()privateDmesh#NewName#intersectionDef EndMacro
real[int][int] privateDmesh#NewName#khi(2);
real[int][int] privateDmesh#NewName#intersection;
ENDIFMACRO
EndMacro
macro copyDmesh(OldName, NewName)
DmeshInitialize(NewName)
IFMACRO(privateDmesh#OldName)
NewName = OldName;
privateDmesh#NewName#khi[0].resize(privateDmesh#OldName#khi[0].n);
privateDmesh#NewName#khi[0] = privateDmesh#OldName#khi[0];
privateDmesh#NewName#khi[1].resize(privateDmesh#OldName#khi[1].n);
privateDmesh#NewName#khi[1] = privateDmesh#OldName#khi[1];
privateDmesh#NewName#intersection.resize(privateDmesh#OldName#intersection.n);
for(int i = 0; i < privateDmesh#NewName#intersection.n; ++i) {
    privateDmesh#NewName#intersection[i].resize(privateDmesh#OldName#intersection[i].n);
    privateDmesh#NewName#intersection[i] = privateDmesh#OldName#intersection[i];
}
ENDIFMACRO
EndMacro
macro createMat(ThName, MatName, PkName)
IFMACRO(privateDmesh#ThName)
{
IFMACRO(!meshN)
IFMACRO(dimension,3)
NewMacro meshN()mesh3 EndMacro     /* three-dimensional problem             */
NewMacro intN()int3d EndMacro      /* three-dimensional integral            */
ENDIFMACRO
IFMACRO(dimension,3S)
NewMacro meshN()meshS EndMacro     /* three-dimensional surface problem     */
NewMacro intN()int2d EndMacro      /* two-dimensional integral              */
ENDIFMACRO
IFMACRO(dimension,3L)
NewMacro meshN()meshL EndMacro     /* three-dimensional line problem        */
NewMacro intN()int1d EndMacro      /* one-dimensional integral              */
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro      /* two-dimensional problem               */
NewMacro intN()int2d EndMacro      /* two-dimensional integral              */
ENDIFMACRO
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!privateCreateMatCheckDmesh)
if(ThName.nv != privateDmesh#ThName#khi[0].n || (privateDmesh#ThName#khi[1].n && ThName.nt != privateDmesh#ThName#khi[1].n)) {
    DmeshCreate(ThName)
}
ENDIFMACRO
NewMacro privateCreateMat()1 EndMacro
int[int][int] intersection;
real[int][int] DTab(1);
meshN[int] ThTab(1);
ThTab[0] = ThName;
NewMacro privateDmesh#ThTab()privateDmesh#ThName EndMacro
NewMacro privateDmesh#ThTab#khi()privateDmesh#ThName#khiDef EndMacro
NewMacro privateDmesh#ThTab#intersection()privateDmesh#ThName#intersectionDef EndMacro
IFMACRO(!def)
NewMacro def(i)i EndMacro
ENDIFMACRO
IFMACRO(!init)
NewMacro init(i)i EndMacro
ENDIFMACRO
if(mpiSize(ThName#Comm) > 1) {
IFMACRO(ThName#N2O)
IFMACRO(ThName#Original)
IFMACRO(ThName#Restriction)
    NewMacro privateDmesh#N2O()ThName#N2O EndMacro
    NewMacro privateDmesh#Original()ThName#Original EndMacro
    NewMacro privateDmesh#Restriction()ThName#Restriction EndMacro
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
IFMACRO(!ThName#PkPart)
    NewMacro ThName#PkPart()PkName EndMacro
ENDIFMACRO
IFMACRO(ThName#CartesianPartitioning)
    NewMacro privateDmesh#CartesianPartitioning() EndMacro
IFMACRO(!dimension)
    NewMacro dimension()2 EndMacro
ENDIFMACRO
ENDIFMACRO
IFMACRO(ThName#PostProcessD)
    NewMacro privateDmesh#PostProcessD(arg)ThName#PostProcessD(arg) EndMacro
IFMACRO(removeZeros,true)
    exit(105); /* not currently implemented */
ENDIFMACRO
IFMACRO(trueRestrict,true)
    exit(105); /* not currently implemented */
ENDIFMACRO
ENDIFMACRO
    partitionPrivate(ThTab, privateCreateMat, privateCreateMat, privateCreateMat, privateCreateMat, privateCreateMat, mpiRank(ThName#Comm), mpiSize(ThName#Comm), 1, 1, 1, privateCreateMat, DTab, PkName, intersection, ThName#Comm, -111111, ThName#PkPart, def, init, 1)
}
else {
    fespace WhGlobalPrivate(ThName, PkName);
    DTab[0].resize(WhGlobalPrivate.ndof);
    DTab[0] = 1;
    intersection.resize(0);
IFMACRO(ThName#N2O)
IFMACRO(ThName#Original)
IFMACRO(ThName#Restriction)
    ThName#Restriction.resize(WhGlobalPrivate.ndof);
    ThName#Restriction = 0:WhGlobalPrivate.ndof - 1;
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
}
IFMACRO(!privateCreatePartition)
constructor(MatName, DTab[0].n, intersection, DTab[0], communicator = ThName#Comm);
ENDIFMACRO
IFMACRO(privateCreatePartition)
privateCreatePartition.resize(DTab[0].n);
privateCreatePartition = DTab[0];
ENDIFMACRO
}
ENDIFMACRO
IFMACRO(!privateDmesh#ThName)
DmeshCreate(ThName)
{
IFMACRO(!meshN)
IFMACRO(dimension,3)
    NewMacro meshN()mesh3 EndMacro     /* three-dimensional problem             */
    NewMacro intN()int3d EndMacro      /* three-dimensional integral            */
ENDIFMACRO
IFMACRO(dimension,3S)
    NewMacro meshN()meshS EndMacro     /* three-dimensional surface problem     */
    NewMacro intN()int2d EndMacro      /* two-dimensional integral              */
ENDIFMACRO
IFMACRO(dimension,3L)
    NewMacro meshN()meshL EndMacro     /* three-dimensional line problem        */
    NewMacro intN()int1d EndMacro      /* one-dimensional integral              */
ENDIFMACRO
IFMACRO(!meshN)
    NewMacro meshN()mesh EndMacro      /* two-dimensional problem               */
    NewMacro intN()int2d EndMacro      /* two-dimensional integral              */
ENDIFMACRO
ENDIFMACRO
    NewMacro privateCreateMatCheckDmesh()1 EndMacro
    MatCreate(ThName, MatName, PkName)
}
ENDIFMACRO
EndMacro

macro createPartition(ThName, PartName, PkName)
IFMACRO(!privateDmesh#ThName)
DmeshCreate(ThName)
ENDIFMACRO
{
    NewMacro privateCreateMatCheckDmesh()1 EndMacro
    NewMacro privateCreatePartition()PartName EndMacro
    MatCreate(ThName, privateCreatePartition, PkName)
}
EndMacro

macro buildOverlapEdgePeriodicRecursive(Th, ThBorder, fakeInterface, s, overlap, level, prolongation, intersection, DTab, P, comm, excluded, PkPart, defPart, initPart, labPeriodic, userPartitioning, bs) {
IFMACRO(!def)
    NewMacro def(i)i EndMacro
ENDIFMACRO
IFMACRO(!init)
    NewMacro init(i)i EndMacro
ENDIFMACRO
    Th.resize(level);
    ThBorder.resize(level);
    prolongation.resize(level - 1);
    real timerPartition = mpiWtime();
    if(mpiSize(comm) > 1 && !excluded) {
        meshN ThGlobal = Th[level - 1];
        fespace PhGlobalPrivate(ThGlobal, P0);
        fespace VhGlobalPrivate(ThGlobal, P1);
        PhGlobalPrivate partGlobal;
IFMACRO(!privateReconstructDmesh)
IFMACRO(privateDmesh#CartesianPartitioning)
        {
            real[int] bb(2 * dimension);
            boundingbox(ThGlobal, bb);
            PhGlobalPrivate xx = x / (bb[1] - bb[0]), yy = y / (bb[3] - bb[2])
IFMACRO(dimension,2)
                                                                              ;
            int i = int(sqrt(mpiSize(comm)));
            while(mpiSize(comm) % i != 0)
                --i;
            int j = mpiSize(comm) / i;
            partGlobal = int(j * xx) + int(i * yy) * j;
ENDIFMACRO
IFMACRO(dimension,3)
                                                                              , zz = z / (bb[5] - bb[4]);
            i = int(mpiSize(comm)^(0.333333333333333));
            while(mpiSize(comm) % i != 0)
                --i;
            real p = mpiSize(comm) / i;
            j = int(sqrt(p));
            while(p % j != 0)
                --j;
            real k = int(p / j);
            partGlobal = int(i * zz) * k * j + int(j * yy) * k + int(k * xx);
ENDIFMACRO
        }
ENDIFMACRO
IFMACRO(!privateDmesh#CartesianPartitioning)
        if(userPartitioning.n != PhGlobalPrivate.ndof || labPeriodic.n > 0) {
            timerPartition = mpiWtime();
            meshN ThGlobalPeriodic;
            if(labPeriodic.n > 0) {
                VhGlobalPrivate marker;
                for(int i = 0; i < labPeriodic.n; ++i) {
                    varf vMarker(uPrivate, vPrivate) = on(labPeriodic[i], uPrivate = 1.0);
                    marker[] += vMarker(0, VhGlobalPrivate, tgv = -1);
                }
                PhGlobalPrivate partPeriodic = marker > 0.1;
                while(1) {
                    AddLayers(ThGlobal, partPeriodic[], 1 + overlap, marker[]);
                    partPeriodic = marker > 0.001;
                    ThGlobalPeriodic = trunc(ThGlobal, partPeriodic < 0.999);
                    if(ThGlobal.nt / real(ThGlobalPeriodic.nt) > mpisize / real(mpisize - 1))
                        break;
                }
            }
            if(mpiRank(comm) == 0) {
                if(verbosity > 0)
                    cout.scientific << " --- global mesh of " << ThGlobal.nt << " elements (prior to refinement) partitioned with " << Stringification(partitioner);
                if(labPeriodic.n > 0) {
                    fespace PhPeriodicPrivate(ThGlobalPeriodic, P0);
                    PhPeriodicPrivate partPeriodic;
                    if(mpiSize(comm) > 2) {
                        partitionerSeq(partPeriodic[], ThGlobalPeriodic, mpiSize(comm) - 1);
                        partPeriodic[] += 1.0;
                    }
                    else
                        partPeriodic[] = 1.0;
                    partGlobal = partPeriodic;
                }
                else {
                    partitionerSeq(partGlobal[], ThGlobal, mpiSize(comm));
                }
            }
            if(labPeriodic.n > 0 && Stringification(partitioner) != "metis" && Stringification(partitioner) != "scotch") {
                fespace PhPeriodicPrivate(ThGlobalPeriodic, P0);
                PhPeriodicPrivate partPeriodic;
                if(mpiSize(comm) > 2) {
                    partitionerPar(partPeriodic[], ThGlobalPeriodic, comm, mpiSize(comm) - 1);
                    partPeriodic[] += 1.0;
                }
                else
                    partPeriodic[] = 1.0;
                partGlobal = partPeriodic;
            }
            else
                partitionerPar(partGlobal[], ThGlobal, comm, mpiSize(comm));
            if(mpiRank(comm) == 0 && verbosity > 0)
                cout.scientific << " (in " << mpiWtime() - timerPartition << ")" << endl;
            timerPartition = mpiWtime();
        }
        else {
            partGlobal[] = userPartitioning;
        }
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateReconstructDmesh)
        partGlobal[] = userPartitioning;
ENDIFMACRO
IFMACRO(!trueRestrict)
        bool trueRestrict = usedARGV("-true_restrict") != -1;
ENDIFMACRO
IFMACRO(!removeZeros)
        bool removeZeros = trueRestrict && overlap == 1 && usedARGV("-remove_zeros") != -1;
ENDIFMACRO
        if(verbosity > 0) {
            mpiBarrier(comm);
            timerPartition = mpiWtime();
        }
IFMACRO(privateBuildDmesh)
        NewMacro defP1(i)i EndMacro
        NewMacro initP1(i)i EndMacro
        partitionPrivate(Th, ThBorder, ThGlobal, PhGlobalPrivate, VhGlobalPrivate, partGlobal, mpiRank(comm), mpiSize(comm), s, overlap, level, prolongation, DTab, P, intersection, comm, fakeInterface, PkPart, defP1, initP1, bs)
ENDIFMACRO
IFMACRO(!privateBuildDmesh)
        partitionPrivate(Th, ThBorder, ThGlobal, PhGlobalPrivate, VhGlobalPrivate, partGlobal, mpiRank(comm), mpiSize(comm), s, overlap, level, prolongation, DTab, P, intersection, comm, fakeInterface, PkPart, defPart, initPart, bs)
ENDIFMACRO
    }
    else if(mpiSize(comm) == 1) {
        for(int i = level - 1; i > 0; --i) {
            Th[i - 1] = trunc(Th[i], 1, split = s);
            fespace WhLocalRefinedPrivate(Th[i - 1], P);
            fespace WhLocalCoarsePrivate(Th[i], P);
            prolongation[i - 1] = interpolate(WhLocalRefinedPrivate, WhLocalCoarsePrivate);
            DTab[i].resize(WhLocalCoarsePrivate.ndof);
            DTab[i] = 1.0;
        }
        if(level == 1) {
IFMACRO(privateBuildDmesh)
IFMACRO(privateDmesh#N2O)
            if(s > 1)
                Th[0] = trunc(Th[0], 1, split = s, new2old = privateDmesh#N2O);
            else {
                privateDmesh#N2O.resize(Th[0].nt);
                privateDmesh#N2O = 0:Th[0].nt-1;
            }
ENDIFMACRO
IFMACRO(!privateDmesh#N2O)
            if(s > 1)
                Th[0] = trunc(Th[0], 1, split = s);
ENDIFMACRO
ENDIFMACRO
IFMACRO(!privateBuildDmesh)
            if(s > 1)
                Th[0] = trunc(Th[0], 1, split = s);
ENDIFMACRO
        }
        fespace WhLocalPrivate(Th[0], P);
        DTab[0].resize(WhLocalPrivate.ndof);
        DTab[0] = 1.0;
    }
    if(verbosity > 0) {
        mpiBarrier(comm);
        if(mpiRank(comm) == 0)
            cout.scientific << " --- partition of unity built (in " << mpiWtime() - timerPartition << ")" << endl;
    }
}// EOM

macro buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, labPeriodic, userPartitioning, bs) {
    meshN[int] ThTab(1);
    meshN[int] ThBorderTab(1);
    real[int][int] DTab(1);
    ThTab[0] = Th;
    matrix[int] prolongation(0);
    buildOverlapEdgePeriodicRecursive(ThTab, ThBorderTab, fakeInterface, s, overlap, 1, prolongation, intersection, DTab, P, comm, excluded, PkPart, defPart, initPart, labPeriodic, userPartitioning, bs)
    Th = ThTab[0];
    ThBorder = ThBorderTab[0];
    D.resize(DTab[0].n);
    D = DTab[0];
}// EOM

IFMACRO(vectorialfe)
macro buildOverlapEdgeRecursive(Th, ThBorder, fakeInterface, s, overlap, level, prolongation, intersection, D, P, comm, excluded, PkPart, defPart, initPart, bs) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    buildOverlapEdgePeriodicRecursive(Th, ThBorder, fakeInterface, s, overlap, level, prolongation, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, emptyRealArray, bs)
}// EOM
macro buildOverlapEdge(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, bs) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, emptyRealArray, bs)
}// EOM
macro buildOverlapEdgeWithPartitioning(Th, ThBorder, part, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, bs) {
    int[int] emptyArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, part, bs)
}// EOM
macro buildOverlapWithPartitioning(Th, ThBorder, part, fakeInterface, s, overlap, intersection, D, P, comm, excluded, bs) {
    int[int] emptyArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, part, bs)
}// EOM
macro buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, bs) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, emptyRealArray, bs)
}// EOM
macro buildOverlapPeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, labPeriodic, bs) {
    real[int] emptyArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, labPeriodic, emptyArray, bs)
}// EOM
macro buildEdgeWithPartitioning(Th, part, s, intersection, D, P, comm, PkPart, defPart, initPart, bs) {
    int[int] emptyArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, part, bs)
}// EOM
macro buildWithPartitioning(Th, part, s, intersection, D, P, comm, bs) {
    int[int] emptyArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, part, bs)
}// EOM
macro build(Th, s, intersection, D, P, comm, bs) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, emptyRealArray, bs)
}// EOM
macro buildPeriodic(Th, s, intersection, D, P, comm, labPeriodic, bs) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, labPeriodic, emptyRealArray, bs)
}// EOM
macro buildMinimalist(Th, intersection, D, P, bs) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, 1, overlap, intersection, D, P, mpiCommWorld, excluded, P, def, init, emptyArray, emptyRealArray, bs)
}// EOM
macro buildRecursive(Th, s, level, prolongation, intersectionMat, DTab, P, comm, bsMat) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN[int] ThBorderTab(level);
    DTab.resize(level);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, level, prolongation, intersectionMat, DTab, P, comm, false, P, def, init, emptyArray, emptyRealArray, bsMat)
}// EOM
macro buildMatRecursive(Th, s, nlevel, prolongation, A, P, comm, bsMat) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN[int] ThBorderTab(nlevel);
    int[int][int] intersectionMat;
    real[int][int] DTab(nlevel);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, nlevel, prolongation, intersectionMat, DTab, P, comm, false, P, def, init, emptyArray, emptyRealArray, bsMat)
    for(int i = 0; i < nlevel; ++i)
        constructor(A[i], DTab[i].n, intersectionMat, DTab[i], bs = bsMat, communicator = comm, level = i);
}// EOM
macro buildMatEdgeRecursive(Th, s, nlevel, prolongation, A, P, comm, PkPart, defPart, initPart, bsMat) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN[int] ThBorderTab(nlevel);
    int[int][int] intersectionMat;
    real[int][int] DTab(nlevel);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, nlevel, prolongation, intersectionMat, DTab, P, comm, false, PkPart, defPart, initPart, emptyArray, emptyRealArray, bsMat)
    for(int i = 0; i < nlevel; ++i)
        constructor(A[i], DTab[i].n, intersectionMat, DTab[i], bs = bsMat, communicator = comm, level = i);
}// EOM
macro buildMatEdgeRecursiveWithPartitioning(Th, part, s, nlevel, prolongation, A, P, comm, PkPart, defPart, initPart, bsMat) {
    int[int] emptyArray(0);
    meshN[int] ThBorderTab(nlevel);
    int[int][int] intersectionMat;
    real[int][int] DTab(nlevel);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, nlevel, prolongation, intersectionMat, DTab, P, comm, false, PkPart, defPart, initPart, emptyArray, part, bsMat)
    for(int i = 0; i < nlevel; ++i)
        constructor(A[i], DTab[i].n, intersectionMat, DTab[i], bs = bsMat, communicator = comm, level = i);
}// EOM
macro buildMatEdgeWithPartitioning(Th, part, s, A, P, comm, PkPart, defPart, initPart, bsMat) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildEdgeWithPartitioning(Th, part, s, intersectionMat, DMat, P, comm, PkPart, defPart, initPart, bsMat)
    constructor(A, DMat.n, intersectionMat, DMat, bs = bsMat, communicator = comm);
}// EOM
macro buildMatWithPartitioning(Th, part, s, A, P, comm, bsMat) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildWithPartitioning(Th, part, s, intersectionMat, DMat, P, comm, bsMat)
    constructor(A, DMat.n, intersectionMat, DMat, bs = bsMat, communicator = comm);
}// EOM
macro buildMat(Th, s, A, P, comm, bsMat) {
    real[int] DMat;
    int[int][int] intersectionMat;
    build(Th, s, intersectionMat, DMat, P, comm, bsMat)
    constructor(A, DMat.n, intersectionMat, DMat, bs = bsMat, communicator = comm);
}// EOM
macro buildMatPeriodic(Th, s, A, P, comm, labPeriodic, bsMat) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildPeriodic(Th, s, intersectionMat, DMat, P, comm, labPeriodic, bsMat)
    constructor(A, DMat.n, intersectionMat, DMat, bs = bsMat, communicator = comm);
}// EOM
macro buildMatMinimalist(Th, A, P, bsMat) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildMinimalist(Th, intersectionMat, DMat, P, bsMat)
    constructor(A, DMat.n, intersectionMat, DMat, bs = bsMat, communicator = comm);
}// EOM
ENDIFMACRO
IFMACRO(!vectorialfe)
macro buildOverlapEdgeRecursive(Th, ThBorder, fakeInterface, s, overlap, level, prolongation, intersection, D, P, comm, excluded, PkPart, defPart, initPart) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    buildOverlapEdgePeriodicRecursive(Th, ThBorder, fakeInterface, s, overlap, level, prolongation, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, emptyRealArray, 1)
}// EOM
macro buildOverlapEdge(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, emptyRealArray, 1)
}// EOM
macro buildOverlapEdgeWithPartitioning(Th, ThBorder, part, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart) {
    int[int] emptyArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, part, 1)
}// EOM
macro buildOverlapWithPartitioning(Th, ThBorder, part, fakeInterface, s, overlap, intersection, D, P, comm, excluded) {
    int[int] emptyArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, part, 1)
}// EOM
macro buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, emptyRealArray, 1)
}// EOM
macro buildOverlapPeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, labPeriodic) {
    real[int] emptyArray(0);
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, labPeriodic, emptyArray, 1)
}// EOM
macro buildEdgeWithPartitioning(Th, part, s, intersection, D, P, comm, PkPart, defPart, initPart) {
    int[int] emptyArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, PkPart, defPart, initPart, emptyArray, part, 1)
}// EOM
macro buildWithPartitioning(Th, part, s, intersection, D, P, comm) {
    int[int] emptyArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, part, 1)
}// EOM
macro build(Th, s, intersection, D, P, comm) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, emptyArray, emptyRealArray, 1)
}// EOM
macro buildPeriodic(Th, s, intersection, D, P, comm, labPeriodic) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, P, comm, excluded, P, def, init, labPeriodic, emptyRealArray, 1)
}// EOM
macro buildMinimalist(Th, intersection, D, P) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN ThBorder;
    int fakeInterface = -111111;
    int overlap = 1;
    bool excluded = false;
    buildOverlapEdgePeriodic(Th, ThBorder, fakeInterface, 1, overlap, intersection, D, P, mpiCommWorld, excluded, P, def, init, emptyArray, emptyRealArray, 1)
}// EOM
macro buildRecursive(Th, s, level, prolongation, intersectionMat, DTab, P, comm) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN[int] ThBorderTab(level);
    DTab.resize(level);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, level, prolongation, intersectionMat, DTab, P, comm, false, P, def, init, emptyArray, emptyRealArray, 1)
}// EOM
macro buildMatRecursive(Th, s, nlevel, prolongation, A, P, comm) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN[int] ThBorderTab(nlevel);
    int[int][int] intersectionMat;
    real[int][int] DTab(nlevel);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, nlevel, prolongation, intersectionMat, DTab, P, comm, false, P, def, init, emptyArray, emptyRealArray, 1)
    for(int i = 0; i < nlevel; ++i)
        constructor(A[i], DTab[i].n, intersectionMat, DTab[i], communicator = comm, level = i);
}// EOM
macro buildMatEdgeRecursive(Th, s, nlevel, prolongation, A, P, comm, PkPart, defPart, initPart) {
    int[int] emptyArray(0);
    real[int] emptyRealArray(0);
    meshN[int] ThBorderTab(nlevel);
    int[int][int] intersectionMat;
    real[int][int] DTab(nlevel);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, nlevel, prolongation, intersectionMat, DTab, P, comm, false, PkPart, defPart, initPart, emptyArray, emptyRealArray, 1)
    for(int i = 0; i < nlevel; ++i)
        constructor(A[i], DTab[i].n, intersectionMat, DTab[i], communicator = comm, level = i);
}// EOM
macro buildMatEdgeRecursiveWithPartitioning(Th, part, s, nlevel, prolongation, A, P, comm, PkPart, defPart, initPart) {
    int[int] emptyArray(0);
    meshN[int] ThBorderTab(nlevel);
    int[int][int] intersectionMat;
    real[int][int] DTab(nlevel);
    buildOverlapEdgePeriodicRecursive(Th, ThBorderTab, -111111, s, 1, nlevel, prolongation, intersectionMat, DTab, P, comm, false, PkPart, defPart, initPart, emptyArray, part, 1)
    for(int i = 0; i < nlevel; ++i)
        constructor(A[i], DTab[i].n, intersectionMat, DTab[i], communicator = comm, level = i);
}// EOM
macro buildMatEdgeWithPartitioning(Th, part, s, A, P, comm, PkPart, defPart, initPart) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildEdgeWithPartitioning(Th, part, s, intersectionMat, DMat, P, comm, PkPart, defPart, initPart)
    constructor(A, DMat.n, intersectionMat, DMat, communicator = comm);
}// EOM
macro buildMatWithPartitioning(Th, part, s, A, P, comm) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildWithPartitioning(Th, part, s, intersectionMat, DMat, P, comm)
    constructor(A, DMat.n, intersectionMat, DMat, communicator = comm);
}// EOM
macro buildMat(Th, s, A, P, comm) {
    real[int] DMat;
    int[int][int] intersectionMat;
    build(Th, s, intersectionMat, DMat, P, comm)
    constructor(A, DMat.n, intersectionMat, DMat, communicator = comm);
}// EOM
macro buildMatPeriodic(Th, s, A, P, comm, labPeriodic) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildPeriodic(Th, s, intersectionMat, DMat, P, comm, labPeriodic)
    constructor(A, DMat.n, intersectionMat, DMat, communicator = comm);
}// EOM
macro buildMatMinimalist(Th, A, P) {
    real[int] DMat;
    int[int][int] intersectionMat;
    buildMinimalist(Th, intersectionMat, DMat, P)
    constructor(A, DMat.n, intersectionMat, DMat);
}// EOM
ENDIFMACRO

macro convectParallel(ThName, uVel, dt, uKhi, safety)
IFMACRO(privateDmesh#ThName)
{
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!ThName#VelocityPk)
func ThSinglePk = P1;
ENDIFMACRO
IFMACRO(ThName#VelocityPk)
func ThSinglePk = ThName#VelocityPk;
ENDIFMACRO
if(verbosity >= 0)
    mpiBarrier(ThName#Comm);
real timerConvect = mpiWtime();
if(mpiSize(ThName#Comm) == 1) {
    uKhi = convect(uVel, dt, uKhi);
}
else {
    int backupSM = searchMethod;
    searchMethod = 0;
    real[int] bb(2 * dimension);
    boundingbox(ThName, bb);
    bb(0) -= safety * ThName.hmax;
    bb(1) += safety * ThName.hmax;
    bb(2) -= safety * ThName.hmax;
    bb(3) += safety * ThName.hmax;
IFMACRO(dimension,3)
    bb(4) -= safety * ThName.hmax;
    bb(5) += safety * ThName.hmax;
ENDIFMACRO
    int size = mpiSize(ThName#Comm);
    real[int] bbAll(2 * dimension * size);
    mpiAllgather(bb, bbAll, ThName#Comm);
    int[int] rankExchange(0);
    for(int i = 0; i < size; ++i) {
IFMACRO(dimension,2)
        if(!(bbAll[1 + 4 * i] < bb[0]
          || bbAll[0 + 4 * i] > bb[1]
          || bbAll[3 + 4 * i] < bb[2]
          || bbAll[2 + 4 * i] > bb[3]))
ENDIFMACRO
IFMACRO(dimension,3)
        if(!(bbAll[1 + 6 * i] < bb[0]
          || bbAll[0 + 6 * i] > bb[1]
          || bbAll[3 + 6 * i] < bb[2]
          || bbAll[2 + 6 * i] > bb[3]
          || bbAll[5 + 6 * i] < bb[4]
          || bbAll[4 + 6 * i] > bb[5]))
ENDIFMACRO
                                                    {
            rankExchange.resize(rankExchange.n + 1);
            rankExchange[rankExchange.n - 1] = i;
        }
    }
    real[int] D, backupRegion(ThName.nt);
IFMACRO(dimension,2)
    func PkVel = [ThSinglePk, ThSinglePk];
ENDIFMACRO
IFMACRO(dimension,3)
    func PkVel = [ThSinglePk, ThSinglePk, ThSinglePk];
ENDIFMACRO
    fespace VhVelPrivate(ThName, PkVel);
    fespace VhKhiPrivate(ThName, ThSinglePk);
    real[int] buffer(VhVelPrivate.ndof + VhKhiPrivate.ndof);
    {
        VhVelPrivate defVel(uVelLocal) = uVel;
        fespace VhKhiP1(ThName, P1);
        VhKhiP1 khiP1;
        khiP1[] = privateDmesh#ThName#khiDef[0];
        VhKhiPrivate khi;
        if(khi[].n != khiP1[].n)
            khi = khiP1;
        else
            khi[] = khiP1[];
        for[i, value : uVelLocal[]] value *= khi[][i / dimension];
        buffer(0:VhVelPrivate.ndof - 1) = uVelLocal[];
        buffer(VhVelPrivate.ndof:VhVelPrivate.ndof + VhKhiPrivate.ndof - 1) = khi[];
        if(khi[].n != uKhi[].n) {
            khi = uKhi;
            buffer(VhVelPrivate.ndof:VhVelPrivate.ndof + VhKhiPrivate.ndof - 1) .*= khi[];
        }
        else
            buffer(VhVelPrivate.ndof:VhVelPrivate.ndof + VhKhiPrivate.ndof - 1) .*= uKhi[];
    }
    fespace PhPartPrivate(ThName, P0);
    {
        PhPartPrivate backup = region;
        backupRegion = backup[];
        ThName = change(ThName, fregion = privateDmesh#ThName#khiDef[1][nuTriangle]);
    }
    meshN[int] recvTh(rankExchange.n);
    meshN[int] sendTh(rankExchange.n);
    real[int][int] exchangeU(rankExchange.n + rankExchange.n);
    mpiRequest[int] rqSendTh(rankExchange.n);
    mpiRequest[int] rqSendU(rankExchange.n);
    mpiRequest[int] rqRecvTh(rankExchange.n);
    mpiRequest[int] rqRecvU(rankExchange.n);
    for[i, value : rankExchange]
        Irecv(processor(value, rqRecvTh[i]), recvTh[i]);
    for[i, value : rankExchange] {
        PhPartPrivate part;
IFMACRO(dimension,2)
        part = (bbAll[0 + 4 * value] < x
             && bbAll[1 + 4 * value] > x
             && bbAll[2 + 4 * value] < y
             && bbAll[3 + 4 * value] > y) ? 1.0 : 0.0;
ENDIFMACRO
IFMACRO(dimension,3)
        part = (bbAll[0 + 6 * value] < x
             && bbAll[1 + 6 * value] > x
             && bbAll[2 + 6 * value] < y
             && bbAll[3 + 6 * value] > y
             && bbAll[4 + 6 * value] < z
             && bbAll[5 + 6 * value] > z) ? 1.0 : 0.0;
ENDIFMACRO
        if(part[].linfty > 1.0e-2) {
            int[int] n2o;
            sendTh[i] = trunc(ThName, part > 1.0e-2, new2old = n2o);
            fespace VhRestrictionPrivate(sendTh[i], ThSinglePk);
            int[int] map;
            map = restrict(VhRestrictionPrivate, VhKhiPrivate, n2o);
            exchangeU[rankExchange.n + i].resize(VhRestrictionPrivate.ndof * (dimension + 1));
            for[j, w : map] {
                exchangeU[rankExchange.n + i][dimension * j] = buffer[dimension * w];
                exchangeU[rankExchange.n + i][dimension * j + 1] = buffer[dimension * w + 1];
IFMACRO(dimension,3)
                exchangeU[rankExchange.n + i][dimension * j + 2] = buffer[dimension * w + 2];
ENDIFMACRO
                exchangeU[rankExchange.n + i][VhRestrictionPrivate.ndof * dimension + j] = buffer[VhKhiPrivate.ndof * dimension + w];
            }
            Isend(processor(value, rqSendTh[i]), sendTh[i]);
            Isend(processor(value, rqSendU[i]), exchangeU[rankExchange.n + i]);
        }
        else
            Isend(processor(value, rqSendTh[i]), sendTh[i]);
    }
    meshN gluedExchange;
    {
        meshN[int] toGlue(rankExchange.n);
        int j = 0;
        for[i, value : rankExchange] {
            int index = mpiWaitAny(rqRecvTh);
            if(recvTh[index].nt) {
                fespace VhRestrictionPrivate(recvTh[index], ThSinglePk);
                exchangeU[index].resize(VhRestrictionPrivate.ndof * (dimension + 1));
                Irecv(processor(rankExchange[index], rqRecvU[index]), exchangeU[index]);
                fespace PhRestrictionPrivate(recvTh[index], P0);
                PhRestrictionPrivate ind = abs(region - rankExchange[index]) < 1.0e-2 ? 1.0 : 0.0;
                if(abs(ind[].max - 1.0) < 1.0e-2) {
                    toGlue[j] = trunc(recvTh[index], ind > 1.0e-2);
                    ++j;
                }
            }
        }
        toGlue.resize(j);
        gluedExchange = gluemesh(toGlue);
    }
    meshN interpolateExchange;
    fespace VhVelExchangePrivate(gluedExchange, PkVel);
    fespace VhKhiExchangePrivate(gluedExchange, ThSinglePk);
    VhVelExchangePrivate defVel(uVelExchange);
    VhKhiExchangePrivate uKhiExchange;
    for[i, value : rankExchange] {
        int index = mpiWaitAny(rqRecvU);
        if(index != mpiUndefined) {
            if(recvTh[index].nt) {
                fespace VhRestrictionPrivate(recvTh[index], ThSinglePk);
                matrix R = interpolate(VhRestrictionPrivate, VhKhiExchangePrivate);
                if(R.nnz != R.n) {
                    R.thresholding(1.0e-2);
                    assert(R.nnz == R.n);
                }
                for[i, j, value : R] {
                    uVelExchange[][dimension * j] += exchangeU[index][dimension * i];
                    uVelExchange[][dimension * j + 1] += exchangeU[index][dimension * i + 1];
IFMACRO(dimension,3)
                    uVelExchange[][dimension * j + 2] += exchangeU[index][dimension * i + 2];
ENDIFMACRO
                    uKhiExchange[][j] += exchangeU[index][dimension * VhRestrictionPrivate.ndof + i];
                }
            }
        }
    }
    searchMethod = backupSM;
    fespace VhPhiExchangePrivate(gluedExchange, P0);
    fespace VhKhiExchangeP1(gluedExchange, P1);
    int rank = mpiRank(ThName#Comm);
    VhPhiExchangePrivate phi = abs(region - rank) < 1.0e-2 ? 1.0 : 0.0;
    VhKhiExchangeP1 khi;
    AddLayers(gluedExchange, phi[], safety, khi[]);
    int[int] n2o;
    meshN gluedExchangeSafety = trunc(gluedExchange, abs(khi) > 0.1, new2old = n2o);
    fespace VhVelExchangeSafetyPrivate(gluedExchangeSafety, PkVel);
    fespace VhKhiExchangeSafetyPrivate(gluedExchangeSafety, ThSinglePk);
    int[int] map = restrict(VhKhiExchangeSafetyPrivate, VhKhiExchangePrivate, n2o);
    VhVelExchangeSafetyPrivate defVel(uVelExchangeSafety);
    VhKhiExchangeSafetyPrivate uKhiExchangeSafety;
    uKhiExchangeSafety[] = uKhiExchange[](map);
    for[j, w : map] {
        uVelExchangeSafety[][dimension * j] = uVelExchange[][dimension * w];
        uVelExchangeSafety[][dimension * j + 1] = uVelExchange[][dimension * w + 1];
IFMACRO(dimension,3)
        uVelExchangeSafety[][dimension * j + 2] = uVelExchange[][dimension * w + 2];
ENDIFMACRO
    }
    uKhiExchangeSafety = convect(defVel(uVelExchangeSafety), dt, uKhiExchangeSafety);
    uKhi = uKhiExchangeSafety;
    ThName = change(ThName, fregion = backupRegion[nuTriangle]);
    mpiWaitAll(rqSendTh);
    mpiWaitAll(rqSendU);
}
if(verbosity > 0) {
    mpiBarrier(ThName#Comm);
    if(mpiRank(ThName#Comm) == 0)
        cout.scientific << " --- distributed solution convected (in " << mpiWtime() - timerConvect << ")" << endl;
}
}
ENDIFMACRO
// EOM

macro transferBase(ThName, Pk, uA, ThNew, PkNew, uANew, P)
IFMACRO(privateDmesh#ThName)
{
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
if(verbosity > 0)
    mpiBarrier(ThName#Comm);
real timerTransfer = mpiWtime();
IFMACRO(!def)
NewMacro def(i)i EndMacro
ENDIFMACRO
if(mpiSize(ThName#Comm) == 1) {
IFMACRO(!transfer#Q)
    def(uANew) = def(uA);
ENDIFMACRO
IFMACRO(transfer#Q)
    fespace VhLocalOldPrivate(ThName, Pk);
    fespace VhLocalNewPrivate(ThNew, PkNew);
    matrix loc = interpolate(VhLocalNewPrivate, VhLocalOldPrivate);
    matrix<PetscScalar> locPetscScalar = loc;
    constructor(P, uANew, uA, locPetscScalar);
ENDIFMACRO
}
else {
    int backupSM = searchMethod;
    searchMethod = 0;
    fespace VhLocalOldPrivate(ThName, Pk);
    fespace VhLocalNewPrivate(ThNew, PkNew);
IFMACRO(!transfer#Q)
    assert(uA[].n == VhLocalOldPrivate.ndof);
    assert(uANew[].n == VhLocalNewPrivate.ndof);
ENDIFMACRO
IFMACRO(!dimension)
NewMacro dimension()2 EndMacro
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro
ENDIFMACRO
IFMACRO(!ThName#NestedIn#ThNew)
    real[int] bb(4 * dimension);
    {
        real[int] tmp(2 * dimension);
        boundingbox(ThName, tmp);
        bb(0:2 * dimension - 1) = tmp;
        boundingbox(ThNew, tmp);
        bb(2 * dimension:4 * dimension - 1) = tmp;
        bb(0) -= max(ThName.hmax, ThNew.hmax);
        bb(1) += max(ThName.hmax, ThNew.hmax);
        bb(2) -= max(ThName.hmax, ThNew.hmax);
        bb(3) += max(ThName.hmax, ThNew.hmax);
        bb(4) -= max(ThName.hmax, ThNew.hmax);
        bb(5) += max(ThName.hmax, ThNew.hmax);
        bb(6) -= max(ThName.hmax, ThNew.hmax);
        bb(7) += max(ThName.hmax, ThNew.hmax);
IFMACRO(dimension,3)
        bb(8) -= max(ThName.hmax, ThNew.hmax);
        bb(9) += max(ThName.hmax, ThNew.hmax);
        bb(10) -= max(ThName.hmax, ThNew.hmax);
        bb(11) += max(ThName.hmax, ThNew.hmax);
ENDIFMACRO
    }
    int size = mpiSize(ThName#Comm);
    real[int] bbAll(4 * dimension * size);
    mpiAllgather(bb, bbAll, ThName#Comm);
    int[int] rankSend(0);
    int[int] rankRecv(0);
    for(int i = 0; i < size; ++i) {
IFMACRO(dimension,2)
        if(!(bbAll[1 + 8 * i] < bb[4]
          || bbAll[0 + 8 * i] > bb[5]
          || bbAll[3 + 8 * i] < bb[6]
          || bbAll[2 + 8 * i] > bb[7]))
ENDIFMACRO
IFMACRO(dimension,3)
        if(!(bbAll[1 + 12 * i] < bb[6]
          || bbAll[0 + 12 * i] > bb[7]
          || bbAll[3 + 12 * i] < bb[8]
          || bbAll[2 + 12 * i] > bb[9]
          || bbAll[5 + 12 * i] < bb[10]
          || bbAll[4 + 12 * i] > bb[11]))
ENDIFMACRO
                                                    {
            rankRecv.resize(rankRecv.n + 1);
            rankRecv[rankRecv.n - 1] = i;
        }
IFMACRO(dimension,2)
        if(!(bbAll[5 + 8 * i] < bb[0]
          || bbAll[4 + 8 * i] > bb[1]
          || bbAll[7 + 8 * i] < bb[2]
          || bbAll[6 + 8 * i] > bb[3]))
ENDIFMACRO
IFMACRO(dimension,3)
        if(!(bbAll[7 + 12 * i] < bb[0]
          || bbAll[6 + 12 * i] > bb[1]
          || bbAll[9 + 12 * i] < bb[2]
          || bbAll[8 + 12 * i] > bb[3]
          || bbAll[11 + 12 * i] < bb[4]
          || bbAll[10 + 12 * i] > bb[5]))
ENDIFMACRO
                                                    {
            rankSend.resize(rankSend.n + 1);
            rankSend[rankSend.n - 1] = i;
        }
    }
    real[int] D, backupRegion(ThName.nt);
    VhLocalOldPrivate<PetscScalar> def(scaledU);
IFMACRO(!transfer#Q)
    createPartition(ThName, D, Pk)
    scaledU[] = uA[];
ENDIFMACRO
IFMACRO(transfer#Q)
    GlobalNumbering(uA, scaledU[]);
    D.resize(scaledU[].n);
    D = uA.D;
ENDIFMACRO
    for[i, value : D] scaledU[][i] *= value;
    fespace PhPartPrivate(ThName, P0);
    {
        PhPartPrivate backup = region;
        backupRegion = backup[];
        int[int] newRegion(ThName.nt);
        int rank = mpiRank(ThName#Comm);
        for[i, value : privateDmesh#ThName#khiDef[1]] newRegion[i] = abs(value - rank) < 1.0e-2;
        ThName = change(ThName, fregion = newRegion[nuTriangle]);
    }
    meshN[int] recvTh(rankRecv.n);
    meshN[int] sendTh(rankSend.n);
    PetscScalar[int][int] exchangeU(rankSend.n + rankRecv.n);
    mpiRequest[int] rqSendTh(rankSend.n);
    mpiRequest[int] rqSendU(rankSend.n);
    mpiRequest[int] rqRecvTh(rankRecv.n);
    mpiRequest[int] rqRecvU(rankRecv.n);
    for[i, value : rankRecv]
        Irecv(processor(value, rqRecvTh[i]), recvTh[i]);
    for[i, value : rankSend] {
        PhPartPrivate part;
IFMACRO(dimension,2)
        part = (bbAll[4 + 8 * value] < x
             && bbAll[5 + 8 * value] > x
             && bbAll[6 + 8 * value] < y
             && bbAll[7 + 8 * value] > y) ? 1.0 : 0.0;
ENDIFMACRO
IFMACRO(dimension,3)
        part = (bbAll[6 + 12 * value] < x
             && bbAll[7 + 12 * value] > x
             && bbAll[8 + 12 * value] < y
             && bbAll[9 + 12 * value] > y
             && bbAll[10 + 12 * value] < z
             && bbAll[11 + 12 * value] > z) ? 1.0 : 0.0;
ENDIFMACRO
        if(part[].linfty > 1.0e-2) {
            int[int] n2o;
            sendTh[i] = trunc(ThName, part > 1.0e-2, new2old = n2o);
            fespace VhRestrictionPrivate(sendTh[i], Pk);
            int[int] map = restrict(VhRestrictionPrivate, VhLocalOldPrivate, n2o);
            exchangeU[rankRecv.n + i].resize(VhRestrictionPrivate.ndof);
            exchangeU[rankRecv.n + i] = scaledU[](map);
            Isend(processor(value, rqSendTh[i]), sendTh[i]);
            Isend(processor(value, rqSendU[i]), exchangeU[rankRecv.n + i]);
        }
        else
            Isend(processor(value, rqSendTh[i]), sendTh[i]);
    }
    meshN gluedExchange;
    {
        meshN[int] toGlue(rankRecv.n);
        int j = 0;
        for[i, value : rankRecv] {
            int index = mpiWaitAny(rqRecvTh);
            if(recvTh[index].nt) {
                fespace VhRestrictionPrivate(recvTh[index], Pk);
                exchangeU[index].resize(VhRestrictionPrivate.ndof);
                Irecv(processor(rankRecv[index], rqRecvU[index]), exchangeU[index]);
                fespace PhRestrictionPrivate(recvTh[index], P0);
                PhRestrictionPrivate ind = region;
                if(abs(ind[].max - 1.0) < 1.0e-2) {
                    toGlue[j] = trunc(recvTh[index], ind > 1.0e-2);
                    ++j;
                }
            }
        }
        toGlue.resize(j);
        gluedExchange = gluemesh(toGlue);
    }
    meshN interpolateExchange;
    fespace PhExchangePrivate(gluedExchange, P0);
    fespace VhExchangePrivate(gluedExchange, Pk);
    VhExchangePrivate<PetscScalar> def(uExchange);
    for[i, value : rankRecv] {
        int index = mpiWaitAny(rqRecvU);
        if(index != mpiUndefined) {
            if(recvTh[index].nt) {
                fespace PhRestrictionPrivate(recvTh[index], P0);
                matrix R = interpolate(PhRestrictionPrivate, PhExchangePrivate);
                if(R.nnz != R.n) {
                    R.thresholding(1.0e-2);
                    assert(R.nnz == R.n);
                }
                int[int] I, J;
                real[int] C;
                [I, J, C] = R;
                fespace VhRestrictionPrivate(recvTh[index], Pk);
                int[int] restriction = restrict(VhRestrictionPrivate, VhExchangePrivate, J);
                uExchange[](restriction) += exchangeU[index];
            }
        }
    }
    searchMethod = backupSM;
IFMACRO(!transfer#Q)
    def(uANew) = def(uExchange);
ENDIFMACRO
IFMACRO(transfer#Q)
    matrix loc = interpolate(VhLocalNewPrivate, VhExchangePrivate);
    matrix<PetscScalar> locPetscScalar = loc;
    constructor(P, uANew, uA, locPetscScalar, numbering = uExchange[]);
ENDIFMACRO
    ThName = change(ThName, fregion = backupRegion[nuTriangle]);
    mpiWaitAll(rqSendTh);
    mpiWaitAll(rqSendU);
ENDIFMACRO
IFMACRO(ThName#NestedIn#ThNew)
IFMACRO(!transfer#Q)
    def(uANew) = def(uA);
    Mat<PetscScalar> exchange;
    createMat(ThNew, exchange, PkNew)
    PetscScalar[int] tmp;
    ChangeNumbering(exchange, uANew[], tmp);
    ChangeNumbering(exchange, uANew[], tmp, inverse = true, exchange = true);
ENDIFMACRO
IFMACRO(transfer#Q)
    matrix loc = interpolate(VhLocalNewPrivate, VhLocalOldPrivate);
    matrix<PetscScalar> locPetscScalar = loc;
    constructor(P, uANew, uA, locPetscScalar);
ENDIFMACRO
ENDIFMACRO
}
if(verbosity > 0) {
    mpiBarrier(ThName#Comm);
    if(mpiRank(ThName#Comm) == 0)
        cout.scientific << " --- distributed solution transferred (in " << mpiWtime() - timerTransfer << ")" << endl;
}
}
ENDIFMACRO
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
// EOM

macro transferMat(ThName, Pk, A, ThNew, PkNew, ANew, P) {
NewMacro transfer#Q() EndMacro
transferBase(ThName, Pk, A, ThNew, PkNew, ANew, P)
}// EOM

macro transfer(ThName, Pk, uPrivate, ThNew, PkNew, uNew) {
transferBase(ThName, Pk, uPrivate, ThNew, PkNew, uNew, 1)
}// EOM

macro createParMmgCommunicators(ThName, ThParMmgName, ThN2O, ThCommunicators) {
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
    Mat<PetscScalar> A;
    createMat(ThName, A, P1);
    real[int] D(ThName.nt);
    createPartition(ThName, D, P0);
    fespace PhPrivate(ThName, P0);
    PhPrivate d;
    d[] = D;
    ThParMmgName = trunc(ThName, abs(d) > 1.0e-2, label = -111111, new2old = ThN2O);
    fespace VhWithoutOverlapPrivate(ThParMmgName, P1);
    varf vG(uPrivate, vPrivate) = on(-111111, uPrivate = 1.0);
    real[int] gamma(ThParMmgName.nv);
    gamma = vG(0, VhWithoutOverlapPrivate, tgv = -1);
    fespace VhWithOverlapPrivate(ThName, P1);
    int[int] restriction = restrict(VhWithoutOverlapPrivate, VhWithOverlapPrivate, ThN2O);
    ParMmgCommunicators(A, gamma, restriction, ThCommunicators);
}// EOM

macro gatherDmesh(ThName, comm, ThGatherName) {
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!ThGatherName#Comm)
NewMacro ThGatherName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro
ENDIFMACRO
    if(verbosity > 0 && ThName#Comm)
        mpiBarrier(ThName#Comm);
    real timerGather = mpiWtime();
    int size;
    if(ThGatherName#Comm)
        size = mpiSize(comm);
    else
        size = 0;
    int reduce;
    mpiAllReduce(size, reduce, ThName#Comm, mpiSUM);
    assert(reduce == mpiSize(ThName#Comm));
    meshN ThNoOverlap;
    if(mpiSize(ThName#Comm) == 1)
        ThNoOverlap = ThName;
    else
        ThNoOverlap = trunc(ThName, abs(privateDmesh#ThName#khiDef[1][nuTriangle] - mpiRank(ThName#Comm)) < 1.0e-2, label = -111112);
    if(ThGatherName#Comm) {
        meshN[int] recvTh(size);
        mpiRequest[int] rqRecv(size - 1);
        for(int i = 1; i < size; ++i)
            Irecv(processor(i, comm, rqRecv[i - 1]), recvTh[i]);
        recvTh[0] = ThNoOverlap;
        mpiWaitAll(rqRecv);
        ThGatherName = gluemesh(recvTh);
    }
    else {
        mpiRequest rqSend;
        Isend(processor(0, comm, rqSend), ThNoOverlap);
        mpiWait(rqSend);
    }
    if(verbosity > 0 && ThName#Comm) {
        mpiBarrier(ThName#Comm);
        if(mpiRank(ThName#Comm) == 0)
            cout.scientific << " --- distributed mesh gathered (in " << mpiWtime() - timerGather << ")" << endl;
    }
}
reconstructDmesh(ThGatherName)// EOM

macro scatterDmesh(ThName, comm, ThScatterName) {
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!ThScatterName#Comm)
NewMacro ThScatterName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro
ENDIFMACRO
    if(verbosity > 0 && ThScatterName#Comm)
        mpiBarrier(ThScatterName#Comm);
    real timerScatter = mpiWtime();
    int size;
    if(ThName#Comm) {
        size = mpiSize(comm);
    }
    else
        size = 0;
    int reduce;
    mpiAllReduce(size, reduce, ThScatterName#Comm, mpiSUM);
    assert(reduce == mpiSize(ThScatterName#Comm));
    if(ThName#Comm) {
        meshN ThNoOverlap;
        if(mpiSize(ThName#Comm) == 1 || (privateDmesh#ThName#intersectionDef.n == 0 && privateDmesh#ThName#khiDef[0].n == 0 && privateDmesh#ThName#khiDef[1].n == 0))
            ThNoOverlap = ThName;
        else
            ThNoOverlap = trunc(ThName, abs(privateDmesh#ThName#khiDef[1][nuTriangle] - mpiRank(ThName#Comm)) < 1.0e-2, label = -111112);
        fespace PhPartPrivate(ThNoOverlap, P0);
        PhPartPrivate part;
        partitionerSeq(part[], ThNoOverlap, mpiSize(comm));
        partitionerPar(part[], ThNoOverlap, mpiCommSelf, mpiSize(comm));
        meshN[int] sendTh(mpiSize(comm) - 1);
        mpiRequest[int] rqSend(mpiSize(comm) - 1);
        for(int i = 1; i < mpiSize(comm); ++i) {
            sendTh[i - 1] = trunc(ThNoOverlap, abs(part - i) < 1.0e-2, label = -111112);
            Isend(processor(i, comm, rqSend[i - 1]), sendTh[i - 1]);
        }
        ThScatterName = trunc(ThNoOverlap, abs(part) < 1.0e-2, label = -111112);
        mpiWaitAll(rqSend);
    }
    else if(ThScatterName#Comm) {
        mpiRequest rqRecv;
        Irecv(processor(0, comm, rqRecv), ThScatterName);
        mpiWait(rqRecv);
    }
    if(verbosity > 0 && ThScatterName#Comm) {
        mpiBarrier(ThScatterName#Comm);
        if(mpiRank(ThScatterName#Comm) == 0)
            cout.scientific << " --- distributed mesh scattered (in " << mpiWtime() - timerScatter << ")" << endl;
    }
}
reconstructDmesh(ThScatterName)// EOM

macro gatherSolution(ThName, comm, ThGatherName, Pk, uPrivate, uNew) {
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
IFMACRO(!privateDmesh#ThGatherName)
assert(0);
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!ThGatherName#Comm)
NewMacro ThGatherName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro
ENDIFMACRO
IFMACRO(!intN)
NewMacro intN()int2d EndMacro
ENDIFMACRO
    if(verbosity > 0 && ThName#Comm)
        mpiBarrier(ThName#Comm);
    real timerGather = mpiWtime();
IFMACRO(with,PETSc)
    PetscScalar[int] vPrivate(uPrivate[]);
    {
        Mat<PetscScalar> gather;
        createMat(ThName, gather, Pk)
        PetscScalar[int] trash;
        ChangeNumbering(gather, vPrivate, trash);
        ChangeNumbering(gather, vPrivate, trash, inverse = true, exchange = false);
    }
ENDIFMACRO
    if(ThGatherName#Comm) {
        meshN[int] recvTh(mpiSize(comm) - 1);
        PetscScalar[int][int] recvU(mpiSize(comm) - 1);
        mpiRequest[int] rqRecvTh(mpiSize(comm) - 1);
        mpiRequest[int] rqRecvU(mpiSize(comm) - 1);
        for(int i = 0; i < mpiSize(comm) - 1; ++i)
            Irecv(processor(i + 1, comm, rqRecvTh[i]), recvTh[i]);
        for(int i = 0; i < mpiSize(comm) - 1; ++i) {
            int index = mpiWaitAny(rqRecvTh);
            fespace VhRecvPrivate(recvTh[index], Pk);
            recvU[index].resize(VhRecvPrivate.ndof);
            Irecv(processor(index + 1, comm, rqRecvU[index]), recvU[index]);
        }
        fespace VhGlobalGatherPrivate(ThGatherName, Pk);
IFMACRO(!with)
        PetscScalar[int] visited(VhGlobalGatherPrivate.ndof);
        visited = 1.0;
ENDIFMACRO
        {
            fespace VhRestrictionPrivate(ThName, Pk);
            matrix R = interpolate(VhRestrictionPrivate, VhGlobalGatherPrivate);
IFMACRO(with,PETSc)
            uNew[] += R' * vPrivate;
ENDIFMACRO
IFMACRO(!with)
            PetscScalar[int] buffer = R' * uPrivate[];
            buffer .*= visited;
            PetscScalar[int] ones(VhRestrictionPrivate.ndof);
            ones = -1.0;
            visited += R' * ones;
            for[j, value : visited] value = max(abs(value), 0.0);
            uNew[] += buffer;
ENDIFMACRO
        }
        for(int i = 0; i < mpiSize(comm) - 1; ++i) {
            int index = mpiWaitAny(rqRecvU);
            fespace VhRestrictionPrivate(recvTh[index], Pk);
            matrix R = interpolate(VhRestrictionPrivate, VhGlobalGatherPrivate);
IFMACRO(with,PETSc)
            uNew[] += R' * recvU[index];
ENDIFMACRO
IFMACRO(!with)
            PetscScalar[int] buffer = R' * recvU[index];
            buffer .*= visited;
            PetscScalar[int] ones(VhRestrictionPrivate.ndof);
            ones = -1.0;
            visited += R' * ones;
            for[j, value : visited] value = max(abs(value), 0.0);
            uNew[] += buffer;
ENDIFMACRO
        }
IFMACRO(with,PETSc)
        Mat<PetscScalar> gather;
        createMat(ThGatherName, gather, Pk)
        exchange(gather, uNew[], scaled = false);
ENDIFMACRO
    }
    else {
        mpiRequest[int] rqSend(2);
        Isend(processor(0, comm, rqSend[0]), ThName);
        fespace VhLocalGatherPrivate(ThName, Pk);
        assert(uPrivate[].n == VhLocalGatherPrivate.ndof);
IFMACRO(with,PETSc)
        Isend(processor(0, comm, rqSend[1]), vPrivate);
ENDIFMACRO
IFMACRO(!with)
        Isend(processor(0, comm, rqSend[1]), uPrivate[]);
ENDIFMACRO
        mpiWaitAll(rqSend);
    }
    if(verbosity > 0 && ThName#Comm) {
        mpiBarrier(ThName#Comm);
        if(mpiRank(ThName#Comm) == 0)
            cout.scientific << " --- distributed solution gathered (in " << mpiWtime() - timerGather << ")" << endl;
    }
}// EOM

macro scatterSolution(ThName, comm, ThScatterName, Pk, uPrivate, uNew) {
IFMACRO(!privateDmesh#ThName)
assert(0);
ENDIFMACRO
IFMACRO(!privateDmesh#ThScatterName)
assert(0);
ENDIFMACRO
IFMACRO(!def)
NewMacro def(i)i EndMacro
ENDIFMACRO
IFMACRO(!ThName#Comm)
NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!ThScatterName#Comm)
NewMacro ThScatterName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
IFMACRO(!meshN)
NewMacro meshN()mesh EndMacro
ENDIFMACRO
    if(verbosity > 0 && ThScatterName#Comm)
        mpiBarrier(ThScatterName#Comm);
    real timerScatter = mpiWtime();
    if(mpiRank(comm) == 0) {
        broadcast(processor(0, comm), ThName);
        broadcast(processor(0, comm), uPrivate[]);
        def(uNew) = def(uPrivate);
    }
    else {
        meshN ThGlobalScatter;
        broadcast(processor(0, comm), ThGlobalScatter);
        fespace VhGlobalScatterPrivate(ThGlobalScatter, Pk);
        VhGlobalScatterPrivate<PetscScalar> def(uGlobalScatter);
        broadcast(processor(0, comm), uGlobalScatter[]);
        def(uNew) = def(uGlobalScatter);
    }
    if(verbosity > 0 && ThScatterName#Comm) {
        mpiBarrier(ThScatterName#Comm);
        if(mpiRank(ThScatterName#Comm) == 0)
            cout.scientific << " --- distributed solution scattered (in " << mpiWtime() - timerScatter << ")" << endl;
    }
}// EOM

macro CoherentGlobalMesh(MatT, MatV, ThName, ThGlobal) {
IFMACRO(!ThName#Comm)
    NewMacro ThName#Comm()mpiCommWorld EndMacro
ENDIFMACRO
    int[int] numberingT;
    int[int] numberingV;
    GlobalNumbering(MatT, numberingT);
    GlobalNumbering(MatV, numberingV);
    fespace VhLocalPrivateT(ThName, P0);
    fespace VhGlobalPrivateT(ThGlobal, P0);
    fespace VhLocalPrivateV(ThName, P1);
    fespace VhGlobalPrivateV(ThGlobal, P1);
    PetscScalar[int] numberingScalarT(numberingT.n), globalT, reduceT(ThGlobal.nt);
    PetscScalar[int] numberingScalarV(numberingV.n), globalV, reduceV(ThGlobal.nv);
    for[i, value : numberingT] numberingScalarT[i] = value;
    for[i, value : numberingV] numberingScalarV[i] = value;
    ChangeNumbering(MatT, numberingScalarT, globalT);
    ChangeNumbering(MatV, numberingScalarV, globalV);
    if (ThName.nv) {
        ChangeNumbering(MatT, numberingScalarT, globalT, inverse = true);
        ChangeNumbering(MatV, numberingScalarV, globalV, inverse = true);
IFMACRO(ThName#N2O)
        int[int] restrictionT = restrict(VhLocalPrivateT, VhGlobalPrivateT, ThName#N2O);
        int[int] restrictionV = restrict(VhLocalPrivateV, VhGlobalPrivateV, ThName#N2O);
ENDIFMACRO
IFMACRO(!ThName#N2O)
        int[int] restrictionT, restrictionV;
        {
            fespace PhGlobalPrivate(ThGlobal, P0);
            fespace PhLocalPrivate(ThName, P0);
            matrix R = interpolate(PhLocalPrivate, PhGlobalPrivate);
            int[int] I, J;
            real[int] C;
            [I, J, C] = R;
            restrictionT = restrict(VhLocalPrivateT, VhGlobalPrivateT, J);
            restrictionV = restrict(VhLocalPrivateV, VhGlobalPrivateV, J);
        }
ENDIFMACRO
        for[i, value : restrictionT] reduceT[value] = numberingScalarT[i];
        for[i, value : restrictionV] reduceV[value] = numberingScalarV[i];
    }
    globalT.resize(ThGlobal.nt);
    globalV.resize(ThGlobal.nv);
    mpiAllReduce(reduceT, globalT, ThName#Comm, mpiSUM);
    mpiAllReduce(reduceV, globalV, ThName#Comm, mpiSUM);
    int[int] globalIntT(globalT.n);
    int[int] globalIntV(globalV.n);
    for[i, value : globalT] globalIntT[i] = abs(value);
    for[i, value : globalV] globalIntV[i] = abs(value);
    ThGlobal = change(ThGlobal, renumt = globalIntT, renumv = globalIntV);
}// EOM

macro DmeshSave(ThName, name)saveDmesh(ThName, name)// EOM
macro DmeshLoad(ThName, name)loadDmesh(ThName, name)// EOM
macro DmeshCreate(ThName)buildDmesh(ThName)// EOM
macro DmeshReconstruct(ThName)reconstructDmesh(ThName)// EOM
macro DmeshReconstructWithNeighbors(ThName, neighborsName)reconstructDmeshWithNeighbors(ThName, neighborsName)// EOM
macro DmeshInitialize(NewName)initializeDmesh(NewName)// EOM
macro DmeshCopy(OldName, NewName)copyDmesh(OldName, NewName)// EOM
macro DmeshScatter(ThName, comm, ThScatterName)scatterDmesh(ThName, comm, ThScatterName)// EOM
macro DmeshGather(ThName, comm, ThGatherName)gatherDmesh(ThName, comm, ThGatherName)// EOM
macro PartitionCreate(ThName, PartName, PkName)createPartition(ThName, PartName, PkName)// EOM
macro ParMmgCreateCommunicators(ThName, ThParMmgName, ThN2O, ThCommunicators)createParMmgCommunicators(ThName, ThParMmgName, ThN2O, ThCommunicators)// EOM
macro VecScatter(ThName, comm, ThScatterName, Pk, uPrivate, uNew)scatterSolution(ThName, comm, ThScatterName, Pk, uPrivate, uNew)// EOM
macro VecGather(ThName, comm, ThGatherName, Pk, uPrivate, uNew)gatherSolution(ThName, comm, ThGatherName, Pk, uPrivate, uNew)// EOM
macro VecInterpolate(ThName, Pk, uPrivate, ThNew, PkNew, uNew)transfer(ThName, Pk, uPrivate, ThNew, PkNew, uNew)// EOM
macro MatCreate(ThName, MatName, PkName)createMat(ThName, MatName, PkName)// EOM
macro MatInterpolate(ThName, Pk, A, ThNew, PkNew, ANew, P)transferMat(ThName, Pk, A, ThNew, PkNew, ANew, P)// EOM
ENDIFMACRO
---
name: EqPoisson
category: math
folder: 3d
---

## Laplace equation in 3D on a object of revolution

The domain $\Omega$ is obtained by an axisymmetric extrusion of a 2d domain which has a hole
~~~freefem
load "medit"
func f=2*((0.1+(((x/3))*(x-1)*(x-1)/1+x/100))^(1/3.)-(0.1)^(1/3.));
real yf=f(1.2,0); 
border up(t=1.2,0.){ x=t;y=f;label=0;}
border axe2(t=0.2,1.15) { x=t;y=0;label=0;}
border hole(t=pi,0) { x= 0.15 + 0.05*cos(t);y= 0.05*sin(t); label=1;}
border axe1(t=0,0.1) { x=t;y=0;label=0;}
border queue(t=0,1) { x= 1.15 + 0.05*t; y = yf*t; label =0;}
int np= 100;
func bord= up(np)+axe1(np/10)+hole(np/10)+axe2(8*np/10)+ queue(np/10);
plot( bord); 
mesh Th2=buildmesh(bord);
plot(Th2,wait=1);
int[int] l23=[0,0,1,1]; 
mesh3 Th=buildlayers(Th2,coef= max(.15,y/max(f,0.05)), 50 ,zbound=[0,2*pi]
   ,transfo=[x,y*cos(z),y*sin(z)],facemerge=1,labelmid=l23);
~~~

The problem is to find $u\in V_1$ such that
$$
\int_\Omega \nabla u\cdot\nabla v = \int_\Omega v \quad \forall v\in V_0
$$
$$
V_w=\{v\in H^1(\Omega),~v|_S=w\}.
$$
where $S$ is the first border defined above, called "up"
~~~freefem
macro Grad(u) [dx(u),dy(u),dz(u)] //
fespace Vh(Th,P1);  Vh u,v;
solve Poisson(u,v) = int3d(Th)( Grad(u)'*Grad(v) ) - int3d(Th)( v) + on(1,u=1);
plot(u,wait=1,nbiso=20,value=1);
medit("u",Th,u,wait=1);
~~~

| The initial mesh and the deformed mesh |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/EqPoisson/solution.png
---
name: LapDG3d1
category: Applied Math
folder: 3d
---

## Solve the Laplace Equations in a Cube with Discontinous Galerkin Method of degree 1

$$
-\Delta u = f,\texttt{ in } \Omega\quad u|_{\partial\Omega}=g
$$
where $\Omega$ is the unit cube, $f=1$, $g=1$.
The finite element space chosen if the discontinuous $P^1$.
~~~freefem
macro grad(u) [dx(u),dy(u),dz(u)] //
macro dn(u) (N'*grad(u) ) //'  def the normal derivative

int nn=10; 
mesh3 Th= cube(nn,nn,nn); // unit square

int[int] labs=labels(Th);
fespace Vh(Th,P1dc);     // Discontinous P1 finite element
real pena=1e5; // a paramater to add penalisation 

func f=1;
func g=1;
Vh u,v;
solve A(u,v,solver=sparsesolver) = 
  int3d(Th)( grad(u)'*grad(v))//'
+ intallfaces(Th)( pena*jump(u)*jump(v) ) 
- int2d(Th,labs)(pena*g*v)
+ int2d(Th,labs)(pena*u*v)
- int3d(Th)( f*v)
;

plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
~~~

The solution. This display is obtained by typing F (to cancel "fill") and typing L.

| The solution           |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/LapDG3d1/solution.png
// meditddm.edp
load "medit"

/********************************************
 Initial Problem:
Resolution of the following EDP:
$- \Delta u = f$ on   $\Omega =\{ (x,y) |  1 \leq sqrt(x^2+y^2) \geq 2}$
$- \Delta u = f1$ on  $\Omega_{1} =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
$u = 1$ on $\Gamma$  +  Null Neumman condition on $\Gamma_{1}$ and on $\Gamma_{2}$	
We find the solution $u$ in solving two EDP defined on domain $\Omega$ and $\Omega_{1}$
This solution is vizualize with ffmedit 
*********************************************/
verbosity=3;

border Gamma(t=0,2*pi){x=cos(t); y=sin(t); label=1;};
border Gamma1(t=0,2*pi){x=2*cos(t); y=2*sin(t); label=2;};
border Gamma2(t=0,2*pi){x=0.5*cos(t); y=0.5*sin(t); label=3;};

// construction of mesh of domain $\Omega$
mesh Th=buildmesh(Gamma1(40)+Gamma(-40)); 

fespace Vh(Th,P2);
func f=sqrt(x*x+y*y);
Vh us,v;
macro Grad2(us) [dx(us),dy(us)]  // EOM

problem Lap2dOmega(us,v,init=false)=int2d(Th)(Grad2(v)' *Grad2(us)) - int2d(Th)(f*v)+on(Gamma,us=1) ;
//  Resolution of EDP defined on the domain $\Omega$
// $- \Delta u = f$ on $\Omega$ 
//      $u = 1$  on $\Gamma
//   + Null Neumann condition on $\Gamma_{1}$
Lap2dOmega;

// construction of mesh of domain $\Omega1 =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
mesh Th1=buildmesh(Gamma(40)+Gamma2(-40));

fespace Vh1(Th1,P2);
func f1=10*sqrt(x*x+y*y);
Vh1 u1,v1;
macro Grad21(u1) [dx(u1),dy(u1)]  // EOM

problem Lap2dOmega1(u1,v1,init=false)=int2d(Th1)(Grad21(v1)' *Grad21(u1)) - int2d(Th1)(f1*v1)+on(Gamma,u1=1) ;
//   Resolution of EDP defined on the domain $\Omega_{1}$
// $- \Delta u = f1$ on $\Omega_{1}$ 
//      $u = 1$ on $\Gamma$
//   + Null Neumann condition on $\Gamma_{2}$
Lap2dOmega1; 

// vizualisation of solution of the initial problem
medit("solution",Th,us,Th1,u1,order=1,meditff="ffmedit",save="testsavemedit.solb",wait=1);	
verbosity=2;

mesh3 Th("dodecaedre01");
fespace Vh(Th,P23d);
func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func f= -18. ;
//Vh uhe = ue; // bug ..
//cout << " uhe min:  " << uhe[]. min << " max:" << uhe[].max << endl;
/*
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);


Vh u,v;

//uhe = ue;
macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)=int3d(Th)(Grad3(v)' *Grad3(u)) - int3d(Th)(f*v) + - int3d(Th)(f*v) + on(0,1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
cout << int3d(Th)(1.) << " = " << Th.measure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
Vh2 u2=u;
plot(u2,wait=1);
plot(u2,wait=1);
	{ ofstream file("dd.bb"); 
	file << "3 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << d[][j] << endl; 
    }  
*/
---
name: tetgenholeregion
category: mesh
layout: 3d
---

## Various Experiments with TetGen

First the surface mesh of a sphere is built by mapping the mesh of a square.

The first step is to obtain an adapted periodic mesh for a rectangle

~~~freefem
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
//medit("squaremesh",Th,wait=1);
plot(Th);
~~~

Next, $\texttt{movemesh23}$ will be used to map a 2d mesh to a 3d shape

~~~freefem
verbosity=2;
// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;
//savemesh(Th,"Th.mesh");
meshS Th3sph=movemesh23(Th,transfo=[f1min,f2min,f3min],orientation=-1);
//savemesh(Th3sph,"sphereR1.mesh");
//medit("sphereR1",wait=1,Th3sph);
plot(Th3sph);
~~~

Now the same operation is done to construct a bigger sphere

~~~freefem
real Rmax  = 2.;
func f1max = Rmax*f1;
func f2max = Rmax*f2;
func f3max = Rmax*f3;
meshS Th3sph2=movemesh23(Th,transfo=[f1max,f2max,f3max],orientation=1);
cout << "=====================" << endl;
//savemesh(Th3sph2,"sphereR2.mesh");
cout << "addition" << endl;
meshS Th3=Th3sph+Th3sph2;
//savemesh(Th3,"sphereAdd.mesh");
//medit("sphereSurfaceAdd",wait=1,Th3);
plot(Th3);
~~~

Now that we have a sphere inside another, tegen is called

~~~freefem
real[int] domain2 = [1.5,0.,0.,145,0.001,0.5,0.,0.,18,0.01];
cout << "==============================" << endl;
cout << " tetgen call without hole " << endl;
cout << "==============================" << endl;
mesh3 Th3fin=tetg(Th3,switch="paAAYYCCV",nbofregions=2,regionlist=domain2);
cout << "=============================" << endl;
cout << "finish: tetgen call without hole" << endl;
cout << "=============================" << endl;
//savemesh(Th3fin,"spherewithtworegion.mesh");
//medit("spherewithtworegion",wait=1,Th3fin);
plot(Th3fin);
~~~

Finally the inner sphere is defined as a hole and tetgen is called again

~~~freefem
real[int] hole = [0.,0.,0.];
real[int] domain = [1.5,0.,0.,53,0.001];
cout << "=============================" << endl;
cout << "  tetgen call with hole   " << endl;
cout << "=============================" << endl;
mesh3 Th3finhole=tetg(Th3,switch="paAAYCCV",nbofholes=1,holelist=hole,nbofregions=1,regionlist=domain);
cout << "=============================" << endl;
cout << "finish: tetgen call with hole   " << endl;
cout << "=============================" << endl;
//savemesh(Th3finhole,"spherewithahole.mesh");
//medit("spherewithahole",wait=1,Th3finhole);
plot(Th3finhole);
~~~

| The final result       |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/TetgenholeRegion/solution.png
---
name: cylinder-3d
category: mesh
folder: 3d
---
## Build volumic or surface meshes of a 3d cylinder

This is a very simple example to show how to build a 3d mesh of a cylinder by extruding the 2d mesh of a circle
~~~freefem
load "medit"// contains the interface with medit graphic display
load "tetgen"// used by the second part of this program

border C(t=0,2*pi) { x = cos(t); y=sin(t); label=1;}
mesh Baseh = buildmesh(C(20));
plot(Baseh,wait=0);// press return to go to the next plot

int[int] rup=[0,1],  rdown=[0,2], rmid=[1,3];
func zmin= 1;
func zmax= 10;
int nlayer=100;
mesh3 Th=buildlayers(Baseh,nlayer,
  coef= 1.,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
// To see the volumic mesh use the f1 then f2 control functions on the keyboard
medit("Cyl1",Th,wait=1); // press escape in the medit window to go to the next plot

plot(Th,cmm="Cyl1");
~~~

| The solution is on the figure below |
|------------------------|
|![][_cylinder]          |


## Build a 2d mesh of a 3d cylinder

Here we wrap above the mesh of a 2d disk the mesh of a square and close it with the mesh of the same 2d disk but at the top of the cylinder.  We need to call $\texttt{Tetgen}$ functions.
Here the axis of the cylinder is Ox
~~~freefem
int nx=10; // nomber of points along the axis
int nth=50; // number of points on the cercle
real xmin=1.,xmax=3.; // bottom and top of the cylinder

// The mesh of the disk
mesh Thcercle = buildmesh(C(nth));

// This mesh will be wrapped around and above the bottom cercle
mesh Thcarre=square(nx,nth,[xmin+x*(xmax-xmin),2*pi*y]);
~~~
We use $\texttt{movemesh23}$ to transform the mesh of the square into a lateral circular mesh; the same function is used to translate the mesh of the disk at $\texttt{xmin}$ and $\texttt{xmax}$ perpendicular to Ox.
~~~freefem
cout<<" Build a lateral mesh\n";
func f1 = x;
func f2 = cos(y);
func f3 = sin(y);
meshS Thsurf1=movemesh23(Thcarre,transfo=[f1,f2,f3],orientation=-1);
meshS Thsurf2=movemesh23(Thcercle,transfo=[xmin,x,y],orientation=-1);
meshS Thsurf3=movemesh23(Thcercle,transfo=[xmax,x,y],orientation=1);
~~~
Finally the 3 meshes are glued
~~~freefem
meshS Thsurf=Thsurf1+Thsurf2+Thsurf3; // To see that the mesh is surfacic only use the f1 then f2 control functions. To close the window hit the escape key
medit("Cyl2",Thsurf,wait=1);
~~~
If a volumic mesh is desired from the surface mesh (to fill it inside with tetraedra, use the $\texttt{Tetgen}$ function as follows
~~~freefem
real voltet= ( ( (2*pi)/50 )^3 )/6.;
cout << "  voltet = " << voltet << endl;
real[int] domaine = [1.5,0.,0.,1,voltet];
mesh3 Th2=tetg(Thsurf,switch="pqaaAAYYQ",nbofregions=1,regionlist=domaine);

//savemesh(Th,"cyl.mesh");
medit("Cyl3",Th2,wait=1);
// FFCS: testing 3d plots
plot(Th2,cmm="Cyl3");
~~~

| This mesh is surfacic |
|-----------------------|
|![][_surface]          |

| This mesh is volumic |
|----------------------|
|![][_volume]          |

[_cylinder]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cylinder-3d/cylinder.png

[_surface]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cylinder-3d/surface.png

[_volume]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cylinder-3d/volume.png
---
name: fallingspheres
category: mesh
folder: 3d
---

## Test of mmg3d for moving objects in a mesh
The mesh around 2 spheres in a box is built, starting with the surface mesh of the 3 shapes
~~~freefem
load "tetgen" 
load "medit" 
load "mmg3d-v4.0"
include "MeshSurface.idp"

// build mesh of a box (311)  wit 2 holes  (300,310)

real hs = 0.8; 
int[int]  N=[4/hs,8/hs,11.5/hs];
real [int,int]  B=[[-2,2],[-2,6],[-10,1.5]];
int [int,int]  L=[[311,311],[311,311],[311,311]];
meshS ThH = SurfaceHex(N,B,L,1);
meshS ThSg = Sphere(1,hs,300,-1); // "gluing" surface meshs to tolat boundary meshes
meshS ThSd = Sphere(1,hs,310,-1); 

plot (ThH,ThSg,ThSd);
ThSd=movemesh(ThSd,[x,4+y,z]);

meshS ThHS=ThH+ThSg+ThSd;
medit("ThHS", ThHS); // strike the esc key to continue

~~~
The surface mesh ThHS is input for the TetGen  function $\texttt{tetg}$.

~~~freefem
real voltet=(hs^3)/6.;
cout << " voltet = " << voltet << endl;
real[int] domaine = [0,0,-4,1,voltet];
real [int] holes=[0,0,0,0,4,0];
mesh3 Th = tetg(ThHS,switch="pqaAAYYQ",regionlist=domaine,holelist=holes);    
medit("Box-With-two-Ball",Th);
~~~
You may check that Th is a volumic mesh by using the option key f1 and f2 within medit window.

Now the 2 spheres will be moved vertically  with velocity vit. The rest of the mesh is moved according to uh which is solution of the Laplacian with uh=vit on the sheres and 0 on the box.
~~~freefem
verbosity=0;
real[int] vit=[0,0,-0.3];
func zero = 0.;
func dep  = vit[2];

fespace Vh(Th,P1); 
macro Grad(u) [dx(u),dy(u),dz(u)] //

Vh uh,vh; //  to compute the displacemnt field 
problem Lap(uh,vh,solver=CG) = int3d(Th)(Grad(uh)'*Grad(vh))  //') for emacs
				  + on(310,300,uh=dep) +on(311,uh=0.); 

for(int it=0; it<29; it++){ 
  cout<<"  ITERATION       "<<it<<endl;
  Lap;
  plot(Th,uh, wait=1); // hit return to compute the next time step
  Th=mmg3dv4(Th,opt="-O 9",displacement=[zero,zero,uh]); 
 }
~~~

| The solution           |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/fallingspheres/solution.png
---
name: Laplace-Adapt-3d
category: Applied Math
folder: 3d
---

## Solve the Laplace Equations in a Cube with Discontinous Galerkin Method of degree 1 and mesh refinement

This is a continuation of LapDG3d1.md. The problem is the same
$$
-\Delta u = f,\texttt{ in } \Omega\quad u|_{\partial\Omega}=g
$$
where $\Omega$ is the unit cube minus a half unit cube, $f=1$, $g=1$.
The finite element space chosen if the discontinuous $P^1$.

The unit cube is constructed in a different way with $\texttt{buildlayers}$.

~~~freefem
load "tetgen"
load "mshmet"
load "medit"
//build initial mesh
int nn  = 6;
int[int] l1111=[1,1,1,1],l01=[0,1],l11=[1,1];//   label numbering 
mesh3 Th3=buildlayers(square(nn,nn,region=0,label=l1111),
      nn,  zbound=[0,1],  labelmid=l11,   labelup = l01,  labeldown = l01);
Th3 = trunc(Th3,(x<0.5) | (y < 0.5) | (z < 0.5) ,label=1);// remove the $]0.5,1[^3 cube$
//end of build initial mesh
fespace Vh(Th3,P1);
Vh u,v,usol;

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

problem Poisson(u,v,solver=CG) = int3d(Th3)( Grad(u)'*Grad(v) )  // ') for emacs 
  -int3d(Th3)( 1*v ) + on(1,u=0);

real errm=1e-2; // level of error

~~~

The  function $\texttt{mshmet}$ refine a mesh from the given Th3 mesh using a metric constructed from the Hessian of $u$, to be used in conjunction with $\texttt{tetgreconstruction}$.
~~~freefem
for(int ii=0; ii<5; ii++)
{
  Poisson;
  cout <<" u min, max = " <<  u[].min << " "<< u[].max << endl;
  Vh h ;
  h[]=mshmet(Th3,u,normalization=1,aniso=0,nbregul=1,hmin=1e-3,hmax=0.3,err=errm);//loptions=MSHloptions,doptions=MSHdoptions);
  cout <<" h min, max = " <<  h[].min << " "<< h[].max << " " << h[].n << " " << Th3.nv << endl;
  // FFCS: add 3D view parameters
  plot(u,wait=1,fill=0,boundary=0,CutPlane=0,ShowMeshes=1,LabelColors=0);
  errm*= 0.8;// change the level of error
  cout << " Th3" << Th3.nv < " " << Th3.nt << endl;
  Th3=tetgreconstruction(Th3,switch="raAQ",sizeofvolume=h*h*h/6.);
  medit("U-adap-iso-"+ii,Th3,u,wait=1);
}
~~~

| The initial mesh       |
|------------------------|
|![][_solution1]         |

|The mesh after 3 refinement |
|----------------------------|
|![][_solution2]             |

| The mesh after  5 refinement |
|------------------------------|
|![][_solution4]               |

| The solution is recomputed after 5 refinement |
|-------------------------|
|![][_solution5]          |

[_solution1]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Laplace-Adapt-3d/solution1.png

[_solution2]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Laplace-Adapt-3d/solution2.png

[_solution4]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Laplace-Adapt-3d/solution4.png

[_solution5]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Laplace-Adapt-3d/solution5.png
---
name: adaptsphere
category: mesh
layout: 3d
---

## Construct three 3d meshes of a sphere by varying one parameter in tetgen

The mesh is built by mapping the mesh of a square on a sphere and then call $\texttt{tetg}$.
~~~freefem
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

meshS ThS=movemesh23(Th,transfo=[f1min,f2min,f3min]);

real[int] domain = [0.,0.,0.,145,0.01];
mesh3 Th3sph=tetg(ThS,switch="paAAQYY",nbofregions=1,regionlist=domain);

int[int] newlabel = [145,18];
real[int] domainrefine = [0.,0.,0.,145,0.0001];
mesh3 Th3sphrefine=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel,nbofregions=1,regionlist=domainrefine,sizeofvolume=0.0001);

int[int] newlabel2 = [145,53];
func fsize = 0.01/(( 1 + 5*sqrt( (x-0.5)^2+(y-0.5)^2+(z-0.5)^2) )^3);
mesh3 Th3sphrefine2=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel2,sizeofvolume=fsize);
/*
medit("sphere",Th3sph,wait=1);
medit("sphererefinedomain",wait=1,Th3sphrefine);
medit("sphererefinelocal",wait=1,Th3sphrefine2);
*/
plot(Th3sph);
plot(Th3sphrefine);
plot(Th3sphrefine2);
~~~
---
name: cone
category: mesh
folder: 3d
---

## Build a volumic mesh of a cone

| Easiest is build a 2D generator curve, here it is a triangle,|
|------------------------|
|![][_Triangle]          |

|and then use a 2D mesh.|
|-----------------------|
|![][_mesh2D]           |

~~~freefem
include "ball-buildlayer.idp"
load "medit"
// cone using buildlayers with a triangle 
real RR=1,HH=1; 
border Taxe(t=0,HH){x=t;y=0;label=0;};
border Hypo(t=1,0){x=HH*t;y=RR*t;label=1;};
border Vert(t=0,RR){x=HH;y=t;label=2;};

int nn=10;
real h= 1./nn;
plot( Taxe(HH*nn)+ Hypo(sqrt(HH*HH+RR*RR)*nn) + Vert(RR*nn), dim=2, wait=1 );
mesh Th2=buildmesh(  Taxe(HH*nn)+ Hypo(sqrt(HH*HH+RR*RR)*nn) + Vert(RR*nn) ) ;
plot(Th2,wait=1);
~~~
 and lift it 3D by  rotation around an axis
~~~freefem
mesh3 Th3T=BuildAxiOx(Th2,h);
//medit("cone",Th3T,wait=1);
plot(Th3T,cmm="cone");
~~~

| The final result: |
|-------------------|
|![][_cone]         |


[_Triangle]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cone/Triangle.png

[_mesh2D]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cone/mesh2D.png

[_cone]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cone/cone.png
load "tetgen"
load "medit"
// Maillage d'un cylindre d'axe 0x
// 
int nx=10; // nombre de points le long de l'axe
int nth=50; // nombre de points sur la circonference
real xmin=1.,xmax=3.;
// Maillage de cercles pour les deux faces
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Thcercle = buildmesh(cc(nth));

// Maillage de carre qui va etre applique au bord du cylindre ave movemesh23
mesh Thcarre=square(nx,nth,[xmin+x*(xmax-xmin),2*pi*y]);
//plot(Thcarre);

// parametrisation d'un cylindre d'axe Ox
func f1 = x;
func f2 = cos(y);
func f3 = sin(y);
meshS Thsurf1=movemesh23(Thcarre,transfo=[f1,f2,f3],orientation=-1);
meshS Thsurf2=movemesh23(Thcercle,transfo=[xmin,x,y],orientation=-1);
meshS Thsurf3=movemesh23(Thcercle,transfo=[xmax,x,y],orientation=1);
meshS Thsurf=Thsurf1+Thsurf2+Thsurf3;
real voltet= ( ( (2*pi)/50 )^3 )/6.;
cout << "  voltet = " << voltet << endl;
real[int] domaine = [1.5,0.,0.,1,voltet];
mesh3 Th=tetg(Thsurf,switch="pqaaAAYYQ",nbofregions=1,regionlist=domaine);

savemesh(Th,"cyl.mesh");
medit("cyl",Th,wait=1);
// FFCS: testing 3d plots
plot(Th,cmm="cyl");
---
name: LapDG3d
category: Applied Math
folder: 3d
---

## Solve the Laplace Equations in a Cube with Discontinous Galerkin Method of degree 2

based on paper by Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
called "A priori error estimates for finite element methods based on discontinuous approximation spaces for elliptic problems. SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).

solve $ -\Delta u = f$ in $\Omega$ with $u= g$ on $\Gamma$.
The domain is the unit cube
~~~freefem
int nn=5;
mesh3 Th = cube(nn,nn,nn);
~~~
Two FE spaces are tested: $P^2$ and $P^2$-discontinuous element.  Notice that the formulation is non-symmetric.
~~~freefem
macro grad(u) [dx(u),dy(u),dz(u)] //
macro dn(u) (N'*grad(u) ) //'  def the normal derivative
int[int] labs=labels(Th);
fespace Vh(Th,P2dc3d);     // Discontinous P2 finite element
fespace Xh(Th,P2);
real pena=1e2; //to add penalisation for Vh, not needed if Xh is used
func f=1;
func g=0;
Vh u,v;
Xh uu,vv;
problem A(u,v,solver=sparsesolver) = 
   int3d(Th)( grad(u)'*grad(v)) //'
 + intallfaces(Th)(//  loop on all  edges of all triangles
           ( jump(v)*mean(dn(u)) -  jump(u)*mean(dn(v)) 
          + pena*jump(u)*jump(v) ) / nElementonB 
)
- int3d(Th)(f*v) 
- int2d(Th)(g*dn(v)  + pena*g*v) 
;
problem A1(uu,vv,solver=sparsesolver) 
= 
 int3d(Th)(grad(uu)'*grad(vv))//'
  - int3d(Th)(f*vv) + on(labs,uu=g);
 
 A; // solve  DG
 A1; // solve continuous

 real err= sqrt(int3d(Th) ( sqr(u-uu)));
 cout << " err= "<< err<< " " << u[].linfty << " " << uu[].linfty << endl; 
plot(u,uu,cmm="Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
assert(err< 0.01);
~~~

| The solution           |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/LapDG3d/solution.png
mesh3 Th("dodecaedre01.mesh");
fespace Vh(Th,P23d);
Vh[int] u(10);
u[1]=x;
cout << " u[1].l2 =" << u[1][].l2 << endl;
---
name: NSI3d-carac
category: Fluid Mechanics
layout: 3d
---

## Time dependent imcompressible Navier-Stokes Equation in 3D solved by using characteristics

The Navier-Stokes equations are solved in a cube
The time independent Navier-Stokes equations for an incompressible fluid are
$$
\frac{\partial u}{\partial t}-\nu\Delta u +u\cdot\nabla u -\nabla p =0,~~~\nabla\cdot u=0~~~in ~ \Omega.
$$

The driven cavity problem has the upper side of the cube moving at velocity (1,0,0) and the other walls are at rest. By using
$$
\frac{\partial u}{\partial t} + +u\cdot\nabla u  \approx \frac1{\delta t}(u^{n+1}-u^n(x-\delta t u^n)
$$
the problem being linear at each time step, it is solved like a linear system.

The velocities are approximated with  $P^2$ elements and the pressure by a $P^2$ element (Taylor-Hood element)

The mesh is built, as usual by extrusion of a square vertically.
~~~freefem
newconvect=1;
real nu=0.01,dt=0.3;
real alpha=1./dt,alpha2=sqrt(alpha);

int nn=10;

mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
~~~
The finite element spaces are defined and the matrix of the linear system for the Stokes system because it will be our initial start in time
~~~freefem
fespace VVh(Th,[P23d,P23d,P23d,P13d]);
fespace Vh(Th,P23d);
fespace Ph(Th,P13d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  
  varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3)
             - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
 +  on(2,u1=1.,u2=0,u3= 0)
 + on(1,u1=0,u2=0,u3=0)
 ;

cout << "b  mat " << endl;

matrix A=vStokes(VVh,VVh);
cout << "e  mat " << endl;
~~~
The solution method is defined and the right hand side $b$.
~~~freefem
set(A,solver=sparsesolver,dimKrylov=1000);
cout << "e fac  mat " << endl;
real[int] b= vStokes(0,VVh);

VVh [u1,u2,u3,p];
VVh [X1,X2,X3,Xp];
VVh [x1,x2,x3,xp]=[x,y,z,0];

u1[]= A^-1 * b;  // Solves the Stokes problem

ux= u1(x,0.5,y);
uz= u3(x,0.5,y);
p2= p(x,0.5,y);
plot([ux,uz],p2,cmm=" cut y = 0.5",wait=1);
~~~
Now the matrix for the Navier-Stokes equations is defined
~~~freefem
macro XX1() (x-u1*dt)//
macro XX2() (y-u2*dt)//
macro XX3() (z-u3*dt)//

  varf vNS([uu1,uu2,uu3,p],[v1,v2,v3,q]) = 
  int3d(Th)( alpha*(uu1*v1+uu2*v2+uu3*v3) + nu*(Grad(uu1)'*Grad(v1) +  Grad(uu2)'*Grad(v2) +  Grad(uu3)'*Grad(v3)) //'
  - div(uu1,uu2,uu3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,uu1=1,uu2=0,uu3=0)
  + on(1,uu1=0,uu2=0,uu3=0)
 
    +  int3d(Th,optimize=1,qforder=4)(   alpha*(  convect([u1,u2,u3],-dt,u1)*v1  +   convect([u1,u2,u3],-dt,u2)*v2  +   convect([u1,u2,u3],-dt,u3)*v3 )  ) ;

cout << " build  A" << endl;
A = vNS(VVh,VVh);
cout << " fac A" << endl;

set(A,solver=sparsesolver,dimKrylov=1000);
~~~
The time loop is here
~~~freefem
real t=0;
for(int i=0;i<10;++i)
  {
    t += dt;
    cout << " iteration " << i << " t = " << t << endl;
    X1[]=x1[]+u1[]*(-dt);
    b=vNS(0,VVh);
    verbosity=2;
    u1[]= A^-1 * b;
    ux= u1(x,0.5,y);
    uz= u3(x,0.5,y);
    p2= p(x,0.5,y);
    plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=0);
    // to store the solution one uses these
    if(i%5==6)
    {
      exec("mkdir dd");
      string prefu="dd/u-"+(100+i);
      string prefp="dd/p-"+(100+i);
      savemesh(Th,prefu+".mesh");
      savemesh(Th,prefp+".mesh");
     
      ofstream file(prefu+".bb"); 
      ofstream filep(prefp+".bb"); 
      Ph up1=u1,up2=u2,up3=u3,pp=p;
      file << "3 1 3 "<< up1[].n << " 2 \n";
      filep << "3 1 1 "<< pp[].n << " 2 \n";
      for (int j=0;j<up1[].n ; j++)  
	{
	  file << up1[][j] <<" " <<up2[][j] <<" "<< up3[][j] <<"\n";
	  filep << pp[][j] <<  endl; 
	}  
    }
  }
plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=1);
~~~

|The solution with a  1000 vertices mesh |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/NSI3d-carac/solution.png
---
name: first
category: mesh
folder: 3d
---

## Manipulation of various data from a mesh and the solution of a PDE, prints of all kind.
One mesh is read from a file  the other is built from a circular boundary
~~~freefem
verbosity=2;
mesh3 Th("dodecaedre01");
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
~~~
For the $P^2$ elements various quantities are printed.
~~~freefem
fespace Vh2(Th2,P2);
int nbtets=Th.nt;
cout << " Th mes " << Th.measure << " border mes " << Th.bordermeasure << endl;
cout << " nb of Tets = " << nbtets << endl;
if(1) {
  nbtets=2;
  for (int i=0;i<nbtets;i++)
    for (int j=0; j <4; j++)
      cout << i << " " << j << " Th[i][j] = "
	   << Th[i][j] << "  x = "<< Th[i][j].x  << " , y= "<< Th[i][j].y 
	   << ",  label=" << Th[i][j].label << endl;
	    
//   Th(i)   return   the vextex i of Th
//   Th[k]   return   the tet k of Th.

  // get vertices information : 
  int nbvertices=Th.nv;
  //nbvertices=2;
  cout << " nb of vertices = " << nbvertices << endl;
  for (int i=0;i<nbvertices;i++)
	cout << "Th(" <<i  << ") : "   // << endl;	
	     << Th(i).x << " " << Th(i).y  << " " << Th(i).z << " " << Th(i).label  << endl;
int k=0,l=1,e=1;
~~~
These instructions do nothing
~~~freefem
Th.nbe ; // return the number of boundary elements
Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$
Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of boundary element k
Th.be(k).Element ;   // return the tet containing the boundary element k
Th.be(k).whoinElement ;  // return the egde number of triangle containing the boundary element k
Th[k].adj(e) ;
~~~
return adjacent tet to k by face e, and change the value of e to the corresponding face in the adjacent tet
~~~freefem
Th[k] == Th[k].adj(e) ;// non adjacent tet return the same
  Th[k] != Th[k].adj(e) ;// true adjacent tet 
  Th.be(k).N;   // return the Normal  of  boundary element k
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2]) 
         << " " <<  int(Th[k][3])
	 << " , label  " << Th[k].label << endl; 
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<4;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N=" << Th.be(k).N << endl; 
    
	  
savemesh(Th,"dd.meshb");
 }
~~~
This finite element space is also $P^2$
~~~freefem
fespace Vh(Th,P23d);
Vh xx=x;
if(xx[].n == Th.nv)
  for(int i=0;i<Th.nv;++i)
    assert(abs(Th(i).x-xx[][i])<1e-6);

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func f= -18. ;
Vh u=f,b,d,uhe=ue,bc;
cout << " Vh.ndof =  " <<  Vh.ndof << endl;
cout << "  Vh.ndofK " << Vh.ndofK << endl;
cout << Th[5].region << endl;
// cout << Th(0,0,0).region << endl;  a faire ...
cout << Th[5][3] << endl;  // ok.. 

for(int i=0;i<Vh.ndofK;++i )
  cout << Vh(11,i) << " ";
 cout << endl;

cout << ue(0.1,0.2,0.3)<< "  == " << f(0.1,0.2,0.3) << endl;
~~~
Now a PDE is solved by building first the matrix
~~~freefem
macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

varf vbc(u,v) =  on(0,u=1);
varf vlap(u,v) = int3d(Th)(Grad3(v)' *Grad3(u))//'
 + int3d(Th)(f*v) + on(0,u=ue);
varf vBord(u,v,solver=CG) = int2d(Th)(u*v) ;
verbosity=10; 
matrix A=vlap(Vh,Vh);
matrix B=vBord(Vh,Vh);
verbosity=1; 
b[]=vlap(0,Vh);
//bc[]=vbc(0,Vh);
//cout << bc[] <<endl;
{
ofstream fa("A.txt");
ofstream fb("B.txt");
fa << A ;
fb << b[] ;
}

cout << b[]. min << " " << b[].max << endl;
u[]=A^-1*b[];
cout << u[]. min << " " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
d= ue-u;
cout <<  " err = " << err <<  " " << d[].linfty << endl;
cout << " u (0,0,0) "<< u(0.,0.,0.) << endl;
cout << " dx(u) (0,0,0) "<< dx(u)(0.,0.,0.) << endl;
cout << " dy u (0,0,0) "<< dy(u)(0.,0.,0.) << endl;
cout << " dz u (0,0,0) "<< dz(u)(0.,0.,0.) << endl;
Vh2 u2=u(x,y,0.);
plot(u2,wait=1);
plot(u2,wait=1);
	{ ofstream file("dd.bb"); 
	file << "3 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << d[][j] << endl; 
    }  
~~~
---
name: schwarz-nm-3d
category: math
layout: 3d
---

## Use metis to split a triangulation then solve a Laplacian by Schwarz DDM

The mesh of a cube is split using metis.
~~~freefem
bool withmetis=1;
bool RAS=0;
int sizeoverlaps=2; // size off overlap 
int nnx=2,nny=2,nnz=2;

func bool AddLayers(mesh3 & Th,real[int] &ssd,int n,real[int] &unssd)
{
  //  build a continuous function  uussd (P1) :
  //  ssd in the caracteristics function on the input sub domain.
  //  such that : 
  //   unssd = 1 when   ssd =1;
  //   add n layer of element (size of the overlap)
  //   and unssd = 0 ouside of this layer ...
  // ---------------------------------
  fespace Vh(Th,P1);
  fespace Ph(Th,P0);
  Ph s;
  assert(ssd.n==Ph.ndof);
  assert(unssd.n==Vh.ndof);
  unssd=0;
  s[]= ssd;
  //  plot(s,wait=1,fill=1);
  Vh u;
  varf vM(u,v)=int3d(Th,qforder=1)(u*v/volume);
  matrix M=vM(Ph,Vh);
  
  for(int i=0;i<n;++i)
    {
      u[]= M*s[];
      // plot(u,wait=1);
      u = u>.1; 
      // plot(u,wait=1);
      unssd+= u[];
      s[]= M'*u[];//'
      s = s >0.1;
    }
  unssd /= (n);
  u[]=unssd;
  ssd=s[];      
  return true;
}

int withplot=3;
include "cube.idp" 
 int[int]  NN=[25,25,25]; //  the number of step in each  direction                                                                                                                    
 real [int,int]  BB=[[0,1],[0,1],[0,1]]; // bounding box                                                                                                             
 int [int,int]  L=[[1,1],[1,1],[1,1]]; // the label of the 6 face left,right,
//  front, back, down, right
mesh3 Th=Cube(NN,BB,L);
int npart= nnx*nny*nnz;
fespace Ph(Th,P0);
fespace Vh(Th,P1);

Ph  part;
Vh  sun=0,unssd=0;
Ph xx=x,yy=y,zz=z,nupp;
//part = int(xx*nnx)*nny + int(yy*nny);
part = int(xx*nnx)*nny*nnz + int(yy*nny)*nnz + int(zz*nnz);
//plot(part,wait=1);
if(withmetis)
  {
    load "metis";
    int[int] nupart(Th.nt);
    metisdual(nupart,Th,npart); 
    for(int i=0;i<nupart.n;++i)
      part[][i]=nupart[i];
  }
if(withplot>1)
plot(part,fill=1,cmm="dual",wait=1);
~~~
Then the PDEs are prepared
~~~freefem
mesh3[int] aTh(npart);
mesh3 Thi=Th;
fespace Vhi(Thi,P1);
Vhi[int] au(npart),pun(npart);
matrix[int] Rih(npart);
matrix[int] Dih(npart);
matrix[int] aA(npart);
Vhi[int] auntgv(npart);
Vhi[int] rhsi(npart);

for(int i=0;i<npart;++i)
  {
    Ph suppi= abs(part-i)<0.1;
    AddLayers(Th,suppi[],sizeoverlaps,unssd[]);
    Thi=aTh[i]=trunc(Th,suppi>0,label=10,split=1);
    Rih[i]=interpolate(Vhi,Vh,inside=1); //  Vh -> Vhi
    if(RAS)
      {
        suppi= abs(part-i)<0.1;
        varf vSuppi(u,v)=int3d(Th,qforder=1)(suppi*v/volume);
        unssd[]= vSuppi(0,Vh);
        unssd = unssd>0.;
        if(withplot>19)
          plot(unssd,wait=1);
      }
    pun[i][]=Rih[i]*unssd[];
    sun[] += Rih[i]'*pun[i][];//';
    if(withplot>9)
      plot(part,aTh[i],fill=1,wait=1);
  }
real[int] viso=[0,0.1,0.2,0.3];  
plot(sun,wait=1,dim=3,fill=1,viso=viso);
for(int i=0;i<npart;++i)
  {
    Thi=aTh[i];
    pun[i]= pun[i]/sun;
    if(withplot>8)
      plot(pun[i],wait=1);    
  }

//  verif partition of unite 

macro Grad(u) [dx(u),dy(u),dz(u)]//EOM 
  sun=0;

for(int i=0;i<npart;++i)
  {
    cout << " build part :" << i << "/" << npart << endl;
    Thi=aTh[i];
    varf va(u,v) = 
      int3d(Thi)(Grad(u)'*Grad(v))//')
      +on(1,u=1) + int3d(Thi)(v)
      +on(10,u=0) ; 
    
    cout << i << " -----------Vhi.ndof " << Vhi.ndof << endl;
    aA[i]=va(Vhi,Vhi);
      cout << i << " -----------Vhi.ndof " << Vhi.ndof << endl;
  
    set(aA[i],solver="SPARSESOLVER");
    rhsi[i][]= va(0,Vhi);
    Dih[i]=pun[i][];
    real[int]  un(Vhi.ndof);
    un=1.;
    real[int] ui=Dih[i]*un; 
    sun[] += Rih[i]'*ui;;//';
    varf vaun(u,v) = on(10,u=1);
    auntgv[i][]=vaun(0,Vhi); // store array of tgv on Gamma intern.
  }
if(withplot>5)
  plot(sun,fill=1,wait=1);
cout << sun[].max << " " << sun[].min<< endl;
// verification of the partition of the unite.
assert( 1.-1e-9 <= sun[].min  && 1.+1e-9 >= sun[].max);  
~~~
The Schwarz iterations are implemented
~~~freefem
int nitermax=1000;
{
  Vh un=0;
  for(int iter=0;iter<nitermax;++iter)
    {
      real err=0;
      Vh un1=0;
      for(int i=0;i<npart;++i)
        {
          Thi=aTh[i];
          real[int] ui=Rih[i]*un[];//';
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          real[int] bi = ui .* auntgv[i][];
          bi = auntgv[i][] ? bi :  rhsi[i][];  
          ui=au[i][];
          ui= aA[i] ^-1 * bi;
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          bi = ui-au[i][];
          err += bi'*bi;//';
          au[i][]= ui;
          bi = Dih[i]*ui;
          un1[] += Rih[i]'*bi;//';
        }
      err= sqrt(err);
      cout << iter << " Err = " << err << endl;
      if(err<1e-3) break;
      //    plot(un1,wait=1);
      un[]=un1[];
      if(withplot>2)
        plot(au,dim=3,wait=0,cmm=" iter  "+iter,fill=1 );
    }
  plot(un,wait=1,dim=3,fill=1);
}
~~~

|The solution            |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/schwarz-nm-3d/solution.png
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.
cout << "--------- file : 3d-Leman.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "3d-Leman.edp";
	real TEST3dXLeman=vregtest;
		cout<<"3d-Leman reference value = "<<REF3dXLeman
				<<" test value ="<<TEST3dXLeman<<endl;
			assert(TEST3dXLeman<REF3dXLeman*(1+0.1));
				assert(TEST3dXLeman>REF3dXLeman*(1-0.1));
};



---
name: bottle
category: Solid Mechanics
folder: 3d
author: F. Hecht
---
## Build the mesh of a bottle
The bottle is axisymmetric and has a neck similar to those of wine bottles. The program constructs a closed (the bottle has a cork)  surface mesh Ths. First one construct the generatrix using spline interpolations of polygonal curves from the library GSL (Gnu Scientific Library) and then rotate it around the z-axis.

| The end product: a bottle |
|---------------------------|
|![][_bottle]               |

~~~freefem
load "medit"
load "gsl"
load "tetgen"
real hh=.15;// mesh size

real Htube=8; 
real Hneck=2;
real Hbot=Htube+Hneck;

real Rext = 1.;// External radius
real Rneck= 0.2; // Radius of the neck of the bootle
int labtop =3, labbottom =2, labcyl = 1;

meshS Ths;
{
meshS Th3c,Th3bottom, Th3top;
{
// form of the neck ... 	
real[int,int] srneck= 
[
 [Htube-0.001,Htube,Htube+Hneck*0.1, Htube+Hneck*0.3, Htube+Hneck*0.7, Htube+Hneck*0.9, Htube+Hneck+0.1], [Rext,Rext ,Rext, Rext*.7+Rneck*.3 , Rext*.1 + Rneck*.9, Rneck, Rneck  ]
 ];
gslspline rneck(gslinterpcspline,srneck);
~~~
 rneck is the curve of the bollte form z = 0 to Hbot neck of the bottle
  One needs to adapt the 2D mesh for a better 3D mesh. Th2c  will be the surface minus top and bottom.
~~~freefem
mesh Th2c= square(Hbot/hh,2*pi*Rext/hh,[x*Hbot,y*2*pi]);
fespace V2x(Th2c,P1);
macro Dx(u) [dx(u#1),dx(u#2),dx(u#3)] // u#1 is the concatenated value of u with 1
macro Dy(u) [dy(u#1),dy(u#2),dy(u#3)] //
// The transformation 
func E1 = rneck(x)*cos(y);
func E2 = rneck(x)*sin(y);
func E3 = x;
V2x ex1,ex2,ex3;
// the metric for adapting the mesh
real hh2 = hh*hh;
func  em11 = Dx(ex)'*Dx(ex)/hh2;
func  em21 = Dx(ex)'*Dy(ex)/hh2;
func  em22 = Dy(ex)'*Dy(ex)/hh2; //'
func perio=[[1,x],[3,x]];
for(int i=0;i<4;++i)
{
 ex1=E1;ex2=E2;ex3=E3; 
 Th2c=adaptmesh(Th2c,em11,em21,em22,IsMetric=1,periodic=perio,nbvx=100000);
}
Th2c=change(Th2c,fregion=labcyl); 
plot(Th2c,wait=1);
~~~

| The mesh Th2c shown below is used to build an axisymmetric body |
|----------------------|
|![][_mesh2d]          |

~~~freefem
Th3c = movemesh23(Th2c,transfo=[E1 , E2 , E3]);// maillage exterieur 
plot(Th3c,wait=1);
//medit("Th3c",Th3c);
}
~~~

| The bottle is open on both ends |
|---------------------------------|
|![][_bottlezero]                 |


The bottom and the top are constructed by gluing 2 meshes of disks but the points on the border must be identical to the borders of the lateral surface
~~~freefem
// extraction of the border of the bottle
int[int] databoder(1);
int ncb= getborder(Th3c,databoder); 
int ktop= Th3c(databoder[databoder[1]]).z < Th3c(databoder[databoder[0]]).z; 
int  kbot=1-ktop;
real Zbot = Th3c(databoder[databoder[kbot]]).z; 
real Ztop = Th3c(databoder[databoder[ktop]]).z; 
cout << " Z  top  " << Zbot  << endl; 
cout << " Z  bot  " << Ztop << endl; 
assert( ncb ==2);
macro DefBorder(bname,kk,Th3,bb,ll)
int n#bname= bb[kk+1]-bb[kk];
border bname(t=bb[kk], bb[kk+1])
{
	real iv = int(t);
	if( iv == bb[kk+1]) iv = bb[kk];

    cout << t << " iv = " << iv << endl;
		iv = bb[iv];
	x= Th3(iv).x ;
	y= Th3(iv).y ;
	label = ll;	
}//
DefBorder(btop,ktop,Th3c,databoder,1)
DefBorder(bbot,kbot,Th3c,databoder,1)
cout << " btop " << nbtop << " bot: " << nbbot << endl;

plot(btop(nbtop)+bbot(-nbbot),wait=1);
Th3bottom=movemesh23(change(buildmesh(bbot(nbbot),fixeborder=1),fregion=labbottom),transfo=[x,y,Zbot],orientation=-1);
Th3top=movemesh23(change(buildmesh(btop(-nbtop),fixeborder=1),fregion=labtop),transfo=[x,y,Ztop],orientation=1);
Ths = Th3c + Th3bottom + Th3top; 
}

real[int] domaine = [0,0,Htube,1,hh^3/6.];
mesh3 Th=tetg(Ths,switch="pqaAYY",regionlist=domaine);
medit("Th",Th);
~~~
Medit can rotate the object. Press "esc" to end medit.


[_bottle]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/bottle/bottle.png


[_mesh2d]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/bottle/mesh2d.png

[_bottlezero]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/bottle/bottlezero.png
---
name: Lac
category: mesh
folder: 3d
---

## Construction of the mesh of a circular lake
First a 2d disk is triangulated
~~~freefem
load "medit"
int nn=10;
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2= buildmesh(cc(100));
~~~
As usual $\texttt{buildlayers}$ is called to extrude the disk up to rdown with varying radius
~~~freefem
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
func zmin= 2-sqrt(4-(x*x+y*y));
func zmax= 2-sqrt(3.);

mesh3 Th=buildlayers(Th2,nn,
  coef=  (zmax-zmin)/zmax ,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
~~~
Display the result
~~~freefem
medit("Lac",Th,wait=1);
// FFCS: testing 3d plots
plot(Th,cmm="Lac");
~~~

| The 3d mesh            |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Lac/solution.png
---
name: Laplace-Adapt-3d
category: Applied Math
folder: 3d
---

## Solve the Laplace Equations in a Cube with Discontinous Galerkin Method of degree 1 and anisotropic mesh refinement

This is a continuation of Laplace-Adapt-3d.md. The problem is the same
$$
-\Delta u = f,\texttt{ in } \Omega\quad u|_{\partial\Omega}=g
$$
where $\Omega$ is the unit cube minus a half unit cube, $f=1$, $g=1$.
The finite element space chosen if the discontinuous $P^1$.

The unit cube is constructed in a different way with $\texttt{buildlayers}$.
~~~freefem
{
load "tetgen"
load "mshmet"
load "medit"
load "mmg"

int nn  = 6;

int[int] lc=[1,2,2,1,1,2]; //  label numbering 

mesh3 Th3=cube(nn,nn,nn,label=lc);
Th3 = trunc(Th3,(x<0.5) | (y < 0.5) | (z < 0.5) ,label=1);

fespace Vh(Th3,P1);
fespace Mh(Th3,[P1,P1,P1,P1,P1,P1]);
Vh u,v,usol,h3;
Mh [m11,m21,m22,m31,m32,m33];
macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

problem Poisson(u,v,solver=CG) = int3d(Th3)( Grad(u)'*Grad(v) )  // ') for emacs 
  -int3d(Th3)( 1*v ) + on(1,u=0);

real lerr=0.05;
verbosity=4;

for(int ii=0; ii<4; ii++) //  BUG trap  in interation 3 
{
  Poisson;
  plot(u,wait=1);
  h3=0;
  [m11,m21,m22,m31,m32,m33]=[0,0,0,0,0,0];
  cout <<" u min, max = " <<  u[].min << " "<< u[].max << endl;
  real cc=(u[].max-u[].min);// rescale coefficiant 
 
  real[int] met=mshmet(Th3,u,hmin=1e-3,hmax=0.2,err=lerr,aniso=1);
  m11[]=met;
  Th3=mmg3d(Th3,metric=m11[],hgrad=2.3);//("oo/Th3.o.mesh");
  
  lerr *= 0.6;// change the level of error
  cout << " Th3" << Th3.nv < " " << Th3.nt << endl;
   u=u;
  if(ii>2) medit("U-adap-iso-"+ii,Th3,u,wait=1);
}
cout <<"end Laplace  Adapt aniso 3d. edp " <<endl;
}
~~~

| The third refined mesh |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Laplace-Adapt-aniso-3d/solution.png
---
name: pyraamid
category: mesh
layout: 3d
---

## Construct the 3d mesh of a pyramid with internal boundaries

The surface mesh of the base is built and then extruded with $\texttt{buildlayers}$
~~~freefem
load "medit"
// cone using buildlayers with a triangle 
real LX=1,LY=1,LXY=sqrt(LX*LX+LY*LY),HH=1; 
border Hypo(t=1,0){x=LX*t;y=LY*(1-t);label=1;};
border Vert(t=LY,0){x=0;y=t;label=0;};
border Hori(t=0,LX){x=t;y=0;label=0;};

int nn=10;
real h= 1./nn;
plot(Vert(LY*nn)+ Hypo(LXY*nn) + Hori(LX*nn),wait=1);
mesh Th2=buildmesh( Vert(LY*nn)+ Hypo(LXY*nn) + Hori(LX*nn) ) ;
 Th2 = Th2 + movemesh(Th2,[x,-y])+ movemesh(Th2,[-x,-y])+  movemesh(Th2,[-x,y]);
plot(Th2,wait=1);
func fpyramide= (1-abs(x)/LX-abs(y)/LY)*HH;
fespace Vh2(Th2,P1);
Vh2 fp2=fpyramide;
plot(fp2,wait=1,dim=3);


int[int] r1T=[0,0], r2up=[0,1],r2down=[0,1];
int[int] r4T=[0,2]; 
mesh3 Th3=buildlayers(Th2,coef= max(fpyramide/HH,0.01), nn,zbound=[0,fpyramide],
 region=r1T, labelup=r2up, labeldown=r2down);

//medit("Pyramide",Th3,wait=1);

plot(Th3);
~~~

|The 3d mesh   |
|--------------|
|![][_solution]|

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/pyramide/solution.png
---
name: crack-3d
category: Solid Mechanics
folder: 3d
---

## Build a 3d mesh with a fissure, check eps in trunc check mesh
We begin with a crack in a circle
~~~freefem
real theta = 1*pi/180.; // 0.7 degree  limit to build the 2d mesh if no refinement in zero
real xt = cos(theta),yt=sin(theta);
cout << xt << " " << yt << endl;
border C(t=theta, 2*pi-theta) { x = cos(t); y=sin(t); label=1;}
border Ss(t=0,1;i){ t= t; x= t*xt; y = t*yt;if(i) y = -y; label=2+i;}
real hs = 0.05;
int nC = (2*pi-2*theta)/hs;
int ns = (1./hs)/1;//   
int[int] nS=[ ns,-ns ];
func bord = C(nC)+Ss(nS); 
plot(bord,wait=1); // check the border is closed
mesh Th2 = buildmesh(bord,nbvx=1000000);
plot(Th2);
~~~

![][_crack2d]

Let us verify that the mesh points are not closed to one another
~~~freefem
int nt = Th2.nt, nv = Th2.nv;
Th2=trunc(Th2,true);// verif to closeness of points
assert(nt==Th2.nt);
assert(nv==Th2.nv);
~~~
The 3d mesh is obtained by a vertical extrusion using $\texttt{buildlayers}$
~~~freefem
mesh3 Th = buildlayers(Th2,1./hs);
plot(Th,wait=1);
 nt = Th.nt;
 nv = Th.nv;
// check mesh
Th=checkmesh(Th); // works only in 3d hence not used above in 2d
assert(nt==Th.nt);
assert(nv==Th.nv);
cout<<"All is well that ends well "<<endl;
~~~

| The final result: |
|-------------------|
|![][_crack3d]      |


[_crack2d]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/crack-3d/crack2d.png

[_crack3d]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/crack-3d/crack3d.png
---
name: Sphere-isocahedron
category: mesh
layout: 3d
---

##  Build a 3d mesh for a sphere by TetGen from a surface mesh

First call $\texttt{Sphere20}$ to build the surface mesh of a sphere, then call $\texttt{tetg}$.
~~~freefem
load "medit" 
load "tetgen"
load "mmg"
include "MeshSurface.idp"
real R= 2;
real hsize= 0.1; 
real areaT = hsize*hsize*sqrt(3)/2.;
real areaS= 4*pi*R*R;
real nn = sqrt(areaS/areaT/20.); 
cout << nn << endl; 
meshS Thb=Sphere20(2.,nn,1,0);// sphere of  Raduis 2 ..
real[int] bb(6);
boundingbox(Thb,bb);
cout << " BB = " << bb << endl;
plot(Thb,wait=1);//Thb=mmgs(Thb,hmin=hsize,hmax=hsize,hgrad=1.1);

real[int] domain = [0.,0.,0.,1,hsize^3/6];
mesh3 Th3sph=tetg(Thb,switch="paAAQYY",nbofregions=1,regionlist=domain);


 plot(cmm="sphere",Th3sph,wait=1);
~~~

| The mesh               |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Sphere-Isocahedron/solution.png
---
name: Sphere-buildlayer
category: mesh
layout: 3d
---

##  Two ways to build a 3d mesh for a sphere

The easiest is to call $\texttt{BuildBall}$ but one can also rotate the mesh of a half disk around an axis with $\texttt{BuildAxiOx}$.
~~~freefem
include "ball-buildlayer.idp"
load "medit"
{
real RR=4.8828; 
real h= 0.2; // mesh size 
mesh3 Th=BuildBall(RR,h,2);
cout << " region = "<< regions(Th)<< endl;
cout << " label = "<< labels(Th)<< endl;
medit("Th",Th);
plot(Th,wait=1);
}
{
real RR=4.8828; 
real h= 0.2; // mesh size 
border Taxe(t=-RR,RR){x=t;y=0;label=0;}
border CC(t=0,pi){x=RR*cos(t);y=RR*sin(t);label=2+(x>0);}
mesh Th2=buildmesh(  Taxe(2*RR/h)+ CC(pi*RR/h) ) ;
mesh3 Th=BuildAxiOx(Th2,h);
cout << " region = "<< regions(Th)<< endl;
cout << " label = "<< labels(Th)<< endl;
medit("Th",Th);
plot(Th,wait=1);
}
~~~
---
name: sphereincube
category: mesh
layout: 3d
---

##  Build the mesh of a cube with a sphere inside it

The surface mesh of the cube is built using $\texttt{SurfaceHex}$ and that of the sphere with $\texttt{Sphere}$.  Then $\texttt{tetg}$ builds a volumic mesh from the sum of both surface meshes.

~~~freefem
verbosity=1;
load "tetgen"
load "medit"
include "MeshSurface.idp"

real hs = 0.1; // mesh size
real Lex=1,Lin =0.5;
int nLex = 2*Lex/hs;

int[int]  Nex=[nLex,nLex,nLex];
real [int,int]  Bex=[[-Lex,Lex],[-Lex,Lex],[-Lex,Lex]];
int [int,int]  Lbex=[[1,1],[1,1],[1,1]] ;
int  Ls=2 ;

////////////////////////////////
meshS ThHS = SurfaceHex(Nex,Bex,Lbex,1)+Sphere(Lin,hs,Ls,1); // "gluing" surface meshs to total boundary meshes
real voltet=(hs^3)/6.;
cout << " voltet = " << voltet << endl;
real[int] domaine = [0,0,0,2,voltet,0,0,(Lex+Lin)/2,1,voltet];

mesh3 Th = tetg(ThHS,switch="pqaAYY",regionlist=domaine);
Th= trunc(Th,region==1);
// Tetrahelize the interior of the cube with tetgen
// medit("tetg",Th,wait=1);
// savemesh(Th,"Th.mesh");
plot(Th);
~~~

|The 3d mesh             |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/sphereincube/solution.png
verbosity=2;

mesh3 Th("dodecaedre01");
fespace Vh(Th,P23d);
func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;
Vh uhe = ue; // bug ..
cout << " uhe min:  " << uhe[]. min << " max:" << uhe[].max << endl;

border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);


Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)=int3d(Th)(Grad3(v)' *Grad3(u)) - int3d(Th)(f*v) 
+ on(0,1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
cout << int3d(Th)(1.) << " = " << Th.measure << endl;
plot(u,wait=1);
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
Vh2 u2=u,u2e=ue;
plot(u2,wait=1);
plot(u2,u2e,wait=1);

// test new plot ... 
plot(Th,wait=1);
plot(u,wait=1);

/*
	{
 ofstream file("dd.bb"); 
	file << "3 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << d[][j] << endl; 
    }
*/  
assert(err < 1e-9);
---
name: convect-3d
category: fluid
layout: 3d
---

##  Convection of a Tracer
The concentration $v$ of a tracer in a fluid $\Omega$ moving at velocity ${\bf u}=[u_1,u_2,u_3]^T$ is modeled by the convection equation
$$
\partial_t v + {\bf u}\cdot\nabla v=0 \texttt{ in } \Omega\times(0,T)
$$
Here $\Omega$ is a cube, built by extruding a square vertically using $\texttt{buildlayers}$
$v|_{t=0}=v^0$ must be given as well as $v|_\Sigma= v^\Sigma$ where
$$
\Sigma=\{x\in\partial\Omega, t\in(0,T) ~:~{\bf n}_\Gamma\cdot{\bf u} <0\}.
$$

```freefem
int nn=8;

mesh Th2=square(nn,nn,[x*2.-1.,y*2.-1.]);
fespace Vh2(Th2,P1);
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
```
These arrays are used by buildlayers to assign labels to faces. Hence because of rup[0,2] the region 0 in the triangulation of the square becomes the top face of the cube with label = 2.  Similarly the bottom face has label 1 because of rdown[] and finally the sides  which had label 1,2,3,4 (because of the boundary labels of $\texttt{square}$ become faces with label=1.
```freefem
real zmin=-1,zmax=1.;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
```
The concentration of the tracer is shaped like a hill around the $[x_0,y_0,z_0]^T$ at time $t=0$.  The velocity is $[1,2,3]^T$.
```freefem
func  real hill(real r2){return exp(-10.*(r2));};

fespace Vh(Th,P13d);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

Vh v,vo;
Vh2 v2;
real x0=0.3,y0=0.3,z0=0;
vo=hill(square(x-x0)+square(y-y0)+square(z-z0));

real t=0;
v2=vo(x,y,0);
plot(v2,cmm=" cut y = 0.5, time ="+t,wait=1);
real dt=0.1;
func u1=1.;
func u2=2.;
func u3=3.;
```
The PDE is discretized by the method of characteristics
$$
v_h(x,t+\delta t)= \Pi v_h(x-\delta t{\bf u}(x,t),t).
$$
where $\Pi$ denotes the $P^1$ interpolation operator.
The method is simple but diffusive. A more precise, elbeit more expensive, discretization is
$$
\int_\Omega v_h(x,t+\delta t) \hat v dx = \int_\Omega v(x-\delta t{\bf u}(x,t),t) \hat v dx ~~\text{ for all hat function of }V_h.
$$
```freefem
verbosity = 1;
v=convect([u1,u2,u3],-dt,vo);
verbosity = 1;
v2=v(x,y,0);
t += dt;
plot(v2,cmm=" cut y = 0.5, time ="+t,wait=1);
// verification ...
int err=0; 
macro Verif(w,val)
{
   real so= int3d(Th)(vo);
   real soi= int3d(Th)(vo*w);
   real sv= int3d(Th)(v);
   real svi= int3d(Th)(v*w);

   cout  << Stringification(w) << "  old " <<  soi/so << " new " << svi/sv << " delta " << (svi/sv  - soi/so )/dt << " ~ " <<  val << endl; 
   err += (abs((svi/sv  - soi/so )/dt - val)> 0.2);
}   //EOM

Verif(x,1)
Verif(y,2)
Verif(z,3)     
assert(err==0);
```

| The solution at $y=0.5$ |
|-------------------------|
|![][_cut]                |

[_cut]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/convect-3d/cut.png
---
name: Elasticity-simple-support-BC
category: Elasticity
folder: 3d
---
## Linear elasticity with clamped parts of boundary

Homogeneous Dirichlet Boundary conditions are imposed on 2 Edge in 3d for the linear elasticity PDEs.
 The two edges are at the intersection of faces with label 2,5, x==1 (resp.  4,5, x==0).
 The deformation of the structure is due to its own weight.
~~~freefem
mesh3 Th=cube(20,5,5,[x*4,y,z]);
fespace Wh(Th,[P2,P2,P2]) ;

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -100;
~~~
The equations of linear elasticity are used
~~~freefem
real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
Wh [u1,u2,u3],[v1,v2,v3];
varf von5([u1,u2,u3],[v1,v2,v3]) = on(5,u1=1,u2=1,u3=1);
varf von24([u1,u2,u3],[v1,v2,v3]) = on(2,4,u1=1,u2=1,u3=1);

Wh [au1,au2,au3];
{
	real[int] w5=von5(0,Wh, tgv=1); //  find dof on face 5 
	real[int] w24=von24(0,Wh, tgv=1); //  find dof on face 2 and 4 
	au1[] = w5 .* w24; // 1 do intersect  face 5 and 2 4 
	plot(au3,wait=1); // see for debugging 
}
// so array au1[] is non zero on dof on edges  (2,5) and (4,5)

varf  Lame([u1,u2,u3],[v1,v2,v3]) =
  int3d(Th)(  
	     lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  + int3d(Th) (gravity*v3)
;
~~~
The solution is computed
~~~freefem
matrix A = Lame(Wh,Wh,sym=1,positive=1,solver="CG");
cout << " half "<< A.half << " nnz "<< A.nnz << endl;
  real[int] b= Lame(0,Wh); 
  //  put tgv = -2 on matrix A 
  setBC(A,au1[],-2);   // 1 on diagonal and  0 on row  i et column i if  au1[][i] !=0  
  b =  au1[] ? 0 : b;
  set(A,solver= "CHOLMOD"); 
  cout << A.nnz << endl; 
   u1[] = A^-1*b;
~~~
The rest is for visualization, in particular the initial mesh is moved with the displacements just computed
~~~freefem
cout << " || u|| =" << u1[].linfty << endl;
 real cc = 0.5/u1[].linfty;
 mesh3 Thm = movemesh(Th,[x+u1*cc,y+u2*cc,z+u3*cc]) ;
 plot(Th,Thm,wait=1);
~~~

| The initial mesh and the deformed mesh |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Elasticity-simple-support-BC/solution.png
---
name: cube-period
category: mathematics and porous media
folder: 3d
---

## Solve a PDE in a cube with periodic conditions

Here the cube is generated by an extrusion in the vertical direction of a square

~~~freefem
int nn=10;
mesh Th2=square(nn,nn,region=0);
fespace Vh2(Th2,P2);
~~~
The numbering of the faces of the cube is done by hand here
~~~freefem
int[int] rup=[0,5],  rdown=[0,6], rmid=[4,1,2,2, 1,3 ,3,4];
//       label  face  numbering
//      1 :  ( x == xmin)        2 :  ( x == xmax) 
//      3 :  ( y == ymin)        4 :  ( y == ymax) 
//      5 :  ( z == zmin)        6 :  ( z == zmax) 
// ---
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
cout << "Th :  nv = " << Th.nv << " nt =" << Th.nt << endl;
//savemesh(Th,"Th.mesh");
~~~
Let us read as many messages as possible  by setting the verbosity to level 10.  The periodic conditions work by pairs. for instance $\texttt{periodic=[[1,y,z],[2,y,z]]}$ means periodicity in x and y between face 1 (x=xmin) and face 2 (x=xmax).
~~~freefem
verbosity=10;

//  the Finite element space with full periodic condition in 3 axes
fespace Vh(Th,P2,periodic=[[1,y,z],[2,y,z],[3,x,z],[4,x,z],[5,x,y],[6,x,y]]);
verbosity=2;
~~~
The following aims at verifying that all went well
~~~freefem
fespace Vhh(Th,P2);

int[int] num(Vhh.ndof);
num=-1;
int er=0;
for(int k=0;k<Th.nt;++k)
  {
    int err=0;
    for(int i=0;i<4;i++) 
      {
	if(num[Vhh(k,i)]== -1)
	  num[Vhh(k,i)] = Vh(k,i);
	else if(num[Vhh(k,i)] != Vh(k,i))
	  {
	    ++err;
	    cout << " bug " << k <<  " : " << num[Vh(k,i)]  << " !=  " << Vhh(k,i) << endl; 
	  }
      }
    if(err)
      {
	for(int i=0;i<4;i++) cout << Vh(k,i) << " ";     cout << endl;
	for(int i=0;i<4;i++) cout << Vhh(k,i) << " ";    cout << endl << endl;;
      }
    er+=err;
  }

int  n1 = nn+nn+1; //   P2 =>  
int  n2 = n1-1; //
int  nnn=n2*n2*n2;
int nnn1=n1*n1*n1;
assert(er==0 && nnn == Vh.ndof && nnn1 == Vhh.ndof);
cout << " ndf pare= " << Vh.ndof << " " << nnn << endl;
cout << " ndf  = " << Vhh.ndof << " " << nnn1 << endl;
~~~
Now let us solve the Laplace equation  on a manufactured problem whose solution is known
~~~freefem
Vh u,v,uu;
  real x0=2*pi/3,y0=2*pi/4,z0=2*pi*2/3;
  func ue= sin(2*pi*x+x0)*sin(2*pi*y+y0)*sin(2*pi*z+z0);
  real cc= -3*(2*pi)^2 ;
  func f = -cc*ue;
  uu=ue;
macro Grad(u) [dx(u),dy(u),dz(u)] //;
  solve P(u,v,solver=CG)= int3d(Th)(Grad(u)'*Grad(v)) - int3d(Th)(f*v); //') ;
cout << "Err L2 = " << sqrt(int3d(Th)( square(u-uu)) ) << endl;

// FFCS: add 3D view

///Vh2 u0=u(x,y,0);
///Vh2 u1=u(x,y,1);
///plot(u0,u1,wait=1);

plot(u,nbiso=10);
~~~

| The solution is on the figure below |
|------------------------|
|![][_periodic]          |

[_periodic]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/cube-period/periodic.png
---
name: intlevelset3d
category: mesh
folder: 3d
---

## Manipulation of data and PDE on surfaces defined by constant values of a function.

A cube with extreme points [-2,-2,-2] and [2,2,2] is triangulated with $16^3$ points. All labels are set to 1.
~~~freefem
load "medit"
include "cube.idp"
real surfS1 = 4*pi;
real volS1 =surfS1/3.; 
int nn= 16; 
int[int]  Nxyz=[nn,nn,nn];
real [int,int]  Bxyz=[[-2.,2.],[-2.,2.],[-2.,2.]];
int [int,int]  Lxyz=[[1,1],[1,1],[1,1]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);
~~~
A  surface of equal values of the function $x^2+y^2+z^2-1$  is measured.
~~~freefem
int err=0;
real eps = 0.5;
func r = sqrt(x*x +y*y+z*z);

real lc ;
verbosity=3;
lc = int2d(Th,levelset=r-1.)(1.) ; 
cout << " area of the level set = " <<  lc  << " =  surfS1 " << surfS1 ;
cout << ", Ok = " << (abs(lc-surfS1) < eps) << endl; 
if( abs(lc-surfS1) > eps) err++;
~~~
A bilinear form is defined on the surface and a vector $vv$  of values on the hat functions.
~~~freefem
fespace Vh(Th,P1);
// test linear and bilinear ... 
varf vl(u,v) = int2d(Th,levelset=r-1.)(v) + int2d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh);

cout << " area of the level set (varf linear ) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1 ;
cout  << ", Ok = " << (abs(lc-surfS1) < eps) << endl;
if( abs(lc-surfS1) > eps) err++; 
~~~
Now let us prepare the data to solve a PDE on the level sets.

Just for test a idea approximation of int of negative part of levelset  to we just change the measure of the element not the quadrature point .
~~~freefem
real[int]  one(Vh.ndof); 
one=1.;
matrix VV=vl(Vh,Vh); //  matrix with levelset
vv = VV*one;
cout << " area of the level set (varf bilinear same) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1;
cout << ", Ok = " << (abs(lc-surfS1) < eps) << endl;
if( abs(lc-surfS1) > eps) err++;
~~~
Test the new stuff for level set ...
~~~freefem
{
    macro grad(u) [dx(u),dy(u),dz(u)] //
    Vh u,v;
    solve Pxx(u,v) = int3d(Th) ( grad(u)'*grad(v)*1e-8 ) + int3d(Th, levelset= 1-r) ( grad(u)'*grad(v) ) + on(1,u=0) + int3d(Th, levelset= 1-r) ( 1*v);
    plot(u,wait=1);   
    varf vxx(u,v) =  int3d(Th, levelset= 1-r) ( u*v ) + int3d(Th, levelset= 1-r) ( 1*v);
  matrix XX=vxx(Vh,Vh);
  real[int] xx=vxx(0,Vh);
  real vol1= int3d(Th, levelset= 1-r)(1.);
  cout << "   vol1 = " << vol1 << "  ~= " << Th.measure - volS1 << endl;
  err += (abs(vol1-(Th.measure - volS1)) > eps); 
  cout << " xx.sum = " << xx.sum << " == " << vol1 <<endl;
  err += (abs(vol1-xx.sum) > 1e-8); 
  
  real[int] yy(Vh.ndof); yy=1;
  xx= XX*yy;
  cout << " XX.sum = " << xx.sum << " == " << vol1 << endl;
  err += (abs(vol1-xx.sum) > 1e-8); 
}
~~~
test on diff mesh3  not yet implemented
~~~freefem
if(0)
{
mesh3 Th1=Cube(Nxyz,Bxyz,Lxyz);
mesh3 Th2=Cube(Nxyz,Bxyz,Lxyz);
fespace Vh1(Th1,P1);
fespace Vh2(Th2,P1);

varf vl(u,v) = int2d(Th,levelset=r-1.)(v) + int2d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh2);

cout << " area of the level set (varf linear diff    ) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1 ;
cout  << ", Ok = " << (abs(lc-surfS1) < eps) << endl;
if( abs(lc-surfS1) > eps) err++; 
real[int]  one(Vh1.ndof); 
one=1.;

matrix VV=vl(Vh1,Vh2);
vv = VV*one;
cout << " area of the level set (varf bilinear diff ) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1;
cout << ", Ok = " << (abs(lc-surfS1) < eps) << endl;; 
if( abs(lc-surfS1) > eps) err++;

}
cout << " Nb err " << err << endl;
assert(err==0);
~~~

| The surface mesh extracted |
|----------------------------|
|![][_solution]              |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/intlevelset3d/solution.png
---
name: sphere6
category: mesh
layout: 3d
---

##  Build a 3d mesh for a sphere by mapping the surface mesh of a cube

The mesh of the cube is built by gluing the 6 meshes of the faces and then use the mapping
$$
(x,y,z)\mapsto\frac{(x,y,z)}{\sqrt{x^2+y^2+z^2}}.
$$
~~~freefem
load "medit" 
real sqrt2=sqrt(2.);
real onesqrt2=sqrt2/2.;

mesh TS= square(10,10);
TS=adaptmesh(TS,sqrt(1+x*x+y*y),err=0.003,periodic=[[4,y],[1,x],[2,y],[3,x]]);
TS=adaptmesh(TS,sqrt(1+x*x+y*y),err=0.003,periodic=[[4,y],[1,x],[2,y],[3,x]]);
TS=TS+movemesh(TS,[-x,y])+movemesh(TS,[x,-y])+movemesh(TS,[-x,-y]);//  build symetrique mesh
plot(TS,wait=1); 
int orientation=1;
func f = 1;
int[int]  ref=[0,1]; 
meshS Thx0 = movemesh23(TS,transfo=[-f,x,y],orientation=-orientation,label=ref);
meshS Thx1 = movemesh23(TS,transfo=[+f,x,y],orientation=+orientation,label=ref);
meshS Thy0 = movemesh23(TS,transfo=[x,-f,y],orientation=+orientation,label=ref);
meshS Thy1 = movemesh23(TS,transfo=[x,+f,y],orientation=-orientation,label=ref);
meshS Thz0 = movemesh23(TS,transfo=[x,y,-f],orientation=-orientation,label=ref);
meshS Thz1 = movemesh23(TS,transfo=[x,y,+f],orientation=+orientation,label=ref);
meshS Tcube= Thx0+Thx1+Thy0+Thy1+Thz0+Thz1;
//savemesh(Tcube,"T.mesh");
//exec("ffmedit T.mesh");
//medit("Tcube",Tcube);
plot(Tcube,wait=1);
func R = sqrt(x*x+y*y+z*z); 
meshS Th = movemesh(Tcube,[x/R,y/R,z/R]);
plot(Th,wait=1);
//savemesh(Th,"T.mesh");
//exec("ffmedit T.mesh");
//medit("Th",Th);

plot(Th);
~~~

|The 3d mesh             |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/sphere6/SOLUTION.png
---
name: Laplace3d
category: Applied Math
folder: 3d
---

## Solve the Laplace Equations in a Cube with P2 Elements

First build the mesh
~~~freefem
verbosity=2;

int nn=20;
mesh Th2=square(nn,nn,region=0);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
~~~
This method is more complex that $\texttt{ mesh3 Th = cube(nn,nn,nn);}$.  Now the following problem is solved
$$
\int_{Th}\nabla u\cdot\nabla v = \int_{Th}f v, \quad \frac{\partial u}{\partial n}|_{\Gamma_2}= \vec n\cdot\nabla u_e,\quad u|_{\Gamma_1}=u_e
$$
and $f$ is chosen  to be $-\Delta u_e$ so that the solution is $u_e$
~~~freefem
fespace Vh(Th,P2);

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;
Vh uhe = ue; //

cout << " uhe min:  " << uhe[].min << " max:" << uhe[].max << endl;

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM


  problem Lap3d(u,v,solver=CG)  =
  int3d(Th)(Grad3(v)' *Grad3(u)) //') for emacs 
  + int2d(Th,2)(u*v)  
  - int3d(Th)(f*v) 
  - int2d(Th,2) ( ue*v + (uex*N.x +uey*N.y +uez*N.z)*v )
  + on(1,u=ue);
Lap3d;
~~~
Various quantities are printed including the effect of a quadrature change.
~~~freefem
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
real aa1= int3d(Th,qfV=qfV1)(u) ;
real aa2= int3d(Th,qfV=qfV1lump)(u) ;

cout << " aa1 = " << aa1 << endl;
cout << " aa2 = " << aa2 << endl;
cout << int3d(Th)(1.) << " = " << Th.measure << endl;
cout << int3d(Th,qfV=qfV1)(1.) << " = " << Th.measure << endl;
cout << int3d(Th,qfV=qfV1lump)(1.) << " = " << Th.measure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
real  aire2=int2d(Th,2)(1.); // bug correct in version 3.0-4 
cout << " aire2 = " << aire2 << endl;
func uuu= 2.+x;
cout << uuu(1,1,1) << endl;
assert( abs(aire2-1.) < 1e-6);
plot(u,wait=1);

assert( err < 1e-6);
~~~

|The solution            |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Laplace3d/solution.png

mesh3 Th3 = cube(10,10,10,[x*2*pi,y*2*pi,z*2*pi]);

verbosity=10;
fespace Vh3(Th3,P1, periodic=[[1,x,z],[3,x,z],[2,y,z],[4,y,z],[5,x,y],[6,x,y]]);
macro grad3(u) [dx(u),dy(u),dz(u)]//
cout << " Vh3 ndof " << Vh3.ndof << endl; 
func u3e =(sin(x+1)*sin(y+2)*sin(z+3));
Vh3 u3,v3,u3h=u3e;
func f3= 3.*u3e;
solve P3(u3,v3) = int3d(Th3)(grad3(u3)'*grad3(v3)+1e-6*u3*v3) - int3d(Th3)(f3*v3) ;
//plot(u3,u3h,cmm=1);
//plot(u3h,cmm=1);
u3[]-=u3h[];
cout << " err3  = " << u3[].linfty << endl;
assert(u3[].linfty < 0.07);
load "medit"
int nn=10;

border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2= buildmesh(cc(100));
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
func zmin= 2-sqrt(4-(x*x+y*y));
func zmax= 2-sqrt(3.);

mesh3 Th=buildlayers(Th2,nn,
  coef=  (zmax-zmin)/zmax,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);


func u=x^2+y^2;

mesh3 Th3=trunc(Th,(u-0.5)>1.e-10,split=1,label=135);
medit("Lac",wait=1,Th);
plot(Th); // FFCS: testing 3d plots
medit("LacTruncated",Th3,wait=1);
plot(Th3); // FFCS: testing 3d plots
---
name: 3d-Leman
category: fluid
layout: module
---

# 3d-Potential Flow
Aims at computing the flow in the Leman lake with water input from the Rhone on the east side (label 1) and water output at the western tip near Geneva (label 2). The velocity is the gradient of the potential $u$ which solves
$$
\left\{
\begin{align*}
	-\Delta u  &= 0 \hbox{ in $\Omega_3$}\\
	\frac{\partial u}{\partial n}|_{\partial\Omega_3} &= q
\end{align*}
\right.
$$
where $\Omega_3$ is the region of space occupied by water.
The solution exists only iff $\int_{\partial\Omega_3}q=0$ and uniqueness holds up to a constant.
### Variational form
Given a small positive parameter $\epsilon$, find $u\in H^1(\Omega_3)$ such that
$$
\displaystyle{
	\int_{\Omega_3}{\nabla u\cdot\nabla v +\epsilon u v}  = \int_{\partial\Omega_3}{q v},
  \quad \forall v\in H^1(\Omega_3)
}
$$
It can be shown that $u$ converge to the solution when $\epsilon\to0$ iff $\int_{\partial\Omega_3}{q}=0$.

The 3D mesh is built layer by layer from a 2d mesh of the lake surface.  So one must first reads a 2d mesh, construct a 3d mesh from the 2d mesh and the depth and solves the potential flow equation.


## Step 1: Build a 3d mesh from a 2d mesh and and a depth function

To display the results we will call Medit so we need to load the corresponding module.
~~~freefem
load "medit"
~~~
Verbosity adjusts the messages sent by FreeFem++.
~~~freefem
verbosity=3;
~~~
Let us read the 2d mesh contained in file ("lac-leman-v4.msh". The format is
- On the first line : the number of vertices, the number of triangles and the number of boundary edges
- Then the coordinates of the vertices and their region number
- Then the identification number (i.e; the position in the above list) of the 3 vertices of each triangle
- Finally the connectivity of the boundary edges: the 2 vertices and the label number of the edge
~~~freefem
mesh Th2("lac-leman-v4.msh");
fespace Vh2(Th2,P1);
Vh2 d;
~~~
The 2 lines above have defined a Finite Element Space on the 2d mesh with $P^1$ triangular elements.

To construct a 3d mesh we need the bathymetry of the lake, i.e. a function for the lake's depth at each point of the surface, $d(x,y),~(x,y)\in \Omega_2$.
This is done in a very approximate way as the result of a Laplace equation
$$
\left\{
\begin{align*}
	\Delta d  &= 1 \hbox{ in }\Omega_2
  \\
	d|_{\partial\Omega_2} &= 0
\end{align*}
\right.
$$
In variational form, this is
~~~freefem
{  Vh2 v; 
	macro Grad(u) [dx(u),dy(u)] //
	solve P(d,v)= int2d(Th2)(Grad(d)'*Grad(v))+int2d(Th2)(v)
	+on(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,d=-1);
	d = d*5/abs(d[].min);
	plot(d,wait=1);
}
~~~
The macro is here to make the formula easier to read.
There are many labels for $\partial\Omega$ each corresponding to a portion of the lake boundary betwen two rivers.
The code has been surrounded by braces so as to make all variables local. This is by no means compulsory but this way one can reuse the names of the variables.

#### Build the 3d mesh using "buildlayers"
The mesh will have nn=10 layers:
~~~freefem
int[int] rup=[0,200],  rdown=[0,100];
real maxdeep = d[].min;
int nn=10; // controls the mesh fineness
mesh3 Th=buildlayers(Th2,nn,
  coef= d/maxdeep,
  zbound=[d,0],
  reffaceup = rup,
  reffacelow = rdown);
~~~
The purpose of rup and rdown is to replace 0 by 200 and 0 by 100 in the labels for the faces of the elements which are on the bottom of the lake and on the surface. For more details see
https://doc.freefem.org/documentation/mesh-generation.html#the-command-buildlayers
The mesh is displayed with "medit" (type "q" to exit medit)
### Step2: Solve the problem
As usual we need to work with a finite element space on the 3d mesh and define some functions
~~~freefem
fespace Vh(Th,P1);
Vh p,q;
macro Grad(u) [dx(u),dy(u),dz(u)] //

~~~
In the following $\texttt{din}$ and $\texttt{dout}$ are the debits from borders 1 and borders 2, in and out of the lake.  Some rescaling is needed to satisfy the necessary condition for existence of a solution.
~~~freefem
real ain=int2d(Th,1)(1.);
real aout=int2d(Th,2)(1.);
cout << " area " << ain << " " << aout << endl;
real din=1./ain; // inflow
real dout=-1./aout; // ouflow

~~~
Now the problem is solved and the solution is displayed statically by plot and interactively by medit:
~~~freefem
solve P(p,q)= int3d(Th)(Grad(p)'*Grad(q)+1e-5*p*q)-int2d(Th,1)(q*din)+int2d(Th,2)(q*dout);
plot(p,wait=1,nbiso=30,value=1);
/* if(!NoUseOfWait) medit("potentiel",Th,p,wait=1);*/
~~~
## Results

| The depth function d:|
|----------------------|
|![][_depth]           |

| The potential function p: the flow is slow except near Geneva at the tip of the lake.|
|--------------------|
|![][_flow]          |


[_depth]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/3d-leman/bathymetry.png

[_flow]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/3d-leman/flow.png
---
name: sphere2
category: mesh
layout: 3d
---

##  Build a 3d mesh for a sphere by glueing the meshes of two half spheres

~~~freefem
load "medit"
border BC(t=0,2*pi){ x=cos(t);y=sin(t);label=1;}
mesh TC= buildmesh(BC(100));
func r
 = (1e-5+abs(1-square(x)-square(y)))^0.5;
real cc=100;
//TC=adaptmesh(TC,[cc*x/r,0,cc*y/r],IsMetric=1);
plot(TC,wait=1);
meshS Thup=movemesh23(TC,transfo=[x,y,sqrt(abs(1-square(x)-square(y)))]);
meshS Thdown=movemesh23(TC,transfo=[x,y,-sqrt(abs(1-square(x)-square(y)))], orientation=-1);
verbosity=10;
meshS Th= Thup+Thdown;

bool usemedit=false;
if(usemedit)
  {
    medit("Thup",Thup,wait=1);
    medit("Thdown",Thdown,wait=1);
    medit("Th",Th,wait=1);
  }
//savemesh(Th,"toto.mesh");
plot(Thup);
plot(Thdown);
plot(Th);
~~~

|The 3d mesh             |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/sphere2/solution.png
---
name: Periodic-Poisson-cube-ballon
category: math
layout: 3d
---

## Construction of a periodic domain with a cube and a ball

First a surface mesh is made for a cube plus a ball inside; $\texttt{SurfaceHex}$ triangulate the surface of a cube and $\texttt{Sphere}$ triangulate the surface of a sphere.  Then $\texttt{tetg}$ is invoked to make a 3d triangulation of the volume delimited by these 2 surfaces.
~~~freefem
verbosity=1;

load "tetgen"
load "medit"
include "MeshSurface.idp"

mesh3 Th;
try {
  Th=readmesh3("Th-hex-sph.mesh");
 }
catch(...)
  { 
    real hs = 0.2;  // mesh size on sphere 
    int[int]  NN=[11,9,10];
    real [int,int]  BB=[[-1.1,1.1],[-.9,.9],[-1,1]];
    int [int,int]  LL=[[1,2],[3,4],[5,6]];
    
    ////////////////////////////////
    meshS ThHS = SurfaceHex(NN,BB,LL,1)+Sphere(0.5,hs,7,1); // "gluing" surface meshs to tolat boundary meshes
    real voltet=(hs^3)/6.;
    cout << " voltet = " << voltet << endl;
    real[int] domaine = [0,0,0,1,voltet,0,0,0.7,2,voltet];
    
    Th = tetg(ThHS,switch="pqaAYY",nbofregions=2,regionlist=domaine);    
    // Tetrahelize the interior of the cube with tetgen
    medit("tetg",Th,wait=1);
 //   savemesh(Th,"Th-hex-sph.mesh");
    // FFCS: testing 3d plots
    plot(Th,wait=1);
 }
~~~
The periodic $P^1$ finite element space Vh is defined
~~~freefem
fespace Ph(Th,P0);
verbosity=50;
fespace Vh(Th,P1,periodic=[[3,x,z],[4,x,z],[1,y,z],[2,y,z],[5,x,y],[6,x,y]]);// back and front
verbosity=1;
Ph reg=region;

cout << "  centre = " << reg(0,0,0) << endl;
cout << " exterieur = " << reg(0,0,0.7) << endl;
~~~
An elliptic problem is set with discontinuous coefficients of 100 in region 1 and 2 in region 2.
~~~freefem
macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

Vh uh,vh;
real x0=0.3,y0=0.4,z0=06;
func f= sin(x*2*pi+x0)*sin(y*2*pi+y0)*sin(z*2*pi+z0);
real gn = 1.;
real cf= 1;
problem P(uh,vh,solver=sparsesolver)=
     int3d(Th,1)( Grad(uh)'*Grad(vh)*100) +  int3d(Th,2)( Grad(uh)'*Grad(vh)*2)
  + int3d(Th) (vh*f)
  ; 
  
  P;

plot(uh,wait=1, nbiso=6);
medit("   uh ",Th, uh,wait=1); 
~~~

|The solution and a cut into the domain (do "b" then "m" then f1 then f2 in the medit window) to see in the volume |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Period-Poisson-cube-ballon/solution.png
---
name: beam-3d
category: solid
layout: module
---

# Compute the deflection of a 3d elastic beam
The geometry is a beam of rectangular cross section.
The equations are
$$
\displaystyle{
	\begin{align*}&
  \int_{\Omega}[\mu\epsilon(u)\cdot\epsilon(v) +\lambda (\nabla\cdot u )(\nabla\cdot v)]  = \int_{\partial\Omega}{g u_3},
  \quad \forall v\in V(\Omega)
  \cr&
  \nabla\cdot u= \partial_x u_1+\partial_y u_2+\partial_z u_3,
  \cr&
  \epsilon(u)=[\partial_x u_1,\partial_y u_2,\partial_z u_3, \frac1{\sqrt{2}}(\partial_z u_2 + \partial_y u_3), \frac1{\sqrt{2}}(\partial_y u_1 + \partial_x u_2)].
  \end{align*}
}
$$
where $V(\Omega)=\{ v\in (H(\Omega)^3): v|_S=0\}$ and $S\subset\partial\Omega$ is the portion of the boundary where the beam is clamped.
$\mu$ and $\lambda$ are computed from the Young and Poisson constants $E,\sigma$,
~~~freefem
real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
~~~
Gravity is vertical and the value is chosen to obtain a good picture.  The equatins hold for small displacements anyway.
The mesh is built with the function $\texttt{Cube}$ with $20\times5\times5$ edge vertices. The size of the beam is specified by [min x, max x],[min y, max y],[min z, max z] in Bxyz. The label of the beam faces are in Lxyz: [xmin face, xmax face],[ymin face, ymax face],[zmin, zmax]. Hence the  face at xmin has label 1. It will be where the beam is clamped.
~~~freefem
include "cube.idp"
int[int]  Nxyz=[20,5,5];
real [int,int]  Bxyz=[[0.,5.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,2],[2,2],[2,2]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);
~~~
A vector finite element space with 3 $P^1$ components is defined and 2 functions with vector values $u,v$:
~~~freefem
fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];
~~~
Everything is in place to solve the problem
~~~freefem
real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),
                  (dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
 // EOM means End Of Macro
solve Lame([u1,u2,u3],[v1,v2,v3])=
  int3d(Th)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  - int3d(Th) (gravity*v3)
  + on(1,u1=0,u2=0,u3=0)
  ;
~~~
To visualize the result, the best is to move the mesh by the displacement just computed.
~~~freefem
real dmax= u1[].max;
cout << " max deplacement = " << dmax << endl;
real coef= 0.1/dmax;
int[int] ref2=[1,0,2,0];
mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2);
Thm=change(Thm,label=ref2);
plot(Th,Thm, wait=1,cmm="coef  amplification = "+coef );
~~~
| The deflection of the beam |
|----------------------------|
|![][_deflection]            |


[_deflection]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/beam-3d/beam3d.png

// file tetgencube.edp
load "tetgen"
load "medit"

real x0,x1,y0,y1;
x0=1.; x1=2.; y0=0.; y1=2*pi;
mesh Thsq1 = square(5,35,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

int[int] ref31h = [0,12];
int[int] ref31b = [0,11];

meshS Th31h = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1max],region=ref31h,orientation=1);
savemesh(Th31h,"Th31h.mesh");
meshS Th31b = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1min],region=ref31b,orientation=-1);   


/////////////////////////////////
x0=1.; x1=2.; y0=0.; y1=1.5;
mesh Thsq2 = square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

int[int] ref32h = [0,13];
int[int] ref32b = [0,14];

meshS Th32h = movemesh23(Thsq2,transfo=[XX2,YY2max,ZZ2],region=ref32h,orientation=-1);  
meshS Th32b = movemesh23(Thsq2,transfo=[XX2,YY2min,ZZ2],region=ref32b,orientation=1);

/////////////////////////////////
x0=0.; x1=2*pi; y0=0.; y1=1.5;
mesh Thsq3 = square(35,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
func XX3min = 1.;
func XX3max = 2.;

func YY3 = x;
func ZZ3 = y;

int[int] ref33h = [0,15];
int[int] ref33b = [0,16];

meshS Th33h = movemesh23(Thsq3,transfo=[XX3max,YY3,ZZ3],region=ref33h,orientation=1);  
meshS Th33b = movemesh23(Thsq3,transfo=[XX3min,YY3,ZZ3],region=ref33b,orientation=-1); 

////////////////////////////////
meshS Th33 = Th31h+Th31b+Th32h+Th32b+Th33h+Th33b; // "gluing" surface meshs to obtain the surface of cube
//medit("glumesh",Th33);
Th33=change(Th33, rmInternalEdges=true);
savemesh(Th33,"Th33.mesh");

// build a mesh of a axis parallel box with TetGen
//real[int] domaine = [1.5,pi,0.75,145,0.001];
//mesh3 Thfinal = tetg(Th33,switch="pqaAAYYQ",nbofregions=1,regionlist=domaine);    // Tetrahelize the interior of the cube with tetgen
//medit("tetg",Thfinal);
//savemesh(Thfinal,"Thfinal.mesh");


// build a mesh of a half cylindrical shell of interior radius 1. and exterior radius 2 and heigh 1.5
func mv2x = x*cos(y);
func mv2y = x*sin(y);
func mv2z = z;

plot(Th33,wait=1);

meshS Thmv2surf = movemesh(Th33,[mv2x,mv2y,mv2z]);
meshS Thmv2surfclean = movemesh(Th33,[mv2x,mv2y,mv2z],cleanmesh=true, removeduplicate=true);

savemesh(Thmv2surfclean,"Thmv2surfclean.mesh");
plot(Thmv2surf,wait=1,cmm="th without clean mesh");
plot(Thmv2surfclean,wait=1,cmm="th with clean mesh and remove all multiples ");

//assert( Th33.nt-Thmv2surfclean.nt == Thsq2.nt); 
---
name: Stokes
category: fluid
layout: 3d
---

##  Stokes problem in 3d

The problem is to find velocities and pressure solution of
$$
-\Delta \vec u = \vec f,\quad \nabla\cdot \vec u=0,\quad \vec u|_{\partial\Omega}=\vec u_\Gamma
$$
For the driven cavity problem the domain $\Omega$ is a cube, $f=0$ and $u_\Gamma=(1,0,0)^T$ on the top face and zero elswhere. The boundaries define $\Gamma$.

First build a mesh for the cube by using $\texttt{buildlayer}$ by extruding vertically the 2d mesh of a square
~~~freefem
load "medit"
int nn=3;
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);  Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],  labelmid=rmid, 
  reffaceup = rup,     reffacelow = rdown);
  
medit("c10x10x10",Th,wait=1);

// FFCS: testing 3d plots
plot(Th);
~~~
Then define the Hood-Taylor element which is $P^2$ for $u$ anf $P^1$ for $p$.  The variational formulation finds $u$ satisfying the boundary conditions and $p$ such that
$$
\int_\Omega[\nabla u\cdot\nabla v -q\nabla\cdot u - p\nabla\cdot v + \epsilon u\cdot v]=0
$$
for all $v$ zero on $\Gamma$.  The regularization parameter $\epsilon$ is necessary to avoid a singular linear system.
~~~freefem
fespace VVh(Th,[P2,P2,P2,P1]);
fespace Vh(Th,P23d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

VVh [u1,u2,u3,p];
VVh [v1,v2,v3,q];
func fup = (1-x)*(x)*y*(1-y)*16;
solve vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) //)';
		       - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,u1=fup,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ;
plot(p,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
plot([u1,u2,u3] ,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
//  to see the 10 cup plan in 2d 
for(int i=1;i<10;i++)
  {
    real yy=i/10.;
    ux= u1(x,yy,y);
    uz= u3(x,yy,y);
    p2= p(x,yy,y);
    plot([ux,uz],p2,cmm=" cut y = "+yy,wait= 1);
  }

// FFCS: testing 3d plots
plot(u1);
plot(u2);
plot(u3);
plot(p);
~~~
---
name: Connectivity
category: Mesh
folder: 3d
---

## Explains how to address the internal data of a mesh
On the mesh of a cube the following data can be accessed
~~~freefem
mesh3 Th=cube(1,1,1);

  // --------- new stuff -----------------
  int k=0,l=1,e=1;  // for example
  Th.nbe ; //   the number of boundary elements
  Th.nt ; // the number of elements
  Th.nv ;  // the number of vertices
  Th.be(k);   //   the boundary element k $\in \{0,...,Th.nbe-1\}$
  Th.be(k)[l];   //   the vertices l $\in \{0,1\}$ of  boundary element k
  Th.be(k).Element ;   //   the triangle contening the  boundary element k
  Th.be(k).whoinElement ; // egde number of triangle containing the  bdy element k
  Th.be(k).N ;   //   the Normal to be(k)   version 4.10.1
  Th.be(k).measure ;   //   the measure of be(k)   version 4.10.1
  Th[k].adj(e) ; //   adjacent triangle to k by edge e
  Th[k].measure ; //    the volume of element k
  Th(l).x ; // first coordinate of node l
  Th[k][0];  // the  number of the first of the 4 vertex  of element k.

// Here are some examples

  cout << " print mesh connectivity " << endl;
  Th[k] == Th[k].adj(e) ;// non adjacent element   the same
  Th[k] != Th[k].adj(e) ;// true adjacent triangle
   int nbelement = Th.nt;
  for (int i=0;i<Th.nv;++i)
  cout << i << " : "  << Th(i).x << " "<< Th(i).y << " " << Th(i).z  << endl; 
 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2])<< " " <<  int(Th[k][2])
	 << " , label/ region  " << Th[k].label << endl;
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<4;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) it is not a adjacent element

  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " " << Th.be(k)[2]  << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 

~~~
The following bounding box bb contains the triangulation. It is useful for limiting the region of a plot

~~~freefem
real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 
R3 O(0.5,0.5,0.5);
real ss =0;
 for (int k=0;k<nbboundaryelement;++k)
  ss += solidangle(O,Th.be(k));
 cout << " solid angle = " << ss << " == 4*pi == " << 4*pi << endl;
 assert( abs(ss-4*pi) < 1e-9);
 
 {
 Th = cube(3,3,3);
 func real f(R3 A)
 {
    assert(nuFace>=0); 	 
    cout << "P "<< P << " " << nuTriangle << " " << nuFace << " A = "<< A << endl;
    return solidangle(A,Th[nuTet],nuFace)/area;
 }
 cout << " integral " << int2d(Th,qforder=1)(f(O) )<< " " << 4*pi <<  endl; 
}
~~~
---
name: Poisson3d
category: math
layout: 3d
---

## Construct a periodic 3d mesh of a cube minus a cylinder

A volumic mesh of a sphere is built by mapping a surface mesh of a square and then call $\texttt{tetgentransfo}$.
~~~freefem
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  de  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;
real[int] domaine =[0.,0.,0.,1,0.01];
mesh3 Th3=tetgtransfo(Th,transfo=[f1,f2,f3],nbofregions=1,regionlist=domaine);
//savemesh(Th3,"sphere.meshb");
//medit("sphere",Th3);
plot(Th3,cmm="sphere");
~~~
The folowing problem is solved
$$
-\Delta u=f,\quad u=u_e ~~on~\Gamma_0\cup\Gamma1
$$
and homogeneous Neumann conditon on other boundaries. A $P^2$ FEM is used
~~~freefem
fespace Vh(Th3,P23d);
func ue =   2*x*x + 3*y*y + 4*z*z+ 5*x*y+6*x*z+1;
func f= -18. ;
Vh uhe = ue; // bug ..
cout << " uhe min:  " << uhe[].min << " max:" << uhe[].max << endl;
cout << uhe(0.,0.,0.) << endl;

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)=int3d(Th3)(Grad3(v)' *Grad3(u))//'
 - int3d(Th3)(f*v) + on(0,1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th3)( square(u-ue) );
cout << int3d(Th3)(1.) << " = " << Th3.measure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
plot(u);
~~~
To compare with the exact solution a 2d mesh is built and the functions are displayed in a cut corresponding to this 2d mesh.
~~~freefem
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);

Vh2 u2=u,u2e=ue-u2;
plot(u2e,wait=1, value=1);

assert(err < 1e-9);
~~~

| The 3d solution |
|-----------------|
|![][_solution]   |

| The 2d error |
|--------------|
|![][_error]   |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Poisson3d/solution.png

[_error]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Poisson3d/error.png
---
name: Periodic-3d
category: math
layout: 3d
---

## Construct a periodic 3d mesh of a cube minus a cylinder

We begin with a 2d mesh of a square with a hole
~~~freefem
load "medit"

searchMethod=1;
verbosity=1;
real a=1, d=0.5, h=0.5;
border b1(t=0.5,-0.5) {x=a*t; y=-a/2; label=1;};
border b2(t=0.5,-0.5) {x=a/2; y=a*t; label=2;};
border b3(t=0.5,-0.5) {x=a*t; y=a/2; label=3;};
border b4(t=0.5,-0.5) {x=-a/2; y=a*t; label=4;};
border i1(t=0,2*pi) {x=d/2*cos(t); y=-d/2*sin(t); label=7;};
int nnb=10, nni=20; 
mesh Th=buildmesh(b1(-nnb)+b3(nnb)+b2(-nnb)+b4(nnb)+i1(nni));//, fixedborder=true);
//Th=adaptmesh(Th,0.1,IsMetric=1,periodic=[[1,x],[3,x],[2,y],[4,y]]);

~~~
Now we renumber the vertices
~~~freefem
int nz=10;
{ // Between braces to declare all var local, hence save on memory.
int[int] old2new(0:Th.nv-1);
fespace Vh2(Th,P1);
Vh2 sorder=x+y; 
sort(sorder[],old2new);
int[int]  new2old=old2new^-1;   // inverse the permuation 
//for(int i=0;i< Th.nv;++i) // so by hand. 
//  new2old[old2new[i]]=i;
Th= change(Th,renumv=new2old);
sorder[]=0:Th.nv-1;
}
~~~
Now the 3d mesh is built using $\texttt{buildlayers}$.
~~~freefem
{
  fespace Vh2(Th,P1);
  Vh2 nu;
  nu[]=0:Th.nv-1;
  plot(nu,cmm="nu=",wait=1);
}
int[int] rup=[0,5], rlow=[0,6], rmid=[1,1,2,2,3,3,4,4,7,7], rtet=[0,41];
func zmin=0;
func zmax=h;
mesh3 Th3=buildlayers(Th, nz, zbound=[zmin,zmax],
    reftet=rtet,reffacemid=rmid, reffaceup=rup, reffacelow=rlow);
for(int i=1;i<=6;++i)
  cout << " int " << i << " :  " << int2d(Th3,i)(1.) << " " << int2d(Th3,i)(1./area) << endl;
//savemesh(Th3,"Th3.mesh");
plot(Th3,wait=1);
//medit("Th3",Th3);
~~~

|The 3d mesh |
|------------|
|![][_mesh]  |

The finite element space with periodic mesh can be define and a PDE can be solved
~~~freefem
fespace Vh(Th3,P2, periodic=[[1,x,z],[3,x,z],[2,y,z],[4,y,z],[5,x,y],[6,x,y]]);
macro grad3(u) [dx(u),dy(u),dz(u)]//
func u3e =(sin(2*pi*x+1)*sin(2*pi*y+2)*sin(4*pi*z+3));
Vh u3,v3,u3h=u3e;
real ccc= pi^2*(4+4+16);
func f3= ccc*u3e;
solve P3(u3,v3) = int3d(Th3)(grad3(u3)'*grad3(v3)//'
                  +1e-6*u3*v3) - int3d(Th3)(f3*v3) 
                  + on(7,u3=u3e);
//plot(u3,u3h,cmm=1);
plot(u3,cmm=1);
u3[]-=u3h[];
cout << " err3  = " << u3[].linfty << endl;
assert(u3[].linfty < 0.07);
~~~

|The solution            |
|------------------------|
|![][_solution]          |

[_mesh]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/periodic-3d/mesh.png

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/periodic-3d/solution.png
---
name: LaplaceRT-3d
category: Applied Math
folder: 3d
---

## Solve the Laplace Equations in a Cube by a Mixed Method

$$
-\Delta p = f    \hbox{ in }\Omega,\quad
\frac{\partial p }{\partial n} = (g_1^d,g_2^d). n \hbox{ on }\Gamma_{1}\quad
p = g^d  \hbox{ on }\Gamma_{2}
$$

with the mixed finite element formulation,

Find $p\in L^2(\Omega) $  and $u\in H(div) $ such that
$$  u - \nabla p = 0 , \quad - \nabla\cdot u =  f, \quad
  u\cdot n = (g_1^d,g_2^d)\cdot n   \hbox{ on } \Gamma_{2}, \quad
  p = g^d  \hbox{ on }\Gamma_{1}$$
the variational form is: $\forall v\in H(div):  v\cdot n|_{\Gamma_{2}}=0,~\forall q\in L^2$:

$$ \int_\Omega  u v + p \nabla\cdot  v -\int_{\Gamma_{1}} g^d v\cdot n     =0,\quad \int_\Omega q \nabla\cdot u = -\int_\Omega f q,\quad
u\cdot n |_{\Gamma_2}= (g^d_1,g^d_2)\cdot n $$

~~~freefem
include "cube.idp"
    int[int]  Nxyz=[10,10,10];
    real [int,int]  Bxyz=[[0,1],[0,1],[0,1]];
    int [int,int]  Lxyz=[[1,1],[1,1],[2,1]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);
fespace Vh(Th,P1);
fespace Rh(Th,RT03d);
fespace Nh(Th,Edge03d);//  Nedelec Finite element. 
fespace Ph(Th,P0);

func gd = 1.;

func g1n = 2.;
func g2n = 3.; 
func g3n = 4.; 

func f = 1.;

Rh [u1,u2,u3],[v1,v2,v3];
Nh [e1,e2,e3];
[u1,u2,u3]=[1+100*x,2+100*y,3+100*z];

// a + b ^ x = 
/*
  b1    x     a1 + b2*z - b3*y 
  b2 ^  y  =  a2 - b1*z + b3*x
  b3    z     a3 + b1*y - b2*x
*/
real b1=30,b2=10,b3=20;
func ex1=100+b2*z-b3*y;

func ex1x=0.;
func ex1y=-b3+0;
func ex1z=b2+0;

func ex2=200.- b1*z + b3*x ;
func ex2x= b3 +0;
func ex2y= 0. ;
func ex2z= -b1 +0;
func ex3=300.+b1*y - b2*x ;
func ex3x= -b2 +0;
func ex3y= b1 +0;
func ex3z= 0. ;
[e1,e2,e3]=[ex1,ex2,ex3]; 

int k=Th(.1,.2,.3).nuTriangle ;
cout << " u = " << u1(.1,.2,.3)  << " " << u2(.1,.2,.3) << " " << u3(.1,.2,.3) << endl;
cout << " dx u = " << dx(u1)(.1,.2,.3)  << " " << dy(u2)(.1,.2,.3) << " " << dz(u3)(.1,.2,.3) << endl;

cout << " e  = " << e1(.1,.2,.3)  << " " << e2(.1,.2,.3) << " " << e3(.1,.2,.3) << endl;
cout << " ex = " << ex1(.1,.2,.3)  << " " << ex2(.1,.2,.3) << " " << ex3(.1,.2,.3) << endl;


cout << " dx,dy,dz   e1x= " << ex1x(.1,.2,.3)  << " " << ex1y(.1,.2,.3) << " " << ex1z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2x= " << ex2x(.1,.2,.3)  << " " << ex2y(.1,.2,.3) << " " << ex2z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3x= " << ex3x(.1,.2,.3)  << " " << ex3y(.1,.2,.3) << " " << ex3z(.1,.2,.3) << endl;

cout << " dx,dy,dz   e1 = " << dx(e1)(.1,.2,.3)  << " " << dy(e1)(.1,.2,.3) << " " << dz(e1)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2 = " << dx(e2)(.1,.2,.3)  << " " << dy(e2)(.1,.2,.3) << " " << dz(e2)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3 = " << dx(e3)(.1,.2,.3)  << " " << dy(e3)(.1,.2,.3) << " " << dz(e3)(.1,.2,.3) << endl;


cout << " k = " << k << endl;
cout << Rh(k,0) << " " <<Rh(k,1) << " " <<Rh(k,2) << " " <<Rh(k,3) << endl;
cout << " df = " << u1[][Rh(k,0)] <<  " " << u1[][Rh(k,1)]  <<" " << u1[][Rh(k,2)]  << " " << u1[][Rh(k,2)] << endl;
// cout << u1[] << endl;

Vh P,Q;
Ph p,q; 
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //
macro Grad(u) [dx(u),dy(u),dz(u)]  //
  problem laplace(P,Q,solver=CG) = 
  int3d(Th) ( Grad(P)'*Grad(Q)) //') for emacs
  - int3d(Th)(f*Q) 
  + on(1,P=gd) 
  - int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q);

fespace RPh(Th,[RT03d,P0]);
varf von1([u1,u2,u3,p],[v1,v2,v3,q])  = 
   int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 - int3d(Th) ( f*q)
 + int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);

RPh [vv1,vv2,vv3,qq];
// some verification Boundary Condition
// and interpolation ...
real[int]  ron=von1(0,RPh);
vv3[]=von1(0,RPh);
cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << endl;
[vv1,vv2,vv3,qq]=[g1n,g2n,g3n,100];
[v1,v2,v3]=[g1n,g2n,g3n];

cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << " " << qq(.1,.2,.001) << endl;
cout << " v : = " << v1(.1,.2,.001)  << " " << v2(.1,.2,.001) << " " << v3(.1,.2,.001)  << endl;

// end of verification of Boundary Condition ... 

problem laplaceMixte([u1,u2,u3,p],[v1,v2,v3,q],eps=1.0e-10,tgv=1e30,dimKrylov=1000) =
   int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 + int3d(Th) ( f*q)
 - int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);

laplace;

// FFCS: add 3D view parameters
real[int] CameraPositionValue = [0.0165449,3.23891,-0.991528];
real[int] CameraFocalPointValue = [0.5,0.5,0.5];
real[int] CameraViewUpValue = [0.671735,0.442219,0.594318];
real[int] CutPlaneOriginValue = [0.5,0.5,1.01];
real[int] CutPlaneNormalValue = [0.689523,0.722423,0.0516115];
plot(P,fill=0,boundary=0,ShowMeshes=1,CutPlane=1,
	CameraPosition=CameraPositionValue,
	CameraFocalPoint=CameraFocalPointValue,
	CameraViewUp=CameraViewUpValue,
	CutPlaneOrigin=CutPlaneOriginValue,
	CutPlaneNormal = CutPlaneNormalValue);

laplaceMixte;

real errL2=sqrt(int3d(Th)(square(P-p))) ;
cout << " int 2 x,yz "<<int2d(Th,2)(x) << " " << int2d(Th,2)(y) << " " << int2d(Th,2)(z) << endl;
cout << " int 2 gn "<<int2d(Th,2)(g1n) << " " << int2d(Th,2)(g2n) << " " << int2d(Th,2)(g3n) << endl;
cout << " int 2 U  "<<int2d(Th,2)(u1) << " " << int2d(Th,2)(u2) << " " << int2d(Th,2)(u3) << endl;
cout << " int 2 V  "<<int2d(Th,2)(vv1) << " " << int2d(Th,2)(vv2) << " " << int2d(Th,2)(vv3) << endl;
cout << " int 2 DP "<<int2d(Th,2)(dx(P)) << " " << int2d(Th,2)(dy(P)) << " " << int2d(Th,2)(dz(P)) << endl;
  
cout << "  diff: u Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (u1*N.x +u2*N.y + u3*N.z) ) ) ) <<endl;
cout << "  diff: P Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (dx(P)*N.x +dy(P)*N.y + dz(P)*N.z) ) ) ) <<endl;
cout << " diff err L2 :" << errL2 << endl;
cout << "    P     L2 :" <<sqrt(int3d(Th)(square(P))) << endl;
cout << "    p     L2 :" <<sqrt(int3d(Th)(square(p))) << endl;
assert(errL2<0.05);
~~~

|The solution            |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/LaplaceRT-3d/solution.png
---
name: extract-boundary-3d
category: mesh
folder: 3d
---

## Extract from the mesh the boundary with a given label

The cube has 6 faces, each with a different label. The function $\texttt{extract}$ returns a surface mesh on which all vertices have the given label
~~~freefem
load "medit"
int n= 10;
int nvb = (n+1)^3 - (n-1)^3;// Nb boundary vertices
int ntb = n*n*12; // Nb of Boundary triangle 
mesh3 Th=cube(n,n,n); // lalels are from 1 to 6
int[int] ll=[1,3];//for example
meshS ThS=extract(Th,label=ll);// extract boundary of 3d Mesh with given label
plot(ThS);
~~~

| The surface mesh extracted |
|----------------------------|
|![][_solution]              |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/extract-boundary3d/solution.png
---
name: Periodic-cube-ballon
category: math
layout: 3d
---

## Solution of a Poisson problem  with discontinuous coefficient in a cube with a sphere inside for the discontinuity

The surface mesh of the cube is built by glueing the 6 meshes of the faces. The mesh of the sphere is built by mapping the mesh of a square

So first the 6 surface meshes for the cube
~~~freefem
verbosity=1;

load "tetgen"
load "medit"
 
// 
meshS ThHex;
real volumetet;  // use in tetg.
{
	//  first  build the 6 faces of the hex.
real x0=-1,x1=1;
real y0=-1.1,y1=1.1;
real z0=-1.2,z1=1.2;

int nx=19,ny=20,nz=21;
//  a  volume  of  on tet. 
volumetet= (x1-x0)*(y1-y0)*(z1-z0)/ (nx*ny*ny) /6.;

mesh Thx = square(ny,nz,[y0+(y1-y0)*x,z0+(z1-z0)*y]);
mesh Thy = square(nx,nz,[x0+(x1-x0)*x,z0+(z1-z0)*y]);
mesh Thz = square(nx,ny,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

int[int] refz=[0,5];  //  down
int[int] refZ=[0,6];   //  up
int[int] refy=[0,3];  //  front
int[int] refY=[0,4];   // back
int[int] refx=[0,1];  // left
int[int] refX=[0,2];   // right


meshS Thx0 = movemesh23(Thx,transfo=[x0,x,y],orientation=-1,region=refx,removeduplicate=false); 
meshS Thx1 = movemesh23(Thx,transfo=[x1,x,y],orientation=1,region=refX,removeduplicate=false);
meshS Thy0 = movemesh23(Thy,transfo=[x,y0,y],orientation=+1,region=refy,removeduplicate=false);
meshS Thy1 = movemesh23(Thy,transfo=[x,y1,y],orientation=-1,region=refY,removeduplicate=false);
meshS Thz0 = movemesh23(Thz,transfo=[x,y,z0],orientation=-1,region=refz,removeduplicate=false);
meshS Thz1 = movemesh23(Thz,transfo=[x,y,z1],orientation=+1,region=refZ,removeduplicate=false);

//medit("  --- ", Thx0,Thx1,Thy0,Thy1,Thz0,Thz1);
 ThHex = Thx0+Thx1+Thy0+Thy1+Thz0+Thz1;
 
}
meshS Thsph;
~~~
Then the surface mesh of the sphere
~~~freefem
{
mesh  Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a paratrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  de  partiel derivatrive of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  // to store the periodic condition 

// the intial mesh
//savemesh(Th,"sphere",[f1,f2,f3]);

real R=0.5,hh=0.1/R;// hh  taille du maille sur la shere unite. 
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,inquire=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);

Thsph = movemesh23(Th,transfo=[f1*R,f2*R,f3*R],orientation=-1,removeduplicate=false);
}
~~~
Then define the final volumic mesh and the PDE
~~~freefem
meshS ThS = ThHex+Thsph; // "glueing" all the surface meshes
//medit("Bounday mesh",ThS,wait=1);
// build a mesh of a axis parallel box with TetGen
real[int] domaine = [0,0,0,1,volumetet,0,0,0.7,2,volumetet];
mesh3 Th = tetg(ThS,switch="pqaAAYYQ",nbofregions=2,regionlist=domaine);    
// Tetrahelize the interior of the cube with tetgen
medit("tetg",Th,wait=1);
//savemesh(Th,"Th-hex-sph.mesh");

fespace Ph(Th,P03d);
Ph reg=region;

cout << "  centre = " << reg(0,0,0) << endl;
cout << " exterieur = " << reg(0,0,0.7) << endl;

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

fespace Vh(Th,P13d);
Vh uh,vh;
real f=1.;
real gn = 1.;
real cf= 1;
problem P(uh,vh)=
   int3d(Th,1)( Grad(uh)'*Grad(vh)*100) 
  +  int3d(Th,2)( Grad(uh)'*Grad(vh)*2) 
  + int3d(Th) (vh*f)
  + on(-1,uh=-1) + on(1,uh=1) 
  + int2d(Th,2,-2)(vh*gn)
  + int2d(Th,3,-3)(cf*vh*uh)
  ; 
  P;
  
// FFCS: with 3D view parameters
real[int] CameraPositionValue = [3.50634,-2.51489,2.60313];
real[int] CameraFocalPointValue = [0.0604689,-0.304636,-0.256484];
real[int] CameraViewUpValue = [0.7198,0.502367,-0.479078];
real[int] CutPlaneOriginValue = [-0.5,-0.55,0.0335184];
real[int] CutPlaneNormalValue = [0,0,1];

plot(uh,wait=1, nbiso=6,
	BorderAsMesh = 1,
	CameraPosition=CameraPositionValue,
	CameraFocalPoint=CameraFocalPointValue,
	CameraViewUp=CameraViewUpValue,
	CutPlaneOrigin=CutPlaneOriginValue,
	CutPlaneNormal = CutPlaneNormalValue);
medit("   uh ",Th, uh,wait=1); 

~~~

| The solution displayed with medit and plot |
|------------------------|
|![][_solution]          |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/3d/Poisson-cube-ballon/solution.png
real nu=0.01,dt=0.3;
real alpha=1./dt,alpha2=sqrt(alpha);

int nn=5;

mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);

fespace VVh(Th,[P23d,P23d,P23d,P13d]);
fespace Vh(Th,P23d);
fespace Ph(Th,P13d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  
  varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3)
             - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
 +  on(2,u1=1.,u2=0,u3= 0)
 + on(1,u1=0,u2=0,u3=0)
 ;

cout << "b  mat " << endl;

matrix A=vStokes(VVh,VVh);
cout << "e  mat " << endl;
set(A,solver=sparsesolver);
cout << "e fac  mat " << endl;
real[int] b= vStokes(0,VVh);

VVh [u1,u2,u3,p];
VVh [X1,X2,X3,Xp];
VVh [x1,x2,x3,xp]=[x,y,z,0];



u1[]= A^-1 * b;

ux= u1(x,0.5,y);
uz= u3(x,0.5,y);
p2= p(x,0.5,y);
plot([ux,uz],p2,cmm=" cut y = 0.5",wait=1);
macro XX1() (x-u1*dt)//
macro XX2() (y-u2*dt)//
macro XX3() (z-u3*dt)//

  varf vNS([uu1,uu2,uu3,p],[v1,v2,v3,q]) = 
  int3d(Th)( alpha*(uu1*v1+uu2*v2+uu3*v3) + nu*(Grad(uu1)'*Grad(v1) +  Grad(uu2)'*Grad(v2) +  Grad(uu3)'*Grad(v3))
  - div(uu1,uu2,uu3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,uu1=1,uu2=0,uu3=0)
  + on(1,uu1=0,uu2=0,uu3=0)
   +  int3d(Th,optimize=1)(   alpha*(  u1(X1,X2,X3)*v1  +  u2(X1,X2,X3)*v2  +  u3(X1,X2,X3)*v3 )  ) ;
//  +  int3d(Th,optimize=1)(   alpha*(  u1(XX1,XX2,XX3)*v1  +  u2(XX1,XX2,XX3)*v2  +  u3(XX1,XX2,XX3)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1(x,y,z)*v1  +  u2(x,y,z)*v2  +  u3(x,y,z)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1*v1  +  u2*v2  +  u3*v3 )  ) ;

cout << " build  A" << endl;
A = vNS(VVh,VVh);
cout << " fac A" << endl;
set(A,solver=sparsesolver);
real t=0;
for(int i=0;i<10;++i)
  {
    t += dt;
    cout << " iteration " << i << " t = " << t << endl;
    X1[]=x1[]+u1[]*(-dt);
    //    verbosity=200;
    b=vNS(0,VVh);
    verbosity=2;
    u1[]= A^-1 * b;
    ux= u1(x,0.5,y);
    uz= u3(x,0.5,y);
    p2= p(x,0.5,y);
    plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=0);
    if(0)
    {
      exec("mkdir dd");
      string prefu="dd/u-"+(100+i);
      string prefp="dd/p-"+(100+i);
      savemesh(Th,prefu+".mesh");
      savemesh(Th,prefp+".mesh");
     
      ofstream file(prefu+".bb"); 
      ofstream filep(prefp+".bb"); 
      Ph up1=u1,up2=u2,up3=u3,pp=p;
      file << "3 1 3 "<< up1[].n << " 2 \n";
      filep << "3 1 1 "<< pp[].n << " 2 \n";
      for (int j=0;j<up1[].n ; j++)  
	{
	  file << up1[][j] <<" " <<up2[][j] <<" "<< up3[][j] <<"\n";
	  filep << pp[][j] <<  endl; 
	}  
    }
  }
plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=1);
real REFadapt=0.238852;
real REFadaptindicatorP1=0.23912;
real REFadaptindicatorP2=0.239362;
real REFalgo=0.283072;
real REFaXtutorial=1.00032;
real REFbeam=2.19089;
real REFcavity=0.423606;
real REFconvect2=2.59152;
real REFconvectXapt=0.0016933;
real REFconvect=10.2173;
real REFFE=84.7687;
real REFfluidStructAdapt=3.87121;
real REFfluidStruct=1.25804;
real REFLapDG2=2.04648;
real REFLaplace=0.167397;
real REFLaplaceP1bis=3.4845e-14;
real REFLaplaceP1=2.34669;
real REFLaplaceP1P2h=8.60123;
real REFLaplaceRT=0.433835;
real REFmovemesh=42.35;
real REFnolinearXelas=1.00047;
real REFNSUzawaCahouetChabart=2.02821;
real REFonde=146.865;
real REFplot=85.3776;
real REFreadmesh=107.273;
real REFregion=0.01116;
real REFschwarzXgc=3.25892;
real REFschwarzXnoXoverlap=5.07864;
real REFschwarzXoverlap=5.05857;
real REFsparseXmatrix=116.382;
real REFsparseXcmatrix=232.764;
real REFStokesUzawa=32.7781;
real REFtablefunction=66.5851;
real a;
try { 
  a=1./0.;
}
catch  (...) 
{
  cout << " get a ExecError " << endl;
  a =0;
}

verbosity=10;

int nn=5	;
mesh Th=square(nn,nn);
verbosity=5;
fespace Vh(Th,P1);     // P1 FE space
Vh uh,vh;              // unkown and test function. 
func f=1;                 //  right hand side function 
func g=0;                 //  boundary condition function
real   cpu=clock(); 
problem laplace(uh,vh,solver=Cholesky,tolpivot=1e-6) =                    //  definion of  the problem 
int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int2d(Th)( -f*vh )                          //  linear form
  ;

try {
  cout << " Try Cholesky \n";
  laplace; // solve the problem plot(uh); // to see the result
  cout << "-- lap Cholesky " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
} 
catch(...) {
  cout << " Catch cholesky PB " << endl;
}


/*
   Solving the following Poisson problem 
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$, 
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$ 
   $ p = gd  $ on $\Gamma_{1}$ 
  with de Mixte finite element formulation 
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than  
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $ 
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$ 

*/
mesh Th=square(10,10);
fespace Vh(Th,RT0);
fespace Ph(Th,P0);

func gd = 1.;
func g1n = 1.;
func g2n = 1.; 
func f = 1.;

Vh [u1,u2],[v1,v2];
Ph p,q; 

problem laplaceMixte([u1,u2,p],[v1,v2,q],solver=sparsesolver,eps=1.0e-10,tgv=1e30,dimKrylov=150) =
   int2d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
 + int2d(Th) ( f*q)
 - int1d(Th,1,2,3)( gd*(v1*N.x +v2*N.y))   //  int on gamma 
 + on(4,u1=g1n,u2=g2n);

 laplaceMixte;
 plot([u1,u2],coef=0.1,wait=1,ps="lapRTuv.eps",value=true); 
 plot(p,fill=1,wait=1,ps="laRTp.eps",value=true);  
 mesh Th=square(10,10,[2*x*pi,2*y*pi]);
 fespace Vh(Th,P2,periodic=[[2,y],[4,y],[1,x],[3,x]]);     // the label 2 and 4 are periodic
 //  [a1,b1,b2,f1],[b,fb] the degree of freedom of of the border a1,b1,c1 and b are equivalent 
 //  via fonctions f1 and f2 
 //  here full periodic in x and y direction
 Vh uh,vh;              // unkown and test function. 
 func f=sin(x+pi/4.)*cos(y+pi/4.);                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int2d(Th)( -f*vh )                          //  linear form
;                

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="period.eps",value=true);
assert(version>=1.24); //  for big bug is non symetric matrix see HISTORY, and sign in int1d 
int method1=0;
int iwait=0;
include "beam.edp"
// Stokes on square  b,e,f,g  driven cavite on left side g 
border e(t=0,10) { x=t; y=-10; label= 1; };      //  bottom
border f(t=0,10) { x=10; y=-10+t ; label= 1; };   //  right
border g(t=0,10) { x=0; y=-t ;label= 2;};       //  left
border h(t=0,10) { x=t; y=vv(t,0)*( t>=0.001 )*(t <= 9.999); label=3;};   //  top of cavity deforme 

real err=10;
mesh sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
plot(sh,wait=iwait);

fespace Xh(sh,P2),Mh(sh,P1);
fespace V1h(sh,P2);

Xh u1,u2,v1,v2;
Mh p,q,ppp;

real veps=1e-4;
varf bx(u1,q) = int2d(sh)( -(dx(u1)*q)); 

varf by(u1,q) = int2d(sh)( -(dy(u1)*q));

varf Lap(u1,u2)= int2d(sh)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                   +  on(2,u1=1) +  on(1,3,u1=0)   ;

varf Mass(p,q)=int2d(sh)(p*q);

Xh bc1; 
Xh brhs;
string solver="UMFPACK";
if(!HaveUMFPACK) solver="CHOLESKY";
                   
matrix A= Lap(Xh,Xh,solver=solver); 
matrix M= Mass(Mh,Mh,solver=solver); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);
func cly =(-y)*(10.+y)/25.;
Xh bcx=0,bcy=cly;
func real[int] divup(real[int] & pp)
{ //  
  int verb=verbosity;
   verbosity=1;
   brhs[]  = Bx'*pp; brhs[] += bc1[] .*bcx[];
   u1[] = A^-1*brhs[];
   brhs[]  = By'*pp; brhs[] += bc1[] .*bcy[];
   u2[] = A^-1*brhs[];
   ppp[] = M^-1*pp;
   ppp[] = 1.e-6*ppp[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   return ppp[] ;
};
p=0;q=0;u1=0;v1=0;

int i;
 th1 = movemesh(th, [x+uu, y+vv]);
for( i=0;i<6;i++)
 {    
 bc1=0; 
 brhs=0;
 bc1[] = Lap(0,Xh);
 q=0;   
 verbosity=50;
 LinearCG(divup,p[],veps=veps,nbiter=100);
 divup(p[]);
 verbosity=1;
 plot([u1,u2],p,wait=iwait,value=true,coef=0.1);

 real coef=0.2;

Vh [uu1,vv1];
[uu1,vv1]=[uu,vv];

if(method1==1)
 {
 V1h sigma11,sigma22,sigma12;

  sigma11([x+uu,y+vv]) = (2*dx(u1)-p);
  sigma22([x+uu,y+vv]) = (2*dy(u2)-p);
  sigma12([x+uu,y+vv]) = (dx(u2)+dy(u1));

solve  bbst([uu,vv],[w,s],init=i)  = 
    int2d(th)(
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
              )
  + int2d(th) (-gravity*s)
  + int1d(th,bottombeam)( coef*(sigma11*N.x*w + sigma22*N.y*s + sigma12*(N.y*w+N.x*s) )  )
  + on(1,uu=0,vv=0) 
  ;
  }
 else
 {
 // this piece of code is crucial to mixe adaptation and fluid structure 
 fespace  Vh11(th1,[P1,P1]);
 varf vFS([yyyy],[w,s])= int1d(th1,bottombeam)( 
     coef*((2*dx(u1)-p)*N.x*w + (2*dy(u2)-p)*N.y*s + (dx(u1)+dy(u2))*(N.y*w+N.x*s)) 
   );
 Vh11 [FS,FS1];[FS,FS1]=[0,0];
 FS[]= vFS(0,Vh11);
 cout << FS[].min << " " << FS[].max << endl;
 
 plot([FS,FS1],wait=iwait,value=1);
 solve  bbst2([uu,vv],[w,s],init=i)  = 
    int2d(th)(
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
              )
  + int2d(th) (-gravity*s)
  + FS[] // + int1d(th,bottombeam)( coef*(sigma11*N.x*w + sigma22*N.y*s + sigma12*(N.y*w+N.x*s) )  )
  + on(1,uu=0,vv=0) 
  ;
   
 }
 //plot([uu,vv],wait=1);
  err = sqrt(int2d(th)( (uu-uu1)^2 + (vv-vv1)^2 )); 
 cout << " ----- Iteration = " << i <<  " Erreur L2 = " << err << "----------\n";
 cout << " max deplacement " << uu[].linfty << endl;
 bool iadapt=err>0.05;
 if(iadapt)
 th = adaptmesh(th,[uu,vv],err=1.e-2);
 [uu,vv]=[uu,vv];
 [w,s]=[0,0];
 
 th1 = movemesh(th, [x+uu, y+vv]);
 //plot(th1,wait=1);
 if(method1==1)
   sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
 else 
  {
    fespace VVh(sh,P1);VVh  uh,vh;
    solve lapllll(uh,vh,solver=sparsesolver,tgv=1e5) =                    //  definion of  the problem 
    //  compute a deformation field for moving the fluid mesh
    
    //  x -> vv(x,0) is the new deformation y 
    //  x -> y is the position of the mesh on border 3
    int2d(sh)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
    + on(1,2,uh=0)+ on(3,uh=(vv(x,0)-y)*( x>=0.001 )*(x <= 9.999))  ;    //  boundary condition form
    
    sh = movemesh(sh,[x,y+uh]);
   if(iadapt)
    {
    sh = adaptmesh(sh,[u1,u2],p,err=2.e-2);
    lapllll;  
    sh = movemesh(sh,[x,y+uh]);    
    }
    plot(th1,sh,wait=iwait);
    p=p;
    u1=u1; 
    u2=u2;
    A= Lap(Xh,Xh,solver=sparsesolver); 
    M= Mass(Mh,Mh,solver=sparsesolver); 
    Bx= bx(Xh,Mh);
    By= by(Xh,Mh);
    bcx=0;
    bcy=cly;
  }


 p=p;q=q;u1=u1;u2=u2;brhs=brhs;ppp=ppp;
 A= Lap(Xh,Xh,solver=sparsesolver); 
 M= Mass(Mh,Mh,solver=sparsesolver); 
 Bx= bx(Xh,Mh);
 By= by(Xh,Mh);
 bc1=0;  // for resize
 bc1[] = Lap(0,Xh);
}
cout << " max deplacement " << uu[].linfty << endl;
// Mesh
border a(t=0, 1.0){x=t;   y=0;   label=1;}
border b(t=0, 0.5){x=1;   y=t;   label=2;}
border c(t=0, 0.5){x=1-t; y=0.5; label=3;}
border d(t=0.5, 1){x=0.5; y=t;   label=4;}
border e(t=0.5, 1){x=1-t; y=1;   label=5;}
border f(t=0.0, 1){x=0;   y=1-t; label=6;}
mesh Th = buildmesh (a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
savemesh(Th, "th.msh");

// Fespace
fespace Vh(Th, P1);
Vh u, v;

// Problem
problem Probem1(u, v, solver=CG, eps=1.0e-6)
	= int2d(Th, qforder=2)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	+ int2d(Th, qforder=2)((x-y)*v)
	;

// Adaptation loop
int i;
real error = 0.01;
for (i = 0; i < 4; i++) {
	// Solve
	Probem1;
	cout << u[].min << " " << u[].max << endl;

	// Plot
	plot(u,wait=1);

	// Mesh adaptation
	Th = adaptmesh(Th, u, err=error);
	plot(Th, wait=1);

	// Interpolation
	// on the new mesh
	u = u;

	// Error update
	error = error/2;
}
assert(version>=1.24); //  for big bug is non symetric matrix see HISTORY, and sign in int1d 
include "beam.edp"
// Stokes on square  b,e,f,g  driven cavite on left side g 
border e(t=0,10) { x=t; y=-10; label= 1; };      //  bottom
border f(t=0,10) { x=10; y=-10+t ; label= 1; };   //  right
border g(t=0,10) { x=0; y=-t ;label= 2;};       //  left
border h(t=0,10) { x=t; y=vv(t,0)*( t>=0.001 )*(t <= 9.999); label=3;};   //  top of cavity deforme 


mesh sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
plot(sh,wait=1);

fespace Xh(sh,P2),Mh(sh,P1);
fespace V1h(sh,P1dc);

Xh u1,u2,v1,v2;
Mh p,q,ppp;


varf bx(u1,q) = int2d(sh)( -(dx(u1)*q)); 

varf by(u1,q) = int2d(sh)( -(dy(u1)*q));

varf Lap(u1,u2)= int2d(sh)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                   +  on(2,u1=1) +  on(1,3,u1=0)   ;

varf Mass(p,q)=int2d(sh)(p*q);

Xh bc1; 
Xh brhs;
string solver="UMFPACK";
if(!HaveUMFPACK) solver="CHOLESKY";
                   
matrix A= Lap(Xh,Xh,solver=solver); 
matrix M= Mass(Mh,Mh,solver=solver); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);

Xh bcx,bcy;
func real[int] divup(real[int] & pp)
{ //  
  int verb=verbosity;
   verbosity=1;
   brhs[]  = Bx'*pp; brhs[] += bc1[] .*bcx[];
   u1[] = A^-1*brhs[];
   brhs[]  = By'*pp; brhs[] += bc1[] .*bcy[];
   u2[] = A^-1*brhs[];
   ppp[] = M^-1*pp;
   ppp[] = 1.e-6*ppp[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   return ppp[] ;
};
p=0;q=0;u1=0;v1=0;

int i;
for( i=0;i<2;i++)
 {    
bcx=0;
bcy= (-y)*(10.+y)/25.;

 cout << " loop " << i << endl; 
 bc1[] = Lap(0,Xh);
 q=0;   
 verbosity=50;
 LinearCG(divup,p[],eps=1.e-3,nbiter=50);
 divup(p[]);
 verbosity=1;
 plot([u1,u2],p,wait=1,value=true,coef=0.1,cmm="[u1,u2],p");

 real coef=0.2;

V1h sigma11,sigma22,sigma12;
Vh [uu1,vv1];
  [uu1,vv1]=[uu,vv];

  sigma11([x+uu,y+vv]) = (2*dx(u1)-p);
  sigma22([x+uu,y+vv]) = (2*dy(u2)-p);
  sigma12([x+uu,y+vv]) = (dx(u2)+dy(u1));


solve  bbst([uu,vv],[w,s],init=i)  = 
    int2d(th)(
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
             )
  + int2d(th) (-gravity*s)
  + int1d(th,bottombeam)( coef*(sigma11*N.x*w + sigma22*N.y*s + sigma12*(N.y*w+N.x*s) )  )
  + on(1,uu=0,vv=0) 
  ;
cout << " max deplacement " << uu[].linfty << " " << uu[].min << " " << uu[].max <<endl;
 plot([uu,vv],wait=1);
 real  err = sqrt(int2d(th)( (uu-uu1)^2 + (vv-vv1)^2 )); 
 cout << " ----- Iteration = " << i <<  " Erreur L2 = " << err << "----------\n";
 th1 = movemesh(th, [x+uu, y+vv]);
 plot(th1,wait=1);
 sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
 plot(sh);
 p=p;q=q;u1=u1;u2=u2;brhs=brhs;ppp=ppp;
 A= Lap(Xh,Xh,solver=sparsesolver); 
 M= Mass(Mh,Mh,solver=sparsesolver); 
 Bx= bx(Xh,Mh);
 By= by(Xh,Mh);
 bc1=0;  // for resize
 bc1[] = Lap(0,Xh);
}
cout << " max deplacement " << uu[].linfty << endl;
assert(  abs(0.219964 -uu[].linfty ) < 5e-2); // 0.176678
real [int,int] a(10,10);
real [int,int] aa(2,3);
for [i,j,aij : aa] 
{
   aij= 1.+i+2*j;
   cout << i << " "<< j << " " << aij << endl; 
}
	
real [int] b(10);
for [i,bi : b] {bi=i+1; cout << i << " " << bi << endl;}
cout << " b="<< b<< endl;  
for [i,j,aij : a] 
{
   aij= 1.+i+2*j;
   if(abs(i-j)>2) aij=0;
}
cout << a(1,2) << " == " << 1.+1+2*2 << endl; 
assert(abs(a(1,2)- (1.+1+2*2))<1e-9);
cout << " a= "<< a << endl; 
matrix A=a;
string[string] ss;
ss["1"]= 1;
ss["2"]= 2;
ss["3"]= 5;
for [i,bi : ss] 
    ss[i]=bi+i+6+"-dddd"; 
cout <<" ss = "<< ss << endl;
int[string] si;
si[1]=2;
si[50]=1;
for [i,vi : si]
   {
   cout << " i " << setw(3) << i << " " << setw(10) <<vi << endl;
    vi= atoi(i)*2;
    }

cout <<" si = "<< si << endl;
for [i,j,aij : A]
{
    cout << i<< " " << j <<" " <<  aij << endl; 
    aij= -aij;
}
cout << A << endl; 
real[string] sd;
sd["1"]= 1;
sd["2"]= 2;
sd["3"]= 5;
for [i,bi : sd] 
    bi=bi*bi;
cout << "sd=\n"<< sd <<endl ;
// FFCS: for regression tests
real regtest;
{
 // build from bamg geometrie

  { // build the geom file
    ofstream ff("g.mesh");
    int n = 8;
    real h = 0.1;
    ff <<"MeshVersionFormatted 0\n";
    ff <<"AngleOfCornerBound 46\n";
    ff <<"Dimension 2 \n";
    ff << "Vertices "<< n <<  endl;
    for (int i=0;i<n;i++)
      ff << cos(i*pi*2./n) << " " << sin(i*pi*2./n) << " 1\n"; 
    
    ff << "Edges "<< n<< endl;
    for (int i=0;i<n;i++)
      ff << i+1 << " " << (i+1)%n +1 << " 1\n";
    
    ff << "hVertices"<< endl;
    for (int i=0;i<n;i++)
      ff << h << endl;
  }
  
  mesh Th=buildmesh("g.mesh",nbvx=100000);
  plot(Th,wait=1);
}

//    example for mesh work 
// --------------------------
{ // square 
  real x0=1.2,x1=1.8;
  real y0=0,y1=1;
  int n=5,m=20;
  mesh Th=square(n,m,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
  int[int] lab=[5,5,5,5]; // the 4 side 1,2,3,4 have label 5
  mesh th=square(4,5,label=lab,region=1);
  plot(Th,th,ps="twosquare.eps");
  
  // mesh of a ring with no duplication of point and edge on common border.
  mesh Th2=square(19,5,[(1+y)*cos(2*pi*x),(1+y)*sin(x*pi*2)],removeduplicate=1)   ;
   plot(Th2,wait=1);
  

}
// ------------------------------------------------------------
{ //    hole 
real pi=4*atan(1);
border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
border b(t=0,2*pi){ x=0.3+0.3*cos(t); y=0.3*sin(t);label=2;}
border c(t=0,2*pi){ x=0.3+0.0001*cos(t); y=0.0001*sin(t);label=2;}
mesh Thwithouthole= buildmesh(a(50)+b(+30));
mesh Thwithhole   = buildmesh(a(50)+b(-30));
// to change the default maximun number of vertices to 100000
mesh Thwithtinyhole   = buildmesh(a(50)+c(-5),nbvx=100000); 
plot(Thwithouthole,wait=1,ps="Thwithouthole.eps");
plot(Thwithhole,wait=1,ps="Thwithhole.eps");
plot(Thwithtinyhole,wait=1,ps="Thwithtinyhole.eps");

}
// ------------------------------------------------------------
{ //  square with border and no edge with two vextices on border 
border a(t=0,2){x=t; y=0;label=1;};
border b(t=0,1){x=2; y=t;label=1;};
border c(t=2,0){x=t; y=1;label=1;};
border d(t=1,0){x=0; y=t;label=1;};
int n = 20;
plot(a(2*n)+b(n)+c(2*n)+d(n),wait=1,ps="squarebb.eps");
mesh th= buildmesh(a(2*n)+b(n)+c(2*n)+d(n),splitpbedge=1); 
plot(th,ps="squareb.eps",wait=1,cmm=" with splitpbedge=1");
}
// ------------------------------------------------------------
// bug before version 2.24
{ // L shape 
border a(t=0,1){x=t;y=0;label=1;};
border b(t=0,0.5){x=1;y=t;label=1;};
border c(t=0,0.5){x=1-t;y=0.5;label=1;};
border d(t=0.5,1){x=0.5;y=t;label=1;};
border e(t=0.5,1){x=1-t;y=1;label=1;};
border f(t=0,1){x=0;y=1-t;label=1;};
assert(version >= 2.24);
 func abc=  a(6) + b(4) + c(4)  ;
 func def = d(4) + e(4) + f(6);
 plot(abc  + def,wait=1);
mesh rh = buildmesh (abc  + def );
plot(rh,ps="lshape.eps");

}
// ------------------------------------------------------------
{ // readmesh 
  mesh th("aile.msh");
  plot(th);
  
}
// ------------------------------------------------------------
{ // movemesh 
  real Pi=atan(1)*4;
  verbosity=4;
  border a(t=0,1){x=t;y=0;label=1;};
  border b(t=0,0.5){x=1;y=t;label=1;};
  border c(t=0,0.5){x=1-t;y=0.5;label=1;};
  border d(t=0.5,1){x=0.5;y=t;label=1;};
  border e(t=0.5,1){x=1-t;y=1;label=1;};
  border f(t=0,1){x=0;y=1-t;label=1;};
  func uu= sin(y*Pi)/10;
  func vv= cos(x*Pi)/10;
  
  mesh Th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
  
  // find a good deformation coef. 
  // ---------------------------------
  // return the minimal area of a triangle of Th 
  real okareamin = checkmovemesh(Th,[x,y])/10;
  // we accept to divide by 10 the area of the smallest triangles
  real coef=1000,cc=0;
  while (okareamin > (cc=checkmovemesh(Th,[x+coef*uu,y+coef*vv]) ) )
    {
      cout << " coef = " << coef << " min area " << cc << endl;
      coef /=2;
    }
  
  
  Th=movemesh(Th,[x+coef*uu,y+coef*vv]);
  plot(Th,wait=1,fill=1,ps="movemesh.eps");
  
  // save mesh 
  int i=12;
  string filename="Th"+i+".msh";
  savemesh(Th,filename);
}
// ------------------------------------------------------------
{  //  trunc mesh  tools exemples 
  mesh Th=square(3,3);
  int[int] n2o(1); 
  fespace Vh(Th,P1);
  Vh u;	
  int i,n=u.n;
  u=0;
  for (i=0;i<n;i++)
    {
      u[][i]=1;
      plot(u,wait=1);
      mesh Shi=trunc(Th,abs(u)>1e-10,split=2,label=2,new2old=n2o,fregion=i+0);
      int [int] lr = regions(Shi);
	  cout<< "regions " <<  i << " :: " << lr.n << " " << lr[0] << endl; 
	  assert( lr.n ==1 && lr[0] == i);
      plot(Th,Shi,wait=1,ps="trunc"+i+".eps");                    
      cout << " n2o " << n2o << endl; // where the element come
      u[][i]=0;
    }
}
// ------------------------------------------------------------
{  //  new stuff 2004 splitmesh (version 1.37)
  assert(version>=1.37);
  border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
  mesh Th=buildmesh(a(20));
  plot(Th,wait=1,ps="nosplitmesh.eps");
  plot(Th,wait=1);
  Th=splitmesh(Th,1+5*(square(x-0.5)+y*y));
  plot(Th,wait=1,ps="splitmesh.eps");
}

// ------------------------------------------------------------
{  //  new stuff 2004 emptymesh (version 1.40)
 // -- usefull to build Multiplicator space 
 //  build a mesh without internal point
 // with the same boundary 
 //  -----
  assert(version>=1.40);
  border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
  mesh Th=buildmesh(a(20));
  plot(Th,wait=1,ps="nosplitmesh.eps");
  plot(Th,wait=1);
  Th=emptymesh(Th);
  plot(Th,wait=1,ps="emptymesh-1.eps");
}
{  //  new stuff 2004 emptymesh (version 1.40)
 // -- usefull to build Multiplicator space 
 //  build a mesh without internal point
 //   if the adj triangle 
 //  -----
  assert(version>=1.40);
  mesh Th=square(10,10);
  int[int] ssd(Th.nt);
  fespace Ph(Th,P0);
   Ph sd;
  for(int i=0;i<ssd.n;i++)
   {  int iq=i/2;   // because 2 traingle per quad 
      int ix=iq%10;
      int iy=iq/10;  
    ssd[i]= 1 + (ix>=5) +  (iy>=5)*2;
    sd[][i]=ssd[i];
   }
  plot(sd,fill=1,wait=1);
  Th=emptymesh(Th,ssd);
  plot(Th,wait=1,ps="emptymesh-2.eps");
  savemesh(Th,"emptymesh-2.msh");
}

  // ------------------------------------------------------------
{  // get mesh information (version 1.37)
  mesh Th=square(2,2);
  // get data of the mesh 
  int nbtriangles=Th.nt;
  cout << " nb of Triangles = " << nbtriangles << endl;
  for (int i=0;i<nbtriangles;i++)
    for (int j=0; j <3; j++)
      cout << i << " " << j << " Th[i][j] = "
	   << Th[i][j] << "  x = "<< Th[i][j].x  << " , y= "<< Th[i][j].y 
	   << ",  label=" << Th[i][j].label << endl;
	    
//   Th(i)   return   the vextex i of Th
//   Th[k]   return   the triangle k of Th.
//   Th.be(i)  return  the boundary element 
  fespace femp1(Th,P1);
  femp1 Thx=x,Thy=y; 
  // get vertices information : 
  int nbvertices=Th.nv;
  cout << " nb of vertices = " << nbvertices << endl;
  for (int i=0;i<nbvertices;i++)
	cout << "Th(" <<i  << ") : "   // << endl;	
	     << Th(i).x << " " << Th(i).y  << " " << Th(i).label // version 2.19 
	     << "       old method: " << Thx[][i] << " " << Thy[][i] << " == R3  "  
	     << Th(i).P << endl; // version 4.10.1  jan 2022

// method to find information of point (0.55,0.6) 
  int it00 = Th(0.55,0.6).nuTriangle;// then triangle numbe 
  int nr00 = Th(0.55,0.6).region;
  
  real area00 = Th[it00].area; // new in version 2.19 
  real nrr00 = Th[it00].region; // new in version 2.19 
  real nll00 = Th[it00].label; // same as region in this case.
      
 //Hack  to get a triangle contening point x,y
  //     or   region number
  // -----------------------------------------
  fespace femp0(Th,P0);
  femp0 nuT; // a P0 function  to get triangle numbering
    for (int i=0;i<Th.nt;i++)
     nuT[][i]=i; 
  femp0 nuReg=region; // a P0 function to get the region number
  //  inquire 
  int it0=nuT(0.55,0.6); //  number of triangle Th's contening point (0.55,0,6);
  int nr0=nuReg(0.55,0.6); //  number of region of Th mesh contening point (0.55,0,6);
  // dump  
  cout << "  point (0.55,0,6) :triangle number " << it00 << " " << it00 
       << ", region = " << nr0 << " == " << nr00 << ",  area K " << area00 << endl;

  // new method to get boundary inforamtion 
 
  // version >3.4-1
  // --------- new stuff -----------------
  int k=0,l=1,e=1,v=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th(v).P; // coordinate of vetices v in R3 ::  22 jan 2022
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2])
	 << " , label  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<3;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " , label " << Th.be(k).label 
	   <<  " tria  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 

regtest=Th.nv;
}
//   test to catch bogus boundary ( just a test)
{
int err;
real c0,c1;
c0=0;
c1=0;
mesh Th;
for( int i=0;i<=4;i++)
{
    c1=sin(i*pi/8);
try 
{
err=0; 
border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
border b(t=0,2*pi){ x=c0+0.3*cos(t); y=c1+0.3*sin(t);label=2;}
plot(a(50)+b(30),wait=1);
Th   = buildmesh(a(50)+b(30));
}
catch(...)
{
  err=1;
  plot(a(50)+b(30),wait=1,cmm="bogus border ",ps="bogusborder.eps");  
}
if(err==0)
  plot(Th,wait=1,cmm="mesh ok");
}
}
// <<multiborder>>
// in test ... 
{ 
// multy border syntax version 3.30 avril 2014 ... 
  real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
  // radius, centre of the 4 circles .. 
  real[int] RC=[ 0.1, 0.05, 0.05, 0.1],
            XC= [0.2,0.8,0.2,0.8],
            YC= [0.2,0.8,0.8,0.2];
  int[int]  NC=[-10,-11,-12,13]; //list number of $\pm$ segments
  // of the 4 circles borders  

  border bb(t=0,1;i) 
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 0; ; 
  }
  
  border cc(t=0,2*pi;i) 
 {
    x = RC[i]*cos(t)+XC[i];
    y = RC[i]*sin(t)+YC[i];
    label = i+1; 
  }
  int[int] nn=[4,4,5,7];// 4 border , with 4,4,5,7 segment respectively . 
  plot(bb(nn),cc(NC),wait=1);
  mesh th= buildmesh(bb(nn)+cc(NC)) ; 
  plot(th,wait=1,ps="multy-border.eps");
  // version 3.44-1
  cout << " th max mesh size = h = " << th.hmax << endl;
  cout << " th min mesh size     = " << th.hmin<< endl;
}
{
	include "movemeshsmooth.idp"
	mesh Th=square(3,3);
	int[int] lab=[1,2,3,4]; 
	Th=adaptmesh(Th,0.1,IsMetric=1);
	fespace Vh(Th,P1); 

	Vh u=x,v=y;
	verbosity=5;// 1000 debbug => plot 
	Th=movemeshsmooth(Th,lab,u[],v[],100);
	verbosity=1;
}
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
// build square $]-1,1[^2$
mesh Th=square(10,10,[2*x-1,2*y-1]); 
fespace Vh(Th,P1);
Vh u=2-x*x-y*y;
// old code ::
if(1)
{
   savemesh(Th,"mm",[x,y,u*.5]); //  save mm.points and mm.faces file for medit
   // build a mm.bb file 
	{ ofstream file("mm.bb"); 
	file << "2 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << u[][j] << endl; 
    }  
    // call ffmedit command 	
    if(!NoGraphicWindow) exec("ffmedit mm");
    // clean files
    exec("rm mm.bb mm.faces mm.points");
}
else 
{
// new code 
load "medit"
    meshS Th3= movemesh23(Th,transfo=[x,y,u*0.5]);
    medit("mm",Th3);// bug un color of u ... FH 
}

// FFCS: testing 3D plots
plot(u);
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
//  \url{from:   http://en.wikipedia.org/wiki/HSV_color_space} 
//The HSV (Hue, Saturation, Value) model, 
//   defines a color space in terms of three constituent components:
//
//HSV color space as a color wheel
//Hue, the color type (such as red, blue, or yellow):
//   Ranges from 0-360 (but normalized to 0-100% h ere)
// Saturation, the "vibrancy" of the color: Ranges     from 0-100%
//    The lower the saturation of a color, the more "grayness" is present 
//    and the more faded the color will appear.
// Value, the brightness of the color:
//   Ranges from 0-100%
// 
real[int] colorhsv=[  // color hsv model
  4./6., 1 , 0.5, // dark blue
  4./6., 1 , 1, //  blue
  5./6., 1 , 1, //  magenta
  1, 1. , 1, //  red
  1, 0.5 , 1 // light red 
   ];
mesh Th=square(5,5);
fespace Vh(Th,P2);
Vh uh=x*x+y*y,vh=-y^2+x^2;
assert(n+1 < nn);
//  compute a cut 
for (int i=0;i<=n;i++)
 {
   xx[i]=i;
   yy[i]=uh(real(i)/n,real(i)/n); // value of uh at point (i/10. , i/10.) 
 }
 
 plot(Th,uh,[uh,vh],value=true,ps="three.eps",wait=true); // plot mesh, isovalue, and vector
 //  zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]
 plot(uh,[uh,vh],bb=[[0.1,0.2],[0.5,0.6]],wait=true,grey=1,fill=1,value=1,ps="threeg.eps");  // in grey with filling
 plot([xx(0:n),yy(0:n)],[xx(0:n:5),yy(0:n:5)],ps="likegnu.eps",wait=true); //  like gnuplot plot a cut of uh

 real[int] viso(31);
 
 for (int i=0;i<viso.n;i++)
   viso[i]=i*0.1;
   
 plot(uh,viso=viso(0:viso.n-1),value=1,fill=1,wait=1,hsv=colorhsv,ps="threehsv.eps");

   
//  signe of pressure if correct 
assert(version>1.18); 
mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;


varf bx(u1,q) = int2d(Th)( (dx(u1)*q)); 

varf by(u1,q) = int2d(Th)( (dy(u1)*q));

varf a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(1,2,4,u1=0)  +  on(3,u1=1) ;

Xh bc1; bc1[] = a(0,Xh);
Xh b;
                   
matrix A= a(Xh,Xh,solver=CG); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);
Xh bcx=1,bcy=0;
Mh f=x;
Xh g=sin(x);
b[]  = Bx'*f[]; 
b[] += bc1[] .*bcx[];
u1[] = A^-1*b[];
// This test shows some powerful features of FreeFEM on a
// simple example: -\Delta(u) = 1 in the unit cercle with u=0 on the
// border of the unit cercle. This problem has an analytical solution
// u = (1-x^2-y^2)/4

// Mesh
real pi = 4*atan(1);
border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}

mesh disk = buildmesh(a(50));
plot(disk);

// Fespace
fespace femp1(disk, P1);
femp1 u, v;

// Problem
problem laplace(u, v)
	= int2d(disk)(	// bilinear form
		  dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	+ int2d(disk)(	// linear form
		- 1*v
	)
	+ on(1, u=0)	// boundary condition
	;

// Solve
laplace;

// Error
femp1 err = u - (1-x^2-y^2)/4;

// Plot
plot(u, value=true, wait=true);
plot(err, value=true, wait=true);

// Display (on terminal)
cout << "error L2 = " << sqrt(int2d(disk)( (u-(1-x^2-y^2)/4)^2 )) << endl;
cout << "error H10 = " << sqrt(int2d(disk)((dx(u)+x/2)^2)
							 + int2d(disk)((dy(u)+y/2)^2) )<< endl;

// Mesh adaptation
disk = adaptmesh(disk, u, err=0.01);
plot(disk, wait=1);

// Solve
laplace;

// Error
err =u-(1-x^2-y^2)/4;

// Plot
plot(u, value=true, wait=true);
plot(err, value=true, wait=true);

// Display
cout << "error L2 = " << sqrt(int2d(disk)( (u-(1-x^2-y^2)/4) ^2 )) << endl;
cout << "error H10 = " << sqrt(int2d(disk)((dx(u)+x/2)^2)
							 + int2d(disk)((dy(u)+y/2)^2)) << endl;
//  test of diff kind of freefem++ function
// work if version >= 3.3 

verbosity=500;

real[int] G=[7,8,9];

func mesh carre(int n) 
{ mesh th=square(n,n);
  return th;}
  
  
func real[int]   aaa(int n) 
{ real[int] a(n);
  a=0;
  a[2]=n;
  return a;}
  
  
 func real[int]   bb(real[int] &a) 
{ cout << " sum " <<a.sum <<endl;
  return a;}
 func real[int]   bbb(real[int] a) 
{ cout << " sum " <<a.sum <<endl;
  a[0]=100; // change the value of the parameter  
  return a;}

 func real[int]   GG(int i) 
{ G[1]=i;
  return G;}
 
 func real[int]   GGG(int i) 
{ G[1]=i;
  return G(1:2);} 

  
  
mesh Th=  carre(2);
carre(3); // the mesh is lose 
cout << Th.nt << endl;
cout << aaa(3) << endl;
  
real[int] A=[1,4,7];
cout << bb(A) << endl;
real[int] aa=bb(A);
real[int] ac=bbb(A); //  warning A[0] is set to 100.
cout << " xxxx "<< endl;
cout << aa << " == "  << A <<endl;
assert(A[0]==100);
cout << ac << " == " << A << endl;
cout << GG(3) << endl;
cout << GGG(5) << endl;

verbosity=1;

//  test Nan and inf  version 3.19 

real x=1e1000;
cout << x << " " << isInf(x) << " " << isNaN(x) << " " << isNormal(x) <<endl;
x =1;
cout << x << " " << isInf(x) << " " << isNaN(x) << " " << isNormal(x)<<endl;
x = NaN();
cout << x << " " << isInf(x) << " " << isNaN(x) << " " << isNormal(x)<<endl;
//  sparse matrix test  ---
// example of the new matrix feature in version 1.40
// -------------------------------------------------

// ALH - for regression test
real regtest;

for(int step=0; step <2; ++step)
  {
    mesh  TH = square(3,4);
    mesh  th = square(2,3);
    mesh  Th = square(4,4);

    complex ccc;
    ccc= 1;
    cout << ccc << endl;
    fespace VH(TH,P1);
    fespace Vh(th,P1);
    fespace Wh(Th,P1);

    matrix RB= interpolate(VH,Vh);  // build interpolation matrix Vh->Vh 
    matrix RBB= interpolate(Wh,Vh);  // build interpolation matrix
    matrix<complex> B=RB;
    B = B*(1+2i);
    B(0,4)=1i;
    matrix<complex> BB=RBB;

    varf vA(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+ int1d(Th)(u*v); 
    matrix<complex> A=vA(Wh,Wh);
    Vh<complex> ml=0;
    cout << " ml " << ml[] << endl;
    varf vML(u,v) = int2d(th)(1.*v);
    ml[]=vML(0,Vh); // build the P1 mass lump of P1
    cout << ml[] << endl;
    matrix<complex> ML(ml[]); // matrix diagonal
    cout << "ML="<<ML << endl;
    cout << "B="<<B << endl;
    matrix<complex> BML=B*ML; // a faire 
    matrix<complex> tB=B';        //'; transpose and conjugate 
	cout << " trace tB=" << tB.trace << " trace B  " << B.trace << endl;
    matrix<complex> MLtB=ML'*B'; // 
    assert( imag(tB.trace) * imag(B.trace) < 0) ;
	{
		
		 matrix<complex> BtB = B'*B, tBtB= BtB';
		 matrix<complex> ZZ =  BtB - tBtB;
		 cout << " BtB hermitain  "<< ZZ.linfty <<  endl; 
		 ZZ =  BtB - BtB';
		 cout << " BtB hermitain  "<< ZZ.linfty <<  endl; 
		 assert( ZZ.linfty < 1e-10);
	}
	
    cout << "BML="<<BML << endl;
    cout << "MLtB=" << MLtB << endl;

    // WARNING if sparsesolver is not install
    // the sparsesolver solver is replace by LU 
    //  but LU need skyline matrix 
    string typesolver="sparsesolver";
    if(!HaveUMFPACK) typesolver="GMRES"; 
    set(A,solver=typesolver); // set a solver 

    VH<complex> uH=0;
    Vh<complex> uh=x+y+1i*(x-y);
    uH[]= B*uh[];
    Vh uHr = imag(uH);
    plot(uHr,wait=1);
    matrix<complex> BtA = BB'*A;//';
	cout << BtA << endl; 
    matrix<complex> BtAB = BtA*BB;
    if(HaveUMFPACK)  
      set(BtAB,solver=sparsesolver);  
    else 
      set(BtAB,solver=GMRES);  
    Vh<complex> ff=1+1i;
    Vh<complex> xx;
    Vh xxr;
    cout << " ------ " << endl;

    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    xxr=imag(xx);
    plot(xxr, wait=1);

    // ALH - For regression test
    regtest=real(xx[]'*xx[]); //');
      
    {
      int N=10;
      complex [int,int] A(N,N);
      complex [int] a(N),b(N),bb(N);
      A =0;
      for (int i=0;i<N;i++)
	{
	  A(i,i)=1.+i;
	  if(i+1 < N)    A(i,i+1)=-i-1i*i;
	  a[i]=i*(1.+2i);
	}
      b=A*a;
  
      cout << " b =" << b << endl ;
      cout << " a =" << a << endl ;
      cout << " b'*b (hermissian product) = " << b'*b << endl; //';
      cout << " a'*a = " << a'*a << endl;//';;
      assert( abs(imag(b'*b)) <1e-5);//')));
      cout << "xxxx\n"; 
      matrix<complex> sparseA=A;
  
      cout << sparseA << endl;
      sparseA = 2*sparseA+sparseA;
      sparseA = 4*sparseA+sparseA*(5+1i); //  * 27
      matrix<complex> sparseB=sparseA;//+sparseA+sparseA; ;
      cout << sparseA << endl;
      cout << sparseB << endl; // *81 
      cout << "sparseB = " << sparseB(0,0) << endl;
      // ajoute version  2.0-2
      sparseA=A;
      verbosity=4;
      if(HaveUMFPACK)		
	set(sparseA,solver=sparsesolver,tolpivot=1e-10,tolpivotsym=1e-9);  
      else 
	set(sparseA,solver=GMRES);  
      bb=sparseA^-1*a;
      verbosity=1;
      b = sparseA*bb;
      b -= a;
      cout << " nb coef sparseA " << sparseA.nbcoef << endl; 
      cout << " ||b.||_1  " << b.l1 << endl;
      cout << " ||b.||_2  " << b.l2 << endl;
      cout << " ||b.||_infty  " << b.linfty << endl;
      assert(b.l1 < 1e-10);
    }
    {// version 3.8    
      mesh Th=square(2,2);
      fespace Xh(Th,P1);
      varf vv(u,v)= int2d(Th)( ((2+1i)*u*v)')+int2d(Th)((3+2i)*v);//');
      varf vr(u,v)= int2d(Th)( u*v);//');

      matrix<complex> A=vv(Xh,Xh);
      matrix  Ar=vr(Xh,Xh);
      complex[int] vc=vv(0,Xh);
      real[int] vrr=vc.re,vii=vc.im;
      vrr=vc.re;
      vii=vc.im;
  // bugus ::s
 // vrr=real(vc);
 // vii=imag(vc);
  cout << "vc[0] = " <<vc[0] 
    << " = " << vc.re[0]  << " +i " << vc.im[0] 
    << " :: = " << vrr[0]  << " +i " << vii[0] 
    
    <<endl;
  
      cout << [ 1i, 1i]'*[ 1i, 1i] <<endl;//'; 
      // real part un complex par of matrix . 
      Ar = A.re;
      cout <<" A(0,0) = " << A(0,0)  << "   ";
      cout << " A.re(0.0) = " << Ar(0,0) << "   " ;
      Ar = A.im; 
      cout << " A.im(0.0) = " << Ar(0,0) << endl  ;

  
      macro Grada(u) [  phia*dx(u) + phiax*u ,dy(u) ]// ...
	func phia = exp(-2i*pi*x);
      func phiax = -2i*pi*exp(-2i*pi*x);

      varf va(u,v)= int2d(Th)( Grada(v)'*Grada(u) ) ;//');
      A = va(Xh,Xh);
      matrix<complex> At=A';//';
      cout << A(1,2)' << " ==  " << At(2,1) << endl;//';
      A = A+ (-1)*At;
      cout << A << endl;
      // copy and initialisation of complex matric with real matrix. 
      A = Ar; 
      matrix<complex> Ac=Ar; 
    }
  }
{  // version 3.46
  mesh Th=square(2,2);
  fespace Xh(Th,P1);
  varf vr(u,v)= int2d(Th)( u*v);//');
  matrix A=vr(Xh,Xh); 
  Xh<complex> u=(1+2i)*x*y;
  Xh ur=x*y;
  complex[int]  Au=A*u[];
  real[int]  Aur=A*ur[];
  Au.re -= Aur;
  Au.im -= 2.*Aur;
  cout << Au.linfty << endl; 
  assert(Au.linfty < 1e-10); 
}
// This a the rotating hill problem with one turn.
// First 1/2 turn is a convection equation and second 1/2 a convection diffusion

border a(t=0, 2*pi)     {    x = cos(t);    y = sin(t);  }; // the unit circle
mesh th2 = buildmesh(a(35));                                 // triangulates the disk
mesh th= trunc(th2,1,split=2);
fespace Vh(th,P1);
fespace Vh2(th2,P2);
Vh2 v = exp(-10*((x-0.3)^2 +(y-0.3)^2));                  // initial condition
plot(v);

real dt = 0.17,t=0;                                                 // time step
Vh u1 = y, u2 = -x;                                        // rotation velocity
int i;
Vh2 vv,vo; // work  Finite element function 
for ( i=0; i< 20 ; i++) {
    t += dt;
    vo=v;
    v=convect([u1,u2],-dt,vo);                          // convect v by u1,u2, dt seconds, results in f
 // convec(u1,u2,dt,v,v) won't work
    plot(v,cmm="convection: t="+t + ", min=" + v[].min + ", max=" +  v[].max,wait=0);
};

problem  A(v,vv,solver=CG) = int2d(th2)(v*vv/dt + 0.01*(dx(v)*dx(vv)+dy(v)*dy(vv)) )
  + int2d(th2)(-vv*convect([u1,u2],-dt,vo)/dt)  + on(a,v=0);
  
for ( i=0; i< 20 ; i++) 
{ 
    t += dt;
  vo=v;
  A; // solve le problem A
  plot(v,cmm="convection& diffusive: t="+t + ", min=" + v[].min + ", max=" +  v[].max);
};  

plot(v,wait=1);
// FFCS: making a numerical value visible for regression tests
real regtest;

{ // ---  a real non linear test ---
mesh Th=square(10,10);  // mesh definition of $\Omega$
Th = adaptmesh(Th,0.05,IsMetric=1,splitpbedge=1);

//plot(Th,wait=1);
//Th = adaptmesh(Th,0.1,IsMetric=1,splitpbedge=1);
plot(Th,wait=0);
fespace Vh(Th,P1);      // finite element space
fespace Ph(Th,P1dc);      // make optimization 

Vh b=1;  // to defined b 
// $ J(u) = 1/2 \int_\Omega f(|\nabla u|^2) - \int\Omega  u b $
// $ f(x) = a*x + x-ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) =  \frac{1}{(1+x)^2}$
real a=0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u);}
func real ddf(real u) { return 1/((1+u)*(1+u));}

Vh u=0; //  the current value of the solution
Ph alpha; // to store  $ (|\nabla u|^2)$
Ph dfalpha; // to store  $f' (|\nabla u|^2)$
Ph ddfalpha ; //to store = $2 f''( |\nabla u|^2) $  optimisation

int iter=0;


//   methode of  Newton Ralphson to solve dJ(u)=0;
//    $$ u^{n+1} = u^n - (\frac{\partial dJ}{\partial u_i})^{-1}*dJ(u^n) $$ 
//   ---------------------------------------------
  // the variationnal form of evaluate  dJ 
  // --------------------------------------
  //  dJ =  f'()*( dx(u)*dx(vh) + dy(u)*dy(vh) 
  varf vdJ(uh,vh) =  int2d(Th)( dfalpha*( dx(u)*dx(vh) + dy(u)*dy(vh) ) - b*vh)
  + on(1,2,3,4, uh=0);
  // the variationnal form of evaluate  ddJ   
  // hJ(uh,vh) =  f'()*( dx(uh)*dx(vh) + dy(uh)*dy(vh)
  //            + f''()( dx(u)*dx(uh) + dy(u)*dy(uh) ) * (dx(u)*dx(vh) + dy(u)*dy(vh)) 
  varf vhJ(uh,vh) = int2d(Th)( dfalpha*( dx(uh)*dx(vh) + dy(uh)*dy(vh) )
   +  ddfalpha*( dx(u)*dx(vh) + dy(u)*dy(vh)  )*( dx(u)*dx(uh) + dy(u)*dy(uh) ) )
   + on(1,2,3,4, uh=0);
   
 // the newton algorithm  
  Vh v,w; 
  u=0;
  for (int i=0;i<100;i++)
   {
    alpha = dx(u)*dx(u) + dy(u)*dy(u);// optimization
    dfalpha = df( alpha ) ; // optimization
    ddfalpha = 2*ddf(alpha ) ; // optimization
    v[]= vdJ(0,Vh);
    real res= v[]'*v[]; //'
    cout << i <<  " residu^2 = " <<  res  << endl;
    matrix H;
    if( res< 1e-12) break;
    H= vhJ(Vh,Vh,factorize=3,solver=LU);
    w[]=H^-1*v[];
    u[] -= w[];
    plot (u,wait=0,cmm="solution with Newton Raphson");

    // FFCS: regression tests
    regtest=u[]'*u[]; //'
   }

load "medit"
    meshS Th3= movemesh23(Th,transfo=[x,y,u*1.5]);
    medit("N",Th3);
}
/*
  Incompressible Navier Stokes 
    with Taylor-Hood Finite element
    No linearity : Newton method 
    continuation on Reynols Number
    Mesh adaptation 
    
    Test case Laminar Flow over a Backward Facing Step  Gamm Workshop
    
     K.Morgan, J.Périaux and F.Thomasset, Analysis of laminar flow over a backward facing step, Vol9 of Notes on Num. Fluid Mech., Vieweg, 1984. 
    
*/

// FFCS regression test value
real regtest;

real[int] Reynold=[50,150,300,400,500];
real[int] HH=[1.5,1]; 
real[int,int] reattachP=[ [ 2.8, 2 ], [ 5.16, 3.7 ]] ;  // reattachP[irey,cas]  
int nerr=0; 
bool adapt=1; // do adap or not 
bool dplot=0; // debug plot 
for(int cas=0;cas<2;++cas)
{
real h=HH[cas]-0.5,H=HH[cas],l=3,L=22;
int[int] ll=[3,2,5,1];
// label 1 in
//       2  out 
//       3  down wall
//       4   step 
//       5   up wall 
func zoom=[[2.5,0],[10,H]];
mesh Th=square(22,6,[x*22,y*H],label=ll);
Th=trunc(Th, (x>l) | (y >0.5),label=4); 
func meshsize= 2*max(0.05,max(max(x-l,0.0)/19./5.,max(l-x,0.0)/3./8. ));
func uin=(H-y)*(y-0.5)/square((H-0.5)/2.);
Th=adaptmesh(Th,meshsize,IsMetric=1);
Th=adaptmesh(Th,meshsize,IsMetric=1);
plot(Th,wait=0);
fespace Xh(Th,P2);
fespace Mh(Th,P1);
fespace XXMh(Th,[P2,P2,P1]);
XXMh [u1,u2,p];
XXMh [v1,v2,q]; 

macro div(u1,u2) (dx(u1)+dy(u2))//
macro grad(u1,u2) [dx(u1),dy(u2)]//
macro ugrad(u1,u2,v) (u1*dx(v)+u2*dy(v)) //
macro Ugrad(u1,u2,v1,v2) [ugrad(u1,u2,v1),ugrad(u1,u2,v2)]//

solve Stokes ([u1,u2,p],[v1,v2,q],solver=sparsesolver) =
    int2d(Th)( ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*div(v1,v2)-q*div(u1,u2)
           )
  + on(1,u1=uin,u2=0) 
  + on(3,4,5,u1=0,u2=0);

 Xh uu1=u1,uu2=u2;  
plot(coef=0.2,cmm="Stokes [u1,u2] et p  ",p,[uu1,uu2],wait=0);
plot(coef=0.2,cmm="Stokes  p  ",p,wait=0);
Mh psi,phi;


solve streamlines(psi,phi) = 
      int2d(Th)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
   +  int2d(Th)( -phi*(dy(u1)-dx(u2)))
   +  on(3,4,psi=0)+ on(5,psi=-2./3.*(H-0.5))
   ;
real[int] psiviso(31);
{int k=0;
for(int i=-20;i<0;i++)
 psiviso[k++] = i*2./3.*(H-0.5)/20;
for(int i=0;i<=10;i++)
 psiviso[k++] = i*2./3.*(H-0.5)/100/(H*H*H);
}

plot(psi,wait=0,viso=psiviso);
int i=0;
real  nu=1./100.;
real dt=0.1;
real alpha=1/dt;





XXMh [up1,up2,pp];
varf   vDNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
            
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
            + Ugrad(u1,u2,up1,up2)'*[v1,v2]
            + Ugrad(up1,up2,u1,u2)'*[v1,v2]
           )
  + on(1,3,4,5,u1=0,u2=0) 
;


varf   vNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
          
            + nu * ( dx(up1)*dx(v1) + dy(up1)*dy(v1)
            +  dx(up2)*dx(v2) + dy(up2)*dy(v2) )
            + pp*q*(0.000001) 
            + pp*dx(v1)+ pp*dy(v2)
            + dx(up1)*q+ dy(up2)*q
            + Ugrad(up1,up2,up1,up2)'*[v1,v2]//'
	      )
  + on(1,3,4,5,u1=0,u2=0) 
  ;

for(int krey=0;krey<Reynold.n;++krey)
  { 
    real re=Reynold[krey];
    real lerr=0.01;
    
    for(int step=0;step<(adapt?2:1) ;step++)
      {
     if(adapt)
     {
	  Th=adaptmesh(Th,[u1,u2],p,abserror=1,cutoff=1e-5,err=lerr,nbvx=100000,hmin=0.01);
	  if(dplot) plot(Th,wait=0,bb=zoom);
     }
	[u1,u2,p]=[u1,u2,p];
	[up1,up2,pp]=[up1,up2,pp];
	
	for (i=0;i<=20;i++)
	  {
	    nu = (H-h)/re;
	    up1[]=u1[];
	    real[int] b = vNS(0,XXMh);
	    matrix Ans=vDNS(XXMh,XXMh);
	    set(Ans,solver=sparsesolver);
	    real[int] w = Ans^-1*b;
	    u1[] -= w;
	    cout << " iter = "<< i << "  " << w.l2 <<  " rey = " << re << endl;
	    if(w.l2<1e-6) break; 
	    // uu1=u1;uu2=u2;
	    if(dplot) plot(coef=0.2,cmm="H="+H+" re "+re+ " [u1,u2] et p  ",p,[uu1,uu2],bb=zoom);  
	    
	  } ;
      }
    uu1=u1;uu2=u2;
    streamlines;
    real rp1=1./(H-h)*int1d(Th,3)( real( (x>=l & x < (l+0.5)) | (x>(l+0.4)) & (x<10)& (dy(psi) >= 1e-5)) ) ;
    real rp2=1./(H-h)*int1d(Th,3)( real( (x>=l & x < (l+0.5)) | (x>(l+0.4)) & (x<10)& (dy(psi) >= -1e-5)) ) ;
    real rp3=1./(H-h)*int1d(Th,3)( real( (x>=l & x < (l+0.5)) | (x>(l+0.4)) & (x<10)& (dy(u1)<=0)       ) ) ;
    cout << " Reattach point " << rp2 << " " << rp2 << " " << rp3 << endl;
    real rp = (rp1+rp2)/2;
    real rppaper =  krey < 2 ? reattachP(krey,cas) : rp; 
    real err= abs(rppaper - rp)/rp;
    if( err>0.5 ) nerr++;//  
    cout << "\n\n\n";
    cout << "H= " << H << " Re " << re << " Reattach point " << rp << " paper=" << rppaper << " err "<< err 
         << "  psi max = " << psi[].max <<endl; 
    cout << "\n\n\n";
    plot(coef=0.2,cmm="H="+H+", rey="+re+" [u1,u2] et p  ",p,[uu1,uu2],wait=0,nbiso=20,bb=zoom);//,ps="Upstep-"+H+"-"+re
    plot(coef=0.2,cmm="H="+H+", rey="+re+" [u1,u2] et p  ",p,[uu1,uu2],wait=0,nbiso=20,bb=zoom);//,ps="Upstep-"+H+"-"+re+".ps");  
    plot(coef=0.2,cmm="H="+H+", rey="+re+" [u1,u2] et p  ",psi,bb=zoom,viso=psiviso);//,ps="psi-step-"+H+"-"+re+".ps");  

    // FFCS regression test value
    regtest=uu1[]'*uu1[];//'
     }
}
assert(nerr==0); 
/*
  Example to cumpute min max of min size of edge on each triangle.
*/
mesh Th=square(10,10,[x,y*(1+x)]);
fespace Ph(Th,P0);
fespace Eh(Th,P0edge);
Ph hmin = hTriangle;

varf vle(u,v)=intalledges(Th)(v*1./nTonEdge);

real[int] lenedges = vle(0,Eh);
cout << " min / max len edges " << lenedges.min << " "  << lenedges.max <<endl; 

for(int k=0; k< Th.nt; ++k)
for(int i=0; i<3; ++i)
{
	hmin[][k]= min(hmin[][k],lenedges[Eh(k,i)]);
}
plot(hmin,fill=1,value=1);
real hminmin = 0.1, hminmax= 0.141421;
cout << " hmin = " << hmin[].min << " max = " << hmin[].max << endl;
assert(abs(hmin[].min-hminmin) < 0.0001); 
assert(abs(hmin[].max-hminmax) < 0.0001); 
//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
//  on intalledges :
// the edge are see nTonEdge times so we / nTonEdge
// remark: nTonEdge =1 on border edge and =2 on internal 
// we are in a triangle normal is the exterior normal
// def: jump = external - internal value,     on border extern  - internal value
//      mean = (external + internal value)/2, on border just mean internal value

macro dn(u) (N.x*dx(u)+N.y*dy(u) ) //  def the normal derivative 

mesh Th = square(10,10); // unite square 
fespace Vh(Th,P2dc);     // Discontinous P2 finite element
fespace Xh(Th,P2);
//  if pena = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=100; // a paramater to add penalisation 

func f=x+2*y;
func g=x-y;
Vh u,v;
Xh uu,vv;
solve A(u,v,solver=sparsesolver) = 
   int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)  )
 + intalledges(Th)(//  loop on all  edge of all triangle 
          ( jump(v)*mean(dn(u)) -  jump(u)*mean(dn(v)) 
          + pena*jump(u)*jump(v) ) / nTonEdge 
          ) 
- int2d(Th)(f*v) 
- int1d(Th)(g*dn(v)  + pena*g*v) 
;

solve A1(uu,vv,solver=CG) 
= 
 int2d(Th)(dx(uu)*dx(vv)+dy(uu)*dy(vv)) - int2d(Th)(f*vv) + on(1,2,3,4,uu=g);
 

plot(u,uu,cmm="Continuous and Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
Vh eh= u-uu;
real err =eh[].linfty/u[].linfty; 
cout << " ||err|| relative: " << err << " " <<uu[].linfty  <<  endl;

assert( err < 1e-2);

//  bug string macro parameter   version < 1.41
// bug in string parameter version before <2.5
// -----------------

 macro tyty(uu) uu//  
cout << tyty("toto") << endl;

func string   write(string  fn,real[int] & u)
{
  cout <<"write :   " <<  fn << " u = "<<  u << endl;  //  delete 2 times before version 2.5 
  return fn; 
}

func string   write1(string  fn,real[int] & u)
{
  cout << "write 1 " << fn << " u = " << u << endl;   
  string toto=fn; ;
  return toto+"dfsdf"; 
}

real[int] u(3);
u=1;

string tt=tyty("toto1"+1+" -- 77");

string t1="0123456789";// write(tt,u);

string t2;


  {
    t2=  write1(t1,u)+write1(tt,u); // 
    // because the local variable of write1 are  delete 2 times at the  ;
    cout << " t2 = " << t2 << endl;
  }
if(0)
   { // the correct way
     t2=  write1(t1,u);
     t2=t2 + write1(tt,u); 
    cout << " t2 = " << t2 << endl;
   }
// new operator
t2 ="12340005678";
t2(4:3) = "abcdefghijk-"; 
string t55=t2(4:3);
//t2 = "12340abcdefghijk-005678";
cout << t2 << endl;
cout << "  find abc " << t2.find("abc") << endl;
cout << "r find abc " << t2.rfind("abc") << endl;
cout << " find abc from 10  " << t2.find("abc",10) << endl;
cout << " ffind abc from 10 " <<t2.rfind("abc",10) << endl;
cout << "   " << string("abcc").length << endl; 
cout << " t55 " << t55 << endl;
{  // add getline version 3.0-6 jan 2009 FH
string s;
ifstream toto("xyf");
for (int i=0;i<10;++i)
  {
   getline(toto,s);
   cout << i << " : " << s << endl;
  }
}
// add  3.29 + Stringification, LINE, FILE, ltime ..

macro aa()  "tyty"  //
cout << aa << endl; 

// <<Stringification>> reference example

cout << "in " << FILE << " line " << LINE << "    -- '" << Stringification( "zzz" aa  () {} +  /* */  bb cc) << "'" << endl;

cout << " unix time = " << time() << " " << ltime() << endl;

 
//  compute the solution of a Laplace operator in a Semi infini domain.
//  with coupling of Boundary element with periodicity BC in x . 
// -------------------------------------------------------------
include "ExtractDofsonBorder.idp"
real eps0=1;
int labup=3, labdown=1;
int nharm= 10; // Number of  Harmonique

func ug= max(0.,-(x-0.5)*(x-0.75)); // boundary condition.. 

macro Grad(u) [dx(u),dy(u)] // eom


real Xmax=1,Ymax=0.3;
int NNx=100,NNy=NNx*Ymax;
mesh Th=square(NNx,NNy,[x*Xmax,y*Ymax]); 
fespace Vh(Th,P1,periodic=[[2,y],[4,y]]);

Vh uref; // la solution de reference. 

{ // calcule de la solution de reference in  Huge Domaine.
mesh Th1=square(NNx,NNx*10,[x*Xmax,10*Xmax*y]); // pour la solution de reference 
fespace Uh(Th1,P1,periodic=[[2,y],[4,y]]);
Uh uu,vv;
solve Pref(uu,vv)=int2d(Th1)(eps0*(Grad(uu)'*Grad(vv)))+on(labdown,uu=ug);
 uref=uu; 
 plot(uu,wait=1,cmm=" ref sol / large Th ");
} // pour nettoyer la memoire

plot(uref,wait=1,cmm=" ref sol / Th");


varf vP(u,v)=int2d(Th)(eps0*(Grad(u)'*Grad(v)))+on(labdown,u=ug);
varf vF(u,v)=on(labdown,u=ug);
matrix<complex> A=vP(Vh,Vh);  // la matrice sans BEM. 

complex[int] b=vF(0,Vh);
Vh<complex> u;

{// for cleanning all local varaible at end of block.
 // computation of the matrice BEM
  // nb of  DoF on border 
 int[int] IdfB2Vh(1); // for numbering IdfB2Vh[i]==i 
 ExtractDofsonBorder(labup,Vh,IdfB2Vh,-1)
 int kdfBEM=IdfB2Vh.n;
 // verif
 if(0)  { Vh X=x;
     real[int] xx(IdfB2Vh.n);
     xx=X[](IdfB2Vh);
     cout << IdfB2Vh << endl; 
     cout << xx << endl; 
   }
//  end of the numbering computation
 // so  IdfB2Vh[ibem] = iVh where ibem is a df of on bem , and iVh is a df in Vh space. 
   real perio=Xmax;
   complex  deuxpii=2*pi*1i;
   int n=0;// 
   // Use of higher order Quadarture formular ...
   varf vWn(u,w)=int1d(Th,labup,qforder=10)(exp(-deuxpii*(n)*x)*w);
      
   //complex[int] wn=vWn(0,Vh);//  with Vh numbering.. 

   complex[int,int] ABemFull(kdfBEM,kdfBEM);// the full bem matrix in Bem numbering.
   ABemFull=0;//  set of 0 
   for ( n=-nharm;n<=nharm;++n)
    {
    	complex[int] wwn(kdfBEM);
    	complex[int] wn=vWn(0,Vh);
    	wwn=wn(IdfB2Vh);//  wwn(i) = wn(IdfB2Vh(i))  i=0 a wwn.n -1 
        complex Gs=+2.*pi*abs(n/perio/perio)*eps0;
    	ABemFull += Gs*wwn*wwn';
    }
    
 
  matrix<complex> ABem=ABemFull(IdfB2Vh^-1,IdfB2Vh^-1); // Build the sparse BEm matrix
   //  ABem(IdfB2Vh(ib),IdfB2Vh(jb)) = ABemFull(ib,jb) 
  A = A + ABem;
  }// for cleanning all local varaible at end of block. ABem ABemFull
  set(A,solver=sparsesolver);
  u[]=A^-1*b;
  Vh ur=real(u),ui=imag(u);
  Vh  err=ur-uref;
  cout << " err Linty=" << err[].linfty << " /  " <<  uref[].linfty << endl; 

  plot(ur,uref,wait=1,cmm="ur + uref ");

    
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


cout << "--------- file : adapt.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "adapt.edp";
	real TESTadapt=u[].max-u[].min;
		cout<<"adapt reference value = "<<REFadapt
				<<" test value ="<<TESTadapt<<endl;
			assert(TESTadapt<REFadapt*(1+0.01));
				assert(TESTadapt>REFadapt*(1-0.01));
};

cout << "--------- file : adaptindicatorP1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "adaptindicatorP1.edp";
	real TESTadaptindicatorP1=u[].max-u[].min;
		cout<<"adaptindicatorP1 reference value = "<<REFadaptindicatorP1
				<<" test value ="<<TESTadaptindicatorP1<<endl;
			assert(TESTadaptindicatorP1<REFadaptindicatorP1*(1+0.01));
				assert(TESTadaptindicatorP1>REFadaptindicatorP1*(1-0.01));
};

cout << "--------- file : adaptindicatorP2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "adaptindicatorP2.edp";
	real TESTadaptindicatorP2=u[].max-u[].min;
		cout<<"adaptindicatorP2 reference value = "<<REFadaptindicatorP2
				<<" test value ="<<TESTadaptindicatorP2<<endl;
			assert(TESTadaptindicatorP2<REFadaptindicatorP2*(1+0.01));
				assert(TESTadaptindicatorP2>REFadaptindicatorP2*(1-0.01));
};

cout << "--------- file : algo.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "algo.edp";
	real TESTalgo=umax;
		cout<<"algo reference value = "<<REFalgo
				<<" test value ="<<TESTalgo<<endl;
			assert(TESTalgo<REFalgo*(1+0.01));
				assert(TESTalgo>REFalgo*(1-0.01));
};

cout << "--------- file : array.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "array.edp";
	
};

cout << "--------- file : a_tutorial.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "a_tutorial.edp";
	real TESTaXtutorial=1+max(err[].max,-err[].min);
		cout<<"a_tutorial reference value = "<<REFaXtutorial
				<<" test value ="<<TESTaXtutorial<<endl;
			assert(TESTaXtutorial<REFaXtutorial*(1+0.001));
				assert(TESTaXtutorial>REFaXtutorial*(1-0.001));
};

cout << "--------- file : beam.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "beam.edp";
	real TESTbeam=uu[]'*uu[];
		cout<<"beam reference value = "<<REFbeam
				<<" test value ="<<TESTbeam<<endl;
			assert(TESTbeam<REFbeam*(1+5e-2));
				assert(TESTbeam>REFbeam*(1-5e-2));
};

cout << "--------- file : calculus.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "calculus.edp";
	
};

cout << "--------- file : cavity.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "cavity.edp";
	real TESTcavity=psi[]'*psi[];
		cout<<"cavity reference value = "<<REFcavity
				<<" test value ="<<TESTcavity<<endl;
			assert(TESTcavity<REFcavity*(1+1e-2));
				assert(TESTcavity>REFcavity*(1-1e-2));
};

cout << "--------- file : convect2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "convect2.edp";
	real TESTconvect2=v[]'*v[];
		cout<<"convect2 reference value = "<<REFconvect2
				<<" test value ="<<TESTconvect2<<endl;
			assert(TESTconvect2<REFconvect2*(1+1e-1));
				assert(TESTconvect2>REFconvect2*(1-1e-1));
};

cout << "--------- file : convect-apt.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "convect-apt.edp";
	real TESTconvectXapt=error;
		cout<<"convect-apt reference value = "<<REFconvectXapt
				<<" test value ="<<TESTconvectXapt<<endl;
			assert(TESTconvectXapt<REFconvectXapt*(1+5e-1));
				assert(TESTconvectXapt>REFconvectXapt*(1-5e-1));
};

cout << "--------- file : convect.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "convect.edp";
	real TESTconvect=v[]'*v[];
		cout<<"convect reference value = "<<REFconvect
				<<" test value ="<<TESTconvect<<endl;
			assert(TESTconvect<REFconvect*(1+1e-1));
				assert(TESTconvect>REFconvect*(1-1e-1));
};

cout << "--------- file : dumptable.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "dumptable.edp";
	
};

cout << "--------- file : ex-vf.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "ex-vf.edp";
	
};

cout << "--------- file : FE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "FE.edp";
	real TESTFE=wdc[]'*wdc[];
		cout<<"FE reference value = "<<REFFE
				<<" test value ="<<TESTFE<<endl;
			assert(TESTFE<REFFE*(1+1e-2));
				assert(TESTFE>REFFE*(1-1e-2));
};

cout << "--------- file : fluidStructAdapt.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "fluidStructAdapt.edp";
	real TESTfluidStructAdapt=uu[]'*uu[];
		cout<<"fluidStructAdapt reference value = "<<REFfluidStructAdapt
				<<" test value ="<<TESTfluidStructAdapt<<endl;
			assert(TESTfluidStructAdapt<REFfluidStructAdapt*(1+2e-1));
				assert(TESTfluidStructAdapt>REFfluidStructAdapt*(1-2e-1));
};

cout << "--------- file : fluidStruct.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "fluidStruct.edp";
	real TESTfluidStruct=uu[]'*uu[];
		cout<<"fluidStruct reference value = "<<REFfluidStruct
				<<" test value ="<<TESTfluidStruct<<endl;
			assert(TESTfluidStruct<REFfluidStruct*(1+2e-1));
				assert(TESTfluidStruct>REFfluidStruct*(1-2e-1));
};




cout << "--------- file : LapDG2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LapDG2.edp";
	real TESTLapDG2=u[]'*u[];
		cout<<"LapDG2 reference value = "<<REFLapDG2
				<<" test value ="<<TESTLapDG2<<endl;
			assert(TESTLapDG2<REFLapDG2*(1+1e-2));
				assert(TESTLapDG2>REFLapDG2*(1-1e-2));
};

cout << "--------- file : Laplace.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "Laplace.edp";
	real TESTLaplace=uh[]'*uh[];
		cout<<"Laplace reference value = "<<REFLaplace
				<<" test value ="<<TESTLaplace<<endl;
			assert(TESTLaplace<REFLaplace*(1+1e-2));
				assert(TESTLaplace>REFLaplace*(1-1e-2));
};

cout << "--------- file : LaplaceP1bis.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP1bis.edp";
	real TESTLaplaceP1bis=u[]'*u[];
		cout<<"LaplaceP1bis reference value = "<<REFLaplaceP1bis
				<<" test value ="<<TESTLaplaceP1bis<<endl;
			assert(TESTLaplaceP1bis<REFLaplaceP1bis*(1+1e-2));
				assert(TESTLaplaceP1bis>REFLaplaceP1bis*(1-1e-2));
};

cout << "--------- file : LaplaceP1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP1.edp";
	real TESTLaplaceP1=uh[]'*uh[];
		cout<<"LaplaceP1 reference value = "<<REFLaplaceP1
				<<" test value ="<<TESTLaplaceP1<<endl;
			assert(TESTLaplaceP1<REFLaplaceP1*(1+1e-2));
				assert(TESTLaplaceP1>REFLaplaceP1*(1-1e-2));
};

cout << "--------- file : LaplaceP1P2h.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP1P2h.edp";
	real TESTLaplaceP1P2h=u2h[]'*u2h[];
		cout<<"LaplaceP1P2h reference value = "<<REFLaplaceP1P2h
				<<" test value ="<<TESTLaplaceP1P2h<<endl;
			assert(TESTLaplaceP1P2h<REFLaplaceP1P2h*(1+1e-2));
				assert(TESTLaplaceP1P2h>REFLaplaceP1P2h*(1-1e-2));
};

cout << "--------- file : LaplaceRT.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceRT.edp";
	real TESTLaplaceRT=u1[]'*u1[];
		cout<<"LaplaceRT reference value = "<<REFLaplaceRT
				<<" test value ="<<TESTLaplaceRT<<endl;
			assert(TESTLaplaceRT<REFLaplaceRT*(1+1e-2));
				assert(TESTLaplaceRT>REFLaplaceRT*(1-1e-2));
};

cout << "--------- file : mesh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "mesh.edp";
	
};

cout << "--------- file : movemesh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "movemesh.edp";
	real TESTmovemesh=u[]'*u[];
		cout<<"movemesh reference value = "<<REFmovemesh
				<<" test value ="<<TESTmovemesh<<endl;
			assert(TESTmovemesh<REFmovemesh*(1+1e-2));
				assert(TESTmovemesh>REFmovemesh*(1-1e-2));
};

cout << "--------- file : nolinear-elas.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "nolinear-elas.edp";
	real TESTnolinearXelas=(1+errb);
		cout<<"nolinear-elas reference value = "<<REFnolinearXelas
				<<" test value ="<<TESTnolinearXelas<<endl;
			assert(TESTnolinearXelas<REFnolinearXelas*(1+1e-3));
				assert(TESTnolinearXelas>REFnolinearXelas*(1-1e-3));
};

cout << "--------- file : NSUzawaCahouetChabart.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSUzawaCahouetChabart.edp";
	real TESTNSUzawaCahouetChabart=u1[].linfty;
		cout<<"NSUzawaCahouetChabart reference value = "<<REFNSUzawaCahouetChabart
				<<" test value ="<<TESTNSUzawaCahouetChabart<<endl;
			assert(TESTNSUzawaCahouetChabart<REFNSUzawaCahouetChabart*(1+1e-2));
				assert(TESTNSUzawaCahouetChabart>REFNSUzawaCahouetChabart*(1-1e-2));
};

cout << "--------- file : onde.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "onde.edp";
	real TESTonde=u[]'*u[];
		cout<<"onde reference value = "<<REFonde
				<<" test value ="<<TESTonde<<endl;
			assert(TESTonde<REFonde*(1+1e-2));
				assert(TESTonde>REFonde*(1-1e-2));
};



cout << "--------- file : plot.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot.edp";
	real TESTplot=uh[]'*uh[];
		cout<<"plot reference value = "<<REFplot
				<<" test value ="<<TESTplot<<endl;
			assert(TESTplot<REFplot*(1+1e-2));
				assert(TESTplot>REFplot*(1-1e-2));
};

cout << "--------- file : readmesh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "readmesh.edp";
	real TESTreadmesh=u[]'*u[];
		cout<<"readmesh reference value = "<<REFreadmesh
				<<" test value ="<<TESTreadmesh<<endl;
			assert(TESTreadmesh<REFreadmesh*(1+2e-1));
				assert(TESTreadmesh>REFreadmesh*(1-2e-1));
};

cout << "--------- file : region.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "region.edp";
	real TESTregion=u[]'*u[];
		cout<<"region reference value = "<<REFregion
				<<" test value ="<<TESTregion<<endl;
			assert(TESTregion<REFregion*(1+1e-1));
				assert(TESTregion>REFregion*(1-1e-1));
};

cout << "--------- file : saverestore.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "saverestore.edp";
	
};

cout << "--------- file : schwarz-gc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "schwarz-gc.edp";
	real TESTschwarzXgc=u1[]'*u1[];
		cout<<"schwarz-gc reference value = "<<REFschwarzXgc
				<<" test value ="<<TESTschwarzXgc<<endl;
			assert(TESTschwarzXgc<REFschwarzXgc*(1+5e-2));
				assert(TESTschwarzXgc>REFschwarzXgc*(1-5e-2));
};

cout << "--------- file : schwarz-no-overlap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "schwarz-no-overlap.edp";
	real TESTschwarzXnoXoverlap=u[]'*u[];
		cout<<"schwarz-no-overlap reference value = "<<REFschwarzXnoXoverlap
				<<" test value ="<<TESTschwarzXnoXoverlap<<endl;
			assert(TESTschwarzXnoXoverlap<REFschwarzXnoXoverlap*(1+5e-2));
				assert(TESTschwarzXnoXoverlap>REFschwarzXnoXoverlap*(1-5e-2));
};

cout << "--------- file : schwarz-overlap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "schwarz-overlap.edp";
	real TESTschwarzXoverlap=u[]'*u[];
		cout<<"schwarz-overlap reference value = "<<REFschwarzXoverlap
				<<" test value ="<<TESTschwarzXoverlap<<endl;
			assert(TESTschwarzXoverlap<REFschwarzXoverlap*(1+5e-2));
				assert(TESTschwarzXoverlap>REFschwarzXoverlap*(1-5e-2));
};

cout << "--------- file : sparse-matrix.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "sparse-matrix.edp";
	real TESTsparseXmatrix=regtest;
		cout<<"sparse-matrix reference value = "<<REFsparseXmatrix
				<<" test value ="<<TESTsparseXmatrix<<endl;
			assert(TESTsparseXmatrix<REFsparseXmatrix*(1+5e-2));
				assert(TESTsparseXmatrix>REFsparseXmatrix*(1-5e-2));
};

cout << "--------- file : sparse-cmatrix.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "sparse-cmatrix.edp";
	real TESTsparseXcmatrix=real(regtest);
		cout<<"sparse-cmatrix reference value = "<<REFsparseXcmatrix
				<<" test value ="<<TESTsparseXcmatrix<<endl;
			assert(TESTsparseXcmatrix<REFsparseXcmatrix*(1+5e-2));
				assert(TESTsparseXcmatrix>REFsparseXcmatrix*(1-5e-2));
};

cout << "--------- file : StokesUzawa.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "StokesUzawa.edp";
	real TESTStokesUzawa=u1[]'*u1[];
		cout<<"StokesUzawa reference value = "<<REFStokesUzawa
				<<" test value ="<<TESTStokesUzawa<<endl;
			assert(TESTStokesUzawa<REFStokesUzawa*(1+5e-2));
				assert(TESTStokesUzawa>REFStokesUzawa*(1-5e-2));
};

cout << "--------- file : tablefunction.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "tablefunction.edp";
	real TESTtablefunction=fxy[]'*fxy[];
		cout<<"tablefunction reference value = "<<REFtablefunction
				<<" test value ="<<TESTtablefunction<<endl;
			assert(TESTtablefunction<REFtablefunction*(1+1e-2));
				assert(TESTtablefunction>REFtablefunction*(1-1e-2));
};

cout << "--------- file : AdjointSolve.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "AdjointSolve.edp";
	
};
// variationnal inequality 
// --------------------------
//  Probleme:
//  $ - \Delta u = f , \quad u=g \on \Gamma, \quad u < umax  $
//  algo of   Primal-Dual Active set strategy as a semi smoth Newton Method
//   HinterMuller , K. Ito, K. Kunisch 
//  to appeared in SIAM Option
// Thank to O. Pironneau 
// --------------------------
// F. Hecht
//  -----------------------
 mesh Th=square(10,10);
 real eps=1e-10;
 fespace Vh(Th,P1);     // P1 FE space
 int n = Vh.ndof; // number of Degree of freedom
 Vh uh,uhp,Ah;              // unkown and test function. 
real[int] rhs(n);
real cc=1000; 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 func gmax=0.05;
 Vh umax=gmax;
//
real tol=0.05,tolmin=0.002;  
real tgv = 1e30;
real res=0;
 varf a(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form
varf vM(uh,vh) = int2d(Th)(uh*vh);


matrix A=a(Vh,Vh,tgv=tgv,solver=CG);
matrix AA=a(Vh,Vh);
matrix M=vM(Vh,Vh);
rhs = a(0,Vh,tgv=tgv);
real[int] Aii(n),Aiin(n),Ah1(n),b(n);

Aii=A.diag; // get the diagonal of the matrix 
//cout << " Aii= " << Aii << endl;
Ah =0;
uhp=0;
Vh lh=0;
int kadapt=0,kkadapt=0;
for(int iter=0;iter<100;++iter)
{
  
  // solve the problem plot(uh); // to see the result
  b = rhs;
  //  add new lock condition on i / if (Ah[i] ==1 )
  Ah1= 1.; Ah1  -= Ah[];  // Ah1  = ! Ah 
  b = Ah[] .* umax[];  b *= tgv;       b  -=  Ah1 .* rhs;
  Aiin = Ah[] *  tgv; Aiin  +=  Ah1  .* Aii;
  A.diag = Aiin;
  set(A,solver=CG); // important to change precondiconning 
  uh[] = A^-1* b;
  lh[] = AA * uh[];
  lh[] += rhs;
  //  plot(lh,wait=1);
  Ah = ( lh + cc*( umax- uh)) < 0.; 
  
  // plot(Ah, wait=1,cmm=" lock ",value=1 );
  plot(uh,wait=1,cmm="uh");
  real[int] d(n),Md(n);
  d= uh[]-uhp[];    
  Md = M*d;
  real err = sqrt(Md'*d);
  Md=M*uh[];
  Ah1=1.;
  real intuh  = (Ah1'*Md); // int uh; 
  cout << " err norm L2 " << err << " "
       << " int uh = " << intuh  
      <<  " kkadapt =" << kkadapt <<endl;
  res = intuh;
  if(err< eps && kkadapt ) break;
  bool adapt = err< eps || (iter%5 == 4)  ;
  if(adapt)
    { 
      kadapt++;
      Th=adaptmesh(Th,uh,err=tol);
      kkadapt = tol == tolmin; // we reacht  the bound       
      tol = max(tol/2,tolmin);
       cout << " ++ tol = " << tol << "  " << kadapt << " " << kkadapt <<endl;
      plot(Th,wait=0);
      uhp=uhp;
      n=uhp.n;	
      uh=uh;
      Ah=Ah;
      lh=lh;
      umax = gmax; 
      A=a(Vh,Vh,tgv=tgv,solver=CG);
      AA=a(Vh,Vh);
      M=vM(Vh,Vh);
      Aii.resize(n);	
      Aiin.resize(n);
      Ah1.resize(n);
      b.resize(n);
      rhs.resize(n); 
      Aii=A.diag; // get the diagonal of the matrix 
      rhs = a(0,Vh,tgv=tgv);
    }
  uhp[]=uh[];
} 
savemesh(Th,"mm",[x,y,uh*10]);
{
  int nn=100;

  real[int] xx(nn+1),yy(nn+1),pp(nn+1);
  for (int i=0;i<=nn;i++)
   {
   
     xx[i]=i/real(nn);
     yy[i]=uh(0.5,i/real(nn));
    }
   plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
}

Aiin=M*uh[];
Aii=1.;
cout << " -- int uh = " << res  << endl;
assert( abs(res-0.0288611) < 0.001);  
   
  
  
include "ElasticLaw2d.idp"

// ================================================================

//  I[0] = trace(C) +1 
//  I[1] = (trace(C)^2 - trace(C^2) )/2
//  I[2] = det(C) 
//  Model from wiki https://en.wikipedia.org/wiki/Neo-Hookean_solid
// the  materail coef ..
real mu = 5.e2; //  kg/cm^2
real lambda= 2e3;
real C1 = mu/2;
real D1 = lambda/2;
// log(sqrt(a)*sqrt(a)) = log(sqrt(a))+log(sqrt(a)) 
// 2 log(sqrt(a)) = log(a)
// J=sqrt(I3) =>   (sqrt(I3)-1)^2 ' =  sqrt(I3)' (sqrt(I3)-1) = 0.5 I3' (1-1/sqrt(I3))
// -1/sqrt(I3)'  = 0.5 I3''/(sqrt(I3)*I3)
// the enarge ... 
macro W(I) ( 
	C1*(I[0] - 4. - log(I[2]) ) 
      + D1 *sqr(1.-sqrt(I[2])) )   //EOM  (J-1)^2 
          
macro dW(I,dI)  ( 
	  C1*    (dI[0] - dI[2]/I[2] )
	+ 0.5*D1*dI[2]*(1.-1/sqrt(I[2])  )
	)    //EOM
// EOM
macro ddW(I,dI,ddI) ( 
	+C1/sqr(I[2])*ddI[2]*dI[2] 
	+ 0.25*D1* dI[2]*ddI[2]/(sqrt(I[2])*I[2])
	)   //EOM
 // EOM

// ************************************************
// THE (BIO)MECHANICAL PARAMETERS: Begin

//  Elastic coefficients


//  Stress loads
real Pa = -3.e2;


// THE (BIO)MECHANICAL PARAMETERS: End
// ************************************************


// ************************************************
// THE COMPUTATIONAL PARAMETERS: Begin

//  The wound radius
real InnerRadius = 1.e0;

//  The outer (truncated) radius
real OuterRadius = 4.e0;

//  Tolerance (L^2)
real tol = 1.e-4;

//  Extension of the inner ellipse ((major axis) - (minor axis))
real InnerEllipseExtension = 1.e0;

int m = 100, n = 50;

border InnerEdge(t = 0, 2.0*pi) {x = (1.0 + InnerEllipseExtension) * InnerRadius * cos(t); y = InnerRadius * sin(t); label = 1;}

border OuterEdge(t = 0, 2.0*pi) {x = (1.0 + 0.0 * InnerEllipseExtension) * OuterRadius * cos(t); y = OuterRadius * sin(t); label = 2;}

mesh Th = buildmesh(InnerEdge(-m) + OuterEdge(n));
plot(Th,wait=1);
int bottom=1, right=2,upper=3,left=4;

int Nnewton     = 20;
real epsNewton  = 1.e-10;

fespace Wh(Th,[P2,P2]);

// methode de Newton ..

 Wh [d1,d2]=[0,0/100]; // Ok CL sirichlet homogene . 
 Wh [w1,w2],[v1,v2];
 
    cout << 0  << "  Energie  = " << int2d(Th)(W2d([d1,d2])) - int1d(Th,1)( Pa * ([d1,d2]'*[N.x,N.y]) )  << endl;
    
 for(int i=0;i<Nnewton;++i)
 {
  
    solve dWW([w1,w2],[v1,v2]) = 
         int2d(Th)( ddW2d([d1,d2],[w1,w2],[v1,v2]) ) 
       - int2d(Th)( dW2d([d1,d2],[v1,v2]) )
       - int1d(Th,1)( Pa * (N'*[v1,v2]) ) 
       
       // -[v1,v2]'*[f1,f2] ) 
      + on(2,w1=0,w2=0); 
      
     d1[] -= w1[];
     plot([d1,d2],coef=1/d1[].linfty, cmm=d1[].linfty);
     real err = w1[].linfty;
     cout << i << " err Nw = " << err << " d max = " << d1[].linfty 
          << "  Energie  = " << int2d(Th)(W2d([d1,d2]))  - int1d(Th,1)( Pa * ([d1,d2]'*[N.x,N.y]) )  << endl;
     if(err< epsNewton) break;
     assert(err < 1e5);  
 
  }
{
       real amplify= 0.3/d1[].linfty;
       mesh Thm=movemesh(Th,[x+d1*amplify,y+d2*amplify]);
       plot(Thm,wait=1,[d1,d2],coef=amplify);
}
  
 
 // Laplace operator with RHS sum of Dirac 
 //  f = sum  cdelta_i \delta_i
 real[int] xdelta = [0.25,0.6];//  coord x de delta_i
 real[int] ydelta = [0.25,0.6];//  coord x de delta_j
 real[int] cdelta=[1.,2.];//  coef    delta_i
  mesh Th=square(10,10);
  verbosity=0;

// Reference value for FFCS regression tests
real ref;

 for(int iter=0;iter < 11;iter++)
 {

 fespace Vh(Th,P1);     // P1 FE space
 
 matrix D = interpolate(Vh,xdelta,ydelta); // the interpolation matrix  
 // at point (xdelta[j],ydelta[i] ) \hfilll
 // so $D_ij = w^i((xdelta[j],ydelta[j]) $ where $w^i$ are the basic function of $V_h$. 
 
 Vh uh,vh;  // unkown and test function. 
 func g=0;                 //  boundary condition function
 Vh b;
 b[]= D*cdelta;
 b[]= -b[];
 problem laplace(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + b[]                         //  linear form of the rhs (so an array)
  + on(1,2,3,4,uh=0) ;          //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  cout <<iter << "max uh = " << uh[].max << " nv =  "<< Th.nv <<  endl; 
  plot(uh,wait=1,dim=3,fill=1);
  Th=adaptmesh(Th,uh,nbvx=100000,err= 0.01*1.15^-iter);
  
  // Reference value for FFCS regression tests
  ref=uh[]'*uh[];//'
  }
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
mesh Th=square(5,5);
fespace Vh(Th,P2);
Vh uh=x*x+y*y,vh=-y^2+x^2;
assert(n+1 < nn);
//  compute a cut 
for (int i=0;i<=n;i++)
 {
   xx[i]=i;
   yy[i]=uh(real(i)/n,real(i)/n); // value of uh at point (i/10. , i/10.) 
 }
 
 plot(Th,uh,[uh,vh],value=true,ps="three.eps",wait=true); // plot mesh, isovalue, and vector
 plot([xx(0:n),yy(0:n)],[xx(0:n:5),yy(0:n:5)],ps="likegnu.eps",wait=true); //  like gnuplot plot a cut of uh
// file for gnuplot
{
  ofstream gnu("plot.gp");
for (int i=0;i<=n;i++)
 {
  gnu <<  xx[i] << " " << yy[i] << endl;
 }
}
savegnuplot(Th,"Th.gp");
exec("echo 'plot \"Th.gp\" w l, \"\" w labels offset 1.5 \
pause 5 \
set term postscript \
set output \"gnuTh.eps\" \
replot \
quit' | gnuplot"); 
//  to call gnuplot command and wait 5 second (tanks to unix command)
//  and make postscipt plot 
exec("echo 'plot \"plot.gp\" w l \
pause 5 \
set term postscript \
set output \"gnuplot.eps\" \
replot \
quit' | gnuplot"); 
// Mesh
border ba(t=0, 1.0){x=t;   y=0;  label=1;}
border bb(t=0, 0.5){x=1;   y=t;  label=2;}
border bc(t=0, 0.5){x=1-t; y=0.5;label=3;}
border bd(t=0.5, 1){x=0.5; y=t;  label=4;}
border be(t=0.5, 1){x=1-t; y=1;  label=5;}
border bf(t=0.0, 1){x=0;   y=1-t;label=6;}
mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));
savemesh(Th, "th.msh");

// Fespace
fespace Vh(Th, P2);
fespace Nh(Th, P0);
Vh u, v;
Nh rho, logrho;

// Variables
real[int] viso(21);
for (int i = 0; i < viso.n; i++)
	viso[i]=10.^(+(i-16.)/2.);

// Functions
func f = (x-y);

// Problem
problem Probem1 (u, v, solver=CG, eps=1.0e-6)
	= int2d(Th, qforder=5)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	+ int2d(Th, qforder=10)(-f*v)
	;

varf indicator2 (uu, chiK)
	= intalledges(Th)(
		  chiK*lenEdge*square(jump(N.x*dx(u) + N.y*dy(u)))
	  )
	+ int2d(Th)(
		  chiK*square(hTriangle*(f+dxx(u)+dyy(u)))
	)
	;

// Adaptation loop
real error = 0.01;
for (int i = 0; i < 4; i++) {
	// Solve
	Probem1;
	cout << u[].min << " " << u[].max << endl;

	// Plot
	plot(u, wait=1);

	// Indicator
	rho[] = indicator2(0, Nh);
	rho = sqrt(rho);
	logrho = log10(rho);
	cout << "rho min = " << rho[].min << ", rho max = " << rho[].max << endl;

	// Plot
	plot(rho, fill=1, wait=1, cmm="indicator density ", value=1, viso=viso, nbiso=viso.n);
	plot(logrho, fill=1, wait=1, cmm="log 10 indicator density ", value=1, nbiso=10);

	// Mesh adaptation
	Th = adaptmesh(Th, [dx(u), dy(u)], err=error, anisomax=1);
	plot(Th, wait=1);

	// Interpolation
	u = u;
	rho = rho;

	// Update error
	error = error/2;
}
//  non linear elasticity model 
//   
//  -------------------------------
//  with huge utilisation of  macro  new version
// more simple 
// ---------------------------
//   optimize version 
// ------------
//  problem is  find $(uu,vn)$  minimizing  $J$
//  $ min J(un,vn) = \int 1/2 (F2) -  int Pa * un $
//   $ dJ(u,u,uu,vv) = int dF2(u,v,uu,vv) df(F2(u,v)) $
//   where $F2 =  (^t {E}  A {E} ) $,
//   $E(U) =  1/2 (\nabla U + \nabla U^t + \nabla U^t  \nabla U) $
//         ($u_1$)
//  with U=(   )
//         ($u_2$)
// so: 
//$$ E_ij = 0.5 ( d_i u_j + d_j u_i ) + \sum_k d_i u_k * d_j*u_k  \leqno(1)$$
//  the symetric tensor $t_{ij}$ are a vector  [t11,2*t12,t22] 
// date from
/*
Proposal for numerical benchmarking of fluid-structure interaction between an elastic object and laminar incompressible flow

Stefan Turek and Jaroslav Hron⋆
Institute for Applied Mathematics and Numerics, University of Dortmund,
Vogelpothsweg 87, 44227 Dortmund, Germany

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.550.1689&rep=rep1&type=pdf

section 4.2 CSM test: 
*/

macro EL(u,v) [dx(u),(dx(v)+dy(u)),dy(v)] // is $[\epsilon_{11},2\epsilon_{12},\epsilon_{22}]$

macro ENL(u,v) [ 
(dx(u)*dx(u)+dx(v)*dx(v))*0.5,
(dx(u)*dy(u)+dx(v)*dy(v))    ,
(dy(u)*dy(u)+dy(v)*dy(v))*0.5 ] // EOM ENL 

macro dENL(u,v,uu,vv) [(dx(u)*dx(uu)+dx(v)*dx(vv)),
 (dx(u)*dy(uu)+dx(v)*dy(vv)+dx(uu)*dy(u)+dx(vv)*dy(v)),
 (dy(u)*dy(uu)+dy(v)*dy(vv)) ] // 
 
 
macro E(u,v) (EL(u,v)+ENL(u,v)) // is $[\E{11},\sqrt2\E{12},\E{22}]
macro dE(u,v,uu,vv) (EL(uu,vv)+dENL(u,v,uu,vv)) //
macro ddE(u,v,uu,vv,uuu,vvv) dENL(uuu,vvv,uu,vv) //
macro F2(u,v) (E(u,v)'*A*E(u,v)) // 
macro dF2(u,v,uu,vv)  (E(u,v)'*A*dE(u,v,uu,vv) ) //
macro ddF2(u,v,uu,vv,uuu,vvv) (
            (dE(u,v,uu,vv)'*A*dE(u,v,uuu,vvv)) 
          + (E(u,v)'*A*ddE(u,v,uu,vv,uuu,vvv))  )// EOM

//  for hyper elasticity problem 
//  -----------------------------
macro f(u) (u) // end of macro
macro df(u) (1) // end of macro
macro ddf(u) (0) // end of macro

// -------------------------------
//  
//   $  \sigma = 2 \mu E + \lambda tr(E) Id $
//   $   A(u,v)= \sigma(u):\E(v) $
//   
//   ( a b )
//   ( b c )
//
//  tr*Id : (a,b,c) -> (a+c,0,a+c) 
// so the associed matrix is:
//   ( 1 0 1 )
//   ( 0 0 0 )
//   ( 1 0 1 ) 
// ------------------
verbosity=0;

// data CMS 1 
real xp=0.35,yp=0.0;//
real upbench= -0.007187, vpbench= -0.066;

real EE = 1.4e6;
real rho = 1000;
real sigma = 0.4;
real mu = EE/(2*(1+sigma));
real lambda = EE*sigma/((1+sigma)*(1-2*sigma));
real gravity = -2;
int nnn = 10;

mesh Th = square(17*nnn,nnn,[0.35*x,0.02*(y-0.5)]);
cout<<" Th nt : " << Th.nt<<endl;
int bottom=1, right=2,upper=3,left=4;

plot(Th);

real a11= 2*mu +  lambda  ;
real a22= mu ; //  because [0,2*t12,0]' A [0,2*s12,0]  = 2*mu*(t12*s12+t21*s21) = 4*mu*t12*s12
real a33= 2*mu +   lambda ;
real a12= 0 ;
real a13= lambda ;
real a23= 0 ;
//  symetric part
real a21= a12 ;
real a31= a13 ;
real a32= a23 ;
func A = [ [ a11,a12,a13],[ a21,a22,a23],[ a31,a32,a33] ];  





 
fespace Vh(Th,[P2,P2]);






Vh [uu,vv], [w,s],[un,vn];
[un,vn]=[0,0];//  intialisation 
[uu,vv]=[0,0];



real errb=0; 
// Newton's method
// ---------------
for (int i=0;i<10;i++)
{
  cout << "Loop " << i << endl;
  solve NonLin([uu,vv],[w,s])=
    int2d(Th)(        ddF2(un,vn,uu,vv,w,s)  )
     - int2d(Th)(  dF2(un,vn,w,s) - rho*gravity*s)    
     + on(left,uu=0,vv=0);
  ;  
  real res = uu[].linfty ; //  norme  L^2 of [uu,vv]
  errb = max(abs(un(xp,yp)-upbench) , abs(vn(xp,yp)-vpbench));

  un[] -= uu[]; 
  cout << "     Linfty residual = " << res << endl;
  cout << "     u of A =" << un(xp,yp) << " " << vn(xp,yp)  <<  " bench " << upbench  << " "<< vpbench << " err bench =" << errb << endl; 
  plot(movemesh(Th, [x+un, y+vn]),wait=1,cmm=" i =" +i + " err =" + res);

  if (res<1e-10) break;
}

cout << " err bench = " << errb << endl;  
//plot([un,vn],wait=1);
mesh th1 = movemesh(Th, [x+un, y+vn]);
plot(th1,wait=1,ps="nl-elas.eps");
assert( errb < 1e-2);
// irregular boundary condition. 
real Ax=0.9,Ay=1;
real Bx=2,By=1;
real Cx=2.5,Cy=2.5;
real Dx=1,Dy=2;
real gx = (Ax+Bx+Cx+Dx)/4.;
real gy = (Ay+By+Cy+Dy)/4.;

macro  LINEBORDER(A,B,lab) border A#B(t=0,1){real t1=1.-t;x=A#x*t1+B#x*t;y=A#y*t1+B#y*t;label=lab;}//EOM

LINEBORDER(A,B,1)
LINEBORDER(B,C,2)
LINEBORDER(C,D,3)
LINEBORDER(D,A,4)

// , A (1-x)(1-y) B x(1-y)  C: x*y  , D (x-1)*y) 
//mesh Th=square(10,10,[Cx*x*y+ Bx*(1-x)*y + Cx*(1-x)*(1-y) + Dx*(x)*(1-y),Ay*x*y+ By*(1-x)*y + Cy*(1-x)*(1-y) + Dy*(x)*(1-y)]  );
int n=10;
macro dist(ax,ay,bx,by) sqrt(square((ax)-(bx))+ square((ay)-(by)))  // EOM  
real l1=dist(Ax,Ay,Bx,By);
real l2=dist(Bx,By,Cx,Cy);
real l3=dist(Cx,Cy,Dx,Dy);
real l4=dist(Dx,Dy,Ax,Ay);
func s1=dist(Ax,Ay,x,y)/l1;
func s2=dist(Bx,By,x,y)/l2;
func s3=dist(Cx,Cy,x,y)/l3;
func s4=dist(Dx,Dy,x,y)/l4;
cout << " l1:4 = "<< l1 << " " << l2 << " "<< l3 << " " <<l4 << endl;
cout << "  s1:4 (final point: :)= " << s1(Bx,By) << " " 
     << s2(Cx,Cy) << " " 
     << s3(Dx,Dy) << " " 
     << s4(Ax,Ay) << "\n "; 

mesh Th=buildmesh(AB(n)+BC(n)+CD(n)+DA(n),fixedborder=1);

verbosity=6;// to see the abscisse value pour the periodic condition.
fespace Vh(Th,P1,periodic=[[1,s1],[3,s3],[2,s2],[4,s4]]);
verbosity=1;
macro Grad(u) [dx(u),dy(u)]//EOM
Vh u,v;

real cc=0;
cc= int2d(Th)((x-gx)*(y-gy)-cc)/Th.area;
cout << " compatibility =" << int2d(Th)((x-gx)*(y-gy)-cc) <<endl;

solve Poission(u,v)=int2d(Th)(Grad(u)'*Grad(v)+ 1e-10*u*v)-int2d(Th)(10*v*((x-gx)*(y-gy)-cc));
plot(u,wait=1,value=1);

// Mesh
border ba(t=0, 1.0){x=t;   y=0;  label=1;}
border bb(t=0, 0.5){x=1;   y=t;  label=2;}
border bc(t=0, 0.5){x=1-t; y=0.5;label=3;}
border bd(t=0.5, 1){x=0.5; y=t;  label=4;}
border be(t=0.5, 1){x=1-t; y=1;  label=5;}
border bf(t=0.0, 1){x=0;   y=1-t;label=6;}
mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));
savemesh(Th, "th.msh");

// Fespace
fespace Vh(Th, P1);
fespace Nh(Th, P0);
Vh u, v;
Nh rho;

// Variables
real[int] viso(21);
for (int i = 0; i < viso.n; i++)
	viso[i] = 10.^(+(i-16.)/2.);

// Functions
func f = (x-y);

// Problem
problem Probem1 (u, v, solver=CG, eps=1.0e-6)
	= int2d(Th, qforder=5)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
		)
	+ int2d(Th, qforder=5)(-f*v)
	;

varf indicator2 (uu, chiK)
	= intalledges(Th)(
		  chiK*lenEdge*square(jump(N.x*dx(u) + N.y*dy(u)))
	)
	+ int2d(Th)(
		  chiK*square(hTriangle*(f + dxx(u) + dyy(u)))
	)
	;

// Adaptation loop
real error = 0.01;
for (int i = 0; i < 4; i++) {
	// Solve
	Probem1;
	cout << u[].min << " " << u[].max << endl;

	// Plot
	plot(u, wait=1);

	// Indicator
	rho[] = indicator2(0, Nh);
	rho = sqrt(rho);
	cout << "rho min = " << rho[].min << ", rho max = " << rho[].max << endl;

	// Plot
	plot(rho, fill=1, wait=1, cmm="indicator density", value=1, viso=viso, nbiso=viso.n);

	// Mesh adaptation
	Th = adaptmesh(Th, u, err=error, anisomax=1);
	plot(Th, wait=1);

	// Interpolation
	u = u;
	rho = rho;

	// Update error
	error = error/2;
}
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=CG) =          //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  - int1d(Th,1)( vh)
  - int2d(Th)( f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="LaplaceP1P2h.eps",value=true);
//  if error on macos version codeworrior 
//  remove in panal  PPC linker FreeFEm++ Setting Dead-strip Static Initializition Code Flag
  fespace V2h(Th,P2);
 V2h u2h,v2h;              // unkown and test function. 

 problem errorh (u2h,v2h,solver=CG) =           //  definion of  the problem 
    int2d(Th)( dx(u2h)*dx(v2h) + dy(u2h)*dy(v2h) ) //  bilinear form
  + int1d(Th,1)( u2h*v2h) 
  - int1d(Th,1)( v2h)
  - int2d(Th)( f*v2h )                          //  linear form
  + on(2,3,4,u2h=g) ;                      //  boundary condition form
 errorh;
plot(u2h,ps="ErrorHerachical.ps",value=true,wait=1);
real D=0.1, H=0.41;
real cx0 = 0.2, cy0 = 0.2; // center of cyl. 
real xa = 0.15, ya=0.2, xe = 0.25,ye =0.2;
border fr1(t=0,2.2){x=t; y=0; label=1;}
border fr2(t=0,H){x=2.2; y=t; label=2;}
border fr3(t=2.2,0){x=t; y=H; label=1;}
border fr4(t=H,0){x=0; y=t; label=1;}
border fr5(t=2*pi,0){x=cx0+D*sin(t)/2; y=cy0+D*cos(t)/2; label=3;}
int nn=15;
 
mesh Th=buildmesh(fr1(5*nn)+fr2(nn)+fr3(5*nn)+fr4(nn)+fr5(-nn*3));
real Um= 1.5;// max velocity (Rey 100) 
func Ub = Um*2./3.; 
real nu = 1e-3; 
real Rey = Ub*D/nu;
// Boundary condition 
func U1 = 4.*Um*y*(H-y)/(H*H)  ;
func U2 = 0. ;

 real T=2,t=0; 
 real dt = D/nn/Um;// CFL = 1 
 cout << " dt = " << dt <<endl;
real alpha=1/dt,epspq=1e-10;


fespace Mh(Th,[P1]);
fespace Xh(Th,[P2]);
fespace Wh(Th,[P1dc]);
macro grad(u) [dx(u),dy(u)] //
macro div(u1,u2) (dx(u1)+dy(u2)) //

 
 varf von1([u1,u2,p],[v1,v2,q]) =  on(3,u1=0,u2=0) + on(1,u1=U1,u2=U2);

//remark : the value 1000 in next line is manualy fitted, because free outlet. 
 varf vA(p,q) =int2d(Th)((grad( p ) '*grad(q)) ) + int1d(Th,2)(1000*p*q) ;
 varf vM(p,q) =int2d(Th,qft=qf2pT)(  p*q );

 varf vu([u1],[v1]) = int2d(Th)(alpha*(u1*v1)+nu*(grad(u1)'*grad(v1) )) 
                       + on(1,3,u1=0) ;
 varf vu1([p],[v1]) = int2d(Th)(p*dx(v1)) ;
 varf vu2([p],[v1]) = int2d(Th)(p*dy(v1)) ;
   
 string solver="UMFPACK";
 if(!HaveUMFPACK) solver="CHOLESKY";
 matrix pAM=vM(Mh,Mh,solver=solver); 
 matrix pAA=vA(Mh,Mh,solver=solver); 
 matrix AU=vu(Xh,Xh,solver=solver); 
 matrix B1=vu1(Mh,Xh);
 matrix B2=vu2(Mh,Xh);
 Xh u1,u2;
 Mh p;
varf vonu1([u1],[v1]) =  on(1,u1=U1) + on(3,u1=0);
varf vonu2([u1],[v1]) =  on(1,u1=U2) + on(3,u1=0);


real[int] brhs1 = vonu1(0,Xh);
real[int] brhs2 = vonu2(0,Xh);
 
varf  vrhs1(uu,vv)  = int2d(Th) (convect([u1,u2],-dt,u1)*vv*alpha)+vonu1 ;
varf  vrhs2(v2,v1)  = int2d(Th) (convect([u1,u2],-dt,u2)*v1*alpha)+vonu2;


func  real[int]   JUzawa(real[int] & pp) 
{
	real[int] b1=brhs1; b1 += B1*pp;
	real[int] b2=brhs2; b2 += B2*pp;
	u1[] = AU^-1 * b1;
	u2[] = AU^-1 * b2;
	pp  = B1'*u1[];
	pp += B2'*u2[];
	pp = -pp; 
	return pp; 
}

func  real[int]   Precon(real[int] & p)
 {  
    real[int] pa= pAA^-1*p;
    real[int] pm= pAM^-1*p;
    real[int] pp= alpha*pa+nu*pm;
 
  	return pp;
 }

 verbosity = 0; 
 p=0;
 
   
 Wh w; // to store voticity ..
  
 real eps=1e-6;
 int ndt = T/dt;
 for(int i=0;i<ndt;++i)
 {
     brhs1 = vrhs1(0,Xh);
     brhs2 = vrhs2(0,Xh);
     int res=AffineCG(JUzawa,p[],precon=Precon,nbiter=100,verbosity=10,veps=eps); 
     assert(res==1) ; 
     eps = -abs(eps); 
     w = -dy(u1)+dx(u2);
     plot(w,fill=1,wait=0, nbiso=40,WindowIndex=0);
    
     dt = min(dt,T-t);
     t += dt; 
     if( dt < 1e-10*T) break;  
	 if( clock()>50)  break; // to remove CPU limit exceed on some slow machine  
 }
 plot(w,fill=1,wait=0, nbiso=40,ps="NScahouetChabart.eps");
 cout << " u1 max " << u1[].linfty 
      << " u2 max " << u2[].linfty 
      << " p max = " << p[].max << endl; 
 
// FFCS: for regression tests
real regtest;
{
    // example of mesh with a given set of internal point (P)
    // P(i,0) x,
    // P(i,1) y,
    // P(i,2) = mesh density close to x,y not mandatory ..
    verbosity=1;
   
 real[int,int] P(100,3);
 for(int i=0; i<P.n; ++i)
  {
      P(i,0) = 0.5+0.1*cos(i*0.02*pi);
      P(i,1) = 0.5+0.1*sin(i*0.02*pi);
      P(i,2) = 0.05*0.02*2*pi;// mesh size auron point..
  }
// multy border syntax version 3.30 avril 2014 ... 
  real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
  // radius, centre of the 4 circles .. 
  real[int] RC=[ 0.1, 0.05, 0.05, 0.1],
            XC= [0.2,0.8,0.2,0.8],
            YC= [0.2,0.8,0.8,0.2];
  int[int]  NC=[-10,-11,-12,13]; //list number of $\pm$ segments
  // of the 4 circles borders  

  border bb(t=0,1;i) 
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 0; ; 
  }
  
  border cc(t=0,2*pi;i) 
 {
    x = RC[i]*cos(t)+XC[i];
    y = RC[i]*sin(t)+YC[i];
    label = i+1; 
  }
  int[int] nn=[4,4,5,7];// 4 border , with 4,4,5,7 segment respectively . 
  plot(bb(nn),cc(NC),wait=1);
  mesh th= buildmesh(bb(nn)+cc(NC), points=P,nbvx=100000) ; 
  plot(th,wait=1,ps="multy-border+internal.eps"); 
  regtest = th.area; 
}
// macro the get the current mesh size
// parameters
// input:
//   - Th: the mesh
//   - Vh: P1 fespace on Th
// output:
//   - h: the Vh finite element finite set to the current mesh size
macro  MeshSizecomputation(Th, Vh, h)
{	/*Th mesh
	 * Vh P1 finite element space
	 * h the P1 mesh size value
	 */
	real[int] count(Th.nv);
	/* mesh size (lenEdge = int_e 1) */
	varf vmeshsizen(u, v) = intalledges(Th, qfnbpE=1)(v);
	/* number of edge / par vertex */
	varf vedgecount(u, v) = intalledges(Th, qfnbpE=1)(v/lenEdge);
	/* computation of the mesh size */
	count = vedgecount(0, Vh);
	h[] = 0.;
	h[] = vmeshsizen(0, Vh);
	cout << "count min = " << count.min << ", max = " << count.max << endl;
	h[] = h[]./count;
    cout << "bound meshsize = " << h[].min << " " << h[].max << endl;
} // end of macro MeshSizecomputation

// macro to remesh according the de residual indicator
// input:
//   - Th: the mesh
//   - Ph: P0 fespace on Th
//   - Vh: P1 fespace on Th
//   - vindicator: the varf to evaluate the indicator to ^2
//   - coef: coef on etameam
macro  ReMeshIndicator(Th, Ph, Vh, vindicator, coef)
{
	Vh h = 0;
	/* evalutate the mesh size  */
	MeshSizecomputation(Th, Vh, h);
	Ph etak;
	etak[] = vindicator(0, Ph);
	cout << "global  Eta: " << sqrt(etak[].sum) << "  ......... " <<  Th.nv<< endl;
	etak[] = sqrt(etak[]);
	plot(etak, ps="arei-etak.eps", fill=1, value=1);
	real etastar = coef*(etak[].sum/etak[].n);
	cout << "etastar = " << etastar << ", sum = " << etak[].sum << " " << endl;

	/* here etaK is discontinous
	 * we use the P1 L2 projection with mass lumping
	 */

	 Vh fn, sigma;
	varf veta(unused, v) = int2d(Th)(etak*v);
	varf vun(unused, v) = int2d(Th)(1*v);
	fn[] = veta(0, Vh);
	sigma[] = vun(0, Vh);
	fn[] = fn[] ./ sigma[];
	fn =  max(min(fn/etastar, 3.), 0.3333) ;

	/* new mesh size */
	h = h / fn ;
	Th = adaptmesh(Th, IsMetric=1, h, splitpbedge=1, nbvx=10000);
}

// Mesh
border ba(t=0, 1.0){x=t;   y=0;  label=1;}
border bb(t=0, 0.5){x=1;   y=t;  label=2;}
border bc(t=0, 0.5){x=1-t; y=0.5;label=3;}
border bd(t=0.5, 1){x=0.5; y=t;  label=4;}
border be(t=0.5, 1){x=1-t; y=1;  label=5;}
border bf(t=0.0, 1){x=0;   y=1-t;label=6;}
mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));

// Fespace
fespace Vh(Th, P1); // for the mesh size
Vh u, v;
fespace Ph(Th, P0); // for the indicator

// Mesh adaptation
real hinit = 0.2; //
Vh   h = hinit; // the FE fonction  for the mesh size
// to build a mesh with a given mesh size: meshsize
Th = adaptmesh(Th, h, IsMetric=1, splitpbedge=1, nbvx=10000);
plot(Th, wait=1, ps="RRI-Th-init.eps");

// Functions
func f = (x-y);

// Problem
problem Poisson (u, v)
	= int2d(Th, qforder=5)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	- int2d(Th, qforder=5)(f*v)
	;

varf indicator2 (unused, chiK)
	= intalledges(Th)(
		  chiK*lenEdge*square(jump(N.x*dx(u) + N.y*dy(u)))
	)
	+int2d(Th)(
		  chiK*square(hTriangle*(f + dxx(u) + dyy(u)))
	)
	;

// Adaptation loop
for (int i = 0; i < 10; i++) {
	// Solve
	Poisson;

	// Plot
	plot(Th, u, wait=1);

	// Mesh adaptation
	real cc=0.7;
	if (i > 5) cc = 1;
	if (i < 9) {
		ReMeshIndicator(Th, Ph, Vh, indicator2, cc);
		u=u;
	}
	
	// Plot
	plot(u, Th, wait=1, ps="arei-Thu.eps", value=1);
}
//  
//   calcul d'une zone saturation en eau (nappe phréatique)
//
real L=10;        // longueur du domaine					   	
real q=0.02;      // flux entrant
real K=0.5;	      //permeabilité	

real  erradap=0.001;
real  coef=1;



real h=2.1;	 // hauteur du bord gauche
real h1=0.35;    // hauteur du bord droite

//  maillage d'un tapeze
border a(t=0,L){x=t;y=0;};       // bas			   	
border b(t=0,h1){x=L;y=t;};      // droite
border f(t=L,0){x=t;y=t*(h1-h)/L+h;}; //  free surface
border d(t=h,0){x=0;y=t;};      // gauche

int n=10;
mesh Th=buildmesh (a(L*n)+b(h1*n)+f(sqrt(L^2+(h-h1)^2)*n)+d(h*n));
plot(Th,ps="dTh.eps");

fespace Vh(Th,P1);
int j=0,ii=0;

Vh u,v,uu,vv;

problem Pu(u,uu,solver=CG) = int2d(Th)( dx(u)*dx(uu)+dy(u)*dy(uu)) 
  + on(b,f,u=y) ;

problem Pv(v,vv,solver=CG) = int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  on (a, v=0) + int1d(Th,f)(vv*((q/K)*N.y- (dx(u)*N.x+dy(u)*N.y))); 
  

real errv=1;
verbosity=1;
while(errv>1e-6)
{
  j++;       
  Pu;
  Pv;
  plot(Th,u,v ,wait=0);
  errv=int1d(Th,f)(v*v);
  
//  if (j%10==0)
//    Th=adaptmesh(Th,u,err=erradap ) ;
  real coef=1;
  real mintcc = checkmovemesh(Th,[x,y])/5.; 
  real mint = checkmovemesh(Th,[x,y-v*coef]); 
  
  if (mint<mintcc ||  j%10==0) {  
    Th=adaptmesh(Th,u,err=erradap ) ;
    v=v;
    u=u;
    mintcc = checkmovemesh(Th,[x,y])/5.;     
  }
  
  while (1) 
  {  	    
    real mint = checkmovemesh(Th,[x,y-v*coef]); 
    
    if (mint>mintcc) break;
    
    cout << " min |T]  " << mint << endl;    
    coef /= 1.5;
  }
  
  Th=movemesh(Th,[x,y-coef*v]); // calcul de la deformation 
  cout << "\n\n"<<j <<"------------ errv = " << errv << "\n\n";

}
plot(Th,ps="d_Thf.eps");
plot(u,wait=1,ps="d_u.eps",fill=1);
// version 3.18-2 ...
real[int] a,b(10);
a.resize(b.n); // `
a=b;  
a=[1,2];
a.resize(5); //  Pas init a voir ??? 
cout << "a="<<a << endl;
real[int,int][int] m(10);
real[int][int] v(10);
for(int i=0;i<v.n;++i)
{
  v[i].resize(i+1);
  for(int j=0;j<v[i].n;++j)
    v[i][j] = 100*i + j;   
}

cout << " v = " << v << endl;
v.resize(4);
cout << " v = " << v << endl;
v.resize(10);
cout << " v = " << v << endl;

// test sub array of full matrix ... 
real[int,int] A(10,5);
for(int i=0;i<A.n;++i)
for(int j=0;j<A.m;++j)
  A(i,j)=i*100+j;

cout << " A( 2:4,1:2) =" << A( 2:4,1:2) << endl;
cout << " A( 2,1:2) =" << A( 2,1:2) << endl;
cout << " A( 1:3,1) =" << A( 1:3,1) << endl;
cout << " A( :,1) =" << A( :,1) << endl;
cout << " A( :,1).sum =" << A( :,1).sum << endl;
cout << " A( :,1).min =" << A( :,1).min << endl;
// This is the rotating hill problem with one turn

// Parameters
real dt = 0.17, t = 0;	// time step

// Mesh
border a(t=0, 2*pi){x=cos(t); y=sin(t);}	// the unit circle
mesh th = buildmesh(a(70));	// triangulates the disk

// Fespace
fespace Vh(th, P1);
Vh v;
Vh u1, u2;
Vh vv, vo; // work Finite element function

// Function
func real hill (real r2){ return exp(-10*(r2)); }

// Initialization
v = hill( (x-0.3)^2 +(y-0.3)^2 );
plot(v);

u1 = y;
u2 = -x;	// rotation velocity
int i;
for (i = 0; i < 20; i++) {
	t += dt;
	vo = v;
	v = convect([u1, u2], -dt, vo);	// convect v by u1,u2, dt seconds, results in f
	plot(v, cmm="convection: t=" + t + ", min=" + v[].min + ", max=" + v[].max, wait=0);
}
// Schwarz without overlapping (Shur complenement Neumann -> Dirichet)  
verbosity=2;
real cpu=clock();
int inside = 2; 
int outside = 1;
border Gamma1(t=1,2){x=t;y=0;label=outside;};
border Gamma2(t=0,1){x=2;y=t;label=outside;};
border Gamma3(t=2,0){x=t ;y=1;label=outside;};

border GammaInside(t=1,0){x = 1-t; y = t;label=inside;};

border GammaArc(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh Th1 = buildmesh( Gamma1(5*n) + Gamma2(5*n) + GammaInside(5*n) + Gamma3(5*n));
mesh Th2 = buildmesh ( GammaInside(-5*n) + GammaArc(25*n) );

plot(Th1,Th2);

fespace Vh1(Th1,P1),      Vh2(Th2,P1);
Vh1 u1=0,v1;              Vh2 u2,v2;
Vh1 lambda=0;  // take $\lambda \in V_{h1}$
/*
Remark, to day is not possible to
defined a function just on a border, so the $\ lambda $
function is defined on the all domain $\Omega_1$
by:
*/
int i=0;  // for factorization optimization 


problem Pb2(u2,v2,init=i,solver=Cholesky) = 
    int2d(Th2)( dx(u2)*dx(v2)+dy(u2)*dy(v2) )
  + int2d(Th2)( -v2) 
  + int1d(Th2,inside)(-lambda*v2) +    on(outside,u2= 0 ) ;
problem Pb1(u1,v1,init=i,solver=Cholesky) = 
    int2d(Th1)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  + int2d(Th1)( -v1) 
  + int1d(Th1,inside)(+lambda*v1) +    on(outside,u1 = 0 ) ;

varf b(u2,v2,solver=CG) =int1d(Th1,inside)(u2*v2);
matrix B= b(Vh1,Vh1,solver=CG);

//  $\lambda \longrightarrow  \int_{\Gamma_i }(u_1-u_2) v_{1}$
func real[int] BoundaryProblem(real[int] &l)
{ 
   lambda[]=l;
   Pb1; 
   Pb2;
   i++;
   v1=-(u1-u2); 
   lambda[]=B*v1[];
   return lambda[] ;
};
/*
Remark, the  difference between the tow notation \ttCC{v1} and \ttCC{v1[]}  is: 
 \ttCC{v1} is the finite element  function and \ttCC{v1[]} 
is the vector in the canonical basis of the   finite element  function  \ttCC{v1} .
*/
Vh1 p=0,q=0; 
//  solve the problem with Conjugue Gradient

LinearCG(BoundaryProblem,p[],q[],eps=1.e-6,nbiter=100);
//  compute the final solution, because CG works with increment
BoundaryProblem(p[]); // solve again  to have right u1,u2
cout << " -- CPU time  schwarz-gc:" <<  clock()-cpu << endl;

plot(u1,u2);

 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=GMRES,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="Laplace.eps",value=true);
border floor(t=0,1){ x=t; y=0; label=1;}; // the unit square
border right(t=0,1){ x=1; y=t; label=5;};
border ceiling(t=1,0){ x=t; y=1; label=5;};
border left(t=1,0){ x=0; y=t; label=5;};
int n=10;
mesh th= buildmesh(floor(n)+right(n)+ceiling(n)+left(n));
savemesh(th,"toto.am_fmt");// format "formated Marrocco"
savemesh(th,"toto.Th");//format database "bamg"
savemesh(th,"toto.dbg");//format debug
savemesh(th,"toto.msh"); //format freefem
mesh th2 = readmesh("toto.msh");
fespace femp1(th,P1);
femp1 f = sin(x)*cos(y),g;
int where;
real xx;
{
  
  ofstream file("f.txt",binary);// for windows add binary version 3.30 
  file.precision(16);
  file << f[] << endl;
  where=file.tellp();
  file << 0.1 ;
  //  file << " " << 0.2 ;
  cout << " where in file " << where << endl;
  file << " # comment bla bla ...  0.3 \n";
  file << 0.2 << endl; 
  file.flush; // to flush the io  buffer of file
}
//  Idea to skip comment in a file ...  start with  # too EOL
func ifstream skipcomment(ifstream &ff)
{
    
    while(1)
    {
    int where = ff.tellg(); // store file position 
    string comment;
    ff >> comment; 
    if ( ! ff.good() ) break; 
    if( comment(0:0)=="#") {
         getline(ff,comment);
         cout << " -- #" << comment << endl;
    }
    else {
        ff.seekg(where); //restore file position 
        break;        
    }    
    }
    return ff;
}


{
  ifstream file("f.txt",binary); // for windows (pb CRNL EOL  translation ) 
  int l = file.length;
  cout << " where " << file.seekg << endl; 
  file.seekg(where);
  file >> xx;
  cout <<  " xx = " << xx << " good ? " << file.good() << endl;
  assert(xx==0.1);
  skipcomment(file) >> xx;
  assert(xx==0.2);
  where =file.tellg();
  assert(!file.eatspace); 
  cout << where << " < " << l << endl; 
  assert(l>=where);
  file.seekg(0);
  cout << " where " << file.tellg() << " " << file.good() << endl; 
  file >> g[] ;
  // nothing after only space
  
}
fespace Vh2(th2,P1);
Vh2 u,v;
plot(g);
solve pb(u,v) =
    int2d(th2)( u*v -dx(u)*dx(v)-dy(u)*dy(v) )
  + int2d(th2)(-g*v) 
  + int1d(th2,5)( -g*v)
  + on(1,u=0) ;
plot (th2,u);
cout << " (u[],u[]) = " << (u[]'*u[]) << endl; 
{
ofstream file("u.txt");
file << u[] << endl;
 file.seekp(100);
 file.flush;
 file  << "xxx "<< endl;
 
}
real r=0.25;
// a diamond with a hole
border a(t=0,1){x=-t+1; y=t;label=1;}; 
border b(t=0,1){ x=-t; y=1-t;label=2;};
border c(t=0,1){ x=t-1; y=-t;label=3;};
border d(t=0,1){ x=t; y=-1+t;label=4;};
border e(t=0,2*pi){ x=r*cos(t); y=-r*sin(t);label=0;};
int n = 10;
mesh Th= buildmesh(a(n)+b(n)+c(n)+d(n)+e(n)); 
plot(Th,wait=1);
real r2=1.732;
func abs=sqrt(x^2+y^2);
//  warning for periodic condition:
//  side a and c \hfilll
//  on side a (label 1) $ x \in [0,1] $ or $ x-y\in [-1,1] $ \hfilll
//  on side c (label 3) $ x \in [-1,0]$ or $ x-y\in[-1,1] $\hfilll
// so the common abcissa can be repectively $x$ and $x+1$
// or you can can try curviline abcissa $x-y$ and $x-y$ 
//  1 first way
// fespace Vh(Th,P2,periodic=[[2,1+x],[4,x],[1,x],[3,1+x]]);     
// 2 second way
 fespace Vh(Th,P2,periodic=[[2,x+y],[4,x+y],[1,x-y],[3,x-y]]);     

 Vh uh,vh;             

 func f=(y+x+1)*(y+x-1)*(y-x+1)*(y-x-1);                
 real intf = int2d(Th)(f);
 real mTh = int2d(Th)(1.);
real moyf =  intf/mTh;
cout << moyf << endl; 
 problem laplace(uh,vh) =                     
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) + 1e-8*uh*vh ) + int2d(Th)( (moyf-f)*vh ) ;                
laplace; 
  plot(uh,wait=1,ps="perio4.eps");
//  test all FEspace
verbosity=10;
mesh Th=square(5,5);
verbosity = 10;
cout << " P0 " << endl;
fespace Ph(Th,P0);
cout << " P1 " << endl;
fespace Vh(Th,P1);
cout << " P2 " << endl;
fespace Wh(Th,P2);
cout << " nb of degre of freedom           : " << Wh.ndof << endl;
cout << " nb of degre of freedom / ELEMENT : " << Wh.ndofK << endl;
//*  don't work to day in progresse
{
 int k= 2;
 int kdf= Wh.ndofK ;
cout << " df of element " << k << ":" ;
for (int i=0;i<kdf;i++)
  cout << Wh(k,i) << " ";
 cout << endl;
}
//int[int] IK=[1,2,4];
//cout << "Wh(IK) = " << Wh(IK) << endl;  
//*/
cout << " P1nc " << endl;
fespace Vnch(Th,P1nc);
Vnch u1nc=x+10*y;
cout << " Interpola P1nc : " << int2d(Th)(square(u1nc-(x+10*y))) << endl;

cout << " P2dc " << endl;
fespace Wdch(Th,P2dc);

cout << " P1dc " << endl;
fespace Vdch(Th,P1dc);
Vdch u1dc=x+10*y;
cout << " Interpola P1dc : " << int2d(Th)(square(u1dc-(x+10*y))) << endl;

Wh w=x*x*y,dxw=2*x*y;

Vdch vdc = dx(w);
Wdch wdc = dx(w)*x;
plot(vdc,dxw,wait=1);
plot(wdc);
Vnch vnc = x*x;
Vh vh = x*x;
Ph p = x*x;

{
func f=x*x+10*y*y+50*x*y;
cout << " P2b " << endl;
fespace Wh2b(Th,P2);
Wh2b vh=f;
cout << " ?? " << vh(0.1,0.4) << " == " << f(0.1,0.4) <<  " diff = " << vh(0.1,0.4) - f(0.1,0.4) <<endl;
assert( abs(vh(0.1,0.4) - f(0.1,0.4)) < 1e-12 );
}

{ // version 3.41 
mesh TTh=Wdch.Th;
plot(TTh,wait=1);
mesh Tw =w.Th; 
}
{// Version 3.58  
	Vh uu=x;
	Vh uuu=uu[]; 
	varf va(u,v) = int2d(Th)(v)+on(1,u=1);
	Vh vu = va(0,Vh,tgv=1);
	plot(vu, wait=1); 

}
/*
 * Incompressible Navier Stokes
 * with Taylor-Hood Finite element
 * Non linearity : Newton method
 * continuation on Reynols Number
 * Mesh adaptation
*/

// Parameters
real reymax = 1600;	// ok < 125000
real nu = 1./100.;
real dt = 0.1;
func BCu1 = 4*x*(1-x);
real epsr=1e-6;

// Mesh
mesh Th = square(8, 8);

// Fespace
fespace Xh(Th, P2);
Xh uu1, uu2;
Xh psi, phi;

fespace Mh(Th, P1);
fespace XXMh(Th, [P2, P2, P1]);
XXMh [u1, u2, p];
XXMh [v1, v2, q];
XXMh [up1, up2, pp];

// Macro
macro div(u1, u2) (dx(u1) + dy(u2)) //
macro grad(u1, u2) [dx(u1), dy(u2)] //
macro ugrad(u1, u2, v) (u1*dx(v) + u2*dy(v)) //
macro Ugrad(u1, u2, v1, v2) [ugrad(u1, u2, v1), ugrad(u1, u2, v2)] //

// Problem Stokes (with solve)
solve Stokes ([u1, u2, p], [v1, v2, q], solver=sparsesolver)
	= int2d(Th)(
		( dx(u1)*dx(v1) + dy(u1)*dy(v1)
		+ dx(u2)*dx(v2) + dy(u2)*dy(v2) )
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);

// Plot
uu1 = u1;
uu2 = u2;
plot(coef=0.2, cmm="[u1, u2] and p" ,p, [uu1, uu2], wait=1);

// Problem stream-lines (with solve)
solve streamlines (psi, phi)
	= int2d(Th)(
		  dx(psi)*dx(phi)
		+ dy(psi)*dy(phi)
	)
	+ int2d(Th)(
		- phi*(dy(u1) - dx(u2))
	)
	+ on(1, 2, 3, 4, psi=0);

// Plot
plot(psi, wait=1);

// Variatonal form definition Navier-Stokes
int i = 0;
real alpha = 1/dt;

varf vDNS ([u1, u2, p], [v1, v2, q])
	= int2d(Th)(
		+ nu * (
			  dx(u1)*dx(v1) + dy(u1)*dy(v1)
			+ dx(u2)*dx(v2) + dy(u2)*dy(v2)
		)
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
		+ Ugrad(u1, u2, up1, up2)'*[v1, v2]
		+ Ugrad(up1, up2, u1, u2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;

varf vNS ([u1, u2, p], [v1, v2, q])	// DF(u)u - F(u)
	= int2d(Th)(
		  Ugrad(up1, up2, up1, up2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;

for (real re = 100; re <= reymax; re *= 2) {
	real lerr = 0.1;
	nu = 1./re;

	if (re > 8000) lerr = 0.05;
	if (re > 10000) lerr = 0.01;
	for (int step = 0; step < 2; step++) {
		// Mesh adaptation & interpolation
		Th = adaptmesh(Th, [u1, u2], p, err=lerr, nbvx=100000, abserror=0, cutoff=0.01);
		[u1, u2, p] = [u1, u2, p];
		[up1, up2, pp] = [up1, up2, pp];

		// Newton
		for (i = 0; i <= 20; i++) {
			// Update
			up1[] = u1[];

			// Solve
			real[int] b = vNS(0, XXMh);	// build right hand side
			matrix Ans = vDNS(XXMh, XXMh);	// build matrix
			set(Ans, solver=sparsesolver);	// set solver
			u1[] = Ans^-1*b;	// solve linear system

			// Error
			b = u1[]-up1[];

			cout << "iter = "<< i << ", err = " << b.l2 << ", rey = " << re << endl;

			// Convergence criteria
			if (b.l2 < 1e-6) break;
		}
	}

	// Stream-lines
	uu1 = u1;
	uu2 = u2;
	streamlines;
	plot(coef=0.2, cmm="rey="+re+" [u1, u2] and p", psi, [uu1, uu2], wait=0, nbiso=20, ps="cavity-"+re+".ps");
}
/*
load "BEC" 
load "BernardiRaugel" 
load "BinaryIO" 
load "CircumCenter" 
load "ClosePoints" 
load "Curvature" 
load "DxWriter" 
load "Element_HCT" 
load "Element_Mixte" 
load "Element_Mixte3d" 
load "Element_P1bl" 
load "Element_P1dc1" 
load "Element_P1ncdc" 
load "Element_P2bulle3" 
load "Element_P2pnc" 
load "Element_P2pnc_3d" 
load "Element_P3" 
load "Element_P3dc" 
load "Element_P3nc" 
load "Element_P3pnc" 
load "Element_P3pnc_3d" 
load "Element_P4" 
load "Element_P4dc" 
load "Element_PkEdge" 
load "Element_QF" 
load "FreeFemQA" 
load "Helmholtz_FD" 
load "IncompleteCholesky" 
load "MUMPS" 
//load "MUMPS_seq" 
load "MatD-VFP0" 
load "MatrixMarket" 
load "MetricKuate" 
load "MetricPk" 
load "Morley" 
load "NewSolver" 
load "SaveHB" 
load "Schur-Complement" 
//load "SuperLu" 
load "UMFPACK64" 
load "VTK_writer" 
//load "VTK_writer_3d" 
load "addNewType" 
load "aniso" 
load "bfstream" 
load "biofunc" 
load "dfft" 
load "distance" 
load "exactpartition" 
load "ff-AiryBiry" 
load "ff-Ipopt" 
load "ff-NLopt" 
load "ff-cmaes" 
load "ff-mmap-semaphore" 
load "ffnewuoa" 
load "ffrandom" 
load "freeyams" 
load "funcTemplate" 
load "geophysics" 
load "gmsh" 
load "gsl" 
load "ilut" 
load "iohdf5" 
load "ioply" 
load "iovtk" 
load "isoline" 
load "lapack" 
load "lgbmo" 
load "mat_dervieux" 
load "mat_edgeP1" 
load "mat_psi" 
load "medit" 
load "meshtools" 
load "metis" 
load "mmg" 
load "mmg3d-v4.0" 
load "mshmet" 
load "myfunction" 
load "myfunction2" 
load "pcm2rnm" 
load "pipe" 
load "plotPDF" 
load "ppm2rnm" 
load "qf11to25" 
load "scotch" 
load "shell" 
load "splitedges" 
load "splitmesh12" 
load "splitmesh3" 
load "splitmesh4" 
load "splitmesh6" 
load "tetgen" 
load "vortextools" 
*/
ofstream table("theTables");
dumptable(table);

if (!exec("ls -al theTables")) cout << "execution ok " << endl;

real alpha=1;int Niter=50;

mesh TH;mesh[int] Th(2);int Dirichlet,Interface;
int[int] reg(2);
{
	int n=30;
	Dirichlet=1;Interface=2;
	border a0(t=0,1){x=t;y=0;label=Dirichlet;}
	border a1(t=1,2){x=t;y=0;label=Dirichlet;}
	border b1(t=0,1){x=2;y=t;label=Dirichlet;}
	border c1(t=2,1){x=t;y=1;label=Dirichlet;}
	border c0(t=1,0){x=t;y=1;label=Dirichlet;}
	border b0(t=1,0){x=0;y=t;label=Dirichlet;}
	border d(t=0,1){x=1;y=t;label=Interface;}
	plot(a0(n)+a1(n)+b1(n)+c1(n)+c0(n)+b0(n)+d(n));	
	TH=buildmesh(a0(n)+a1(n)+b1(n)+c1(n)+c0(n)+b0(n)+d(n));	

	reg(0)=TH(0.5,0.5).region;
	reg(1)=TH(1.5,0.5).region;

	for(int i=0;i<2;i++) Th[i]=trunc(TH,region==reg(i));
}

macro f 1 // Volumic flux

int i;
fespace Vh0(Th[0],P1),Vh1(Th[1],P1);
Vh0 u0=0;Vh1 u1=0;

macro grad(u) [dx(u),dy(u)] //

varf a(u,v)=int2d(Th[i])(grad(u)'*grad(v))+int1d(Th[i],Interface)(alpha*u*v)+on(Dirichlet,u=0);
varf b(u,v)=int2d(Th[i])(f*v)+on(Dirichlet,u=0);
varf du1dn(u,v)=-int2d(Th[1])(grad(u1)'*grad(v)-f*v)+int1d(Th[1],Interface)(alpha*u1*v)+on(Dirichlet,u=0);
varf du0dn(u,v)=-int2d(Th[0])(grad(u0)'*grad(v)-f*v)+int1d(Th[0],Interface)(alpha*u0*v)+on(Dirichlet,u=0);

matrix[int] I(2);
I[0]=interpolate(Vh1,Vh0);
I[1]=interpolate(Vh0,Vh1);

matrix[int] A(2); real[int][int] B(2);
i=0; A[0]=a(Vh0,Vh0); B[0].resize(Vh0.ndof); B[0]=b(0,Vh0);
i=1; A[1]=a(Vh1,Vh1); B[1].resize(Vh1.ndof); B[1]=b(0,Vh1);


for(int iter=0;iter<Niter;iter++)
{
 	// Solve on Th[0]
	{
		i=0;// for def of  b
		real[int] b0=B[0];
		real[int] Du1dn=du1dn(0,Vh1);
		real[int] Tdu1dn(Vh0.ndof); Tdu1dn=I[0]'*Du1dn;
		b0+=Tdu1dn;
		u0[]=A[0]^-1*b0;
	}
 	// Solve on Th[1]
	{
		i=1; // for def of  b
		real[int] b1=B[1];
		real[int] Du0dn=du0dn(0,Vh0);
		real[int] Tdu0dn(Vh1.ndof); Tdu0dn=I[1]'*Du0dn;
		b1+=Tdu0dn;
		u1[]=A[1]^-1*b1;
	}
	plot(u0,u1,cmm="iter="+iter);
}
// -Ddim=3   parametre or -D=2
int bar=4;
// valeur par defaut ..
IFMACRO(!dim)
macro dim 2//
ENDIFMACRO

IFMACRO(dim,2) 
macro intO int2d//
macro intG int1d//
macro Mesh mesh//
macro Boite(n) square(n,n)//
macro grad(u) [dx(u),dy(u)]//
macro Grad(u) [ grad(u#1), grad(u#2)]//
macro div(u) (dx(u#1)+dy(u#2))//
macro cnd(u) u#1,u#2//
macro ccd(u) u,u//
macro Vd(u) [u#1,u#2]//
macro myON1(l,u,v) on(l,u#1=0.,u#2=v)//
ENDIFMACRO
IFMACRO(dim,3) 
macro intO int3d//
macro intG int2d//
macro Mesh mesh3//
macro Boite(n) cube(n,n,n)//
macro grad(u) [dx(u),dy(u),dz(u)]//
macro Grad(u) [ grad(u#1), grad(u#2),grad(u#3)]//
macro div(u) (dx(u#1)+dy(u#2)+dz(u#3))//
macro cnd(u) u#1,u#2,u#3//
macro ccd(u) u,u,u//
macro Vd(u) [u#1,u#2,u#3]//
macro myON1(l,u,v) on(l,u#1=v,u#2=0.,u#3=0.)//
ENDIFMACRO

Mesh Th=Boite(10);
int[int] ll(4);
if(dim==2) ll=[1,1,2,1,3,2,4,1];
else ll=[1,1,2,1,3,1,4,1,5,1,6,2];

Th=change(Th,label=ll);

plot(Th);
fespace Vh(Th,[ccd(P2),P1]);
Vh [cnd(u),p], [cnd(v),q],[cnd(up),pp];

solve Stokes ([cnd(u),p], [cnd(v),q])
= intO(Th)( (Grad(u):Grad(v)) - div(u)*q - div(v)*p - 1e6*p*q  )
+ myON1(1,u,0.) + myON1(2,u,1.);

plot(p, wait=1);
int i, N=20;
mesh Th=square(N,N);
fespace RTh(Th,RT0);
fespace P0h(Th,P0);
fespace P1h(Th,P1);

RTh [Vx,Vy],[vx,vy];
P0h up,u,um;

real dt=0.125/N, pi=4*atan(1.0);
[Vx,Vy]=[0,0];
um= sin(pi*x)*sin(pi*y);
u=um;

problem prob(Vx,Vy,vx,vy,solver=Cholesky,init=i)
    = int2d(Th) (Vx*vx+Vy*vy) + int2d(Th)(up*(dx(vx)+dy(vy)))
//     + on(1,2,3,4,Vx=pi*cos(pi*x)*sin(pi*y)*cos(i*dt*pi*sqrt(2.))
//                 ,Vy=pi*sin(pi*x)*cos(pi*y)*cos(i*dt*pi*sqrt(2.)) )
;
for (i=0;i<20;i++)
 {
     up = 2*u-um+dt*dt*(dx(Vx)+dy(Vy));
     prob;
     um=u;
     u=up;
     cout<< int2d(Th)((u-sin(pi*x)*sin(pi*y)*cos(i*dt*pi*sqrt(2.)))^2)
     /int2d(Th)((sin(pi*x)*sin(pi*y)*cos(i*dt*pi*sqrt(2.)))^2)<< endl;
//     plot([Vx,Vy],wait=0, value=1);
 }
P1h w,W = 0;
problem prob1(W,w,solver=Cholesky,init=0)
    = int2d(Th) (W*w) + int2d(Th)(up*w);
    prob1;
    plot(W,wait=1,value=1);
assert(version>=4.7 || version >= 4.11);
//   Change empty mesh in meshL form version 4.5
//  warning missing  operator a(Vh,Lh) 

//  Mortar  (4 sub domain) 
//  with matrix -et Precon Conjugade Gradient --
//    Neuman -> Dirichlet . 
//  -------------------------------
func f=1+x+y;
real g=1; 
int withprecon=1; 
macro Grad(u) [ dx(u), dy(u) ] //
int nbsd=4;

macro Psd(U) U[0],U[1],U[2],U[3] //
int labext= nbsd+1;
real meshsize=0.025; 
real meshsizem=meshsize*1.5; 
bool noconforme=0;// conforme ok ..

// --- begin  meshes  building --------------
real[int] theta(nbsd+1),cost(nbsd),sint(nbsd);

for (int i=0;i<nbsd;i++)
 {
  real t=i*2*pi/nbsd;
  theta[i]= t;
  theta[i+1]= (i+1)*2*pi/nbsd;
  cost[i]=cos(t);
  sint[i]=sin(t);
 }


border gi(t=0,1;i){x=cost[i]*t;y=sint[i]*t;label=1;region=1;};// correct Bug  mai 2021 FH. region = 

border ei(tt=0,1;i){ real t = theta[i]+ tt*(theta[i+1]-theta[i]);
	 x=cos(t);y=sin(t);label=labext;};

 int[int]  Ng(nbsd), Ne(nbsd);
  Ne = 2*pi/nbsd/meshsize ;
  Ng = 1./meshsize ;

plot(gi(Ng)+ei(Ne) ,wait=1);

mesh Tha = buildmesh( gi(Ng)+ei(Ne) , splitpbedge=1);

int [int] regi(4);
for (int i=0;i<4;i++)
  {
    real tt = (theta[i]+theta[i+1])*0.5;
    regi[i]=Tha(0.5*cos(tt),0.5*sin(tt)).region;
  }

Ng = 1./meshsize;
cout << "mortar : " << endl;
meshL Thm=buildmeshL(gi(Ng));
Thm=trunc(Thm,1,split=4); //
meshL Thmm=Thm;
if(noconforme)
  { ; //  need a find mesh to integrate on Thm. 
  //  Thmm=trunc(Thm,split=4,1); // for fine integration
  //  Thmm=emptymesh(Thmm);
   Ng *= 4;
   Thmm=buildmeshL(gi(Ng));
  }
plot(Thm,wait=1);

verbosity=1;


mesh[int] Thsd(nbsd);

for(int sd=0;sd<nbsd;++sd)
 Thsd[sd]=trunc(Tha,region==regi[sd],split=1);// les sous domaines

if(noconforme)
{
for(int sd=0;sd<nbsd;++sd)
 Thsd[sd]=adaptmesh(Thsd[sd],meshsize*(1+sd*0.05),IsMetric=1,nbvx=100000,thetamax=60);// les sous domaines

}
plot(Thsd,Thm,dim=2,wait=1);   // axel: ok

fespace Lh(Thm,P0);// 
fespace RTh(Thm,[P0,P0]);
 RTh [Nmx,Nmy]; // ne marche pas car la normal 
// Warning now only the tangent is defined on meshL because le line is in R3 not in R2 generaly
varf  vNN([ux,uy],[nx,ny]) = int1d(Thm,1)(( -nx*Tl.y + ny*Tl.x)/lenEdge);  // axel: N 2D -> Nt 3D curve 
Nmx[]= vNN(0,RTh);

// les joint P0 sur le squelette 
// -----   \int [q] l + \int[p] m 
Lh  lh=0,rhsl=0;

mesh Thi=Thsd[0];

// remark: operator # is  the concatenation operator in macro 

//   cout << " Domaine " << i<< " --------" << endl;
// OK P1/P0 ;, PB P1/P1,  P1/P0Edge , FH..
fespace Vhi(Thi,P1);
fespace Ehi(Thi,P0);
matrix[int] Asd(nbsd),Csd(nbsd),PAsd(nbsd),PIsd(nbsd),PJsd(nbsd);
Vhi[int] usd(nbsd),vsd(nbsd),rhssd(nbsd), pusd(nbsd),bcsd(nbsd);
Ehi[int] epssd(nbsd);
   
real tgv=1e30;
for(int sd=0;sd<nbsd;++sd)
{
  Thi=Thsd[sd];
  usd[sd]=0;
  vsd[sd]=0;
   
  varf cci([l],[u]) = int1d(Thmm,1,qforder=3)(l*u*epssd[sd]);
  varf vepsi(u,v)= int1d(Thi,1,qforder=10)( (Nmx*N.x + Nmy*N.y)*v/lenEdge);    
  
  varf vLapMi([ui],[vi],tgv=tgv) =
         int2d(Thi)(  Grad(ui)'*Grad(vi)  )
      // + int1d(Thi,1,qfe=qf1pElump)(alpha*ui*vi)
    +  int2d(Thi) (f*vi)   +  on(labext,ui=g);  
    
  varf vPLapMi([ui],[vi],tgv=tgv) =
        int2d(Thi)(  Grad(ui)'*Grad(vi)  )
     // + int1d(Thi,1,qfe=qf1pElump)(alphap*ui*vi)
      + on(labext,1,ui=0);
   ;  

   varf  vrhsMi(ui,vi) =   on(labext,ui=g);

   epssd[sd][]= vepsi(0,Ehi);
   epssd[sd] = -real(epssd[sd] <-0.00001) + real(epssd[sd] >0.00001);
   
   Csd[sd]  = cci(Lh,Vhi);
   Asd[sd]  = vLapMi(Vhi,Vhi,solver=sparsesolver);
   PAsd[sd] = vPLapMi(Vhi,Vhi,solver=sparsesolver);
   matrix IVL=interpolate(Vhi,Lh,inside=1);
   //   v = IVL*l 
   varf vonext(u,v)=on(labext,u=1);
   varf von1(u,v)=on(1,u=1);
   real[int]  onext=vonext(0,Vhi);
   real[int]  on1=von1(0,Vhi);
   on1= on1 ? 1 : 0;
   on1 = onext ? 0 : on1; //  remove df of ext
   matrix I1(on1);//   matrix    tgv $i\in Gamma_1 \ Gamma_e $ , 0 otherwise
   
   PIsd[sd]=  I1*IVL;//  remove of line not on $Gamma_1 \ Gamma_e $
 
    // so PIsd[sd]*l  =  tgv * Interpole l on $Gamma_1 \ Gamma_e $
   I1.diag=on1;
   matrix AA=I1*Asd[sd];//  remove line not on lab 1 
   PJsd[sd]= IVL'*AA;
   
   
   rhssd[sd][]=vLapMi(0,Vhi);

}

plot(epssd,cmm="eps 0,1,2,3",wait=0,value=1);


lh[]=0;
varf  vDD(u,v) = int1d(Thm)(u*v*1e-10);  // axel: int2d -> int1d
varf  vML(u,v) = int1d(Thm)(u*v*1e-10)+int1d(Thm,1)(u*v);   // axel: int2d -> int1d
matrix ML=vML(Lh,Lh);




matrix DD=vDD(Lh,Lh);

matrix M=[ 
  [ Asd[0] ,0      ,0      ,0      ,Csd[0] ],
  [ 0      ,Asd[1] ,0      ,0      ,Csd[1] ],
  [ 0      ,0      ,Asd[2] ,0      ,Csd[2] ],
  [ 0      ,0      ,0      ,Asd[3] ,Csd[3] ],
  [ Csd[0]',Csd[1]',Csd[2]',Csd[3]',DD     ] 
 ];

real[int] xx(M.n);

real[int] bb =[rhssd[0][], rhssd[1][],rhssd[2][],rhssd[3][],rhsl[] ];
set(M,solver=sparsesolver);

xx = M^-1 * bb;

[usd[0][],usd[1][],usd[2][],usd[3][],lh[]] = xx; // dispatch the solution 

plot(usd,cmm="u1,u2,u3,u4",wait=1); 


int itera=0;

varf  vbc(u,v) =   int1d(Thm,labext)(v);
real[int] lbc(Lh.ndof),lbc0(Lh.ndof);
lbc=vbc(0,Lh);
lbc = lbc ? 0 : 1 ; 

func real[int] SkPb(real[int] &l)
{ 
   int verb=verbosity;   verbosity=0;   itera++;
   for(int sd=0;sd<nbsd;++sd)
    {
      Thi=Thsd[sd];  //  for initialisation of vsd with the correct size 
      vsd[sd][]  = rhssd[sd][];
      vsd[sd][] += Csd[sd]* l;
      usd[sd][]  = Asd[sd]^-1*vsd[sd][];

    }
    l=0;
   for(int sd=0;sd<nbsd;++sd)
     	l  += Csd[sd]'*usd[sd][];  
     	
    l= lbc .* l; 
    plot(usd,wait=0,cmm="CG iteration u");
   verbosity=verb; 
   return l ;
};

func real[int] PSkPb(real[int] &l)
{ 
  if(withprecon)
  {  	
   int verb=verbosity;   verbosity=0;   itera++;
   real[int] ll= ML^-1*l;
   ll= lbc .* ll; 
   ll *= tgv;
 
   for(int sd=0;sd<nbsd;++sd)
    {
      Thi=Thsd[sd];              
      pusd[sd][] = PAsd[sd]^-1*(vsd[sd][]= PIsd[sd]* ll);
    }
    ll=0;
   for(int sd=0;sd<nbsd;++sd)
     ll  += PJsd[sd]*pusd[sd][];  
    l = ML^-1*ll; 	
    l= lbc .* l; 
   verbosity=verb; 
  }
  return l ;
};


verbosity=100;
lh[]=0;
LinearCG(SkPb,lh[],eps=1.e-7,nbiter=100,precon=PSkPb);
verbosity=1; 

plot(usd,wait=1,cmm="CG");

// FFCS: for regression tests
real regtest;
{  
fespace Vha(Tha,P1);
Vha vah,uah;
solve vLapMM([uah],[vah]) =
       int2d(Tha)(  Grad(uah)'*Grad(vah) )
    -  int2d(Tha) (f*vah)
    +  on(labext,uah=g)
   ;
verbosity =3;
real errL2=0;
for(int sd=0;sd<nbsd;++sd)
  errL2 += int2d(Thsd[sd])( sqr(uah-usd[sd]));
  errL2 = sqrt(errL2);
plot(uah,usd,cmm="uah err="+errL2,wait=1); 
assert(errL2<1e-4); 
regtest=uah[]'*uah[];
}

//  cleanning version 07/2008  FH in Sevilla.
// VERSION 2024  avec FGMRES test ...  FH
int nerr =0; 
int debugJ =0; 
int debugdJ =0; 
real umax=0;
//load "fgmres"
{
 func  bool stop(int iter,real[int] u,real[int] g)	
{
  cout << " stop = " << iter << " " << u.linfty << " " << g.linfty << endl;
  return g.linfty < 1e-5 || iter > 15;;
}
  // minimisation of $J(u) = \frac12\sum (i+1) u_i^2 - b_i $	
  // work array 
  real[int] b(10),u(10); 
  complex[int] cb(10),cu(10); 
  
  func real J(real[int] & u)
    {
      real s=0;
      for (int i=0;i<u.n;i++)
	s +=(i+1)*u[i]*u[i]*0.5 - b[i]*u[i];
      if(debugJ) cout << "J ="<< s << " u =" <<  u[0] << " " << u[1] << "...\n" ;
      return s;
    }
    func complex cJ(complex[int] & u)
      {
        complex s=0;
        for (int i=0;i<u.n;i++)
  	s +=(i+1)*u[i]*u[i]*0.5 - b[i]*u[i];
        if(debugJ) cout << "J ="<< s << " u =" <<  u[0] << " " << u[1] << "...\n" ;
        return s;
      }

//  the grad of J (this	 is a affine version (the RHS is in  )
  func real[int] DJ(real[int] &u)
    { 
      for (int i=0;i<u.n;i++)
	u[i]=(i+1)*u[i];
      if(debugdJ) cout << "dJ0  ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
      u -= b; 
      if(debugdJ) cout << "dJ-b ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
      return u;  // return of global variable ok 
    };
    func complex[int] cDJ(complex[int] &u)
      { 
        for (int i=0;i<u.n;i++)
  	u[i]=(i+1)*u[i];
        if(debugdJ) cout << "dJ0  ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
        u -= cb; 
        if(debugdJ) cout << "dJ-b ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
        return u;  // return of global variable ok 
      };

// the grad of the bilinear part of J (the RHS in remove)
  func real[int] DJ0(real[int] &u)
    { 
      for (int i=0;i<u.n;i++)
	u[i]=(i+1)*u[i];
      if(debugdJ) cout << "dJ0 ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
      return u;  // return of global variable ok 
    };


  func real error(real[int] & u,real[int] & b)
   {
   real s=0;
     for (int i=0;i<u.n;i++)
	s += abs((i+1)*u[i] - b[i]);
   return s;    
   }
   func real error(complex[int] & u,complex[int] & b)
    {
    real s=0;
      for (int i=0;i<u.n;i++)
 	s += abs((i+1)*u[i] - b[i]);
    return s;    
    }
  func real[int] matId(real[int] &u) { return u;};
  func complex[int] cmatId(complex[int] &u) { return u;};
  int verb=5; // verbosity of algo ..
  b=1. ; u=0.; // set  right hand side and initial gest
  LinearCG(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "LinearGC (Affine) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  b=1; u=0; 
  LinearCG(DJ,u,eps=1.e-15,nbiter=20,precon=matId,verbosity=50,stop=stop);
  cout << "LinearGC (Affine with stop) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  b=1; u=0; // set  right hand side and initial gest
  LinearCG(DJ0,u,b,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "LinearGC (Linear) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  b=1; u=0; // set  right hand side and initial gest
  AffineGMRES(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb); // correct in version 3.11 
  cout << "LinearGMRES (Affine) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		


  b=1; u=0; // set  right hand side and initial gest
  AffineFGMRES(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb); // correct in version 3.11 
  cout << "LinearFGMRES (Affine) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  cb=1; cu=0; // set  right hand side and initial gest
  AffineFGMRES(cDJ,cu,eps=1.e-6,nbiter=20,verbosity=verb); // correct in version 3.11 
  cout << "complex LinearFGMRES (Affine) : " << " err=" << error(cu,cb) << endl;
  nerr += !(error(cu,cb) < 1e-5);
  if(nerr) cout << "    sol: "<< " cu =" <<  cu[0] << " " << cu[1] << " " << cu[2]  << "...\n" ;		

  b=1; u=0; // set  right hand side and initial gest
  LinearGMRES(DJ0,u,b,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "LinearGMRES (Linear) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		


  b=1; u=0; // set  right hand side and initial gest
  NLCG(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "NLCG: J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		


  // warning BFGS use a full matrix of size nxn (where n=u.n) 
  b=1; u=2; // set  right hand side and initial gest
  BFGS(J,DJ,u,eps=1.e-6,nbiter=20,nbiterline=20);
   cout << "BFGS: J(u) = " << J(u) << " err=" << error(u,b) << endl;
  assert(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		
 

  assert(nerr==0);
};
{ // ---  a real non linear test ---
mesh Th=square(10,10);  // mesh definition of $\Omega$
fespace Vh(Th,P1);      // finite element space
fespace Ph(Th,P0);      // make optimization

Vh b=1;  // to defined b 
// $ J(u) = 1/2\int_\Omega f(|\nabla u|^2) - \int\Omega  u b $
// $ f(u) = a*u + u-ln(1+u), \quad f'(u) = a+\frac{u}{1+u}, \quad f''(u) =  \frac{1}{(1+u)^2}$
real a=0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u);}
func real ddf(real u) { return 1/((1+u)*(1+u));}

// the functionnal J 

func real J(real[int] & u)
  {
    Vh w;w[]=u; 
    real r=int2d(Th)(0.5*f( dx(w)*dx(w) + dy(w)*dy(w) ) - b*w) ;
    cout << "J(u) =" << r << " " << u.min <<  " " << u.max << endl;
    return r;
  }
// -----------------------

Vh u=0; //  the current value of the solution
Ph alpha; // of store  $df(|\nabla u|^2)$
int iter=0;
alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // optimization 

func real[int] dJ(real[int] & u)
  {
    Vh w;w[]=u; 
    alpha=df( dx(w)*dx(w) + dy(w)*dy(w) ); // optimization 
    varf au(uh,vh) = int2d(Th)( alpha*( dx(w)*dx(vh) + dy(w)*dy(vh) ) - b*vh)
    + on(1,2,3,4,uh=0);
    u= au(0,Vh);  
    return u; // warning no return of local array  
  }

varf alap(uh,vh)=  
   int2d(Th)( alpha *( dx(uh)*dx(vh) + dy(uh)*dy(vh) ))   + on(1,2,3,4,uh=0);

varf amass(uh,vh)=  int2d(Th)( uh*vh)  + on(1,2,3,4,uh=0);

matrix Amass = amass(Vh,Vh,solver=CG);

matrix Alap=  alap(Vh,Vh,solver=Cholesky,factorize=3);   

func real[int] C(real[int] & u)
{
   real[int] w=u;
   u = Alap^-1*w;
   return u; // no return of local array  variable 
}
   int conv=0;
   real eps=1e-6; 
   for(int i=0;i<20;i++)
   {
     conv=NLCG(dJ,u[],nbiter=10,precon=C,veps=eps,verbosity=5); 

     if (conv) break; 
     alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // optimization 
     Alap = alap(Vh,Vh,solver=Cholesky,factorize=3);   
     cout << " restart with new preconditionner " << conv << " eps =" << eps << endl;
   }
   plot (u,wait=1,cmm="solution with NLCG");
   umax = u[].max; 

   Vh sss= df( dx(u)*dx(u) + dy(u)*dy(u) ) ;
   plot (sss,wait=0,fill=1,value=1);

// the  method of  Newton Ralphson to solve dJ(u)=0;
//  see Newton.edp example

}
assert(nerr==0); 
int err=0;
mesh Th=square(50,50,[3*x-1.5,3*y-1.5]);
func r = sqrt(x*x +y*y);
// wrong ...
real lc ;
verbosity=0;
lc = int1d(Th,levelset=r-1.)(1.) ; 
cout << " len of the level set = " <<  lc  << " =  2pi " << 2*pi ;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl; 
if( abs(lc-2*pi) > 1e-1) err++;
fespace Vh(Th,P1);
// test linear and bilinear ... 
varf vl(u,v) = int1d(Th,levelset=r-1.)(v) + int1d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh);

cout << " len of the level set (varf linear ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi ;
cout  << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;
if( abs(lc-2*pi) > 1e-1) err++; 
real[int]  one(Vh.ndof); 
one=1.;
matrix VV=vl(Vh,Vh); //  matrix with levelset
vv = VV*one;
cout << " len of the level set (varf bilinear same) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;; 
if( abs(lc-2*pi) > 1e-1) err++;

// FFCS regression test
real ffcsreg;

//  just for test a idea approximation of int of negative part of levelset 
//   to we just change the mesure of the element not the quadrature point 
{ // test new stuff for level set  ... 
    macro grad(u) [dx(u),dy(u)] //
    Vh u,v;
    solve Pxx(u,v) = int2d(Th) ( grad(u)'*grad(v)*1e-8 ) + int2d(Th, levelset= 1-r) ( grad(u)'*grad(v) ) + on(1,u=0) + int2d(Th, levelset= 1-r) ( 1*v);
    plot(u,wait=1);   
    varf vxx(u,v) =  int2d(Th, levelset= 1-r) ( u*v ) + int2d(Th, levelset= 1-r) ( 1*v);
  matrix XX=vxx(Vh,Vh);
  real[int] xx=vxx(0,Vh);
  real area1= int2d(Th, levelset= 1-r)(1.);
  cout << "  area1 = " << area1 << "  ~= " << Th.area - pi << endl;
  assert(abs(area1-(Th.area - pi)) < 0.1); 
  cout << " xx.sum = " << xx.sum << " == " << area1 <<endl;
  assert(abs(area1-xx.sum) < 1e-8); 
  
  real[int] yy(Vh.ndof); yy=1;
  xx= XX*yy;
  cout << " XX.sum = " << xx.sum << " == " << area1 << endl;
  assert(abs(area1-xx.sum) < 1e-8); 

  // FFCS regression tests
  ffcsreg=abs(area1-xx.sum);
}



if(1){// test on diff mesh  not wet implemented (FH  frev 2014)
mesh Th1=square(10,10,[3*x-1.5,3*y-1.5]);
mesh Th2=square(11,11,[3*x-1.5,3*y-1.5]);
fespace Vh1(Th1,P1);
fespace Vh2(Th2,P1);

varf vl(u,v) = int1d(Th,levelset=r-1.)(v) + int1d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh2);

cout << " len of the level set (varf linear diff    ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi ;
cout  << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;
if( abs(lc-2*pi) > 1e-1) err++; 
real[int]  one(Vh1.ndof); 
one=1.;
// sorry not implemented to day ... FH 
//verbosity=10000;
matrix VV=vl(Vh1,Vh2); // no build of matrix with levelset 
vv = VV*one;
cout << " len of the level set (varf bilinear diff ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;; 
if( abs(lc-2*pi) > 1e-1) err++;

}
cout << " Nb err " << err << endl;
assert(err==0);

real pi=4*atan(1);
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
mesh TH = buildmesh ( e(5*n) + e1(25*n) );
plot(th,TH,ps="schwarz-th.eps");
fespace vh(th,P1);
fespace VH(TH,P1);
vh u=0,v; VH U,V;
int i=0;

problem PB(U,V,init=i,solver=Cholesky) = 
    int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + int2d(TH)( -V) + on(inside,U = u)  +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(th)( -v) + on(inside ,u = U) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 10; i++) 
{   
   PB; 
   pb;
   //if (i==0) 
        plot(U,u,wait=true,ps="schwarz-u"+i+".eps");
};

plot(U,u,ps="schwarz-u.eps");
int i;
real [int] tab(10), tab1(10); // 2 array of 10 real 
complex [int] ctab(10), ctab1(10); // 2 array of 10 complex 
//string [int] stab(10);   pas code ... 


//  real [int] tab2; //  bug 
tab = 1;  //  set all the array to 1
tab[1]=2;
ctab = 1+2i;  //  set all the array to 1+2i
ctab[1]=2;
cout << tab[1] << " " << tab[9] << " size of tab = " << tab.n << endl;
cout << ctab[1] << " " << ctab[9] << " size of ctab = " << ctab.n << endl;

tab1=tab;
tab=tab+tab1;
tab=2*tab+tab1*5;
tab1=2*tab-tab1*5;
tab+=tab;
cout << tab << endl;
cout << tab[1] << " " << tab[9] <<  endl;

ctab1=ctab;
ctab=ctab+ctab1;
ctab=2*ctab+ctab1*5;
ctab1=2*ctab-ctab1*5;
ctab+=ctab;
cout << ctab << endl;
cout << ctab[1] << " " << ctab[9] <<  endl;


real [string] map; //  a dynamique array
 string[string] smap;
for (i=0;i<10;i=i+1)
  {
    tab[i] = i*i;
    cout << i << " " << tab[i] << "\n";
  };

map["1"]=2.0;
map[2]=3.0; //  2 is automaticaly cast to the string "2"

cout << " map[\"1\"] = " << map["1"] << " == 2.0 ; "<< endl;
cout << " map[2] = " << map[2] << " == 3.0 "<< endl;
assert( abs(map["1"]-2.0)<1.e-6);
assert(abs(map[2]-3.0)<1e-6);



real [int] tab2=[1,2,3,3.14];
int  [int] itab2=[1,2,3,5];

cout << tab2 << endl;
cout << itab2 << endl;
tab2.resize(10);
for (int i=4;i<10;i++) tab2[i]=i;
cout << "tab2 = " << tab2 << endl;
tab2 /= 2; // bug  before v2.0-3
cout << "tab2 = " << tab2 << endl;
tab2 *= 2;
cout << "tab2 = " << tab2 << endl;


real [int,int] mat(10,10),mmat(10,10);
mat=0;
for(int i=0;i<mat.n;i++)
  for(int j=0;j<mat.m;j++)
    mat(i,j)=i+100*(j+1);
mmat=mat;
cout << mmat << endl;
mat.resize(15,15);
for(int i=10;i<mat.n;i++)
  for(int j=0;j<mat.m;j++)
    mat(i,j)=i+100*(j+1);
for(int i=0;i<mat.n;i++)
  for(int j=10;j<mat.m;j++)
    mat(i,j)=i+100*(j+1);
cout << mat << endl; // wrong
//mat(0:9,0:9)=mmat;  todo 
//cout << mat << endl; // wrong

// array of mesh 
mesh[int] aTh(10);
aTh[1]= square(2,2);
plot(aTh[1]);

// add 1 sep 2005 FH 
real[int]  a(5),b(5),c(5),d(5);
a = 1;
b = 2;
c = 3;
a[2]=0;
d = ( a ? b : c ); // i = 0, n-1  d[i] = a[i] ? b[i] : c[i] , 
cout << d << endl;
cout << "==   2       2       3       2       2 \n";
d = (a ? 1 : 10);
cout << " (a ? 1 : 10) "<< d << endl;
d = (a ? b : -1);
cout << " (a ? b : -1 ) "<< d << endl;
d = (a ? -2 : c);
cout << " (a ? -2 : c) " <<  d << endl;
d =   1./d; 
cout << " 1/ d == (a ? -2 : c) " <<  d << endl;
d =   a/3.; 
cout << "a/3 ==  " <<  d << endl;

// Liste all array operator and method 
// ok in version 2.0-3 
// they exist in the 3 type of array
// real[int] , long[int], complex[int] 
// ---------------------------------
int N=5;
{
real[int] a(N),b(N),c(N);
a =1; 
 a(0:4:2) = 2;
a(3:4) = 4;
cout <<" a = " << a << endl;
b = a+ a;
cout <<" b = a+a : " << b << endl;
b += a;
cout <<" b += a : " << b << endl;
b += 2*a;
cout <<" b += 2*a : " << b << endl;
b /= 2;
cout <<" b /= 2 : " << b << endl;
b .*= a; // same b = b .* a 
cout << "b*=a; b =" << b << endl;
b ./= a; // same b = b ./ a 
cout << "b/=a; b =" << b << endl;
c = a+b;
cout << " c =a+b : c=" << c << endl;
c = 2*a+4*b;
cout << " c =2*a+4b : c= " << c << endl;

c = a+4*b;
cout << " c =a+4b : c= " << c << endl;
c = -a+4*b;
cout << " c =-a+4b : c= " << c << endl;
c = -a-4*b;
cout << " c =-a-4b : c= " << c << endl;
c = -a-b;
cout << " c =-a-b : c= " << c << endl;

c = a .* b; 
cout << " c =a.*b  : c= " << c << endl;
c = a ./ b; 
cout << " c =a./b  : c= " << c << endl;
c = 2 * b;
cout << " c =2*b   : c= " << c << endl;
c =  b*2 ;
cout << " c =b*2   : c= " << c << endl;

/*  this operator do not exist 
c =  b/2 ;
cout << " c =b/2   : c= " << c << endl;
*/

// ---- the  methods --
cout << " ||a||_1     = " <<  a.l1     << endl;
cout << " ||a||_2     = " <<  a.l2     << endl;
cout << " ||a||_infty = " <<  a.linfty << endl;
cout << " sum a_i     = " <<  a.sum    << endl;
cout << " max a_i     = " <<  a.max  << " a[  " << a.imax << " ] = " << a[a.imax]     << endl;
cout << " imax a_i     = " <<  a.imax  << " a[  " << a.imax << " ] = " << a[a.imax]     << endl;
cout << " min a_i     = " <<  a.min  << " a[  " << a.imin << " ] = " << a[a.imin]    << endl;
cout << " imin a_i     = " <<  a.imin  << " a[  " << a.imin << " ] = " << a[a.imin]    << endl;
cout << " a'*a        = " <<  (a'*a)   << endl;
cout << " a quantile 0.2 =  " <<  a.quantile(0.2) << endl;

// array mapping  after version 2.3
int[int] I=[2,3,4,-1,3];
b=c=-3; 
b= a(I); // for( i=0;i<b.n;i++) if(I[i] >=0)  b[i]=a[I[i]];
c(I)= a; // for( i=0;i<I.n;i++) if(I[i] >=0)  C(I[i])=a[i];
cout << " b = a(I) : " << b << "\n  c(I) = a " << c << endl;
c(I) += a;// for( i=0;i<I.n;i++) if(I[i] >=0)  C(I[i])+=a[i];
cout << " b = a(I) : " << b << "\n  c(I) = a " << c << endl;   


}
{
// bidimensionnal  array
  int N=3,M=4;

  real[int,int] A(N,M),RA(N,M);
  real[int]  b(N),c(M);
  b=[1,2,3];
  c=[4,5,6,7];

  complex[int,int]  C(N,M);
  complex[int]  cb=[1,2,3],cc=[10i,20i,30i,40i];


  b=[1,2,3];

  int [int] I=[2,0,1];
  int [int] J=[2,0,1,3];

  A=1; // set the all matrix
  A(2,:) = 4; //  the full line 2
  A(:,1) = 5; //  the full column 1
  A(0:N-1,2) = 2; // set the column 2
  A(1,0:2) = 3; // set the line 1 from 0 to 2

  cout << " A = " << A << endl;
  // outer product 
  C  =  cb*cc';
  C +=  3*cb*cc';
  C -=  5i*cb*cc';
  cout << " C = " << C << endl;
  // the way to transform a array to a sparce matrix
  matrix B;
  B = A; 
  B=A(I,J); // B(i,j)= A(I(i),J(j))
  B=A(I^-1,J^-1);  // B(I(i),J(j))= A(i,j)  

  A = 2.*b*c'; // outer product  
  cout << " A = " << A << endl;
  cout << " A(1,2) " << A(1,2)  << endl;
  B = b*c'; // outer product  B(i,j)  = b(i)*c(j) 
  B = b*c'; // outer product  B(i,j)  = b(i)*c(j) 
  B = (2*b*c')(I,J); //   outer product  B(i,j)  = b(I(i))*c(J(j)) 
  B = (3.*b*c')(I^-1,J^-1); // outer product  B(I(i),J(j))  = b(i)*c(j) 
  cout << "B = (3.*b*c')(I^-1,J^-1) =  " << B << endl;  
  cout << " b =" <<  b << endl;
  b = exp(b) ;
  cout << " exp(b) =" <<  b << endl;
  cb += complex(10.)*cc(0:2);
  cout << " cb =" <<  cb << endl;
  cb = exp(cb) ;
  cout << " exp(cb) =" <<  cb << endl;
  cout << " exp(cb).re =" <<  cb.re << endl;
  cout << " exp(cb).im =" <<  cb.im << endl;
  cb.im = 0.;
  cout << cb << endl;
  b += cb.re + cb.im;   //  do not work to do
  cout << " b = " << endl; 
  {ofstream FA("A.txt");
  FA << A << endl;
  }
  {ifstream FA("A.txt");
  FA >> RA ;
  cout << RA << endl; 
  RA -= A;
  cout << " RA =  00 == " << RA.linfty  << endl; 
  assert( RA.linfty < 1e-12);
  }
  //  Add april 2018
   	real[int] AV(A.n*A.m);
	for [i,j,aij: A ] AV[i+A.n*j]=aij;
	// test break .. 10/2024 !!!
	for [i,AVi:AV] if( i< 2) cout << i << " "<< AVi << endl; else {cout << i <<" break ???\n" ;break;}
  	int i,j,ii,jj;
  	ijmax(A,ii,jj);
  	i = A.imax;	j=  A.jmax;
  	cout << " max " << i << " " << j << " "<< AV.imax << " " << A.max << endl; 
  	assert( i+A.n*j== AV.imax );
  	assert( ii+A.n*jj == AV.imax );
  	ijmin(A,i,j);
  	ii = A.imin;	jj=  A.jmin;
  	cout << " min  " << i << " " << j << " "<< AV.imin << " " << A.min<< " == " << AV.min << endl; 
  	cout << " minn " << ii << " " << jj << " "<< AV.imin << " " << A.min<< " == " << AV.min << endl; 
  	assert( i+A.n*j == AV.imin  );
  	assert( ii+A.n*jj == AV.imin  );
}
{
// sort array : 
real[int] a=[3,5,7,9,0];
real[int] b(a);
int[int] p=[0,1,2,3,4];

b=a;
cout << " a =" <<a << endl;
sort(b,p);
cout << " b.sort=" <<  b << endl;
cout << " b = " << b << endl;
cout << " p =  " << p << endl;
b=a;
b(0:5:2).sort;
cout << b << endl; 
cout << b(0:5:2)  << endl; 
cout << " quantile(0.2)  = " <<  b.quantile(0.2) << endl; 
p[0] = 1000;
p[1] = 888;
cout << "before    p(1:3).sort  " << p  << endl; 
p(1:3).sort;
cout << "after   p(1:3).sort " << p  << endl; 
p.sort; // version 3.19 ##
cout << "after   p.sort " << p  << endl; 

macro AA [ [1,2],[3,4]] //
macro BB [ [1,2],[5,10]] //
 cout << AA[1][0] << " 3  " << endl;
 cout << trace( AA * BB' + AA - BB' ) <<endl;
}
//  version 3.2  mai 2009
//  like math lab. and scilab
{
int[int] tt(2:10); //  2,3,4,5,6,7,8,9,10  
int[int] t1(2:3:10); // 2,5,8,
cout << " tt(2:10)= " << tt << endl;
cout << " t1(2:3:10)= " << t1 << endl;
tt=1:2:5;
cout << " 1.:2:5 =>  " << tt << endl;
}

{
real[int] tt(2:10); //  2,3,4,5,6,7,8,9,10  
real[int] t1(2.:3:10.); // 2,5,8,
cout << " tt(2:10) = = " << tt << endl;
cout << " t1(2.:3:10.)= " << t1 << endl;
tt=1.:0.5:3.999;
cout << " 1.:0.5:3.999 =>  " << tt << endl;
}
{
complex[int] tt(2.+0i:10.+0i); //  2,3,4,5,6,7,8,9,10  
complex[int] t1(2.:3.:10.); // 2,5,8,
cout << " tt(2.+0i:10.+0i)= " << tt << endl;
cout << " t1(2.:3.:10.);= " << t1 << endl;
cout << " tt.re real part array   " << tt.re << endl ; 
 //  the real part array of the complex array \index{re}\index{array!re}
cout << " tt.im imag part array   " << tt.im << endl ; 
//  the imag part array of the complex array \index{im}\index{array!im}


}
{

real [int] tab(10), tab1(10); // 2 array of 10 real
//real [int] tab2;    //  bug array with no size
tab = 1.03;                //  set all the array to 1.03
tab[1]=2.15;
cout << tab[1] << " " << tab[9] << " size of tab = "
     << tab.n << " min: " << tab.min << "  max:" << tab.max
     << " sum : "   << tab.sum <<   endl; //
tab.resize(12); //  change the size of array tab
  // to 12 with preserving first value
tab(10:11)=3.14; //  set unset value
cout <<" resize tab: " <<  tab << endl;
real [string] tt;
tt["+"]=1.5;
cout<<tt["a"]<<"  "<<tt["+"]<<endl;
real[int]  a(5),b(5),c(5),d(5);
a = 1;
b = 2;
c = 3;
a[2]=0;
d = ( a ? b : c ); // for i = 0, n-1  : d[i] = a[i] ? b[i] : c[i] ,
cout << " d = ( a ? b : c )  is " << d << endl;
d = ( a ? 1 : c );// for i = 0, n-1: d[i] = a[i] ? 1 : c[i] ,   (v2.23-1)
d = ( a ? b : 0 );// for i = 0, n-1: d[i] = a[i] ? b[i] : 0 ,   (v2.23-1)
d = ( a ? 1 : 0 );// for i = 0, n-1: d[i] = a[i] ? 0 : 1 ,     \hfill(v2.23-1)
 tab.sort ; //  sort the array tab  (version 2.18) 
cout << " tab (after sort) "  << tab << endl;
int[int] ii(0:d.n-1); // set array ii to 0,1, ..., d.n-1
d=-1:-5; // set d to  -1,-2, .. -5
sort(d,ii); // sort array d and ii in parallele
cout << " d " << d << "\n ii = " << ii << endl;

}

//  version 3.8-1
for(int i=0;i<ARGV.n;++i)
  {
    cout << ARGV[i] << endl;
  }
// Array of FE.
{
mesh Th=square(2,2);
fespace Vh(Th,P1);// scalar 
fespace Wh(Th,[P1,P1]);// vector
Vh[int] vh(10);
Wh[int] [uh,wh](10); 
vh[2]=x;
[uh[2],wh[2]]=[y,x];
[uh[2],wh[2]]=[y,x]; // set 3rd value 
cout << wh.n << endl;
cout << vh.n <<endl;
vh.resize(20);
cout << vh.n <<endl;
}



{ // version 3.43-3  init of map ...
  cout << " new stuff " << endl; 
  int[string] a=["2",1,"12",4];
  string[string] b= ["-1",1,"13","qsdqdq"];
  cout << " a " << a  << endl;
   cout << " b " << b  << endl; 
// the new kind of loop: 
  for [i,v:a] cout << " a: " << i << " " << v << endl;

  real[int,int] t=[[1,2],[2,3],[3,4],[5,6]]; 
  cout << t << endl;
  cout << t(1:3,0:1)' << endl; 

}
{ // version 3.51-1
  for(real a=-1;a< 2; a+= 0.4)
  cout << projection(-0.1,1,a)<< endl; 
  cout << dist(3,4)<< " " << dist(1,2,3) << " = " << sqrt( 14.  ) << endl; 
}
{ // array of array
	
	real[int][int] a(10);

	for(int i=0; i< a.n; ++i)
	{
	  a[i].resize(10+i);
	  a[i]=1:10+i ;
	}
	cout << a[3] << endl; 
	
	real[int,int][int]  aa(5); //  array of matrix 
	for(int i=0; i< aa.n; ++i)
	{
	  aa[i].resize(10+i,2);
	  aa[i]= 10 ;
	  aa[i](2,1)=2;
	}
	

}
{//    version 4.4-1 
	int n=10; 
	real[int,int] a(10,10);
	int[int] I=[1,3,6];
	for [i,j,aij:a] aij = i + 10 *j; 

	cout << a << endl; 

	real[int] b(I.n);
	b= a(1,:)(I);
	cout << b << endl; 
	real[int] c= a(:,1)(I);
	cout << b << endl; 

	real[int] d = a.diag ; // 
	real[int] aa= a.asarray; //  view full mat as a arry 
	real[int] d1= a.asarray(1:n*n-1:n+1); // build 

	cout <<  " d =" << d <<endl; 
	cout <<  " aa =" << aa <<endl; 
	cout <<  " d1=" << d1  <<endl; // diag shifted to one
	// change the diag of a
	//cout << a(2:5,3:7) <<endl; 
	//cout << " diag " << a(2:5,3:7).diag << endl; // a piece of diag
	a(2:5,3:7).diag= 200;
	a.diag += 100;

	cout << a << endl; 

	assert( a(9,9) == 199 );
	assert( a(5,6) == 200 );
	a =eye(5);
	cout << a << endl;

	matrix A=eye(10);
	cout << A << endl; 
	A=eye(5);
	cout << A << endl; 
	d.rmeps(15.);// put to zero term abs < 15
	cout << d << endl;
		
}
{ // oct 2020 FH.. 
	// all equal value in int array ???
	int[int] XX=[1,2,6,1,1];
	int[int] I;
	findall(XX,10,I);// version 4.7.
	cout << I << endl;
	cout  << " max "<< I.max << " min  " << I.min << " sum " << I.sum << " " << I.n << endl;
	//assert(I.n==0);// attention I.sum bug before v 4.7.1
	verbosity=10; 
	findall(XX,1,I);
	cout << I << " " << I.sum << endl;
         assert(I.sum==0+3+4); //commemt   due  to bug on ubuntu ????? FH ...
	cout  << " max "<< I.max << " min  " << I.min << " sum " << I.sum << endl;
	

}
//  sparse matrix test  ---
// example of the new matrix feature in version 1.40
// -------------------------------------------------

// ALH - for regression test
real regtest;

for(int step=0; step<2; ++step) // make to time the test to find memoire leak ..
  { 
    mesh  TH = square(3,4);
    mesh  th = square(2,3);
    mesh  Th = square(4,4);


    fespace VH(TH,P1);
    fespace Vh(th,P1);
    fespace Wh(Th,P1);

    matrix B= interpolate(VH,Vh);  // build interpolation matrix Vh->Vh 
    matrix BB= interpolate(Wh,Vh);  // build interpolation matrix
    varf vA(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+ int1d(Th)(u*v); 
    matrix A=vA(Wh,Wh);



    Vh ml=0;
    varf vML(u,v) = int2d(th)(1*v);
    ml[]=vML(0,Vh); // build the P1 mass lump of P1
    cout << ml[] << endl;
    matrix ML(ml[]); // matrix diagonal
// check +=  version 3.xx
real sml=ml[].sum;
ml[]+=vML(0,Vh);
real sml2=ml[].sum;
cout << " ### " << sml2 << " " << sml*2 << endl;    
assert((sml*2-sml2) < 1e-10);
ml[]/=2.; 
    cout << "ML="<<ML << endl;
    cout << "B="<<B << endl;
    matrix BML=B*ML;
    matrix tB=B';        //'; transpose 
				//cout << "tB=" << tB << endl;
				matrix MLtB=ML'*B'; // 

    //cout << "BML="<<BML << endl;
    //cout << "MLtB=" << MLtB << endl;

    // WARNING if sparsesolver is not install
    // the sparsesolver solver is replace by LU 
    //  but LU need skyline matrix 
    if(HaveUMFPACK)
      set(A,solver=sparsesolver); // set a solver 
    else 
      set(A,solver=GMRES); // set a solver 
    VH uH=0;
    Vh uh=x+y;
    uH[]= B*uh[];
    plot(uH,wait=1);
    matrix BtA = BB'*A;//';
    matrix BtAB = BtA*BB;
    if(HaveUMFPACK)  
      set(BtAB,solver=sparsesolver);  
    else 
      set(BtAB,solver=GMRES);  
    Vh ff=1;
    Vh xx;
    cout << " ------ " << xx[].n << " = " << BtAB.n << "x" << BtAB.m << " " << ff[].n <<  endl;

    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    plot(xx, wait=1);

    // ALH - for regression test
    regtest=xx[]'*xx[]; //'

      {
	int N=10;
	real [int,int] A(N,N);
	real [int] a(N),b(N),c(N);
	int [int] II(N);
	int [int] JJ(N);
	int [int] III(N);
	int [int] JJJ(N);
	for (int i=0;i<N;i++)
	  {
	    II(i)=i*2;
	    III(i)=(i*1023)%N;
	    JJJ(i)=(i*7)%N;
	    JJ(i)=20-i;
	  }	
	A =0;
	for (int i=0;i<N;i++)
	  {
	    A(i,i)=1+i;
	    if(i+1 < N)    A(i,i+1)=-i;
	    a[i]=i;
	  }
	b=a(III);  //  b(i)=a(iii(i))
	c(III)=a;  //  c(III(i)) = a(i)
	cout << " III = " << III << endl;
	cout << " a(III)     " <<  b << endl;
	cout << " a(III^1) = " << c  << endl;
	for (int i=0;i<N;i++)
	  assert( int(c[int(b[i])]) == i);
  
	matrix sA=A;
	{
	  {
	    ofstream ff("A.matrix");
	    ff  << sA; 
	  }
	  matrix ssA;
	  {
	    ifstream ff("A.matrix");
	    ff >> ssA;
	    ssA = (1.)*sA+ (-1.)*ssA;
	    cout  << ssA << endl; 
	  }
	}
  
	matrix tAA=sA+sA';//';
	matrix ttAA=sA'+sA;//';
	// matrix tttAA=sA'-sA;
	// matrix ttAA=sA'-sA;
	A += 2*a*a';  //'//  produit tensoriel
	matrix A1=   A(II^-1,JJ^-1);   //  do A1(II(i),JJ(j)) = A(i),j) $
	matrix A2=   A(III,JJJ);   //  do   $A2(i,j) = A(III(i),JJJ(i)) $
	matrix sA1=   sA(II^-1,JJ^-1); //  do A1(II(i),JJ(i)) = A( 
	matrix sA2=   sA(III,JJJ);   //  do A = A 
  
	matrix A0 = (a*a')(II^-1,JJ^-1); //');
	matrix A3 = (a*a')(III,JJJ);//');
  
	cout << " ------------------- " << endl;
	// cout <<  " A  = " << A << endl;
	// cout <<  " A1 = " << A1 <<endl;
	cout << " 8,9 -> " <<II[8] << " " <<  JJ[9] <<" " << A(9,8)<< " " << A1(II[9],JJ[8]) << endl;
	assert(A(9,1) == 2*a[9]*a[1]);  
  
	for (int i9=0;i9<N;++i9)
	  for (int j9=0;j9<N;++j9)
	    {
	
	      if( abs(A(j9,i9))> 0.01) 
		assert(A1(II[j9],JJ[i9]) == A(j9,i9));
	      if( abs(A(III(j9),JJJ(i9))) > 0.01) 
		assert(A2(j9,i9) == A(III(j9),JJJ(i9) )) ;
	      //     cout << " i9,j9 -> " <<II[i9] << " " <<  JJ[j9] <<endl;
	      if( abs(a[i9]*a[j9])> 0.01) 
		assert(A0(II[i9],JJ[j9]) == a[i9]*a[j9]);
	      if( abs(a[III[i9]]*a[JJJ[j9]])> 0.01) 
		assert(A3(i9,j9) == a[III[i9]]*a[JJJ[j9]]);
	    }
	b=A*a;
	c=-9;
	cout << "xxxx\n"; 
	matrix sparseA=A;
	//cout << sparseA << endl;
	sparseA = 2*sparseA+sparseA;
	sparseA = 4*sparseA+sparseA*5; //  * 27
	matrix sparseB=sparseA+sparseA+sparseA-sparseA+2*sparseA; 
	//cout << sparseA << endl;
	//cout << sparseB << endl; // *81 
	cout << "sparseB = " << sparseB(0,0) << endl;
    cout << " trace = " << sparseB.trace << " == " <<  sparseA.trace*4 << endl; 
	cout << " -------- block matrix \n " << endl;
	matrix B = [ [sparseA, 0 , sparseA ], 
		     [ 0, sparseA , 0 ] ,
		     [0, 0, sparseB' ]];//']];
	matrix B2 = [ [sparseA], [sparseA]];
  
	assert( B2.n == sparseA.n*2);
	assert( B2.m == sparseA.m);
  
	matrix B1 = [ [sparseA, sparseA] ];
	assert( B1.m == sparseA.m*2); // FH. bug before version  2.11-4 (10/01/2007)
	assert( B1.n == sparseA.n);
  
  
	real[int] x([a,b,c]); //  construct the block vector x form a,b,c,
	//  where the size is  sum of size of a,b,c, 
	x=[a,b,c]; // set x to to the block vector (the vector x is  resize if it necessary
	cout << " abc =" << a[2] << " " << b[3] << " "<< c[4] << endl;
	cout << " xxx =" << x[2] << " " << x[3+N] << " "<< x[4+N*2] << endl;
	x = x*10;
	[a,b,c]=x; // set the block vector a,b,c  from concecutive part of  x;
	cout << " abc*10 == "  << a[2] << " " << b[3] << " "<< c[4] << endl;
  
  
	// remark  the size of sum of size must be equal to the size of x.  
	//cout << " B = " << B << endl; 
	cout << B(8,29) << " ===  " <<  sparseA(8,9) << endl;
	cout << B(28,27)
	<< " ===  " <<  sparseB(7,8) << endl;
	B(8,29)=100;  // change the value an existing coef 
	cout << " B(8,29) " <<  B(8,29) << endl;
	cout << " -------- block matrix \n " << endl;
      }

    //  build FE  matrice with differente meshes (here 3) 
    varf vM(u,v)=int1d(Th,qforder=1)(u*v);
    matrix MM=vM(Vh,VH);
    //cout << MM << endl;
    Vh unVh=0,wVh=0;
    VH unVH=0,wVH=0;
    unVh[]=1;
    unVH[]=1;
    wVh[] = MM' * unVH[] ; //'
      wVH[] = MM * unVh[] ; 

    //cout << "wWh : " << wVh[] << endl;
    //cout <<" wVH : " << wVH[] << endl;
    // array of matrix v2.4-1 
    cout << " array of matrix   \n" ;
    matrix[int]  aM(10);
    aM[0]= MM;
    aM[3]= MM;
    aM[9]= MM;
    // aM.resize(4);
    //  aM.resize(10);  bug on debian ? FH 

    //  add version 2.17 --- 
    {
      real[int] coef([1,2,3,5,6]);
      int[int]  lg(  [1,3,6,9,100]);
      int[int]  cl(  [1,4,9,0,0]);
  
      // a diagonal matrix
      matrix A=[coef];
      cout << " A = " << A << endl;
      // a raw matrix  
      matrix B=[lg,cl,coef];
      cout << " B = " << B << endl;
      [lg,cl,coef] = A; 
      cout<< " lg    : "  << lg << endl;
      cout << " cl   : " << cl << endl;
      cout << " coef = "<< coef << endl;
  
    }

    // version 3.1-1
	MM.CSR; 
    cout << " MM (format CSR or Morse)   "<< MM << endl;
    MM.resize(10,100);
    cout << " MM format COO " << MM << endl;

    {  //  test renumbering of sub mesh ..
      func Pk=P2;
      int[int] n2ok(1); 
      mesh ThC = trunc(Th,x < 0.5,new2old=n2ok);
      fespace VFh(Th,Pk);
      fespace VCh(ThC,Pk);
      verbosity= 1; 
      int[int] n2o=restrict(VCh,VFh,n2ok);
      cout << " n2o " << n2o << endl;
  
    }
  }
  
  { // verification v 4.3-2 F. H
	  matrix A = [[1,2],[3,4]],B;
	  matrix D2 = -(A-( (-1.5)*A- (2.2)*A));
	  real a00= -(1.-( (-1.5)*1.- (2.2)*1.));
	  //  -1 ---1.5 ---2.2
	  cout << D2 << endl; 
	  cout << a00 <<endl ;
	  assert( abs(D2(0,0)-a00 ) < 1e-10);  
	  B=A;
	  B+= A;// ???
	  B+= 2*A;
	  cout << B << endl;
	  assert( abs(B(0,0)-4 ) < 1e-10);  
	  cout << A << endl;
	  B -= 2*A - 3*A;// 
	  cout << B << endl;
	  assert( abs(B(0,0)-5) < 1e-10);  
  
  }
  {  // version 4.3-2-b F.H. (31 july 2017)
	  real[int] diag=[1,2,3,4,6,7,9,10];
	  int n = diag.n; 
	  
	  matrix A(n,n);
	  A.diag = diag;
	  cout << " A " << A << endl;
	  A.coef =0; // put all coef to zero 
	  cout << " A " << A << endl;
	  assert( A.l2 ==0);
	  A.diag = diag;
	  A.clear; 
	  cout << " A " << A << endl;
	  assert(A.nnz==0); 
  }
  { // add Oct 2019 version 4.4-1
  matrix A=eye(10);
  cout << A << endl; 
  A=eye(5);
  cout << A << endl; 
}
{  // version 4.13  sep. 2023 FH..
	// get structure of sparse matrix int [int][int] array ..
	// usefull to find some cnnectity
	// here:  for each vertex i, gives the list of  vertex in a same element. 
	mesh Th=square(3,3);
	fespace Vh(Th,P1);
	varf va(u,v)= int2d(Th)(u*v);
	matrix A = va(Vh,Vh);
	int [int][int] a=A;// array of array : Warning sort in  CSR  on A 
	int [int][int] at=A';// array of array:   Warning sort in  CSC  on A 

	for (int i=0; i< a.n; ++i)
	  cout << i << " " << a[i]  << endl;
        // here array at and array a are equal !
}
// Example of number manipulation

real x = 3.14, y;
int i, j;
complex c;
cout << "x = " << x << endl;

x = 1; y = 2;
x = y;

i = 0; j = 1;

cout << "--- Integer and real numbers ---" << endl;
cout << 1 + 3 << " " << 1/3 << "\n";
cout << 10 ^10 << "\n";
cout << 10 ^-10 << "\n";
cout << -10^-2 + 5 << " == 4.99\n";
cout << 10^-2 + 5 << " == 5.01\n";

cout << "--- Complex numbers ---" << endl;
cout << 10 - 10i << endl;

cout.scientific << "--- Scientific notation ---\n";
int prec = cout.precision(12);
cout << "-1^(1/3) = " << (-1+0i)^(1./3.) << " (precision=12)\n";
cout.precision(prec);
cout.fixed;
cout.showpos << "--- Fixed and showpos ---\n";
cout << "-1^(1/3) = " << (-1+0i)^(1./3.) << " (precision=" << prec << ")\n";
cout.noshowpos << "--- noshowpos ---\n";
cout << "8^(1/3)= " << (8)^(1./3.) << endl;
cout << "sqrt(-1) = " << sqrt(-1+0i) << endl;
complex a = 10 + 1i;
cout.default << "--- Default ---\n";
cout << a << endl;
cout << "real(a) = " << real(a) << ", conj(a) = " << conj(a)
	<< ", arg(a) = " << arg(a) << endl;

cout << "++i =" << ++i ;
cout << "i = " << i << endl;
cout << "i++ = "<< i++ << endl;
cout << "i = " << i << endl;
cout << "--- String concatenation ---" << endl;
string str, str1;
str = "abc+";
str1 = "+abcddddd+";
str = str + str1;
str = str + 2 ;
cout << "str = " << str << " == abc++abcddddd+2;\n";

{
	real x=0;
	for (int i = 0; i < 10; i++)
		x += i*i;
	cout << "x= " << x << endl;
	// example of if arithmetic expression
	real a = x == 0 ? x : -1;
	real b = x != 0 ? x : -1;
	cout << "a = " << a << ", b = " << b << endl;
	string ss = "\z\a\b\f\\--\\";
	cout << "\"" << ss << "\"" << endl;
}

// Add basic operation on R3 version 4.10.1 feb. 2022 
// to speed up compuatution 
R3 A(1.,2.,3.);
R3 B(3.,1.,0.);
R3 AB(A,B); // bipoint affine construction ..
R3 C = A^B; // cross product ..
R3 AB1 = A.*B ; //  product by componant by componant
R3 AB2 = A./B ; //  div by componant by componant
R3 Q= A+3*B+C-B;
cout << "det= " << det(A,B,C) << " == " << (A^B)'*C << endl; 
cout << Q.x << " " << Q.y << " "<< Q. z << endl; 
Q.x =1;
P=Q;// Current pojnt 
cout << P.x << " " << P.y << " "<< P. z << endl; 
cout <<"P=" <<  P << " det " << det(A,B,C) << endl;
cout << "R3" << R3(1,3,6) << " R3(A,) =" << R3(A,B) << endl; 
cout << C.l2 << " " << C.norm << " " << C.linfty  << " " << C <<  " dot product:  " << C'*C <<  endl;
real[int] E=A; // def array from R3*
real[int] F2=A+A; // def array from R3
R3 F3=E; // def R3 from array
F3=E; // set R3 from array 
F3+=E;
R3 O(0,0,0),E1(1,0,0),E2(0,1,0),E3(0,0,1); 
cout << " solidangle " << solidangle(O,E1,E2,E3) << " == " << pi/2 << endl;
cout << A'*R3(1,1,1) << endl; 
cout << R3(1,2,3).norm << " == " << sqrt(14.) << endl; 

mesh Th=square(4,4);
mesh Th4=square(2,2,[x*0.5,y*0.5]);
plot(Th,Th4,ps="ThTh4.eps",wait=1);
fespace Vh(Th,P1);
fespace Vh4(Th4,P1);
fespace Wh(Th,P0);
fespace Wh4(Th4,P0);

// remark in previous version (before v1.44)
// the name of interpolate function is interplotematrix

matrix IV= interpolate(Vh,Vh4); //  here the function is 
// exended by continuity

cout << " IV Vh<-Vh4 " << IV << endl;
Vh v;          Vh4 v4=x*y;
v=v4;           real[int]   vv= IV*v4[];
// here   v[]  == vv    =>  
real[int]  diff= vv - v[]; 
cout << " || v - vv || = " <<  diff.linfty << endl;
assert( diff.linfty<= 1e-6); // 

matrix IV0= interpolate(Vh,Vh4,inside=0);//  here the function is 
// exended by zero

cout << " IV Vh<-Vh4 (inside=1)  " << IV0 << endl;

matrix IVt0= interpolate(Vh,Vh4,inside=1,t=1);
cout << " IV Vh<-Vh4^t (inside=1)  " << IVt0 << endl;

matrix IV4t0= interpolate(Vh4,Vh);
cout << " IV Vh4<-Vh^t  " << IV4t0 << endl;

matrix IW4= interpolate(Wh4,Wh);
cout << " IV Wh4<-Wh  " << IW4  << endl;

matrix IW4V= interpolate(Wh4,Vh);
cout << " IV Wh4<-Vh  " << IW4  << endl;



fespace V4h(Th4,[P1,P1,P1,P1]);
fespace V3h(Th,[P1,P1,P1]);
int[int] u2vc=[1,3,-1];// -1 => put zero on the componante ;
matrix IV34= interpolate(V3h,V4h,inside=0,U2Vc=u2vc);//  here the function is 
V4h [a1,a2,a3,a4]=[1,2,3,4];
V3h [b1,b2,b3]=[10,20,30];
b1[]=IV34*a1[];

cout << "b1 = " << b1(.25,.25) << " == " << 2 << endl;
cout << "b2 = " << b2(.25,.25) << " == " << 4 <<endl;
cout << "b3 = " << b3(.25,.25) << " == " << 0 <<endl;
// Build interplation matrix a_ij at points (xx[j],yy[j]) j = 0, 1 :
//  $a_ij = d_op(w^i_c (xx[j],yy[j]))$ where $w_i$ is the basic function.  
real[int] xx=[.3,.4],yy=[.1,.4];
int c=0,dop=0; //  component and d operator 
matrix Ixx= interpolate(Vh,xx,yy,op=dop,composante=c);
cout << Ixx << endl;
Vh ww;
real[int] dd=[1,2]; 
ww[]= Ixx*dd;
plot(ww,wait=1);
mesh Th=square(10,10);
fespace Vh(Th,P1); 

macro grad(u) [dx(u),dy(u)]//
varf va(u,v) = int2d(Th) ( u*v+grad(u)'*grad(v)-10*dy(v)*(u))+ int2d(Th)(v*x)+on(1,2,3,4,u=0);
varf vat(u,v) = int2d(Th) ( u*v+grad(u)'*grad(v)-10*(v)*dy(u))+ int2d(Th)(v*x)+on(1,2,3,4,u=0);



matrix A=va(Vh,Vh,solver=sparsesolver);
matrix At=vat(Vh,Vh,solver=sparsesolver);
real[int] b = va(0,Vh);
set(A,solver=sparsesolver);

Vh u,ut;

u[]=A'^-1*b;
ut[]=At^-1*b;
plot(u,ut,wait=1);

ut[]-=u[];
real err = ut[].linfty ;
cout << " err = " << err << endl; 
assert(err < 1e-6); 

mesh Th=square(2,2);
plot(Th,wait=1,ps="square-0.eps");
Th= adaptmesh(Th,1./30.,IsMetric=1,nbvx=10000);// \index{mesh!uniforme}
plot(Th,wait=1,ps="square-1.eps");
Th= adaptmesh(Th,1./30.,IsMetric=1,nbvx=10000);//  more the one time du to
Th= adaptmesh(Th,1./30.,IsMetric=1,nbvx=10000);//  adaptation  bound \texttt{maxsubdiv=}
plot(Th,wait=1,ps="square-2.eps");


// variationnal inequality 
// --------------------------
//  Probleme:
//  $ - \Delta u = f , \quad u=gd \on \Gamma, \quad u < g $
//  algo of   Primal-Dual Active set strategy as a semi smoth Newton Method
//   HinterMuller , K. Ito, K. Kunisch 
//  to appeared in SIAM Option
// Thank to O. Pironneau 
// --------------------------
// F. Hecht april 2005
//  -----------------------
 mesh Th=square(20,20);
 real eps=1e-5;
 fespace Vh(Th,P1);     // P1 FE space
 int n = Vh.ndof; // number of Degree of freedom
 Vh uh,uhp;              // solution and previous one
 Vh Ik; //  to def the set where the containt is reached. 
 real[int] rhs(n); // to store the right and side of the equation 
 real c=10;  // the parameter of the algoritme
 func f=1;         //  right hand side function 
 func fd=0;         // Dirichlet   boundary condition function
 Vh g=0.05;
// array to store   
real[int] Aii(n),Aiin(n); // store the diagonal of the matrix




 real tgv = 1e30; // a hude value of exact penalisation of boundary condition
//  the variatonnal form of the problem:
 varf a(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=fd) ;                      //  boundary condition form



// two version of the problem  
matrix A=a(Vh,Vh,tgv=tgv,solver=CG);
matrix AA=a(Vh,Vh);

//  the mass Matrix construction: 
varf vM(uh,vh) = int2d(Th)(uh*vh);
matrix M=vM(Vh,Vh); // to do a fast computing of $L^2$ norm : sqrt( u'*(w=M*u)) 
Aii=A.diag; // get the diagonal of the matrix 

rhs = a(0,Vh,tgv=tgv);
Ik =0;
uhp=0;
Vh lambda=0;
for(int iter=0;iter<100;++iter)
{
  real[int] b(n) ; b=rhs;  //  get a copy of the Right hand side 
  real[int] Ak(n); //  the complementary of Ik ( !Ik = (Ik-1))
  // Today  the operator Ik- 1. is not implement so we do:
  Ak= 1.; Ak  -= Ik[];  // build Ak  = ! Ik 
  //  adding new locking  condition on b and on the diagonal if (Ik ==1 )
  b = Ik[] .* g[];      b *= tgv;     b  -=  Ak .* rhs;
  Aiin = Ik[] *  tgv;      Aiin  +=  Ak  .* Aii;  //set  Aii= tgv  $ i \in Ik $
  A.diag = Aiin; //  set the matrix diagonal 
  set(A,solver=CG); // important to change precondiconning  for solving
  uh[] = A^-1* b;   //  solve the problem with more locking condition
  lambda[] = AA * uh[]; //  compute the resudal ( fast with matrix)
  lambda[] += rhs; // remark rhs = $-\int f v $ 

  Ik = ( lambda + c*( g- uh)) < 0.;  //  set the new value 
  
   plot(Ik, wait=1,cmm=" lock set ",value=1 );
   plot(uh,wait=1,cmm="uh");
   // trick to compute  $L^2$ norm of the variation
      real[int] diff(n),Mdiff(n);  
      diff= uh[]-uhp[];    
      Mdiff = M*diff; 
      real err = sqrt(Mdiff'*diff);
  cout << "  || u_{k=1} - u_{k} ||_2 " << err << endl;
  if(err< eps) break; // stop test 
  uhp[]=uh[] ; // set the previous solution 
} 
savemesh(Th,"mm",[x,y,uh*10]);
  
  
  
// file thermal-fast.edp    same problem than thermal.edp

func fu0 =10+90*x/6;
func k = 1.8*(y<0.5)+0.2;
real ue = 25. , alpha=0.25, T=5, dt=0.1 ;

mesh Th=square(30,5,[6*x,y]);
fespace Vh(Th,P1);

Vh u0=fu0,u=u0;

varf vthermic (u,v)= int2d(Th)(u*v/dt + k*(dx(u) * dx(v) + dy(u) * dy(v)))  
  +  int1d(Th,1,3)(alpha*u*v)
  + on(2,4,u=1); 

varf vthermic0(u,v) =   int1d(Th,1,3)(alpha*ue*v);

varf vMass (u,v)= int2d(Th)( u*v/dt)  + on(2,4,u=1);

real tgv = 1e30;
matrix A= vthermic(Vh,Vh,tgv=tgv,solver=CG);
matrix M= vMass(Vh,Vh);


real[int]  b0  = vthermic0(0,Vh); // constant part of the RHS 
real[int]  bcn = vthermic(0,Vh); //  tgv on Dirichlet boundary  node  ( !=0 )
// we have for the node $i$ : $i\in \Gamma_{24}  \quad \Leftrightarrow \quad bcn[i] \ne 0 $ 
real[int]  bcl=tgv*u0[]; //  the Dirichlet boundary condition part 


ofstream ff("thermic.dat");
for(real t=0;t<T;t+=dt){
    real[int] b = b0 ; // for  the  RHS
    b += M*u[]; //  add the the time dependant part
    // to lock boundary 2,4 part:
    b = bcn ? bcl  : b ; // do $\forall i$:  b[i] =  bcn[i] ? bcl[i] : b[i]  ;      
    u[] = A^-1*b;    
    ff<< t << " " << u(3,0.5) <<endl;
    plot(u);
}
for(int i=0;i<20;i++) 
  cout<<dy(u)(6.0*i/20.0,0.9)<<endl;
plot(u,fill=true,wait=1,ps="thermic.eps");


verbosity=2;
mesh Thxy=triangulate("xyf");
plot(Thxy,wait=1,ps="Thxy.ps");
fespace Vhxy(Thxy,P1);
Vhxy fxy;

{ ifstream file("xyf");
   real xx,yy;
   for(int i=0;i<fxy.n;i++)
   file >> xx >>yy >> fxy[][i]; 
}

plot(fxy,wait=1,ps="xyf.ps");

// new way to bluid a mesh   version 2.23-2
Vhxy xx=x,yy=y;

mesh Th=triangulate(xx[],yy[]);
cout << " region = " <<  triangulate(xx[],yy[])[1].region  <<endl; 
cout << fxy[]'*fxy[] << endl;
plot(Th,wait=1); 
//  
//   calcul d'une zone saturation en eau (nappe phreatique)
//
verbosity=1;
real weak=1;
string com= "  avec du/dn ";
if(weak) com = " avec du/du = residu  ";
real L=10;        // longueur du domaine					   	
real Q=0.02;      // flux entrant
real K=0.5;	      //permeabilite	

real  erradap=0.001;
real  coef=1;



real h=2.1;	 // hauteur du bord gauche
real h1=0.35;    // hauteur du bord droite

//  maillage d'un tapeze
border a(t=0,L){x=t;y=0;};       // bas			   	
border b(t=0,h1){x=L;y=t;};      // droite
border f(t=L,0){x=t;y=t*(h1-h)/L+h;}; //  free surface
border d(t=h,0){x=0;y=t;};      // gauche

int n=10;
mesh Th=buildmesh (a(L*n)+b(h1*n)+f(sqrt(L^2+(h-h1)^2)*n)+d(h*n));

plot(Th,ps="dTh.eps");

fespace Vh(Th,P1);

int j=0,ii=0;

Vh p,v,pp,vv;

varf vPp(p,pp) = int2d(Th)( dx(p)*dx(pp)+dy(p)*dy(pp));
varf vonfree(p,pp) =on(f,p=1);
Vh onfree,wdpdn;
onfree[]=vonfree(0,Vh);
cout << "pb ?" << endl;
onfree[]/=onfree[].max; // sauce
cout << "pb non " << endl;
matrix A= vPp(Vh,Vh,solver=CG);


problem Pp(p,pp,solver=CG) = int2d(Th)( dx(p)*dx(pp)+dy(p)*dy(pp)) 
  + on(b,f,p=y) ;

//  --  imprecise (fort)
problem Pv(v,vv,solver=CG) = int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  on (a, v=0) + int1d(Th,f)(vv*((Q/K)*N.y- (dx(p)*N.x+dy(p)*N.y))); 
//   -- precise (faible)
problem Pw(v,vv,solver=CG) = int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  on (a, v=0) + int1d(Th,f)(vv*((Q/K)*N.y)) + wdpdn[]; 
  

real errv=1;
verbosity=1;
while(errv>1e-6)
{
  j++;       
  Pp;
  if (weak) {   wdpdn[] = A*p[]; wdpdn[] = wdpdn[].*onfree[];   wdpdn[] = -wdpdn[];
             Pw;}
  else Pv;
  errv=int1d(Th,f)(v*v);
  plot(Th,p,v ,cmm=com+"   iter = "+j+ "  errv =" +errv,wait=0);
  
//  if (j%10==0)
//    Th=adaptmesh(Th,p,err=erradap ) ;
  real coef=1;
  real mintcc = checkmovemesh(Th,[x,y])/5.; 
  real mint = checkmovemesh(Th,[x,y-v*coef]); 
  
  if (mint<mintcc ||  j%10==0) {  
    Th=adaptmesh(Th,p,err=erradap ) ;
    
     mintcc = checkmovemesh(Th,[x,y])/5.;     
     wdpdn=0; 	
     onfree=0;
  }
  
  while (1) 
  {  	    
    real mint = checkmovemesh(Th,[x,y-v*coef]); 
    
    if (mint>mintcc) break;
    
    cout << " min |T]  " << mint << endl;    
    coef /= 1.5;
  }
  
  Th=movemesh(Th,[x,y-coef*v]); // calcul de la deformation 
  A= vPp(Vh,Vh,solver=CG);	
  onfree[]=vonfree(0,Vh);onfree[]/=onfree[].max; // sauce
  cout << "\n\n"<<j <<"------------ errv = " << errv << "\n\n";

}
//plot(Th,wiat=1,ps="d_Thf.eps",cmm=com);
plot(p,wait=1,ps="d_u.eps",cmm=com);
// Beam under it own weight

// Parameters
real E = 21.5;
real sigma = 0.29;
real gravity = -0.05;

// Mesh
int bottombeam = 2;
border a(t=2, 0){x=0; y=t ;label=1;}	// left beam
border b(t=0, 10){x=t; y=0 ;label=bottombeam;}	// bottom of beam
border c(t=0, 2){x=10; y=t ;label=1;}	// rigth beam
border d(t=0, 10){x=10-t; y=2; label=3;}	// top beam
mesh th = buildmesh(b(20) + c(5) + d(20) + a(5));

// Fespace
fespace Vh(th, [P1, P1]);
Vh [uu, vv], [w, s];

// Macro
real sqrt2 = sqrt(2.);
macro epsilon(u1, u2) [dx(u1), dy(u2), (dy(u1) + dx(u2))/sqrt2] // EOM
macro div(u, v) (dx(u) + dy(v)) // EOM

// Problem (with solve)
real mu = E/(2*(1 + sigma));
real lambda = E*sigma/((1 + sigma)*(1 - 2*sigma));
cout << "Lambda = " << lambda << endl;
cout << "Mu = " << mu << endl;
cout << "Gravity = " << gravity << endl;
solve Elasticity ([uu, vv], [w, s], solver=sparsesolver)
	= int2d(th)(
		  lambda*div(w, s)*div(uu, vv)
		+ 2.*mu*(epsilon(w, s)' * epsilon(uu, vv))
	)
	- int2d(th)(gravity*s)
	+ on(1, uu=0, vv=0)
	;
cout << "Max displacement = " << uu[].linfty << endl;

// Plot
plot([uu, vv], wait=1);
plot([uu, vv], wait=1, bb=[[-0.5, 2.5], [2.5, -0.5]]);

// Move mesh
mesh th1 = movemesh(th, [x+uu, y+vv]);
plot(th1, wait=1);

mesh Th1=square(10,10);
mesh Th2=square(20,10,[x+1,y]);
verbosity=3;
int[int] r1=[2,18],  r2=[4,0];
savemesh(Th1,"meshTh1_av.mesh");
Th1=change(Th1,refe=r1);
savemesh(Th1,"meshTh1_ap.mesh");
Th2=change(Th2,refe=r2);
mesh Th=Th1+Th2;

cout << " nb ref = " << int1d(Th1,1,3,4)(1./lenEdge)+int1d(Th2,1,2,3)(1./lenEdge) 
     << " == " << int1d(Th,1,2,3,4)(1./lenEdge) <<" == " << ((10+20)+10)*2 << endl; 
plot(Th,wait=1);
fespace Vh(Th,P1);
macro Grad(u) [dx(u),dy(u)]//
Vh u,v;
solve P(u,v)=int2d(Th)(Grad(u)'*Grad(v))-int2d(Th)(v)+on(1,3,u=0);
plot(u,wait=1);
mesh[int] TT(2);
TT[0]=Th1;
TT[1]=Th2;
Th=gluemesh([Th1,Th2],eps=0); //  no glue 

// Th=gluemesh(Th1+Th2,eps=0); //  no glue 
// Th=gluemesh(TT,eps=0); //  no glue 
 
solve PP(u,v)=int2d(Th)(Grad(u)'*Grad(v))-int2d(Th)(v)+on(1,3,u=0);
// FFCS: for regression tests
real regtest;

{
// ---------------
real R=50.*sqrt(2.); //  theta = 
//un quart du paraboloide
border t1(t=0,R) {x=t;y=0;    label=1;}
border t2(t=0,R) {x=(R-t);y=t;label=2;}
border t3(t=R,0) {x=0;y=t;    label=3;}
int nn=3;
mesh Th= buildmesh(t1(5*nn)+t2(5*sqrt(2.)*nn)+t3(5*nn));  
plot(Th,wait=0);

 mesh Th4;

mesh th1=movemesh(Th,[x,-y]);
mesh th2=movemesh(Th,[-x,-y]);
mesh th3=movemesh(Th,[-x,y]);
plot(Th,th1,th2,th3,wait=1);
 Th4=Th+th1+th2+th3;

plot(Th4,wait=1);
Th=Th4;
regtest=Th.nv;
}
/*
   solving   Laplace operator with Neumann boundary condition
   with 1D lagrange multiplier
   
   The variational form is
   find (u,l) such that

   $\forall (v,m)   a(u,v) + b(u,m) + b(v,l) = L(v) $
   where $b(u,m) = int u*m dx$
   
*/
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
int n = Vh.ndof;
int n1 = n+1;

 Vh uh,vh;              // unknown and test function. 
 func f=1+x-y;                 //  right hand side function 
  
varf va(uh,vh) =                    //  definition of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
;
varf vL(uh,vh)=  int2d(Th)( f*vh )  ;
varf vb(uh,vh)= int2d(Th)(1.*vh);

matrix A=va(Vh,Vh);

real[int] b(n);
b = vL(0,Vh);

real[int]  B = vb(0,Vh); 	
// the block matrix

matrix AA = [ [ A ,  B ] ,
              [ B', 0 ] ] ;

real[int]  bb(n+1),xx(n+1),b1(1),l(1);
b1=0;
// build the block rhs 
bb = [ b, b1];
set(AA,solver=sparsesolver);
xx = AA^-1*bb; // solve the linear system

[uh[],l] = xx;  // set the value 
cout << " l = " << l(0) <<  " ,  b(u,1)  =" << B'*uh[]  << endl;  
plot(uh,wait=1);

//  signe of pressure is correct 
assert(version>1.18); 
real s0=clock();
mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;


varf bx(u1,q) = int2d(Th)( (dx(u1)*q)); 

varf by(u1,q) = int2d(Th)( (dy(u1)*q));

varf a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(1,2,4,u1=0)  +  on(3,u1=1) ;

Xh bc1; bc1[] = a(0,Xh);
Xh b;
                   
matrix A= a(Xh,Xh,solver=CG); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);
Xh bcx=1,bcy=0;

func real[int] divup(real[int] & pp)
{ 
  int verb=verbosity;
   verbosity=0;
   b[]  = Bx'*pp; b[] += bc1[] .*bcx[];
   u1[] = A^-1*b[];
   b[]  = By'*pp; b[] += bc1[] .*bcy[];
   u2[] = A^-1*b[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   return ppp[] ;
};
p=0;q=0;u1=0;v1=0;

        
LinearCG(divup,p[],q[],eps=1.e-6,nbiter=50);

divup(p[]);

plot([u1,u2],p,wait=1,value=true,coef=0.1);

//  test all FEspace
verbosity=2;
real a=real(1+1i);
verbosity=2;
mesh Th=square(5,5);
verbosity = 2;
cout << " P0 " << endl;
fespace Ph(Th,P0);
cout << " P1 " << endl;
fespace Vh(Th,P1);
fespace Wh(Th,RT0);
Vh<real> v=x,diff;
Vh<complex> w=x+1i*y;
cout << "w[][10] "  << " " << w[][10] << endl;
w=y+1i*y;
cout << "w[][10] " << w[][10] << " " << (w[][10])' << endl;
Wh<complex> [wx,wy]=[x+1i*y,y];
[wx,wy]=[x+1i*y,y];

func ue= (x*x+2.*y*y+(x*y*y+3.*x*x*y)*1i);
func uexx = 2.+6.i*y;
func ueyy = 4.+2.i*x;

func f= (-uexx-(2i+1)*ueyy);
func g= ue;
Vh<complex> uh,vh;
 problem laplace(uh,vh,solver=LU,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th,optimize=1)( dx(uh)*dx(vh) + (2i+1)*dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,optimize=1)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form
//verbosity=102;
  laplace; // solve the problem plot(uh); // to see the result
  real err = int2d(Th)(norm(uh-ue));
  cout << " -- err = " << err << endl;
  assert(err<0.01);
//  cout << " -- uh = " << uh[] << endl;
  cout << " uh(0.5,0.5) = " << uh(0.5,0.5) << " ~  " << ue(0.5,0.5) << endl;
  Vh vr=real(uh(x,y));
  Vh vi=imag(uh(x,y));
  vr = real(uh);
  vi = imag(uh);
  Vh ver = real(ue);
  Vh vei = imag(ue);

 // for (int i=0;i<vi[].n;i++)
 // vi[][i] = imag(uh[][i]);

// now no complex plot 
  plot(vr,ver,ps="Lr.eps",cmm="real",value=true,wait=1);
  plot(vi,vei,ps="Li.eps",cmm="imag",value=true,wait=1);

// simple movemesh example
mesh Th=square(10,10);
fespace Vh(Th,P1); 
real t=0;
// ---
//  problem is how to build data without interpolation
//  so the data u is moving with the mesh hse you can see in the plot
// ---
Vh u=y;
for (int i=0;i<4;i++)
{ 
 t=i*0.1;
 Vh f= x*t;
 real minarea=checkmovemesh(Th,[x,y+f]);
 if (minarea >0 ) //  the movemesh will be ok
   Th=movemesh(Th,[x,y+f]);
 cout << " Min area  " << minarea << endl;
//  u=(Vh,u[]);  // the new syntaxe  FH
 Vh tmp;     // =u[],  sorry no init of FEspace function with array. 
 tmp[]=u[];  //save the value  
 u=0;        // to change the FEspace and mesh  associated to u
 u[]=tmp[];  // set le value of the array without no mesh update 
 plot(Th,u,wait=1);
};
//  remark, in this programme we have no solution with link to a previous mesh
// so all the previoux are delete in memory
//   -------- 
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh,u;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0.;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=GMRES,tgv=1e5) =                    //  definion of  the problem 
  - int2d(Th)( -dx(uh)*dx(vh) - dy(uh)*dy(vh) ) //  bilinear form
  - int1d(Th,1)( -uh*vh) 
  - int1d(Th,1)(  vh)
  - int2d(Th)( f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplacep(uh,vh,solver=CG,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

  
  laplace; // solve the problem plot(uh); // to see the result
  u=uh;
  laplacep; // solve the problem plot(uh); // to see the result
  
  plot(uh,u,value=true);
  u[] -= uh[];
  cout << "Diff min = "<< u[].min << " max=" << u[].max << endl ;
//  -----  
// the convolution of fonction:  int(Sh) ( fh(x-y) * phih(y) dy ),
// for regularisation 
load "Element_P3"
real eps =  0.02;// support of the  function phih ...
func f = x >0 ; //y*x*x+y*y*y+h*tanh(val*(sin(5.0*y)-2.0*x));

meshL S1= segment(1);
meshL S10= segment(100);
fespace V1H(S1,P3HL);// P3 hermite .. function C1.. ???
V1H [rho,drho]=[1-x,0];//  fonction axi sur [0,1] 
meshL Lh=segment(100);
fespace VLh(Lh,P1);
VLh xh=x,rhoh=rho;
// a trick to plot 1d function as arry .. 
plot([xh[],rhoh[]],wait=1,cmm=" the rho function ");

func r=dist(x,y);

border csupport(t=0,2*pi){ x=eps*cos(t);y=eps*sin(t);}
mesh Sh=buildmesh(csupport(20));
fespace Wh(Sh,P1);
Wh rr=min(r/eps,1.);// 
real beta2h=1; 
Wh phih= beta2h*rho(rr);// Ok version 5/10/2023. 
cout << " int int2d(Sh)(phih) "<<int2d(Sh)(phih)<< " == " << 1 << endl;
beta2h= 1./ int2d(Sh)(phih) ; // to a mass == 1 
phih[] *= beta2h; 
cout << " int int2d(Sh)(phih) "<<int2d(Sh)(phih)<< " == " << 1 << endl;
plot(Sh,phih,wait=1,value=1,cmm="phih");

cout << " int phih =  " << int2d(Sh)(phih) << " ----------- " << endl; 
mesh Th=square(50,50,[x-0.5,y-0.5]);//buildmesh(cercle(20));

fespace Ph(Th,P0);
fespace Vh(Th,P1);
Ph fh=f;
plot(fh,fill=1,wait=0); //

// the convolution fonction // int fh(x-y) * phih(y) dy 

func real  conv(real a,real b) {  return int2d(Sh)( fh(a-x,b-y)* phih); }


   fh =f;
   Vh  fhc = conv(x,y); // do the interpolation of the convolution fonction (expencive)
   plot(Th,fhc,wait=1);





// Schwarz without overlapping (Shur complement Neumann -> Dirichet)  
//  with matrix ---
//  ------------
verbosity=2;
real cpu=clock();

macro laplacien(u,v) (dx(u)*dx(v)+dy(u)*dy(u)) //

// --- beging  meshes  building --------------
int nbsd=4;
int labext= nbsd+1;
real[int] theta(nbsd+1),cost(nbsd),sint(nbsd);

for (int i=0;i<nbsd;i++)
 {
  real t=i*2*pi/nbsd;
  theta[i]= t;
  theta[i+1]= (i+1)*2*pi/nbsd;
  cost[i]=cos(t);
  sint[i]=sin(t);
 }


border g1(t=0,1){x=cost[0]*t;y=sint[0]*t;label=1;};
border g2(t=0,1){x=cost[1]*t;y=sint[1]*t;label=2;};
border g3(t=0,1){x=cost[2]*t;y=sint[2]*t;label=3;};
border g4(t=0,1){x=cost[3]*t;y=sint[3]*t;label=4;};

border e12(t=theta[0],theta[1]){x=cos(t);y=sin(t);label=labext;};
border e23(t=theta[1],theta[2]){x=cos(t);y=sin(t);label=labext;};
border e34(t=theta[2],theta[3]){x=cos(t);y=sin(t);label=labext;};
border e41(t=theta[3],theta[4]){x=cos(t);y=sin(t);label=labext;};

 int Ng = 10;
 int Ne = 10;

plot(g1(Ng)+g2(Ng)+g3(Ng)+g4(Ng) + e12(Ne) + e23(Ne)+ e34(Ne) + e41(Ne) ,wait=1);

mesh Thf = buildmesh( g1(Ng)+g2(Ng)+g3(Ng)+g4(Ng) + e12(Ne) + e23(Ne)+ e34(Ne) + e41(Ne) );
fespace Phf(Thf,P0);
fespace Vhf(Thf,P1);
Phf reg=region;
int rr1 = 0; 
int rr2 = 1;
int rr3 = 2; 
int rr4 = 3;

func rreg1 = reg==rr1;
func rreg2 = reg==rr2;
func rreg3 = reg==rr3;
func rreg4 = reg==rr4;

Vhf reg1=rreg1, reg2=rreg2, reg3=rreg3, reg4=rreg4;

int[int] ssd(Thf.nt);
for (int i=0;i<Thf.nt;i++)
 ssd[i]=reg[][i];

mesh The = emptymesh(Thf,ssd);
plot(Thf,wait=1);
plot(The,wait=1);

fespace Phe(The,P0); //

Phe rege=reg;
plot(rege,fill=1,wait=1);
fespace Whe(The,P1dc); // espace des multilicateur de Lagrange
fespace Mhe(The,P1); // espace des multilicateur de Lagrange
Whe trace;
Mhe lambda; 
Mhe intern; //  1 if the vertex in internal and 0 if on the real boundary 

intern=  (square(x)+square(y))  < 0.999; 

//   - end of  meshes building  . 
mesh[int] aTh(nbsd);
for (int i=0;i<nbsd;i++)
  aTh[i]=trunc(Thf,region==i);

int i=0;

fespace Xh1(aTh[0],P1);
Xh1 u1,v1,dnu1;

fespace Xh2(aTh[1],P1);
Xh2 u2,v2,dnu2;

fespace Xh3(aTh[2],P1);
Xh3 u3,v3,dnu3;

fespace Xh4(aTh[3],P1);
Xh4 u4,v4,dnu4;

matrix I1=interpolate(Xh1,Mhe); // build interpolation matrix  Mhe -> Xh1
matrix I2=interpolate(Xh2,Mhe); // build interpolation matrix  Mhe -> Xh2
matrix I3=interpolate(Xh3,Mhe); // build interpolation matrix  Mhe -> Xh2
matrix I4=interpolate(Xh4,Mhe); // build interpolation matrix  Mhe -> Xh3

int nm = Mhe.ndof;
real [int]  l1(nm),l2(nm),l3(nm),l4(nm);

func f = (x+1)*(y-2);
varf vgamma(u,v) = on(1,2,3,4,u=1);
Mhe  gamma;
gamma[] = vgamma(0,Mhe,tgv=1);
plot(gamma,wait=1,cmm="gamma",value=1);
varf vM(u,v) =  int1d(The)( u*v) ;
matrix M = vM(Mhe,Mhe,solver=sparsesolver) ;
 
// debut macro par ssd 
macro Pb(A,B,a,P,Th,u1,v1,Xh)
   cout << " -- PB -- " << endl;
  varf a(u1,v1) =   int2d(Th)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  - int2d(Th)( f*v1) ;
problem P(u1,v1,init=i,solver=Cholesky) = 
  int2d(Th)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  - int2d(Th)( f*v1) 
  + on(labext,u1= 0 ) 
  + on(1,2,3,4,u1=lambda)
  ;

matrix A = a(Xh,Xh,solver=GMRES) ;
real[int] B(Xh.ndof);
B=a(0,Xh);

// Fin macro ssd -------


Pb(A1,b1,va1,Pb1,aTh[0],u1,v1,Xh1);
Pb(A2,b2,va2,Pb2,aTh[1],u2,v2,Xh2);
Pb(A3,b3,va3,Pb3,aTh[2],u3,v3,Xh3);
Pb(A4,b4,va4,Pb4,aTh[3],u4,v4,Xh4);


func real[int] BoundaryProblem(real[int] &l)
{
  int vv = verbosity;
  verbosity=0; 
  lambda[]=l;
  Pb1;  dnu1[]= A1*u1[];dnu1[]+=b1;  l1= I1'*dnu1[];
  Pb2;  dnu2[]= A2*u2[];dnu2[]+=b2;  l2= I2'*dnu2[];
  Pb3;  dnu3[]= A3*u3[];dnu3[]+=b3;  l3= I3'*dnu3[];
  Pb4;  dnu4[]= A4*u4[];dnu4[]+=b4;  l4= I4'*dnu4[];
  l1 += l2;
  l1 += l3;
  l1 += l4;
  l1 = l1.* intern[]; 
  cout << " residu = " <<  l1.max << " " << l1.min << endl;
  lambda[]=M*l1;
  plot(lambda,wait=1,cmm="lamdba");
  lambda[]=lambda[].* intern[];
  i++;
  verbosity=vv; 
  return lambda[] ;
};

lambda=0;

Mhe p=0;

verbosity=100;
LinearCG(BoundaryProblem,p[],eps=1.e-6,nbiter=100);
BoundaryProblem(p[]);
plot(u1,u2,u3,u4,wait=1,cmm="u1,u2,u3,u4");
// Parameters
real nu = 1./100.;
real dt = 0.1;

// Mesh
mesh Th = square(8, 8);

// Fespace
fespace Xh(Th, P2);
Xh u1, v1;
Xh u2, v2;
Xh up1, up2;
Xh psi, phi;
fespace Mh(Th, P1);
Mh p, q;

// Problem Stokes (with solve)
real epsr = 1e-8;
solve Stokes ([u1, u2, p], [v1, v2, q])
	= int2d(Th)(
		( dx(u1)*dx(v1) + dy(u1)*dy(v1)
		+ dx(u2)*dx(v2) + dy(u2)*dy(v2) )
		- p*q*epsr
		+ p*dx(v1) + p*dy(v2)
		+ dx(u1)*q + dy(u2)*q
	)
	+ on(3, u1=1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0)
	;

// Plot
plot(coef=0.2, cmm="[u1, u2] and p", p, [u1, u2], ArrowSize=0.5, wait=1);

// Problem stream-lines (with solve)
solve streamlines (psi, phi)
	= int2d(Th)(
		  dx(psi)*dx(phi)
		+ dy(psi)*dy(phi)
	)
	+ int2d(Th)(
		- phi*(dy(u1) - dx(u2))
	)
	+ on(1, 2, 3, 4, psi=0);

// Plot
plot(psi, wait=1);

// Problem Navier-Stokes
int i = 0;
real alpha = 1/dt;
problem NS ([u1, u2, p], [v1, v2, q], init=i)
	= int2d(Th)(
		  alpha*(u1*v1 + u2*v2)
		+ nu * (
			  dx(u1)*dx(v1) + dy(u1)*dy(v1)
			+ dx(u2)*dx(v2) + dy(u2)*dy(v2)
		)
		- p * q * epsr
		+ p*dx(v1) + p*dy(v2)
		+ dx(u1)*q + dy(u2)*q
	)
	+ int2d(Th)(
		- alpha*convect([up1, up2], -dt, up1)*v1
		- alpha*convect([up1, up2], -dt, up2)*v2
	)
	+ on(3, u1=1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0)
	;

for (i = 0; i <= 20; i++) {
	// Update
	up1 = u1;
	up2 = u2;

	// Solve
	NS;

	// Plot
	if (!(i % 10))
		plot(coef=0.2, cmm="[u1, u2] and p", p, [u1, u2]);
}
plot(coef=0.2, cmm="[u1, u2] and p", p, [u1, u2]);

// Re-calculate stream-lines
streamlines;
plot(psi, wait=1);
// This is the rotating hill problem with one turn
// First 1/2 turn is a convection equation and second 1/2 a convection diffusion

// Parameters
int kt = 6;
int kloop = 5;
int nbadap = 5;

bool inq = 0;
real tol = 0.05;
real tol2 = 1e-4;
real dt = 0.17, t = 0;	// time step
int i;

// Mesh
border a(t=0, 2*pi){x=cos(t); y=sin(t);}	// the unit circle
mesh th = buildmesh(a(70));	// triangulates the disk

// Fespace
fespace Vh(th, P1);
Vh u1 = y, u2 = -x;	// rotation velocity
Vh m11 = 0, m22 = 0, m12 = 0;	// to store the metric field
Vh vT;	// to save the initial in big loop
Vh vv, vo, vp;	// working Finite element function
Vh v;

// Functions
func rhill = sqrt((x-0.3)^2 + (y-0.3)^2);
func hill = 1 - tanh(30*(rhill - 0.2));

// Initialization
v = hill;
vp = 0;
plot(v);

// Mesh adaptation loop
for (int i = 0; i < nbadap; i++) {
	th = adaptmesh(th, v, err=tol, inquire=inq);
	v = hill;
	real errl2 = sqrt(int2d(th)(square(vp-v)));
	vp = vp - v;
	cout << "adaptation iteration =" << i << ", l2 error = " << errl2
		<< ", diff min = " << vp[].min << ", max = " << vp[].max << endl
		<< " --------------- " << endl;
	vp = v;
	if (errl2 < tol2) break;
}

// Plot
plot(th, wait=1);

// Initialization
vT[] = v[];

// Solve loop
real error = 0;
for (i = 0; i < 20/kt; i++) {
	real T = t;
	vp = 0;
	for (int k = 0; k < kloop; k++) {
		t = T;	// restart
		v = vT;	// interpolation
		m11 = 0; m22 = 0; m12 = 0;	// reset metric
		adaptmesh(th, v, err=tol, metric=[m11[], m12[], m22[]], nomeshgeneration= true );	// warning change the order in version 1.28

		cout << "m11 = " << m11[].min << " " << m11[].max << endl;
		cout << "m22 = " << m22[].min << " " << m22[].max << endl;
		cout << "m12 = " << m12[].min << " " << m12[].max << endl;

		for (int j = 0; j < kt; j++) {
			t = t+dt;
			vo[] = v[];
			v = convect([u1, u2], -dt, vo);	// convect v by u1,u2, dt seconds, results in f
			plot(v, cmm="convection: t=" + t + ", min=" + v[].min + ", max=" + v[].max, wait=1, dim=3);
			adaptmesh(th, v, err=tol, metric=[m11[], m12[], m22[]], nomeshgeneration= true);
		}
		th = adaptmesh(th, v, err=tol, metric=[m11[], m12[], m22[]]);
		vo = 0;
		plot(th, wait=1, cmm="k=" + k + ", t= " + t + " ,i= " + i);
		real errl2 = sqrt(int2d(th)(square(vp - v)));
		cout << "iteration " << k << ", err l2 = " << errl2 << " --------------- " << endl;
		vp = v;
		error = errl2;
		if (errl2 < tol2) break;
	}
	vT = v;
};

// Plot
plot(th, v, wait=1);
//   example using region keywork
// construct a mesh with 4 regions (sub-domains)
border a(t=0,1){x=t;y=0;};
border b(t=0,0.5){x=1;y=t;};
border c(t=0,0.5){x=1-t;y=0.5;};
border d(t=0.5,1){x=0.5;y=t;};
border e(t=0.5,1){x=1-t;y=1;};
border f(t=0,1){x=0;y=1-t;};
//  internal boundary 
border i1(t=0,0.5){x=t;y=1-t;};
border i2(t=0,0.5){x=t;y=t;};
border i3(t=0,0.5){x=1-t;y=t;};
   
mesh th = buildmesh (a(6) + b(4) + c(4) +d(4) + e(4) + 
    f(6)+i1(6)+i2(6)+i3(6));
fespace Ph(th,P0);
fespace Vh(th,P1);
Ph reg=region;
plot(reg,fill=1,wait=1,value=1,ps="region.eps");
int nupper=reg(0.4,0.9);
int nlower=reg(0.9,0.1);
cout << " nlower " <<  nlower << ", nupper = " << nupper<< endl;
//  defined the characteristics fonctions of upper and lower region
Ph nu=1+5*(region==nlower) + 10*(region==nupper);
if ( nu[].sum < 1) { cout << " Bug in region.edp (bad version try new one)"<< endl; exit(1);}
plot(nu,fill=1,wait=1,value=1,ps="region_nu.eps");
Vh u,v;
solve lap(u,v) =   int2d(th)( nu*(dx(u)*dx(v) +dy(u)*dy(v)))  + int2d(th)(-1*v) + on(a,b,c,d,e,f,u=0);
plot(u,value=1,ps="region_u.eps");

// schwarz1 without overlapping
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, 1){ x= 1-t; y = t;label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
mesh TH = buildmesh ( e(6*n) + e1(25*n) );
plot(th,TH,wait=1,ps="schwarz-no-th.eps");
fespace vh(th,P1);
fespace VH(TH,P1);
vh u=0,v; VH U,V;
vh lambda=0;
int i=0;

problem PB(U,V,init=i,solver=Cholesky) = 
    int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + int2d(TH)( -V) 
  + int1d(TH,inside)(lambda*V) +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(th)( -v) 
  + int1d(th,inside)(-lambda*v) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 20; i++) 
{   
   PB; 
   pb;
   lambda = lambda - (u-U)/2;
//  if (i==0)

    // FFCS: add 3d view
  plot(U,u,wait=true,ps="schwarz-no-u"+i+".eps",dim=3,fill=1);
};

plot(U,u,ps="schwarz-no-u.eps");
// bug  save - restore P2 
verbosity=3;
int nn=2;
mesh Th=square(nn,nn);
savemesh(Th,"Th.msh");
func f=x+y+0.1234567890e-5;
fespace Vh(Th,P2);
Vh u=f;
{ofstream f("u2.txt");
  f.precision; 
 cout << " f.precision() = " << f.precision() << endl;
 f.precision(12);
 cout << " f.precision() = " << f.precision() << endl;

f <<u[];
}
real regtest;//FFCS regression test value
{
mesh Th=readmesh("Th.msh"); // il y a un changement de numerotation des traingle ou??
// mesh Th("Th.msh"); // oK ..
//savemesh(Th,"Th1.msh");
fespace VVh(Th,P2);
VVh u=f,v,e;
ifstream f("u2.txt");
f >> v[] ;
e[] = u[] -v[];
cout << e[].max << " " << e[].min << endl;
plot(e,wait=1,value=1);
assert(e[].max-e[].min < 1e-6);
regtest=e[].max-e[].min;
}

int nn =10;// 10 coubre 

real[int][int] xx(nn);
real[int][int] yy(nn);
real[int][int] zz(nn);
real[int][int] vv(nn);

mesh Th=square(1,1);
fespace Vh(Th,P1);
Vh u=1;

for(int i=0; i<nn; ++i)
{
	int m = 100+i;
	real dm = 1./(m-1);
	xx[i].resize(m);
	yy[i].resize(m);
	zz[i].resize(m);
	vv[i].resize(m);
	real dd = i*pi/nn, cc = 0.5*(4.*nn+i)/(5.*nn);
	real  px =dd; 
	
   for(int j=0; j<m; ++j)
   {
	   
	   xx[i][j] = px;
	   x =  px*4*pi+dd;
	   px += dm; 
	   yy[i][j] = cc*sin(x);
	   zz[i][j] = cos(x)/10+x/10.;
	   vv[i][j] = x;
   }


}

plot([xx,yy],dim=2,cmm="2");
plot([xx,yy,zz],dim=3,cmm="3");
plot([xx,yy,zz,vv],dim=3,cmm="4");
meshL Th = segment(3);
real [int] vtgv = [ -30,-20,-10,-3,-2,-1,0, tgv]; 
real [int] vsym = [ 0,1]; 
varf va(u,v)= int1d(Th)(u*v*4*9.)+on(1,2,u=0);// mul by 12  to have integer coef ..
// label : 1 on first DoF O 
//         2 on last DoF 2 
// tgv :  -30  set column of Dof with label 1 or 2 to zero
// tgv :  -20  set row and column of Dof with label 1 or 2 to zero
// tgv :  -10  set row of Dof with label 1 or 2 to zero
// tgv :  -3   set column of Dof with label 1 or 2 to zero and set diagonal term to one
// tgv :  -2   set row and column of Dof with label 1 or 2 to zero and set diagonal term to one
// tgv :  -1   set row of Dof with label 1 or 2 to zero and set diagonal term to one
// tgv >=0     set diagonal term of Dof with label 1 or 2 to tgv value

fespace Vh(Th,P1);
int symj = 0; 
// for [j,symj:vsym]  buggus never get sym matrix .... FH..  
for [i,tgvi:vtgv]
{
	verbosity=9; 
	matrix A= va(Vh,Vh,tgv=tgvi,sym=symj,solver="GMRES");
	real[int,int] F(Vh.ndof,Vh.ndof); // to copy sparse matrix in full matrix ..
	F=0.;  
	for [i,j,aij:A]
	  F(i,j) = aij;
	cout << " sym= " << symj << " tgv =  " << tgvi << "  matrix= " << F << "\n\n\n";
}
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=GMRES,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  - int1d(Th,1)( vh)
  - int2d(Th)( f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="LaplaceP1.eps",value=true);
mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a paratrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  de  partiel derivatrive of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  // to store the periodic condition 

// the intial mesh
savemesh(Th,"sphere",[f1,f2,f3]);

real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,inquire=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
load "medit" 
//savemesh(Th,"sphere-a",[f1,f2,f3]);
plot(Th,wait=1);
meshS Th3= movemesh23(Th,transfo=[f1,f2,f3]);
plot(Th3,wait=1); 
medit("sphere-a",Th3);// bug un color of u ... FH 

//exec("ffmedit sphere-a");
//ff-mpirun -np 4 Helmholtz_circle_Neumann_all_direct.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Bemkernels
BemKernel SL("SL",k=k);
BemKernel DL("DL",k=k);
BemKernel TDL("TDL",k=k);
BemKernel HS("HS",k=k);
BemKernel CFIE=1i*k*DL+HS;
BemKernel CFIERHS=k*1i*SL+TDL;

// varf
varf vSL(u,v)=int1dx1d(Th)(Th)(BEM(SL,u,v)) ;  
varf vDL(u,v)=int1dx1d(Th)(Th)(BEM(DL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vTDL(u,v)=int1dx1d(Th)(Th)(BEM(TDL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vHS(u,v)=int1dx1d(Th)(Th)(BEM(HS,u,v)) ;  
varf vCFIE(u,v)=int1d(Th)(-1i*k*0.5*u*v)+int1dx1d(Th)(Th)(BEM(CFIE,u,v)) ;  
varf vCFIERHS(u,v)=int1dx1d(Th)(Th)(BEM(CFIERHS,u,v))-int1d(Th)(0.5*u*v) ;  


// hmat
HMatrix<complex> HSecondKindRHS     = vSL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HFirstKindRHS    = vTDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HSecondKind  = vDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HFirstKind = vHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HCFIE = vCFIE(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HCFIERHS = vCFIERHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);


if (mpirank == 0) cout << HFirstKind.infos << endl;
if (mpirank == 0) cout << HSecondKind.infos << endl;
if (mpirank == 0) cout << HFirstKindRHS.infos << endl;
if (mpirank == 0) cout << HSecondKindRHS.infos << endl;


// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind, gN;
gN=-(dxfinc*Tl.y-dyfinc*Tl.x);
bFirstKind[] = HFirstKindRHS*gN[];
bFirstKind[] *=-1; // because we cannot compute I/2-TDL, we computed TDL-I/2...
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = HSecondKindRHS*gN[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = HCFIERHS*gN[];
bCombined[]*=-1;
uCombined[] = HCFIE^-1*bCombined[];
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind1,vFirstKind2;
vFirstKind1[] = HSLPot*gN[];
vFirstKind2[] = HDLPot*uFirstKind[];
vFirstKind1[] += vFirstKind2[]+ vinc[];
UhOut vFirstKindabs = abs(vFirstKind1);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind1,vSecondKind2;
vSecondKind1[] = HSLPot*gN[];
vSecondKind2[] = HDLPot*uFirstKind[];
vSecondKind1[] += vSecondKind2[]+vinc[];
UhOut vSecondKindabs = abs(vSecondKind1);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*gN[];
vCombined2[] = HDLPot*uCombined[];
vCombined1[] += vCombined2[]+ vinc[];
UhOut vCombinedabs = abs(vCombined1);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
//ff-mpirun -np 4 Maxwell_cube_EFIE.edp -wg

// for the make check:
// NBPROC 4
// PARAM -frequency 2.e+8

load "bem"

include "getARGV.idp"

real c0= 299792458;
real f = getARGV("-frequency",6e+8);
real k = 2*pi*f/c0;
real lambda = c0/f;

cout << "lambda=" << lambda << endl;
// incident wave
real thetaI =  2*pi*0./360.;
real[int] dir=[cos(thetaI),0,sin(thetaI)];

// plane wave polarisation y
func fincx = 0;
func fincy = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));
func fincz = 0;

int nloc = 4./lambda;
mesh3 Th3 = cube(nloc,nloc,nloc,[x-0.5,y-0.5,z-0.5]);

meshS ThS = extract(Th3);

plot(ThS);

macro def(u)[u,u#2,u#3]//

fespace Uh(ThS,RT0S);
Uh<complex> def(u), def(b);

varf vM([u1,u2,u3],[v1,v2,v3]) = int2dx2d(ThS)(ThS)(BEM(BemKernel("MA_SL",k=k),[u1,u2,u3],[v1,v2,v3]));  
HMatrix<complex> H = vM(Uh,Uh,eta=10,eps=1e-3);

if (mpirank == 0) cout << H.infos << endl;
display(H);

varf vrhs(def(u),def(v)) = int2d(ThS)(def(v)'*[-fincx,-fincy,-fincz]);

b[] = vrhs(0,Uh);

// resolution of the courant J
u[] = H^-1*b[];

// computation of the potential to reconstruct E
nloc *= 20;
nloc -= nloc%8;
meshS ThOut = square3(nloc,nloc,[4*(x-0.5),4*(y-0.5),0]);
ThOut = trunc(ThOut, max(abs(x),abs(y)) > 0.5 + 4./nloc);

fespace UhOut(ThOut,[P1,P1,P1]);
 
varf vP([u1,u2,u3],[v1,v2,v3])=int2d(ThS)(POT(BemPotential("MA_SL",k=k),[u1,u2,u3],[v1,v2,v3])) ;
HMatrix<complex> B = vP(Uh,UhOut,eta=10,eps=1e-3);

if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> [Ex,Ey,Ez];

Ex[] = B*u[];

fespace UhOutP1(ThOut,P1);
UhOutP1 Etotalr = sqrt(real(Ex+fincx)^2+ real(Ey+fincy)^2 + real(Ez+fincz)^2);

plot(Etotalr, dim=2, fill=1, value=1, nbiso=20);
//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling-MUMPS-composite.edp -wg

// for the make check:
// NBPROC 4
// PARAM -nlenses 1 -Rout 5

/* example of wave guiding with gradient-index lenses */

load "bem"
load "MUMPS"

include "getARGV.idp"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int nlenses = getARGV("-nlenses",10); // number of lenses
int[int] nsl(nlenses);
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

// Fem mesh :
mesh Th = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l)+circle(nsl));

plot(Th, wait=1, dim=2, cmm="FEM mesh Th");

int[int] lab = [interface];
meshL ThL = extract(Th, label=lab); // BEM mesh
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL, wait=1, dim=2, cmm="BEM mesh ThL");

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);
reg = region;

func ind = reg == -1 ? 1 : 2./(1+((x-nsx[max(0.,reg-1)])^2+(y-nsy[max(0.,reg-1)])^2)); // gradient index in lenses

fespace Uh(Th,P1);
fespace UhL(ThL,P1);

macro Grad(u) [dx(u),dy(u)] // EOM

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (Frhs)
(  mass  -SL ) (ubem)   ( 0  ) */

Uh<complex> ufem,v1;
UhL<complex> ubem,v2;

// problem formulation ; the linear system is assembled in parallel and solved in a distributed way with MUMPS
problem pbLenses(<[ufem],[ubem]>,<[v1],[v2]>,solver=sparsesolver,master=-1) =
                                int2d(Th)(-ind*k^2*ufem*v1 + Grad(ufem)'*Grad(v1)) // F
                              + int1dx1d(ThL)(ThL)(BEM(BemKernel("TDL",k=k),ubem,v1)) + int1d(ThL)(0.5*ubem*v1) // TDL
                              + int1d(ThL)(ufem*v2)                        // mass
                              + int1dx1d(ThL)(ThL)(BEM(-1*BemKernel("SL",k=k),ubem,v2))  // -SL
                              - int2d(Th)(finc*v1) + on(waveguide,ufem=0); // RHS

pbLenses;

plot(ufem, fill=1, value=1, wait=1, dim=2, cmm="FEM solution");
plot(ubem, fill=1, value=1, wait=1, dim=2, cmm="BEM ansatz on ThL");

// output mesh for visualization
int np = 5;
real R = getARGV("-Rout",20.);
real rr = R;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R)+b2(np*rr)+b3(np*R)+b4(np*rr)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(UhL,UhOut);
if (mpirank == 0) cout << B.infos << endl;

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40, cmm="u");
//ff-mpirun -np 4 Helmholtz_circle_Dirichlet_all_indirect.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Hmatrix for formulation of first kind
BemKernel ker1("SL",k=k);
varf vk1(u,v)=int1dx1d(Th)(Th)(BEM(ker1,u,v)) ;  
HMatrix<complex> HFirstKind = vk1(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
if (mpirank == 0) cout << HFirstKind.infos << endl;
display(HFirstKind);

// Hmatrix for formulation of second kind
BemKernel ker2("DL",k=k);
varf vk2(u,v)=int1dx1d(Th)(Th)(BEM(ker2,u,v)) + int1d(Th)(0.5*u*v);  

HMatrix<complex> HSecondKind = vk2(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
if (mpirank == 0) cout << HSecondKind.infos << endl;
display(HSecondKind);

// Hmatrix for combined formulation
BemKernel ker5=-1i*k*ker1+ker2;
varf vk3(u,v)=int1dx1d(Th)(Th)(BEM(ker5,u,v)) + int1d(Th)(0.5*u*v); 

HMatrix<complex> HCombined = vk3(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HCombined.infos << endl;
display(HCombined);


// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind;
varf vmassFirstKind(u,v) = int1d(Th)(-(finc)*v);
bFirstKind[] = vmassFirstKind(0,Uh);
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = bFirstKind[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = bFirstKind[];
uCombined[] = HCombined^-1*bCombined[];
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind;
vFirstKind[] = HSLPot*uFirstKind[];
vFirstKind[] += vinc[];
UhOut vFirstKindabs = abs(vFirstKind);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind;
vSecondKind[] = HDLPot*uSecondKind[];
vSecondKind[] += vinc[];
UhOut vSecondKindabs = abs(vSecondKind);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*uCombined[];
vCombined2[] = HDLPot*uCombined[];
UhOut vCombinedabs = abs(-1i*k*vCombined1+vCombined2+vinc);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
/*
time convention exp(-iwt).
solving EFIE for Maxwell with a incoming plane wave.

The polarization is such that:
\vec{k} = ( 0, 0, -k_z)^t (the wave vector), E_{inc}  =( E_x, 0, 0)^t \quad \mathtt{and}  \quad  H_{inc}=( 0, H_y, 0)^t

mpirun -np 2 ../../src/mpi/FreeFem++-mpi Maxwell_EFIE_sphere.edp -wg -frequency 6e8
*/

load "bem"
load "PETSc-complex"
include "getARGV.idp"


real c0= 299792458;
real f = getARGV("-frequency",6.e+8);
complex k = 2*pi*f/c0;
real mu0 = 4*pi*1.e-7;
real epsilon0 = 1./(c0*c0*mu0);
real Z0 = 119.9169832*pi;
real lambda = c0/f;

cout << "wave number   = " <<lambda << endl;
cout << "vacuum impedance = " <<Z0 << endl;
cout << "frequency = " << f << endl;

string testcase = "sphere";
meshS ThS;
meshS ThOut;

int nlambda = 4;                // number of wave lenght 

if( testcase == "sphere"){
    // definition of the surface mesh 
    include "MeshSurface.idp"
    real radius = 1;
    real hs = lambda/(1.0*nlambda); // mesh size on the sphere
    ThS = Sphere(radius,hs,7,1); 

    // definition of the mesh for the potentiel view
    real Rin = radius*1.05;
    real Rout = radius*1.5;

    int Nin = nlambda*40;
    int Nout = Nin*int(Rout/Rin+1);

    border circleS(t=0, 2*pi){x=Rin*cos(t); y=Rin*sin(t); z=0;}
    border circleOut(t=0, 2*pi){x=Rout*cos(t); y=Rout*sin(t); z=0;}
    mesh Thtmp = buildmesh( circleS(-Nin) + circleOut(Nout) );

    ThOut = movemesh23(Thtmp, transfo=[x,y,0]);
}
else if( testcase == "cube" ){
    int nloc = (1.0*nlambda)/lambda;
    mesh3 Th3 = cube(nloc,nloc,nloc,[x-0.5,y-0.5,z-0.5]);
    ThS = extract(Th3);

    real xout = 3.0; 
    int nlocOut = 5.0*(xout/lambda)*nlambda;
    real dxout = xout/nlocOut;
    ThOut = square3(nlocOut,nlocOut,[xout*(x-0.5),xout*(y-0.5),0]);
    ThOut = trunc(ThOut, max(abs(x),abs(y)) > 0.5 + dxout);
}
else{
    cout << "error in the choice of the test case" <<endl;
    exit(0);
}

// definition of the wave plane
// ========
//   E_inc = \vec{u}*exp(i*\vec{k}.\vec{x})
//
//   where \vec{k} =  k*\vec{dir}
//         \vec{dir} : direction of propagation
//         \vec{u} : polarization
// ========
real[int] dir(3), u(3);

if( testcase == "sphere"){
dir[0] =  0;
dir[1] =  0;
dir[2] = -1;

u[0] = 1;
u[1] = 0;
u[2] = 0;
}else if( testcase == "cube"){
dir[0] = 1;
dir[1] = 0;
dir[2] = 0;

u[0] = 0;
u[1] = 1;
u[2] = 0;
}

func uinc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));
func fincx = u[0]*uinc;
func fincy = u[1]*uinc;
func fincz = u[2]*uinc;
// ================================

// definition of fespace for EFIE 
fespace Uh3(ThS,RT0S);

Uh3<complex> [Fincx,Fincy,Fincz] = [uinc*u[0],uinc*u[1],uinc*u[2]]; // wave plane discretization
Uh3<complex> [mcx,mcy,mcz];  // FE function for magnetic current

BemKernel KerMA("MA_SL",k=k);
// construction of BEM H-matrix for EFIE operator
varf vEFIE([u1,u2,u3],[v1,v2,v3])=int2dx2d(ThS)(ThS)(BEM(KerMA,[u1,u2,u3],[v1,v2,v3]));    
HMatrix<complex> H = vEFIE(Uh3,Uh3,eta=10,eps=1e-2,minclustersize=10,nbiter=4000);

if (mpirank == 0) cout << H.infos << endl;
display(H);



// computation of rhs of EFIE 
Uh3<complex> [rhsx,rhsy,rhsz]; // FE function for rhs
varf vrhs([u1,u2,u3],[v1,v2,v3]) = -int2d(ThS)( [v1,v2,v3]'*[Fincx,Fincy,Fincz] );
rhsx[] = vrhs(0,Uh3);

// solving magnetic current
mcx[] = H^-1*rhsx[];

fespace UhOutV(ThOut,[P1,P1,P1]);
// FE function of the scattered field E
UhOutV<complex> [Ex, Ey, Ez];

// Maxwell potentiel corresponding to EFIE for electromagnetic field
BemPotential PotMA("MA_SL", k=k);

varf vpotMA([u1,u2,u3],[v1,v2,v3])=int2d(ThS)(POT(PotMA,[u1,u2,u3],[v1,v2,v3]));
HMatrix<complex> HpotMA = vpotMA(Uh3,UhOutV,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HpotMA.infos << endl;
display(HpotMA);

// compute the scattered electromagnetic field
Ex[]  = HpotMA*mcx[];

fespace UhOut(ThOut,P1);
// save the real part of scattered electromagnetic field
UhOut rExScat = real(Ex);

// compute the real part of total electromagnetic field
UhOut vr = sqrt(real(Ex)^2 + real(Ey)^2 + real(Ez)^2 );

plot(vr, dim=2, fill=1, value=1, nbiso=20, cmm="|E-real|_L2");

// compute the real part of total electromagnetic field
UhOut rEx = real(Ex)+real(fincx);
UhOut rEy = real(Ey)+real(fincy);
UhOut rEz = real(Ez)+real(fincz);

plot(rEx, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ex) total",ps="MaxwellSphereRealEx.ps");
plot(rExScat, dim=2, fill=1, value=1, nbiso=20, cmm="real(ExScat)",ps="MaxwellSphereRealScatterEx.ps");
plot(rEy, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ey) total",ps="MaxwellSphererRealEy.ps");
plot(rEz, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ez) total",ps="MaxwellSphererRealEz.ps");

//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling-MUMPS.edp -wg

// for the make check:
// NBPROC 4
// PARAM -nlenses 1 -Rout 5

/* example of wave guiding with gradient-index lenses */

load "bem"
load "MUMPS"

include "getARGV.idp"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int nlenses = getARGV("-nlenses",10); // number of lenses
int[int] nsl(nlenses);
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

// Fem mesh :
mesh Th = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l)+circle(nsl));

plot(Th, wait=1, dim=2, cmm="FEM mesh Th");

int[int] lab = [interface];
meshL ThL = extract(Th, label=lab); // BEM mesh
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL, wait=1, dim=2, cmm="BEM mesh ThL");

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);
reg = region;

func ind = reg == -1 ? 1 : 2./(1+((x-nsx[max(0.,reg-1)])^2+(y-nsy[max(0.,reg-1)])^2)); // gradient index in lenses

fespace Uh(Th,P1);
fespace UhL(ThL,P1);

macro Grad(u) [dx(u),dy(u)] // EOM

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (Frhs)
(  mass  -SL ) (ubem)   ( 0  ) */

// assemble SL BEM block :
varf SL(u,v) = int1dx1d(ThL)(ThL)(BEM(BemKernel("SL",k=k),u,v));
HMatrix<complex> HSL = SL(UhL,UhL);
if (mpirank == 0) cout << HSL.infos << endl;
display(HSL, wait=1);

// assemble TDL BEM block :
varf TDL(u,v) = int1d(ThL)(0.5*u*v) + int1dx1d(ThL)(ThL)(BEM(BemKernel("TDL",k=k),u,v));
HMatrix<complex> HTDL = TDL(UhL,UhL);
if (mpirank == 0) cout << HTDL.infos << endl;

// assemble Helmholtz FEM block :
Th=change(Th,fregion = nuTriangle%mpisize); // for parallel assembly 
varf F(u,v) = int2d(Th,mpirank)((-ind*k^2*u*v+Grad(u)'*Grad(v))) + on(waveguide,u=0);
matrix<complex> mF = F(Uh,Uh);

matrix Rr = interpolate(UhL,Uh);
matrix<complex> Rc = Rr;

// assemble mass block, only on rank 0 :
varf mass(u,v) = int1d(Th,interface)(u*v);
matrix<complex> mmass(UhL.ndof, Uh.ndof);
if (mpirank == 0) {
  mmass = mass(Uh,Uh,solver=GMRES);
  mmass = Rc*mmass;
}

complex[int,int] MSL(UhL.ndof,UhL.ndof);
MSL = HSL; // each MPI process densifies its part of HMatrix HSL
MSL *= -1;
complex[int,int] MTDL(UhL.ndof,UhL.ndof);
MTDL = HTDL; // each MPI process densifies its part of HMatrix HTDL
matrix<complex> mTDL = MTDL;
mTDL = Rc'*mTDL;

matrix<complex> A = [[mF,mTDL],[mmass,MSL]];

// compute factorization of distributed matrix A in parallel with MUMPS
set(A,solver=sparsesolver,master=-1);

// assemble FEM rhs
varf FHrhs(u,v) = int2d(Th,mpirank)(finc*v) + on(waveguide,u=0);
complex[int] rhs(Uh.ndof+UhL.ndof);
rhs(0:Uh.ndof-1) = FHrhs(0,Uh);

complex[int] u(Uh.ndof+UhL.ndof);

u = A^-1*rhs;

Uh<complex> ufem;
ufem[] = u(0:Uh.ndof-1);

UhL<complex> ubem;
ubem[] = u(Uh.ndof:u.n-1);

plot(ufem, fill=1, value=1, wait=1, dim=2, cmm="FEM solution");
plot(ubem, fill=1, value=1, wait=1, dim=2, cmm="BEM ansatz on ThL");

// output mesh for visualization
int np = 5;
real R = getARGV("-Rout",20.);
real rr = R;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R)+b2(np*rr)+b3(np*R)+b4(np*rr)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(UhL,UhOut);
if (mpirank == 0) cout << B.infos << endl;

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40, cmm="u");
//ff-mpirun -np 4 Helmholtz_circle_Neumann_all_indirect.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Hmatrix for formulation of first kind
BemKernel ker1("HS",k=k);
varf vk1(u,v)=int1dx1d(Th)(Th)(BEM(ker1,u,v)) ;  
HMatrix<complex> HFirstKind = vk1(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
if (mpirank == 0) cout << HFirstKind.infos << endl;
display(HFirstKind);

// Hmatrix for formulation of second kind
BemKernel ker2("TDL",k=k);
varf vk2(u,v)=int1dx1d(Th)(Th)(BEM(ker2,u,v)) + int1d(Th)(0.5*u*v);  

HMatrix<complex> HSecondKind = vk2(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
if (mpirank == 0) cout << HSecondKind.infos << endl;
display(HSecondKind);

// Hmatrix for combined formulation
BemKernel ker5=(-1i*k)*ker2+ker1;
varf vk3(u,v)=int1dx1d(Th)(Th)(BEM(ker5,u,v)) +int1d(Th)((-1i*k)* 0.5*u*v); 

HMatrix<complex> HCombined = vk3(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
if (mpirank == 0) cout << HCombined.infos << endl;
display(HCombined);


// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind;
varf vmassFirstKind(u,v) = -int1d(Th)((dxfinc*Tl.y-dyfinc*Tl.x)*v);// change New Nt -> Tl (the tangent to Curve Nt^ortho == Tl )
bFirstKind[] = vmassFirstKind(0,Uh);
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = bFirstKind[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = bFirstKind[];
uCombined[] = HCombined^-1*bCombined[];
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind;
vFirstKind[] = HDLPot*uFirstKind[];
vFirstKind[] += vinc[];
UhOut vFirstKindabs = abs(vFirstKind);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind;
vSecondKind[] = HSLPot*uSecondKind[];
vSecondKind[] += vinc[];
UhOut vSecondKindabs = abs(vSecondKind);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*uCombined[];
vCombined2[] = HDLPot*uCombined[];
UhOut vCombinedabs = abs(-1i*k*vCombined1+vCombined2+vinc);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
//ff-mpirun -np 4 Helmholtz_circle_Dirichlet_all_direct.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Bemkernels
BemKernel SL("SL",k=k);
BemKernel DL("DL",k=k);
BemKernel TDL("TDL",k=k);
BemKernel HS("HS",k=k);
BemKernel CFIE=k*1i*SL+TDL;
BemKernel CFIERHS=1*k*1i*DL+HS;

// varf
varf vSL(u,v)=int1dx1d(Th)(Th)(BEM(SL,u,v)) ;  
varf vDL(u,v)=int1dx1d(Th)(Th)(BEM(DL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vTDL(u,v)=int1dx1d(Th)(Th)(BEM(TDL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vHS(u,v)=int1dx1d(Th)(Th)(BEM(HS,u,v)) ;  
varf vCFIE(u,v)=int1dx1d(Th)(Th)(BEM(CFIE,u,v))+int1d(Th)(-0.5*u*v) ;  
varf vCFIERHS(u,v)=int1d(Th)(-1i*k*0.5*u*v)+int1dx1d(Th)(Th)(BEM(CFIERHS,u,v)) ;  

// hmat
HMatrix<complex> HFirstKind     = vSL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HSecondKind    = vTDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HFirstKindRHS  = vDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HSecondKindRHS = vHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HCFIE = vCFIE(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
HMatrix<complex> HCFIERHS = vCFIERHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);


if (mpirank == 0) cout << HFirstKind.infos << endl;
if (mpirank == 0) cout << HSecondKind.infos << endl;
if (mpirank == 0) cout << HFirstKindRHS.infos << endl;
if (mpirank == 0) cout << HSecondKindRHS.infos << endl;
// if (mpirank == 0) cout << HCFIE.infos << endl;
// if (mpirank == 0) cout << HCFIERHS.infos << endl;

// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind, gd;
gd=-finc;
bFirstKind[] = HFirstKindRHS*gd[];
bFirstKind[]*=-1; // because we cannot compute I/2-DL, we compute DL-I/2...
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = HSecondKindRHS*gd[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = HCFIERHS*gd[];
uCombined[] = HCFIE^-1*bCombined[];
uCombined[] *=-1;
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind1,vFirstKind2;
vFirstKind1[] = HSLPot*uFirstKind[];
vFirstKind2[] = HDLPot*gd[];
vFirstKind1[] += vFirstKind2[]+ vinc[];
UhOut vFirstKindabs = abs(vFirstKind1);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind1,vSecondKind2;
vSecondKind1[] = HSLPot*uFirstKind[];
vSecondKind2[] = HDLPot*gd[];
vSecondKind1[] += vSecondKind2[]+vinc[];
UhOut vSecondKindabs = abs(vSecondKind1);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*uCombined[];
vCombined2[] = HDLPot*gd[];
vCombined1[] += vCombined2[]+ vinc[];
UhOut vCombinedabs = abs(vCombined1);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
//ff-mpirun -np 4 Helmholtz_Cobracavity.edp -wg

// for the make check:
// NBPROC 4
// PARAM

load "bem"

include "getARGV.idp"

include "cobrameshcavity.idp"

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",3.e+9);
complex k = 2*pi*f/c0;
real lambda = c0/f;

real distx = 0.2*lambda;
real disty = distx;
real distz = distx;

int labextxm = 11, labextxM = 12, labextym = 13, labextyM = 14, labextzm = 15, labextzM = 16;
int regint = 4, regext = 5;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

// incident wave
real[int] dir=[1,0,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));

int nloc = 10.*sec3/lambda;

mesh3 Th3;
buildcobramesh(Th3);
Th3 = buildBdMesh(Th3);

meshS ThS = Th3.Gamma;
ThS = trunc(ThS, region==labmetal);

plot(ThS);

fespace Uh(ThS,P1);

cout << "ndof = " << Uh.ndof << endl;

//BemKernel ker("SL",k=k);
varf vk(u,v)=int2dx2d(ThS)(ThS)(BEM(BemKernel("SL",k=k),u,v)) ;  
HMatrix<complex> H = vk(Uh,Uh,eta=10,eps=1e-2,minclustersize=10);
//HMatrix<complex> H = assemblecomplexHESL(Uh,Uh,k,eta=10,epsilon=1e-2,minclustersize=10);

if (mpirank == 0) cout << H.infos << endl;
display(H);

Uh<complex> u, b, uinc = -finc;

varf vmass(u,v) = int2d(ThS)(u*v);
matrix<complex> M = vmass(Uh,Uh,solver=CG);

b[] = M*uinc[];

u[] = H^-1*b[];

// output visu
distx = 2*lambda;
disty = distx;
distz = distx;

int np = 100;
meshS ThOut = square3(np,np,[(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3+2*distx)*x
                               -distx,
                               (height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))*y
                               +(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,
                               width/2]);

fespace UhOut(ThOut,P1);

//BemPotential Pot("SL",k=k);
varf vp(u,v)=int2d(ThS)(POT(BemPotential("SL",k=k),u,v)) ;  
HMatrix<complex> B = vp(Uh,UhOut,eta=10,eps=1e-2,minclustersize=10);

//HMatrix<complex> B = assemblecomplexHESLPot(Uh,UhOut,k,eta=10,epsilon=1e-2,minclustersize=10);


if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = real(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);
//ff-mpirun -np 4 Helmholtz_circle_Dirichlet_simple.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 1

/*
    This example solves the Dirichlet scattering problem with an indirect formulation of the first kind.
    You can find an overview of all standard direct and indirect BEM formulations for Dirichlet
    and Neumann problems in Helmholtz_circle_Dirichlet_all_direct.edp, Helmholtz_circle_Dirichlet_all_indirect.edp,
    Helmholtz_circle_Neumann_all_direct.edp and Helmholtz_circle_Neumann_all_indirect.edp
*/

load "bem"
load "gsl"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real angle = 0;
func finc = exp(-1i*k*(x*cos(angle)+y*sin(angle)));

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

real Robj = 1;
func complex exactsol(real xi, real yi){
    real r = sqrt(xi^2 + yi^2);
    real theta = atan2(yi,xi);
    complex value = 0;
    for (int n=0;n<100;n++){
        real JnAtr    = gslsfbesselJn(n,real(k)*r);
        real YnAtr    = gslsfbesselYn(n,real(k)*r);
        real JnAtRobj = gslsfbesselJn(n,real(k)*Robj);
        real YnAtRobj = gslsfbesselYn(n,real(k)*Robj);
        value+=2*(-1*JnAtRobj*(JnAtr+1i*YnAtr)/(JnAtRobj+1i*YnAtRobj))*exp(-1i*n*pi/2.)*cos(n*(theta-angle));
        if (n==0){
            value*=0.5;
        }
    }
    return value;
}

// Hmatrix for formulation of first kind
BemKernel ker1("SL",k=k);
varf vk1(u,v)=int1dx1d(Th)(Th)(BEM(ker1,u,v));
HMatrix<complex> HFirstKind = vk1(Uh,Uh,eta=10,eps=1e-3,minclustersize=10);
if (mpirank == 0) cout << HFirstKind.infos << endl;
display(HFirstKind);

// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind;
varf vmassFirstKind(u,v) = int1d(Th)(-(finc)*v);
bFirstKind[] = vmassFirstKind(0,Uh);
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for potential
BemPotential Pot("SL",k=k);
varf vp(u,v)=int1d(Th)(POT(Pot,u,v));
HMatrix<complex> HPot = vp(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10);

if (mpirank == 0) cout << HPot.infos << endl;
display(HPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind, exacti = 0, exact;

// Compare to the exact solution:
for [i, bi : exacti[]]
if (i >= mpirank*ceil(1.*UhOut.ndof/mpisize) && i < (mpirank+1)*ceil(1.*UhOut.ndof/mpisize))
    bi = exactsol(ThOut(i).x,ThOut(i).y);
mpiReduce(exacti[],exact[],processor(0,mpiCommWorld),mpiSUM);

exact = exact + finc;

vFirstKind[] = HPot*uFirstKind[];
vFirstKind[] += vinc[];

UhOut<complex> diff = exact-vFirstKind;
if (mpirank == 0) cout << "relative L2 error = " << diff[].l2/exact[].l2 << endl;

plot(vFirstKind, dim=1, fill=1, value=1, nbiso=20,cmm="u");
plot(exact, dim=1, fill=1, value=1, nbiso=20,cmm="u exact");
plot(diff, dim=1, fill=1, value=1, nbiso=20,cmm="error");

int n=2;
meshL Th1 = segment(n);
meshL Th2 = segment(n,[0,x,0],orientation=1);
meshL Th3 = segment(n,[x,0,1],orientation=1);
meshL Th4 = segment(n,[0,0,x],orientation=-1);

meshL Th = Th1+Th2+Th3+Th4;
cout << "test nv: " << Th.nv << " nt: " << Th.nt << " nbe: "<< Th.nbe << endl;
Th=rebuildBorder(Th, angle=pi/2.+0.0001);
cout << "rebuildBorder test nv: " << Th.nv << " nt: " << Th.nt << " nbe: "<< Th.nbe << endl;

plot(Th);

meshL[int] Thglue(4);
Thglue[0] = Th1;
Thglue[1] = Th2;
Thglue[2] = Th3;
Thglue[3] = Th4;
plot(Thglue[0],Thglue[1],Thglue[2],Thglue[3]);
meshL Thglued = gluemesh(Thglue);
plot(Thglued,cmm="2");

// c0 lap u + c1 u = f 
// CL u|x=0 = 0
// f = g
// time scheme backward euler 
// [ c0 masse + c1 rigidity ] u^n = fv + rho*epsilon/tau masse  V^n-1
// + [ rho*epsilon/dt^2*(1 + dt alpha) masse + beta*\lambda1/tau rigidity ] u^{n-1}

 
// parameters
real density = 1.1, young = 0.75e6, poisson = 0.5, thickness = 0.1;
real alpha = 0., beta = 0; //(coeff rayleigh)
real dt = 0.0001, iMax = 100.;
//real tgv = 1e30; // a hude value of exact penalisation of boundary condition

func h= sin(pi*x);

real lambda0 = young*thickness/(0.25*(1-poisson*poisson)); 
real lambda1 = young*thickness/(2.*(1.+poisson));   
real c0 = density*thickness/(dt*dt)+lambda0+alpha*density*thickness/dt;
real c1 = lambda1+beta*lambda1/dt;
real a = density*thickness*(1.+dt*alpha)/(dt*dt);
real b = density*thickness/dt;

macro Grad(u) [dx(u),dy(u),dz(u)]  // EOM

// string mesh 
meshL Th=Sline(100,[2.*x,y,z]);
savemesh(Th,"ThL.mesh");
// FE space
fespace Uh(Th,P1);
Uh u, v, V, uold ;
V=0;uold=0;

func g=1000.; //x^2;//; //10000.
// c0 * mass matrix + c1 stifness matrix
varf m(u,v) = int1d(Th) (u*v);
varf k(u,v) = int1d(Th) (Grad(u)'*Grad(v));
varf mmkk(u,v) = int1d(Th) (c0*u*v + c1*Grad(u)'*Grad(v)) + on(1,u=0);
varf cl(u,v) = on(1,u=0);

matrix mass=m(Uh,Uh);
matrix stifness=k(Uh,Uh);
matrix mk = mmkk(Uh,Uh); //,tgv=tgv,solver="SPARSESOLVER");

varf f(u,v) = int1d(Th)(g*v);
real[int] Force=f(0,Uh);
real[int] CL=cl(0,Uh);
matrix T = a*mass + (beta*lambda1/dt)*stifness;  

//initial condition
u[] = 0;
  
meshL Thmv;
real t=dt;

for (int i=0; i<=iMax; i++) {
	   V[]=(u[]-uold[]);
	   V[]/=dt; 
	   uold[]=u[];
	   //  for the time dependant part
	   real[int] rhs = mass*V[];  	   
	   rhs *= b;
	   rhs += CL;
	   rhs += T*uold[];
	   // apply the external force
	   if( ( t> 0.004 && t<0.008 ) || (t>0.02 && t<0.03)) 
	   		rhs+=Force;
	   u[] = mk^-1*rhs;
	   t+=dt;
	   // coeff for the visu
	   real coeff=100;
	   Thmv=movemesh(Th,[x,y,u*coeff]);
	   if (verbosity)
	   		cout << " time " << t << " u min "<< u[].min << " u max " << u[].max << endl;
       plot(Th, Thmv, wait=0, cmm=" d = "+t+" iter = "+i,prev=1);


    }


meshL Th=Sline(4);

  // --------- new stuff -----------------
  int k=0,l=1,e=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int i=0;i<Th.nv;++i)
  cout << i << " : "  << Th(i).x << " "<< Th(i).y << " " << Th(i).z  << endl; 
 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) 
	 << " , label/ region  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<2;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0]    << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 


load "medit"

int n=10;

int[int] labs = [1, 2, 2, 1, 1, 2]; // Label numbering
mesh3 Th = cube(n, n, n, label=labs);
// extract the surface (boundary) of the cube
int[int] llabs = [1]; 
meshS ThS = extract(Th,label=llabs);
ThS = buildBdMesh(ThS);
meshL ThL= ThS.Gamma;
assert(ThL.nv==88); 
assert(ThL.nt==90);
assert(ThL.nbe==7);

plot(ThL, wait=1);

savemesh(ThL, "testL.mesh");
meshL ThL2=Sline(10);
medit("ThL2",ThL2);
 
meshL ThL3=Sline(40,[x,1,x*0.1]);
real[int] bb(6);
boundingbox(ThL3,bb);
cout << bb << endl; 
fespace Vh(ThL3,P2);
Vh p2=x*x+2*x*z+3*z*(z-1);
cout << " dxx "<< dxx(p2)(0.5,0,0.5) << endl; 
cout << " dxz "<< dxz(p2)(0.5,0,0.5) << endl; 
cout << " dzz "<< dzz(p2)(0.5,0,0.5) << endl; 

func f = 1 ;
macro Grad3(uh) [dx(uh),dy(uh),dz(uh)]  // EOM

Vh uLPb,vLPb;

// with problem
problem Lap3dL(uLPb,vLPb)  = int1d(ThL3)(Grad3(uLPb)'*Grad3(vLPb))
 - int1d ( ThL3 ) ( f * vLPb )
  + on(1,uLPb=0);
Lap3dL;
// verif.
cout << " len ThL3 = "<< int1d(ThL3)(1.) << endl; 
// P=[0.5,1,0.05]; to do

real uP=uLPb(0.5,1,0.05);

Vh uex = cos(x) * cosh(y) + sin(x) * sinh(y);
Vh vn = (1 - x) * uex(0,1,0) + x * uex(1,1,0) +4;

cout << nuTriangle<< endl; 
cout << uP << " " << " ~ " << uLPb[][40]<< endl;
// cout << uLPb(0.5,1,0.05) << endl; // to do also ..
cout << ThL3.mesure << endl; 
Vh u1=dx(uLPb),u2=dy(uLPb),u3=dz(uLPb);

plot(ThL3,uLPb);
//
// Problem definition
//
//1d pde on the boundary term       u_t=e*u_{xx}   0<x<1
//                                  u(0,x)=1-2*(t-1/2)*sign(t-1/2)
//                                  u(t,0)=0,u(t,1)=0

// Technical data to recreate OX and OY axis
//
border OX(t=0,1){x=t;y=0;} 
border OY(t=-1,1){x=0;y=t;}

int m=100; // grid points on x-interval [0,1]
real h=1./m;

meshL Th=segment(m);

plot(Th, cmm="NO ADAPTED MESH ",wait=0);//,ps="reactiondiffusionnoadapted2dmesh.eps");
fespace Uh(Th,P1);
 
// Initial data
func real u0(real t) 
{
return sin(4*pi*t);
}

 
Uh S, uold0,uold1,unew;

uold0=u0(x);// Step cero
uold1=uold0; // Step one

real dt=0.01;
real T=1; // tempo di uscita
real t=0;  // velocita iniziale
real c=1400; // Speed of propagation
real L=1000; // Speed of propagation


real ratio = 0.5*dt^2*c^2/L^2;

varf mat(u,v)= int1d(Th)(u*v+ratio*dx(u)*dx(v))+on(1,2,u=0); 

varf rhs(u,v)= int1d(Th)((2*uold1-uold0)*v
                          -ratio*dx(uold0)*dx(v)+0*v)+on(1,2,u=0);


matrix A=mat(Uh,Uh);
real[int] b=rhs(0,Uh);

real maximum=0.0;

// time loop
for (t=0;t<T; t+=dt) { 

S[]=A^-1*b;
meshL Thmv=movemesh(Th,[x,y+S*0.3]);
plot(Thmv,OX(1),OY(1),wait=0,prev=1,dim=2, cmm="Time "+t+" max "+S[].max);

//
//update

uold0[] = uold1[]; 
uold1[] = S[]; 
A=mat(Uh,Uh);
b=rhs(0,Uh);

}; // end of time loop
int nn= 4; 
int[int] ll=[10,11]; 
meshL Th= segment(nn,[x*nn,0,0],label=ll,region=1); // 
//  print information of Th
// bug label corrige ??
cout << " Element : "<<endl;
for(int k=0; k< Th.nt; ++k)
{
	cout << Th[k][0] << " "<< Th[k][1]  << ":  " 
	     << Th[k][0].x << " " << Th[k][0].label << " , " 
	     << Th[k][1].x << " " << Th[k][1].label <<  " " << Th[k].region << endl;
	
}
for(int i=0; i< Th.nv; ++i)
{
	cout << Th(i).x << " " << Th(i).y  << " " << Th(i).y  << " " << Th(i).label << endl; 
}
for(int i=0; i< Th.nbe; ++i)
{
	cout << " be " << i << " " << Th.be(i) << " " <<  Th.be(i).label  <<endl;
}

//  verif integration ..
func real track() { cout << " Track " << x << " N " << N << " Tl= " << Tl << endl; return 1.;}
fespace Vh(Th,P1);
varf va(u,v) = int1d(Th)(track()*dx(u)*dx(v)) + int0d(Th,10)(track()*u*v) - int0d(Th,10)(track()*v);
matrix A = va(Vh,Vh);
verbosity= 10; 
real[int] b= va(0,Vh);

cout << " A = " << A << endl;
cout << " b = " << b << endl;

assert(abs(b.sum+1)< 1e-7);
assert(abs(A(0,0)-2)<1e-7);
assert(abs(A(nn,nn)-1)<1e-7);

meshL Th=segment(10,[x*pi*2]);
fespace Vh(Th,P1,periodic=[[1],[2]]);
meshL ThVh = Vh.Th; // check code ..
func u1e =(sin(x+1));
Vh u,v,uh=u1e;

meshL Thu = u.Th; // check code ..
u.n; // check code ..  
func f1= 1*u1e;
macro grad3(u) [dx(u),dy(u),dz(u)]//
solve PP2(u,v) = int1d(Th)(grad3(u)'*grad3(v)+1e-6*u*v) - int1d(Th)(f1*v) ;
Vh xx=x;
//plot([xx[],u[]],[xx[],uh[]],wait=1);
u[]-=uh[];
cout << " err 1 = " << u[].linfty << endl;

assert(u[].linfty< 0.05);
int n = 100;
meshL Th = segment(n,[10.*(2.*x-1.),1.*y]);	
fespace Vh(Th,P1); 	
Vh psi, chi; // unknown and testfunction

int nev = 6; // number of eigensolutions
real e = 1.; // energy parameter (eigenvalue)
Vh[int] EigenPsi(nev); // array to store eigenvectors
real[int] EigenVal(nev); // array to store eigenvalues									

varf Schrodinger(psi,chi) = // variational form of the schrodinger equation
	int1d(Th)(dx(psi)*dx(chi) + x^2*psi*chi) 
	- int1d(Th)(e*psi*chi) + on(2,4,psi=0);
varf RHS(psi,chi) = int1d(Th)(psi*chi);
matrix A = Schrodinger(Vh,Vh);
matrix B = RHS(Vh,Vh);

// solve the eigenvalue problem:
int num = EigenValue(A,B,sym=true,sigma=e,value=EigenVal,
vector=EigenPsi,tol=1e-10,maxit=1000,ncv=0);

for(int i = 0; i < nev; i++){
	cout << "Eigenvalue["+i+"] = " << EigenVal[i] << endl;
	plot(EigenPsi[i],dim=3,fill=1,cmm="("+i+")");
	}

int upper = 1;
int others = 2;
int inner = 3;
int n = 10;

border D01(t=0, 1) {x=0; y=-1+t;z=3; }
border D02(t=0, 1){x=1.5-1.5*t; y=-1; z=3;label=upper;}
border D03(t=0, 1){x=1.5; y=-t; z=3;label=upper;}
border D04(t=0, 1){x=1+0.5*t; y=0; z=3;label=others;}
border D05(t=0, 1){x=0.5+0.5*t; y=0; z=3;label=others;}
border D06(t=0, 1){x=0.5*t; y=0; z=3;label=others;}
border D11(t=0, 1){x=0.5; y=-0.5*t; z=3;label=inner;}
border D12(t=0, 1){x=0.5+0.5*t; y=-0.5; z=3;label=inner;}
border D13(t=0, 1){x=1; y=-0.5+0.5*t; z=3;label=inner;}

plot(D01(-n) + D02(-n) + D03(-n) + D04(-n) + D05(-n)
   + D06(-n) + D11(n) + D12(n) + D13(n), wait=true);
 
meshL ThL=buildmeshL(D01(-n) + D02(-n) + D03(-n) + D04(-n) + D05(-n)
    + D06(-n) + D11(n) + D12(n) + D13(n));

savemesh(ThL,"toto.mesh");
	
//helice conique
border E1(t=0, 10.*pi){x=(1.)*t*cos(t); y=-(1.)*t*sin(t); z=t;}
meshL ThL2=buildmeshL(E1(1000));
plot(ThL2);

mesh Th=square(10,10);
int[int] ll=[4];
meshL ThL3 = extract(Th,[x+2,y*5],refedge=ll);
verbosity=3;
border C(t=0, 2*pi){ x= cos(t); y=sin(t); region=1;}
meshL Lh=buildmeshL(C(20));
plot(Lh,dim=2, wait=1);
mesh Th = buildmesh(Lh);

plot(Th,dim=2, wait=1);
// NBPROC 4 
// PARAM   -cas 2    -n 20 -ndt 50
// usage :
//  ff-mpirun -np 8 NSNewtonCyl-100-mpi.edp -cas 2    -n 20 -ndt 50 
/* args can are:
   -ns                no output of script 
   -cas 1|2|3         case of benchmark  or Reynorl integer)
   -n nbseg           nb of seg on input edge ..  
   -ndt  ndt         nb time step par period 
   -nNewton nNx      number of of iteration in Newtow loop.    
   -gp      gnuplot ..
   -T final time 
 */
// Author: F. Hecht  .. 
// jan 2012 Stationnary imcompressible Navier Stokes Equation with Newton method.
//  a round a 2d Cylinder 
//  Benchmark  
// http://www.mathematik.tu-dortmund.de/lsiii/cms/papers/SchaeferTurek1996.pdf
//  
//  Thank to Macarena Gómez Mármol <macarena@us.es>
// need version 3.20-2 ****  for pipe pluging 
// otherwise remove line with  pgnuplot 
// corresponding to gnuplot visualization
// --------------------------------------------------
include "getARGV.idp"
include "getARGV.idp"
load "MUMPS_mpi"
load "shell"
load "scotch"
load "pipe"

int cas = getARGV("-cas",2);; // 1, 2 or 3 ..
int n=getARGV("-n",15); //  mesh size ...
int ndt=getARGV("-ndt",25); 
int schema = 2; //  order 1  
bool gplt = usedARGV("-gp")>=0  && (mpirank==0) && (cas!=1) ; // 
real Tend = getARGV("-T",2);;  
bool save=0; 
real cpu0=mpiWtime() ; 
string data="./dd";//"2D-"+cas+"-"+n;
if(mpirank==0) mkdir(data);
string fgnup =data+"/fld2-"+cas+".gp";
string fdata = data+"/sol-cas-";
string fTh = data+"/Th-"+cas+".msh";

pstream  pgnuplot(  gplt  ? "gnuplot": "cat" );
 
//   parameter ... 
real D=0.1;
real H=0.41;
int ncurl=20; 

real[int] colorhsv=[  // color hsv model
  3./6., 1 , 0.5, // dark cyan
  3./6., 1 , 1, //  cyan
  4./6., 1 , 1, //  blue  
  5./6., 1 , 1, //  magenta
  1, 1. , 1, //  red
  1, 0.5 , 1 // light red 
   ];

real[int] vcurl( ncurl*2+1);
{ int n = vcurl.n;
   real d = 100;
   real c = 1.3 ;
    real ccc=0,cc = d/(1- c^(ncurl+1))/ (1-c) ; 
   vcurl[ncurl]=0; 
    for( int i =1 ; i <= ncurl;++i)
      {
        ccc += cc;
        cc *= c ; 
      //  cout << i << " " << ncurl-i << " " << ncurl+i << endl;
        vcurl[ncurl-i] = -ccc;
        vcurl[ncurl+i] = ccc;
      }
   cout << vcurl << endl; 
}
real cx0 = 0.2, cy0 = 0.2; // center of cyl. 
real xa = 0.15, ya=0.2, xe = 0.25,ye =0.2;// point for pressure..
//Definición del dominio 
border fr1(t=0,2.2){x=t; y=0; label=1;}
border fr2(t=0,H){x=2.2; y=t; label=2;}
border fr3(t=2.2,0){x=t; y=H; label=1;}
border fr4(t=H,0){x=0; y=t; label=1;}
border fr5(t=2*pi,0){x=cx0+D*sin(t)/2; y=cy0+D*cos(t)/2; label=3;}

//plot(fr1(n)+fr2(n)+fr3(n)+fr4(n)+fr5(n));
mesh Th;

if(mpirank==0)
{
  Th=buildmesh(fr1(5*n)+fr2(n)+fr3(5*n)+fr4(n)+fr5(-n*3));
  int[int] nupart(Th.nt);
  nupart=0; 
  if(mpisize>1)
    scotch(nupart, Th, mpisize);
  Th=change(Th,fregion= nupart[nuTriangle]);
  savemesh(Th,fTh);
  plot(Th,wait=0);

}
broadcast(processor(0),Th); 
// partition of the mesh ...
// for computation of the Strouhal number
include "func-max.idp"
real hsize = D*pi/n; // size of the mesh ???? 

// bounding box for the plot 
func bb=[[0,H/4],[H*2,3*H/4]];

//  operator 
macro Grad(u1,u2) [ dx(u1),dy(u1), dx(u2),dy(u2)]// 
macro Eps(u1,u2) [ dx(u1),(dy(u1)+dx(u2))*0.5,(dy(u1)+dx(u2))*0.5,dy(u2)]// 
macro UgradV(u1,u2,v1,v2) [ [u1,u2]'*[dx(v1),dy(v1)] , [u1,u2]'*[dx(v2),dy(v2)] ]// 
macro div(u1,u2)  (dx(u1)+dy(u2))//
//  FE Space 
fespace Xh(Th,P2);fespace Mh(Th,P1);
fespace Wh(Th,[P2,P2,P1]);
fespace Rh(Th,P1dc);
Wh [u1,u2,p];
Wh [up1,up2,pp];
Wh [upp1,upp2,ppp];

Wh [vx1,vx2,vxp];
Wh [vy1,vy2,vyp];
varf von3x([u1,u2,p],[v1,v2,q]) = on(3 ,u1= 1); 
varf von3y([u1,u2,p],[v1,v2,q]) = on(3 ,u2= 1); 
vx1[]= von3x(0,Wh,tgv=1);
vy1[]= von3y(0,Wh,tgv=1);
real coefv =1, vtheta=0;  
real Um= 1.5;// max volicite case 2,3 (Rey 100) 
if( cas>3) 
  {
    
    Um = cas*1.5/100.;
    cas =2;
  }

func  Ub = Um*2./3.; 
real nu = 1e-3; 
real mu = 2*nu; //  Formulation in Eps : Eps 
func Rey = Ub*D/nu;
func ccdrag = 2./ square(Ub) /D ;
func ccfreq = D/Ub; 
real freq = 0.3/ccfreq; // frequence theorique
// initial guess..
u1[]=0; 

real T=0; // current time 

// velocity BC .. 
func coefV = (cas<3)? 1 : sin(pi*min(T/8.,1.));
func U1 = 4.*Um*y*(H-y)/(H*H) * coefv ;
func U2 = 0 ;

// stop test for Newton 
real eps=1e-8*Um;
//  choise of time step ..
int  mdt = rint(Tend*freq*ndt);
real dt = Tend/mdt;//  ntd  pas de temps pas periode 
real CFL = Um*dt/hsize; 
if(mpirank==0) cout << " dt =" << dt << " CFL = " << CFL <<  endl; 

verbosity=0;
// BDF2 schema  order 2 in time ... 
real[int] beta=[1.5, -2., +0.5];  
if(schema ==1) 
  beta=[1,-1,0]; // Euler implicit + ruse OP 
  
real[int] ab=1./dt*beta  ;

if(cas ==1) 
{ // static case
  Um = 0.3;
  Tend=0;
  ab=0; // no time .. 
 
}
// init..
int iter=0;
if(mpirank==0) {
        ofstream f(fgnup);// clean the file ..   
 }

varf GStokesl([du1,du2,dp],[v1,v2,q]) =
		   int2d(Th,mpirank) ( 
		                ab[0]*[du1,du2]'*[v1,v2]
		              + mu*(Eps(du1,du2)'*Eps(v1,v2) )
		              - div(du1,du2)*q - div(v1,v2)*dp 
		              - 1e-8*dp*q // stabilization term 
		             )
	    + on(1,3,du1=0,du2=0)
	    + on(2,du2=0) 
	    
;
varf GStokesl0([du1,du2,dp],[v1,v2,q]) =
		   int2d(Th,mpirank) ( 
		                ab[0]*[du1,du2]'*[v1,v2]
		              + mu*(Eps(du1,du2)'*Eps(v1,v2) )
		              - div(du1,du2)*q - div(v1,v2)*dp 
		              - 1e-8*dp*q // stabilization term 
		             )
	   ;
varf Vconvect([du1,du2,dp],[v1,v2,q]) =
  -int2d(Th,mpirank) ( 
    ab[1]* ( [v1,v2]'* [
      convect([u1,u2],-dt,up1),
      convect([u1,u2],-dt,up2)
    ] )
   +  ab[2]* ( [v1,v2]'* [
      convect([u1,u2],-dt*2,upp1),
      convect([u1,u2],-dt*2,upp2)
    ] )
     ); 

varf Vconvect1([du1,du2,dp],[v1,v2,q]) =
  -int2d(Th,mpirank) ( 
    ab[1]* ( [v1,v2]'* [
      convect([u1,u2],-dt,up1),
      convect([u1,u2],-dt,up2)
    ] )
); 
    
  
varf VBC([u1,u2,p],[v1,v2,q]) = on(1,u1=U1,u2=U2); 
real[int] bcl=VBC(0,Wh);
real[int] bl(Wh.ndof),b(Wh.ndof),bcv(Wh.ndof); 
matrix A,A0;
 
 A=GStokesl(Wh,Wh,solver=GMRES); //sparsesolver,master=-1);
//mpiAllReduce(Al,A,mpiCommWorld,mpiSUM);
A0=GStokesl0(Wh,Wh,solver=GMRES);
//mpiAllReduce(A0,A,mpiCommWorld,mpiSUM);

set(A,solver=sparsesolver,master=-1);
Wh [w1,w2,wp]; 
// loop in time if need ..
cout << "Stort\n";
real CPU0=mpiWtime();

while(1) 
{	
    real err=0;
    T += dt;
    iter++;
    real co = coefv;
    coefv  =  coefV;// coef in velocty ..
    if( co != coefv ) bcl=VBC(0,Wh);
    upp1[]=up1[];
    up1[]=u1[];
    if(schema>1)
     { u1[] *=2; u1[] -= upp1[]; } 
     if( ab[2])    
      bcv = Vconvect(0,Wh);
    else 
      bcv = Vconvect1(0,Wh);
    bl = bcv;
    bl += bcl;
       	
	{
	   //mpiAllReduce(bl,b,mpiCommWorld,mpiSUM);
        w1[]=A^-1*bl;
	    u1[] =  w1[];
	    if(mpirank==0)  
	      cout << T << "\t " << n << " rey  =" << Rey << " U1 max = " << u1[].max <<" " ;
	}
	//if( schema==1)
	 //{ u1[] *= 2; u1[] -= up1[]; }   
   if(cas==1) 
    {
        plot([u1,u2],p,  coef = 0.02/u1[].max, bb=bb,wait=1, cmm=" cas 1 "); 
    }
     b  = A0*w1[];
     b += bcv;
     real cdrag = -(b'*vx1[]) ; 
     real clift = b'*vy1[] ; 
		             
    real drag,lift,Cd,Cl,Ta;
    mpiAllReduce(clift,lift,mpiCommWorld,mpiSUM);  
    mpiAllReduce(cdrag,drag,mpiCommWorld,mpiSUM);  
    if ( iter > 2)
    {
    Cd = ccdrag*drag;
    Cl = ccdrag*lift; 
    }
    // end of compute the Drag and lift Coef 
    
    Ta = T/ccfreq; // The adimensional time ..
    real Deltap = p(xa,ya) - p(xe,ye) ; // the Deltap
    real strouhal = AddStrouhal(iter,Ta,Cl);
    AddMaxO2(Cd,iter,mxdrag,mxdragi);   
    AddMaxO2(Cl,iter,mxlift,mxlifti);   
    real Cdx = mxdrag.max, Clx = mxlift.max; 
   if(mpirank==0) {
        {
        ofstream f(fgnup,append);
        f << T << " " << drag << " " << lift << " " 
          << Ta << " " << Cd << " " << Cl    << " " << Deltap <<"   " << mpiWtime()-cpu0 << " " 
          << iter <<  "  " << strouhal << endl;
        }
     real Td = max((int(Ta)-20),0); //  period  = 3 en Ta 
     if(cas==3) Td=0; 
     if(gplt) {
        pgnuplot << "set title \"Rey = " +Rey + ", Strouhal= "+strouhal+",  T = "
                    + T + ", cas = " + cas << ", Cara CFL : "+CFL+"\";\n";
        pgnuplot << "plot ["+Td+":] \""+fgnup+"\" u 4:5 w l t \"Cd\", \""+fgnup
                    +"\"  u 4:6 w l t \"Cl\","+Cdx+",   "+ Clx << endl;
        flush(pgnuplot); 
     }
 
    }
    
    // plot curl of the flow preetty ...
    Rh curlu = -dy(u1)+ dx(u2);
    plot(curlu,viso=vcurl,  fill=1,hsv=colorhsv,
    // bb=bb,
      coef=0.01/Um,cmm = " T = " + T+" / "+Tend+" s + "); 
    
    upp1[] = up1[] -u1[];
    upp2[] = up2[] -u2[];
     real CPU = mpiWtime()-CPU0;
     CPU0=mpiWtime();
    real errt = upp1[].linfty + upp2[].linfty; 
    if(mpirank==0)  cout << " errt = " << errt<< " T = " << T <<  " Strouhal  " << strouhal  <<" Cdx= " << Cdx<< " Clx =  " << Clx << " " << CPU << "s" <<endl; 
    if(mpirank ==0 && save)
    {
        ofstream f(fdata+"-"+iter+".txt");
        f << T << endl;
        f << u1[] << endl;
        f << u2[] << endl;
        f << p[] << endl; 
    }
    if( errt < 1e-5) break; // stop if steady state 
    if(T>Tend*1.0000001) break; // stop after final time ..
}


//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4


verbosity=100;
cout << " rank = " << mpirank << " " << " size " << mpisize << endl;
if ( mpisize > 1) 
  if( mpirank==0) 
    {
      cout << " send to 1 " << endl;
      processor(1) << 123456;
    }
  else if (mpirank==1) 
    {
      int k;
      processor(0) >> k;
      cout << " recived " << k << endl;
    }
int l= mpirank+100;
cout << " l == " << l << " broadcast l from 0   mpirank = " << mpirank << endl;
broadcast(processor(0),l);
cout << " l == " << l << "  mpirank ="<< mpirank << endl;

matrix<complex> A;

if( mpirank==0)
   A=[[1+1i,1i],[0,2-1i]];
broadcast(processor(0),A);

if (mpirank==1)
  { A=A+A;
    processor(0) << A;
  }
 else if(mpirank==0)
   processor(1) >>  A;
cout << " mpirank = " << " A =  " <<  A << endl;

cout << " " <<  norm(A(1,1) - 2-1i) << endl;
if( mpisize>4)
{
int[int] procs=[1,0,3];
mpiGroup group(procs);
}
// NBPROC 10
// ff-mpirun -np 4 DDM-Schwarz-Lap-3d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/

load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer3d.idp"
include "DDM-funcs-v2.idp"
include "cube.idp" 
include "MPIplot.idp"

searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",20);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3);
string tsolver = getARGV("-ts","CG"); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=1; // size of overlap
bool RAS=1; 

if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

string sPk="P2-3gd";     
func Pk=P2;
int Pknbcomp=1; 

func bool  plotMPIall(mesh3 &Th,real[int] & u,string  cm)
{ if(vdebug) PLOTMPIALL(mesh3,Pk, Th, u,{ cmm=cm,nbiso=4,fill=1,dim=3,value=1}); return 1;}

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;

int[int] l111=[1,1,1,1]; 
settt 


int[int,int] LL=[[1,1],[1,1],[1,1]];
real[int,int] BB=[[0,1],[0,1],[0,1]];
int[int] NN=[nloc,nloc,nloc]; 
int[int] NNC=[nC,nC,nC]; 
settt 
mesh3 Thg=Cube(NN,BB,LL);
mesh3 ThC=Cube(NNC,BB,LL);

fespace VhC(ThC,P1); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh3,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh3,Pk,1,[0],
                 Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)

Whi ui,vi; 



/* the definition of the Problem .... */
func G=1.; /* ok  */
func F=1.; /* ok  */
macro grad(u) [dx(u),dy(u),dz(u)] //
// warning for Dir. BC. the last win 
varf vPb(U,V)= int3d(Thi)(grad(U)'*grad(V)) + int3d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int3d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon10(U,V)=on(10,U=1)+on(1,U=0);

varf vPBC(U,V)=on(1,U=G);


real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=tsolver); 

DMMDeffuncAndGlobals(Lap3,comm,jpart,Whi,Vhc,1,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0])

Lap3CheckUpdate();
  
Whi u=0,v;
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lap3DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lap3kiter <<  endl;
}

Lap3Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
//ff-mpirun -np 4 parmmg.edp -wg 

// for the make check:
// NBPROC 4
// PARAM

load "medit"
load "mmg"
load "parmmg"

int nn = 40;

mesh3 Th3=cube(nn,nn,nn);

func sphere = sqrt((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)-0.3;
real hmin = 0.02;
real hmax = 0.1;

fespace Uh(Th3,P1);
Uh met = max(hmin,min(hmax,abs(sphere)));

// centralized input ; input mesh is from rank 0
Th3 = parmmg3d(Th3,metric=met[],comm=mpiCommWorld);
// output mesh is broadcast to all processes in comm

if (mpirank == 0)
  medit("Th3",Th3);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

// other
//load "medit"
load "MUMPS_mpi"
include "cube.idp"

real ttgv=1e10;
//string ssparams="nprow=1, npcol="+mpisize;

int[int]  Nxyz=[40,8,8];
real [int,int]  Bxyz=[[0.,5.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,1],[2,2],[2,2]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

fespace Vh(Th,[P2,P2,P2]);
//fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
real time=clock();  

real tMatrix = clock();
varf vLame([u1,u2,u3],[v1,v2,v3]) = 
int3d(Th)(
		 lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    + 2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //') for emacs
	      )
	      + on(1,u1=0,u2=0,u3=0);

matrix MLame=vLame(Vh,Vh,tgv=ttgv);
tMatrix = clock()-tMatrix;

real tFact = clock();
set(MLame,solver="MUMPSMPI",tgv=ttgv);
tFact = clock()-tFact;

real tsdc = clock();
varf vsdc([u1,u2,u3],[v1,v2,v3])=int3d(Th) (gravity*v3)+ on(1,u1=0,u2=0,u3=0);
real[int] sdc= vsdc(0,Vh); 
tsdc = clock()-tsdc;

real tsolve=clock();
u1[] = MLame^-1*sdc;
tsolve= clock()-tsolve;
cout << "===============================================" << endl;
cout << "====            CPU time                  =====" << endl;
cout << "===============================================" << endl;
cout << " ALL solving steps :::: "  << clock()-time << endl;
cout << " Matrix            :::: "  << tMatrix << endl;
cout << " Fact              :::: "  << tFact   << endl;
cout << " Second member     :::: "  << tsdc    << endl;
cout << " Solve             :::: "  << tsolve  << endl;
cout << "===============================================" << endl;

if(mpirank==0)
{
	real dmax= u1[].max;
	cout << mpirank << " max deplacement = " << dmax << endl;
	real coef= 0.01/max(dmax,1e-10);
	int[int] ref2=[1,0,2,0];
	
searchMethod=0;		
  mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2);
  savemesh(Thm,"beam-deformed-mumps.mesh");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -n 5

// other
load "medit"
load "MUMPS_mpi"
include "getARGV.idp"

real ttgv=1e10;
//string ssparams="nprow=1, npcol="+mpisize;

int nn=getARGV("-n",15);
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);  Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],  labelmid=rmid, 
  reffaceup = rup,     reffacelow = rdown);
  
//medit("c10x10x10",Th);
fespace VVh(Th,[P2,P2,P2,P1]);
fespace UUh(Th,[P2,P2,P2]);
fespace Uh(Th,P2);
fespace Ph(Th,P1);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

func fup = (1-x)*(x)*y*(1-y)*16;

Uh u1,u2,u3;
Uh v1,v2,v3;
Ph p,q;

real timeI=clock();
real time1=clock();

//VVh [uu1,uu2,uu3,up];
varf vlaplace([u1,u2,u3],[v1,v2,v3]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) ) 
  + on(2,u1=fup,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ; //'

varf vdiv([u1,u2,u3],[q])=int3d(Th,qforder=3)(- div(u1,u2,u3)*q );
varf vdivT([q],[u1,u2,u3])=int3d(Th,qforder=3)(- div(u1,u2,u3)*q );
varf vmass(p,q) = int3d(Th,qforder=3)( 1e-10*p*q );

matrix M=vmass(Ph,Ph);
matrix L=vlaplace(UUh,UUh,tgv=ttgv);
matrix B=vdiv(UUh,Ph);
matrix BT=vdivT(Ph,UUh);

matrix A = [ [ L, BT ],     //'
	     [ B, M  ]];

time1=clock()-time1;

real timeF=clock();
set(A,solver=sparsesolver);
timeF=clock()-timeF;

real time2=clock();
real[int] b(VVh.ndof);
real[int] xx(VVh.ndof);
{ 
  real[int] b1 = vlaplace(0,UUh);
  
  for(int ii=0; ii<UUh.ndof; ii++)
    {
      b[ii]=b1[ii];
    }
  for(int ii=0; ii<Ph.ndof; ii++)
    {
      b[ii+UUh.ndof]=0;
    }
}
time2=clock()-time2;

real time3=clock();
xx = A^-1*b;
time3=clock()-time3;

for(int ii=0; ii<Uh.ndof; ii++)
    {
      u1[][ii]=xx[3*ii];
      u2[][ii]=xx[3*ii+1];
      u3[][ii]=xx[3*ii+2];
    }
  for(int ii=0; ii<Ph.ndof; ii++)
    {
      p[][ii]=xx[ii+UUh.ndof];
    }

timeI=clock()-timeI;

cout << "============= CPU TIME ============" << endl;
cout << " matrix                  " <<  time1 << endl;
cout << " Fact                    " <<  timeF << endl;
cout << " second member           " <<  time2 << endl;
cout << " solve                   " <<  time3 << endl;
cout << "                          ------------" << endl;
cout << " all                     " <<  timeI << endl;
cout << "============= CPU TIME ============" << endl;

//if(mpirank==0) medit("UV2 PV2",Th,[u1,u2,u3],p);

// NBPROC 3
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
load "MUMPS_mpi"
verbosity=7;
mesh Th=square(20,20,[pi*y,pi*x]);
Th=change(Th,fregion= (mpisize*nuTriangle)/Th.nt);
plot(Th,wait=1,fill=1);
fespace Vh(Th,P2);
Vh u1,u2;
int n=Vh.ndof; 

real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th,mpirank)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th,mpirank)(  u1*u2 ) ; // no  Boundary condition
int[int] info(40);
info=-1;
info(0)=1;
matrix A= a(Vh,Vh,solver=sparsesolver,master=-1,info=info); 

matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 
 

func real[int] FA(real[int] & u) { 
	// resolution distribuer mais pas le second membre 
	if(mpirank==0) {int cas=1; broadcast(processor(0),cas);}
	else u=0; //  second menbre non distribute
	real[int] Au=A^-1*u;return Au;
}


func real[int] FB(real[int] & u) { 
	
	if(mpirank==0) {
		int cas=2; broadcast(processor(0),cas);}
	broadcast(processor(0),u);
	real[int] Alu=B*u,Au(Alu.n);
	mpiReduce(Alu,Au,processor(0),mpiSUM);
	return Au;

}


func int Farpack(int i)
{
   
   real[int]  u(n);
   while(1)
	{
	int cas ;
	broadcast(processor(0),cas);
	cout << mpirank << " " << cas << endl; 
	if(cas==1) FA(u);
	else if(cas==2) FB(u);
	else break;
    }
	return 0; 
}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector

if(mpirank==0)
{
int k=EigenValue(n,FA,FB,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);

int cas=0; broadcast(processor(0),cas); 
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
real[int]  eev(36);
eev=1e100;
for(int i=1,k=0;i<7;++i)
for(int j=1;j<7;++j)
  eev[k++]=i*i+j*j;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  if(abs(ev[i]-eev[i]) > 1e-1) nerr++;
  cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=0);
}
assert(nerr==0);
}
else
 Farpack(0);
 

// NBPROC 4
load "MPICG"

// the grad of the bilinear part of J (the RHS in remove)
   int n=3;
  real[int]  b(n),u(n);
  b=1;
   u=0; // set  right hand side and initial gest

  func real[int] matId(real[int] &u) { return u;};
  func real[int] DJ0(real[int] &u)
    { 
      for (int i=0;i<u.n;i++)
	u[i]=10*mpirank+(i+1)*u[i];
      return u;  // return of global variable ok 
   };
  func real error(real[int] & u,real[int] & b)
   {
   real s=0;
     for (int i=0;i<u.n;i++)
	s += abs(10*mpirank+(i+1)*u[i] - b[i]);
   return s;    
   }

  b=1; u=0; // set  right hand side and initial gest
  MPILinearCG(DJ0,u,b,eps=1.e-6,nbiter=20,precon=matId);
  cout << "LinearCG (Linear)  err=" << error(u,b) << endl;
  assert(error(u,b) < 1e-5);


{
  int[int] procs=[0,1];
  mpiGroup gpr(procs);
  cout << " before  ...  " << mpirank << endl;
  mpiComm comm(gpr);
  if(comm)  // ..  comm 
    {
      int rank=mpiRank(comm);
      cout << " rank = " << rank << endl; 
      mesh[int]  aTh(2);
      int[int]  ll=[1,2-rank,1,1+rank];
      aTh[rank]=square(4,4,[rank+x,y], label=ll);	  
      broadcast(processor(0,comm),aTh[0]);
      broadcast(processor(1,comm),aTh[1]);
      mesh Th=aTh[rank];
      mesh Thi=aTh[1-rank]; 
      mesh Thh = Th+Thi;
      
      
      fespace Vh(Th,P1);	
      fespace Vhi(Thi,P1);
      
      matrix Ihi=interpolate(Vh,Vhi, inside=1);// Vh <-Vhi
      cout << rank << " Ihi = "<< Ihi << " ---- " << endl;
      
      // compresse row numbering to min. th comm.
      int [int] Ii(Vhi.ndof),II(Vh.ndof);
      real[int] dhi(Vh.ndof);
      int nn,NN;
      { 
	Vh uh=1.; Vhi ui=1;
	real[int] vi(0:ui[].n-1);
	ui[] =Ihi'*uh[];//';
	ui[] = ui[] ? 1 : 0;
	nn = rint(ui[].sum);
	vi = ui[] ? vi : 1e30;
	vi.sort;
	//	   cout << vi[nn] << " " << vi[nn-1] << endl;
	assert(vi[nn]>1e10 && vi[nn-1] < 1e10);
	vi.resize(nn);
	Ii.resize(nn);
	for(int i=0;i<nn;++i)
	  Ii[i]=vi[i];
	processor(1-rank,comm) << nn;
	processor(1-rank,comm) >> NN;
	assert( nn == NN) ;
	//   II.resize(NN);
	processor(1-rank,comm) <<Ii;
	processor(1-rank,comm) >>II;	     
	//cout << Ii << endl;
	real Ihioo=0;
	try {
	  Ihioo= Ihi(Vh.ndof-1,Ii[nn-1]);
	}
	   catch(...) {;};
	int[int] I(0:Vh.ndof-1);
	Ihi = Ihi(I,Ii);
	//assert(Ihi(Vh.ndof-1,nn-1) == Ihioo);
	// cout << rank << " Ihi = "<< Ihi << " ---- " << endl;
	dhi=1;
	vi=1;
	dhi += Ihi*vi;
	real[int] one(dhi);one=1.;
	dhi = one ./ dhi;
	cout << dhi << endl;
      }
      
      real[int] tosend(NN),torecv(nn);
      real tgv=1e3;
      macro  Grad(u) [dx(u),dy(u)] //
	varf va(u,v)=int2d(Th)(u*v+Grad(u)'*Grad(v)) - int2d(Th)( x*v ) -int1d(Th,1)( N.x*v)  ;	      ;//');
      matrix A=va(Vh,Vh,tgv=tgv);
      real[int] b=va(0,Vh,tgv=tgv);   
      int kiter=0;
      func real[int] projC(real[int] &u)
      {
	verbosity=0;
	processor(1-rank,comm) << (tosend = u(II));
	processor(1-rank,comm) >> torecv;
	//cout << "to send " << tosend << endl;
	u += Ihi*torecv;
	//  u = u .* dhi;
	Vh uu; uu[]=u;
	//     cout << kiter++ << " " << mpirank <<  " ---  " <<  uu(1,0.5) << endl; 	      
	return   u;	      
      }	  
      
      func real[int] projD(real[int] &u)
      {
	verbosity=0;
	processor(1-rank,comm) << (tosend = u(II));
	processor(1-rank,comm) >> torecv;
	u += Ihi*torecv;
	u = u .* dhi;
	Vh uu; uu[]=u;
	//   cout << kiter++ << " " << mpirank <<  " ---  " <<  uu(1,0.5) << endl; 	      
	return   u;	      
      }	
  
      func bool  Plot(real[int] & uu)
      {
	Vh u; u[]=uu;
	Vhi ui;
	if(rank==0)
	  {     
	    processor(1,comm) >> ui[];
	    plot(u,ui,wait=1);
	  }
	else
	  processor(0,comm) << u[];
	return true;
      }
      
      func real[int] DJJ(real[int] &v)
      { 
	verbosity=0;
	// Plot(v);
	v = projD(v);
	real[int] u=A*v;
	u += b; 
	u = projC(u);
	verbosity=1;
	return u;  // return 
      };		  
      
      func real[int] matId(real[int] &u) { 
	verbosity=0;
	u =projD(u);
	verbosity=1;
	return u;};
      
      
      
      
      Vh u=0;
      
      u=0;
      verbosity=1;
      MPIAffineCG(DJJ,u[],eps=1.e-4,nbiter=200,precon=matId,comm=comm);
      projD(u[]);
      Plot(u[]);
      if(rank==0)
	{
	  fespace Vhh(Thh,P1);
	  Vhh uuu,vvv;
	  // u = x , dn(x) = N.x 
	  solve PPPP(uuu,vvv) = int2d(Thh)(uuu*vvv+Grad(uuu)'*Grad(vvv)) - int2d(Thh)( x*vvv ) -int1d(Thh,1)( N.x*vvv)  ; //');
	  cout << " err = " << int2d(Th)( square(uuu-u)) << " " << int2d(Thh)( square(uuu-x)) << endl;
	 // savemesh(Thh,"/tmp/Thh.msh");
	}
    }
}

//  run with MPI:  ff-mpirun -np 2 script.edp
// NBPROC 2

if ( mpisize != 2 ) {
cout << " sorry number of processeur !=2 " << endl;
exit(1);}
verbosity=1;
real pi=4*atan(1);
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=40;
mesh th,TH;

if (mpirank == 0) 
 {
 th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
 cout << " end th  " << endl;
// processor(1) << th ;
// processor(1) >> TH;
}
else
 {
 TH = buildmesh ( e(5*n) + e1(25*n) );
 cout << " end TH  " << endl;
// processor(0) << TH ;
// processor(0) >> th;
 }
broadcast(processor(0),th);
broadcast(processor(1),TH);



fespace vh(th,P1);
fespace VH(TH,P1);
vh u=0,v; VH U,V;
int i=0;

problem PB(U,V,init=i,solver=Cholesky) = 
    int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + int2d(TH)( -V) + on(inside,U = u)  +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(th)( -v) + on(inside ,u = U) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 10; i++) 
{ 
  cout << mpirank << " looP " << i << endl;
  if (mpirank == 0)
  {   
   PB;
   processor(1) << U[];
   processor(1) >> u[];
  }
  else 
  {
   pb;
   processor(0) >> U[];
   processor(0) << u[];
  }
  //  if (mpirank==0)  
  // plot(U,u,wait=true,ps="Uu"+i+".eps");
};
mpiBarrier(mpiCommWorld);// missing FH. Jan/2016 
 if (mpirank==0)  
    plot(U,u,ps="Uu.eps");
    
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

cout << "\n\n empty file remove NSI3d-carac.edp\n\n" << endl;
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4


// other
load "medit"
load "MUMPS_mpi"

real ttgv=-1;
//string ssparams="nprow=1, npcol="+mpisize;


int nn=5;
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);  Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],  labelmid=rmid, 
  reffaceup = rup,     reffacelow = rdown);

real ccc = mpisize/real(Th.nt) ;
Th=change(Th,fregion= min(mpisize-1,int(nuTriangle* ccc+1e-10)));
if(mpirank==0)
for(int i=0;i<=mpisize;++i)
	 cout<< " Volume region  " <<  i << " " << int3d(Th,i)(1.) << endl;
//if(mpirank==0) medit("c10x10x10",Th);
fespace VVh(Th,[P2,P2,P2,P1]);
fespace UUh(Th,[P2,P2,P2]);
fespace Uh(Th,P2);
fespace Ph(Th,P1);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

func fup = (1-x)*(x)*y*(1-y)*16;

Uh u1,u2,u3;
Uh v1,v2,v3;
Ph p,q;

//VVh [uu1,uu2,uu3,up];
real timeI=clock();
real time1=clock();
varf vlaplace1(u1,v1) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) ) + on(2,u1=fup) + on(1,u1=0); //' for emacs 

varf vlaplacenull(u2,v2) = 
  int3d(Th,qforder=3)( Grad(u2)'*Grad(v2) ) + on(2,u2=0) + on(1,u2=0); //' for emacs 

varf vdx(u1,q) = int3d(Th,qforder=3)( -dx(u1)*q );
varf vdy(u2,q) = int3d(Th,qforder=3)( -dy(u2)*q ); 
varf vdz(u3,q) = int3d(Th,qforder=3)( -dz(u3)*q );

varf vmass(p,q) = int3d(Th,qforder=3)( 1e-10*p*q );

matrix M     = vmass(Ph,Ph,tgv=ttgv);
matrix L1    = vlaplace1(Uh,Uh,tgv=ttgv);
matrix Lnull = vlaplacenull(Uh,Uh);
matrix Bx = vdx(Uh,Ph);
matrix By = vdy(Uh,Ph);
matrix Bz = vdz(Uh,Ph);


matrix A = [ [ L1,     0,     0, Bx' ],     
	         [  0, Lnull,     0, By' ],
             [  0,     0, Lnull, Bz' ],
             [ Bx,    By,    Bz,  M  ] ];    //' for emacs


time1=clock()-time1;

real time2=clock();
real[int] b(VVh.ndof);
real[int] xx(VVh.ndof);
{ 
  real[int] b1 = vlaplace1(0,Uh,tgv=ttgv);
  real[int] b2 = vlaplacenull(0,Uh,tgv=ttgv);
  
  for(int ii=0; ii<Uh.ndof; ii++)
    {
      b[ii]=b1[ii];
      b[ii+Uh.ndof]=b2[ii];
      b[ii+2*Uh.ndof]=b2[ii];
    }
  for(int ii=UUh.ndof; ii<UUh.ndof+Ph.ndof; ii++)
    {
      b[ii]=0;
    }
}
time2=clock()-time2;

real timeF=clock();
set(A,solver=sparsesolver,tgv=ttgv);
timeF=clock()-timeF;

real time3=clock();
xx = A^-1*b;
time3=clock()-time3;

for(int ii=0; ii<Uh.ndof; ii++)
    {
      u1[][ii]=xx[ii];
      u2[][ii]=xx[ii+Uh.ndof];
      u3[][ii]=xx[ii+2*Uh.ndof];
    }
  for(int ii=0; ii<Ph.ndof; ii++)
    {
      p[][ii]=xx[ii+UUh.ndof];
    }

timeI=clock()-timeI;

cout << "============= CPU TIME ============" << endl;
cout << " matrix                  " <<  time1 << endl;
cout << " Fact                    " <<  timeF << endl;
cout << " second member           " <<  time2 << endl;
cout << " solve                   " <<  time3 << endl;
cout << "                          ------------" << endl;
cout << " all                     " <<  timeI << endl;
cout << "============= CPU TIME ============" << endl;

//if(mpirank==0) medit("UV2 PV2",Th,[u1,u2,u3],p);

//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

include "getARGV.idp"
load "metis"
load "parmetis"

mesh Th = square(getARGV("-global", 800), getARGV("-global", 800));
fespace Ph(Th, P0);
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    if(mpirank == 0)
        metisdual(part[], Th, getARGV("-lpart", 128));
    broadcast(processor(0, mpiCommWorld), part[]);
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "METIS: " << mpiWtime() - time << endl;
        plot(part, wait = 1, fill = 1, cmm = "METIS");
    }
}
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    parmetis(part[], Th, getARGV("-lpart", 128), communicator = mpiCommWorld, worker = getARGV("-worker", mpisize));
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "ParMETIS: " << mpiWtime() - time << endl;
        plot(part, wait = 1, fill = 1, cmm = "ParMETIS");
    }
}
// NBPROC 4
// ff-mpirun -np 4 DDM-Schwarz-Lap-3d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES2d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer3d.idp"
include "DDM-funcs-v2.idp"
include "cube.idp" 


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",5);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=1; // size of overlap
bool RAS=1; 

if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

string sPk="P2-Lame-3gd";     
func Pk=[P2,P2,P2];

func bool  plotMPIall(mesh3 &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh3,Pk, defPk3, Th, u, allu2, { cmm=cm,nbiso=20,fill=1,dim=3,value=1}); return 1;}


mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,1,1]; 
settt 


int[int,int] LL=[[1,1],[2,1],[1,1]];
real[int,int] BB=[[0,1],[0,5],[0,1]];
int[int] NN=[nloc,nloc*5,nloc]; 
int[int] NNC=[nC,nC*5,nC]; 


settt 
mesh3 Thg=Cube(NN,BB,LL);
mesh3 ThC=Cube(NNC,BB,LL);

fespace VhC(ThC,[P1,P1,P1]); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh3,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh3,Pk,3,[0,1,2],Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)





/* the definition of the Problem .... */


// the definition of the Problem ....
real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
  
varf vPb([u1,u2,u3],[v1,v2,v3])=
  int3d(Thi)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  + int3d(Thi) (gravity*v3)
  + on(2,10,u1=0,u2=0,u3=0)
  ;
  
varf vPbC([u1,u2,u3],[v1,v2,v3])=
  int3d(ThC)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  + int3d(ThC) (gravity*v3)
  + on(2,u1=0,u2=0,u3=0)
  ;

varf vPbon10([u1,u2,u3],[v1,v2,v3])=on(10,u1=1,u2=1,u3=1)+on(2,u1=0,u2=0,u3=0);
varf vPBC(U,V)=on(2,U=0);



real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Lame3,comm,jpart,Whi,Vhc,3,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0,1,2])

Lame3CheckUpdate();
  
Whi [u,u1,u2],[v,v1,v2];
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lame3DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lame3kiter <<  endl;
}

Lame3Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
cout << " On A Fin"<<endl; 
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

/*
   $ - \Delta p = f $   on $\Omega$, 
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{1}$ 
   $ p = gd  $ on $\Gamma_{2}$    
   with de Mixte finite element formulation 

   Find $p\in L^2(\Omega) $  and $u\in H(div) $ such than 
   $$  u - Grad p = 0    $$
   $$ - div u =  f $$
   $$  u. n = (g1d,g2d). n   \mbox{ on } \Gamma_{2}$$
   $$ p = gd  \mbox{ on }\Gamma_{1}$$
   the variationnel form is: 
                                                                                                                   
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{2} $:  

  $ \int_\Omega  u v + p div v -\int_{\Gamma_{1}} gd* v.n  = 0 $ 
 $\forall q\in L^2$:   $  +\int_\Omega q div u = -\int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_2$

*/

// brochet
load "medit"
load "MUMPS_mpi"
include "cube.idp"


real ttgv = 1e30;
string ssparams = "nprow=1, npcol="+mpisize;

    //int[int]  Nxyz=[18,18,18];
    int[int]  Nxyz=[10,10,10];
    real [int,int]  Bxyz=[[0,1],[0,1],[0,1]];
    int [int,int]  Lxyz=[[1,1],[1,1],[2,1]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);
fespace Vh(Th,P1);
fespace Rh(Th,RT03d);
fespace Nh(Th,Edge03d);//  Nedelec Finite element. 
fespace Ph(Th,P0);

func gd = 1.;

func g1n = 2.;
func g2n = 3.; 
func g3n = 4.; 

func f = 1.;

Rh [u1,u2,u3],[v1,v2,v3];
Nh [e1,e2,e3];
[u1,u2,u3]=[1+100*x,2+100*y,3+100*z];

// a + b ^ x = 
/*
  b1    x     a1 + b2*z - b3*y 
  b2 ^  y  =  a2 - b1*z + b3*x
  b3    z     a3 + b1*y - b2*x
*/
real b1=30,b2=10,b3=20;
func ex1=100+b2*z-b3*y;

func ex1x=0.;
func ex1y=-b3+0;
func ex1z=b2+0;

func ex2=200.- b1*z + b3*x ;
func ex2x= b3 +0;
func ex2y= 0. ;
func ex2z= -b1 +0;
func ex3=300.+b1*y - b2*x ;
func ex3x= -b2 +0;
func ex3y= b1 +0;
func ex3z= 0. ;
[e1,e2,e3]=[ex1,ex2,ex3]; 

int k=Th(.1,.2,.3).nuTriangle ;
cout << " u = " << u1(.1,.2,.3)  << " " << u2(.1,.2,.3) << " " << u3(.1,.2,.3) << endl;
cout << " dx u = " << dx(u1)(.1,.2,.3)  << " " << dy(u2)(.1,.2,.3) << " " << dz(u3)(.1,.2,.3) << endl;

cout << " e  = " << e1(.1,.2,.3)  << " " << e2(.1,.2,.3) << " " << e3(.1,.2,.3) << endl;
cout << " ex = " << ex1(.1,.2,.3)  << " " << ex2(.1,.2,.3) << " " << ex3(.1,.2,.3) << endl;


cout << " dx,dy,dz   e1x= " << ex1x(.1,.2,.3)  << " " << ex1y(.1,.2,.3) << " " << ex1z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2x= " << ex2x(.1,.2,.3)  << " " << ex2y(.1,.2,.3) << " " << ex2z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3x= " << ex3x(.1,.2,.3)  << " " << ex3y(.1,.2,.3) << " " << ex3z(.1,.2,.3) << endl;

cout << " dx,dy,dz   e1 = " << dx(e1)(.1,.2,.3)  << " " << dy(e1)(.1,.2,.3) << " " << dz(e1)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2 = " << dx(e2)(.1,.2,.3)  << " " << dy(e2)(.1,.2,.3) << " " << dz(e2)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3 = " << dx(e3)(.1,.2,.3)  << " " << dy(e3)(.1,.2,.3) << " " << dz(e3)(.1,.2,.3) << endl;


cout << " k = " << k << endl;
cout << Rh(k,0) << " " <<Rh(k,1) << " " <<Rh(k,2) << " " <<Rh(k,3) << endl;
cout << " df = " << u1[][Rh(k,0)] <<  " " << u1[][Rh(k,1)]  <<" " << u1[][Rh(k,2)]  << " " << u1[][Rh(k,2)] << endl;
// cout << u1[] << endl;

Vh P,Q;
Ph p,q; 
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //
macro Grad(u) [dx(u),dy(u),dz(u)]  //

// Laplace resolution
real timeLapl = clock();
{
/*
problem laplace(P,Q,solver=CG) = 
  int3d(Th) ( Grad(P)'*Grad(Q)) //') for emacs
  - int3d(Th)(f*Q) 
  + on(1,P=gd) 
  - int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q);
*/
// matrix resolution
varf vlap(P,Q) = int3d(Th) ( Grad(P)'*Grad(Q))+on(1,P=gd); //') for emacs

varf vsdc(P,Q) = int3d(Th)(f*Q) + int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q)+ on(1,P=gd);

matrix Mlap=vlap(Vh,Vh,solver=sparsesolver);
real[int] sdc=vsdc(0,Vh);
/*
varf vtot(P,Q) = int3d(Th) ( Grad(P)'*Grad(Q)) +int3d(Th)(f*Q) + int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q)+ on(1,P=gd); //') for emacs

matrix Mlap = vtot(Vh,Vh,solver=CG);
real[int] sdc = vtot(0,Vh);
*/
P[] = Mlap^-1*sdc;
}
timeLapl = clock()-timeLapl;

// some verification of Boundary condition
fespace RPh(Th,[RT03d,P0]);

varf von1([u1,u2,u3,p],[v1,v2,v3,q])  = 
   int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 - int3d(Th) ( f*q)
 + int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);

RPh [vv1,vv2,vv3,qq];
// some verification Boundary Condition
// and interpolation ...
real[int]  ron=von1(0,RPh);
vv3[]=von1(0,RPh);
cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << endl;
[vv1,vv2,vv3,qq]=[g1n,g2n,g3n,100];
[v1,v2,v3]=[g1n,g2n,g3n];

cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << " " << qq(.1,.2,.001) << endl;
cout << " v : = " << v1(.1,.2,.001)  << " " << v2(.1,.2,.001) << " " << v3(.1,.2,.001)  << endl;

// end of verification of Boundary Condition ... 


/*
problem laplaceMixte([u1,u2,u3,p],[v1,v2,v3,q],solver=sparsesolver,tgv=1e30,sparams="nprow=1, npcol="+mpisize, dimKrylov=400) = 
int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 + int3d(Th) ( f*q)
 - int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);
*/

RPh [uu1,uu2,uu3,pp];
//RPh [v1,v2,v3,q];

real tMatrix=clock();
varf vlaplaceMixte([uu1,uu2,uu3,pp],[v1,v2,v3,q]) = int3d(Th)( pp*q*1e-15+ uu1*v1 + uu2*v2 + uu3*v3 + pp*div(v1,v2,v3) + div(uu1,uu2,uu3)*q )+on(2,uu1=g1n,uu2=g2n,uu3=g3n);
matrix MlaplaceMixte = vlaplaceMixte(RPh,RPh,tgv=ttgv,solver=sparsesolver);
tMatrix=clock()-tMatrix;

real tFact=clock();
set(MlaplaceMixte,solver=sparsesolver,tgv=ttgv,sparams=ssparams);
tFact=clock()-tFact;

real tscd=clock();
varf vsdcLM([uu1,uu2,uu3,pp],[v1,v2,v3,q]) = -int3d(Th) ( f*q) + int2d(Th,1)( gd*(v1*N.x+v2*N.y + v3*N.z) )+on(2,uu1=g1n,uu2=g2n,uu3=g3n);
real[int] sdcLM = vsdcLM(0,RPh);
tscd=clock()-tscd;

real tsolve=clock();
uu1[] = MlaplaceMixte^-1*sdcLM;
tsolve=clock()-tsolve;

cout << "=============================" << endl;
cout << "CPU TIME Lapl: " << timeLapl << endl;
cout << "=============================" << endl;

cout << "=============================" << endl;
cout << "CPU TIME Lapl Mixte:         " << endl;
cout << " matrix         "<< tMatrix << endl;
cout << " factorization  "<< tFact   << endl;
cout << " second menber  "<< tscd    << endl;
cout << " solving        "<< tsolve  << endl;
cout << "=============================" << endl;

//if(mpirank==0){
real errL2=sqrt(int3d(Th)(square(P-pp))) ;
cout << " int 2 x,yz "<<int2d(Th,2)(x) << " " << int2d(Th,2)(y) << " " << int2d(Th,2)(z) << endl;
cout << " int 2 gn "<<int2d(Th,2)(g1n) << " " << int2d(Th,2)(g2n) << " " << int2d(Th,2)(g3n) << endl;
cout << " int 2 U  "<<int2d(Th,2)(uu1) << " " << int2d(Th,2)(uu2) << " " << int2d(Th,2)(uu3) << endl;
cout << " int 2 V  "<<int2d(Th,2)(v1) << " " << int2d(Th,2)(v2) << " " << int2d(Th,2)(v3) << endl;
cout << " int 2 DP "<<int2d(Th,2)(dx(P)) << " " << int2d(Th,2)(dy(P)) << " " << int2d(Th,2)(dz(P)) << endl;
  
cout << "  diff: u Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (uu1*N.x +uu2*N.y + uu3*N.z) ) ) ) <<endl;
cout << "  diff: P Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (dx(P)*N.x +dy(P)*N.y + dz(P)*N.z) ) ) ) <<endl;
cout << " diff err L2 :" << errL2 << endl;
cout << "    P     L2 :" <<sqrt(int3d(Th)(square(P))) << endl;
cout << "    p     L2 :" <<sqrt(int3d(Th)(square(pp))) << endl;
assert(errL2<0.05);
//}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

verbosity=2;
cout << " rank = " << mpirank << " " << " size " << mpisize << endl;
cout << " rank = " << mpiRank(mpiCommWorld) << " " << " size " << mpiSize(mpiCommWorld) << endl;
if(mpisize>4)
  { 
    int[int] procs=[1,4];
    mpiGroup gpr(procs);
    cout << " before  ...  " << mpirank << endl;
    mpiComm comm(gpr);
    cout << " after ...  " << mpirank << "  in : " << bool(comm)   
	 << " rank " << mpiRank(comm) << " / " << mpiSize(comm) <<endl;
    mpiComm  n0comm(mpiCommWorld,mpirank%3,0);// MPI_Comm_split
    mpiComm  n1comm(mpiCommWorld,mpirank%3,1);// MPI_Comm_split
    mpiComm  n2comm(mpiCommWorld,mpirank%3,2);// MPI_Comm_split
    if( ! n1comm)  // not in n1comm 
      {
	// MPI_Intercomm_create constructor 
	mpiComm  nicomm(processor(n1comm,1),processor(n2comm,2),1000); 
	mpiComm  n12comm(nicomm,true);  // MPI_Intercomm_merge cosntructor 
      }
  }

if ( mpirank<2 && mpisize>=2)
  { 
    
    if( mpirank==0) 
      {
	cout << mpirank << " send to 1 " << endl;
	processor(1) << 123456; //  unblock send
      }
    else if (mpirank==1) 
      {
	int k;
	processor(0) >> k; // block recv 
	cout << " recived " << k << endl;
      }
    {
      // UnBlock communication 
      mpiRequest rq;
      if( mpirank==0) 
	{
	  Isend(processor(1,rq),16.);
	  mpiWait(rq);// Send
	}
      else if (mpirank==1) 
	{
	  real  k;
	  Irecv(processor(0,rq),k);
	  mpiWait(rq);// Recv 
	  assert(k==16.);// verif..
	}
    }


    {
    //  Block Communication
      if( mpirank==0) 
	  Send(processor(1),16.);
      else if (mpirank==1) 
	{
	  real  k;
	  Recv(processor(0),k);
	  assert(k==16.);// verif..
	}
    }

  }
int l= mpirank+100;
cout << " l == " << l << " broadcast l from 0   mpirank = " << mpirank << endl;
broadcast(processor(0),l);
cout << " l == " << l << "  mpirank ="<< mpirank << endl;

{
matrix<complex> A;
matrix<complex>[int]  B(10);
if( mpirank==0)
   A=[[1+1i,1i],[0,2-1i],[0,2-1i]];
broadcast(processor(0),A);


if (mpirank==1)
  { A=A+A;
    processor(0) << A;
  }
 else if (mpirank==0)
   processor(1) >>  B[3];

cout << " mpirank = " << mpirank << " A =  " << endl;
if (mpirank==0)
cout <<  " **** " <<  B[3] << endl;

cout << " " <<  norm(A(1,1) - 2-1i) << endl;
mpiRequest rr;
if (mpirank==1) Isend(processor(0,mpiCommWorld,rr),A);
else if (mpirank==0) Irecv(processor(1,mpiCommWorld,rr),B[3]);
mpiWait(rr);
if (mpirank==0)  cout << " B3= " << B[3] << endl;
if (mpirank==1)  cout << " A= " << A << endl;

}

// asyncronous  send/recv  messages....
mpiRequest rr;
real[int] vv(mpirank*mpisize:mpirank*mpisize+mpisize-1),ww(mpisize);
processor(0,rr) << vv;
if(mpirank==0)
  {
    mpiRequest[int] rq(mpisize);
    cout << " --- in ++ " <<mpisize << endl;
    for (int i=0;i<mpisize;++i)
       processor(i,rq[i]) >> ww;
    cout << " --- out ++ " <<mpisize << endl;

    int k=0;
    for (int i=0;i<mpisize;++i)
      {
	int k= mpiWaitAny(rq);
	cout << k << "  mpiWaitAny " << ww << endl; 
      }
  }
cout << " mpiWait " << mpiWait(rr) << " " << mpirank << endl;
//  a way to get data from any proc ... 
processor(0,rr) << vv;
if(mpirank==0)
  {
    for (int i=0;i<mpisize;++i)
      {
	processor(mpiAnySource) >> ww;  // correction jan 2024  mpiAnySource==-2 in mpich 
	cout << " case " << i << "   " <<  ww[0] << endl ;
      }
  }


mpiAlltoall(vv,ww);
cout << " all2all " << mpirank << " :  "  ;
for(int i=0;i<mpisize;i++) 
  cout << vv[i] << " ";
cout << " -> "  ;
for(int i=0;i<mpisize;i++) 
  cout << ww[i] << " ";
cout << endl; 


real s0=mpiWtime();
real[int,int] aa(10,mpisize),bb(10,mpisize);
real [int,int] ss(10,mpisize);
for(int i=0;i<10;i++)
  for(int j=0;j<mpisize;j++) 
    aa(i,j)=100*i+j;
mpiAlltoall(aa,bb);
mpiAlltoall(aa,bb,mpiCommWorld);
mpiAllgather(aa(:,mpirank),ss);
if(mpirank == 1) // just printing the result of one process ..
    cout << " AllGather " << ss << endl;
mpiGather (aa(:,mpirank),ss,processor(0,mpiCommWorld));
if(mpirank == 0)
    cout << " Gather " << ss << endl;

mpiScatter(aa,bb(:,mpirank),processor(0,mpiCommWorld));

cout << " all2all " << mpirank << " " << mpiWtime()-s0 << "s :  "  ;
cout << mpirank << " aa = " << aa << endl;
cout << mpirank << " bb = " << bb << endl;


mpiBarrier(mpiCommWorld);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "MUMPS_mpi"  // load the library dynamic correspond to MUMPS interface
verbosity = 0;
int[int] ICNTL(40); // declaration of ICNTL parameter for MUMPS

// get value of ICNTL from file
if(mpirank == 0)
{
	ifstream ff("ffmumps_fileparam.txt");
	string line;
	getline(ff,line);
	getline(ff,line);
	for(int iii=0; iii<40;iii++){
	ff >> ICNTL[iii];
	getline(ff,line);
	}
}

broadcast(processor(0),ICNTL);

// Given data of MUMPS solver in array lparams(SYM,PAR,ICNTL)
// There is no symmetric storage for a matrix associated with a sparse solver.
// Therefore, the matrix will be considered unsymmetric for parallel sparse solver even if symmetric.
// This fact will be change in new version of FreeFEM
{
    int SYM = 0;
    int PAR = 1;
    matrix A =
      [[ 40,  0,     45,  0, 0],
       [ 0,    12,     0,  0 , 0],
       [ 0,     0,  40,  0, 0],
       [ 12,     0,    0,  22, 0],
       [ 0,     0,    20,  0., 22]];

    // construction of integer parameter for MUMPS
    int[int] MumpsLParams(42);
    MumpsLParams[0] = SYM;
    MumpsLParams[1] = PAR;
    for(int ii=0; ii< 40; ii++) MumpsLParams[ii+2] = ICNTL[ii]; // ICNTL begin with index 0 here

    real[int] xx = [ 1,32,45,7,2], x(5), b(5), di(5);
    b=A*xx;
    if(mpirank ==0) cout << "xx=" << xx << endl;

    set(A,solver=sparsesolver,lparams=MumpsLParams); // We take the default value for CNTL MUMPS parameter

    if(mpirank ==0)  cout << "solving solution" << endl;
    x = A^-1*b;
    if(mpirank ==0) cout << "b=" << b << endl;
    if(mpirank ==0) cout << "x=" << endl; cout << x << endl;
    di = xx-x;
    if(mpirank==0){
    cout << "x-xx="<< endl; cout << "Linf "<< di.linfty << " L2 " << di.l2 << endl;
    }
}

// FFCS - reference value for regression tests
real regtest;

// Read parameter of MUMPS solver in file ffmumps_fileparam.txt

{
matrix A =
      [[ 40,  0,     45,  0, 0],
       [ 0,    12,     0,  0 , 0],
       [ 0,     0,  40,  0, 0],
       [ 12,     0,    0,  22, 0],
       [ 0,     0,    20,  0., 22]];


    real[int] xx = [ 1,32,45,7000,2], x(5), b(5), di(5); // xb(4),bbb(4);
    b=A*xx;
    cout << "b="  << b  << endl;
    cout << "xx=" << xx << endl;

    set(A,solver=sparsesolver);

    cout << "solving solution" << endl;
    x = A^-1*b;

    cout << "b=" << b << endl;
    cout << "x=" << endl; cout << x << endl;
    di = xx-x;
    if(mpirank==0){
    cout << "x-xx="<< endl; cout << "Linf "<< di.linfty << " L2 " << di.l2 << endl;
    regtest=di.l2;
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// time on 4 proc times: compile 0.013393s, execution 2.28842s,  mpirank:0
// time on 1 proc times: compile 0.012316s, execution 4.92302s,  mpirank:0
// NBPROC 4

load "MUMPS_mpi"

verbosity=0; 
real ttgv=1e30;

/*
  Incompressible Navier Stokes 
    with Taylor-Hood Finite element
    No linearity : Newton methode 
    continuation on Reynols Number
    Mesh adaptation 
*/
real  reymax = 9000; // ok < 125000 
mesh Th=square(8,8);
Th=change(Th,fregion=nuTriangle%mpisize); 
fespace Xh(Th,P2);
fespace Mh(Th,P1);
fespace XXMh(Th,[P2,P2,P1]);
XXMh [u1,u2,p];
XXMh [v1,v2,q]; 

macro div(u1,u2) (dx(u1)+dy(u2))//
macro grad(u1,u2) [dx(u1),dy(u2)]//
macro ugrad(u1,u2,v) (u1*dx(v)+u2*dy(v)) //
macro Ugrad(u1,u2,v1,v2) [ugrad(u1,u2,v1),ugrad(u1,u2,v2)]//

solve Stokes ([u1,u2,p],[v1,v2,q],solver=sparsesolver,tgv=ttgv,master=-1) =
    int2d(Th,mpirank)( ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*div(v1,v2)-q*div(u1,u2)
           )
  + on(3,u1=4*x*(1-x),u2=0) 
  + on(1,2,4,u1=0,u2=0);

 Xh uu1=u1,uu2=u2;  
if(mpirank==0)
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[uu1,uu2],wait=0);

Xh psi,phi;


solve streamlines(psi,phi,master=-1) = 
      int2d(Th,mpirank)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
   +  int2d(Th,mpirank)( -phi*(dy(u1)-dx(u2)))
   +  on(1,2,3,4,psi=0);
if(mpirank==0)
plot(psi,wait=0);
int i=0;
real  nu=1./100.;
real dt=0.1;
real alpha=1/dt;



/* NL 
 varf   vNS ([u1,u2,p],[v1,v2,q],solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
            + Ugrad(u1,u2,u1,u2)'*[v1,v2]
           )   
  + on(3,u1=1,u2=0) 
  + on(1,2,4,u1=0,u2=0) 
*/

XXMh [up1,up2,pp];
varf   vDNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th,mpirank)(
            
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
            + Ugrad(u1,u2,up1,up2)'*[v1,v2]
            + Ugrad(up1,up2,u1,u2)'*[v1,v2]
           )
  + on(1,2,3,4,u1=0,u2=0) 
;


varf   vNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th,mpirank)(
          
            + nu * ( dx(up1)*dx(v1) + dy(up1)*dy(v1)
            +  dx(up2)*dx(v2) + dy(up2)*dy(v2) )
            + pp*q*(0.000001) 
            + pp*dx(v1)+ pp*dy(v2)
            + dx(up1)*q+ dy(up2)*q
            + Ugrad(up1,up2,up1,up2)'*[v1,v2]//'
	      )
  + on(1,2,3,4,u1=0,u2=0) 
  ;

for(real re=100;re<=reymax;re *=2)
  { 
    
    real lerr=0.04;
    
    if(re>8000) lerr=0.01;
    if(re>10000) lerr=0.005; 
    for(int step=0;step<2;step++)
      {
		  
	   if( mpirank==0) {
		    Th=change(Th,fregion=1);
			Th=adaptmesh(Th,[u1,u2],p,err=lerr,nbvx=100000);
		    Th=change(Th,fregion=nuTriangle%mpisize);			
		   } 
	    broadcast(processor(0),Th);
      
	//plot(Th,wait=0);
	[u1,u2,p]=[u1,u2,p];
	[up1,up2,pp]=[up1,up2,pp];
	
	for (i=0;i<=20;i++)
	  {
	    nu =1./re;
	    up1[]=u1[];
	    real[int] b = vNS(0,XXMh);
	    matrix Ans=vDNS(XXMh,XXMh,tgv=ttgv);
	    set(Ans,solver=sparsesolver,master=-1);
	    real[int] w = Ans^-1*b;
	    u1[] -= w;
	    if( mpirank==0)  cout << step << " iter = "<< i << "  " << w.l2 <<  " rey = " << re << endl;
	    if(w.l2<1e-6) break; 
	    // uu1=u1;uu2=u2;
	    //plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[uu1,uu2]);  
	    
	  } ;
      }
    uu1=u1;uu2=u2;
    streamlines;
    if( mpirank==0) 
    plot(coef=0.2,cmm="rey="+re+" [u1,u2] et psi  ",psi,[uu1,uu2],wait=0,nbiso=20,ps="cavity-"+re+".ps");  
  }
  
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

include "getARGV.idp"
include "cube.idp"
load "metis"
load "parmetis"
load "medit"
int[int] Nxyz = [getARGV("-global", 50), getARGV("-global", 50), getARGV("-global", 50)];
real[int,int] Bxyz = [[0.0, 1.0], [0.0, 1.0], [0.0, 1.0]];
int[int,int] Lxyz = [[1, 2], [2, 2], [2, 2]];
mesh3 Th = Cube(Nxyz, Bxyz, Lxyz);
fespace Ph(Th, P0);
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    if(mpirank == 0)
        metisdual(part[], Th, getARGV("-lpart", mpisize));
    broadcast(processor(0, mpiCommWorld), part[]);
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "METIS: " << mpiWtime() - time << endl;
        medit("METIS", Th, part);
    }
}
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    parmetis(part[], Th, getARGV("-lpart", mpisize), communicator = mpiCommWorld, worker = getARGV("-worker", mpisize));
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "ParMETIS: " << mpiWtime() - time << endl;
        medit("ParMETIS", Th, part);
    }
}
// NBPROC 4
// ff-mpirun -np 4 DDM-Schwarz-Lap-3d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES2d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer2d.idp"
include "DDM-funcs-v2.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",10);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=1; // size of overlap
bool RAS=1; // select kind of  of $\pi_i$ 


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;


string sPk="P2-Lame-2gd";     
func Pk=[P2,P2];
 
func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh,Pk, defPk2, Th, u, allu1, { cmm=cm,nbiso=10,fill=1,dim=3,value=1}); return 1;}


mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[2,2,2,1]; 
settt 

mesh Thg=square(nloc*4,nloc,[x*4,y],label=l111);
mesh ThC=square(nC*4,nC,[x*4,y],label=l111);//   Coarse Mesh
fespace VhC(ThC,[P1,P1]); // of the coarse problem.. 

BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh,Pk,2,[0,1],Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)





/* the definition of the Problem .... */


// the definition of the Problem ....
real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2)  [dx(u1),dy(u2),(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2) ( dx(u1)+dy(u2) ) // EOM
  
varf vPb([u1,u2],[v1,v2])=
  int2d(Thi)(  
	    lambda*div(u1,u2)*div(v1,v2)	
	    +2.*mu*( epsilon(u1,u2)'*epsilon(v1,v2) ) //')
	      )
  + int2d(Thi) (gravity*v2)
  + on(1,10,u1=0,u2=0)
  ;
  
varf vPbC([u1,u2],[v1,v2])=
  int2d(ThC)(  
	    lambda*div(u1,u2)*div(v1,v2)	
	    +2.*mu*( epsilon(u1,u2)'*epsilon(v1,v2) ) //')
	      )
  + on(1,u1=0,u2=0)
  ;

varf vPbon10([u1,u2],[v1,v2])=on(10,u1=1,u2=1)+on(1,u1=0,u2=0);
varf vPBC(U,V)=on(1,U=0);



real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Lame2,comm,jpart,Whi,Vhc,2,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0,1])

Lame2CheckUpdate();
  
Whi [u,u1],[v,v1];
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lame2DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lame2kiter <<  endl;
}

Lame2Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
---
name: Lac
category: mesh
folder: 3d-examples
---
# Solution of the Radiative Transfer equations in the Chamonix valley

### Companion script of 2 articles published in JCP
	Golse, F., Hecht, F., Pironneau, O., Tournier, P. H., & Smets, D. (2022). Radiative Transfer For Variable 3D Atmospheres.
 arXiv preprint arXiv:2208.06410.  
 https://doi.org/10.1016/j.jcp.2022.111864  
 https://doi.org/10.1016/j.jcp.2023.112531

This script also illustrates the use of the Htool Hierarchical Matrix library to compress a dense matrix stemming from a custom user-defined operator defined in a user C++ FreeFEM plugin. The script uses freefem-mpi to run in parallel.

### About Htool
Htool (https://github.com/htool-ddm/htool) is designed for electromagnetism, acoustics, etc, by boundary element methods.  
Interface with Htool for a new problem, with a new kernel like here, can be done by defining and interfacing a Generator class deriving from the virtual class VirtualGenerator of Htool. This is done here in the freefem plugin `RadiativeTransfer_htool.cpp`.

The file can be compiled by typing in a terminal window

	ff-c++ -auto RadiativeTransfer_htool.cpp

### About RadiativeTransfer_htool.cpp
The "Generator" class contains the description of the kernel; it is created through a user-defined constructor, for example here GenSE which takes for arguments a mesh3, a meshS, two vectors and a new user-defined type KappaGrid (also defined in the plugin); thence, to use it:

	Generator GenSE(Th3,onGamma,ThS,seeface,kappag);

The Generator can then be passed to Htool through the Build() function, which returns the compressed H-Matrix built by Htool from the user-defined copy_submatrix (or get_coef) routine  of the Generator computing the matrix coefficients:

	HMatrix HSE = Build(GenSE,VhS,Vh,eta=100,eps=1e-2,minclustersize=10);

### To launch this script:
for example:

~~~bash
ff-mpirun -np 8 chamonix3.edp -ns -wg -Kmax 1 -fullmesh -n 15
~~~

which means run with 8 cores, no script output, with graphics, with one level of $\kappa$ (grey case) and a mesh refinement defined by n=15.

In order to run the test cases from the JCP article you can select  the chamonix smaller mesh or you can download the original mesh at https://freefem.org/misc/chamonix_100K_surf.meshb,
 load the file in the readmesh command, and run with argument '-fullmesh':
~~~bash
	wget https://freefem.org/misc/chamonix_100K_surf.meshb
~~~
then run with
~~~bash
	 ff-mpirun -np 8 chamonix3.edp -ns -wg -Kmax 9
~~~

### Remark
You are reading this Markdown file which contains explainations and the FreeFEM script. When running Markdown files, FreeFEM selects the code lines enclosed in Markdown FreeFEM code blocks.

For a user friendly environment install the **vscode-FreeFEM** extension in the **VSCode** app. If your code is "not trusted" do Ctrl+Maj+P and look for "trust workspace settings".

## The problem solved
$$
\begin{aligned}
{}&\omega\cdot\nabla I_\nu+{\rho\kappa} I_\nu={\rho\kappa}(1-a)B_\nu(T)+{\rho\kappa} a J_\nu\,,\forall\omega\in S^2,~\forall \nu\in (\nu_{min},\nu_{max})
\\
&I_\nu({x},\omega)\!=\!Q_\nu({x},\omega)\,,\quad\forall\omega\cdot n({x})<0\,,\,\,\forall {x}\in\partial\Omega.
\\
&u\nabla T -\nabla\cdot(\kappa_\theta\nabla T)+\int_{\nu_{min}}^{\nu_{max}}\rho\kappa(1-a)(J_\nu-B_\nu(T))d\nu\,=0,\quad  \forall x\in\Omega\subset R^3,
\\ & \hbox{ where } J_\nu:=\tfrac1{4\pi}\int_{{S^2}}I_\nu d\omega\,,
\end{aligned}
$$
$B_\nu=\nu^3/(e^{-\frac\nu T}-1)$ is the normalized Planck function with $T= T_{Kelvin}/4798$.  The frequencies are also normalized: the physical frequencies are divided by $10^{14}$.

The unknowns are the radiation intensity $(\nu,\omega,x)\mapsto I_\nu(\omega,x)$ and the temperature $x\mapsto T(x)$, $\omega\in S^2$ are the directions of the rays in the unit sphere $S^2$, and $\nu$ is its frequency.  The density $\rho$ is a given function of $x$, usually linear, exponential or constant. To define your own you must select the "constant" predefined type; $\kappa$ is a given function of $\nu$ read from the file $\texttt{kappafile}$. The boundary conditions are applied at points and rays entering the domain ($n$ is the outer normal).

The program handles $u\ne 0$, $\kappa_\theta\ne 0$, but we document only the zero case.

Two cases are of interest:
  1. Infrared radiations enter $\Omega$ from the ground and  no rays enter from the upper atmosphere.
  2. Sunrays enter $\Omega$ from the the top $z=Z$, crosses the atmosphere undisturbed and reflects on the ground. So here too one assumes that the rays are emitted by the ground and no rays come from the top.
  The part of $\partial\Omega$ where the rays enter is called $\Sigma$.

#### Reformulation of the first PDE
If $S$ is the right-hand side of the first PDE, the method of characteristics gives
$$
\begin{aligned}
J_\nu(x)&:=\frac1{4\pi}\int_{S^2} I(x,\omega){d}\omega
=\frac1{4\pi}\int_{S^2} I({x}_\Sigma({x},\omega))e^{-\int_0^{\tau_{{x},\omega}}\kappa({x}-\omega s){d} s}{d}\omega
\cr& + \frac1{4\pi}\int_{S^2}\int_0^{\tau_{{x},\omega}} e^{-\int_0^s\kappa({x}-\omega s'){d} s'} S({x}-\omega s){d} s{d}\omega
%\cr&
=: S^E_\nu({x}) + {\mathcal J}[S]({x}),
\end{aligned}
$$
where
$$
\begin{aligned}&
 S^E_\nu({x}):=
 \frac{1}{4\pi}\int_\Gamma  Q_\nu({x}',\frac{{x}'-{x}}{|{x}'-{x}|})
 \frac{[({x}'-{x})\cdot n({x}')]_+}{|{x}'-{x}|^3} e^{-\int_{[{x},{x}']}\kappa}{d}\Gamma({x}'),
 \cr&
{\mathcal J}_\nu[S]({x}):=
 \frac1{4\pi}\int_{\Omega} S({x}')\frac{e^{-\int_{[{x},{x}']}\kappa}}{|{x}'-{x}|^2}{d}{x}'.
 \end{aligned}
$$

### The iterative method

If $T$  and an old $J_\nu$ are given, then we can compute $S$ and then compute a new $J_\nu$ for all $\nu,x$ and then finally update $T(x)$ from the integral equation of the problem.
The integral equation is solved by a Newton method at every $x$.

To compute the two integrals the integrands $S$ and $Q$ are approximated by  continuous piecewise polynomials on a tetraedral (resp. triangular) mesh of $\Omega$ (resp. $\Sigma$). Then, one computes once and for all $S_\nu^{ij}$ which is $S_\nu^E(x)$ when $Q_\nu$ is replaced by the finite element hat function associated with vertex $x^i$ and similarly for ${\mathcal J}_\nu$, producing ${\mathcal J}_\nu^{ij}$ .  Notice that $S_\nu$ is a rectangular matrix while $ {\mathcal J}_\nu$ is a square matrix.

These matrices are stored as ${\mathcal H}$-matrices to reduce the computing time to $O(n\log n)$ where $n$ is the number of vertices in the mesh.

## The freefem script
The following libraries are used

~~~freefem
// NBPROC 8
// PARAM -ns -wg -Kmax 9
load "bem"  // boundary element methods for electromagnetism (Htool)
load "RadiativeTransfer_htool"  // contains the functions specific to this application program in C++
load "qf11to25"  // needed for better quadrature rules of integrals
load "medit"  // for 3D graphics
load "iovtk"  // interface to vtk
load "mmg"  // for mesh adaptivity
load "shell"  // interface with unix terminal
load "gsl" // gnu scientific library
load "ffrandom" // for random functions
srandomdev(); // for a random def of kappa and a

include "getARGV.idp" // to specify parameters in the terminal command

verbosity=0;  // minimal
~~~

There are two types of parameters to define: physical quantities and algorithmic parameters.

### Physical Parameters
- The light source from the ground is
  $$
  Q_\nu(x,\omega) =Q_0(\beta+(1-\beta){\bf 1}_{z<s_{al}}) \cos(\omega\cdot n)B_\nu(T_{sun})\cos\gamma
  $$
- $\gamma$ is the angle of incidence of the light source (to study the difference between morning and evening)
- $Q_0=2.10^{-5}$ is its intensity (to understand why the sun light comes from the ground, see the paper)
- $T_{sun}=1.209$ is the scaled sun temperature (5800K before rescaling)
- $ (\beta+(1-\beta){\bf 1}_{z<s_{al}})$ is a factor to account for snow on the ground above altitude $s_{al}$
- The scattering coefficient depends on the presence of a cloud, assumed to be in a band $x\in[1.5-\sqrt{0.5},1.5+\sqrt{0.5}]$ between altitude $cloud_m$ and $cloud_M$.  It is possible to have a random density/scattering in the cloud.
 Here the scattering coefficient is $a_{scat}{\bf 1}_{z\in(cloud_m,cloud_M)}{\bf 1}_{(x-1.5)^2<0.5}$.

### Algorithmic Parameters
- `Newton` is the maximum number of Newton iterations for the temperature equation
- `heat`: the temperature equation is the heat PDE with thermal diffusion
- `Niter` is the number of global iterations $T\to I\to T$

~~~freefem
/********************* SCRIPT PARAMETERS *********************/
int dc = 1, 						// samples every dc points in the nu integrals (speedup with dc>1, danger, do not change)
Newton = 40,						// max Newton iter for the temp eq
n = getARGV("-n", 13),				// controls the number of vertices in the mesh
Niter = 7,  						// outer loop for convergence
Kmax = getARGV("-Kmax",1), 		    // 1 if kappa constant // in [2,10] otherwise
gamma = getARGV("-gamma", 0), 		// incidence of sunlight (0 is vertical, 1 is morning and -1 evening)
heat = 0, 							// if 1, temperature eq is solved
nosnow = getARGV("-nosnow", 0), 	// 0 or 1 if no snow
cloud = getARGV("-cloud",0), 		// 0 or 1 if cloud
altkappa = getARGV("-altkappa", 0);	// if 1 (resp-1) Kappa is changed in a range for CO2 (resp CH4)

real sal = 10*nosnow+0.25, beta=0.3, 	// snow altitude limit and snow albedo
	Tsun=1.209, Q0=2.0e-5, sigma=sqr(sqr(pi))/15; // the Sunlight

real ascat =0, cloudm=0.3, cloudM=0.7; // scattering in altitude [zscalm,zscalM]
~~~

### Names of I/O files

There are two input files and several output files.

One input file, `geminitransmittance.txt`, defines $\nu\mapsto\kappa_\nu$ pointwise, the other defines `Thf` the mesh and altitude of the ground (see `readmeshS`).

All output file paths are relative to the `basedir`; their names reflect the test case. Hence output files from one case do not overwrite outputs of another cases if the cases are different.

~~~freefem
/********************* OUTPUT FILES *********************/
string basedir("chamonix-output/");
if(mpirank==0) mkdir(basedir);
string tempestr("noon");
if (gamma == 1) tempestr = "morning";
if (gamma == -1) tempestr = "evening";
if (nosnow) tempestr = tempestr + "nosnow";
if (cloud) tempestr = tempestr + "cloud";
if (ascat>0)  tempestr = tempestr + "Scatt";
if (heat) tempestr = tempestr + "heat";
if (Kmax > 1) tempestr = tempestr + "K";  // res file non grey have a xx.K
if (Kmax > 1 && altkappa>0) tempestr = tempestr + "K";  // res file have a xx.KK
if (Kmax > 1 && altkappa<0) tempestr = tempestr + "KK"; // res file have a xx.KKK
int mem = storageused(); // memory used at this stage
~~~

### Read the mesh which defines the ground

The file which defines the mesh must be next to this .md file.  For the format of a surface mesh see the freefem documentation.
It contains a triangulation where the vertices have 3 coodinates (x,y,z).

To construct the 3d mesh above `Thf` it is convenient to use an auxiliary mesh which is `Thf` where all vertices are at altitude zero.

~~~freefem
/********************* BUILD THE MESH *********************/
mesh3 Th3;
mesh Th2;
if (mpirank == 0)
{
	// read the surface mesh of the Chamonix valley:
	meshS Thf = readmeshS("chamonix_surf.meshb");
	//meshS Thf = readmeshS("chamonix_100K_surf.meshb"); // uncomment to use the original fine mesh ; you can download it at https://freefem.org/misc/chamonix_100K_surf.meshb
	// build the volume mesh above the valley:
	real[int] bb(6);
	boundingbox(Thf, bb);
	int nn = 5*n;

	Th2 = movemesh(Thf,transfo=[x,y]); // flatten the mesh, will be the input of buildlayers
	fespace Vhf(Thf, P1);
	fespace Vh2(Th2, P1);
	Vhf zzf = z;
	Vh2 z2;
	z2[] = zzf[]; // get the altitude as a P1 function on the flattened 2D mesh
	
	bool fullmesh = usedARGV("-fullmesh") != -1; // use the original fine adapted surface mesh ; beware, expensive case !
	if (!fullmesh) Th2 = square(nn, nn, [bb[0]+x*(bb[1]-bb[0]),bb[2]+y*(bb[3]-bb[2])]);
	z2 = z2;

	real zmin = z2[].min, zmax = 1;
	plot(z2);

	int[int] l23 = [1,1,2,2,3,3,4,4], lup = [0,6], lbot = [0,5];
	real hx = (bb[1]-bb[0])/nn;
	int nnz = fullmesh ? 5 : (zmax-zmin)/hx;

	func cc = (zmax-z2)/(zmax-zmin);
	Th3 = buildlayers(Th2, coef=cc, nnz, zbound=[z2,zmax],
		labelmid=l23, labelup=lup, labeldown=lbot);
	
	int[int] reqt=[5];
	
	if (fullmesh) Th3 = mmg3d(Th3,requiredTriangle=reqt,hmin=hx,hmax=hx,hgrad=1.5,mem=8192);
}
~~~

### Define the finite element spaces

The finite element space of degree 1 on the volume mesh (tetrahedra) is called `Vh`.
The finite element space of degree 1 on the surface mesh (triangles) is called `VhS`.
It contains all radiative boundaries of the `Th` (in this case, the ground).

~~~freefem
broadcast(processor(0),Th3);
broadcast(processor(0),Th2);

real[int] bounds(6); // Domain bounds
boundingbox(Th3, bounds);
if (mpirank == 0) cout<< "x,y,z bounds: " << bounds << endl;

int[int] labRT = [5]; // emitting boundary
meshS ThS = extract(Th3, label=labRT, angle=pi); // extract as a surface mesh
if (mpirank == 0) cout << "Number of Vertices = " << Th3.nv << endl;
fespace Vh(Th3, P1);
fespace VhS(ThS, P1);
~~~

### Define the absorption $(\nu,x)\mapsto\rho(x)\kappa_\nu$.

The absorption is the product of the density $\rho(x)$ and a function $\nu\mapsto\kappa_\nu$.

For $\kappa_\nu$ we rely on a file read from the Gemini experiment web site. The number of lines in the file must be specified (more convenient than an EOF test). The file has 2 columns, one for $\nu[k]$ and one for the transmittance $1-\kappa[k]$ which is capped in $(0,1)$. The last 200 values are entered analytically because the data from Gemini are not complete.

To account for greenhouse gases we change the gemini data in given $\nu$-ranges, according to the value of `altkappa`.

~~~freefem
/********************* READ KAPPA[nu] *********************/
int Nnu = 483; // number of frequencies, will be augmented by 200
real[int] nu(200+Nnu), kappa(200+Nnu);
ifstream kappafile("geminitransmittance.txt");
int j =- 1;
while (j++ < Nnu-1) {
	real auxx, kappaux, nuj;
	kappafile >> nuj >> kappaux >> auxx >> auxx >> auxx;
	kappa[200+j] = 1 - min(1.,max(0.,kappaux)); // necessary
	nu[200+j] = nuj;
	if (altkappa<0 && nuj > 3/4. && nuj < 3/3.) kappa[200+j]=1;
	if (altkappa>0 && nuj > 3/18. && nuj < 3/14.) kappa[200+j]=1;
}
for (int j=0; j<200; j++) { nu[j] = 0.01+(nu[200]-0.01)*j/200.; kappa[j] = kappa[200]; }
Nnu += 200;
real kappa0=0;
for (int j=0; j<Nnu; j++) kappa0 += kappa[j]/Nnu;  // mean kappa is used in Newton steps
// absorption is kappa[nu]*rhof(x,y,z), but integrals are sampled by kappaApprox[K]*rhof(x,y,z)
real[int] kappaApprox(Kmax); // kappa(nu,x) = kappaApprox(K(nu))*rhof(x)  cf Lebesgue integral
for (int K=0; K<Kmax; K++) kappaApprox[K] = 1-real(K)/Kmax; // grey case: kappaApprox[0]=1

int[int] kappaInK(Kmax); // detect if kappa in (kappaApprox[K],kappaApprox[K-1])
kappaInK[0] = (Kmax==1); // used for the grey case
for (int K=1; K<Kmax; K++) {
	kappaInK[K]=0;
	for (int k=0; k<Nnu-dc-1; k+=dc) // every dc points
	if ( (kappa[k]>kappaApprox[K]) && (kappa[k]<=kappaApprox[K-1]) )
		kappaInK[K] = 1;
	if (mpirank == 0)
		cout << K << "K kappaApprox " << kappaApprox[K] << " " << kappaInK[K] << " " << kappaApprox[K-1] <<endl;
}
~~~

The last block above is a piecewise constant interpolation of $\nu\mapsto\kappa_\nu$ in `K` levels. `kappaApprox[K]` is the value of the `K`$^{th}$ level.
- if `kappaInK[K]` $=0$ then there exists a `k` such that `kappa[k]` $\in [$
`kappaApprox[K-1]`, `kappaApprox[K]`$]$.
- When needed `kappa[k]`  can be approximated by `kappaApprox[K-1]` where `K` is such that `kappaApprox[K-1]` $\leq$ `kappa[k]` $<$ `kappaApprox[K]`.

Now the x-dependency of the absorption is defined. It is the product of the density `rhof` and the change of density in the cloud.

The **scattering** coefficient is  defined below in `scatf`.

~~~freefem
/********************* DEFINE the x-dependence of kappa, called rho *********************/

/************************ Generation of cloud density *********************************/
fespace Vh2(Th2,P1);
Vh2 xi;
if(mpirank==0) {
	real sigma=0.85, mu=2.7;
	real musig2=mu+sigma*sigma;
	real aux = 1-(mu*mu+2*sigma*sigma*log(sigma))/musig2/musig2;
	gslrng ffng;
	gslrngset(ffng,random());

	for(int i=0;i<Th2.nv;i++)
		xi[][i]=0.125*musig2*(1- sqrt(aux+pow(gslrangaussian(ffng,1)*sigma/musig2,2))); //average(xi)=0.5
}
broadcast(processor(0),xi[]);

/*****************************************/
func rhof = 0.5*(1-z/2) * (1 + (Kmax > 1)) * (1 + cloud * xi*(z>cloudm)*(z<cloudM)*(sqr(x-1.5)<0.5));//(sqr(x-1.5)+sqr(y+1.5)<0.5)) );
xi = (1 + cloud * (1+xi*(sqr(x-1.5)<0.5))); // only to plot
Vh rhox = rhof; // rhox is the P1 function equal to rhof
int[int] fforderr = [1];
if (mpirank == 0) savevtk(basedir+tempestr+"_volkappa.vtk",Th3,rhox,order=fforderr);
if(mpirank==0) {plot(xi,value=1); plot(rhox,value=1,wait=0);} //medit("Cloud",Th3,rhox);}

func scatf = ascat*(z>cloudm)*(z<cloudM)*(sqr(x-1.5)<0.5);

Vh scatx=scatf; // rhox,scatx is the P1 function equal to rhof, scatf
real surf = int3d(Th3)(1.);
if (mpirank == 0) cout << "arithmetic mean of kappa(nu)*rhof = " << kappa0*int3d(Th3)(rhox)/surf << endl << endl;
~~~

The wind velocity could be read from files as a result of a Navier-Stokes simulation or defined by hand.

~~~freefem
/********************* DEFINE WIND *********************/
Vh u1, u2, u3, dT, dTh;
/*
{
ifstream velocity1("maillageCham/velocity1.txt");
ifstream velocity2("maillageCham/velocity2.txt");
ifstream velocity3("maillageCham/velocity3.txt");
velocity1 >> u1[];
velocity2 >> u2[];
velocity3 >> u3[]; 
if (mpirank==0) plot(u2, wait=1);
}
*/
u2 = 1*z; u1 = 0; u3 = 0;
~~~

### Surface integral vectors

Some integrals on the surface are computed.  For instance, `seeface1` is a vector on the vertices `i` of `ThSof` an integral on `ThS` -computed with mass lumping- of the vertical component of the normal `Ns.z` + `gamma*(Ns.x -..)` times `Q0S` times the $P^1$- hat function associated to vertex `i`.

~~~freefem
/********************* Light intensity is x cos(angle with normal)^-. Stored in seeface *********************/
VhS Q0S = Q0*(beta+(1-beta)*(z<sal)); // Light intensity modified by snow
varf vseeface1(u,v) = int2d(ThS,qft=qf1pTlump)(Q0S*(Ns.z+gamma*(Ns.x-0.2*Ns.y))*v/sqrt(1+0.04*gamma*gamma));
real[int] seeface1 = vseeface1(0,VhS);
varf vlump(u,v) = int2d(ThS,qft=qf1pTlump)(v);
real[int] blump = vlump(0,VhS);
seeface1 ./= blump;
for [i, bi : seeface1] bi = -min(bi,0.);

varf vseeface2(u,v) = int2d(ThS,qft=qf1pTlump)(Q0S*(-1+gamma*(0-0.2*0))*v/sqrt(1+0.04*gamma*gamma));
real[int] seeface2 = vseeface2(0,VhS);
seeface2 ./= blump;
for [i, bi : seeface2] bi = -min(bi,0.);

real[int] seeface = [seeface1, seeface2];
~~~

### Interpolation matrix

The rectangular matrix `R` allows to find where on surface S is a point given in the 3D FE space.
`[I,J,K]` refers to a compact definition of a matrix storing the row, column indices and coefficients when `K(I,J)` $\neq 0$. `onGamma` contains the index of the surface vertex corresponding to the same vertex of index `J[i]` in the volume mesh.

###
~~~freefem
/********************* Interpolation operator from Th3 to ThS *********************/
Vh onGamma;
{
       onGamma[] = -1;
       matrix R = interpolate(VhS,Vh);
       int[int] I(1),J(1);
       real[int] K(1);
       [I,J,K] = R;
       for (int i=0; i<I.n; i++)
               if (K[i] > 0.5) onGamma[][J[i]] = I[i];
}

/********************* Define truncated volume mesh Th3t (without the surface) *********************/
// Th3t will be used to remove surface-surface interactions from the boundary operator,
// as they will be treated separately.

fespace Ph0(Th3,P0);
varf vGamma(u,v) = int3d(Th3)(u*v);
matrix RGamma = vGamma(Vh, Ph0);
Ph0 tGamma;
Vh onG = (onGamma == -1 ? 0 : 1);
tGamma[] = RGamma*onG[];
mesh3 Th3t = trunc(Th3, tGamma == 0);
fespace Vht(Th3t,P1);

matrix Rt = interpolate(Vht,Vh); // restriction matrix from Th3 to Th3t
~~~

### Computation of the ${\mathcal H}$-matrices

For each level `K` there are two ${\mathcal H}$-matrices, one called `HVolume[K]` and the other called `HSE`. `HVolume[K]` needs to be stored and applied at each iteration, while `HSE` is computed and used on the fly for each `K` to compute `SE[K]`, the discrete counterpart of $ S^E_\nu$.  
The dynamic plugin `RadiativeTransfer_htool.dylib` contains the functions necessary for their construction.  
As the elements contain an integral of $\kappa$ on a segment, there is an interpolation of $\kappa$ on a uniform square grid to speed up the computations (see the type `KappaGrid`).  
In the end,
$$
\text{HSE}(i,j) = \int_\Sigma w^j(x')((x^i-x').n) \exp(-\int_{(x^i,x')}{\bf 1}_{\kappa(\nu,x'')\approx \kappa_{approx}[K]}d x'')/|x^i-x'|^3 d\Sigma(x'),
$$
where $x^i$ is the vertex $i$ of the volume mesh.

Similarly,
$$
\text{HVolume[K]}(i,j) = \int_\Omega w^j(x') \kappa(nu,x') \exp(-\int_{(x^i,x')}\kappa_{approx}[K]{\bf 1}_{\kappa(nu,x'')}d x'')/|x^i-x'|^2 dx'
$$

~~~freefem
/********************* BUILD H-Matrices *********************/
verbosity = 1;
HMatrix[int] HVolume(Kmax); // The Volume integral matrices
Vh[int] SE(Kmax); // The surface integral vector operator

Vht SEt;
VhS ones = 1;

for (int K=min(Kmax-1,1); K<Kmax; K++)
if (kappaInK[K]) {
	if (mpirank == 0) cout<<"building surface matrix K= "<<K<<endl;
	KappaGrid kappag(bounds,0.01,kappaApprox[K-(K>0)]*rhof);

	// We use the truncated volume mesh Th3t (without the surface) for the boundary operator,
	// as we use an analytic formula for surface-surface interactions
	Generator GenSE(Th3t,ThS,seeface,kappag);
	HMatrix HSE = Build(GenSE,VhS,Vht,eta=100,eps=1e-2,minclustersize=10);
	if (mpirank == 0) cout << HSE.infos << endl; 
	display(HSE);
	SEt[] = HSE*ones[]; // SE = \int_∑ ((x-x').n) exp(-\int_(x,x')kappa(nu,x'))/|x-x'|^3
	SE[K][] = Rt'*SEt[]; // extend the result from truncated Vht to Vh
	// use an analytic formula for surface-surface interactions:
	for [i,bi:SE[K][]] if (onGamma[][i] > -0.5) bi = 0.25*seeface1[int(onGamma[][i]+0.5)];

	if (mpirank == 0) cout<<"Building volume matrix K= "<<K<<endl;

	Generator GenVolume(Th3,kappag);
	HVolume[K] = Build(GenVolume,Vh,Vh,eta=100,eps=1e-2,minclustersize=10);
	if (mpirank == 0) cout << HVolume[K].infos << endl; 
	display(HVolume[K]); // = \int_Omega kappa(nu,x') exp(-\int_(x,x')kappa(nu,x'))/|x-x'|^2
}
~~~

### Non constant thermal diffusion

~~~freefem
/********************* OUTER LOOP *********************/ 
Vh T = 0.01; // initial value of the temperature for iterations
Vh res, sT4=sqr(sqr(T)), J=sigma*sT4;
// This is when kappatheta>0
real kappatheta=0.02;
problem heatedp(dT, dTh) = int3d(Th3) (0.02*(dx(dT)*dx(dTh)+dy(dT)*dy(dTh)+dz(dT)*dz(dTh))
		+ (u1*dx(dT)+u2*dy(dT)+u3*dz(dT))*dTh + 15*dT*dTh)
	+ int3d(Th3) (kappatheta*(dx(T)*dx(dTh)+dy(T)*dy(dTh)+dz(T)*dz(dTh)));
~~~

### The grey case

If $\kappa$ is independent of $\nu$ Stefan's law can be used because $\int_0^\infty B_\nu(T)d\nu=\sigma T^4$ where $\sigma$ is the Stefan constant.
In this case $T$ can be found explicitly from the temperature equation.

~~~freefem
if (Kmax == 1) { /********************* GREY CASE kappaApprox[0] = 1 *********************/
	for (int niter=0; niter<Niter; niter++) {
		sT4 = sigma*T*T*T*T*(1-scatx)+scatx*J; // results are independent of scatx
		res[] = HVolume[0]*sT4[];
		J[] = SE[0][];
		J = J*sigma*sqr(sqr(Tsun));
		J[] += res[];
		T = sqrt(sqrt(abs(J/sigma)));
		if (heat) {
			heatedp;
			T = T + dT;
		}
		sT4 = sT4-J;
		if (mpirank == 0) {
			//plot(J, cmm="J at iter "+ niter, value=1, fill=1);
			plot(sT4, cmm="sT4 at iter "+ niter , value=1, fill=1);
			//plot(T, cmm="T at iter "+ niter, value=1, fill=1);
		}
	}
}
~~~

### The general case

~~~freefem
else { /********************* General Nonlinear loop *********************/
	// The method:
	// Let 4 pi J(nu,x) = int_om I dw = \int_∑(x') exp(-kappa(nu,x')|x'-x|)(angle(N,x'-x))^2Bnu(nu,Tsun)d∑ 
	// 							+ \int_O(x') exp(-kappa(nu,x')|x'-x|)/|x'-x|^2 Bnu(nu,T(x'))dx'
	// get T(x) from : \int_0^∞ kappa(nu,x) Bnu(nu,T(x)) dnu = \int_0^∞ kappa(nu,x)J(nu,x)dnu =: J by Newton
	// nu-integrals as double sum: \int_0^∞ f(kappa(nu),nu)=\sum_K=1..Kmax \sum_k f(nu_k,kappa=K/Kmax)dnu_k
	// = \sum_K=1..Kmax H(kappa)*\sum_k F(K/Kmax,nu)dnu_k   when f=H(kappa)*F(kappa,nu)

	// Note: function Bnu is defined in the C++ plugin instead in order to speed up computations. The function corresponds to:
	// func real Bnu(real nu, real T) {return nu*nu*nu/(exp(nu/T)-1);}

	real[int] BnuTsun(Nnu);
	for (int k=0; k<Nnu-1 ;k++) BnuTsun[k] = Bnu(nu[k],Tsun); // aim is to speed up below
	Vh aux,aux2,aux3, bux, pres, paux = 0;
	Vh[int] Jold(Kmax); for (int k=0; k<Kmax;k++) Jold[k]=J;

	real[int] compint(Vh.ndof);
	varf vint(u,v) = int3d(Th3)(v);
	compint = vint(0,Vh);

	// cut expensive loops into MPI slices for parallel computation
	int[int] sizes(mpisize);
	int[int] offsets(mpisize);
	offsets = 0;
	int chunksize = Vh.ndof%mpisize == 0 ? Vh.ndof/mpisize : Vh.ndof/mpisize + 1;

	for (int i = 0; i < mpisize; i++)
	if (i != mpisize - 1) {
		sizes[i] = chunksize;
		offsets[i] = i*chunksize;
	}
	else {
		sizes[i] = Vh.ndof - i*chunksize;
		offsets[i] = i*chunksize;
	}

	int ii = offsets[mpirank];
	real[int] chunkbuff(sizes[mpirank]), chunkbuff2(sizes[mpirank]), chunkbuff3(sizes[mpirank]);
~~~

## The main iteration loop

Again here two integrals are computed for each level $\kappa_{approx}[K]$ of $\kappa$.
Notice that all computations are done in parallel on chunks of global vectors like  `res[]`, `aux[]`. Thence at some points the chunks need to be gathered to the global vectors, when used as input for ${\mathcal H}$-matrix vector multiplies.

~~~freefem
	for (int niter=0; niter<Niter; niter++){ // Nonlinear loop
		bux=0; J=0;
		for (int K=1; K<Kmax; K++)
		if (kappaInK[K]) {
			real auxs = 0;
			chunkbuff2 = 0;
			chunkbuff3 = 0;
			for (int k=0; k<Nnu-dc-1; k+=dc)  // every dc points, dc can be changed
			if ( (kappa[k]>kappaApprox[K]) && (kappa[k]<=kappaApprox[K-1]) ) {    
				real dnu = nu[k+dc] - nu[k];
				for [i,bi:chunkbuff] bi = rhox[](i+ii)*Bnu(nu[k],T[][i+ii]);
				chunkbuff3 += dnu*kappaApprox[K-1]*chunkbuff ; // = int_{kappa[k]=K} kappa Bnu(nu,T(x)) dnu
				if(ascat){
					for [i,bi:chunkbuff] bi = rhox[](i+ii)*Jold[K][][i+ii];
					chunkbuff2 += dnu*kappaApprox[K-1]*chunkbuff; //  = int_{kappa[k]=K} kappa Jold_nu dnu
				}
				auxs += BnuTsun[k]*dnu; // auxs = Q0*int_{kappa(nu)=K} Bnu(nu,Tsun) dnu
			}
			if(ascat) mpiAllgatherv(chunkbuff2, aux2[], mpiCommWorld, sizes, offsets); // aux2= int_K (kappa Jold) dnu
			mpiAllgatherv(chunkbuff3, aux3[], mpiCommWorld, sizes, offsets); // aux3=int_K (kappa Bnu(nu,T(x)))dnu
			if(ascat) aux = (1-scatx)*aux3 + scatx*aux2; // aux = int_K ( (1-scat)Bnu + scat Jold )kappa dnu
				 else aux=aux3;
			res[] = HVolume[K]*aux[];
			for [i,bi:chunkbuff] bi = res[][i+ii] + SE[K][][i+ii]*rhox[][i+ii]*kappaApprox[K-1]*auxs;
			mpiAllgatherv(chunkbuff, res[], mpiCommWorld, sizes, offsets);
			bux[] += aux3[]; // bux = \sum_K  \int_{kappa(nu)=K} kappa_K Bnu(nu[k],T(x))dnu
			J[] += res[]; // J(x) =  \sum_K  int_{kappa(nu)=K} kappa_K exp(-kappa|x'-x|)/|x'-x|^2 Bnu(nu,T(x)) dnu
			Jold[K][] = res[];
		}
		bux = bux - J;
		if (mpirank == 0) {
			//plot(J, cmm="J at n="+ niter ,value=1,fill=1);
			plot(bux, cmm="Bnu-J at n = "+ niter ,value=1, fill=1); // J = bux => converged
		}
~~~

### Quasi-Newton iterations

The problem is of type $F(T)=0$ for each $x$.  The derivative $F'$ is computed as if it was the grey case, i.e. $(\sigma T^4)'=4\sigma T^3$. Hence
$$
T^{m+1} = T ^m - \frac12\frac{bux-J}{4\sigma\rho\kappa_0 {T^m}^3}
$$
where $F(T^m)=bux-J$.  The $\frac12$ is to slow down the iterations.

~~~freefem
		int newton = 0; // Newton iterations for T

		for [i,bi:chunkbuff] bi = sqrt(sqrt(abs(J[][i+ii]/sigma/rhox[][i+ii]/kappa0))); // guess to start Newton
		mpiAllgatherv(chunkbuff, T[], mpiCommWorld, sizes, offsets);

		pres = abs(bux/J-1);
		while (pres[]'*compint > 0.0001*surf && newton < Newton) {
			if (newton>0) { // compute bux with new T
				chunkbuff2 = 0; 
				for (int k=0; k<Nnu-dc-1; k+=dc) { 
					real dnu = nu[k+dc]-nu[k];
					for [i,bi:chunkbuff] bi = rhox[](i+ii)*kappa[k]*Bnu(nu[k],T[][i+ii]);
					chunkbuff2 += dnu*chunkbuff;
				}
				mpiAllgatherv(chunkbuff2, bux[], mpiCommWorld, sizes, offsets);
			}
			pres = bux/J-1;
			if (mpirank == 0) {
				if (Kmax == 1) {
					paux = rhox*kappaApprox[0]*sigma*T^4; 
					cout << niter << " <- niter, error ->" << int3d(Th3)(bux/paux-1)/surf << endl;
				} 
				else 
					cout << niter << " <- niter, newton ->" << newton << " error = " << pres[]'*compint <<endl;
			}
			pres = abs(bux/J-1);
			// bux=paux; T=sqrt(sqrt(J/(sigma*rhox*kappaApprox[0]))); // error check in the grey case
			// T = T - 0.5*(bux-J)/(4*sigma*rhox*kappa0*T*T*T);
			// Newton relaxation parameter 0.5
			for [i,bi:chunkbuff] bi = T[][i+ii] - 0.5*(bux[][i+ii]-J[][i+ii])/(4*sigma*rhox[][i+ii]*kappa0*T[][i+ii]*T[][i+ii]*T[][i+ii]);
			mpiAllgatherv(chunkbuff, T[], mpiCommWorld, sizes, offsets);
			if (newton++ > Newton) bux=J;
		}

		if (heat) {
			heatedp; T=T + dT;
		}

		plot(T, cmm="T at iter = "+ niter, value=1, fill=1);
	}
	// End of non linear loop
~~~

## Graphics and other outputs

### Display of $\nu\mapsto J_\nu$

When $K=9$ (which is the maximum we did) $\nu\mapsto J_\nu$ is printed at point $(x,y,z)=(0.3,1.5,-1.5)$.

~~~freefem
	/********************* Display J_nu(x,y,z) *********************/
	if (Kmax == 9) {
		string lightstr(basedir+tempestr+"light.txt");
		ofstream myfile2(lightstr);
		for (int k=0; k<Nnu-dc-1; k+=dc) { // every dc points, can be changed
			int K = -1; 
			for (int K1=1; K1<Kmax; K1++)
			if ( (kappa[k]>kappaApprox[K1]) && (kappa[k]<=kappaApprox[K1-1]) ) K = K1;
			if (K > 0) {
				for [i,bi:chunkbuff] bi = Bnu(nu[k],T[][i+ii]);
				mpiAllgatherv(chunkbuff, res[], mpiCommWorld, sizes, offsets);
				bux[] = HVolume[K]*res[];
				for [i,bi:chunkbuff] bi = bux[][i+ii] + BnuTsun[k]*SE[K][][i+ii];
				mpiAllgatherv(chunkbuff, J[], mpiCommWorld, sizes, offsets);
				if( k>380 && k<389 ) Jold[k-380]=1e5*J; // for graphics
				if (mpirank == 0) myfile2 << 3/nu[k] << " " << 1e5*J(0.3,1.5,-1.5) << " " << kappa[k]
					<< " " << int(kappa[k]*10+0.5)/10. << " " << kappaApprox[K-1] << " " << K-1 << " " << k << endl;
			}
		}
	}
}
int tmem = storagetotal(); // max memory used at this stage
~~~

### Display of the temperature in Celcius degrees

- 1D plot of $z\mapsto T[x_0,y_0,z]$ at $x_0=1.5,y_0=-1.5$ which is approximately at the city of Chamonix.

~~~freefem
/********************* GRAPHICS *********************/
real hx=bounds[1]-bounds[0], hy=bounds[3]-bounds[2], hz=bounds[5]-bounds[4]; // domain size
mesh Tp = square(10*n, 5*n, [bounds[2]+hx*x, bounds[4]+hz*y]);
fespace Vp(Tp,P1);
Vp Temp = 4798*T(1.5,x,y)-273;
plot(Temp, value=1, fill=1);

if (mpirank == 0) {
	ofstream myfile(basedir+tempestr+"tempe.txt");
	real[int] XX(2000), YY(2000);
	int kk = 0;
	for (real Z=bounds[4]; Z<bounds[5];Z+=0.01) {
		real Tx = 4798*T(1.5,-1.5,Z)-273;
		XX[kk] = Z; YY[kk++] = Tx;
		cout << Z << "  " << Tx << endl;
		myfile << Z << "  " << Tx << endl;
	}
	XX.resize(kk); YY.resize(kk);
//	plot([XX,YY], cmm = "T in ["+YY.min+","+YY.max+"]");
}
~~~

  Two files in the vtk format are written for $T$:
  - One for $T$ in Celcius on the volume mesh
  -  The other for $T$ in Celcius on the surface mesh

~~~freefem
VhS Ts = 4798*T-273, dTs=4798*dT;
//	plot(u1); plot(u2); plot(u3);
meshS ThS2 = movemesh(ThS,[x,y,2*z]); // to enhance graphics
fespace VhS2(ThS2,P1);
VhS2 Ts2;
Ts2[]= dTs[];
Ts2[] = Ts[];
plot(Ts2,fill=1,value=1);
//if (mpirank == 0) medit("Temperature",ThS2,Ts2);
	T= 4798*T-273;
//if (mpirank == 0) medit("Temperature",Th3,T);
int[int] fforder = [1];
if (mpirank == 0) savevtk(basedir+tempestr+"_vol.vtk",Th3,T,order=fforder);
if (mpirank == 0) savevtk(basedir+tempestr+".vtk",ThS2,Ts2,order=fforder);


/*
if (mpirank == 0){
	ofstream f("solS.dat");
	f << Ts2[];
	ofstream g("solV.dat");
	g << T[];
}
*/

/*
if (mpirank == 0){
	ifstream f("solS.dat");
	VhS2 Ts2c;
	f >> Ts2c[];
	Vh Tc;
	ifstream g("solV.dat");
	g >> Tc[];

	Tc[] -= T[];
	Ts2c[] -= Ts2[];
	plot(Ts2c,fill=1,value=1,cmm="diff");
	cout << "relative L2 error surf = " << Ts2c[].l2 / Ts2[].l2 << ", vol = " << Tc[].l2 / T[].l2 << endl;
	savevtk(basedir+tempestr+"_vol_diff.vtk",Th3,Tc,order=fforder);
	savevtk(basedir+tempestr+"_diff.vtk",ThS2,Ts2c,order=fforder);
 }
*/

if (mpirank == 0) cout << "file name: " << basedir+tempestr << endl;
if (mpirank == 0) cout << "Memory used (Go) = " << (((tmem-mem)/1000.)/1000.)/1000. << endl;
~~~

|The temperature in a cutting plane in the middle of the domain |
|-----------------------|
|![][_coupe3D]          |

[_coupe3D]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/mpi/chamonix/coupe3D.png
// NBPROC 2
// ff-mpirun -np 4 DDM-Schwarz-Stokes-2d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter]  DDM-Schwarz-Stokes-2d.edp   [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer2d.idp"
include "DDM-funcs-v2.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",10);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",0); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
bool RAS=1; 
int sizeoverlaps=1; // size of overlap


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;


string sPk="P2-Stokes-2gd";     
func Pk=[P2,P2,P1];
//int  Pknbcomp=3; 

func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh,Pk, defPk3, Th, u, allu1, { cmm=cm,nbiso=10,fill=1,dim=3,value=1}); return 1;}
func bool  plotMPIallp(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh,Pk, defPk3, Th, u, allu2, { cmm=cm,nbiso=10,fill=1,dim=3,value=1}); return 1;}


mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,2,1]; 
settt 

mesh Thg=square(nloc,nloc,[x,y],label=l111);
mesh ThC=square(nC,nC,[x,y],label=l111);//   Coarse Mesh

fespace VhC(ThC,[P2,P2,P1]); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh,Pk,3,[0,1,-1],Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)





/* the definition of the Problem .... */


// the definition of the Problem ....
// the definition of the Problem ....
func u1bc= (1.-x)*(x)*4.;
// the definition of the Problem ....
macro grad(u) [dx(u),dy(u)] //  
macro div(u1,u2) (dx(u1)+dy(u2)) // 
real nu=1,alpha=0;
varf vPb([u1,u2,p],[v1,v2,q])=
  int2d(Thi)(  
       [u1,u2]'*[v1,v2]* alpha
	   + (   grad(u1)'*grad(v1)
	       + grad(u2)'*grad(v2)
	        ) *nu
	       - div(u1,u2)*q - div(v1,v2)*p +1e-9*p*q)
  + on(10,u1=0,u2=0)	      
  + on(2,u1=u1bc,u2=0)
  + on(1,u1=0,u2=0)
 ;
  
varf vPbC([u1,u2,p],[v1,v2,q])=
  int2d(ThC)(  
       [u1,u2]'*[v1,v2]* alpha
	   + (   grad(u1)'*grad(v1)
	       + grad(u2)'*grad(v2)
	        ) *nu
	       - div(u1,u2)*q - div(v1,v2)*p +1e-9*p*q)	      
  + on(1,2,u1=0,u2=0)
  ;
 
varf vPbon10([u1,u2,p],[v1,v2,q])=on(10,u1=1,u2=1)+on(1,2,u1=0,u2=0);
varf vPBC(U,V)=on(1,2,U=0);




real[int] onG10 = vPbon10(0,Whi); // on 1 on 10 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Stokes2,comm,jpart,Whi,Vhc,3,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0,1,-1])


  
Whi [u,u1,p],[v,v1,q];
 

u[]=vPb(0,Whi,tgv=1); 
real eps=1e-10;
Stokes2DDMSolver(Bi,u,v,gmres,eps,vdebug)


plotMPIall(Thi,v[],"u-final");
plotMPIallp(Thi,v[],"p-final");
{  //  update the pressure 
   /* find c_i such that 
    i,j  (O_i \cap O_j)  int(O_i \cap O_j) (p_i -  c_i - p_j + c_j) = 0
    int (O_i \cap O_j) (c_i - c_j) = int (O_i \cap O_j) p_i - p_j ;  
   */
   1;
}

real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Stokes2kiter <<  endl;
}

Stokes2Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
// NBPROC 10
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter]  DDM-Schwarz-Lap-2dd.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "MPIplot.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer2d.idp"
include "DDM-funcs-v2.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default

assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",10);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=getARGV("-overlap" ,1); ; // size of overlap
bool RAS=getARGV("-RAS",1);  // Global Variable ..



if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

string sPk="P2-2gd";     
func Pk=P2;

func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALL(mesh,Pk, Th, u,{ cmm=cm,nbiso=20,fill=1,dim=3,value=1}); return 1;}

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int iiipart= mpiRank(comm); // current partition number 


if(iiipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,2,2,2]; 
settt 

mesh Thg=square(nloc,nloc*5,[x,5*y],label=l111);
mesh ThC=square(nC,nC*5,[x,5*y],label=l111);//   Caarse Mesh
fespace VhC(ThC,P1); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
 for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
 Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(iiipart,mesh,Pk,1,[0],
                 Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)

Whi ui,vi; 



/* the definition of the Problem .... */
func G=1; /* ok  */
func F=2.; /* ok  */
macro grad(u) [dx(u),dy(u)] //
// warning for Dir. BC. the last win 
varf vPb(U,V)= int2d(Thi)(grad(U)'*grad(V)) + int2d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int2d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon10(U,V)=on(10,U=1)+on(1,U=0);

varf vPBC(U,V)=on(1,U=G);


real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Lap2,comm,jpart,Whi,Vhc,1,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0])

Lap2CheckUpdate(); 
  
Whi u=0,v;
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lap2DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;

{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(iiipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lap2kiter <<  endl;
}

Lap2Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
//  run with MPI:  ff-mpirun -np 2 script.edp
// NBPROC 2

/* to run : in a Shell.  cut and past:
cd /Users/hecht/work/freefem++/examples/mpi 
mpirun -np 2 FreeFem++-mpi schwarz-3.edp -glut ffglut
*/
if ( mpisize != 2 ) {
cout << " sorry number of processeur !=2 " << endl;
exit(1);}
verbosity=4;
real pi=4*atan(1);
int inside = 2;
int outside = 1;
real zmin =0, zmax=1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;};
int n=1;
mesh th2,TH2;
mesh3 th,TH;
int[int] rup=[0,0], rdown=[0,0], rmid=[outside,outside,inside,inside];;
if (mpirank == 0)
 {
 th2 = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
 th =  buildlayers(th2,n,
	     zbound=[zmin,zmax],  labelmid=rmid,
	     reffaceup = rup,     reffacelow = rdown);

 cout << " end th  " << endl;
}
else
 {
 TH2 = buildmesh ( e(5*n) + e1(25*n) );
 TH =  buildlayers(TH2,n,
	     zbound=[zmin,zmax],  labelmid=rmid,
	     reffaceup = rup,     reffacelow = rdown);

 cout << " end TH  " << endl;
 }
broadcast(processor(0),th);
broadcast(processor(1),TH);


fespace vh(th,P1);
fespace VH(TH,P1);
fespace ph(th,P1);
fespace PH(TH,P1);
vh u=0,v; VH U,V;
ph chi=1;
PH CHI=1;
int i=0;

problem PB(U,V,init=i,solver=CG) =
  int3d(TH)( dx(U)*dx(V)+dy(U)*dy(V) +dz(U)*dz(V))
  + int3d(TH)( -V) + on(inside,U = u)  +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=CG) =
    int3d(th)( dx(u)*dx(v)+dy(u)*dy(v)+dz(u)*dz(v) )
  + int3d(th)( -v) + on(inside ,u = U) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 10; i++)
{
  cout << mpirank << " looP " << i << endl;
  if (mpirank == 0)
   PB;
  else
    pb;
   broadcast(processor(0),U[]);
   broadcast(processor(1),u[]);
 
  if (mpirank==0)     plot(U,u,wait=1,fill=1);

  if(mpirank==0)
    {
      real ERR= int3d(TH)( square(U-u)*CHI*chi) ;
      cout << " ERR= " << ERR<< endl;
    }
  else
    {
      real err= int3d(th)( square(U-u)*CHI*chi) ;
      cout << " err= " << err<< endl;
    }

};
 if (mpirank==0)
    plot(U,u,ps="Uu.eps",fill=1);

// ff-mpirun -np 4 MPIGMRES2D.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES2d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "MPIplot.idp"
include "MPIGMRESmacro.idp"
//include "AddLayer2d.idp" 

searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",3);
int nloc = getARGV("-n",11);
string sff=getARGV("-p,","");
int gmres=getARGV("-gmres",2); 
bool dplot=getARGV("-dp",0);
int nC = getARGV("-N" ,max(nloc/10,4)); 

if(mpirank==0 && verbosity)
{
  cout << "ARGV : ";
  for(int i=0;i<ARGV.n;++i)
    cout << ARGV[i] <<" ";
  cout << endl;
}


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

int withplot=0;
bool withmetis=1;
bool RAS=1; 
string sPk="P2-2gd";     
func Pk=P2;

func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALL(mesh,Pk, Th, u,{ cmm=cm,nbiso=20,fill=1,dim=3,value=1}); return 1;}

int sizeoverlaps=1; // size of overlap

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 
 
int npart=mpiSize(comm); // total number of partion
int ipart= mpiRank(comm); // current partition number 

int njpart=0; // nb of part with intersection (a jpart) with ipart without ipart
int[int] jpart(npart); //  list of jpart ..
if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,1,1]; 
settt 

mesh Thg=square(nloc,nloc,label=l111);
mesh ThC=square(nC,nC,label=l111);//   Caarse Mesh

mesh Thi,Thin;//  with overlap, without olverlap  
fespace Phg(Thg,P0);
fespace Vhg(Thg,P1);
fespace VhC(ThC,P1); // of the coarse problem.. 


Phg  part;

// build the partitioning ...  
{    
 int[int] nupart(Thg.nt);
 nupart=0; 
 if(npart>1 && ipart==0)
   metisdual(nupart,Thg,npart); 
   
 broadcast(processor(0,comm),nupart);
 for(int i=0;i<nupart.n;++i)
    part[][i]=nupart[i];
  
} // build ... 


if(withplot>1)
  plot(part,fill=1,cmm="dual",wait=1);

// overlapping partition

 Phg suppi= abs(part-ipart)<0.1; 
 Vhg unssd;                       // boolean function 1 in the subdomain 0 elswhere 
 Thin=trunc(Thg,suppi>0,label=10); // non-overlapping mesh, interfaces have label 10
 int nnn = sizeoverlaps*2;// to be sure 
 AddLayers(Thg,suppi[],nnn,unssd[]);    // see above ! suppi and unssd are modified  
 unssd[] *= nnn;  //  to put value nnn a 0  
 real nnn0 = nnn - sizeoverlaps +  0.001   ;
 Thi=trunc(Thg,unssd>nnn0 ,label=10); // overlapping mesh, interfaces have label 10
 
 settt 

 fespace Vhi(Thi,P1);
 int npij=npart;
 Vhi[int] pij(npij);// local partition of unit + pii 
 Vhi pii;  
 
 real nnn1=  + 0.001  ;
 { /*
   construction of the partition of the unit,
    let phi_i P1 FE function 1 on Thin and zero ouside of Thi and positive
    the partition is build with  
  $$  p_i = phi_i/ \sum phi_i 
    
    to build the partition of one domain i
    we nned to find all j such that supp(phi_j) \cap supp(phi_j) is not empty
    <=> int phi_j
 */
 //   build a local mesh of thii such that all compuation of the unit partition are
 //   exact in thii
 mesh Thii=trunc(Thg,unssd>nnn1 ,label=10); // overlapping mesh, interfaces have label 10


 {  
   // find all j  mes (supp(p_j) \cap supp(p_i)) >0  
   // compute all phi_j on Thii
   //  remark supp p_i include in Thi 
   //  
   fespace Phii(Thii,P0);
   fespace Vhii(Thii,P1);
   Vhi sumphi=0;
   jpart=0;
   njpart=0;
   int nlayer=RAS?1:sizeoverlaps;
   if(ipart==0) 
     cout <<" nlayer=" << nlayer << endl;
   pii= max(unssd-nnn+nlayer,0.)/nlayer;
   if(dplot) plot(pii,wait=1,cmm=" 0000");
   sumphi[] +=  pii[];
   if(dplot) plot(sumphi,wait=1,cmm=" summ 0000");
   Vhii phii=0;
   real epsmes=1e-10*Thii.area;
   for (int i=0;i<npart;++i)
     if(i != ipart ) 
       { 
	    Phii suppii=abs(i-part)<0.2; 
	    if(suppii[].max > 0.5) 
	    {
	     AddLayers(Thii,suppii[],nlayer,phii[]);
	     assert(phii[].min >=0);
	     real interij = int2d(Thi)(  phii); 
	     if(interij>epsmes) 
	       {  
		     pij[njpart]=abs(phii);	 
		     if(vdebug>2) cout << " ***** " << int2d(Thi)(real(pij[njpart])<0) << " " <<pij[njpart][].min << " " << phii[].min << endl;
		     assert(int2d(Thi)(real(pij[njpart])<0) ==0);
		     if(dplot)  plot(pij[njpart],wait=1,cmm=" j = "+ i + " " + njpart);
		     sumphi[] += pij[njpart][]; 
		     if(dplot)  plot(sumphi,wait=1,cmm=" sum j = "+ i + " " + njpart);
		     jpart[njpart++]=i;
	       }}}
   
   if(dplot) plot(sumphi,wait=1,dim=3,cmm="sum ",fill=1 );
   pii[]=pii[] ./ sumphi[];
   for (int j=0;j<njpart;++j)
     pij[j][] = pij[j][] ./ sumphi[];
   jpart.resize(njpart);	
   for (int j=0;j<njpart;++j)
     assert(pij[j][].max<=1);
   {
     cout << ipart << " number of jpart " << njpart << " : ";
     for (int j=0;j<njpart;++j)
       cout << jpart[j] << " ";
  	cout << endl;
   }
   sumphi[]=pii[];
   for (int j=0;j<njpart;++j)
     sumphi[]+= pij[j][];
   if(vdebug>2)  
     cout << " sum min " <<sumphi[].min << " " << sumphi[].max << endl;
   assert(sumphi[].min> 1.-1e-6 && sumphi[].max< 1.+1e-6);  
   //  verification 
 }}// (Thii is remove here) 
  // end of the construction of the local partition of the unity ...
  // on Thi ...  
  // -----------------------------------------------------------------
if(ipart==0) cout << " *** end build partition " << endl;

//  computation of  number of intersection ..
// ------------------------------------------

// here  pii and the pij is the locate partition of the unite on 
// Thi ( mesh with overlap )....
//Thi=splitmesh(Thi,2);
if(dplot ) 
  { plot(Thi,wait=1); 
    for(int j=0;j<njpart;++j)
      plot(pij[j],cmm=" j="+j ,wait=1); } 
      
//  Partition of the unity on Thi ..
// computation of message.
// all j> we have to recive 
// data on intersection of the support of pij[0] and pij[j]
settt 

 if(vdebug) plotMPIall(Thi,pii[],"pi_i");

mesh[int] aThij(njpart); 
matrix Pii;  
matrix[int] sMj(njpart); // M of send to j
matrix[int] rMj(njpart); // M to recv from j
fespace Whi(Thi,Pk);
mesh Thij=Thi;
fespace Whij(Thij,Pk);// 

// construction of the mesh intersect i,j part 
for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(Thi,pij[jp]>1e-6,label=10); // mesh of the supp of pij

for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);

Thi =   trunc(Thi,1,split=ksplit);

settt 

if(ipart==0) cout << " *** end build mesh  intersection  " << endl;
// construction of transfert  matrix
{
  Whi wpii=pii;
  Pii = wpii[];
  for(int jp=0;jp<njpart;++jp)
    {
      int j=jpart[jp];
      Thij = aThij[jp];
      matrix I = interpolate(Whij,Whi); // Whji <- Whi
      sMj[jp] = I*Pii;  // Whi -> s Whij  
      rMj[jp] = interpolate(Whij,Whi,t=1);   // Whji -> Whi
      if(vdebug>10) {
      {Whi uuu=1;Whij vvv=-1; vvv[]+=I*uuu[]; cout << jp << " %%% " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}
      {Whi uuu=1;Whij vvv=-1; vvv[]+=rMj[jp]'*uuu[]; cout << jp << " ### " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}}
    }}
if(ipart==0) cout << " *** end build transfert matrix " << endl;
// alloc array of send and recv data ..

InitU(njpart,Whij,Thij,aThij,Usend)  // initU(n,Vh,Th,aTh,U)
InitU(njpart,Whij,Thij,aThij,Vrecv) // ...
if(ipart==0) cout << " *** end init  data for send/revc  " << endl;

Whi ui,vi; 

func bool Update(real[int] &ui, real[int] &vi)
{
  for(int j=0;j<njpart;++j)
    Usend[j][]=sMj[j]*ui; 
   SendRecvUV(comm,jpart,Usend,Vrecv)
     vi = Pii*ui;
   for(int j=0;j<njpart;++j)
     vi += rMj[j]*Vrecv[j][]; 
   return true;
}


// the definition of the Problem ....
func G=x*0.1; // ok 
func F=1.; // ok 
macro grad(u) [dx(u),dy(u)] // 
varf vBC(U,V)=  on(1,U=G); 
varf vPb(U,V)= int2d(Thi)(grad(U)'*grad(V)) + int2d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int2d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon(U,V)=on(10,U=1)+on(1,U=1);
varf vPbon10only(U,V)=on(10,U=1)+on(1,U=0); 
// remark the order is important we want 0 part on 10 and 1


//----  

matrix Ai = vPb(Whi,Whi,solver=sparsesolver);
matrix AC,Rci,Pci;// 


if(mpiRank(comm)==0)
  AC = vPbC(VhC,VhC,solver=sparsesolver);

Pci=   interpolate(Whi,VhC);
Rci =  Pci'*Pii; 

real[int] onG10 = vPbon10only(0,Whi);
real[int] onG = vPbon(0,Whi);
real[int] Bi=vPb(0,Whi);





int kiter=-1;


func bool  CoarseSolve(real[int]& V,real[int]& U,mpiComm& comm)
{
   //  solving the coarse probleme 
   real[int] Uc(Rci.n),Bc(Uc.n); 
   Uc= Rci*U;
   mpiReduce(Uc,Bc,processor(0,comm),mpiSUM);
   if(mpiRank(comm)==0) 
      Uc = AC^-1*Bc;
    broadcast(processor(0,comm),Uc);
   V = Pci*Uc;
}//EOF ...
func real[int] DJ(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
   V =  Ai*U;
  V = onG10 ? 0.: V;  // remove internal boundary  
  return V; 
}

func real[int] PDJ(real[int]& U) // C1
{ 
  real[int] V(U.n); 
  
  real[int] b= onG10 ? 0. :  U; 
  V =  Ai^-1*b;	
  Update(V,U);
  return U; 
}

func real[int] PDJC(real[int]& U) // 
{ // Precon  C1= Precon //, C2  precon Coarse
// Idea : F. Nataf. 
  //  0 ~  (I C1A)(I-C2A) => I ~  - C1AC2A +C1A +C2A 
  //  New Prec P= C1+C2 - C1AC2   = C1(I- A C2) +C2
  // (  C1(I- A C2) +C2 ) Uo 
  //   V =  - C2*Uo
  // .... 
  real[int] V(U.n); 
  CoarseSolve(V,U,comm);
  V = -V; //  -C2*Uo 
  U  += Ai*V; // U =  (I-A C2) Uo 
  real[int] b= onG10 ? 0. :  U; 
  U =  Ai^-1*b;	//  ( C1( I -A C2) Uo 
  V = U -V; //  
  Update(V,U);
  return U; 
}


 func real[int] DJ0(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
  real[int] b= onG .* U;
  b  = onG ? b : Bi ;  
  V = Ai^-1*b;	
  Update(V,U);
  V -= U;
   return V; 
}


Whi u=0,v;
{ // verification.....
  Whi u=1,v;
  Update(u[],v[]);
  u[]-=v[];
  assert( u[].linfty<1e-6); }
  


settt
u[]=vBC(0,Whi,tgv=1); // set u with tge BC value ...

real epss=1e-6;
int rgmres=0;
if(gmres==1)
  {
   rgmres=MPIAffineGMRES(DJ0,u[],veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
   real[int] b= onG .* u[];
   b  = onG ? b : Bi ;
   v[] = Ai^-1*b;	
   Update(v[],u[]);
  }
else if(gmres==2)
  rgmres= MPILinearGMRES(DJ,precon=PDJ,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else if(gmres==3)
   rgmres= MPILinearGMRES(DJ,precon=PDJC,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else // algo Shwarz for demo ...
   for(int iter=0;iter <10; ++iter)
     {
       real[int] b= onG .* u[];
       b  = onG ? b : Bi ;
       v[] = Ai^-1*b;	
       
       Update(v[],u[]);
       if(vdebug) plotMPIall(Thi,u[],"u-"+iter);
        v[] -= u[];
       
       real err = v[].linfty;
       real umax = u[].max;
       real[int] aa=[err,umax], bb(2);
       mpiAllReduce(aa,bb,comm,mpiMAX);
       real errg = bb[0];
       real umaxg = bb[1];
       
       if(ipart==0)
	     cout << ipart << " err = " << errg << " u. max  " << umaxg << endl;
       if(errg< 1e-5) break;
     }
if(vdebug) plotMPIall(Thi,u[],"u-final");

settt

real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << kiter <<  endl;
}

if(sff != "")
  {
    ofstream ff(sff+".txt",append);
    cout << " ++++  " ;
    cout  << mpirank <<"/" <<  mpisize << " k=" <<  ksplit << " n= " << nloc << " " << sizeoverlaps << " it=  " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      cout << " " << ttt[i]-ttt[i-1] << " ";
    cout << epss << " " << Ai.nbcoef << " " << Ai.n << endl;
    
    /*
      1 mpirank
      2 mpisize 
      3 ksplit 
      4 nloc
      5 sizeoverlaps
      6 kiter
      7 mesh & part build  
      8 build the partion 
      9 build mesh, transfere , and the fine mesh .. 
      10 build the matrix,  the trans matrix, factorizatioon 
      11 GMRES 
    */
    ff   << mpirank << " " << mpisize << " " << sPk << " " ;
    ff <<  ksplit << " " << nloc << " " << sizeoverlaps << " " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      ff << " " << ttt[i]-ttt[i-1] << " ";
    ff << epss << " " << Ai.nbcoef << " " << Ai.n << " " << gmres << endl;
    
  }
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "mpi-cmaes"


int NN = 6;
mesh Th = square(NN,NN);
func f1=1.;
func f2=-1.;
func g1=0.;
func g2=0.1;
int iter=0;
int nadapt=1;
real starttol=1e-10,bctol=6.e-12;
fespace Vh(Th,P1);
Vh ou1,ou2;
real pena=1000;


for(int al=0;al<nadapt;++al)
{
	
varf BVF(v,w) = int2d(Th)(0.5*dx(v)*dx(w) + 0.5*dy(v)*dy(w));
varf LVF1(v,w) = int2d(Th)(f1*w);
varf LVF2(v,w) = int2d(Th)(f2*w);
matrix A =  BVF(Vh,Vh);
real[int] b1 = LVF1(0,Vh) , b2 = LVF2(0,Vh); 

varf Vbord(v,w) = on(1,2,3,4,v=1);
//real[int] bord = Vbord(0,Vh);
//real[int] in = bord ? 0 : 1;
Vh In,Bord;
Bord[] = Vbord(0,Vh,tgv=1);
In[] = Bord[] ? 0:1;
Vh gh1=Bord*g1,gh2=Bord*g2;



//Function which create a vector of the search space type from
//two finite element functions
func int FEFToSSP(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			ssp[kX] = fef1[i];
			ssp[kX+In[].sum] = fef2[i];
			++kX;
		}
	}
	return 1;
}
//Function spliting a vector from the search space and fills
//two finite element functions with it
func int SSPToFEF(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			fef1[i] = ssp[kX];
			fef2[i] = ssp[kX+In[].sum];
			++kX;
		}
		else
		{
			fef1[i] = gh1[][i];
			fef2[i] = gh2[][i];
		}
	}
	return 1;
}


func real IneqC(real[int] &X)
{
	real[int] constraints(In[].sum);
	for(int i=0;i<In[].sum;++i)
	{
		constraints[i] = X[i] - X[i+In[].sum];
		constraints[i] = constraints[i] <= 0 ? 0. : constraints[i];
	}
	return constraints.l2;
}


func real J(real[int] &X)
{
	Vh u1,u2;
	SSPToFEF(u1[],u2[],X);
	iter++;
	real[int] Au1 = A*u1[], Au2 = A*u2[];
	Au1 -= b1;
	Au2 -= b2;
	real val = u1[]'*Au1 + u2[]'*Au2;
	val +=  pena * IneqC(X);
	if(iter%100==0) plot(u1,u2,nbiso=30,fill=1,dim=3,cmm="adapt level " + al + " - iteration " + iter + " - J = " + val,value=1);
	return val ;
}



real[int] start(2*In[].sum);

if(al==0)
{
	start(0:In[].sum-1) = 0.;
	start(In[].sum:2*In[].sum-1) = 0.1;
}
else FEFToSSP(ou1[],ou2[],start);


real mini = cmaesMPI(J,start,stopMaxFunEval=10000*(al+1),stopTolX=1.e-4/(10*(al+1)),initialStdDev=(0.025/(pow(100.,al))));
Vh best1,best2;
SSPToFEF(best1[],best2[],start);

Th = adaptmesh(Th,best1,best2);
ou1 = best1;
ou2 = best2;

}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "MUMPS_mpi"
////////////////////
//  parameters

real ttgv=1e30;
//string ssparams="nprow=1, npcol="+mpisize;
////////////////////
real nu=0.01,dt=0.3;
real alpha=1./dt,alpha2=sqrt(alpha);

int nn=7;

mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);

fespace VVh(Th,[P23d,P23d,P23d,P13d]);
fespace Vh(Th,P23d);
fespace Ph(Th,P13d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  
cout << "initilisation" << endl;

real t1,t2,t3,t4;

t1=clock();
varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) //' for emacs
             - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
 + on(2,u1=1.,u2=0,u3=0)
 + on(1,u1=0,u2=0,u3=0)
 ;
matrix A=vStokes( VVh, VVh, tgv=ttgv );
t1=clock()-t1;

t4=clock();
set(A,solver=sparsesolver );
t4=clock()-t4;

t2=clock();
real[int] b= vStokes(0,VVh);
t2=clock()-t2;

VVh [u1,u2,u3,p];
VVh [X1,X2,X3,Xp];
VVh [x1,x2,x3,xp]=[x,y,z,0];

t3=clock();
u1[]= A^-1 * b;
t3=clock()-t3;

ux= u1(x,0.5,y);
uz= u3(x,0.5,y);
p2= p(x,0.5,y);
plot([ux,uz],p2,cmm=" cut y = 0.5",wait=1);
macro XX1() (x-u1*dt)//
macro XX2() (y-u2*dt)//
macro XX3() (z-u3*dt)//

  varf vNS([uu1,uu2,uu3,p],[v1,v2,v3,q]) = 
  int3d(Th)( alpha*(uu1*v1+uu2*v2+uu3*v3) + nu*(Grad(uu1)'*Grad(v1) +  Grad(uu2)'*Grad(v2) +  Grad(uu3)'*Grad(v3)) //' for emacs
  - div(uu1,uu2,uu3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,uu1=1,uu2=0,uu3=0)
  + on(1,uu1=0,uu2=0,uu3=0)
 
  +  int3d(Th,optimize=1,qforder=4)(   alpha*(  convect([u1,u2,u3],-dt,u1)*v1  +   convect([u1,u2,u3],-dt,u2)*v2  +   convect([u1,u2,u3],-dt,u3)*v3 )  ) ;
  //   +  int3d(Th,optimize=1)(   alpha*(  u1(X1,X2,X3)*v1  +  u2(X1,X2,X3)*v2  +  u3(X1,X2,X3)*v3 )  ) ;
//  +  int3d(Th,optimize=1)(   alpha*(  u1(XX1,XX2,XX3)*v1  +  u2(XX1,XX2,XX3)*v2  +  u3(XX1,XX2,XX3)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1(x,y,z)*v1  +  u2(x,y,z)*v2  +  u3(x,y,z)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1*v1  +  u2*v2  +  u3*v3 )  ) ;

real time1,time2=0.,time3=0.,time4,time5;

time1=clock();
A = vNS( VVh, VVh, tgv=ttgv);
time1=clock()-time1;

time5=clock();
set(A,solver=sparsesolver,verb=1);
time5=clock()-time5;

time4=clock();
real t=0;
int nbtemps=5;
for(int i=0;i<nbtemps;++i)
  {
    real time2tmp,time3tmp;
    t += dt;
    cout << " iteration " << i << " t = " << t << endl;
    X1[]=x1[]+u1[]*(-dt);
    //    verbosity=1000;

    time2tmp=clock();
    b=vNS(0,VVh);
    time2=time2+(clock()-time2tmp);

    time3tmp=clock();
    u1[]= A^-1 * b;
    time3=time3+(clock()-time3tmp);

    ux= u1(x,0.5,y);
    uz= u3(x,0.5,y);
    p2= p(x,0.5,y);
    plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=0);
    if(i%5==6)
    {
      //exec("mkdir dd");
      string prefu="dd/pastix-nn-"+nn+"+u-"+(100+i);
      string prefp="dd/pastix-nn-"+nn+"p-"+(100+i);
      savemesh(Th,prefu+".mesh");
      savemesh(Th,prefp+".mesh");
     
      ofstream file(prefu+".bb"); 
      ofstream filep(prefp+".bb"); 
      Ph up1=u1,up2=u2,up3=u3,pp=p;
      file << "3 1 3 "<< up1[].n << " 2 \n";
      filep << "3 1 1 "<< pp[].n << " 2 \n";
      for (int j=0;j<up1[].n ; j++)  
	{
	  file << up1[][j] <<" " <<up2[][j] <<" "<< up3[][j] <<"\n";
	  filep << pp[][j] <<  endl; 
	}  
    }
  }
time4=clock()-time4;

//plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=1);
cout << "============ CPU TIME ==========================" << endl;
cout << "= Intialisation Stokes :::         =" << endl;
cout << "= matrix                           =" << t1<< endl;
cout << "= Factorization                    =" << t4 << endl; 
cout << "= second member                    =" << t2 << endl;
cout << "= solving                          =" << t3<< endl;
cout << "= all                              =" << t1+t2+t3+t4 << endl; 
cout << "============ CPU TIME ==========================" << endl;
cout << "= Navier Stokes :::                =" << endl;
cout << "= matrix                           =" << time1<< endl;
cout << "= Factorization                    =" << time5 << endl; 
cout << "= second member by step (dt)       =" << time2/nbtemps << endl;
cout << "= solving by step (dt)             =" << time3/nbtemps<< endl;
cout << "= all step solving                 =" << time4 << endl;
cout << "= solving Navier Stokes            =" << time1+time2+time3+time4+time5 << endl; 
cout << "============ CPU TIME ==========================" << endl;
// NBPROC 4
assert(version>=2.23);
if ( mpisize != 4 )
  {
    cout << " sorry number of processeur !=4 " << endl;
    exit(1);
  }

//  Mortar  (4 sub domain)
//  with matrix -et Precon Conjugade Gradient --
//    Neuman -> Dirichlet .
//  -------------------------------

func f=1+x+y;
real g=1;
int withprecon=1;
macro Grad(u) [ dx(u), dy(u) ] //
int nbsd=4;

macro Psd(U) U[0],U[1],U[2],U[3] //

int labext= nbsd+1;
real meshsize=0.03;
real meshsizem=meshsize*1.5;
bool noconforme=0;

mesh Tha,Thm,Thmm;
int [int] regsd(4);


if(mpirank==0)
  {

    mesh Thacopy; //hack to dcl Tha ouside of mortar-msh.idp
    {
      include "mortar-msh.idp"
	Thacopy=Tha;
      regsd=regi;
    }
    Tha=Thacopy;
    cout << "mortar : " << endl;
    Thm=Tha;
    Thm=adaptmesh(Thm,meshsizem,IsMetric=1,thetamax=60);
    Thm=emptymesh(Thm);       Thmm=Thm;
    Thmm=trunc(Thm,split=4,1); // for fine integration
    Thmm=emptymesh(Thmm);
    plot(Thm,wait=0,ps="mortar-Thm.eps");
  }

// send meshes
verbosity=1;
broadcast(processor(0),Tha);
broadcast(processor(0),Thm);
broadcast(processor(0),Thmm);
broadcast(processor(0),regsd);

// build sub domaine mesh :
mesh Thi=trunc(Tha,region==regsd[mpirank],split=1);// les sous domaines

if(noconforme)
 Thi=adaptmesh(Thi,meshsize*(1+0.1*mpirank),IsMetric=1,nbvx=100000,thetamax=60);// les sous domaines


fespace Lh(Thm,P1);
fespace RTh(Thm,[P0edge,P0edge]);
 RTh [Nmx,Nmy]; // ne marche pas car la normal
//                             n'est definie que une un bord
varf  vNN([ux,uy],[nx,ny]) = int1d(Thm,1)(( nx*N.x + ny*N.y)/lenEdge);
Nmx[]= vNN(0,RTh);

// les joint P0 sur le squelette
// -----   \int [q] l + \int[p] m
Lh  lh=0,rhsl=0;

fespace Vhi(Thi,P1);
fespace Ehi(Thi,P0);
matrix Asd,Csd,PAsd,PIsd,PJsd;
Vhi usd,vsd,rhssd, pusd,bcsd;
Ehi epssd;

real tgv=1e30;



varf cci([l],[u]) = int1d(Thmm,1,qforder=3)(l*u*epssd);
varf vepsi(u,v)= int1d(Thi,1,qforder=10)( (Nmx*N.x + Nmy*N.y)*v/lenEdge);

varf vLapMi([ui],[vi],tgv=tgv) =
			   int2d(Thi)(  Grad(ui)'*Grad(vi)  )
			   // + int1d(Thi,1,qfe=qf1pElump)(alpha*ui*vi)
			   +  int2d(Thi) (f*vi)   +  on(labext,ui=g);

varf vPLapMi([ui],[vi],tgv=tgv) =
			   int2d(Thi)(  Grad(ui)'*Grad(vi)  )
			   // + int1d(Thi,1,qfe=qf1pElump)(alphap*ui*vi)
			   + on(labext,1,ui=0);
;

varf  vrhsMi(ui,vi) =   on(labext,ui=g);


usd=0;
vsd=0;
epssd[]= vepsi(0,Ehi);
epssd = -real(epssd <-0.00001) + real(epssd >0.00001);

Csd  = cci(Lh,Vhi);
Asd  = vLapMi(Vhi,Vhi,solver="SPARSESOLVER");
PAsd = vPLapMi(Vhi,Vhi,solver="SPARSESOLVER");
matrix IVL=interpolate(Vhi,Lh,inside=1);
//   v = IVL*l
varf vonext(u,v)=on(labext,u=1);
varf von1(u,v)=on(1,u=1);
real[int]  onext=vonext(0,Vhi);
real[int]  on1=von1(0,Vhi);
on1= on1 ? 1 : 0;
on1 = onext ? 0 : on1; //  remove df of ext
matrix I1(on1);//   matrix    tgv $i\in Gamma_1 \ Gamma_e $ , 0 otherwise
PIsd=  I1*IVL;//  remove of line not on $Gamma_1 \ Gamma_e $
// so PIsd*l  =  tgv * Interpole l on $Gamma_1 \ Gamma_e $
I1.diag=on1;
matrix AA=I1*Asd;//  remove line not on lab 1
PJsd= IVL'*AA;
rhssd[]=vLapMi(0,Vhi);

varf  vML(u,v) = int2d(Thm)(u*v*1e-10)+int1d(Thm,1)(u*v);
matrix ML=vML(Lh,Lh);


lh[]=0;
int itera=0;

varf  vbc(u,v) =   int1d(Thm,labext)(v);
real[int] lbc(Lh.ndof),lbc0(Lh.ndof);
lbc=vbc(0,Lh);
lbc = lbc ? 0 : 1 ;

int what; //  to choose which  funct call 1  SkPb 2:PSkPb, 3:end
// the preconditionner
func real[int] PSkPb(real[int] &l)
{
  if(withprecon)
    {
      if(mpirank==0)
	{
	  what=2;
	  broadcast(processor(0),what); // get from SkBk routine
	}
      if(what!=2) return l;

      int verb=verbosity;   verbosity=0;   itera++;
      real[int] ll= ML^-1*l;
      broadcast(processor(0),ll);
      ll= lbc .* ll;
      ll *= tgv;
      pusd[] = PAsd^-1*(vsd[]= PIsd* ll);
      ll  = PJsd*pusd[];
      if(mpirank==0)
	{
	  for (int i=1;i<4;++i)
	    {
	      processor(i) >> l;
	      ll += l;
	    }
	  l = ML^-1*ll;
	  l= lbc .* l;
	}
      else
	processor(0) << ll;
      verbosity=verb;
    }
  return l ;
};

func real[int] SkPb(real[int] &l)
{
  int verb=verbosity;   verbosity=0;   itera++;
  if(mpirank==0 && what!=3) what=1;
  broadcast(processor(0),what);
  if(what==2) return PSkPb(l);
  else if (what !=1) return l;
  broadcast(processor(0),l);

  vsd[]  = rhssd[];
  vsd[] += Csd* l;
  usd[]  = Asd^-1*vsd[];
  l  = Csd'*usd[];
  l= lbc .* l;

  if(mpirank==0)
   {
    real[int] ll(l.n);
    for (int i=1;i<4;++i)
      {
        processor(i) >> ll;
        l += ll;
      }
    }
  else
    processor(0) << l;
  verbosity=verb;
  return l ;
};





if(mpirank==0)
  {
    verbosity=100;
    lh[]=0;
     LinearCG(SkPb,lh[],eps=1.e-5,nbiter=100,precon=PSkPb);
    what=3;
    SkPb(lh[]);
  }
 else
   while(what!=3)
     SkPb(lh[]);

plot(usd,bb=[[-1,-1],[1,1]],ps="mortar-"+mpirank+".eps");
cout << "Fin CG  " << mpirank <<  endl;

/*
Brochet:examples/mpi hecht$ (grep -vh showpage  mortar-?.eps;echo showpage) > mortar.eps
Brochet:examples/mpi hecht$ gv mortar.eps
*/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -n 5

/*
to change locatation of daynamic lib. set   freefem++.pref   file like :
more freefem++.pref
loadpath = "../../plugin/seq/"
loadpath += "./"
*/

//load "medit"
load "MUMPS_mpi"
include "getARGV.idp"

verbosity=0;
real ttgv=1e10;



int nn=getARGV("-n",15);
int pplot=getARGV("-plot",0);


int[int] ll=[1,1,1,1,1,2];
mesh3 Th;
if(mpirank==0)
{
	Th=cube(nn,nn,nn,label=ll);
	Th=change(Th,fregion=nuTriangle%mpisize);
}
broadcast(processor(0),Th);
fespace VVh(Th,[P2,P2,P2,P1]);
fespace UUh(Th,[P2,P2,P2]);
fespace Uh(Th,P2);
fespace Ph(Th,P1);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

func fup = (1-x)*(x)*y*(1-y)*16;


VVh [u1,u2,u3,p];
VVh [v1,v2,v3,q];

real timeI=mpiWtime();
real time1=mpiWtime();
varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) =
  int3d(Th,qforder=3,mpirank)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3)   //' for emacs
                  - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p )
  + on(2,u1=fup,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ;


matrix MStokes=vStokes(VVh,VVh,tgv=ttgv);
if(mpirank==0)
cout << "size of matrix " << MStokes.n << " x " << MStokes.m << " nn nzero coef  = " << MStokes.nbcoef << endl;
time1=mpiWtime()-time1;

real timeF=mpiWtime();
set(MStokes,solver=sparsesolver,master=-1);
timeF=mpiWtime()-timeF;

real time2=mpiWtime();
real[int] b=vStokes(0,VVh);
time2=mpiWtime()-time2;

real time3=mpiWtime();
u1[] = MStokes^-1*b;
time3=mpiWtime()-time3;

timeI=mpiWtime()-timeI;

if(mpirank==0)
{
cout << "============= CPU TIME ============" << endl;
cout << "size of matrix " << MStokes.n << " x " << MStokes.m << " nn nzero coef  = " << MStokes.nbcoef << endl;
cout << " matrix                  " <<  time1 << endl;
cout << " Fact                    " <<  timeF << endl;
cout << " second member           " <<  time2 << endl;
cout << " solve                   " <<  time3 << endl;
cout << "                          ------------" << endl;
cout << " all                     " <<  timeI << endl;
cout << "============= CPU TIME ============" << endl;
}
//if(mpirank==0 && pplot) medit("UV2 PV2",Th,[u1,u2,u3],p);
// UNCHECK-FILE   : BUGGUS  ....
// NBPROC 2
//  a new coding  methode de schwarz 
// with 2 proc. 
//  -------------------------------
// F.Hecht december 2003
// ----------------------------------
//  to test the broadcast instruction 
//  and array of mesh 
//  add add the stop test 
//  ---------------------------------

if ( mpisize != 2 ) {
cout << " sorry, number of processors !=2 " << endl;
exit(1);}
verbosity=3;
int interior = 2;
int exterior = 1;
border a(t=1,2){x=t;y=0;label=exterior;};
border b(t=0,1){x=2;y=t;label=exterior;};
border c(t=2,0){x=t ;y=1;label=exterior;};
border d(t=1,0){x = 1-t; y = t;label=interior;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=interior;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=exterior;}; 
int n=4;
mesh[int]  Th(mpisize);
if (mpirank == 0) 
 Th[0] = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
else
 Th[1] = buildmesh ( e(5*n) + e1(25*n) );

broadcast(processor(0),Th[0]);
broadcast(processor(1),Th[1]);

fespace Vh(Th[mpirank],P1);
fespace Vhother(Th[1-mpirank],P1);

Vh u=0,v;
Vhother U=0;
int i=0;

problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(Th[mpirank])( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(Th[mpirank])( -v) + on(interior,u = U)  +    on(exterior,u= 0 ) ;

for ( i=0 ;i< 20; i++) 
{ 
  cout << mpirank << " looP " << i << endl;
   pb; 
   //  send u  to the other proc, receive in U
  // processor(1-mpirank) << u[];    processor(1-mpirank) >> U[];
  mpiAlltoall(u[],U[]);
    real[int] err0(1),err1(1);
   err0[0] = int1d(Th[mpirank],interior)(square(U-u)) ;
   // send err0  to the other proc, receive in err1
   // dead lock use broadcast 
  // processor(1-mpirank)<<err0;   processor(1-mpirank)>>err1;
    mpiAlltoall(err0,err1);    
   real err= sqrt(err0[0]+err1[0]);
   cout <<" err = " << err << " err0 = " << err0[0] << ", err1 = " << err1[0] << endl;
   if(err<1e-3) break;
};
if (mpirank==0)  
    plot(u,U,ps="uU.eps");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "MUMPS_mpi" // add _mpi for windows do day
// load "symmetrizeCSR"
int[int] l = [1, 1, 2, 2];
mesh Th = square(150, 150, label = l);
int master = 0; //  no choose see MUMPS doc sect 4.3 
if(mpirank != master) // no need to store the matrix on ranks other than 0
    Th = square(1, 1, label = l);
fespace Vh(Th, P2);
real[int] rinfo(40);
 int[int] info(40); 

varf lap(u,v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v) - 100*u*v) + int2d(Th)(v) + on(1, u = 1);
real[int] b = lap(0, Vh);
matrix A,B;
//if( mpirank==master) // => trap pb of size  in  A^-1 * b;
{ // def only on master .. 
	A = lap(Vh, Vh); B = A;
	//symmetrizeCSR(B);
	set(B,sym=1);
	
	cout<< " A nnz "<< A.nnz << endl;
	cout<< " B nnz "<< B.nnz << endl;
} 
verbosity = 2;
// If you want, you can pass an array of integer (int[int] t)
// for specifying the ordering you want to use
// 1 : AMD
// 3 : AMF
// 4 : SCOTCH
// 5 : PORD
// 6 : METIS
// 7 : QAMD
// 10 : PT-SCOTCH
// 11 : ParMETIS
//
// You can also set on which MPI rank the matrix is defined
// as the current interface only supports centralized matrices
//
// Example :
// If one wants to use SCOTCH with a matrix stored on mpirank == 0
// int[int] t(2); t(0) = 4; t(1) = 1;
// set(A, solver = sparsesolver, lparams = t);
set(A, solver = sparsesolver,master=master);
set(B, solver = sparsesolver,master=master,rinfo=rinfo,info=info);
verbosity = 0;
Vh u;
u[] = A^-1 * b;
if(mpirank==master) cout << " A :  u " << u[].l1 << " " << u[].linfty << endl; 
if(mpirank==0-master)
plot(Th, u, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver unsymmetric", value = 1);
u[] = B^-1 * b;
if(mpirank==master) cout << " B :  u " << u[].l1 << " " << u[].linfty << endl; 
if(mpirank==master)
for(int i=0; i<40;++i)
   {
    cout << "mumps: info B" << i+1 << " = " << info[i] << " , / r " << rinfo[i] <<endl;
   }

if(mpirank==master)
plot(Th, u, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver symmetric", value = 1);

//  try distributed  version ...
 Th = square(150, 150, label = l);
u=0; // resize u..
b.resize(Vh.ndof);
Th=change(Th,fregion= nuTriangle%mpisize);
varf lapd(u,v) = int2d(Th,mpirank)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th,mpirank)(v) + on(1, u = 1);
A = lapd(Vh, Vh,solver=CG);
set(A, solver = sparsesolver,master=-1);// distruteb
b = lapd(0, Vh);
u[] = A^-1 * b;
cout << " D u " << u[].l1 << " " << u[].linfty << " " << mpirank << endl; 
cout << " On Fini" << endl; 
// NBPROC 4
// ff-mpirun -np 4 MPIGMRES2D.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES3d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1|2|3]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh3 cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "MPIplot.idp"
include "MPIGMRESmacro.idp"
//include "AddLayer3d.idp" 
include  "cube.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
assert(version >3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",2);
int nloc = getARGV("-n",10);
string sff=getARGV("-p,","");
int gmres=getARGV("-gmres",3); 
bool dplot=getARGV("-dp",0);
int nC = getARGV("-N" ,max(nloc/10,4)); 

if(mpirank==0 && verbosity)
{
  cout << "ARGV : ";
  for(int i=0;i<ARGV.n;++i)
    cout << ARGV[i] <<" ";
  cout << endl;
}


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

int withplot=0;
bool withmetis=1;
bool RAS=1; 
string sPk="P2-3gd";     
func Pk=P2;

func bool  plotMPIall(mesh3 &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALL(mesh3,Pk, Th, u,{ cmm=cm,nbiso=3,fill=0,dim=3,value=1}); return 1;}

int sizeoverlaps=1; // size of overlap

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 
 
int npart=mpiSize(comm); // total number of partion
int ipart= mpiRank(comm); // current partition number 

int njpart=0; // nb of part with intersection (a jpart) with ipart without ipart
int[int] jpart(npart); //  list of jpart ..
if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,1,1]; 
settt 

int[int,int] LL=[[1,1],[1,1],[1,1]];
real[int,int] BB=[[0,1],[0,1],[0,1]];
int[int] NN=[nloc,nloc,nloc]; 
int[int] NNC=[nC,nC,nC]; 
settt 
mesh3 Thg=Cube(NN,BB,LL);
mesh3 ThC=Cube(NNC,BB,LL);

mesh3 Thi,Thin;//  with overlap, without olverlap  
fespace Phg(Thg,P0);
fespace Vhg(Thg,P1);
fespace VhC(ThC,P1); // of the coarse problem.. 


Phg  part;

// build the partitioning ...  
{    
 int[int] nupart(Thg.nt);
 nupart=0; 
 if(npart>1 && ipart==0)
   metisdual(nupart,Thg,npart); 
   
 broadcast(processor(0,comm),nupart);
 for(int i=0;i<nupart.n;++i)
    part[][i]=nupart[i];
  
} // build ... 


if(withplot>1)
  plot(part,fill=1,cmm="dual",wait=1);

// overlapping partition

 Phg suppi= abs(part-ipart)<0.1; 
 Vhg unssd;                       // boolean function 1 in the subdomain 0 elswhere 
 Thin=trunc(Thg,suppi>0,label=10); // non-overlapping mesh3, interfaces have label 10
 int nnn = sizeoverlaps*2;// to be sure 
 AddLayers(Thg,suppi[],nnn,unssd[]);    // see above ! suppi and unssd are modified  
 unssd[] *= nnn;  //  to put value nnn a 0  
 real nnn0 = nnn - sizeoverlaps +  0.001   ;
 Thi=trunc(Thg,unssd>nnn0 ,label=10); // overlapping mesh3, interfaces have label 10
 
 settt 

 fespace Vhi(Thi,P1);
 int npij=npart;
 Vhi[int] pij(npij);// local partition of unit + pii 
 Vhi pii;  
 
 real nnn1=  + 0.001  ;
 { /*
   construction of the partition of the unit,
    let phi_i P1 FE function 1 on Thin and zero ouside of Thi and positive
    the partition is build with  
  $$  p_i = phi_i/ \sum phi_i 
    
    to build the partition of one domain i
    we nned to find all j such that supp(phi_j) \cap supp(phi_j) is not empty
    <=> int phi_j
 */
 //   build a local mesh3 of thii such that all compuation of the unit partition are
 //   exact in thii
 mesh3 Thii=trunc(Thg,unssd>nnn1 ,label=10); // overlapping mesh3, interfaces have label 10


 {  
   // find all j  mes (supp(p_j) \cap supp(p_i)) >0  
   // compute all phi_j on Thii
   //  remark supp p_i include in Thi 
   //  
   fespace Phii(Thii,P0);
   fespace Vhii(Thii,P1);
   Vhi sumphi=0;
   jpart=0;
   njpart=0;
   int nlayer=RAS?1:sizeoverlaps;
   if(ipart==0) 
     cout <<" nlayer=" << nlayer << endl;
   pii= max(unssd-nnn+nlayer,0.)/nlayer;
   if(dplot) plot(pii,wait=1,cmm=" 0000");
   sumphi[] +=  pii[];
   if(dplot) plot(sumphi,wait=1,cmm=" summ 0000");
   Vhii phii=0;
   real epsmes=1e-10*Thii.measure;
   for (int i=0;i<npart;++i)
     if(i != ipart ) 
       { 
	    Phii suppii=abs(i-part)<0.2; 
	    if(suppii[].max > 0.5) 
	    {
	     AddLayers(Thii,suppii[],nlayer,phii[]);
	     assert(phii[].min >=0);
	     real interij = int3d(Thi)(  phii); 
	     if(interij>epsmes) 
	       {  
		     pij[njpart]=abs(phii);	 
		     if(vdebug>2) cout << " ***** " << int3d(Thi)(real(pij[njpart])<0) << " " <<pij[njpart][].min << " " << phii[].min << endl;
		     assert(int3d(Thi)(real(pij[njpart])<0) ==0);
		     if(dplot)  plot(pij[njpart],wait=1,cmm=" j = "+ i + " " + njpart);
		     sumphi[] += pij[njpart][]; 
		     if(dplot)  plot(sumphi,wait=1,cmm=" sum j = "+ i + " " + njpart);
		     jpart[njpart++]=i;
	       }}}
   
   if(dplot) plot(sumphi,wait=1,dim=3,cmm="sum ",fill=1 );
   pii[]=pii[] ./ sumphi[];
   for (int j=0;j<njpart;++j)
     pij[j][] = pij[j][] ./ sumphi[];
   jpart.resize(njpart);	
   for (int j=0;j<njpart;++j)
     assert(pij[j][].max<=1);
   {
     cout << ipart << " number of jpart " << njpart << " : ";
     for (int j=0;j<njpart;++j)
       cout << jpart[j] << " ";
  	cout << endl;
   }
   sumphi[]=pii[];
   for (int j=0;j<njpart;++j)
     sumphi[]+= pij[j][];
   if(vdebug)  
     cout << " sum min " <<sumphi[].min << " " << sumphi[].max << endl;
   assert(sumphi[].min> 1.-1e-6 && sumphi[].max< 1.+1e-6);  
   //  verification 
 }}// (Thii is remove here) 
  // end of the construction of the local partition of the unity ...
  // on Thi ...  
  // -----------------------------------------------------------------
if(ipart==0) cout << " *** end build partition " << endl;

//  computation of  number of intersection ..
// ------------------------------------------

// here  pii and the pij is the locate partition of the unite on 
// Thi ( mesh3 with overlap )....
//Thi=splitmesh(Thi,2);
if(dplot ) 
  { plot(Thi,wait=1); 
    for(int j=0;j<njpart;++j)
      plot(pij[j],cmm=" j="+j ,wait=1); } 
      
//  Partition of the unity on Thi ..
// computation of message.
// all j> we have to recive 
// data on intersection of the support of pij[0] and pij[j]
settt 

 plotMPIall(Thi,pii[],"pi_i");

mesh3[int] aThij(njpart); 
matrix Pii;  
matrix[int] sMj(njpart); // M of send to j
matrix[int] rMj(njpart); // M to recv from j
fespace Whi(Thi,Pk);
mesh3 Thij=Thi;
fespace Whij(Thij,Pk);// 

// construction of the mesh3 intersect i,j part 
for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(Thi,pij[jp]>1e-6,label=10); // mesh3 of the supp of pij

for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);

Thi =   trunc(Thi,1,split=ksplit);

settt 

if(ipart==0) cout << " *** end build mesh3  intersection  " << endl;
// construction of transfert  matrix
{
  Whi wpii=pii;
  Pii = wpii[];
  for(int jp=0;jp<njpart;++jp)
    {
      int j=jpart[jp];
      Thij = aThij[jp];
      matrix I = interpolate(Whij,Whi); // Whji <- Whi
      sMj[jp] = I*Pii;  // Whi -> s Whij  
      rMj[jp] = interpolate(Whij,Whi,t=1);   // Whji -> Whi
      if(vdebug>10) {
      {Whi uuu=1;Whij vvv=-1; vvv[]+=I*uuu[]; cout << jp << " %%% " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}
      {Whi uuu=1;Whij vvv=-1; vvv[]+=rMj[jp]'*uuu[]; cout << jp << " ### " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}}
    }}
if(ipart==0) cout << " *** end build transfert matrix " << endl;
// alloc array of send and recv data ..

InitU(njpart,Whij,Thij,aThij,Usend)  // initU(n,Vh,Th,aTh,U)
InitU(njpart,Whij,Thij,aThij,Vrecv) // ...
if(ipart==0) cout << " *** end init  data for send/revc  " << endl;

Whi ui,vi; 

func bool Update(real[int] &ui, real[int] &vi)
{
  for(int j=0;j<njpart;++j)
    Usend[j][]=sMj[j]*ui; 
   SendRecvUV(comm,jpart,Usend,Vrecv)
     vi = Pii*ui;
   for(int j=0;j<njpart;++j)
     vi += rMj[j]*Vrecv[j][]; 
   return true;
}


// the definition of the Problem ....
func G=1.; // ok 
func F=1.; // ok 
macro grad(u) [dx(u),dy(u),dz(u)] // 
varf vBC(U,V)=  on(1,U=G); 
varf vPb(U,V)= int3d(Thi)(grad(U)'*grad(V)) + int3d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int3d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon(U,V)=on(10,U=1)+on(1,U=1);
varf vPbon10only(U,V)=on(10,U=1)+on(1,U=0); 

//----  

matrix Ai = vPb(Whi,Whi,solver=sparsesolver);
matrix AC,Rci,Pci;// 


if(mpiRank(comm)==0)
  AC = vPbC(VhC,VhC,solver=sparsesolver);

Pci=   interpolate(Whi,VhC);
Rci =  Pci'*Pii; 

real[int] onG10 = vPbon10only(0,Whi);
real[int] onG = vPbon(0,Whi);
real[int] Bi=vPb(0,Whi);





int kiter=-1;


func bool  CoarseSolve(real[int]& V,real[int]& U,mpiComm& comm)
{
   //  solving the coarse probleme 
   real[int] Uc(Rci.n),Bc(Uc.n); 
   Uc= Rci*U;
   mpiReduce(Uc,Bc,processor(0,comm),mpiSUM);
   if(mpiRank(comm)==0) 
      Uc = AC^-1*Bc;
    broadcast(processor(0,comm),Uc);
   V = Pci*Uc;
}//EOF ...
func real[int] DJ(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
   V =  Ai*U;
  V = onG10 ? 0.: V;  // remove internal boundary  
  return V; 
}

func real[int] PDJ(real[int]& U) // C1
{ 
  real[int] V(U.n); 
  
  real[int] b= onG10 ? 0. :  U; 
  V =  Ai^-1*b;	
  Update(V,U);
  return U; 
}

func real[int] PDJC(real[int]& U) // 
{ // Precon  C1= Precon //, C2  precon Coarse
// Idea : F. Nataf. 
  //  0 ~  (I C1A)(I-C2A) => I ~  - C1AC2A +C1A +C2A 
  //  New Prec P= C1+C2 - C1AC2   = C1(I- A C2) +C2
  // (  C1(I- A C2) +C2 ) Uo 
  //   V =  - C2*Uo
  // .... 
  real[int] V(U.n); 
  CoarseSolve(V,U,comm);
  V = -V; //  -C2*Uo 
  U  += Ai*V; // U =  (I-A C2) Uo 
  real[int] b= onG10 ? 0. :  U; 
  U =  Ai^-1*b;	//  ( C1( I -A C2) Uo 
  V = U -V; //  
  Update(V,U);
  return U; 
}


 func real[int] DJ0(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
  real[int] b= onG .* U;
  b  = onG ? b : Bi ;  
  V = Ai^-1*b;	
  Update(V,U);
  V -= U;
   return V; 
}


Whi u=0,v;
{ // verification.....
  Whi u=1,v;
  Update(u[],v[]);
  u[]-=v[];
  assert( u[].linfty<1e-6); }
  


settt
u[]=vBC(0,Whi,tgv=1); // set u with tge BC value ...

real epss=1e-6;
int rgmres=0;
if(gmres==1)
  {
   rgmres=MPIAffineGMRES(DJ0,u[],veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
   real[int] b= onG .* u[];
   b  = onG ? b : Bi ;
   v[] = Ai^-1*b;	
   Update(v[],u[]);
  }
else if(gmres==2)
  rgmres= MPILinearGMRES(DJ,precon=PDJ,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else if(gmres==3)
   rgmres= MPILinearGMRES(DJ,precon=PDJC,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else // algo Shwarz for demo ...
   for(int iter=0;iter <10; ++iter)
     {
       real[int] b= onG .* u[];
       b  = onG ? b : Bi ;
       v[] = Ai^-1*b;	
       
       Update(v[],u[]);
       if(vdebug) plotMPIall(Thi,u[],"u-"+iter);
        v[] -= u[];
       
       real err = v[].linfty;
       real umax = u[].max;
       real[int] aa=[err,umax], bb(2);
       mpiAllReduce(aa,bb,comm,mpiMAX);
       real errg = bb[0];
       real umaxg = bb[1];
       
       if(ipart==0)
	     cout << ipart << " err = " << errg << " u. max  " << umaxg << endl;
       if(errg< 1e-5) break;
     }
if(vdebug) plotMPIall(Thi,u[],"u-final");

settt

real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << kiter <<  endl;
}

if(sff != "")
  {
    ofstream ff(sff+".txt",append);
    cout << " ++++  " ;
    cout  << mpirank <<"/" <<  mpisize << " k=" <<  ksplit << " n= " << nloc << " " << sizeoverlaps << " it=  " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      cout << " " << ttt[i]-ttt[i-1] << " ";
    cout << epss << " " << Ai.nbcoef << " " << Ai.n << endl;
    
    /*
      1 mpirank
      2 mpisize 
      3 ksplit 
      4 nloc
      5 sizeoverlaps
      6 kiter
      7 mesh3 & part build  
      8 build the partion 
      9 build mesh3, transfere , and the fine mesh3 .. 
      10 build the matrix,  the trans matrix, factorizatioon 
      11 GMRES 
    */
    ff   << mpirank << " " << mpisize << " " << sPk << " " ;
    ff <<  ksplit << " " << nloc << " " << sizeoverlaps << " " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      ff << " " << ttt[i]-ttt[i-1] << " ";
    ff << epss << " " << Ai.nbcoef << " " << Ai.n << " " << gmres << endl;
    
  }
//  a new coding  methode de schwarz 
//  -------------------------------
// F.Hecht december 2003
// ----------------------------------
//  to test the broadcast instruction 
//  add add the stop test 
//  ---------------------------------
// NBPROC 2

if ( mpisize != 2 ) {
cout << " sorry number of processeur !=2 " << endl;
exit(1);}
verbosity=3;
real pi=4*atan(1);
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh Th0,Th1;

if (mpirank == 0) 
 Th0 = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
else
 Th1 = buildmesh ( e(5*n) + e1(25*n) );

broadcast(processor(0),Th0);
broadcast(processor(1),Th1);

fespace Vh1(Th1,P1);
fespace Vh0(Th0,P1);
Vh0 u0,v0;	
Vh1 u1=0,v1;

int i=0;

problem pb0(u0,v0,init=i,solver=Cholesky) = 
    int2d(Th0)( dx(u0)*dx(v0)+dy(u0)*dy(v0) )
  + int2d(Th0)( -v0) + on(inside,u0 = u1)  +    on(outside,u0= 0 ) ;

problem pb1(u1,v1,init=i,solver=Cholesky) = 
    int2d(Th1)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  + int2d(Th1)( -v1) + on(inside ,u1 = u0) +    on(outside,u1 = 0 ) ;


for ( i=0 ;i< 20; i++) 
{ 
  cout << mpirank << " looP " << i << endl;
  if (mpirank == 0)
    pb0; 
   else
    pb1;
   broadcast(processor(0),u0[]);
   broadcast(processor(1),u1[]);
   real err0,err1;
   if (mpirank == 0)
     err0 = int1d(Th0,inside)(square(u0-u1)) ;
   else 
     err1= int1d(Th1,inside)(square(u0-u1)) ;
   broadcast(processor(0),err0);
   broadcast(processor(1),err1);  
   real err= sqrt(err0+err1);
   cout <<" err = " << err << " err0 = " << err0 << ", err1 = " << err1 << endl;
   if(err<1e-3) break;
};
 if (mpirank==0)  
    plot(u0,u1,ps="u0-u1.eps");
//ff-mpirun  -np  4 heat-torus-3d-surf.edp -wg -ffddm_schwarz_method ras -ffddm_geneo_nu 10 -global 5

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -ffddm_schwarz_method ras -ffddm_geneo_nu 10 -global 5

macro dimension 3S// EOM            // 2D or 3D

include "ffddm.idp"


macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

real R = 3, r=1; 
int nx = r*2*pi*getARGV("-global", 5);
int ny = R*2*pi*getARGV("-global", 5);

meshS ThGlobal = square3(nx,ny,[(R+r*cos(2*pi*x))*cos(2*pi*y),(R+r*cos(2*pi*x))*sin(2*pi*y),r*sin(2*pi*x)]);

func f = 100*exp(-20*((x-0)^2+(y-(R+r))^2+z^2));

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int2d(meshName)(u*v + dt * grad(u)' * grad(v)) +int2d(meshName)(un*v + f*v);
// EOM

int nt = 50;
real dt = 0.5;

ffddmbuildDmesh(Lap, ThGlobal, mpiCommWorld)
ffddmbuildDfespace(Lap, Lap, real, def, init, P1)

LapVhi u, un;

ffddmsetupOperator(Lap, Lap, Varf)
ffddmsetupPrecond(Lap, Varf)
ffddmgeneosetup(Lap, Varf)

real[int] rhs(LapVhi.ndof);

un = 0;

for (int i = 0; i < nt; i++) {
  ffddmbuildrhs(Lap, Varf, rhs)
  u[] = LapfGMRES(un[], rhs, 1.e-6, 200, "right");
  ffddmplot(Lap,u, "u");
  un[] = u[];
}

Lapwritesummary
//ff-mpirun  -np 4 diffusion-3d-minimal-direct.edp -wg -raspart -global 20

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// Abstract "Lap: Direct solver (MUMPS) :" << endl;//direct parallel solver 

// for the make check:
// NBPROC 4
// PARAM -raspart -global 20


macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient

int[int] LL = [2,2, 1,2, 2,2];
mesh3 ThGlobal = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10),
    [x, y, z], label = LL);      // global mesh

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int3d(meshName)(grad(u)' * grad(v)) + int3d(meshName)(v) + on(1, u = 1.0); // EOM
       
// Domain decomposition
ffddmbuildDmesh( Lap , ThGlobal , mpiCommWorld )
ffddmbuildDfespace( Lap , Lap , real , def , init , P1 )
ffddmsetupOperator(Lap ,Lap , Varf)

// Distributed Direct solve
real[int] rhs(LapVhi.ndof);//rhs(1) works as well 
ffddmbuildrhs(Lap , Varf , rhs )
LapVhi def(udirectsolver);

//Direct solve
udirectsolver[] = Lapdirectsolve(rhs);
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,udirectsolver, "Lap Global solution with direct solver");


//ff-mpirun  -np 4 Richards-2d.edp -wg -ns -ffddm_disable_plots

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -ffddm_disable_plots -nt 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

int nt = getARGV("-nt", 100);

searchMethod = 1; // safe search algo, use brute force in case of missing point

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P1;

real Ks=0.01,
     hg=30,
     thetas=0.3,
     eta = 6.55,
     m = 0.173,
     n = 2/(1-m);
     
     
real z0=215;
real q0=15/3600.;
real dt=60;

// $A(h) - \partial h / \partial t - div(K(h)(\nabla(h-y)) = f $ dans $ \Omega$
//  -K(h)(\nabla(h-y)). n = q0 $ sur $ \Gamma_1$
//  h = h_0$ sur $\Gamma_0$
//  + condition initial $d_d$
//   A(h) = h <0 ? C(h) : 0; 
//  


// remarque z == y 
real xmax = 300, ymax=300, x0=60, y0= 215;

border ba(t=0,ymax)   { x=0; y=ymax-t ;label=2;};  // left   
   
border bb1(t=x0,0)    { x=t; y=ymax ;label=1;};   // top     1 
border bb2(t=xmax,x0) { x=t; y=ymax ;label=2;};  // top   2   
 
border bc1(t=y0,0) { x=xmax; y=ymax-t ;label=2;};  // right     
border bc2(t=ymax,y0) { x=xmax; y=ymax-t ;label=3;};  // right  
   
border bd(t=0,xmax)   { x=t; y=0; label=4;};   // bottom

int Gamma0=3;
int Gamma1=1;

int nn=20;
int nn1=nn*x0/xmax,nn2=nn-nn1;
int ny1=nn*y0/ymax,ny2=nn-ny1;
plot(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn),wait=1);
mesh Th=buildmesh(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn));
plot(Th,wait=1);

mesh Thc = Th;

fespace Vh(Th,P1);
Vh h,v,hhh;

macro theta(h) (thetas*(1+((abs(h)/hg))^n)^(-m))//
macro dtheta(h) (m*n*thetas*(1+((abs(h)/hg))^n)^(-m-1)*(((abs(h)/hg))^(n-1))/hg)
//
macro A(h)  ( (h<=0)* dtheta(h) ) 
//
macro K(h) (Ks*((h<=0)*((theta(h)/thetas)^eta)+ (h>0)))
//

Vh hd= -y0+(ymax-y); // bof bof ????
Vh hn=hd,hh;
Vh Ahdt,Kh;

int nbiso=20;
real[int] viso(3+(75+110/2)/5);

{int k=0;
for(int i=-75;i<0;i+=5)
 viso(k++)=i;
 viso(k++)=-0.5;
 viso(k++)=0.;
 viso(k++)=0.5;
for(int i=5;i<=110;i+=5*2)
 viso(k++)=i;
}
/* 
problem Richard(h,v) =
  int2d(Th)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(Th)( Ahdt* hn*v - Kh* dy(v) )
- int1d(Th,Gamma1)(q0*v)
+ on(3,h=(ymax-y)-y0)
;
*/

real pena=1e10;

macro VarfPb(varfName, meshName, VhName)

  VhName mh, mhn;
  RfromVhi(hi[],VhName,mh[])
  RfromVhi(hin[],VhName,mhn[])
  VhName Ahdt = A(mh)/dt;
  VhName Kh = K(mh);

  varf varfName(h,v) =
  int2d(meshName)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(meshName)( Ahdt* mhn*v - Kh* dy(v) )
- int1d(meshName,Gamma1)(q0*v)
 +int1d(meshName,3)(pena*h*v)-int1d(Th,3)(pena*((ymax-y)-y0)* v)

; // EOM

plot(hn,wait=1,cmm=" hd ");

macro Rdefmplot(u)u//EOM

//macro Rwithhpddmkrylov()1//EOM

ffddmbuildDmeshAug(R,Th,mpiCommWorld)

ffddmbuildDfespace(R,R,real,def,init,Pk)

ffddmsetupinit(R,R)// 

ffddmset(R,verbosity,1)// 

RVhi hi=hd, hin=hd;

real[int] rhs;

// Richard;
// plot(hd,wait=1,cmm="hd ----");
real temps=0;
for(int ii=0;ii<nt;ii++)
{
  string scmm="h + temps "+int(temps)/3600+"h "+ ((temps)%3600/60.) + "mn ";
  for(int k=0;k<3;k++) 
  {

	ffddmsetup(R,R,VarfPb,null)
	
	ffddmbuildrhs(R,VarfPb,rhs)
	
	rhs = -rhs;
  
  //cout << " "<< Kh[].min << " " << Kh[].max << endl;
 // plot(Ahdt,fill=1,value=1,wait=1,cmm="Ahdt");
 // plot(Kh,fill=1,value=1,wait=1,cmm="Kh");
 // plot(Kh,wait=1,cmm="Kh");

	hi[] = RfGMRES(hi[], rhs, -1.e-6, 200, "right");

  // forces a refresh of the FE function h, so that it is defined on the currrent mesh Th
  // in particular, the underlying array h[] has the correct size
  h = 0.;
  
	RfromVhi(hi[],Vh,h[]);

  // plot(h,wait=0,cmm=scmm,viso=viso);
//  hhh = h <0;
  }
  if(ii%10==1) {
  Th=adaptmesh(Th,h,ratio=1.1,err=2e-2);
  broadcast(processor(0),Th);
  
  // the mesh has changed ; we create a new decomposition and obtain new local meshes
  ffddmbuildDmeshAug(R,Th,mpiCommWorld)
  ffddmbuildDfespace(R,R,real,def,init,Pk)
  // interpolate the solution at the previous time step on the new local mesh 
  hi = h;
  
//  plot(Th,h,cmm="h ",value=1,wait=1);
  }
 // plot(hhh,wait=1,cmm="h < 0");

  plot(h,wait=0,cmm=scmm,viso=viso,value=1);
//  plot(h,cmm="h ",value=1);
  hin = hi;
  temps += dt;
}

Rwritesummary
//ff-mpirun -np 8 natural_convection_3D_obstacle.edp -raspart -ffddm_schwarz_method oras -wg -ffddm_medit -global 9 -CSsplit 3

//large scale case : ff-mpirun  -np 224 natural_convection_3D_obstacle.edp -raspart -ffddm_schwarz_method oras -ns -nw -global 36 -noGlob -CSsplit 6 -ffddm_master_p 2 -ffddm_master_exclude 1

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -Ra 1e4 -global 4 -CSsplit 2

macro dimension()3// EOM            // 2D or 3D

include "ffddm.idp"


searchMethod = 1;

macro def(i)[i, i#B, i#C, i#D, i#E]// EOM     // vector field definition
macro init(i)[i, i, i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u),dz(u)]// EOM   // two-dimensional gradient
macro Grad(u1,u2,u3)[dx(u1),dy(u1),dz(u1),dx(u2),dy(u2),dz(u2),dx(u3),dy(u3),dz(u3)]//
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
macro UgradU(uw,u)[[uw,uw#B,uw#C]'*grad(u),[uw,uw#B,uw#C]'*grad(u#B),[uw,uw#B,uw#C]'*grad(u#C)]//
func Pk = [P2, P2, P2, P1, P1];             // finite element space

real Ra=getARGV("-Ra", 1.e4);
real Pr=0.71;
real Rey=sqrt(Ra/Pr);
real IRe=1./Rey, IRa=Ra/(Rey*Rey*Pr), IPr=1./(Rey*Pr);

real Thot=0.5, Tcold=-0.5, Tin=0.8;

real eps = 1e-7; // penalisation dans Navier-Stokes

int newtonMax = 20; 
real tolNewton = 1.e-3;

real coef;

int np = getARGV("-global", 6);

int mysplit = getARGV("-CSsplit", 3);

// maillage grossier pour le precond 2 niveaux
mesh3 Thc = cube(np/mysplit,np/mysplit,np/mysplit, [x, y, z]);
Thc = trunc(Thc,(((x>0.66|x<0.33) |(y>0.66|y<0.33)| (z>0.66|z<0.33))),label=20);

// maillage fin defini en splittant le maillage grossier : on split les aretes du maillage grossier en 3 (parametre mysplit) -> les 2 maillages sont emboites
mesh3 ThGlobal = trunc(Thc,1,split=mysplit);

//macro NCdefplot(u)u#E//

// on construit la decomposition avec recouvrement (le "aug" signifie qu'on fait egalement le necessaire pour pouvoir recuperer la solution syncronisee sur les ThAugmented, ce qui va nous servir pour avoir la matrice restreinte au sous-domaine (qui depend de la solution precedente) correcte).
// "NC" est un prefixe, un nom qu'on choisit en input, qui va correspondre a une simulation (on peut combiner et resoudre de maniere differente plusieurs problemes dans le meme script)
// Toutes les structures de donnees creees par la suite auront un nom prefixe par "NC"
ffddmbuildDmeshAug(NC,ThGlobal,mpiCommWorld)
ffddmbuildDfespace(NC,NC,real,def,init,Pk)

// tgv = -1 -> pseudo elimination pour les conditions de Dirichlet (on met 1 sur la diagonale et 0 ailleurs sur la ligne).
vtgv = -1;
vtgvelim = -1;
vsym = 0;

// la definition de la macro ci-dessous signifie qu'on veut utiliser le GMRES d'hpddm, mais avec notre preconditionneur (par defaut si on ne la definit pas on utilise un GMRES parallele "maison" en freefem, defini dans ffddm_functions.idp)
macro NCwithhpddmkrylov()1//

// on initialise les structures pour le 1er niveau du precond (tout sauf ce qui depend de l'edp -- on apellera plus tard ffddmsetup(NC,Varf,VarfOpt) a chaque iteration pour assembler les matrices locales a partir des formulations variationnelles, qui changent a chaque iteration)
ffddmsetupinit(NC,NC)

// NCpCS est le nombre de coeurs qui s'occupent du probleme grossier, donne par -ffddm_master_p (1 par defaut). Si NCpCS > 1, alors on "distribue" les elements du maillage grossier en utilisant les regions, pour distribuer plus tard l'assemblage du probleme grossier sur les NCpCS coeurs.
if (NCpCS > 1) {
	int[int] nupart(Thc.nt);
	nupart=0;
	if (mpirank == 0)
		scotch(nupart, Thc, NCpCS);
	if (mpirank < NCpCS) {
		broadcast(processor(0,NCcommCS),nupart);
		Thc=change(Thc,fregion=nupart[nuTriangle]);
	}
}

// on initialise les structures pour le 2e niveau (grossier) du precond (tout sauf ce qui depend de l'edp -- on apellera plus tard ffddmcoarsemeshsetup(NC,Thc,VarfCS,null) a chaque iteration pour assembler la matrice du probleme grossier)
ffddmcoarsemeshsetupinit(NC,Thc)

// [uG,uGB,uGC,pG,TG] est destinee a etre l'interpolation de la solution sur le maillage grossier et interviendra dans l'assemblage du probleme grossier (mais en fait on ne va pas l'utiliser car ca marche beaucoup mieux sans !)
NCVhCoarse [uG,uGB,uGC,pG,TG];
uG[] = 0;

ffddmset(NC,verbosity,10)

// solutions locales
NCVhi [ui,uiB,uiC,pi,Ti], [upi,upiB,upiC,ppi,Tpi];

real[int] rhs;

// la formulation variationnelle pour le probleme initial (pour le produit matrice-vecteur A). On va l'assembler sur les maillage locaux "augmentes" (anciennement les ThAugmented).
macro Varf(varfName, meshName, VhName)
	/* on syncronise la solution precedente (ui[] en local) sur les maillages locaux augmentes. le fespace courant qu'on utilise est "VhName" (qui correspondra au fespace sur maillages augmentes). Le resultat est uG (solution qui est donc syncronisee sur les maillages augmentes apres le call). */
	VhName [uG,uGB,uGC,pG,TG];
	NCfromVhi(ui[],VhName,uG[])
	
    varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(uG,uw)'*[v,vB,vC]
         + UgradU(uw,uG)'*[v,vB,vC]
         + ( Grad(uw,uwB,uwC)'*Grad(v,vB,vC))*IRe
         - coef*IRa*Tw*vB
         -[uG,uGB,uGC]'*grad(W)*Tw
         -[uw,uwB,uwC]'*grad(W)*TG
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

// la formulation variationnelle pour le probleme grossier. On enleve les termes qui dependent de la solution precedente, et ca marche quand meme tres bien.
macro VarfCS(varfName, meshName, VhName)
    varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         /*+ UgradU(uG,uw)'*[v,vB,vC]
         + UgradU(uw,uG)'*[v,vB,vC]*/
         + ( Grad(uw,uwB,uwC)'*Grad(v,vB,vC))*IRe
         - coef*IRa*Tw*vB
         /*-[uG,uGB,uGC]'*grad(W)*Tw
         -[uw,uwB,uwC]'*grad(W)*TG*/
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

// la formulation variationnelle pour le 1er niveau du preconditionneur (optimized schwarz). On integre sur les maillages locaux (NCThi), donc on peut utiliser directement la solution locale precedente ui. La condition optimisee sur les interfaces (bord 10) est un choix a faire, celle-ci semble bien marcher.
macro VarfOpt(varfName, meshName, VhName)
    varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(ui,uw)'*[v,vB,vC]
         + UgradU(uw,ui)'*[v,vB,vC]
         + ( Grad(uw,uwB,uwC)'*Grad(v,vB,vC))*IRe
         - coef*IRa*Tw*vB
         -[ui,uiB,uiC]'*grad(W)*Tw
         -[uw,uwB,uwC]'*grad(W)*Ti
         + grad(Tw)'*grad(W)*IPr)
    + int2d(meshName,10)(20./hTriangle*IRe*[uw,uwB,uwC]'*[v,vB,vC]+20*1./hTriangle*[pw, Tw]'*[q, W])
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

macro Varfrhs(varfName, meshName, VhName)
	varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(
         UgradU(ui,ui)'*[v,vB,vC]       
         - [ui,uiB,uiC]'*grad(W)*Ti       
     )
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

int nstep= max((int(log10(Ra)-4)^2), 2)*max(log10(Ra)-7.,1.);

[ui,uiB,uiC,pi,Ti]=[0,0,0,0,Thot+x*(Tcold-Thot)];

int iter=0;

for(int step=1; step <= nstep; ++step)
{
   iter++;

    real err=1e100;
    real errp = err;
    coef = (step/real(nstep))^3; // continuation sur le coef en temperature ...
    if (mpirank == 0)
      cout<< "---------------  continuation coef*Ra=" << coef*Ra << endl;

   // Iteration de Newton ---------------------------
   for(int niter=0 ; niter < newtonMax ; niter++){
   	
   	 //le call NCfromVhi permet d'interpoler la solution locale fine sur le maillage grossier, mais on a finalement enleve les termes qui dependent de la solution precedente dans le probleme grossier
	 //NCfromVhi(ui[],NCVhCoarse,uG[])

	 // on assemble les matrices locales (Varf pour le produit matrice-vecteur A, VarfOpt pour le 1er niveau du preconditionneur)
	 ffddmsetup(NC,NC,Varf,VarfOpt)
	 
	 // on assemble le probleme grossier. On repasse pour l'occasion en mode penalisation exacte avec des 1e+30 sur la diagonale pour les conditions de Dirichlet, ca marche en general mieux et c'est plus simple lorsque la matrice est distribuee (sur les NCpCS coeurs du probleme grossier).
	 // remarque : si -ffddm_master_exclude 1, les calls ffddmsetup et ffddmcoarsemeshsetup sont faits en parallele : les coeurs qui ne s'occupent que du 1er niveau assemblent les matrices locales dans ffddmsetup, et les coeurs qui ne s'occupent que du probleme grossier l'assemblent dans ffddmcoarsemeshsetup
	 vtgv = 1.e+30/NCpCS; 
	 ffddmcoarsemeshsetup(NC,Thc,VarfCS,null)	 
	 vtgv = -1;
	 
	 // assemblage du second membre
     ffddmbuildrhs(NC,Varfrhs,rhs)

	 // resolution
     ui[] = NCfGMRES(ui[], rhs, 1.e-8, 200, "right");
     
     upi[] -= ui[];
     real reduce = upi[].linfty;
     upi[]  = ui[];
     mpiAllReduce(reduce, err, mpiCommWorld, mpiMAX);

     if(mpirank == 0)
	   cout << "niter = " << niter << " err =  " << err << endl;

     if(err > errp*100) break;
     if(err < tolNewton) break;
   }
   
   ffddmplot(NC,Ti, "Global solution");

}

NCwritesummary

// on peut aussi automatiquement mettre la solution locale ui sur n'importe quel maillage (global) avec NCfromVhi, qui interpole et fait les communications
fespace Vhg(ThGlobal,Pk);
Vhg [u1s,u2s,u3s,ps,Ts];
NCfromVhi(ui[],Vhg,u1s[])

int[int] fforder=[1,1,1,1];
load "iovtk"
if (mpirank == 0)
	savevtk("sol.vtk",ThGlobal,u1s,u2s,u3s,Ts,dataname="VelocityX VelocityY VelocityZ Temperature",order=fforder);

//ff-mpirun  -np  4 diffusion-3d-simple.edp -wg -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"


macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

int[int] LL = [2,2, 1,2, 2,2];
mesh3 ThGlobal = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10),
    [x, y, z], label = LL);      // global mesh


macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int3d(meshName)(grad(u)' * grad(v)) + int3d(meshName)(v) + on(1, u = 1.0); // EOM
       
// Domain decomposition
ffddmbuildDmesh( Lap , ThGlobal , mpiCommWorld )
savemesh(LapThi,"localTh"+mpirank+".mesh");
ffddmbuildDfespace( Lap , Lap , real , def , init , P1 )
ffddmsetupOperator( Lap , Lap , Varf)

//distributed matrix vector product
LapVhi uux=1.;
real[int] Au = LapA(uux[]);

// Distributed Direct and domain decomposition solves
real[int] rhs(LapVhi.ndof);//rhs(1) works as well 
ffddmbuildrhs(Lap,Varf,rhs)
LapVhi def(u) , def(udirectsolver);

//Direct solve
if (mpirank == 0) cout << endl << "Lap: Direct solver (MUMPS) :" << endl;//direct parallel solver 
udirectsolver[] = Lapdirectsolve(rhs);
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,udirectsolver, "Lap Global solution with direct solver");

// Two-level Schwarz solve
if (mpirank == 0) cout << endl << "Lap: RAS + GENEO :" << endl; //second level method with a GenEO coarse space
ffddmsetupPrecond(Lap,Varf)
ffddmgeneosetup(Lap,Varf)

real[int] x0(LapVhi.ndof);
x0 = 0;
u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,u, "Lap Global solution with fGMRES");

// Visualization and computation of relative error w.r.t. direct solver 
LapVhi error;
error[] = u[]-udirectsolver[];
real solnorm2 = Lapscalprod(u[],u[]) ,  errnorm2 = Lapscalprod(error[],error[])  ;
if(mpirank == 0) cout << endl << "Relative error w.r.t. to direct solver : " <<  sqrt(errnorm2/solnorm2) << "\n" << endl;
ffddmplot(Lap,error, "Difference between direct and ddm solve");

real solnorm2global = Lapscalprod(u[],u[]);

cout << solnorm2 << " ==  " <<  solnorm2global << "??"  << endl;









load "geophysics"

include "getARGV.idp"

real gtol = getARGV("-tol",1e-4);

func Pk = P2;

real freq = getARGV("-frequency",10.); // frequency
real nppwl = getARGV("-nppwl",5.); // number of points per wavelength

macro dimension 2// EOM            // 2D or 3D
include "ffddm.idp"

real c0 = 2;

//Marmousi marm("marmousi.bin");
func c = c0;//marm(x,y);

func k = 2*pi*freq/c;

real k0 = 2*pi*freq/c0;

real lambda = c0/freq;

int Robin = 2;
int[int] lab = [Robin,Robin,Robin,Robin];

real length = 9.2;
real depth = 3;

mesh Th = square(nppwl*length/lambda,nppwl*depth/lambda,[x*length,-y*depth],label=lab);

fespace Uh(Th,P1);
Uh met = c/freq/nppwl;
Th = adaptmesh(Th,met,IsMetric=1,nbvx=1000000);

func source = exp(-((x-6)^2+y^2)*50*k0);

ffddmoverlap = 0;
macro mminoverlap()1//
ffddmbuildDmesh(,Th,mpiCommWorld)

macro def(i)i// EOM
macro init(i)i// EOM
ffddmbuildDfespace( , ,complex,def,init,Pk)

macro Grad(u) [dx(u),dy(u)] // EOM

varf vAi(u,v) = int2d(Thi)(-k^2*u*v+Grad(u)'*Grad(v))
				      - int1d(Thi,Robin)(1i*k*u*v);

varf vrhs(u,v) = int2d(Thi)(source*v);

matrix<complex> Ai = vAi(Vhi,Vhi);

int[int] labG=[ffddminterfacelabel];
meshL Gammai = extract(Thi,label=labG);

fespace GammaVhi(Gammai,Pk);

matrix<complex> Ric;
{
  matrix Ri = interpolate(GammaVhi,Vhi);
  Ric = Ri;
}

matrix<complex> Ti;
/*
{
varf vTi(u,v) = int1d(Gammai)(k*u*v);
Ti = vTi(GammaVhi,GammaVhi);
}
*/
{
load "bem"
varf vH(u,v) = int1dx1d(Gammai)(Gammai)(BEM(BemKernel("HS",k=1i*k0),u,v));  
HMatrix<complex> H = vH(GammaVhi,GammaVhi,commworld=mpiCommSelf,compressor="SVD");
display(H);
complex[int,int] mdense(GammaVhi.ndof, GammaVhi.ndof);
mdense = H;
Ti = mdense;
if (mpirank == 0) cout << H.infos << endl;
}

matrix<complex> GTi = Ric'*Ti;
GTi = GTi*Ric;

matrix<complex> Li = Ai - 1i*GTi;
set(Li,solver=sparsesolver,commworld=mpiCommSelf,factorize=3);

matrix<complex> mat;

complex[int] GammaDk = Ric*Dk[mpirank];
{
  complex[int] Diinv = 1./GammaDk;
  matrix<complex> mDiinv = Diinv;
  mat = mDiinv*Ti;
}

int[int][int] petscintersection(1 + numberIntersection);
{
  petscintersection[0].resize(arrayIntersection.n);
  petscintersection[0] = arrayIntersection;
  complex[int] CC;
  int[int] II;
  for (int j=0; j<numberIntersection;j++) {
    matrix<complex> RR = restrictionIntersection[j]*Ric';
    [II, petscintersection[1 + j], CC] = RR;
    if (CC[CC.n-1] == 0) petscintersection[1 + j].resize(CC.n-1);
  }
}

real[int] petscD = GammaDk.re;

load "PETSc-complex"
Mat<complex> Tpetsc(mat, petscintersection, petscD, communicator = mpiCommWorld);

set(Tpetsc,sparams="-ksp_converged_reason -pc_type lu -ksp_rtol "+gtol);

complex[int] ti(GammaVhi.ndof), qi(GammaVhi.ndof), di(GammaVhi.ndof), gi(GammaVhi.ndof), Tg(GammaVhi.ndof);
complex[int] ui(Vhi.ndof), vti(Vhi.ndof);

func complex[int] OP(complex[int] &pi)
{
  ti = Ti*pi;
  vti = Ric'*ti;
  ui = Li^-1*vti;

  qi = Ric*ui;
  qi *= -2i;

  di = pi - qi;

  gi = Ti*di;

  exchange(Tpetsc,gi,scaled=false);

  Tg = 0;
  Tg = Tpetsc^-1*gi;

  complex[int] res = qi + 2*Tg;

  return res;
}

complex[int] rhsi = vrhs(0,Vhi);
update(rhsi,true);

GammaVhi<complex> soli, bi;
{
  complex[int] vi = Li^-1*rhsi;

  bi[] = Ric*vi;
  bi[] *= 2i;

  complex[int] tmp = Ric * vi;
  complex[int] gi = Ti*tmp;
  gi *= 2i;
  
  exchange(Tpetsc,gi,scaled=false);

  complex[int] ri(gi.n);
  ri = Tpetsc^-1*gi;
  bi[] -= 2*ri;
}

Mat<complex> OPshell(GammaVhi.ndof);
Mat<complex> OPpetsc(OPshell,OP);
set(OPpetsc,sparams = "-ksp_monitor -pc_type none -ksp_rtol "+gtol);

soli[] = OPpetsc^-1*bi[];

complex[int] si = Ti*soli[];
complex[int] wi = Ric'*si;
wi += rhsi;

Vhi<complex> vi;

vi[] = Li^-1*wi;

ffddmplot(,real(vi), "Global solution");



//ff-mpirun -np 4 Helmholtz-2d-interfaceBCs-comp.edp -ns -wg

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -frequency 2.0

macro dimension 2// EOM            // 2D or 3D

load "bem"
include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;

int Dirichlet = 1;
int Robin = 2;

int[int] labs=[Robin, Robin, Robin, Robin];
//int[int] labs=[Dirichlet, Dirichlet, Dirichlet, Dirichlet];

real freq = getARGV("-frequency",4.0);
func k = 2.*pi*freq;
real lambda = (1./freq);
if (mpirank == 0) cout << "lambda = " << lambda << endl;

real nppwl = getARGV("-nppwl",10.0);
real h = lambda/nppwl;

real length = 1.;
real lengthpml = getARGV("-lengthpml",1.0)*lambda;

real nloc = nppwl*length/lambda;
int npl = nloc*(length+2*lengthpml)/length;
mesh Th = square(npl,npl,[x*(length+2*lengthpml)-lengthpml, y*(length+2*lengthpml)-lengthpml], label = labs);

func f = 100*exp(-((x-length/2)^2+(y-length/2)^2)*k*10);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*u*v+Grad(u)'*Grad(v))
				- int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOptRobin(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*u*v+Grad(u)'*Grad(v))
				- int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

macro HFEdefmplot(u)real(u)//

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmsetupOperator(H,HFE,Varf)

ffddmprecond = "oras";

complex[int] rhs(1);
ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;
HFEVhi<complex> def(u);

{
NewMacro HRobinmyA()
func complex[int] HRobinA(complex[int] &l) {return HA(l);}
EndMacro

ffddmsetupinit(HRobin,HFE)

ffddmsetupPrecond(HRobin,VarfOptRobin)

if (mpirank == 0) cout << "Robin:" << endl;

u[] = HRobinfGMRES(x0, rhs, 1.e-6, 200, "right");

HRobinwritesummary
}

{
NewMacro HBEMmyA()
func complex[int] HBEMA(complex[int] &l) {return HA(l);}
EndMacro

meshL ThiL = extract(HmeshThi);
ThiL = OrientNormal(ThiL,unbounded=1);
ThiL = trunc(ThiL,region==10);

fespace VhiL(ThiL,Pk);
fespace Chi = HFEVhi*VhiL;

varf vc(<[ufem],[ubem]>,<[v1],[v2]>) = int2d(HmeshThi)(-k^2*ufem*v1+Grad(ufem)'*Grad(v1)) // F
                              - int1d(HmeshThi,Robin)(1i*k*ufem*v1)
                              + on(Dirichlet,ufem=0)
                              + int1dx1d(ThiL)(ThiL)(BEM(BemKernel("TDL",k=k),ubem,v1)) + int1d(ThiL)(0.5*ubem*v1) // TDL
                              + int1d(ThiL)(ufem*v2)                        // mass
                              + int1dx1d(ThiL)(ThiL)(BEM(-1*BemKernel("SL",k=k),ubem,v2));  // -SL

matrix<complex> HC = vc(Chi,Chi,commworld=mpiCommSelf,factorize=3);

complex[int] rhsi(HFEVhi.ndof+VhiL.ndof);
rhsi = 0;

HFEVhi<complex> ufem;
VhiL<complex> ubem;

NewMacro HBEMmyPREC()
func complex[int] HBEMPREC(complex[int] &l) {
  rhsi(0:HFEVhi.ndof-1) = l;
  complex[int] res = HC^-1*rhsi;
  [ufem[],ubem[]] = res;

  HFEupdate(ufem[],true);

  return ufem[];
}
EndMacro

ffddmsetupinit(HBEM,HFE)

if (mpirank == 0) cout << "BEM:" << endl;

u[] = HBEMfGMRES(x0, rhs, 1.e-6, 200, "right");

HBEMwritesummary
}

ffddmplot(HFE,real(u), "Global solution");


//ff-mpirun -np 8 elasticity-3d-simple.edp -wg -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 20 -global 10

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 20 -global 5

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"


macro def(i)[i, i#B, i#C]// EOM                         // vector field definition
macro init(i)[i, i, i]// EOM                        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1,P1,P1];                               // finite element space

int[int] LL = [2,3, 2,1, 2,2];
mesh3 ThGlobal = cube(6 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [6 * x, y, z], label = LL);

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11;
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
int dirichlet = 1;

macro Varf(varfName, meshName, PhName)
    varf varfName(def(u), def(v)) = int3d(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(meshName)(f * vC) + on(dirichlet, u = 0.0, uB = 0.0, uC = 0.0); // EOM

vtgv = -2;
vtgvelim = -2;
vsym = 1;

ffddmbuild(E,ThGlobal,real,def,init,Pk,mpiCommWorld)

//macro Ewithhpddm()1//

macro Edefmplot(u)u//

ffddmsetup(E,E,Varf,null)

real[int] rhs(1);

ffddmbuildrhs(E,Varf,rhs)

real[int] x0(rhs.n);
x0 = 0;

EVhi def(u), def(err);

//set(EhpddmOP,sparams="-hpddm_reuse_preconditioner 1");

if (mpirank == 0) cout << "RAS :" << endl; 

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO :" << endl; 

ffddmgeneosetup(E,Varf)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

err[] = EA(u[]);
err[] -= rhs;

ffddmplot(E,u, "Global solution");
ffddmplot(E,err, "Global residual");

EVhglob def(uglob);

EfromVhi(u[],EVhglob,uglob[])

real alpha = 20000.0;
EThglob = movemesh3(EThglob, transfo = [x + alpha * uglob, y + alpha * uglobB, z + alpha * uglobC]);
u[] = mpirank;

ffddmplot(E,u, "Deformed mesh");
//ff-mpirun -np 4 Helmholtz-2d-sweeping.edp -ns -wg -raspart -ffddm_overlap 4 -nppwl 4 -frequency 10

macro dimension 2// EOM
include "ffddm.idp"

ffddmprecond = "oras";

macro def(i)i// EOM // scalar field definition
macro init(i)i// EOM // scalar field initialization

real freq = getARGV("-frequency",10.); // frequency
int nppwl = getARGV("-nppwl",4); // number of points per wavelength
int npml = getARGV("-npml",4); // number of points for global PML

load "geophysics"

int Dirichlet = 1;
int Robin = 2;
int Neumann = 7;
int PML = 8;

///*** Waveguide : ***///

real c0 = 1;
real k0 = 2*pi*freq/c0;
real lambda = c0/freq;
func Pk = P2;
int[int] lab = [Dirichlet,Robin,Dirichlet,Robin];
real length = mpisize;
real depth = 1;
func c = 1;
func source = 0;
func sourceGamma = (x < 1e-10)*exp(-120*(y+0.5)^2)*sin(-pi*y);


///*** Cavity : ***///
/*
real c0 = 1;
real k0 = 2*pi*freq/c0;
real lambda = c0/freq;
func Pk = P2;
int[int] lab = [Dirichlet,Robin,Dirichlet,Dirichlet];
real length = mpisize;
real depth = 1;
func c = 1;
func source = 0;
real theta = pi/8;
func sourceGamma = (x > length-1e-10)*exp(-1i*k0*(x*cos(theta)+y*sin(theta)));
*/
///*** Marmousi : ***///
/*
real c0 = 2;
real k0 = 2*pi*freq/c0;
real lambda = c0/freq;
func Pk = P2;
int[int] lab = [PML,PML,Neumann,PML];
real length = 9.2;
real depth = 3;
Marmousi marm("marmousi.bin");
func c = marm(x,y);
real xs = 6;
real ys = 0;
func source = exp(-((x-xs)^2+(y-ys)^2)*50*k0);
func sourceGamma = 0;
*/

if (mpirank == 0) cout << "lambda = " << lambda << ", h = " << lambda/nppwl << endl;

func k = 2*pi*freq/c;

int[int] npmlg(4);

npmlg[0] = npml*(lab[3] == PML); npmlg[1] = npml*(lab[1] == PML);
npmlg[2] = npml*(lab[0] == PML); npmlg[3] = npml*(lab[2] == PML);

real[int] lengthpml(4); // length of global PML
for (int i=0; i<4; i++) lengthpml[i] = npmlg[i]*lambda/nppwl;

int npmli = ffddmoverlap == 2 ? 1 : 2; // number of points in subdomain PML
real lpml = npmli*lambda/nppwl; // length of subdomain PML

real nloc = nppwl/ffddmsplit*length/lambda;

int nx = rint(nloc*(length+lengthpml[0]+lengthpml[1])/length);
int ny = rint(nloc*(depth+lengthpml[2]+lengthpml[3])/length);

mesh Th = square(nx,ny,[-lengthpml[0]+x*(length+lengthpml[0]+lengthpml[1]),-depth-lengthpml[2]+y*(depth+lengthpml[2]+lengthpml[3])],label=lab);

real epst = 1e-10;
func sigmax = (npmlg[0]>0)*(x>=length)/max(epst,(length+lengthpml[1]-x)*real(k))  +  (npmlg[1]>0)*(x<=0)/max(epst,(x + lengthpml[0])*real(k));
func sigmay = (npmlg[3]>0)*(y>=0)/max(epst,(lengthpml[3]-y)*real(k))  +  (npmlg[2]>0)*(y<=-depth)/max(epst,(y+depth + lengthpml[2])*real(k));

macro Grad(u) [dx(u),dy(u)] // EOM
macro Gradpml(u) [(1.+1i*sigmay)/(1.+1i*sigmax)*dx(u),
                  (1.+1i*sigmax)/(1.+1i*sigmay)*dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*(1-1i*sigmax)*(1-1i*sigmay)*u*v+Gradpml(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*(1-1i*sigmax)*(1-1i*sigmay)*u*v)
				+ on(Dirichlet,PML,u=0); // EOM

// for the preconditioner
macro VarfOptRobin(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*(1-1i*sigmax)*(1-1i*sigmay)*u*v+Gradpml(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*(1-1i*sigmax)*(1-1i*sigmay)*u*v)
				+ on(Dirichlet,PML,u=0); // EOM

// for the preconditioner with PMLs
macro VarfOpt(varfName, meshName, PhName)
    /* change definition of sigmax to take subdomain PMLs into account
       d is the distance to the subdomain interface */
    func sigmax = (npmlg[0]>0)*(x>=length)/max(epst,(length+lengthpml[1]-x)*real(k))  +  (npmlg[1]>0)*(x<=0)/max(epst,(x + lengthpml[0])*real(k))
                + (d<=lpml)/max(epst,d*real(k));
    varf varfName(u,v) =
  int2d(meshName)(-k^2*(1-1i*sigmax)*(1-1i*sigmay)*u*v+Gradpml(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*(1-1i*sigmax)*(1-1i*sigmay)*u*v)
				+ on(Dirichlet,PML,10,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                int2d(meshName)(source*v)
                +int1d(meshName,Robin)(sourceGamma*v)
                + on(Dirichlet,PML,u=0); // EOM

vsym = 2; // symmetric, not hermitian
vtgv = -2;
vtgvelim = -2;

/****** ORAS METIS ******/
{
ffddmpartitioner = 1;
ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

HFEVhi<complex> uoras, x0, rhs;
x0[] = 0;

ffddmsetup(ORASMETIS,HFE,Varf,VarfOptRobin)

ffddmbuildrhs(ORASMETIS,Varfrhs,rhs[])

uoras[] = ORASMETISfGMRES(x0[], rhs[], 1.e-6, 2000, "right");

ORASMETISwritesummary

ffddmplot(HFE,real(uoras), "ORASMETIS solution");
}

/****** BAND DECOMPOSITION ******/
macro Hmeshsimple(PhGlobal, part, comm)
int cx = 0, ii = 0;
int zx = mpisize - (nx%mpisize);
int px = nx/mpisize;
int[int] partcube(nx*ny);
for (int i=0; i<nx; i++) {
  for (int j=0; j<ny; j++)
    partcube[j+i*ny] = cx;
  ii++; if (cx < zx) { if (ii == px) {ii = 0; cx++;} } else { if (ii == px+1) {ii=0; cx++;} }
}
part = partcube[int((x+lengthpml[0])/(length+lengthpml[0]+lengthpml[1])*nx)*ny+int(-(y-lengthpml[3])/(depth+lengthpml[2]+lengthpml[3])*ny)];
// EOM

ffddmpartitioner = 0;
ffddmbuildDmeshpartcubes(Hmesh,Th,mpiCommWorld)

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

HFEVhi<complex> uoras, u, x0, rhs;
x0[] = 0;

int[int] labi = [ffddminterfacelabel];
meshL ThGamma = extract(HmeshThi,label=labi); // extract subdomain interface as meshL

real[int] bounds(6);
boundingbox(ThGamma,bounds);

func d = min(abs(x-bounds[0]), abs(x-bounds[1])); // distance to subdomain interface to define subdomain PMLs

NewMacro Generate(pr)
/****** ORAS BAND ******/
IFMACRO(!PMLI)
ffddmsetup(pr#ORAS,HFE,Varf,VarfOptRobin)
ENDIFMACRO
IFMACRO(PMLI)
ffddmsetup(pr#ORAS,HFE,Varf,VarfOpt)
ENDIFMACRO

ffddmbuildrhs(pr#ORAS,Varfrhs,rhs[])

uoras[] = pr#ORASfGMRES(x0[], rhs[], 1.e-6, 2000, "right");

pr#ORASwritesummary

ffddmplot(HFE,real(uoras), Stringification(pr)+"ORAS solution");

/****** BJS ******/
IFMACRO(!PMLI)
varf vGamma(u, v) = on(ffddminterfacelabel, u=1);
complex[int] onGamma = vGamma(0,HFEVhi,tgv=1); // tag interface dofs
ENDIFMACRO

IFMACRO(PMLI)
complex[int] onGamma(HFEVhi.ndof);
{
  onGamma = 0;
  HFEVhi dg = (d <= lpml*(1+1e-10));
  onGamma.re = dg[]; // tag interface PML dofs
}
ENDIFMACRO

complex[int] notonGamma(onGamma.n);
notonGamma = 1;
notonGamma -= onGamma; // tag interior dofs

complex[int] l1(HFEVhi.ndof), trsf(HFEVhi.ndof), rhsi(HFEVhi.ndof);
complex[int] wi(HFEVhi.ndof), vil(HFEVhi.ndof), vir(HFEVhi.ndof), hil(HFEVhi.ndof), hir(HFEVhi.ndof), vhil(HFEVhi.ndof), vhir(HFEVhi.ndof), wi2(HFEVhi.ndof);

macro pr#BJSmyPREC1
func complex[int] pr#BJSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l; /* restrict to interior */

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1; /* local solve */

  for (int i=0; i<Hmeshnpart; i++) {
    /* left to right sweep */
    /* transfer from left neighbor i-1 to i */
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi + vil;
    HFEupdate(trsf,false);

    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      /* apply interface operator */
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      rhsi = onGamma.*rhsi; /* restrict to interface */
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*rhsi;
    }

    /* perform right to left sweep simultaneously */
    int j = Hmeshnpart-i-1;
    /* transfer from right neighbor j+1 to j */
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi + vir;
    HFEupdate(trsf,false);

    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      /* apply interface operator */
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      rhsi = onGamma.*rhsi; /* restrict to interface */
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*rhsi;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#GSSmyPREC1
func complex[int] pr#GSSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  vil = 0;
  vir = 0;

 /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#SGSSmyPREC1
func complex[int] pr#SGSSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  vil = 0;
  vir = 0;

 /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir += onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#JSmyPREC1
func complex[int] pr#JSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  vil = 0;
  vir = 0;

 /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#BSGSSmyPREC1
func complex[int] pr#BSGSSPREC1(complex[int] &ll)
{
  complex[int] l = ll;

  /* STEP 1 */
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi + vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart) {
      trsf = wi + vir;
      trsf += vil;
    }
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  /* STEP 2 */
  vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil -= onGamma.*rhsi;
    }
  }

  vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir -= onGamma.*rhsi;
    }
  }

 /* STEP 3 */
  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir += onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  l = wi;
  l+= vil + vir;

  HFEupdate(l,true);
  return l;
}
//

macro pr#BGSSmyPREC1
func complex[int] pr#BGSSPREC1(complex[int] &ll)
{
  complex[int] l = ll;

  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
    }
  }

  vil = 0;
  vir = 0;
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir += onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  l = wi;
  l+= vil + vir;

  HFEupdate(l,true);

  return l;

  /* STEP 2 */
  vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil -= onGamma.*rhsi;
    }
  }

  vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir -= onGamma.*rhsi;
    }
  }

 /* STEP 3 */

  vhir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
  vhil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
  wi2 = vhil + vhir;

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vhir + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vhil + vil;
    if (mpiRank(Hmeshcommddm) == i+1 && i+1 < Hmeshnpart)
      trsf = vhir + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  l = wi;
  l+= vil + vir;

  HFEupdate(l,true);
  return l;
}
//

/* BJS */
macro pr#BJSmyA
func complex[int] pr#BJSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//

ffddmsetupinit(pr#BJS,HFE)

u[] = pr#BJSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#BJSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"BJS solution");

/* BGSS */
macro pr#BGSSmyA
func complex[int] pr#BGSSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//
ffddmsetupinit(pr#BGSS,HFE)

u[] = pr#BGSSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#BGSSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"BGSS solution");

/* BSGSS */
macro pr#BSGSSmyA
func complex[int] pr#BSGSSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//
ffddmsetupinit(pr#BSGSS,HFE)

u[] = pr#BSGSSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#BSGSSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"BSGSS solution");

/* SGSS */
macro pr#SGSSmyA
func complex[int] pr#SGSSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//
ffddmsetupinit(pr#SGSS,HFE)

u[] = pr#SGSSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#SGSSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"SGSS solution");

EndMacro

/* with PML interface conditions */
{
macro PMLI()1//
Generate(PML)
}

/* with Robin interface conditions */
{
Generate(ROBIN)
}
/* solves the 3D Helmholtz equation with finite-differences using the compact
  wavelength-adaptive 27-point stencil from Aghamiry, H. S., Gholami, A.,
  Combe, L., & Operto, S. (2022). Accurate 3D frequency-domain seismic wave
  modeling with the wavelength-adaptive 27-point finite-difference stencil:
  A tool for full-waveform inversion. Geophysics, 87(3), R305-R324.

  Details about the GO_3D_OBS crustal geomodel can be found at https://www.geoazur.fr/WIND/bin/view/Main/Data/GO3DOBS
  The velocity grid can be downloaded at https://www.geoazur.fr/WIND/pub/nfs/FWI-DATA/GO_3D_OBS/TARGET_PAPERS/v.bin
  File 'Helmholtz_geophysics_rhs_pos.txt' contains the coordinates of the 130 right-hand sides representing a seabed node acquisition

  For a simple test run at low frequency, run:

  ff-mpirun -np 8 Helmholtz_geophysics.edp -ns -nw -frequency 0.3 -nppwl 4 -npml 4 -raspart -ffddm_overlap 3 -npmlprec 2 -tol 1e-4 -murhs 20 -maxrhs 20 -ffddm_verbosity 3

  For a large-scale 3.75 Hz frequency simulation, run:

  ff-mpirun -np 660 Helmholtz_geophysics.edp -ns -nw -frequency 3.75 -nppwl 4 -npml 8 -raspart -noGlob -ffddm_overlap 3 -npmlprec 2 -tol 1e-4 -maxit 150 -ffddm_gmres_restart 150 -murhs 20 -maxrhs 130 -ffddm_verbosity 3
*/

macro FDsimulation()1//
//macro FEsimulation()1// uncomment to perform FE simulation

load "Helmholtz_FD" // plugin implementing the 27-point FD stencil
load "geophysics" // for loading velocity grids of the geomodels

load "parmmg" // for parallel mesh adaption
load "Element_P3" // plugin for P3 finite elements
load "qf11to25" // high order quadrature rules

include "cube.idp"
include "getARGV.idp"

macro dimension 3//EOM
include "ffddm.idp"

real lengthx = 102; //the metric unit is the kilometer
real lengthy = 20;
real depth = 28.3;

int[int] npmlg(6);

real freq = getARGV("-frequency",1.); // frequency
real nppwl = getARGV("-nppwl",4.); // number of points per wavelength
npmlg = getARGV("-npml",8); // number of points in the global PMLs

int npmli = getARGV("-npmlprec",2); // number of points in local PMLs for the preconditioner

int maxit = getARGV("-maxit",400); // maximum number of GMRES iterations for finite differences
real gmrestol = getARGV("-tol",1e-4); // GMRES relative stopping criterion

int maxrhs = getARGV("-maxrhs",130); // total number of RHSs to treat
int murhs = getARGV("-murhs",20); // RHSs are treated by blocks of nrhs

int split = getARGV("-split",2); // splitting ratio for the coarse mesh for finite elements
int maxitFE = getARGV("-maxitFE",30); // maximum number of outer GMRES iterations for finite elements

func PkFE = P2; // P2 or P3 finite elements
macro mqfV()qfVp7//EOM // order 7 quadrature rule for finite elements

// point source coordinates for the single RHS case
real xs = 12.3;
real ys = 10.5;
real zs = -0.9;

// file containing the positions of the 130 RHSs mimicking a sparse seabed node acquisition
ifstream f("Helmholtz_geophysics_rhs_pos.txt");

complex omega = 2.*pi*freq;
real c0 = 1.5; // reference (minimum) velocity
real lambda = (1./freq)*c0;
real h = lambda/nppwl;

if (mpirank == 0) cout << "lambda = " << lambda << ", h = " << h << endl;

// dimensions must be multiples of h
lengthx = h*floor(lengthx/h);
lengthy = h*floor(lengthy/h);
depth = h*floor(depth/h);

real[int]bounds = [0,lengthx,0,lengthy,-depth,0];
Crustal crust("v.bin",bounds); // load the GO_3D_OBS crustal geomodel
func c = crust(x,y,z)/1000;
func mu = c^2;

real[int] lengthpml(6); // length of the global PMLs
for (int i=0; i<6; i++) lengthpml[i] = npmlg[i]*lambda/nppwl;

macro def(u)u//EOM
macro init(u)u//EOM

/***********************************************************************/
/*************************  FINITE DIFFERENCES  ************************/
/***********************************************************************/
IFMACRO(FDsimulation)

real nloc = nppwl/ffddmsplit*lengthx/lambda;

int nplx = rint(nloc*(lengthx+lengthpml[0]+lengthpml[1])/lengthx);
int nply = rint(nloc*(lengthy+lengthpml[2]+lengthpml[3])/lengthx);
int npd = rint(nloc*(depth+lengthpml[4]+lengthpml[5])/lengthx);

int[int] N = [nplx,nply,npd];
real[int,int] Bounds = [[-lengthpml[0],lengthx+lengthpml[1]], [-lengthpml[2],lengthy+lengthpml[3]], [-depth-lengthpml[4],lengthpml[5]]];
int[int,int] Labels = [[11,12],[13,14],[15,16]];

/* partition the domain into overlapping cubic subdomains */
ffddmbuildDmeshpartcubesauto(FDmesh,N,Bounds,Labels,mpiCommWorld)

if (mpirank == 0) cout << "grid size " << nplx+1 << " x " << nply+1 << " x " << npd+1 << endl;

/* define the distributed nodal discretization space */
ffddmbuildDfespace(FDspace,FDmesh,complex,def,init,P1)

//////////// *********** BUILD LOCAL MATRICES *********** ////////////

macro FDmyOperator(matName, meshName, VhName)
/* build local matrices A_i for the matrix-vector product */
int[int] labs = labels(meshName);

int[int] pmls(6);
pmls = -1; /* Dirichlet BC */

for (int i=0; i<labs.n; i++)
if (labs[i] >= 11 && labs[i] <= 16)
  pmls[labs[i]-11] = npmlg[labs[i]-11]; /* global PML boundaries */
matName = HelmholtzFD(meshName,omega,mu,npml=pmls);
//EOM

macro FDmyPrecond(matName, meshName, VhName)
/* build local matrices B_i for the preconditioner */
int[int] labs = labels(meshName);

int[int] pmls(6);
pmls = npmli; /* local PMLs */

for (int i=0; i<labs.n; i++)
if (labs[i] >= 11 && labs[i] <= 16)
  pmls[labs[i]-11] = npmlg[labs[i]-11]; /* global PML boundaries */
matName = HelmholtzFD(meshName,omega,mu,npml=pmls);
//EOM

macro FDwithhpddm()1//EOM

ffddmprecond = "oras";
/* define operator (build A_i) */
ffddmsetupOperator(FD,FDspace,null)
/* define preconditioner (build B_i) */
ffddmsetupPrecond(FD,null)

// set BLR parameters for local solver MUMPS
set(FDhpddmOP,sparams="-hpddm_FD_mumps_icntl_35 2 -hpddm_FD_mumps_cntl_7 1e-3 -hpddm_FD_mumps_icntl_37 0 -hpddm_FD_mumps_icntl_36 1");

// use GMRES with Classical Gram-Schmidt orthogonalization
set(FDhpddmOP,sparams="-hpddm_FD_reuse_preconditioner 1 -hpddm_FD_orthogonalization cgs -hpddm_FD_krylov_method gmres");

//////////// ***********  BUILD RIGHT-HAND SIDES  *********** ////////////
//////////// *********** SOLVE THE LINEAR SYSTEMS *********** ////////////

FDspaceVhi<complex> u, rhs;

int irhs = 0;

if (FDmeshisincomm)
while (irhs < maxrhs) {
  int mu = min(murhs, maxrhs-irhs); // number of treated RHSs for this block

  complex[int] brhs(FDspaceVhi.ndof*mu); // local RHSs

  /* assemble the mu RHSs */
  for (int i = 0; i < mu; i++) {
    if (murhs > 1) { // read RHS position in the file
      f >> zs; zs /= -1000; zs = h*rint(zs/h); // closest FD grid point to source position
      f >> xs; xs /= 1000; xs = h*rint(xs/h);
      f >> ys; ys /= 1000; ys = h*rint(ys/h);
    }
    irhs++;

    /* tag the source node */
    rhs = 0;
    for (int i=0; i<FDmeshThi.nv; i++)
    if ((FDmeshThi(i).x-xs)^2+(FDmeshThi(i).y-ys)^2+(FDmeshThi(i).z-zs)^2 < 1e-3*h)
      rhs[][i] = -1./h^2;

    brhs(i*FDspaceVhi.ndof:(i+1)*FDspaceVhi.ndof-1) = rhs[];
  }

  complex[int] bu(FDspaceVhi.ndof*mu); // local solutions
  bu = 0; // 0 initial guess

  /* solve the linear systems */
  bu = FDfGMRES(bu, brhs, gmrestol, maxit, "right");

  u[] = bu(0:FDspaceVhi.ndof-1); // save the first solution for export
  u = u*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2); // scale with distance to source for visualization
}

FDwritesummary

/* export a solution to parallel vtu format */
if (FDmeshisincomm) {
  load "PETSc-complex"
  func pml = (x>=lengthx)+(x<=0)+(y>=lengthy)+(y<=0)+(z>=0)+(z<=-depth);
  //FDmeshThi = trunc(FDmeshThi,pml==0); // remove PML region
  FDspaceVhi ur = (!pml)*real(u), ui = (!pml)*imag(u);
  int[int] fforder = [1,1];
  savevtk("GO_3D_OBS_FD.vtu", FDmeshThi, ur, ui, dataname = "u ui", order=fforder, communicator=FDmeshcommddm);
  if (mpirank == 0) cout << "Solution saved: " << "GO_3D_OBS_FD_"+mpiSize(FDmeshcommddm)+".pvd" << endl;
}
ENDIFMACRO

/***********************************************************************/
/**************************  FINITE ELEMENTS  **************************/
/***********************************************************************/
IFMACRO(FEsimulation)
{
ffddmoverlap = 1;

real nloc = nppwl/ffddmsplit*lengthx/lambda/split;

int nplx = rint(nloc*(lengthx+lengthpml[0]+lengthpml[1])/lengthx);
int nply = rint(nloc*(lengthy+lengthpml[2]+lengthpml[3])/lengthx);
int npd = rint(nloc*(depth+lengthpml[4]+lengthpml[5])/lengthx);

int[int] N=[nplx,nply,npd];
real [int,int] B=[[-lengthpml[0],lengthx+lengthpml[1]],[-lengthpml[2],lengthy+lengthpml[3]],[-depth-lengthpml[4],lengthpml[5]]];
int [int,int] L=[[11,12],[13,14],[15,16]];

mesh3 Th = Cube(N,B,L);

/* mesh adaptation */
for (int i=0; i<3; i++) {
  fespace Uh(Th,P1);
  Uh met = (1./freq)*real(c)/nppwl*split;
  Th = parmmg3d(Th,metric=met[],hgrad=3,verbose=1,mem=16000);
}

ffddmbuildDmeshNested(FEmesh,Th,split,mpiCommWorld)

/* clear memory */
Th = cube(1,1,1);

func k = omega/c;

real epst = 1e-10;
func sigmax = ((x>=lengthx)/max(epst,(lengthx+lengthpml[1]-x))  +  (x<=0)/max(epst,(x + lengthpml[0])))/real(k);
func sigmay = ((y>=lengthy)/max(epst,(lengthy+lengthpml[3]-y))  +  (y<=0)/max(epst,(y + lengthpml[2])))/real(k);
func sigmaz = ((z>=0)/max(epst,(lengthpml[5]-z))  +  (z<=-depth)/max(epst,(z+depth + lengthpml[4])))/real(k);

macro Grad(u) [dx(u),dy(u),dz(u)] //EOM
macro Gradpml(u) [(1.-1i*sigmay)*(1.-1i*sigmaz)/(1.-1i*sigmax)*dx(u),
                  (1.-1i*sigmax)*(1.-1i*sigmaz)/(1.-1i*sigmay)*dy(u),
                  (1.-1i*sigmax)*(1.-1i*sigmay)/(1.-1i*sigmaz)*dz(u)] //EOM

macro Varf(varfName, meshName, PhName)
  varf varfName(u,v) = int3d(meshName,qfV=mqfV)(-(k^2*(1+1i*sigmax)*(1+1i*sigmay)*(1+1i*sigmaz))*u*v+Gradpml(u)'*Grad(v))
                     + on(11,12,13,14,15,16,u=0);
//EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
  varf varfName(u,v) = int3d(meshName,qfV=mqfV)(-(k^2*(1+1i*sigmax)*(1+1i*sigmay)*(1+1i*sigmaz))*u*v+Gradpml(u)'*Grad(v))
                     - int2d(meshName,10)(1i*k*(1+1i*sigmax)*(1+1i*sigmay)*(1+1i*sigmaz)*u*v)
                     + on(11,12,13,14,15,16,u=0);
//EOM

macro Varfrhs(varfName, meshName, PhName)
  func source = exp(-0.5/(h/8)^2*((x-xs)^2+(y-ys)^2+(z-zs)^2)) / pow(2*pi*(h/8)^2,3./2.);
  varf varfName(u,v) = int3d(meshName,qfV=mqfV)(source*v)
                     + on(11,12,13,14,15,16,u=0);
//EOM

ffddmbuildDfespace(FEs,FEmesh,complex,def,init,PkFE)
ffddmbuildDfespace(FEsCoarse,FEmeshCoarse,complex,def,init,PkFE)

vsym = 2; // matrices are symmetric, not hermitian
vtgv = vtgvelim = -2;

ffddmprecond = "oras";

macro FEwithhpddm()1//
macro FECoarsewithhpddm()1//

ffddmsetupOperator(FECoarse,FEsCoarse,Varf)

ffddmsetupOperator(FE,FEs,Varf)

ffddmset(FE,verbosity,3)
ffddmset(FECoarse,verbosity,1)

ffddmsetupPrecond(FECoarse,VarfOpt)

ffddmsetupPrecond(FE,VarfOpt)

ffddmcoarsemeshsetup(FE,Th,Varf,null)

// set BLR parameters for local solver MUMPS
set(FECoarsehpddmOP,sparams="-hpddm_FECoarse_mumps_icntl_35 2 -hpddm_FECoarse_mumps_cntl_7 1e-3 -hpddm_FECoarse_mumps_icntl_37 0 -hpddm_FECoarse_mumps_icntl_36 1");
set(FEhpddmOP,sparams="-hpddm_FE_mumps_icntl_35 2 -hpddm_FE_mumps_cntl_7 1e-3 -hpddm_FE_mumps_icntl_37 0 -hpddm_FE_mumps_icntl_36 1");

// use GMRES with Classical Gram-Schmidt orthogonalization
set(FECoarsehpddmOP,sparams="-hpddm_FECoarse_reuse_preconditioner 1 -hpddm_FECoarse_orthogonalization cgs -hpddm_FECoarse_krylov_method gmres");
set(FEhpddmOP,sparams="-hpddm_FE_reuse_preconditioner 1 -hpddm_FE_orthogonalization cgs -hpddm_FE_krylov_method gmres");

int irhs = 0;

FEsVhi<complex> u, rhs;

ifstream f("Helmholtz_geophysics_rhs_pos.txt");
while (irhs < maxrhs) {
  int mu = min(murhs, maxrhs-irhs); // number of treated RHSs for this block

  complex[int] brhs(FEsVhi.ndof*mu); // local RHSs

  /* assemble the mu RHSs */
  for (int i = 0; i < mu; i++) {
    if (murhs > 1) { // read RHS position in the file
      f >> zs; zs /= -1000; zs = h*rint(zs/h); // closest FD grid point to source position
      f >> xs; xs /= 1000; xs = h*rint(xs/h);
      f >> ys; ys /= 1000; ys = h*rint(ys/h);
    }
    irhs++;

    ffddmbuildrhs(FE,Varfrhs,rhs[])
    brhs(i*FEsVhi.ndof:(i+1)*FEsVhi.ndof-1) = rhs[];
  }

  complex[int] bu(FEsVhi.ndof*mu); // local solutions
  bu = 0; // 0 initial guess

  /* solve the linear systems */
  bu = FEfGMRES(bu, brhs, gmrestol, maxitFE, "right");

  u[] = bu(0:FEsVhi.ndof-1); // save the first solution for export
  u = u*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2); // scale with distance to source for visualization
}

FECoarsewritesummary
FEwritesummary

/* export a solution to parallel vtu format */
load "PETSc-complex"
func pml = (x>=lengthx)+(x<=0)+(y>=lengthy)+(y<=0)+(z>=0)+(z<=-depth);
//FEmeshThi = trunc(FEmeshThi,pml==0); // remove PML region
FEmeshThi = trunc(FEmeshThi,1,split=2);
FEsVhi ur = (!pml)*real(u), ui = (!pml)*imag(u);
int[int] fforder = [1,1];
savevtk("GO_3D_OBS_FE.vtu", FEmeshThi, ur, ui, dataname = "u ui", order=fforder);
if (mpirank == 0) cout << "Solution saved: " << "GO_3D_OBS_FE_"+mpisize+".pvd" << endl;
}
ENDIFMACRO
//ff-mpirun -np 8 diffusion-2d-thirdlevelgeneo.edp -wg -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 50 -ffddm_partitioner 0 -nsuper 4 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

// for the make check:
// NBPROC 4
// PARAM -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 40 -ffddm_partitioner 0 -nsuper 2 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM     // vector field definition
macro init(i)i// EOM        // vector field initialization
macro grad(u) [dx(u),dy(u)] // EOM
func Pk = P1;             // finite element space

int global = getARGV("-global", 8);

mesh ThGlobal = square(global,global);

macro Varf(varfName, meshName, PhName)

varf varfName(def(u), def(v)) = int2d(meshName)(grad(u)' * grad(v))
+ int2d(meshName)(v)
+ on(1, u = 0.0);
// EOM

vsym = 1;
vtgv = 1e+30;
vtgvelim = vtgv;

int nsuper = getARGV("-nsuper",2);

ffddmbuildSuper(Lap,ThGlobal,nsuper,real,def,init,Pk)

real[int] rhs(1);
real[int] x0(LapVhi.ndof);
x0 = 0;
LapVhi def(u), def(err);
macro Lapdefmplot(u)u//

LapbinexactgeneoCS = 0;

ffddmsetupsuperinit(Lap,Lap)

ffddmsetup(Lap,Lap,Varf,null)

ffddmbuildrhs(Lap,Varf,rhs)

if (mpirank == 0) cout << "RAS :" << endl; 

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary
  
if (mpirank == 0) cout << endl << "RAS + GENEO EXACT :" << endl;   
  
ffddmgeneosetup(Lap,Varf)

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(RAS) :" << endl;

LapbinexactgeneoCS = 1;

ffddmgeneosetup(Lap,Varf)

ffddmset(Lapsuper,verbosity,1)

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(GENEO) :" << endl; 

ffddmnu = getARGV("-ffddm_geneo_super_nu",5);

ffddmgeneosetupsuper(Lap)

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary

err[] = LapA(u[]);
err[] -= rhs;

ffddmplot(Lap,u, "Global solution");
ffddmplot(Lap,err, "Global residual");

// SAVE TO FILES
/*
{
LapVhi def(isshared);

isshared[] = 0;
for (int i=0;i<LaparrayIntersection.n;i++){
      real[int] tvec(LaprestrictionIntersection[i].n);
      tvec = 1;
      real[int] tres = LaprestrictionIntersection[i]'*tvec;
      isshared[] += tres;
}

{ofstream f("isshared_"+mpirank+".dat");
 f << isshared[];
}

matrix R = interpolate(LapVhi,LapVhglob);

int[int] I(1), J(1);
real[int] K(1);
[I,J,K] = R;

if (K[K.n-1] == 0) {
  I.resize(K.n-1);
  J.resize(K.n-1);
  K.resize(K.n-1);
}

ofstream parU("ParU_"+mpirank+".dat");
parU << LapDk[mpirank];

ofstream ff("renum_"+mpirank+".dat");
ff << J;

ofstream f("neumann_"+mpirank+".mat");
f << LapmatN;

ffddmnpart = 1;
ffddmbuildDmesh(Lap0,ThGlobal,Lapcommself)

if (mpirank == 0) {

  ffddmbuildDfespace(Lap0,Lap0,real,def,init,P1)
  ffddmsetupOperator(Lap0,Lap0,Varf)
  
  real[int] rhs(1);

  ffddmbuildrhs(Lap0,Varf,rhs)

  ofstream rhsj("rhs.dat");
  rhsj << rhs;
  cout << rhs.l2 << endl;

  ofstream fj("AGlobal.mat");
  fj << Lap0aRd[0];
}

}
*/
//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling.edp -ffddm_partitioner 0 -ffddm_gmres_restart 1000 -wg

// for the make check:
// NBPROC 4
// PARAM -ffddm_partitioner 0 -ffddm_gmres_restart 1000

/* example of wave guiding with gradient-index lenses */

include "ffddm.idp"
load "bem"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int[int] nsl(10); // number of lenses
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

mesh Thwaveguide = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l));

mesh Thlenses = buildmesh(circle(nsl));
// we do not want any region with label 0 for the lenses, as 0 is the waveguide region in Thwaveguide :
Thlenses = change(Thlenses,fregion=region+1);

mesh Th = Thwaveguide + Thlenses; // FEM mesh

meshL ThL = extract(Th);
ThL = trunc(ThL,region==interface);
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL);

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);

func ind = region == -1 ? 1 : 2./(1+((x-nsx[region-1])^2+(y-nsy[region-1])^2)); // gradient index in lenses

// DD mesh partitioning
fespace FPh(Th,P0);
FPh fpart;
if (mpirank == 0) {
  int[int] lpart(FPh.ndof);
  if (mpisize > 1)
    scotch(lpart,Th,mpisize);
  else
    lpart = 0;
  for(int i=0;i<lpart.n;++i)
    fpart[][i]=lpart[i];
}
broadcast(processor(0), fpart[]);

macro Fsimple(PhGlobal, part, comm) part[] = fpart[]; // EOM

macro Bsimple(PhGlobal, part, comm) part = fpart; // EOM

macro Fdim 2//
ffddmbuildDmesh(F, Th, mpiCommWorld)

macro Bdim 3L//
ffddmbuildDmesh(B, ThL, mpiCommWorld)

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
ffddmbuildDfespace(F, F, complex, def, init, P1)

ffddmbuildDfespace(B, B, complex, def, init, P1)

macro VarfSL(varfName, meshName, PhName)
  varf varfName(u,v) = int1dx1d(meshName)(meshName)(BEM(BemKernel("SL",k=k),u,v));
//

macro VarfTDL(varfName, meshName, PhName)
varf varfName(u,v) = int1dx1d(meshName)(meshName)(BEM(BemKernel("TDL",k=k),u,v)) + int1d(meshName)(0.5*u*v);  

// assemble BEM blocks :
ffddmprecond = "ras";
ffddmsetupOperatorBem(B, B, VarfSL)

ffddmsetupPrecond(B, VarfSL)

ffddmsetupOperatorBem(TDL, B, VarfTDL)

if (mpirank == 0)
  cout << BAglobal.infos << endl;
display(BAglobal);

BVhi<complex> ubi, bbi;

bbi[] = 0;

macro Grad(u) [dx(u),dy(u)] // EOM

macro VarfF(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-ind*k^2*u*v+Grad(u)'*Grad(v))
  + on(waveguide,u=0); // EOM

// for the preconditioner
macro VarfFOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-ind*k^2*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,10)(1i*k*u*v)
        + on(waveguide,u=0); // EOM

macro VarfFrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                int2d(meshName)(finc*v)
                + on(waveguide,u=0); // EOM

macro VarfFmass(varfName, meshName, PhName)
    varf varfName(u,v) =
  int1d(meshName,interface)(u*v); // EOM

// assemble FEM blocks :
ffddmprecond = "oras";
ffddmsetup(F, F, VarfF, VarfFOpt)

ffddmsetupOperator(Fmass, F, VarfFmass)

FVhi<complex> ufi, bfi;

ffddmbuildrhs(F, VarfFrhs, bfi[])

int Cn = FVhi.ndof + BVhi.ndof;

// rhs for the coupled problem :
complex[int] bC = [bfi[], bbi[]];

// restriction matrix from local fem space to local bem space :
matrix<complex> RFtoB;
{
  matrix tmp = interpolate(BVhi,FVhi);
  RFtoB = tmp;
}

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (bfi)
(  mass  -SL ) (ubem)   ( 0 ) */

// define custom operators for the coupled problem :
macro Cmyscalprod
func complex Cscalprod(complex[int] va, complex[int] vb)
{
  complex resf = Fscalprod(va(0:FVhi.ndof-1),vb(0:FVhi.ndof-1));
  complex resb = Bscalprod(va(FVhi.ndof:Cn-1),vb(FVhi.ndof:Cn-1));
  return resf+resb;
}
//

ffddminitDfespacef(C, B, complex, def, init, P1, def, init, P1)

macro CmyA
func complex[int] CA(complex[int] &u) 
{
  complex[int] res(u.n);
  res(0:FVhi.ndof-1) = FA(u(0:FVhi.ndof-1));
  res(FVhi.ndof:Cn-1) = (-1)*BA(u(FVhi.ndof:Cn-1));
  
  complex[int] uFm = FmassA(u(0:FVhi.ndof-1));
  complex[int] tmp = RFtoB*uFm;
  Bupdate(tmp,true);
  res(FVhi.ndof:Cn-1) += tmp;
  
  complex[int] utdl = TDLA(u(FVhi.ndof:Cn-1));
  complex[int] tmp2 = RFtoB'*utdl;
  Fupdate(tmp2,true);
  res(0:FVhi.ndof-1) += tmp2;

  return res;
}
//

// block diagonal preconditioner :
macro CmyPREC1
func complex[int] CPREC1(complex[int] &u) 
{
  complex[int] res(u.n);
  res(0:FVhi.ndof-1) = FPREC1(u(0:FVhi.ndof-1));
  res(FVhi.ndof:Cn-1) = (-1)*BPREC1(u(FVhi.ndof:Cn-1));
  return res;
}
//

macro Cwithhpddmkrylov()1//

ffddmsetupinit(C,C);

complex[int] uC(Cn);

uC = CfGMRES(uC, bC, 1.e-4, 2000, "right");

Fwritesummary

Bwritesummary

Cwritesummary

ufi[] = uC(0:FVhi.ndof-1); // FEM local solution

ubi[] = uC(FVhi.ndof:Cn-1); // BEM local solution

FVhglob<complex> ufem;
FfromVhi(ufi[],FVhglob,ufem[]) // FEM global solution

ffddmplot(F,real(ufi),"FEM solution");

BVhglob<complex> ubem;

BfromVhi(ubi[], BVhglob, ubem[]) // BEM global solution

// output mesh for visualization
int np = 200/2;
real R = 20;
real rr = 20;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R/rr)+b2(np)+b3(np*R/rr)+b4(np)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));
broadcast(processor(0),ThOut);

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(BVhglob,UhOut);
if (mpirank == 0) cout << B.infos << endl;
//display(B);

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40);
//ff-mpirun -np 4 Helmholtz-2d-simple.edp -wg -raspart -ffddm_schwarz_method oras -waven 30

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -waven 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P1;

real k = getARGV("-waven",20.);
func f = 100*exp(-((x-.5)^2+(y-.5)^2)*k*10);

real lambda = 2*pi/k;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

//int[int] chlab=[1, Robin, 2, Robin, 3, Robin, 4, Robin];
int[int] chlab=[1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];

int mysplit = 3;

real npplo = 15./mysplit;

mesh Thc = square(npplo*1./lambda,npplo*1./lambda);    // global mesh

Thc=change(Thc,refe=chlab);

mesh Th = trunc(Thc,1,split=mysplit);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

macro HFEdefmplot(u)real(u)//

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

//macro Hwithhpddmkrylov()1//

ffddmsetup(H,HFE,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HFEVhi<complex> def(u), def(err);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL (coarse mesh):" << endl;

ffddmcoarsemeshsetup(H,Thc,VarfEprec,VarfEprec)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL (DtN):" << endl;

ffddmdtnsetup(H,Varf,k)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

err[] = HA(u[]);
err[] -= rhs;

ffddmplot(HFE,real(u), "Global solution");
ffddmplot(HFE,abs(err), "Global residual");
// NBPROC 8
// PARAM -raspart -ffddm_schwarz_method oras -frequency 1 -ffddm_overlap 1 -ffddm_inexactCS_tol 0.1

//ff-c++ -auto marmousi2.cpp
//ff-mpirun -np 8 Navier-2d-marmousi2.edp -wg -ns -raspart -ffddm_schwarz_method oras -frequency 1 -ffddm_overlap 1 -ffddm_inexactCS_tol 0.1

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

load "marmousi2"

macro def(i)[i,i#B]// EOM                         // scalar field definition
macro init(i)[i,i]// EOM                        // scalar field initialization
func Pk = [P1,P1];

Marmousi2 marm2vp("/var/tmp/data/marmousi2/model/vp.rsf@");
Marmousi2 marm2vs("/var/tmp/data/marmousi2/model/vs.rsf@");
Marmousi2 marm2density("/var/tmp/data/marmousi2/model/density.rsf@");

real freq = getARGV("-frequency",1.); // Hz
real k = 2.*pi*freq;
real k0 = 2.*pi*freq;
real lambda0 = 0.32319/freq;
real omega = 2*pi*freq;

real Q = 0;

func Cp = marm2vp(x,y);  // km/s
func Cs = marm2vs(x,y);  // km/s
func rho = marm2density(x,y);
func lambda = -2*Cs^2*rho+Cp^2*rho;
func mu = Cs^2*rho;
func Kp = omega/Cp;
func Ks = Kp*Cp/Cs;                                         // wavenumber of P & S-waves

func source = exp(-200*((x-10)^2+(y+0.5)^2));  // source at the top surface

int labextxm = 4;
int labextxM = 2;
int labextym = 1;
int labextyM = 3;
int[int] labsext = [labextxm,labextxM,labextym,labextyM];

int mysplit = 3;

real npplo = 20./mysplit;

int nloc = npplo*17./lambda0;

int nn = ffddmnpart/2;
int mm = ffddmnpart/nn;

int nlocx = nloc/nn*nn;
int nlocy = int(nloc*3./17)/mm*mm;

mesh Thc = square(nlocx,nlocy,[x*17,y*3-3.5]);

mesh Th = trunc(Thc,1,split=mysplit);

real sqrt2 = sqrt(2.);
macro Grad(u) [dx(u),dy(u)]              // EOM
macro epsilon(u,v) [dx(u),dy(v),(dy(u)+dx(v))/sqrt2] // EOM
macro div(u,v) ( dx(u)+dy(v) )                              // EOM
// Sigma macro
macro sxx() rho*omega*(Cp*N.x^2+Cs*N.y^2) //EOM
macro sxy() rho*omega*(Cp-Cs)*N.x*N.y     //EOM
macro syy() rho*omega*(Cp*N.y^2+Cs*N.x^2) //EOM

macro Navier(u,v,uu,vv) rho*(omega^2)*(u*uu+v*vv) -        
            lambda*(div(u,v)*div(uu,vv))-2.*mu*( epsilon(u,v)'*epsilon(uu,vv) ) // EOM

macro NavierEprec(u,v,uu,vv) rho*(omega^2+1.i*omega)*(u*uu+v*vv) -        
            lambda*(div(u,v)*div(uu,vv))-2.*mu*( epsilon(u,v)'*epsilon(uu,vv) ) // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) = int2d(meshName)(Navier(u,v,uu,vv)) 
              + int1d(meshName,labsext)(1i *(sxx*u*uu + sxy*(v*uu+u*vv) +syy*v*vv));
// EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) = int2d(meshName)(NavierEprec(u,v,uu,vv)) 
              + int1d(meshName,labsext)(1i *(sxx*u*uu + sxy*(v*uu+u*vv) +syy*v*vv));
// EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) = int2d(meshName)(NavierEprec(u,v,uu,vv)) 
              + int1d(meshName,labsext,10)(1i *(sxx*u*uu + sxy*(v*uu+u*vv) +syy*v*vv));
// EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) =
                         -intN(meshName)(source*vv);
// EOM

/*
macro Nsimple(PhGlobal, part, comm)
{

 fespace PhGlobal(Thc,P0);
 real allongx = 17;
 real allongy = 3;
 if (mpirank==0 && (nn*mm != ffddmnpart))
   cout << "PB SIMPLE PARTITIONING : nn*mm != npart" << endl;
 assert (nn*mm == ffddmnpart);

 PhGlobal xx=x,yy=y;
 part= int(xx/allongx*nn)*mm + int((-0.5-yy)/allongy*mm);
}
// EOM
*/

ffddmbuildNested(N,Thc,mysplit,complex,def,init,Pk,mpiCommWorld)

//macro NCoarsewithhpddmkrylov()1//
//macro Nwithhpddmkrylov()1//

ffddmsetup(NCoarse,NCoarse,VarfEprec,VarfOpt)

ffddmset(NCoarse,verbosity,1)

ffddmsetup(N,N,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(N,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

NVhi<complex> def(u), def(err);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = NfGMRES(x0, rhs, 1.e-6, 2000, "right");

Nwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(N,Thc,VarfEprec,VarfEprec)

u[] = NfGMRES(x0, rhs, 1.e-6, 300, "right");

Nwritesummary

if (mpirank == 0) cout << "Coarse problem :" << endl;

NCoarsewritesummary

err[] = NA(u[]);
err[] -= rhs;

ffddmplot(N,sqrt(real(u)^2+real(uB)^2), "Global solution");
ffddmplot(N,abs(err), "Global residual");

fespace Vhg(Th,Pk);
Vhg<complex> def(ug);
NfromVhi(u[],Vhg,ug[])

if (mpirank == 0)
medit("ug",Th,sqrt(real(ug)^2+real(ugB)^2));
# What is ffddm ?

In the acronym `ffddm`, `ff` stands for  FreeFEM and `ddm` for domain decomposition methods. The idea behind ffddm is to simplify the use of parallel solvers in FreeFEM: distributed direct methods and domain decomposition methods.  

Parallelism is an important issue because, since about 2004, the clock speed of cores stagnates at 2-3 GHz. The increase in performance is almost entirely due to the increase in the number of cores per processor. All major processor vendors are producing multicore chips and now every machine is a parallel machine. Waiting for the next generation machine does not guarantee anymore a better performance of a software. To keep doubling performance parallelism must double. It implies a huge effort in algorithmic development.

Thanks to `ffddm`, FreeFEM users have access to high-level functionalities for specifying and solving their finite element problems in parallel. The first task handled by `ffddm` is the data distribution among the processors. This is done via an overlapping domain decomposition and a related distributed linear algebra. Then, solving a linear system is possible either via an interface to the parallel [MUMPS](http://mumps.enseeiht.fr/) solver or by using domain decomposition methods as preconditioners to the GMRES Krylov method. The `ffddm` framework makes it easy to use scalable Schwarz methods enhanced by a coarse space correction built either from a coarse mesh or a [GenEO](https://link.springer.com/article/10.1007%2Fs00211-013-0576-y#page-1) (Generalized Eigenvalue in the Overlap) coarse space, see also the book [An Introduction to Domain Decomposition Methods: algorithms, theory, and parallel implementation](http://bookstore.siam.org/ot144/). State-of-the-art three level methods are also implemented in `ffddm`.  

The `ffddm` framework is entirely written in the FreeFEM language and the '.idp' scripts can be found [here](https://github.com/FreeFem/FreeFem-sources/blob/develop/idp) ('ffddm*.idp' files). It makes it also a very good tool for learning and prototyping domain decomposition methods without compromising efficiency.

 `ffddm` can also act as a wrapper for the [HPDDM](https://github.com/hpddm/hpddm) library. HPDDM is an efficient implementation of various domain decomposition methods and a variety of Krylov subspace algorithms, with advanced block and recycling methods for solving sequences of linear systems with multiple right-hand sides: GMRES and Block GMRES, CG, Block CG, and Breakdown-Free Block CG, GCRO-DR and Block GCRO-DR. For more details on how to use HPDDM within `ffddm`, see [the ffddm documentation](https://doc.freefem.org/documentation/ffddm/documentation.html#ffddmdocumentationhpddmffddm).

# Getting Started

## Minimal Example

```cpp
macro dimension 2// EOM            // 2D or 3D
include "ffddm.idp"
mesh Th = square(50,50);    // global mesh
// Step 1: Decompose the mesh
ffddmbuildDmesh( P , Th , mpiCommWorld )
// Step 2: Define your finite element
macro def(u)  u // EOM
macro init(u) u // EOM
ffddmbuildDfespace( P , P , real , def , init , P2 )
// Step 3: Define your problem
macro grad(u) [dx(u), dy(u)] // EOM
macro Varf(varfName, meshName, VhName)
    varf varfName(u,v) = int2d(meshName)(grad(u)'* grad(v)) + int2d(meshName)(1*v)
                       + on(1, u = 0);  // EOM
ffddmsetupOperator( P , P , Varf )
PVhi ui, bi;
ffddmbuildrhs( P , Varf , bi[] )
// Step 4: Define the one level DD preconditioner
ffddmsetupPrecond( P , Varf )
// Step 5: Define the two-level GenEO Coarse Space
ffddmgeneosetup( P , Varf )
// Step 6: Solve the linear system with GMRES
PVhi x0i = 0;
ui[] = PfGMRES(x0i[], bi[], 1.e-6, 200, "right");
ffddmplot(P, ui, "u")
Pwritesummary
```

This example solves a Laplace problem in 2D in parallel with a two-level GenEO domain decomposition method. To try this example, just copy and paste the script above in a file 'test.edp' and run it on 2 cores with

```console
$ ff-mpirun -np 2 test.edp -wg
```

## Documentation

You can find the `ffddm` documentation [here](https://doc.freefem.org/documentation/ffddm/index.html).

## Examples

| File name                                                                                                                                       | $M^{-1}_1$ | $M^{-1}_2$  | inexact CS  | comments                                           |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------- | ----------- | ----------- | -------------------------------------------------- |
| [diffusion-3d-minimal-direct.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-minimal-direct.edp)       | &nbsp;     | &nbsp;      | &nbsp;      | direct solver <br> MUMPS                           |
| [diffusion-3d-minimal-ddm.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-minimal-ddm.edp)             | RAS        | GenEO       | &nbsp;      |                                                    |
| [diffusion-3d-simple.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-simple.edp)                       | RAS        | GenEO       | &nbsp;      | comparison with <br> direct solver                 |
| [diffusion-2d-thirdlevelgeneo.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-2d-thirdlevelgeneo.edp)     | RAS        | GenEO       | RAS + GenEO | &nbsp;                                             |
| [elasticity-3d-simple.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity-3d-simple.edp)                     | RAS        | GenEO       | &nbsp;      | &nbsp;                                             |
| [elasticity-3d-thirdlevelgeneo.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity-3d-thirdlevelgeneo.edp)   | RAS        | GenEO       | RAS + GenEO | &nbsp;                                             |
| [Helmholtz-2d-simple.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-simple.edp)                       | ORAS       | Coarse Mesh | &nbsp;      | &nbsp;                                             |
| [Helmholtz-2d-marmousi.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-marmousi.edp)                   | ORAS       | Coarse Mesh | &nbsp;      | &nbsp;                                             |
| [Helmholtz-3d-simple.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-3d-simple.edp)                       | ORAS       | Coarse Mesh | &nbsp;      |                                                    |
| [Helmholtz-3d-overthrust.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-3d-overthrust.edp)               | ORAS       | &nbsp;      | &nbsp;      | &nbsp;                                             |
| [Helmholtz-2d-HPDDM-BGMRES.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-HPDDM-BGMRES.edp)           | ORAS       | &nbsp;      | &nbsp;      | multi-rhs <br> Block GMRES <br> with HPDDM         |
| [Navier-2d-marmousi2.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Navier-2d-marmousi2.edp)                       | ORAS       | Coarse Mesh | &nbsp;      | &nbsp;                                             |
| [Maxwell-3d-simple.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell-3d-simple.edp)                           | ORAS       | Coarse Mesh | &nbsp;      | &nbsp;                                             |
| [Maxwell_Cobracavity.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell_Cobracavity.edp)                       | ORAS       | Coarse Mesh | ORAS        | &nbsp;                                             |
| [natural_convection.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/natural_convection.edp)                         | ORAS       | Coarse Mesh |             | nonlinear                                          |
| [natural_convection_3D_obstacle.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/natural_convection_3D_obstacle.edp) | ORAS       | Coarse Mesh | &nbsp;      | nonlinear                                          |
| [Richards-2d.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Richards-2d.edp)                                       | RAS        | &nbsp;      | &nbsp;      | nonlinear <br> time dependent <br> mesh adaptation |
| [heat-torus-3d-surf.edp](https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/heat-torus-3d-surf.edp)                         | RAS        | GenEO       | &nbsp;      | 3d surface <br> time dependent                     |
//ff-mpirun -np 8 elasticity-3d-thirdlevelgeneo.edp -wg -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 10 -ffddm_partitioner 0 -nsuper 4 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 5 -ffddm_partitioner 0 -nsuper 2 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"


macro def(i)[i, i#B, i#C]// EOM                         // vector field definition
macro init(i)[i, i, i]// EOM                        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1,P1,P1];                               // finite element space

int[int] LL = [2,3, 2,1, 2,2];
mesh3 ThGlobal = cube(6 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [6 * x, y, z], label = LL);

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11;
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
int dirichlet = 1;

macro Varf(varfName, meshName, PhName)
    varf varfName(def(u), def(v)) = int3d(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(meshName)(f * vC) + on(dirichlet, u = 0.0, uB = 0.0, uC = 0.0); // EOM

vtgv = -2;
vtgvelim = -2;
vsym = 1;

int nsuper = getARGV("-nsuper",2);

ffddmbuildSuper(E,ThGlobal,nsuper,real,def,init,Pk)

real[int] rhs(1);
real[int] x0(EVhi.ndof);
x0 = 0;
EVhi def(u), def(err);

//macro Ewithhpddmkrylov()1//

//macro Esuperwithhpddmkrylov()1//

macro Edefmplot(u)u//

EbinexactgeneoCS = 0;

ffddmsetupsuperinit(E,E)

ffddmsetup(E,E,Varf,null)

ffddmbuildrhs(E,Varf,rhs)

if (mpirank == 0) cout << "RAS :" << endl; 

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO EXACT :" << endl; 

ffddmgeneosetup(E,Varf)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(RAS) :" << endl; 

EbinexactgeneoCS = 1;

ffddmgeneosetup(E,Varf)

ffddmset(Esuper,verbosity,1)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(GENEO) :" << endl;

ffddmnu = getARGV("-ffddm_geneo_super_nu",5);

ffddmgeneosetupsuper(E)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

err[] = EA(u[]);
err[] -= rhs;

ffddmplot(E,u, "Global solution");
ffddmplot(E,err, "Global residual");

EVhglob def(uglob);

EfromVhi(u[],EVhglob,uglob[])

real alpha = 20000.0;
EThglob = movemesh3(EThglob, transfo = [x + alpha * uglob, y + alpha * uglobB, z + alpha * uglobC]);
u[] = mpirank;

ffddmplot(E,u, "Deformed mesh");
//ff-mpirun -np 8 Maxwell-3d-simple.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -global 10

load "Element_Mixte3d"

macro dimension 3// EOM

include "ffddm.idp"


macro def(i)[i, i#y, i#z]// EOM             // vector field definition
macro init(i)[i, i, i]// EOM                // vector field initialization
macro defPart(u)u// EOM                     // partition of unity definition
macro initPart(u)u// EOM                    // partition of unity initialization
macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
macro Curlabs(ux, uy, uz)[abs(dy(uz)-dz(uy)), abs(dz(ux)-dx(uz)), abs(dx(uy)-dy(ux))]// EOM
func Pk = Edge03d;
func PkPart = Edge03ds0;

int Dirichlet = 1, Robin = 2;

int ng = getARGV("-global", 30);

int[int] labs = [Robin, Robin, Robin, Robin, Robin, Robin];
//int[int] labs = [Dirichlet, Dirichlet, Dirichlet, Dirichlet, Dirichlet, Dirichlet];

mesh3 Th = cube(ng, ng, ng, [x,y,z], label = labs);
func k = 6 * pi;

func f = exp(-((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)*60);

int mysplit = 3;

mesh3 Thc = cube(ng/mysplit, ng/mysplit, ng/mysplit, [x,y,z], label = labs);

real epsilonprob = 0;//0 k k^2;                  // epsilon of the problem
real be = getARGV("-betaEprec",1.); // beta for epsilonEprec  
real epsilonEprec = 0;//k^be; 

//macro Mdefplot(u)sqrt(real(u)^2+real(u#y)^2+real(u#z)^2)//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuildDmesh(M,Th,mpiCommWorld)
ffddmbuildDfespaceEdge(M,M,complex,def,init,Pk,defPart,initPart,PkPart)

macro Varf(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonprob)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(Dirichlet,Ex=0,Ey=0,Ez=0);    // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(Dirichlet,Ex=0,Ey=0,Ez=0);    // EOM
                
// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)

    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + int2d(meshName,10)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(Dirichlet,Ex=0,Ey=0,Ez=0);    // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
        -int3d(meshName)([vx,vy,vz]'*[0,0,f])
       + on(Dirichlet,Ex=0,Ey=0,Ez=0);  // EOM

ffddmsetup(M,M,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(M,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

MVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(M,Thc,VarfEprec,VarfEprec)

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

ffddmplot(M,sqrt(real(u)^2+real(uy)^2+real(uz)^2), "Global solution");
//ff-mpirun -np 8 Maxwell_Cobracavity.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit -frequency 2e+9

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -frequency 0.8e+9

load "medit"
load "Element_Mixte3d"

macro dimension 3// EOM

include "ffddm.idp"


include "cobrameshcavity.idp"

/* COBRA cavity paper JCP: EM wave scattering problem from the COBRA cavity
We place a first order absorbing boundary condition a few lambdas away from the cavity boundary. 
The volume of the computational domain is much bigger than the interior cavity region itself.  */

// The long dimension is along x (not the same axes)

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",5.e+9);//17.5e+9;
real k = 2*pi*f/c0;
real lambda = c0/f;

// the computational domain is a box around the cavity. Distance between artificial boundaries and the cavity in each direction:
real distx = 0.2*lambda;
real disty = distx;
real distz = distx;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

int labextxm = 11;
int labextxM = 12;
int labextym = 13;
int labextyM = 14;
int labextzm = 15;
int labextzM = 16;

int[int] labsext = [labextxm,labextxM,labextym,labextyM,labextzm,labextzM];

int regint = 4;
int regext = 5;

real epsilonprob = 0;//0 k k^2;                  // epsilon of the problem
real be = getARGV("-betaEprec",1.); // beta for epsilonEprec  
real epsilonEprec = k^be; 

int mysplit = 2;

int nloc = 20./mysplit*sec3/lambda;

mesh3 Thc;

buildcobramesh(Thc);

macro def(u)[u,u#y,u#z]//
macro init(u)[u,u,u]//
macro defpart(u)u//
macro initpart(u)u//

func Pk = Edge03d;
func PkP0 = Edge03ds0;

//  Macros: Curl and cross product by the normal
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro CrossN(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM

// Incident plane wave

// Convention exp(+i w t)
// exp(-ikx)
// -> propagation along +x

real theta = 2.*pi*180./360.; // 180 or 150

// eta is - the direction of propagation
real[int] eta(3), etaort(3);
eta = [cos(theta),0,sin(theta)];  // oblique
//eta = [-1,0,0];  // normal
//etaort = [0,1,0]; // not used
    
// plane wave
// y polarization
func fx = 0;
func fy = exp(1.i*k*(eta(0)*x+eta(1)*y+eta(2)*z));
func fz = 0;

// calculated for the impedance condition with n=(-1,0,0) (= 2*1i*k f in the normal case)
func Gxm1 = 0;
func Gxm2 = (-1i*k*cos(theta) + 1i*k)*fy;
func Gxm3 = 0;

// calculated for the impedance condition with n=(1,0,0) (= 0 in the normal case)
func GxM1 = 0;
func GxM2 = (1i*k*cos(theta) + 1i*k)*fy;
func GxM3 = 0;

// n=(0,-1,0)
func Gym1 = 1i*k*cos(theta)*fy;
func Gym2 = 0;
func Gym3 = 1i*k*sin(theta)*fy;

// n=(0,1,0)
func GyM1 = -1i*k*cos(theta)*fy;
func GyM2 = 0;
func GyM3 = -1i*k*sin(theta)*fy;

// n=(0,0,-1)
func Gzm1 = 0;
func Gzm2 = (-1i*k*sin(theta) + 1i*k)*fy;
func Gzm3 = 0;

// n=(0,0,1)
func GzM1 = 0;
func GzM2 = (1i*k*sin(theta) + 1i*k)*fy;
func GzM3 = 0;

macro Varf(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonprob)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,labsext)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(labmetal,labo,Ex=0,Ey=0,Ez=0);    // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,labsext)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(labmetal,labo,Ex=0,Ey=0,Ez=0);    // EOM
                
// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)

    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,labsext)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + int2d(meshName,10)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(labmetal,labo,Ex=0,Ey=0,Ez=0);    // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
        int2d(meshName,labextxm)([vx,vy,vz]'*[Gxm1,Gxm2,Gxm3])
       +int2d(meshName,labextxM)([vx,vy,vz]'*[GxM1,GxM2,GxM3])
       +int2d(meshName,labextym)([vx,vy,vz]'*[Gym1,Gym2,Gym3])
       +int2d(meshName,labextyM)([vx,vy,vz]'*[GyM1,GyM2,GyM3])
       +int2d(meshName,labextzm)([vx,vy,vz]'*[Gzm1,Gzm2,Gzm3])
       +int2d(meshName,labextzM)([vx,vy,vz]'*[GzM1,GzM2,GzM3])
       + on(labmetal,labo,Ex=0,Ey=0,Ez=0);  // EOM

//macro Mdefplot(u)sqrt(real(u)^2+real(u#y)^2+real(u#z)^2)//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = -2;

ffddmbuildDmeshNested(M,Thc,mysplit,mpiCommWorld)
ffddmbuildDfespaceEdge(M,M,complex,def,init,Pk,defpart,initpart,PkP0)
ffddmbuildDfespaceEdge(MCoarse,MCoarse,complex,def,init,Pk,defpart,initpart,PkP0)

//macro Mwithhpddmkrylov()1//
macro MCoarsewithhpddm()1//

ffddmsetupOperator(MCoarse,MCoarse,VarfEprec)
ffddmsetupPrecond(MCoarse,VarfOpt)

ffddmset(MCoarse,verbosity,1)

ffddmsetupOperator(M,M,Varf)
ffddmsetupPrecond(M,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(M,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

MVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL + INEXACT COARSE SOLVE :" << endl;

ffddmcoarsemeshsetup(M,Thc,VarfEprec,VarfEprec)

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

if (mpirank == 0) cout << "fine problem :" << endl;
Mwritesummary
if (mpirank == 0)cout << endl << "coarse problem :" << endl;
MCoarsewritesummary

ffddmplot(M,sqrt(real(u)^2+real(uy)^2+real(uz)^2), "Global solution");
//ff-c++ geophysics.cpp
//ff-mpirun -np 8 Helmholtz-3d-overthrust.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras 

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "geophysics"

include "cube.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;  

Overthrust Ovt("/Users/pn/3DOverthrustdata.bin");

func vel = Ovt(x,y,z);  // km/s

real freq = getARGV("-frequency",1.); // Hz
real refvel = 2.1791;
func k = 2.*pi*freq/vel;
real k0 = 2.*pi*freq/refvel;
real lambda = (1./freq)*refvel;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

real nppwl = 5./ffddmsplit;

real length = 20;
real depth = 4.65;

int nloc = nppwl*length/lambda;

int[int] N=[nloc,nloc,nloc*depth/length];
real[int,int] B=[[0,length],[0,length],[-depth,0]];
int[int] L=[Robin,Robin,Robin,Robin,Robin,Dirichlet];
mesh3 Th = cube(nloc,nloc,nloc*depth/length, [x*length, y*length, z*depth-depth], label = L);      // global mesh

real xs = length/8.;
real ys = length/8.;
real zs = -depth/8.;

// 2000
func source = 1000*exp(-200*((x-xs)^2+(y-ys)^2+(z-zs)^2));  // source at the top surface

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                int3d(meshName)(source*v)
                + on(Dirichlet,u=0); // EOM

macro Hdefplot(u)real(u)//

macro Hwithhpddm()1//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuild(H,Th,complex,def,init,Pk,mpiCommWorld)

ffddmsetup(H,H,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

ffddmplot(H,real(u), "Global solution");

//ff-mpirun -np 4 Helmholtz_Cobracavity_BEM.edp -wg

// for the make check:
// NBPROC 4
// PARAM -frequency 1e+9

load "bem"

include "getARGV.idp"

include "cobrameshcavity.idp"

macro dimension 3S//

include "ffddm.idp"

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",3.e+9);
complex k = 2*pi*f/c0;
real lambda = c0/f;

real distx = 0.2*lambda;
real disty = distx;
real distz = distx;

int labextxm = 11, labextxM = 12, labextym = 13, labextyM = 14, labextzm = 15, labextzM = 16;
int regint = 4, regext = 5;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

// incident wave
real[int] dir=[1,0,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));

int nloc = 10.*sec3/lambda;

mesh3 Th3;
buildcobramesh(Th3);
Th3 = buildBdMesh(Th3);

meshS ThS = Th3.Gamma;
ThS = trunc(ThS, region==labmetal);

plot(ThS);

ffddmbuildDmesh(H, ThS, mpiCommWorld)

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
ffddmbuildDfespace(H, H, complex, def, init, P1)

macro Varf(varfName, meshName, PhName)
  BemKernel ker("SL",k=k);
  varf varfName(u,v) = int2dx2d(meshName)(meshName)(BEM(ker,u,v));
//

macro Varfrhs(varfName, meshName, PhName)
varf varfName(u,v) =
  -int2d(meshName)(finc*v);
//

ffddmsetupOperatorBem(H, H, Varf)

if (mpirank == 0)
  cout << HAglobal.infos << endl;
display(HAglobal);

ffddmsetupPrecond(H, Varf)

HVhi<complex> ui, bi;

ffddmbuildrhs(H, Varfrhs, bi[])

ui[] = HfGMRES(ui[], bi[], 1.e-6, 200, "right");

Hwritesummary

fespace Uh(ThS,P1);
Uh<complex> u;

HfromVhi(ui[], Uh, u[])

// output visu
distx = 2*lambda;
disty = distx;
distz = distx;

int np = 100;
meshS ThOut = square3(np,np,[(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3+2*distx)*x
                               -distx,
                               (height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))*y
                               +(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,
                               width/2]);

fespace UhOut(ThOut,P1);

BemPotential Pot("SL",k=k);
varf vp(u,v)=int2d(ThS)(POT(Pot,u,v));
HMatrix<complex> B = vp(Uh,UhOut);
if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = real(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);
//ff-mpirun -np 8 natural_convection.edp -raspart -ffddm_schwarz_method oras -wg

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -Ra 1e6 -global 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

searchMethod = 1;

macro def(i)[i, i#B, i#C, i#D]// EOM     // vector field definition
macro init(i)[i, i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro Grad(u1,u2)[dx(u1),dy(u1),dx(u2),dy(u2)]//
macro div(u)(dx(u) + dy(u#B))// EOM
macro UgradU(uw,u)[[uw,uw#B]'*grad(u),[uw,uw#B]'*grad(u#B)]//
func Pk = [P2, P2, P1, P1];             // finite element space 

real Ra=getARGV("-Ra", 1.e7);
real Pr=0.71;
real Rey=sqrt(Ra/Pr);
real IRe=1./Rey, IRa=Ra/(Rey*Rey*Pr), IPr=1./(Rey*Pr) ;

real Thot=0.5, Tcold=-0.5;

real eps = 1e-7; // penalization in Navier-Stokes

int newtonMax = 10; 

real coef;

int np = getARGV("-global", 40);

int mysplit = 4;

mesh Thc = square(np/mysplit, np/mysplit, [x, y]);
mesh ThGlobal = trunc(Thc,1,split=mysplit);

//macro NCFEdefplot(u)u#D//

ffddmbuildDmeshAug(NCmesh,ThGlobal,mpiCommWorld)
ffddmbuildDfespaceAug(NCFE,NCmesh,real,def,init,Pk)

//ffddmbuildAug(NC,ThGlobal,real,def,init,Pk,mpiCommWorld)

vtgv = -1;
vtgvelim = -1;
vsym = 0;

macro NCwithhpddmkrylov()1//

ffddmsetupinit(NC,NCFE)

if (NCmeshpCS > 1) {
	int[int] nupart(Thc.nt);
	nupart=0;
	if (mpirank == 0)
		scotch(nupart, Thc, NCmeshpCS);
	if (mpirank < NCmeshpCS) {
		broadcast(processor(0,NCmeshcommCS),nupart);
		Thc=change(Thc,fregion=nupart[nuTriangle]);
	}
}

ffddmcoarsemeshsetupinit(NC,Thc)

NCVhCoarse [uG,uGB,pG,TG];

ffddmset(NC,verbosity,1)

NCFEVhi [ui,uiB,pi,Ti], [upi,upiB,ppi,Tpi];

real[int] rhs;

macro Varf(varfName, meshName, VhName)
	VhName [uG,uGB,pG,TG];
	NCfromVhi(ui[],VhName,uG[])
	
    varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(uG,uw)'*[v,vB]
         + UgradU(uw,uG)'*[v,vB]
         + ( Grad(uw,uwB)'*Grad(v,vB))*IRe
         - coef*IRa*Tw*vB
         -[uG,uGB]'*grad(W)*Tw
         -[uw,uwB]'*grad(W)*TG
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4, uw=0,uwB=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM

macro VarfCS(varfName, meshName, VhName)
    varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName,mpirank)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(uG,uw)'*[v,vB]
         + UgradU(uw,uG)'*[v,vB]
         + ( Grad(uw,uwB)'*Grad(v,vB))*IRe
         - coef*IRa*Tw*vB
         -[uG,uGB]'*grad(W)*Tw
         -[uw,uwB]'*grad(W)*TG
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4, uw=0,uwB=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM

macro VarfOpt(varfName, meshName, VhName)
    varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(ui,uw)'*[v,vB]
         + UgradU(uw,ui)'*[v,vB]
         + ( Grad(uw,uwB)'*Grad(v,vB))*IRe
         - coef*IRa*Tw*vB
         -[ui,uiB]'*grad(W)*Tw
         -[uw,uwB]'*grad(W)*Ti
         + grad(Tw)'*grad(W)*IPr)
    + int1d(meshName,10)(20./hTriangle*IRe*[uw,uwB]'*[v,vB]+20*1./hTriangle*[pw, Tw]'*[q, W])
    + on(1,2,3,4, uw=0,uwB=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM
   
macro Varfrhs(varfName, meshName, VhName)
	varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName)(
         UgradU(ui,ui)'*[v,vB]       
         - [ui,uiB]'*grad(W)*Ti       
     )
     + on(1,2,3,4, uw=0,uwB=0)
     + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM

int nstep= max((int(log10(Ra)-4)^2), 3)*max(log10(Ra)-7.,1.);
real tol = 1e-6;

[ui,uiB,pi,Ti]=[0,0,0,Thot+x*(Tcold-Thot)];
nstep *=2;

int iter=0;

for(int step=1; step <= nstep; ++step)
{
   iter++;

    real err=1e100;
    real errp = err;
    coef = (step/real(nstep))^3; // continuation sur le coef en temperature ...
    if (mpirank == 0)
      cout<< "---------------  continuation coef*Ra=" << coef*Ra << endl;
    real tolk= coef<1 ? 1e-2 : tol;

   // Iteration de Newton ---------------------------
   for(int niter=0 ; niter < newtonMax ; niter++){
   	
	 NCfromVhi(ui[],NCVhCoarse,uG[])

	 ffddmsetup(NC,NCFE,Varf,VarfOpt)
	 
	 vtgv = 1.e+30/NCmeshpCS;	 
	 ffddmcoarsemeshsetup(NC,Thc,VarfCS,null) 
	 vtgv = -1;
	 
     ffddmbuildrhs(NC,Varfrhs,rhs)

     ui[] = NCfGMRES(ui[], rhs, 1.e-6, 200, "left");
     
     upi[] -= ui[];
     real reduce = upi[].linfty;
     upi[]  = ui[];
     mpiAllReduce(reduce, err, mpiCommWorld, mpiMAX);

     if(mpirank == 0)
	   cout << "niter = " << niter << " err =  " << err << endl;

     if(err > errp*100) break;
     if(err < tolk) break;
   }
   
   ffddmplot(NCFE,Ti, "Global solution");

}

NCwritesummary
//ff-mpirun  -np  4 diffusion-3d-minimal-ddm.edp -wg -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// Abstract :  "Lap: RAS + GENEO :" << endl; //second level method with a GenEO coarse space

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

macro dimension 3// EOM            // 2D or 3D


include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

int[int] LL = [2,2, 1,2, 2,2];
mesh3 ThGlobal = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10),
    [x, y, z], label = LL);      // global mesh

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int3d(meshName)(grad(u)' * grad(v)) + int3d(meshName)(v) + on(1, u = 1.0); // EOM
       
// Domain decomposition
ffddmbuildDmesh( Lap , ThGlobal , mpiCommWorld )
ffddmbuildDfespace( Lap , Lap , real , def , init , P1 )
ffddmsetupOperator(Lap ,Lap , Varf)

// Domain decomposition solve
real[int] rhs(LapVhi.ndof);//rhs(1) works as well 
ffddmbuildrhs(Lap , Varf , rhs )
LapVhi def(u) ;

// Two-level Schwarz solve
ffddmsetupPrecond(Lap,Varf)
ffddmgeneosetup(Lap,Varf)

real[int] x0(LapVhi.ndof);
x0 = 0;
u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,u, "Lap Global solution with fGMRES");
 //ff-mpirun -np 4 Helmholtz-3d-simple.edp -wg -raspart -ffddm_schwarz_method oras  -ffddm_medit

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -waven 6

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"


macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;  

real k = getARGV("-waven",10.);
func f = exp(-((x-.5)^2+(y-.5)^2+(z-.5)^2)*k*10);

real lambda = 2*pi/k;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

int mysplit = 3;

real npplo = 10./mysplit;

//int[int] LL = [Dirichlet,Dirichlet, Dirichlet,Dirichlet, Dirichlet,Dirichlet];
int[int] LL = [Robin,Robin, Robin,Robin, Robin,Robin];

mesh3 Thc = cube(npplo*1./lambda,npplo*1./lambda,npplo*1./lambda, [x, y, z], label = LL);

mesh3 Th = trunc(Thc,1,split=mysplit);

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int3d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

macro Hdefmplot(u)real(u)//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuild(H,Th,complex,def,init,Pk,mpiCommWorld)

ffddmsetup(H,H,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout <<  endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(H,Thc,VarfEprec,VarfEprec)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

ffddmplot(H,real(u), "Global solution");
//ff-mpirun -np 4 Helmholtz_circle_BEM.edp -wg

// for the make check:
// NBPROC 4
// PARAM

load "bem"

include "getARGV.idp"

include "cobrameshcavity.idp"

macro dimension 3L//

include "ffddm.idp"
load "bem"

complex k = 10;

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

//  Mesh
int n = 1000;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

ffddmbuildDmesh(H, Th, mpiCommWorld)

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
ffddmbuildDfespace(H, H, complex, def, init, P1)

macro Varf(varfName, meshName, PhName)
  varf varfName(u,v) = int1dx1d(meshName)(meshName)(BEM(BemKernel("SL",k=k),u,v));
//

macro Varfrhs(varfName, meshName, PhName)
varf varfName(u,v) =
  -int1d(meshName)(finc*v);
//

ffddmsetupOperatorBem(H, H, Varf)

if (mpirank == 0)
  cout << HAglobal.infos << endl;
display(HAglobal);

ffddmsetupPrecond(H, Varf)

HVhi<complex> ui, bi;

ffddmbuildrhs(H, Varfrhs, bi[])

ui[] = HfGMRES(ui[], bi[], 1.e-6, 200, "right");

Hwritesummary

fespace Uh(Th,P1);
Uh<complex> u;

HfromVhi(ui[], Uh, u[])

// Mesh output
int np = 200;
int R = 4;

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

fespace UhOut(ThOut,P1);

//BemPotential Pot("SL",k=k);
varf vp(u,v)=int1d(Th)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(Uh,UhOut);
if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = abs(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);

//ff-mpirun -np 4 Helmholtz-2d-HPDDM-BGMRES.edp -wg -raspart -ffddm_schwarz_method oras -waven 30

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -waven 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;

real xf = 0.5;
real yf = 0.5;

real k = getARGV("-waven",40.);
func f = 100*exp(-((x-xf)^2+(y-yf)^2)*k*10);

real lambda = 2*pi/k;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

//int[int] chlab=[1, Robin, 2, Robin, 3, Robin, 4, Robin];
int[int] chlab=[1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];

real npplo = 15;

mesh Th = square(npplo*1./lambda,npplo*1./lambda);    // global mesh

Th=change(Th,refe=chlab);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)
ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

macro Hwithhpddm()1//

ffddmsetup(H,HFE,Varf,VarfOpt)

int nbrhs = 10;

complex[int] brhs(nbrhs*HFEVhi.ndof);
complex[int] bu(nbrhs*HFEVhi.ndof);

complex[int] rhs(0);
for (int i=0; i<nbrhs; i++) {
      xf = 0.4+i*0.4/nbrhs;
      ffddmbuildrhs(H,Varfrhs,rhs)
      brhs(i*HFEVhi.ndof:(i+1)*HFEVhi.ndof-1) = rhs;
}

complex[int] x0(brhs.n);
x0 = 0;

if (mpirank == 0) cout << "Pseudo-Block GMRES :" << endl;

bu = HfGMRES(x0, brhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "Block GMRES :" << endl;

set(HhpddmOP,sparams="-hpddm_H_krylov_method bgmres");

bu = HfGMRES(x0, brhs, 1.e-6, 200, "right");

Hwritesummary

HFEVhi<complex> def(u);
u[] = bu(0:HFEVhi.ndof-1); 

ffddmplot(HFE,real(u), "u[0]");
//ff-c++ -auto geophysics.cpp
//ff-mpirun -np 4 Helmholtz-2d-marmousi.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras 

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

load "geophysics"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;  

Marmousi marm("marmousi.bin");

func vel = marm(x,y);  // km/s

real freq = 5; // Hz
func k = 2.*pi*freq/vel;

func f = exp(-2000*((x-6)^2+y^2));  // source at the top surface

real lambda = 1.5/freq;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

int[int] chlab=[1, Robin, 2, Robin, 3, Dirichlet, 4, Robin];

int mysplit = 3;

real npplo = 10./mysplit;

int nloc = npplo*9.2/lambda;

mesh Thc = square(nloc,nloc*3./9.2,[x*9.2,y*3-3]);

Thc=change(Thc,refe=chlab);

mesh Th = trunc(Thc,1,split=mysplit);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner (if (!bAbsorp) epsilonEprec = epsilonprob;)
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuild(H,Th,complex,def,init,Pk,mpiCommWorld)

//macro Hwithhpddmkrylov()1//

ffddmsetup(H,H,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HVhi<complex> def(u);



if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(H,Thc,VarfEprec,VarfEprec)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

ffddmplot(H,real(u), "Global solution");

/*
complex[int] err(u[].n);
err = HA(u[]);
err -= rhs;

ffddmplot(H,u[], "Global solution");
ffddmplot(H,err, "Global residual");
*/

savemesh(HThi,"visu/marm_" + mpirank + "_" + mpisize + ".mesh");
{
	ofstream f("visu/marm_" + mpirank + "_" + mpisize + ".dat");
	f << u[];
}

int[int] fforder=[1];
load "iovtk"
savevtk("visu/test_" + mpirank + "_" + mpisize + ".vtk", HThi, real(u), dataname = "sol", order = fforder);
exec("/Applications/paraview.app/Contents/bin/pvpython vtk2vtu.py visu/test_" + mpirank + "_" + mpisize);

if(mpirank == 0) {
    ofstream pvd("visu/test.pvd");
    pvd << "<?xml version=\"1.0\"?>\n";
    pvd << "<VTKFile type=\"Collection\" version=\"0.1\"\n";
    pvd << "         byte_order=\"LittleEndian\"\n";
    pvd << "         compressor=\"vtkZLibDataCompressor\">\n";
    pvd << "  <Collection>\n";
    for(int i = 0; i < mpisize; ++i) {
        pvd << "    <DataSet timestep=\"0\" group=\"\" part=\"" << i << "\"\n";
        pvd << "             file=\""; pvd << "test_" << i << "_" << mpisize << ".vtu\"/>\n";
    }   
    pvd << "  </Collection>\n";
    pvd << "</VTKFile>\n";
}
// EOM


//ff-mpirun -np 4 elasticity_saddlepoint.edp -wg -ns -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_threshold_A 0.1 -ffddm_geneo_threshold_S 0.3 -ffddm_geneo_nu 40 -Dmdim=2 -global 10 -nlayers 10

/* 3D heterogenous elasticity problem with nearly incompressible
   material solved with the GenEO saddle point solver from
   Nataf, F., & Tournier, P. H. (2021). A GenEO Domain Decomposition
   method for Saddle Point problems.
   arXiv preprint available at https://arxiv.org/abs/1911.01858 */

// the command line parameter '-Dmdim' sets the value of the macro 'mdim' in the script;
// '-Dmdim=2' or '-Dmdim=3' switches between the 2D and 3D test case

include "getARGV.idp"
int global = getARGV("-global", 10); // discretization parameter
int nlayers = getARGV("-nlayers", global); // number of alternating material layers in the y direction

// material coefficients:
real nu1 = 0.4999;
real nu2 = 0.35;
real E1 = 1e+7;
real E2 = 200e+9;

// heterogeneous material distribution:
func fE = int(y*nlayers)%2 == 0 ?  E1 :  E2;
func fnu = int(y*nlayers)%2 == 0 ? nu1 : nu2;

real gtol = 1e-5;

/********* 2D *********/
IFMACRO(mdim,2)
macro dimension 2// EOM
include "ffddm.idp"

macro grad(u) [dx(u),dy(u)] // EOM
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM

mesh ThGlobal = square(5*global, global, [5*x,y]);

func Pku = [P2,P2];
func Pkp = [P0];

macro VarfA(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));
varf varfName([u, uB], [v, vB]) = int2d(meshName)(2.0 * mu * (epsilon(u)' * epsilon(v)))
                                 +on(4, u = 0, uB = 0)
                                 -int2d(meshName)(100*vB);
 // EOM

macro VarfB(varfName, meshName, PhName)
varf varfName([u, uB], [q]) = int2d(meshName)(div(u) * q);
// EOM

macro VarfC(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));

varf varfName([p], [q]) = int2d(meshName)(1./lambda * p * q);
// EOM

macro defA(i)[i, i#B] // EOM
macro initA(i)[i, i] // EOM

macro defB(i)[i] // EOM
macro initB(i)[i] // EOM
ENDIFMACRO

/********* 3D *********/
IFMACRO(mdim,3)
macro dimension 3// EOM
include "ffddm.idp"

real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM

int[int] LL = [2,3, 2,1, 2,2];
mesh3 ThGlobal = cube(5*global, global, global, [5*x,y,z], label = LL);

func Pku = [P2,P2,P2];
func Pkp = [P1];

macro VarfA(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));
varf varfName([u, uB, uC], [v, vB, vC]) = int3d(meshName)(2.0 * mu * (epsilon(u)' * epsilon(v)))
                                 +on(1, u = 0, uB = 0, uC = 0)
                                 -int3d(meshName)(100*vB);
// EOM

macro VarfB(varfName, meshName, PhName)
varf varfName([u, uB, uC], [q]) = int3d(meshName)(div(u) * q);
// EOM

macro VarfC(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));

varf varfName([p], [q]) = int3d(meshName)(1./lambda * p * q);
// EOM

macro defA(i)[i, i#B, i#C] // EOM
macro initA(i)[i, i, i] // EOM

macro defB(i)[i] // EOM
macro initB(i)[i] // EOM
ENDIFMACRO

/* build mesh decomposition with minimal overlap size 1*2 (prefix M) and also the Augmented decomposition
   with overlap size 2*2 (prefix MAug) */
ffddmbuildDmeshAug(M,ThGlobal,mpiCommWorld)

func Pk = [Pku,Pkp];

/* build Dfespace for A on distributed mesh M (prefix AFE) ; this also builds Dfespace tilde with larger overlap
   on distributed mesh MAug (prefix AFEAug) needed for the rectangular operator B on tilde decomposition.
   This also builds 'AFEAuginterp' matrices (restriction matrices from AFEAugVhi to AFEVhi local FE spaces). */
ffddmbuildDfespace(AFE,M,real,defA,initA,Pku)

ffddmbuildDfespace(CFEAug,MAug,real,defB,initB,Pkp) // Dfespace for C

vsym=1;
vtgvelim=1e+30;
vtgv=1e+30;

ffddmsetupOperator(A,AFE,VarfA); /* Operator A */
ffddmsetupPrecond(A,null); /* one level preconditioner for A */

ffddmtau = getARGV("-ffddm_geneo_threshold_A", 0.3);
ffddmgeneosetup(A,VarfA); /* second level for A */

Acorr == "ADEF1";

ffddmsetupOperatorRect(Btilde,AFEAug,CFEAug,VarfB) /* Operator B on tilde decomposition */

ffddmsetupOperator(Ctilde,CFEAug,VarfC) /* Operator C on tilde decomposition */

matrix Ctildei;
{
  VarfC(vC, MAugThi, null)
  Ctildei = vC(CFEAugVhi,CFEAugVhi,sym=1); /* Ctilde_i from Remark 3.2 */
}

/* define and build all necessary operators for the application of N_S^-1 */
ffddmtau = getARGV("-ffddm_geneo_threshold_S", 0.1);
ffddmSPsetup(SP,A,Btilde,Ctilde,Ctildei)

AFEVhi defA(Fx);
ffddmbuildrhs(A,VarfA,Fx[]) /* Build F_u */

CFEAugVhi [Fp] = [0]; /* Build F_p */

AFEVhi defA(Gx);

Averbosity = 1;
/* Solve A G_u = F_u with M_A^-1 as a preconditioner, step 1 of Algorithm 2 */
Gx[] = AfGMRES(Gx[], Fx[], gtol, 100, "right");

/* Compute G_p = F_p - B G_u, step 2 of Algorithm 2 */
CFEAugVhi [Gp];
Gp[] = Fp[] - SPBmatvec(Gx[]);

/* Step 3 of Algorithm 2: solve (C + B A^-1 B^T) P = -G_p with N_S^-1 as a preconditioner */
Gp[] *= -1;

CFEAugVhi [P];
P[] = 0;
P[] = SPfGMRES(P[], Gp[], gtol, 100, "right");

Awritesummary
SPwritesummary

ffddmplot(CFEAug,P,"P");

// Step 4 of Algorithm 2: compute G_u = F_u - B^T P
Gx[] = Fx[] - SPBTmatvec(P[]);

// Step 5 of Algorithm 2: solve A U = G_u with M_A^-1 as a preconditioner
AFEVhi defA(Ux);
Ux[] = 0;
Ux[] = AfGMRES(Ux[], Gx[], gtol, 100, "right");

ffddmplot(CFEAug,UxB,"Uy");

IFMACRO(BLOCK)
/* Block solve with preconditioner P of eq. (28) */
real[int] rhs(AFEVhi.ndof+CFEAugVhi.ndof);
rhs(0:AFEVhi.ndof-1) = Fx[];
rhs(AFEVhi.ndof:rhs.n-1) = Fp[];

real[int] x0(rhs.n), u(rhs.n);

u = SPBlockfGMRES(x0, rhs, gtol, 100, "right");

SPBlockwritesummary

real[int] Us = Ux[];

Ux[] = u(0:AFEVhi.ndof-1);

ffddmplot(CFEAug,UxB,"UxB block");

Ux[] -= Us;

ffddmplot(CFEAug,UxB,"difference");
ENDIFMACRO
load "SuperLu"
load "MUMPS_seq"
verbosity=3;
//  a example to test the level of optimisation
// --------------------------------------------
int nn=30;
 mesh Th=square(nn,nn);
verbosity=3;
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 int err=0;
 func bool verif()
 {
	real umax  =0.361995;
	if( abs( umax - uh[].max) >0.001) err++;
 }
 int init=0;
 problem laplace0(uh,vh,init=init) =                  //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form
//init=1; 
DefaultSolver="UMFPACK";
DefaultSolverSym="CHOLMOD";
real cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap UMFPACK " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
verif();

uh=0;
DefaultSolver="SUPERLU";
DefaultSolverSym="SUPERLU";
cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap SuperLU " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
verif();
DefaultSolver="MUMPS";
DefaultSolverSym="MUMPS";
cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap MUMPS " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
verif();
assert(err==0); 
include "cube.idp"
load "medit"
int[int, int] LL = [[2,2], [1,1], [1,1]];
real[int, int] BB = [[0,1], [0,1], [0,1]];
int[int] CC = [4, 4, 4];
load "splitmesh4"
mesh3 Th3=Cube(CC, BB, LL);
mesh3 Th4=splitmesh4(Th3);
assert(Th4.nt == Th3.nt * 4);
cout << Th4.nt << " == 4 x " << Th3.nt << endl;
assert(Th4.nbe == Th3.nbe);
cout << Th4.nbe << " == " << Th3.nbe << endl;
plot(Th3, cmm="Th3", wait=1);
plot(Th4, cmm="Th4", wait=1);
fespace Vh(Th4, P1);
Vh xyz = x + y + z;
medit("splitmesh4",Th4,xyz);
load "MetricPk"
load "Element_P3";
load "Element_P4";

int nIter=4;
mesh Th=square(20,20,[x,y]);
//fespace Vh(Th,P1); int kDeg=1;  //degr� des FE utilis�s
//fespace Vh(Th,P2); int kDeg=2;  //degr� des FE utilis�s
fespace Vh(Th,P3); int kDeg=3;  //degr� des FE utilis�s
int rdeg=1;	 //on approche le gradient ou des d�riv�es d'ordre sup�rieur

real ratio = 2.;//number of triangles is multiplied by ratio at each step
real rmax = 1; 	//max triangle size desired.

Vh u,v;
fespace Metric(Th,[P1,P1,P1]);
Metric [m11,m12,m22];
////pour de l'adaptation isotrope
//problem EpsDelta(u,v) =
//		int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+
//		on(1,u=1)+on(2,3,4, u=0);
//avec une forte anisotropie, et des singularit�s aux coins.
real eps=0.01;
problem EpsDelta(u,v) =
		int2d(Th)(eps*dx(u)*dx(v)+eps*dy(u)*dy(v)+(dx(u)+dy(u))*v)+
		on(1,u=atan(10*x*(1-x)))+on(2,3,4, u=0);

//real massRef = 1000*Th.nt;
real massRef = Th.nt/2;
EpsDelta;
plot(u, wait=1);
for(int i=0; i<nIter; i++){
	plot(Th, wait=1); //on affiche avant de tout changer
	plot(u, wait=1);
	[m11,m12,m22]=[0,0,0];	//absolument crucial...
	m11[]=MetricPk(Th,u,kDeg=kDeg,rDeg=rdeg, mass=massRef);
	Th = adaptmesh(Th,m11,m12,m22,IsMetric=true);
	cout << "expected number of triangles : " << massRef/20 << "; obtained " << Th.nt << "\n";
	EpsDelta;
	massRef=ratio*massRef;
}

plot(Th, wait=1, ps="o/triangulationEpsDelta.ps");
      load "splitedges"
      mesh Th=square(50,50);
      real xx=1.1,yy=1.1;	
      for(int i=0;i<4;++i)
	{     
	  xx *= 0.5;
	  yy *= 0.5;
	  Th=SplitEdgeMesh(Th,x<yy && y < yy );
	  plot(Th,wait=1);
	}
// file tetgencube.edp
// this is  a BUGGUS  file work in progress F. Hecht .... Oct 2011
load "tetgen"
load "medit"

real x0,x1,y0,y1;
x0=1.; x1=2.; y0=0.; y1=2*pi;
mesh Thsq1 = square(5,35,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

int[int] ref31h = [0,12];
int[int] ref31b = [0,11];

meshS Th31h = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1max],region=ref31h,orientation=1);
meshS Th31b = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1min],region=ref31b,orientation=-1);   

//medit("haut",Th31h);
//medit("bas",Th31b);

/////////////////////////////////
x0=1.; x1=2.; y0=0.; y1=1.5;
mesh Thsq2 = square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

int[int] ref32h = [0,13];
int[int] ref32b = [0,14];

meshS Th32h = movemesh23(Thsq2,transfo=[XX2,YY2max,ZZ2],region=ref32h,orientation=-1);  
meshS Th32b = movemesh23(Thsq2,transfo=[XX2,YY2min,ZZ2],region=ref32b,orientation=1);

/////////////////////////////////
x0=0.; x1=2*pi; y0=0.; y1=1.5;
mesh Thsq3 = square(35,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
func XX3min = 1.;
func XX3max = 2.;

func YY3 = x;
func ZZ3 = y;

int[int] ref33h = [0,15];
int[int] ref33b = [0,16];
cout << "tyty\n";
verbosity = 4; 
meshS Th33h = movemesh23(Thsq3,transfo=[XX3max,YY3,ZZ3],region=ref33h,orientation=1);  
cout << "tyty\n";
meshS Th33b = movemesh23(Thsq3,transfo=[XX3min,YY3,ZZ3],region=ref33b,orientation=-1); 

////////////////////////////////
meshS Th33 = Th31h+Th31b+Th32h+Th32b+Th33h+Th33b; // "gluing" surface meshs to obtain the surface of cube
cout << "premier check" << endl;
checkbemesh(Th33,manifolds=[ [[11,1],[12,1],[13,1],[14,1],[15,1],[16,1]] ]);


func mv2x = x;
func mv2y = y;
func mv2z = -1.5+z;
cout << "movemesh ::new mesh" <<endl;
meshS Th33mv = movemesh(Th33, [mv2x,mv2y,mv2z]);
int[int] r1=[12,11,11,21,13,23,14,24,15,25,16,26];
cout << "change ::new mesh" <<endl;
//medit("Th33mv",Th33mv);
if(0) {
Th33mv=change(Th33mv,label=r1);  // bug change if non tet in mesh .... HERE ...
cout << "add ::new mesh" <<endl;
meshS Thall = Th33+Th33mv;  // The vertex of faces of labels 11 of Th33 and Th33mv must be same. The faces of label 11 of Thall correspond to the faces of the first in the sum : Th33.

medit("Thall",Thall);
// check manifold of the two gluing mesh
cout << "check gluing 1" << endl; 
checkbemesh(Thall,manifolds=[ [[11,1],[12,1],[13,1],[14,1],[15,1],[16,1]] ]);
cout << "check gluing 2" << endl; 
checkbemesh(Thall,manifolds=[ [[11,-1],[21,1],[23,1],[24,1],[25,1],[26,1]] ]);   
cout << "check exterior" << endl;
checkbemesh(Thall,manifolds=[ [[12,1],[13,1],[14,1],[15,1],[16,1],[21,1],[23,1],[24,1],[25,1],[26,1]] ]); // check the exterior manifold 
}
load "Morley"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-6;
int it1=Th(x1,y1).nuTriangle; 

func ff =  2*x*x + 3*y*y + 4.5*y*x + 5*x + 6*y + 7;
func ffx = 4*x + 4.5*y + 5;
func ffy = 6*y + 4.5*x + 6;
func ffxx = 4.;
func ffyy = 6.;
func ffxy =4.5;

fespace Vh(Th,P2Morley);
fespace Eh(Th,P0edge);

Eh  edges;

Vh [a1,a2,a3],[b1,b2,b3],[c1,c2,c3];
 
[a1,a2,a3] = [ ff,ffx,ffy];

 cout << a1(0.6,0.2) << " == " << ff(0.6,0.2) << endl;
 cout << a2(0.6,0.2) << " == " << ffx(0.6,0.2) << endl;
  cout << a3(0.6,0.2) << " == " << ffy(0.6,0.2) << endl;
  cout << dxx(a1)(0.6,0.2) << " xx== " << ffxx(0.6,0.2) << endl;
  cout << dyy(a1)(0.6,0.2) << " yy== " << ffyy(0.6,0.2) << endl;
  cout << dxy(a1)(0.6,0.2) << " xy== " << ffxy(0.6,0.2) << endl;
  cout << dyx(a1)(0.6,0.2) << " yx== " << ffxy(0.6,0.2) << endl;
 cout << a1(0.2,0.6) << " == " << ff(0.2,0.6) << endl;
 cout << a2(0.2,0.6) << " == " << ffx(0.2,0.6) << endl;
  cout << a3(0.2,0.6) << " == " << ffy(0.2,0.6) << endl;
 cout << " 00 = " << int2d(Th)(square(a1-ff)) << endl;
 cout << " 00 = " << int2d(Th)(square(a2-ffx)) << endl;
 cout << " 00 = " << int2d(Th)(square(a3-ffy)) << endl;
plot(a1,wait=1);

Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  [b1,b2,b3]=[a1,a2,a3];

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];
  cout << " int_1 " <<  int1d(Th,1) (dn(a1)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dn(a1)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dn(a1)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dn(a1)) << endl;

  cout << " int_1 " <<  int1d(Th,1) (dnn(a)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dnn(a)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dnn(a)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dnn(a)) << endl;

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << " == " << a2(x1,y1) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h) << " == " << a3(x1,y1) << endl; 

  cout << " dx(a2)(x1,y1) = " << dx(a2)(x1,y1) << " == " << DD(a2,h,0)  << " == " << dxx(a1) << endl; 
  cout << " dy(a2)(x1,y1) = " << dy(a2)(x1,y1) << " == " << DD(a2,0,h)  << " == " << dxy(a1) << endl; 
  cout << " dx(a3)(x1,y1) = " << dx(a3)(x1,y1) << " == " << DD(a3,h,0)  << " == " << dxy(a1) << endl; 
  cout << " dy(a3)(x1,y1) = " << dy(a3)(x1,y1) << " == " << DD(a3,0,h)  << " == " << dyy(a1) << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a2)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a3)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dx(a2)(x1,y1)-DD(a2,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-4);


} 

load "Element_P4"
{
macro DD(f,hx,hy,hz) ( (f(x1+hx,y1+hy,z1+hz)-f(x1-hx,y1-hy,z1-hz))/(2*(hx+hy+hz))) //
macro DD2(f,hx,hy,hz) ( (-2*f(x1,y1,z1)+f(x1+hx,y1+hy,z1+hz)+f(x1-hx,y1-hy,z1-hz))/(square(hx+hy+hz))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
//mesh3 Th("/Users/Hecht/Desktop/bug-ff/Th2.mesh"); //
mesh3 Th=cube(2,2,2); //,[10*(x+y/3),10*(y-x/3),z]);
//Th=trunc(Th, nuTriangle==0);
real x1=0.7,y1=0.9,z1=0.1, h=1e-4;
int it1=Th(x1,y1,z1).nuTriangle; 
fespace Vh(Th,P4);
fespace Eh(Th,P0face3d);
cout << " ndof = "<< Vh.ndof << " /K "<< Vh.ndofK<< endl; 
Eh  edges;

Vh a1,b1,c1;
func bool pvi(real[int] & v)
{
	for(int i=0; i< v.n; ++i)
	if( abs(v[i])>1e-10) cout << i << " ";
	return true;
} 
varf vFlux([a],[e]) = intallfaces(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intallfaces(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/area);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
int err=0;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Tet " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
//  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
//  cout << " Mean   edges = " << edges[] << endl; 
  real je= intallfaces(Th)(square(jump(a1)));
  if( je > 1e-10) err++;
  //plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

 // plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min ;	
  if( c1[].linfty> 1e-10)
  {
	  err++;
    cout <<i << " " ;
    pvi(a1[]);
    cout << " --> " ;
    pvi(b1[]);
    cout <<"   err = "<< err  <<endl;
  }
  cout<< endl;
 // assert(c1[].max < 1e-5 && c1[].min > -1e-9);
  /*
  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1,z1) << " == " << DD(a1,h,0,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1,z1) << " == " << DD(a1,0,h,0)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1,z1) << " == " << DD2(a1,h,0,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1,z1) << " == " << DD2(a1,0,h,0)  << endl; 

  assert( abs(dx(a1)(x1,y1,z1)-DD(a1,h,0,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1,z1)-DD2(a1,h,0,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1,z1)-DD(a1,0,h,0) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1,z1)-DD2(a1,0,h,0) ) < 1e-4);
*/


} 
assert(err==0); 
}

/*
{
	meshL Th=segment(1);
	fespace Vh(Th,P4L);
	fespace Wh(Th,P4dcL);
	func f = 1; //3*x^3+2*x^2+x + 1;
	Vh u = f;
	Wh fd = f;
	Vh v=0;
	v[][0] = 1.; 
	real err = sqrt(int1d(Th)( sqr(f-u)));
	cout << "err L " << err << endl;
	for(int i=0; i<= 9;++i)
	{
		x = i/9.;
		cout << x << " "<< u << " " << f << " " << fd << " " << v << endl; 
	}
	
	
 assert(err < 1e-6);	
	
}
*/
{
	mesh Th2=square(10,10,flags=3);
	//Th2 = trunc(Th2,x<0.5);
	meshS Th=movemesh23(Th2,transfo=[x,y,0]);
	plot(Th,wait=1);
	fespace Vh(Th,P4S);
	fespace Vh2(Th2,P4);
	int[int] P(Vh2.ndof);
	for(int k=0;k<Th.nt;++k)
	for (int i=0;i<15;++i)
	P[Vh(k,i)]=Vh2(k,i);
	//Vh2 f;f[]=0;f[][1]=3;
	func f =3*x^3+2*x^2+x + 1+x*y+y^3+x^4;
	Vh u = f;
	Vh2 u2 =f;
	Vh v=0;
	v[]=u2[](P); 
	v[] -= u[];
	for(int i=0; i< Vh.ndofK;++i)
	cout << Vh(0,i) << " ";
	cout << endl; 
       // cout << " u = " << u[] << endl;
       // cout << " 0 == v = " << v[] << endl;
	cout << endl;
        v[]=u2[](P); 
	//cout << P << endl;
	real err = sqrt(int1d(Th)( sqr(f-u)));
	real err1 = sqrt(int1d(Th)( sqr(f-v)));
	real err2= sqrt(int1d(Th)( sqr(f-u2)));
	cout << "err S " << err << endl;
	cout << "err 1 " << err1 << endl;
	cout << "err 2 " << err2 << endl;
	u2[](P) -=u[];
	cout << u2[].linfty << endl;
	err+= u2[].linfty;
 assert(err < 1e-6);	
	
}

/*

{ // P4HL
       real L = 1;
	meshL Th=segment(1,[x*L,0,0]);
	fespace Vh(Th,P4HL);
	fespace Wh(Th,P4L);
	fespace Whdc(Th,P4dcL);
	func f = 3*(x^3) +2*(x^2)+x + 1;
	func fxx = 18*x+4. ;//+ 4.;
	Wh fh = f;
	cout << " 0 = "<< f(0,0) << " " << dx(fh)(0,0) << " "<< dxx(fh)(0,0) <<" "<< fxx(0,0) << endl; 
	cout << " L = "<< f(L,0) << " " << dx(fh)(L,0) << " " << dxx(fh)(L,0) <<" "<< fxx(L,0) << endl; 
	
	Vh [u,ux] = [f,dx(fh)];
	cout << " u[]"<< u[] << endl; 
	Vh [v,vx]; v[]=0;
	// function de base OK ...
	// interpolation ok ...
	real err = 0; 
	for(int i=0; i<4;++i)
	{ 
	v[]=0;
	v[][Vh(0,i)] = 1.; 
	Wh vv=v,dvv=dx(vv);
	cout << i << " " << Vh(0,i) << " " << dxx(vv)(0,0,0) << " " <<  dxx(vv)(L,0,0) << " " << dxx(dvv)(L/2,0,0)  <<endl;
	cout << "    v 0: "<< v(0,0,0) << " " << vx(0,0,0) << endl; 
	cout << "    v 1: "<< v(L,0,0) << " " << vx(L,0,0) << endl; 
	cout << "    dx(v) 0: "<< dx(v)(0,0,0) << " " << dx(vx)(0,0,0) << endl; 
	cout << "    dx(v) 1: "<< dx(v)(L,0,0) << " " << dx(vx)(L,0,0) << endl; 
	cout << "    dxx(v) 0: "<< dxx(v)(0,0,0) << " " << dxx(vx)(0,0,0) << endl; 
	cout << "    dxx(v) 1: "<< dxx(v)(L,0,0) << " " << dxx(vx)(L,0,0) << endl; 

	Vh [w,wx]=[v,vx]; 
	v[] -= w[]; 
	err += v[].linfty ;
	cout << " w[]"<< w[] <<" err " << err <<  endl; 
        }
        err+= sqrt(int1d(Th)( sqr(f-u)));
	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(dx(fh)-dx(u))));
	 cout << "err L " << err << endl;	
         err+= sqrt(int1d(Th)( sqr(dx(fh)-ux)));
 	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(fxx-dxx(u))));
	//Whdc d=dxx(fh)-dxx(u);
	//cout << d[] << endl;
        cout << "err L " << err << endl;	
	
	
      {  // BiLap 1d ..
	      real cc = 16.;
	      func ue = cc*(1-x)*(1-x)*x*x;
	      func fe = cc*24.0;
	      int nn=50;
	      Th = segment(nn);
	      meshL Thg=segment(nn*40);
	      fespace Ph(Thg,P1);
	      Vh  [u,ux] ,  [v,vx] ;
	      solve BiLap([u,ux],[v,vx]) = int1d(Th)(dx(ux)*dx(vx))- int1d(Th)(fe*v)+on(1,2,u=0,ux=0);
	      Ph U=u, X=x,Ux=ux, F=ue;
	      //cout << U[] << endl;
	      plot([X[],U[]],[X[],F[]],wait=1);
	      err += sqrt(int1d(Th)(sqr(ue-u)));;
	      cout << " err = " << err << endl; 
      }	
 assert(err < 1e-6);	
	
}
*/
load "addNewType"

myType ff("toto"); 
cout << ff(1,2).x << endl; 

cout << ff(1,2).N.x  << endl; 
load "Element_HCT"
load "splitmesh3"
load "Element_P3dc"

macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,flags=3);//,[10*(x+y/3),10*(y-x/3)]);
// Th=trunc(Th,x<0.5); 
mesh Th3=splitmesh3(trunc(Th,1,split=10));
for(int i=0; i<3;++i)
cout <<i << " "  <<" "<<  Th[0][i].x << " " << Th[0][i].y  << endl;
real x1=0.7,y1=0.9, h=1e-6;
int it1=Th(x1,y1).nuTriangle; 

func ff =  2*x*x + 3*y*y + 4.5*y*x + 5*x + 6*y + 7;
func ffx = 4*x + 4.5*y + 5;
func ffy = 6*y + 4.5*x + 6;
func ffxx = 4.;
func ffyy = 6.;
func ffxy =4.5;

fespace Vh(Th,HCT);
fespace Wh(Th3,P3dc);
fespace Eh(Th,P0edge);

Eh  edges;

Vh [a1,a2,a3],[b1,b2,b3],[c1,c2,c3];

 
[a1,a2,a3] = [ ff,ffx,ffy];
cout << a1(0,0) << endl; 
if(1)
for(int k=0; k<12; ++k)
{
    a1[]=0;
    a1[][Vh(0,k)]=1;
    Wh aa=a1,dxaa=dx(aa),dyaa=dy(aa);
    real err=int2d(Th)( square(aa-a1));
    real errx=int2d(Th)( square(dx(aa)-a2));
    real erry=int2d(Th)( square(dy(aa)-a3));
    real errxx=int2d(Th)( square(dx(dxaa)-dxx(a1)));
    cout << int2d(Th)( square(dxaa));
    cout << int2d(Th)( square(dxx(a1)));
  assert(errxx<1e-9);
 
    real erryy=int2d(Th)( square(dy(dyaa)-dyy(a1)));
    real errxy=int2d(Th)( square(dy(dxaa)-dxy(a1)));
    cout << " err= " <<k << ":" << err << " /" << errx << " "<< erry << " / " << errxx << " "<< errxy << " " 
    << erryy << endl;
    assert(int2d(Th)( square(dy(a2)-dyx(a1))) < 1e-9);
    assert(int2d(Th)( square(dy(a3)-dyy(a1))) < 1e-9);
    assert(int2d(Th)( square(dx(a2)-dxx(a1))) < 1e-9);
    assert(int2d(Th)( square(dx(a3)-dxy(a1))) < 1e-9);
    assert(errx<1e-9);
    assert(erry<1e-9);
   assert(errxx<1e-9);
   assert(errxy<1e-9);
   assert(erryy<1e-9);
   [b1,b2,b3]=[a1,a2,a3];
   cout << " a2, a3 :" << a2(0.5,0.5) << " " << a3(0.5,0.5) <<endl; 
   cout << k <<  " b1 = " << b1[] << endl;
   b1[]-=a1[];
   assert(b1[].linfty < 1e-6);
}
 cout << a1(0.6,0.2) << " == " << ff(0.6,0.2) << endl;
 cout << a2(0.6,0.2) << " == " << ffx(0.6,0.2) << endl;
  cout << a3(0.6,0.2) << " == " << ffy(0.6,0.2) << endl;
  cout << dxx(a1)(0.6,0.2) << " xx== " << ffxx(0.6,0.2) << endl;
  cout << dyy(a1)(0.6,0.2) << " yy== " << ffyy(0.6,0.2) << endl;
  cout << dxy(a1)(0.6,0.2) << " xy== " << ffxy(0.6,0.2) << endl;
  cout << dyx(a1)(0.6,0.2) << " yx== " << ffxy(0.6,0.2) << endl;
 cout << a1(0.2,0.6) << " == " << ff(0.2,0.6) << endl;
 cout << a2(0.2,0.6) << " == " << ffx(0.2,0.6) << endl;
  cout << a3(0.2,0.6) << " == " << ffy(0.2,0.6) << endl;
 cout << " 00 = " << int2d(Th)(square(a1-ff)) << endl;
 cout << " 00 = " << int2d(Th)(square(a2-ffx)) << endl;
 cout << " 00 = " << int2d(Th)(square(a3-ffy)) << endl;
plot(a1,wait=1);

//Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  for (int k=0; k< 3; ++k)
    cout <<" v at " << Th[it1][k] <<  " == " << a1(Th[it1][k].x, Th[it1][k].y) << " " << Th[it1][k].x<< " " <<  Th[it1][k].y <<endl;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  [b1,b2,b3]=[a1,a2,a3];

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];
  cout << " int_1 " <<  int1d(Th,1) (dn(a1)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dn(a1)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dn(a1)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dn(a1)) << endl;

  cout << " int_1 " <<  int1d(Th,1) (dnn(a)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dnn(a)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dnn(a)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dnn(a)) << endl;

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << " == " << a2(x1,y1) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h) << " == " << a3(x1,y1) << endl; 

  cout << " dx(a2)(x1,y1) = " << dx(a2)(x1,y1) << " == " << DD(a2,h,0)  << " == " << dxx(a1)(x1,y1) << endl; 
  cout << " dy(a2)(x1,y1) = " << dy(a2)(x1,y1) << " == " << DD(a2,0,h)  << " == " << dxy(a1)(x1,y1) << endl; 
  cout << " dx(a3)(x1,y1) = " << dx(a3)(x1,y1) << " == " << DD(a3,h,0)  << " == " << dxy(a1)(x1,y1) << endl; 
  cout << " dy(a3)(x1,y1) = " << dy(a3)(x1,y1) << " == " << DD(a3,0,h)  << " == " << dyy(a1)(x1,y1) << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a2)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a3)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dx(a2)(x1,y1)-DD(a2,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-4);


} 

/*  README NEWUOA:
     This is the Fortran version of NEWUOA. Its purpose is to seek
the least value of a function F of several variables, when derivatives
are not available, where F is specified by the user through a subroutine
called CALFUN. The algorithm is intended to change the variables to values
that are close to a local minimum of F. The user, however, should assume
responsibility for finding out if the calculations are satisfactory, by
considering carefully the values of F that occur. The method is described
in the report "The NEWUOA software for unconstrained optimization without
derivatives", which is available on the web at www.damtp.cam.ac.uk, where
you have to click on Numerical Analysis and then on Reports, the number
of the report being NA2004/08. Let N be the number of variables. The main
new feature of the method is that quadratic models are updated using only
about NPT=2N+1 interpolation conditions, the remaining freedom being taken
up by minimizing the Frobenius norm of the change to the second derivative
matrix of the model.

     The new software was developed from UOBYQA, which also forms quadratic
models from interpolation conditions. That method requires NPT=(N+1)(N+2)/2
conditions, however, because they have to define all the parameters of the
model. The least Frobenius norm updating procedure with NPT=2N+1 is usually
much more efficient when N is large, because the work of each iteration is
much less than before, and in some experiments the number of calculations
of the objective function seems to be only of magnitude N.

     The attachments in sequence are a suitable Makefile, followed by a main
program and a CALFUN routine for the Chebyquad problems, in order to provide
an example for testing. Then NEWUOA and its five auxiliary routines, namely
NEWUOB, BIGDEN, BIGLAG, TRSAPP and UPDATE, are given. Finally, the computed
output that the author obtained for the Chebyquad problems is listed.

     The way of calling NEWUOA should be clear from the Chebyquad example
and from the comments of that subroutine. It is hoped that the software will
be helpful to much future research and to many applications. There are no
restrictions on or charges for its use. If you wish to refer to it, please
cite the DAMTP report that is mentioned above, which has been submitted for
publication in the proceedings of the 40th Workshop on Large Scale Nonlinear
Optimization (Erice, Italy, 2004).

December 16th, 2004                    M.J.D. Powell (mjdp@cam.ac.uk)
*/

load "ffnewuoa"
/*
      SUBROUTINE CALFUN (N,X,F,IWF)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(*),Y(10,10),IWF(*)
      DO 10 J=1,N
      Y(1,J)=1.0D0
   10 Y(2,J)=2.0D0*X(J)-1.0D0
      DO 20 I=2,N
      DO 20 J=1,N
   20 Y(I+1,J)=2.0D0*Y(2,J)*Y(I,J)-Y(I-1,J)
      F=0.0D0
      NP=N+1
      IW=1
      DO 40 I=1,NP
      SUM=0.0D0
      DO 30 J=1,N
   30 SUM=SUM+Y(I,J)
      SUM=SUM/DFLOAT(N)
      IF (IW .GT. 0) SUM=SUM+1.0D0/DFLOAT(I*I-2*I)
      IW=-IW
   40 F=F+SUM*SUM
      RETURN
      END 

*/
int N=2;
real[int,int] Y(N+1,N);
real[int] X(N);
func real J(real[int] & X)
{
  Y(0,:)=1.;
  Y(1,:)=2.*X;
  for(int i=2;i<=N;++i)
    for(int j=0;j<N;++j)
      Y(i,j) = Y(1,j) * Y(i-1,j)- Y(i-2,j);

  real f=0;
  int np=N+1,iw=1;
  for(int i=0;i<=N;i++)
    {
      real s=Y(i,:).sum/N;
      int i1=i+1;
      if(iw>0) s+= 1./(i1*i1-2.*i1);
      iw=-iw;
      f += s*s;
    }
  return 2.14+f;
}
real delta=1;
mesh Th=square(30,30,[(x-0.5)*delta,(y-0.5)*delta]);
fespace Vh(Th,P1);
Vh u;
for(int i=0;i<Th.nv;++i)
  {X[0]=Th(i).x;X[1]=Th(i).y;
    u[][i]=J(X);
  }
plot(u,wait=1);

for(int i=0;i<N;++i)
  X[i]=(i+1)/(N+1.);
real mincost=newuoa(J,X,rhobeg=2*X[0],rhoend=1e-6,npt=2*N+1);
cout << " min " << mincost << "  at :" << X << endl;
load "BernardiRaugel"
// remark: the sign of p is correct
real s0=clock();
mesh Th=square(2,2);
fespace Vh2(Th,P2BR);
fespace Vh(Th,P0);

fespace Wh(Th,[P2BR,P0]);
real reylnods=400;
//cout << " Enter the reynolds number :"; cin >> reylnods;
Wh [u1,u2,p],[v1,v2,q],[up1,up2,pp];
assert(reylnods>1 && reylnods < 100000);
[up1,up2,pp]=[0.,0.,0.];

func g=(x)*(1-x)*4;

real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
varf NS ([u1,u2,p],[v1,v2,q],init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2)
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            - p*q*(0.000001)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  - int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0)
  + on(1,2,4,u1=0,u2=0) ;
  matrix A= NS(Wh,Wh,solver="SPARSESOLVER");
  real[int] b=  NS(0,Wh);
  u1[] = A^-1*b;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="o/StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.1;
int nbiter = 3;
real coefdt  = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.3,coeftol = 0.25^(1./nbiter);
nu=1./reylnods;

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  A= NS(Wh,Wh,solver="SPARSESOLVER");
  for (i=0;i<=10;i++)
   {
     up1[]=u1[]; // copie vectoriel
     real[int] b= NS(0,Wh);
	 u1[] = A^-1*b;
     //NS;
     if ( !(i % 10))
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="o/plotNS_"+iter+"_"+i+".eps");
     cout << "CPU " << clock()-s0 << "s " << endl;
   }

  if (iter>= nbiter) break;

  Th=adaptmesh(Th,[u1,u2],iso=0,
              abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="o/ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
  [u1,u2,p]=[u1,u2,p];// reinterpolation
  [up1,up2,pp]=[u1,u2,p];// reinterpolation


//  plot(coef=0.2,cmm=" [u1,u2] et p --------- ",p,[u1,u2],wait=1);
   }
cout << "CPU " << clock()-s0 << "s " << endl;
// meditddm.edp
load "medit"
load "shell"
/********************************************
 Initial Problem:
Resolution of the following EDP:
$- \Delta u = f$ on   $\Omega =\{ (x,y) |  1 \leq sqrt(x^2+y^2) \geq 2}$
$- \Delta u = f1$ on  $\Omega_{1} =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
$u = 1$ on $\Gamma$  +  Null Neumman condition on $\Gamma_{1}$ and on $\Gamma_{2}$	
We find the solution $u$ in solving two EDP defined on domain $\Omega$ and $\Omega_{1}$
This solution is vizualize with ffmedit 
*********************************************/
verbosity=3;
{
border Gamma(t=0,2*pi){x=cos(t); y=sin(t); label=1;};
border Gamma1(t=0,2*pi){x=2*cos(t); y=2*sin(t); label=2;};
border Gamma2(t=0,2*pi){x=0.5*cos(t); y=0.5*sin(t); label=3;};

// construction of mesh of domain $\Omega$
mesh Th=buildmesh(Gamma1(40)+Gamma(-40)); 

fespace Vh(Th,P2);
func f=sqrt(x*x+y*y);
Vh us,v;
macro Grad2(us) [dx(us),dy(us)]  // EOM

problem Lap2dOmega(us,v,init=false)=int2d(Th)(Grad2(v)' *Grad2(us)) - int2d(Th)(f*v)+on(Gamma,us=1) ;
//  Resolution of EDP defined on the domain $\Omega$
// $- \Delta u = f$ on $\Omega$ 
//      $u = 1$  on $\Gamma
//   + Null Neumann condition on $\Gamma_{1}$
Lap2dOmega;

// construction of mesh of domain $\Omega1 =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
mesh Th1=buildmesh(Gamma(40)+Gamma2(-40));

fespace Vh1(Th1,P2);
func f1=10*sqrt(x*x+y*y);
Vh1 u1,v1;
macro Grad21(u1) [dx(u1),dy(u1)]  // EOM

problem Lap2dOmega1(u1,v1,init=false)=int2d(Th1)(Grad21(v1)' *Grad21(u1)) - int2d(Th1)(f1*v1)+on(Gamma,u1=1) ;
//   Resolution of EDP defined on the domain $\Omega_{1}$
// $- \Delta u = f1$ on $\Omega_{1}$ 
//      $u = 1$ on $\Gamma$
//   + Null Neumann condition on $\Gamma_{2}$
Lap2dOmega1; 

// vizualisation of solution of the initial problem
medit("solution",Th,us,Th1,u1,order=1,meditff="ffmedit",save="testsavemedit.solb");	
// 
}
{
	mesh3 Th=cube(10,10,10);
	fespace Vh(Th,P1);

	Vh u= x+2*y+3*z;
	savemesh(Th,"meditcube.meshb");
	savesol("meditcube.solb",Th,u,order=1);
}
{
mesh3 Th=readmesh3("meditcube.meshb");
fespace Vh(Th,P1);
Vh u;
verbosity=99;
u[]=readsol("meditcube.solb");
cout << u[].max << " " << u[].min << endl;
assert(abs(u[].max-6) <1e-6);
plot(u);
unlink("meditcube.meshb");
unlink("meditcube.solb");

}
load "CircumCenter"

mesh Th = square(3,3);

fespace Ph(Th,P0);

Ph px,py;

CircumCenter(Th,px[],py[]);

cout << px[] << endl;
cout << py[] << endl;
/*
 *     min   x1*x4*(x1 + x2 + x3)  +  x3
            (= x1^2.x4 + x1.x2.x4 + x1.x3.x4 + x3)
 *     s.t.  x1*x2*x3*x4                   >=  25
 *           x1**2 + x2**2 + x3**2 + x4**2  =  40
 *           1 <=  x1,x2,x3,x4  <= 5
 *
 *     Starting point:
 *        x = (1, 5, 5, 1)
 *
 *     Optimal solution:
 *        x = (1.00000000, 4.74299963, 3.82114998, 1.37940829)
 */
 
 load "ff-Ipopt"
 real[int] xlb=[1.,1.,1.,1.],xub=[5.,5.,5.,5.],glb=[25.,40.],gub=[1.e19,40.];
 
 func real J(real[int] &X)
 {
 	return X[0]*X[3]*(X[0] + X[1] + X[2]) + X[2];
 }
 
 func real[int] dJ(real[int] &X)
 {
 	real[int] grad(X.n);
 	grad[0] = 2.*X[0]*X[3] + X[1]*X[3] + X[2]*X[3];
 	grad[1] = X[0]*X[3];
 	grad[2] = X[0]*X[3] + 1.;
 	grad[3] = X[0]*X[0] + X[0]*X[1] + X[0]*X[2];
 	return grad;
 }
 
matrix H; 

	int[int] hi=[0,1,1,2,2,2,3,3,3,3],hj=[0,0,1,0,1,2,0,1,2,3];
	real[int] hc(hi.n);
	hc=0.;

func matrix HJ(real[int] &X,real jfactor,real[int] &lambda)
{
	H = [hi,hj,hc];
	H(0,0) = jfactor * 2*X[3];
	H(1,0) = jfactor * X[3];
	H(2,0) = jfactor * X[3];
	H(3,0) = jfactor * (2*X[0] + X[1] + X[2]);
	H(3,1) = jfactor * X[0];
	H(3,2) = jfactor * X[0];
	H(1,0) += lambda[0] * (X[2]*X[3]);
	H(2,0) += lambda[0] * (X[1]*X[3]);
	H(2,1) += lambda[0] * (X[0]*X[3]);
	H(3,0) += lambda[0] * (X[1]*X[2]);
	H(3,1) += lambda[0] * (X[0]*X[2]);
	H(3,2) += lambda[0] * (X[0]*X[1]);
	H(0,0) += lambda[1] * 2.;
	H(1,1) += lambda[1] * 2.;
	H(2,2) += lambda[1] * 2.;
	H(3,3) += lambda[1] * 2.;
	//cout << H << endl;
	return H;
}
 
 func real[int] G(real[int] &X)
 {
 	real[int] g(2);
 	g[0] = X[0]*X[1]*X[2]*X[3];
 	g[1] = square(X.l2);
 	return g;
 }
 
 matrix GG;
 int[int] II=[0, 0, 0, 0, 1, 1, 1, 1], JJ=[0, 1, 2, 3, 0, 1, 2, 3];
 real[int] CC=[0.,0.,0.,0.,0.,0.,0.,0.];
 
 GG = [II,JJ,CC];
 
 func matrix jacG(real[int] &X)
 {
    GG(0,0) = X[1]*X[2]*X[3];
    GG(0,1) = X[0]*X[2]*X[3];
    GG(0,2) = X[0]*X[1]*X[3];
    GG(0,3) = X[0]*X[1]*X[2];
    GG(1,0) = 2.*X[0];
    GG(1,1) = 2.*X[1];
    GG(1,2) = 2.*X[2];
    GG(1,3) = 2.*X[3];
 	return GG;
 }
 
 real[int] start=[1, 5, 5, 1];
 real[int] optimsol=[1.00000000, 4.74299963, 3.82114998, 1.37940829];
IPOPT(J,dJ,HJ,G,jacG,start,ub=xub, lb=xlb,clb=glb,cub=gub);
optimsol -= start;
cout << "Dist : " << optimsol.l2 << endl;
 
// Theorem 3.3 in https://arxiv.org/pdf/2105.14981.pdf 
load "Element_P4dc"
load "Element_P4"
load "Element_P3nc"
func real cc(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];

// the ref triangle 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);


//Th = movemesh(Th,[x+0.1*y,y-0.2*x]);
//Th = movemesh(Th,[x*2,y*2]);

mesh Thg = trunc(Th,1,split=2,label=-1);
plot(Th, wait=1);
cout << " Th: " << Th[0][0] << Th[0][1]  << Th[0][2]  << endl; 
int it0=0; 

fespace Lh(Th,P1);
Lh[int] l(3);
l[0][][0]=1;
l[1][][1]=1;
l[2][][2]=1;


fespace Wh(Th,P4dc);
fespace Vh(Th,P3nc);
Wh[int] mn(10);
int k=0;
real cc6 = 3*4*5;
//func bk = (l[0] - l[1]) * (l[1] - l[2]) * (l[2] - l[0]);
func l0 =l[0];
func l1 =l[1];
func l2 =l[2];

mn[k++]=      l0 * l0 * l0;
mn[k++]=  l1 * l1 * l1;
mn[k++]=  l2 * l2 * l2;                                            //3
mn[k++]=        l0 * l0 * l1;
mn[k++]=   l0 * l0 * l2;
mn[k++]=   l1 * l1 * l0;
mn[k++]=   l1 * l1 * l2;
mn[k++]=   l2 * l2 * l0;
mn[k++]=   l2 * l2 * l1;
  //6
mn[k++]=        l0 * l1 * l2;                                                                       //2
//mn[k++]=        bk * l0;
//mn[k++]=   bk * l1 ;                                                                    // P4 element

assert(k==10);
/*
      l0 * l0 * l0, l1 * l1 * l1, l2 * l2 * l2,                                            //3
      l0 * l0 * l1, l0 * l0 * l2, l1 * l1 * l0, l1 * l1 * l2, l2 * l2 * l0, l2 * l2 * l1,  //6
      l0 * l1 * l2,                                                                        //2

*/
Vh u,v;
real[int,int] CC(10,10),C1(10,10);
for (int j=0;j<10;++j)
{
	Wh u=mn[j];
	int i=0;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge));
		CC(j,i++)=  cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge));
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	CC(j,i++)= cc(int2d(Th,qforder=9)( u/area)) ;// bof bof !!!
}
C1=CC		;
CC *=cc6;
cout << " CC =" << CC << endl;
  load "lapack"
inv(C1); 
real[int,int]   Ct =  C1';

cout << " C1 =" << C1 << "\n C1' " << Ct << endl;
cout << " {";
for( int i=0; i<10; ++i)
{ cout << "{";
for( int j=0; j<10; ++j)
{  cout << C1(j,i)  ;
   if( j != 9) cout << ",";}
   cout << "}";
   if( i != 9) cout << ",\n";
}
cout << "}\n\n";


for (int j=0;j<Vh.ndofK;++j)
{
	int i = Vh(0,j);
	cout << j << " -> " <<  i << " : " ;
    u=0;
	u[][i]=1;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		if ( i2 < i1) swap(i1,i2); 
		cout << " " << cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	cout << " " << cc(int2d(Th,qforder=9)( u/area))  <<  " ::::   " ; 
	//plot(u,wait=1);
	v=u;
	for (int j=0;j<Vh.ndofK;++j)
	cout << cc(v[][Vh(0,j)]) << " " ;
	cout << endl;

}


 Th=square(5,5);
 u=x*x*y;
 v = u;
 cout << " err = " << sqrt(int2d(Th)(square((u)-(u))));
 solve PL2(u,v)=int2d(Th,qforder=7)(u*v)-int2d(Th,qforder=9)(x*x*y*v);
 // verification  !!!!!
 plot(u,wait=1);
 real err=0,err1=0,err2=0; 
for (int i=0;i<Vh.ndof;++i)
{
    u=0;

	u[][i]=1;
	Wh u3=u;
	v=u;
	v[]-=u[];
	real e  = v[].linfty;
	real e1 = sqrt(int2d(Th)(square(dx(u)-dx(u3))));
	real e2 = sqrt(int2d(Th)(square(dy(u)-dy(u3))));
	Wh dxu=dx(u), dxu3=dx(u3);
	Wh dyu=dy(u), dyu3=dy(u3);
	//plot(dxu,cmm=" dxu ", wait=1);
	//plot(dxu3,cmm=" dxu3 ", wait=1);
	dxu [] -= dxu3[];
	dyu [] -= dyu3[];
	real ee =  dxu []. linfty +  dyu []. linfty + e1 + e2;
	if( ee > 1e-6)
	  cout << i << " " << e << " " << e1 << " " << e2 << " :: " << dxu []. linfty << " " << dyu []. linfty << endl;
	err+= ee;
}
cout << " err=" << err  << endl; ; 
assert( err < 1e-6);
load "Element_P4"
load "medit"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P4);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
    medit("mm",Th3); 
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "ff-Ipopt";
int nn=10;
mesh Th=square(nn,nn);
fespace Vh(Th,[P1,P1] );
fespace Wh(Th,[P1] );
int iter=0;

func f1 =  10;//right hand sides
func f2 = -15;
func g1 = -0.1;//Boundary conditions functions
func g2 =  0.1;

Vh [uz,uz2]=[1,1],[lz,lz2]=[1,1];
Wh lm=1.;
Vh [u1,u2]=[0,0];//starting point


while(++iter)
{
macro Grad(u) [dx(u),dy(u)]//gradient macro
varf vP([u1,u2],[v1,v2]) = int2d(Th)(Grad(u1)'*Grad(v1)+ Grad(u2)'*Grad(v2)) 
- int2d(Th)(f1*v1+f2*v2);

matrix A = vP(Vh,Vh);//Fitness function matrix...
real[int] b = vP(0,Vh);//and linear form

int[int] II1=[0],II2=[1];//Constraints matrix
matrix C1 =  interpolate (Wh,Vh, U2Vc=II1);
matrix C2 =  interpolate (Wh,Vh, U2Vc=II2);
matrix CC = -1*C1 + C2; // u2 - u1 >0
Wh cl=0;//constraints lower bounds (no upper bounds)

//Boundary conditions
varf vGamma([u1,u2],[v1,v2]) = on(1,2,3,4,u1=1,u2=1);
real[int] onGamma=vGamma(0,Vh);
Vh [ub1,ub2]=[g1,g2];
Vh [lb1,lb2]=[g1,g2];
ub1[] = onGamma ? ub1[] : 1e19  ; //Unbounded in interior
lb1[] = onGamma ? lb1[] : -1e19  ;


Vh [uzi,uzi2]=[uz,uz2],[lzi,lzi2]=[lz,lz2];
Wh lmi=lm;
Vh [ui1,ui2]=[u1,u2];

IPOPT([b,A],CC,ui1[],lb=lb1[],clb=cl[],ub=ub1[],warmstart=iter>1,uz=uzi[],lz=lzi[],lm=lmi[]);

//cout << "ADAPTMESH ITERATION " << iter << endl << "UZ = " << uzi[] << endl << "LZ = " << lzi[] << endl << "LM = " << lmi[] << endl;

plot(ui1,ui2,wait=1,nbiso=60,dim=3);
if(iter > 1) break;
Th= adaptmesh(Th,[ui1,ui2],err=0.004,nbvx=100000);
[uz,uz2]=[uzi,uzi2];
[lz,lz2]=[lzi,lzi2];
[u1,u2]=[ui1,ui2];
lm=lmi;
}
load "gmsh"
load "iovtk"
load "medit"
//verbosity = 1;

// example gmsh

mesh3 Th = gmshload3("cube.msh");
//medit("gmsh3d",Th,wait=1);

// example iovtk

border Gamma(t=0,2*pi){x=cos(t);y=sin(t);label=3;}
border Gamma1(t=0,2*pi){x=2*cos(t);y=2*sin(t);label=5;}
mesh Th2 = buildmesh( Gamma(10)+Gamma1(20) ); 

fespace Vh(Th2,P1);     // P1 FE space
func gg=x;
Vh uh,vh,u;   
Vh ggg=gg;
solve laplacep(uh,vh,solver=CG,tgv=1e5) =      //  definion of  the problem 
    int2d(Th2)( dx(uh)*dx(vh) + dy(uh)*dy(vh) )   //  bilinear form
       + on(3,uh=1)+ on(5,uh=2) ;                        //  boundary condition form

cout << "vtk information" << endl;
int[int] fforder=[0,0,1,0,1];
savevtk("disque.vtk",Th2,uh,ggg,uh,[uh,ggg],[uh,ggg],dataname="kkdjd jyqql bidule45 vector nnn nn44233T",order=fforder,bin=1);


mesh3 Th3;
try {
Th3=readmesh3("spherewithahole.mesh"); // This .mesh file is obtaing with tetgenholeregion.edp
}
catch (...) {
  // FFCS - path to example scripts are changed, so this needs to be in the local directory to be common to FF and FFCS
  //  trick to extract Th3finhole from "tetgenholeregion_rugby.edp"
  //  warning Th3 mesh3 exist in "tetgenholeregion_rugby.edp"
  mesh3 Thedp;// mesh3 variable  out the block 
  {
  include "tetgenholeregion_rugby.edp"
  Thedp=Th3finhole;// save de correcte mesh 
  }
  Th3=Thedp;// set coorect variable ...
}
fespace Vh3(Th3,P1);     // P1 FE space
func gg2=x+y;
int[int] fforder2=[1,1,1,1];
if(verbosity) verbosity=2;
savevtk("bidule.vtu",Th3,gg2,[gg2,gg2,gg2],gg2,[gg2,gg2,gg2],order=fforder2,dataname="kkdjd jyqql bidule45",bin=1); // The fourth solution Have no name. This name is vector4 (4 ==> fourth solution and vector ==> vector solution).
savevtk("bidule.vtk",Th3,gg2,[gg2,gg2,gg2],gg2,[gg2,gg2,gg2],order=fforder2,dataname="kkdjd jyqql bidule45",bin=1);
if(0) { // restore mesh and data, does not work on Windows
real[int][int] data;	

mesh3 Th=vtkload3("bidule.vtk",fields=data);//  work only with order =1 and vgk file
cout << " " << data.n << " == 4 "<< endl;
}

savegmsh(Th3,"Th3");
load "splitmesh6"
mesh Th=square(5,5);
mesh Th6=splitmesh6(Th);
mesh Th6b=splitmesh6PowellSabin(Th);// Add for François Bouchut  feb 2024 
plot(Th6,wait=1);
plot(Th6b,wait=1);

fespace Vh(Th,P1);
fespace Nh(Th,P0);

fespace Vh6(Th6,P1);
fespace Nh6(Th6,P0);
fespace RT6(Th6,RT0); // Raviart Thomas ordre 0

//  
varf vM6(u,v) = int2d(Th6,qforder=1)(u*v*3/area);
matrix  M610= vM6(Nh6,Vh6);
matrix  I61 = interpolate(Vh,Vh6);
matrix  S61 =  I61*M610;

Nh6 eta6=1;
Vh  eta;
eta[]= S61*eta6[];
plot(eta,wait=1);

RT6  [u6,v6];
RT6  [uu6,vv6];

Nh6 x6=x,y6=y;

//solve  PP([u6,v6],[uu6,vv6]) = intalledges(Th6)(  u6*uu6*N.x + v6*vv6*N.y)
//- intalledges(Th6)(  mean(x6)*uu6*N.x + mean(y6)*vv6*N.y);

  [u6,v6] = [mean(x6),mean(y6)]; // OK version 2.19 
 [uu6,vv6] = [x6,y6];
 plot( [u6,v6],  [uu6,vv6], wait=1);
 
 
load "Element_P4dc"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P4dc);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;

if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    if(0)
      { 
      load "medit"
      meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
      medit("mm",Th3); 

      //savemesh(th,"mm",[x,y,vi*0.5]);   //save *.points and *.faces file for medit
      //exec("ffmedit mm");
      //exec(" rm mm.faces mm.points");
      }	
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "Element_Mixte"
/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$

*/
mesh Th=square(10,10);
fespace Vh(Th,RT1);
fespace Ph(Th,P1dc);

func gd = 1.;
func g1n = 1.;
func g2n = 1.;
func f = 1.;

Vh [u1,u2],[v1,v2];
Ph p,q;

problem laplaceMixte([u1,u2,p],[v1,v2,q],solver="SPARSESOLVER",eps=1.0e-10,tgv=1e30,dimKrylov=150) =
   int2d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
 + int2d(Th) ( f*q)
 - int1d(Th,1,2,3)( gd*(v1*N.x +v2*N.y))   //  int on gamma
 + on(4,u1=g1n,u2=g2n);

 laplaceMixte;
 plot([u1,u2],coef=0.1,wait=1,ps="o/lapRTuv.eps",value=true);
 plot(p,fill=1,wait=1,ps="o/laRTp.eps",value=true);  
load "Element_P4dc"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro DD2(f,hx,hy) ( (-2*f(x1,y1)+f(x1+hx,y1+hy)+f(x1-hx,y1-hy))/(square(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-4;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P4dc);
fespace Eh(Th,P0edge);

Eh  edges;

Vh a1,b1,c1;
 
varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1) << " == " << DD2(a1,h,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1) << " == " << DD2(a1,0,h)  << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1)-DD2(a1,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1)-DD2(a1,0,h) ) < 1e-4);



} 

load "distance"
mesh Th=square(10,10);
Th=adaptmesh(Th,0.03,IsMetric=1);
fespace Vh(Th,P1);
varf vong(u,v)= on(1,u=1);
real[int] ong=vong(0,Vh);
Vh u =1,v, e=y;
u[] = ong ? 0 : u[]; 
//plot(u,wait=1);
//verbosity = 10000; 
//savemesh(Th,"Th.msh"); 
distance(Th,u,v[]);
//for (int i=0;i<v[].n; ++i)
// cout << i << " " << v[][i] << " "<< e[][i] <<  endl;  
e = v-y;
cout << "err = "<< e[].linfty << endl; 
plot(e, wait=1);
assert( e[].linfty < 1e-5);// not really exact F. Hecht but small 
load "Element_P3"
load "UMFPACK64"

//defaulttoUMFPACK64();
verbosity=10;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh,solver="UMFPACK64") =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

verbosity=5;
  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "Element_P3"
{
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro DD2(f,hx,hy) ( (-2*f(x1,y1)+f(x1+hx,y1+hy)+f(x1-hx,y1-hy))/(square(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-4;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P3);
fespace Eh(Th,P0edge);

Eh  edges;

Vh a1,b1,c1;
 
varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1) << " == " << DD2(a1,h,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1) << " == " << DD2(a1,0,h)  << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1)-DD2(a1,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1)-DD2(a1,0,h) ) < 1e-4);



} 
}
{
	meshL Th=segment(1);
	fespace Vh(Th,P3L);
	fespace Wh(Th,P3dcL);
	func f = 1; //3*x^3+2*x^2+x + 1;
	Vh u = f;
	Wh fd = f;
	Vh v=0;
	v[][0] = 1.; 
	real err = sqrt(int1d(Th)( sqr(f-u)));
	cout << "err L " << err << endl;
	for(int i=0; i<= 9;++i)
	{
		x = i/9.;
		cout << x << " "<< u << " " << f << " " << fd << " " << v << endl; 
	}
	
	
 assert(err < 1e-6);	
	
}
{
	meshS Th=square3(10,10);
	fespace Vh(Th,P3S);
	func f = 3*x^3+2*x^2+x + 1+x*y+y^3;
	Vh u = f;
	Vh v=0;
	v[][0] = 1.; 
	real err = sqrt(int1d(Th)( sqr(f-u)));
	cout << "err L " << err << endl;
	
	
 assert(err < 1e-6);	
	
}
{ // P3HL
       real L = 1;
	meshL Th=segment(1,[x*L,0,0]);
	fespace Vh(Th,P3HL);
	fespace Wh(Th,P3L);
	fespace Whdc(Th,P3dcL);
	func f = 3*(x^3) +2*(x^2)+x + 1;
	func fxx = 18*x+4. ;//+ 4.;
	Wh fh = f;
	cout << " 0 = "<< f(0,0) << " " << dx(fh)(0,0) << " "<< dxx(fh)(0,0) <<" "<< fxx(0,0) << endl; 
	cout << " L = "<< f(L,0) << " " << dx(fh)(L,0) << " " << dxx(fh)(L,0) <<" "<< fxx(L,0) << endl; 
	
	Vh [u,ux] = [f,dx(fh)];
	cout << " u[]"<< u[] << endl; 
	Vh [v,vx]; v[]=0;
	// function de base OK ...
	// interpolation ok ...
	real err = 0; 
	for(int i=0; i<4;++i)
	{ 
	v[]=0;
	v[][Vh(0,i)] = 1.; 
	Wh vv=v,dvv=dx(vv);
	cout << i << " " << Vh(0,i) << " " << dxx(vv)(0,0,0) << " " <<  dxx(vv)(L,0,0) << " " << dxx(dvv)(L/2,0,0)  <<endl;
	cout << "    v 0: "<< v(0,0,0) << " " << vx(0,0,0) << endl; 
	cout << "    v 1: "<< v(L,0,0) << " " << vx(L,0,0) << endl; 
	cout << "    dx(v) 0: "<< dx(v)(0,0,0) << " " << dx(vx)(0,0,0) << endl; 
	cout << "    dx(v) 1: "<< dx(v)(L,0,0) << " " << dx(vx)(L,0,0) << endl; 
	cout << "    dxx(v) 0: "<< dxx(v)(0,0,0) << " " << dxx(vx)(0,0,0) << endl; 
	cout << "    dxx(v) 1: "<< dxx(v)(L,0,0) << " " << dxx(vx)(L,0,0) << endl; 

	Vh [w,wx]=[v,vx]; 
	v[] -= w[]; 
	err += v[].linfty ;
	cout << " w[]"<< w[] <<" err " << err <<  endl; 
        }
        err+= sqrt(int1d(Th)( sqr(f-u)));
	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(dx(fh)-dx(u))));
	 cout << "err L " << err << endl;	
         err+= sqrt(int1d(Th)( sqr(dx(fh)-ux)));
 	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(fxx-dxx(u))));
	//Whdc d=dxx(fh)-dxx(u);
	//cout << d[] << endl;
        cout << "err L " << err << endl;	
	
	
      {  // BiLap 1d ..
	      real cc = 16.;
	      func ue = cc*(1-x)*(1-x)*x*x;
	      func fe = cc*24.0;
	      int nn=50;
	      Th = segment(nn);
	      meshL Thg=segment(nn*40);
	      fespace Ph(Thg,P1);
	      Vh  [u,ux] ,  [v,vx] ;
	      solve BiLap([u,ux],[v,vx]) = int1d(Th)(dx(ux)*dx(vx))- int1d(Th)(fe*v)+on(1,2,u=0,ux=0);
	      Ph U=u, X=x,Ux=ux, F=ue;
	      //cout << U[] << endl;
	      plot([X[],U[]],[X[],F[]],wait=1);
	      err += sqrt(int1d(Th)(sqr(ue-u)));;
	      cout << " err = " << err << endl; 
      }	
 assert(err < 1e-6);	
	
}

load "scotch"
load "metis"
border C(t=0, 2*pi){ x=cos(t); y=sin(t); }
mesh Th = buildmesh(C(1000)); // first mesh: a simple circle
int lpart = 10; // how many clusters must be created ?
fespace Ph(Th, P0); // using P0 FE to store the partition
int[int] nupart(Th.nt); // the actual partition
Ph part = nuTriangle; // number of each triangles in the mesh
int[int] weight(Th.nt); // array of integers to store weights
for(int i = 0; i < Th.nt;++i)
    weight[i] = Th[i][1].x > 0. && Th[i][1].y > 0. ? 10 : 1; // if we want to partition has much as possible the region x > 0 && y > 0
plot(Th, part, value = 1, fill = 1, wait = 1, cmm = "original");
scotch(nupart, Th, lpart, weight = weight); // with weight
Ph balance;
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH with weights");
scotch(nupart, Th, lpart); // without weight
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH");
metisdual(nupart, Th, lpart);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "Metis");
Th = square(400, 400); // second mesh: a simple square
balance = 0;
part = nuTriangle;
weight.resize(Th.nt);
nupart.resize(Th.nt);
for(int i = 0; i < Th.nt;++i)
    weight[i] = Th[i][1].x > 0.5 && Th[i][1].y > 0.5 ? 100 : 1; // if we want to partition has much as possible the region x > 0.5 && y > 0.5
plot(Th, part, value = 1, fill = 1, wait = 1, cmm = "original");
scotch(nupart, Th, lpart, weight = weight);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH with weights");
scotch(nupart, Th, lpart);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH");
metisdual(nupart, Th, lpart);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "Metis");
load "Element_P2pnc_3d"
load "tetgen"
load "medit"
int err=0;
int cas1=0;  //0 need Th1.mesh ... 
macro DoFi(d,u,vf,p) ((d==12) ? int3d(Th)((u)/volume) : int2d(Th,d/3,qforder=6)((u)*l[vf(d/3,p[d]%3)]/area)) //
macro DoFih(d,u) ((d==12) ? int3d(Th)((u)/volume) : int2d(Th,d/3,qforder=6)((u)*l[vf(d/3,d%3)]/area)) //
macro ErrH1(Th,u,v) sqrt(int3d(Th)( square(dx(u)-dx(v))+square(dy(u)-dy(v))+square(dz(u)-dz(v)) )) //
macro ErrL2(Th,u,v) sqrt(int3d(Th)( square((u)-(v)) )) //
func real clean(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
func real clean(real[int] &aa) {
	for [i,ai:aa] ai=clean(ai);
	return 0; }
func real clean(real[int,int] &aa) {
		for [i,j,ai:aa] ai=clean(ai);
		return 0; }
func bool PrintCC(string str,real[int,int] &A)
		{
			int n= A.n,m=A.m;
			cout <<"\n\n   double "<<  str << "["<< n <<"][" << m <<"] = {\n";
			for( int i=0; i< n;++i)
			{ cout << "\t {";
			  for( int j=0; j< m;++j)
			  {
			  cout << clean(A(i,j)) ;
			  if( j != m-1) cout <<", ";
		          }
			  if( i != n-1) cout << "},\n ";
			  else  cout << "}};\n\n ";
			  if(i%3==2) cout << endl;
		        }
			return 1; 
		}	
// construction des coef fonction des bases
// matrice 13x13 ... 
// les monomes faire ...
int[int,int] vf= [[3,2,1],[0,2,3],[ 3,1,0],[ 0,1,2]];  // FreeFem face Tet numbering ...
//int[int,int] vf= [[1,2,3],[0,2,3],[ 0,1,3],[ 0,1,2]];
int[int] p(13),p1(13) ;// p(î) = i , î dof dans ^K et i: dof dans K 
int[int] q(12),Kq(12); 
// p[i] : p[i]/3 == nF numero de la face p[i]%3 numero du sommet de face dans K et telle p[i] %3 croissante pour un nF. 
// cf. construction de p,p1 
int[int] id(13); 
for(int i=0;i<13;++i) id[i] = i;
func int  print(string cmm,int[int] & p)
{
	cout << cmm;
	for [i,pi:p] {if(i%3==0) cout << " "; cout << " "<< pi ;}
	cout<< endl;
	return p.n;
}

func int buildp(mesh3 & Th,int k, int[int] & p,int[int,int]&  vf)
{
	int [int] I=[Th[k][0],Th[k][1],Th[k][2],Th[k][3]];// le 4 sommet du tet k.
	int [int] II=[0,1,2,3];
	// cout << I << " " << II << endl; 
	int err =0;
	for(int f=0; f<4;++f)
	{ 
		int k = 3*f;
	  //  build the correct order
	  // sort i_j j=0,1,2  I[i_j] croissnate
	  int[int] F=vf(f,:); 
	  int i0=0,i1=1,i2=2;
	  if( I[vf(f,i0)] >I[vf(f,i2)] )  swap(i0,i2);
	  if( I[vf(f,i1)] >I[vf(f,i2)] )  swap(i1,i2);
	  if( I[vf(f,i0)] >I[vf(f,i1)] )  swap(i0,i1);
	  p[k+0]=k+i0;
	  p[k+1]=k+i1;
	  p[k+2]=k+i2;
	//  cout <<i0 << i1 << i2 << " " <<  I[F[i0]] << I[F[i1]] << I[F[i2]] << endl;
	  assert(I[F[i0]] < I[F[i1]]);
	  assert(I[F[i1]] < I[F[i2]]);
       }
        for(int i=0;i<12;++i)
	 q[i] = vf(i/3,p[i]%3); // numero de sommet local des faces 
	for(int i=0;i<12;++i)
	  Kq[i]= I[q[i]]; // numero global de sommet local des faces
	  p[12]=12; 
	  for(int i=0;i<13;++i) p1[p[i]] = i;
  print(" p = ",p);
  print(" q = ",q );
  print("Kq = ",Kq );
  
   return err;	
}
func int verifp(mesh3 & Th,int k, int[int] & p,int[int,int]&  vf)
{
	cout << p << " " << vf << endl;
	int err =0;
	for(int f=0; f<4;++f)
	{
	   err += ((vf(f,0)+vf(f,1)+vf(f,2))!= (0+1+2+3-f));		
	for( int i=0; i<2; ++i)
	{  int i1 = p[3*f+i]%3;// in [0,1,2]
	   int i2 = p[3*f+i+1]%3;	   
	   int n1 = Th[k][vf(f,i1)];
	   int n2 = Th[k][vf(f,i2)];
	   cout << err << " f "  << f << " " << i << " : " << i1 << " " << i2 << "::  " << n1 << " " << n2 << " " << (vf(f,0)+vf(f,1)+vf(f,2)) << " err = " ;	   
	   err += (n2 <= n1);	
	   cout << err << endl; 
	}}
	if(err) cout << err << "\n p = "<< p << "\n vf= " << vf << endl;
   assert(err==0);
   return err;	
}
load "Element_P3dc"
load "Element_P4dc"
load "Element_P2pnc"

real[int] xx=[0,1,0,0], yy=[0,0,1,0], zz=[0,0,0,1]; 
mesh3 Th=tetgconvexhull(xx,yy,zz,region=1,label=3);
savemesh(Th,"/tmp/Th.mesh");

assert(Th.nbe==4);
int [int] plab=[0,2,3,1];
for(int f=0; f<Th.nbe;++f)
{
  int k = 1+2+3-Th.be(f)[0]-Th.be(f)[1]-Th.be(f)[2];
//  cout << f << " " << k << " ::: ";
  plab[Th[0][f]]=k;
  for(int l=0; l<3;++l)	
      cout << " " <<  Th.be(f)[l] << " ";   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
      cout << endl;
	
}
Th=change(Th,flabel=plab[nuFace]);
savemesh(Th,"/tmp/Th2.mesh");
buildp(Th,0,p,vf);
verifp(Th,0,p,vf);


if(cas1) {
	cout << " cas1 "<< "Th1.mesh"<<endl;
mesh3 Th1("Th1.mesh");Th=Th1;
buildp(Th,0,p,vf);
verifp(Th,0,p,vf);

}
fespace Lh(Th,P1);
Lh[int] l(4); // 4 fonctions de Base du P1 .. sur l'element 0
{
	int 	i0 = Lh(0,0); 
	int 	i1 = Lh(0,1); 
	int 	i2 = Lh(0,2); 
	int 	i3 = Lh(0,3); 
l[0][][i0]=1;
l[1][][i1]=1;
l[2][][i2]=1;
l[3][][i3]=1;
}
// verif face
for(int f=0; f<Th.nbe;++f)
{
 err += (abs(int2d(Th,f)(l[f]))>0 );
 cout << f << " err " << err << endl;
}
 assert(err==0);

fespace Wh(Th,P3dc3d); 

Wh[int] mo(13),fb(13);
// le 13 monome to build Base FE function. 
{
  int k=0;
  for(int i=0;i<4;i++)
    mo[k++]=l[i];
   for(int i=0;i<4;i++)
    for(int j=0;j<i;j++)
     mo[k++] = l[i]*l[j];
     cout << k << endl;
    mo[k++] = l[1]*l[2]^2;
    mo[k++] = l[0]*l[2]^2;
    mo[k++] = l[0]*l[1]^2;
    assert(k==13); 
}
// dof computation ...
real[int,int] CC(13,13),C1(13,13),Cc(13,13);


for(int i=0; i<13;++i)
for(int d=0; d<13;++d)
   CC(i,d) = clean(DoFih(d,mo[i]));
   Cc =CC * (130 *6*3);
if(verbosity>9)  cout << " CC = " << Cc << endl;

load "lapack"
verbosity=9;
C1=CC^-1; 
verbosity=1;
clean(C1); 
//cout << C1 << endl; 
// Build Base Func  !!! 
cout << " Test F b formel  p(^i)=i :: " << endl;
 err=0; 
for(int i=0; i<13;++i)
{
	real dij; 
	fb[i][]=0;
	for(int j=0; j<13;++j)
	  fb[i][] += C1(p[i],j)*mo[j][];
	cout << i << " : " ;
	for(int j=0; j<13;++j)
	{
	  cout <<(dij=clean(DoFi(j,fb[i],vf,p))) << " , ";
	  err +=  abs(dij- (i==j)) > 1e-10;
        }
	cout << endl; 	
} 
assert(err==0);

cout << " cas: "<< cas1 <<endl; 
print("p=",p);
PrintCC("C1",C1);  // for C++


// fonction de base 
// CC(i,j) = dof(j)(mo(i)); // 
//  les fonction de base
//fb_k = sum_i c1(k,i)* mo(i)  
// dof(j)fB_k = delta_jk  = sum_i c1(k,i) dof(j) mo(i)  = sum_i c1(k,i) CC(i,j) 
// => Id = c1*CC => c1 = CC^-1 
fespace Vh(Th,P2pnc3d);
cout << " Vh" << Vh.ndof <<  " : "  ;
for( int i=0; i< 13; ++i)
cout << Vh(0,i) << " ";
cout << endl;
Vh f=l[0],g;
cout << " f : " << f[] << endl; 
real f000 = f(0,0,0);
real f100 = f(1,0,0);
real f010 = f(0,1,0);
real f001 = f(0,0,1);
cout << " f (0,0,0) = "<< f000  <<" " << f100 << " "<< f010 << " "<< f001 << " "<< dx(f)(0.25,0.25,0.25) << endl; 

cout << " dof f  : ";
for(int i=0; i<13;++i)
	cout << DoFi(i,f,vf,p) << " ";
cout << "\n\n Verif Interpolant : dof fb  : \n";
	for(int ii=0; ii<13;++ii)
	{
		int i=Vh(0,ii);
		f = fb[i]; 
		cout << i << " :::: " ;
		real dij;
		for(int d=0; d<13;++d)
		{
	         cout << (dij=clean(f[][d]))  <<  ",";
		 err += abs( dij - (d==i) ) > 1e-10; 
	        }
	 Wh ff =f;
	 real dd = ErrH1(Th,f,ff);
	 cout << " dd "<< dd << " "  << ErrL2(Th,dx(f),dx(ff)) << " " << ErrL2(Th,dy(f),dy(ff)) << " " << ErrL2(Th,dz(f),dz(ff)) <<  endl; ;

	 err += (dd> 1e-10); 
	 cout <<endl ;
	}
	
cout <<endl <<  endl;
verbosity=101;
fespace VVh(Th,[P2pnc3d,P2pnc3d]);
verbosity=1;
VVh [u,v]=[1,2];

//assert(err==0) ;
int errinter=err; 
if(errinter==0)
cout << " Interpolant Ok !"<< endl; 

err=0; 
cout << " Test fb C++  with dofi:"<< endl; 
for(int ii=0; ii<13;++ii)
{ // Attention les fonction de base sont avec la permution !!!  non 
	int i = Vh(0,ii);
	cout << i << " i : " ;
	f[]=0.;
	f[][i]=1.;
	real dij;
	for(int d=0; d<13;++d)
	{
	  cout << (dij= clean(DoFi(d,f,vf,p))) <<  ",";
	  err += abs( dij - (d==i) ) > 1e-10; 
        }
       cout << endl; 
}
cout << endl; cout << endl;
if(err==0)
cout << " Fonction de Base OK !!! nb err = " << err << endl;
else 
cout << " PB Fonction de Base!!! nb err = " << err << endl;

if(errinter==0)
cout << " Interpolant Ok !"<< endl; 
else 
cout << " PB Interpolant nb err = " << errinter << endl;

assert(err==0); 

cout << " verification  compatibility  interpolant and  basic function! "<< endl; 
 err =0; 

for(int i=0; i<13;++i)
{
	cout << i << " g i : ";
	f[]=0.;
	f[][i]=1.;
	g = f;	
	for[ j,gi:g[]] cout << clean(gi) << " ";
	g[]-=f[];
	err += g[].linfty > 1e-10; // if no zeo => bug ...
	cout << endl; 

}
cout << " nb err = " << err << endl;
// 
assert(err==0 && errinter==0);  
{
Th= cube(3,2,1,[x*2,y*3+x,z*5]); //trunc(trunc(cube(1,1,1),x<0.5),nuTet<2);
//Th= trunc(Th,nuTet<1);
Vh u=0,v,w;

for(int k=0;k<Th.nt;++k)
{
	for(int i=0;i<4;++i)
	cout << k << ": " << Th[k][i] <<  " ";
	cout << endl;
	for(int i=0;i<13;++i)
	cout << Vh(k,i) << " ";
	cout << endl;
}

for(int i=0; i<Vh.ndof;++i)
{
	u[]=0;u[][i]=1;
	v=u;
	clean(v[]); 
	w[]=u[];
	w[]-=v[];
	real lerr= w[].linfty;
	if(lerr>1e-10 &&0) {
 		cout << " kkk err = "<< endl;
		for(int d=0; d<Vh.ndof;++d)
		if( abs(w[][d]) > 0.1 ) cout <<  d << " " << w[][d] << " , ";
		cout << endl << endl; 
		verbosity=9;
		v=u;
		verbosity=1;
		clean(v[]); 
		cout << i << " " << v[] << endl; 
		
		plot(u,cmm="u i "+i+" "+lerr,wait=1) ;
		plot(v,cmm="v i "+i+" "+lerr,wait=1) ;
	cout << i << " " << lerr << " " << err << endl;	
	assert(lerr>1e-10);;
	err++;
	
	
}
    
	
}
assert(err==0);
}



// PARAM -cd -ns
load "pipe"

// example for with pipe
string persist=" -persist";
persist="";
string sgnuplot ="gnuplot"+persist;
string sls ="ls -l";
if (onWIN32)
{ // windows command ...
	sls="dir";
	sgnuplot= "\"C:\\Program Files (x86)\\gnuplot\\bin\\pgnuplot.exe\""+persist;
}

if(1) {// input case ..
	pstream  ls(sls,"r");

	while (!ls.eof)
	{
		string file;
		getline(ls,file);
		cout <<  file << endl;
	}
}
cout << "pipe on " << sgnuplot << endl;
pstream  f(sgnuplot,"w");
try {
	f << "set terminal png" << endl;
	f << "set output \"pipe.png\"" << endl;
	for(int i=0;i<100; i++)
	{
		cout << "plot sin(x+" + (i*.01) + ") w l;" << endl;
		f  << "plot sin(x+" + (i*.01) + ") w l;" << endl;
	}
	f << "pause 2"<<endl;
}
catch (...)
	{cout << " catch  error ??? "<< endl;}
load "tetgen"

// Parameters
int C1 = 99, C2 = 98; // Boundary labels, could be anything

// Mesh
border C01(t=0, pi){x=t; y=0; label=1;}
border C02(t=0, 2*pi){x=pi; y=t; label=1;}
border C03(t=0, pi){x=pi-t; y=2*pi; label=1;}
border C04(t=0, 2*pi){x=0; y=2*pi-t; label=1;}

border C11(t=0, 0.7){x=0.5+t; y=2.5; label=C1;}
border C12(t=0, 2){x=1.2; y=2.5+t; label=C1;}
border C13(t=0, 0.7){x=1.2-t; y=4.5; label=C1;}
border C14(t=0, 2){x=0.5; y=4.5-t; label=C1;}

border C21(t=0, 0.7){x=2.3+t; y=2.5; label=C2;}
border C22(t=0, 2){x=3; y=2.5+t; label=C2;}
border C23(t=0, 0.7){x=3-t; y=4.5; label=C2;}
border C24(t=0, 2){x=2.3; y=4.5-t; label=C2;}

mesh Th = buildmesh(
	  C01(10) + C02(10) + C03(10) + C04(10)
	+ C11(5) + C12(5) + C13(5) + C14(5)
	+ C21(-5) + C22(-5) + C23(-5) + C24(-5)
	);

mesh Ths = buildmesh(
	  C01(10) + C02(10) + C03(10) + C04(10)
	+ C11(5) + C12(5) + C13(5) + C14(5)
	);

plot(Th, cmm="Th");
plot(Ths, cmm="Ths");

// Construction of a box with one hole and two regions
func zmin = 0.;
func zmax = 1.;
int MaxLayer = 10;

int[int] r1 = [0, 41];
int[int] r2 = [98, 98, 99, 99, 1, 56];
int[int] r3 = [4, 12];	// The triangles of upper surface generated by the triangle in the 2D region of mesh Th of label 4 as label 12
int[int] r4 = [4, 45];	// The triangles of lower surface generated by the triangle in the 2D region of mesh Th of label 4 as label 45

mesh3 Th3 = buildlayers(Th, MaxLayer, zbound=[zmin, zmax], region=r1,
	labelmid=r2, labelup=r3, labeldown=r4);
savemesh(Th3, "box2region1hole.mesh");
plot(Th3, cmm="Th3");

// Construction of a sphere with tetgen 
func XX1 = cos(y)*sin(x);
func YY1 = sin(y)*sin(x);
func ZZ1 = cos(x);

real [int] domain = [0., 0., 0., 0, 0.001];
string test = "paACQ";
cout << "test=" << test << endl;
mesh3 Th3sph = tetgtransfo(Ths, transfo=[XX1, YY1, ZZ1], switch=test,
	nbofregions=1, regionlist=domain);
savemesh(Th3sph,"sphere2region.mesh");
plot(Th3sph, cmm="Th3sph");

load "splitmesh3"
mesh Th=square(5,5);
mesh Th3=splitmesh3(Th);
plot(Th3,wait=1);
load "Element_Mixte"
/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$

*/
mesh Th=square(10,10);
fespace Vh(Th,RT2);
fespace Ph(Th,P2dc);

func gd = 1.;
func g1n = 1.;
func g2n = 1.;
func f = 1.;

Vh [u1,u2],[v1,v2];
Ph p,q;

problem laplaceMixte([u1,u2,p],[v1,v2,q],solver="SPARSESOLVER") =
   int2d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
 + int2d(Th) ( f*q)
 - int1d(Th,1,2,3)( gd*(v1*N.x +v2*N.y))   //  int on gamma
 + on(4,u1=g1n,u2=g2n);

 laplaceMixte;
 plot([u1,u2],coef=0.1,wait=1,ps="o/lapRTuv.eps",value=true);
 plot(p,fill=1,wait=1,ps="o/laRTp.eps",value=true);  
if (HaveUMFPACK) //  to heavy computation if not 
{
load "BernardiRaugel"

real s0=clock();

// Parameters
real reylnods = 400.;
func g = (x)*(1-x)*4;
real nu = 1;
real dt = 0.1;
real penalty = 1.e-6;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter);
real cut = 0.01;
real tol = 0.3;
real coeftol = 0.25^(1./nbiter);

// Mesh
mesh Th = square(2, 2);

// Fespace
fespace Vh2(Th, P2BR);
fespace Vh(Th, P0);
fespace Wh(Th, [P2BR, P0]);
Wh [u1, u2, p], [v1, v2, q], [up1, up2, pp];

// Macro
macro div(u1, u2) (dx(u1) + dy(u2)) //

// Problem
real alpha = 0;
int i = 0;

varf NS ([u1, u2, p], [v1, v2, q], init=i)
	= int2d(Th)(
		  alpha*(u1*v1 + u2*v2)
		+ nu*(
			  dx(u1)*dx(v1)
			+ dy(u1)*dy(v1)
			+ dx(u2)*dx(v2)
			+ dy(u2)*dy(v2)
		)
		- penalty * p*q
		- p*div(v1, v2)
		- div(u1, u2)*q
	)
	- int2d(Th)(
		- alpha*convect([up1, up2], -dt, up1)*v1
		- alpha*convect([up1, up2], -dt, up2)*v2
	)
	+ on(3, u1=g, u2=0)
	+ on(1, 2, 4, u1=0, u2=0)
	;

// Initialization
[up1, up2, pp] = [0., 0., 0.];

// Solve (Stokes)
matrix A = NS(Wh, Wh, solver="SPARSESOLVER");
real[int] b = NS(0, Wh);
u1[] = A^-1 * b;

// Plot
plot([u1,u2], p, coef=0.2, cmm="[u1, u2] and p", value=true, wait=true);

// Convergence loop
int iter = 0;
nu = 1./reylnods;
for (iter = 1; iter <= nbiter; iter++){
	cout << "dt = " << dt << endl;
	alpha = 1./dt;
	
	A = NS(Wh, Wh, solver="SPARSESOLVER");
	
	// Time loop
	for (i = 0; i <= 10; i++){
		// Update
		up1[] = u1[];
		real[int] b = NS(0, Wh);
		
		// Solve
		u1[] = A^-1 * b;
		
		// Plot
		if (!(i % 10))
			plot([u1,u2], p, coef=0.2, cmm="[u1,u2] and p");
		
		// Display
		cout << "CPU " << clock()-s0 << "s " << endl;
	} 
	
	if (iter >= nbiter) break;
	
	// Mesh adaptation
	Th = adaptmesh(Th, [u1, u2], iso=0, abserror=0, cutoff=cut, err=tol, inquire=0, ratio=1.5, hmin=1./1000);
	plot(Th);
	
	// Update
	dt = dt*coefdt;
	tol = tol *coeftol;
	cut = cut *coefcut;
	
	// Re-interpolation
	[u1, u2, p] = [u1, u2, p];
	[up1, up2, pp] = [u1, u2, p];
}

// Display
cout << "CPU " << clock()-s0 << "s " << endl;
}



load "funcTemplate"
 
mesh Th=square(3,3);
fespace Vh(Th,P1);

Vh N;
for(int i=0; i<N.n; i++) {
 N[][i] = i+0.1;
}

Vh P = 2.0;
Vh uh1;
real a;

// OUTPUT:
//    uh1[]
// INPUT:
//    N[]
//    P[]
// Description:
//  make the product N[] .* P[]
//
CppModTemplate3(uh1[], N[], P[]);
cout << endl;
cout << "uh1: " << uh1[].min  << " " << uh1[].max << endl;


CppModTemplate4(uh1[], N[], P[], P[]);
cout << endl;
cout << "uh1: " << uh1[].min  << " " << uh1[].max << endl;

CppModTemplate5(uh1[], N[], P[], P[], P[]);
cout << endl;
cout << "5 args: uh1: " << uh1[].min  << " " << uh1[].max << endl;

CppModTemplate6(uh1[], N[], P[], P[], P[], P[]);
cout << endl;
cout << "6 args: uh1: " << uh1[].min  << " " << uh1[].max << endl;                                                                                                                                           
                                                                                                                                           
CppModTemplate7(uh1[], N[], P[], P[], P[], P[], P[]);
cout << endl;
cout << "7 args: uh1: " << uh1[].min  << " " << uh1[].max << endl; 


CppModTemplate8(uh1[], N[], P[], P[], P[], P[], P[], P[]);
cout << endl;
cout << "8 args: uh1: " << uh1[].min  << " " << uh1[].max << endl; 
cout << " funcs1 " << funcs1(2) << endl;
cout << " funcs2 " << funcs2(2,3) << endl;
cout << " funcs3 " << funcs3(1,2,3) << endl;



Vh[int] U(10); // Array of finite element function 
for(int i=0; i<10; ++i)
  U[i]= i; 
//  plot(U,wait=1);	
cout << "test = "<< test(U) << endl; 
// Stokes Quasi static avec tension superficiel
if (HaveUMFPACK) //  need UMPACK  computation 
{
verbosity=0; 
// voir https://fr.wikipedia.org/wiki/Pression_de_Laplace
load "isoline"
load "Curvature"

real X0 = 0.1, Y0 =1*X0,Y1=0, CC0=Y0; 
real meshsize=X0/10;
real CFL = 0.1; 
real dt = 0.005;
int niter = 100;
real Kc =10; 
real rhog = 0; 
real nu=1;
real Vin =1; 
int nlissage=2;
real X02=X0*X0; 
func u2in=(-1+x*x/X02)*Vin;
real fluxin;
border ctop(t=X0,0){x=t; y=Y0;label=1;};
border cleft(t=Y0,Y1){x=0; y=t;label=3;};
border cright(t=0,Y0){x=X0; y=t;label=0;}
int nsl=100; 
real[int,int] SL(3,nsl) ;
for(int i=0; i< nsl; ++i)
  { 
    real ll = i/(nsl-1.); 
    SL(0,i) = 0*(1-ll)+X0*ll;
    real l0=ll;
    real RR=1.2*1.2, YY=sqrt(RR-1);
    SL(1,i) = -CC0*(sqrt(RR-l0*l0)-YY);
    SL(2,i) = ll; 
  }
real lgc = setcurveabcisse(SL); 
 {  nsl = lgc/meshsize; 
   real[int,int] SL1=equiparameter(SL,nsl); 
   SL.resize(SL1.n,SL1.m);
   SL = SL1;  
 }
border bSL(t=0,1) 
{
    P= Curve(SL,t); 
    label=2; 
} 
Y1= SL(1,0);  
int nn = 20;
func cfix = ctop(X0/meshsize)+cleft(Y0/meshsize)+cright(Y0/meshsize); 
plot( cfix+ bSL(lgc/meshsize) , wait=1); 
func Bmesh = buildmesh( cfix+ bSL(lgc/meshsize) );
mesh Th= Bmesh;

plot(Th, wait=1);
// Formule (2.9) of  http://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch02.d/AFEM.Ch02.pdf 
//  macro Eps(u,v) [ dx(u),dy(v), (dx(v)+dy(u))*0.5, (dx(v)+dy(u))*0.5 ] // 
// here r==x, z==y
macro Eps(u1,u2)  [dx(u1),dy(u2),u1/x, (dx(u2)+dy(u1))*0.5,(dx(u1)+dy(u2))*.5 ] // EOM

macro Grad(u,v) [ dx(u),dy(v), dx(v), dy(u) ] // 
macro div(u1,u2) (dx(u1)+dy(u2) ) // 
macro rdiv(ur,uy) (x*dx(ur) + ur + x*dy(uy)) //

func mN = [ N.x,N.y]*[ N.x,N.y]'; 
func mT = [ N.y,-N.x]*[ N.y,-N.x]'; 
real bN = 1e6, bT = 1e6, bT1 =1e6; // Coef de 
real bT0 = 1; // frottement a la paroi

fespace Mh(Th,P1);
fespace Wh(Th,P2);
Mh rfcourbure;

rfcourbure[]=0;
int[int] llc=[2];
//plot(frcourbure,wait=1,fill=1); 
//real fcourbure =1;
fespace Vh(Th,[P2,P2,P1]); 
Vh [u1,u2,p],[v1,v2,q];
Wh U;
real temps =0; 
for(int iter=0; iter<niter;++iter)
{
    rfcourbure=0;
    rfcourbure[]=raxicurvature(Th,2);
    u1[]=0;
solve PMeca2( [u1,u2,p],[v1,v2,q] ) =
int2d(Th) ( x*2*nu*Eps(u1,u2)'*Eps(v1,v2) - rdiv(v1,v2)*p -rdiv(u1,u2)*q)
 + on(1,u1=0,u2=u2in)
 + on(0,u1=0,u2=0)
 + on(3,u1=0)
 + int1d(Th,2) ( Kc*rfcourbure*[N.x,N.y]'*[v1,v2]) 
 - int2d(Th)( -x*rhog*v2)
;
//plot(rfcourbure,WindowIndex=1);
fluxin = int1d(Th,1)(-u2);

real[int,int] UU(2,nsl);
real Umax=0;
for(int i=0; i<nsl-1;++i)
  {
    x= SL(0,i);
    y= SL(1,i); 
    real Tx=1,Ty=0;
    if(i>0)
    {
    Tx=SL(0,i+1)-SL(0,i-1);
    Ty=SL(1,i+1)-SL(1,i-1);
    }
    
    real ll = sqrt(Tx*Tx+Ty*Ty); 
    real Nx = -Ty/ll;
    real Ny =  Tx/ll;
    real cN= Nx*u1+Ny*u2;
    UU(0,i)=cN*Nx;
    UU(1,i)=cN*Ny;
    Umax=max(Umax,abs(cN)); 
  }
  //  lissage de UU
  real bb= 0.9, aa = (1-bb)/2.; 
  for(int j=0; j<nlissage;++j)
  for(int i=1; i<nsl-2;++i)
    { 
        UU(0,i) = aa*UU(0,i-1)+bb*UU(0,i)+aa*UU(0,i+1);
        UU(1,i) = aa*UU(1,i-1)+bb*UU(1,i)+aa*UU(1,i+1);
    }

  dt = meshsize*CFL/Umax;
  real Vadd = fluxin*dt;
  real volUU=0;
  
  cout << "nsl =" << nsl << " "<<UU.n << " " << UU.m << " " << SL.m << endl; 
  UU(0,nsl-1)=0;
  UU(1,nsl-1)=0;
  for(int i=0; i<nsl-1;++i)
   { 
     SL(0,i) += dt*UU(0,i);
     SL(1,i) += dt*UU(1,i);
   }
temps += dt;

 cout << iter << temps << " " << " dt = " << dt << " " << Umax << endl; 
lgc = setcurveabcisse(SL); 
if( iter% 10 ==9) 
{
   nsl = lgc/meshsize; 
   cout << "nsl =" << nsl << endl; 
   real[int,int] SL1=equiparameter(SL,nsl); 
   SL.resize(SL1.n,SL1.m);
   SL = SL1;  
   if(verbosity>2) 
   for(int i=1; i<nsl-1;++i)
     cout << i << " " << SL(0,i) << " " << SL(1,i) << " " <<  SL(2,i)  <<endl; 
}
plot([u1,u2],p,bSL(lgc/meshsize),coef=dt,cmm=" temps " + temps+ " / " + dt + " / " +Umax );
 Y1= SL(1,0);
Th= Bmesh;
}
cout << " End loop \n"; 
}
load "SuperLu"

verbosity=0;

{

cout << "laplace solving with SuperLu" << endl;

mesh Th=square(10,10);
fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 verbosity= 3;
problem laplace(uh,vh,solver="SUPERLU",tgv=1e5,sym=0) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                        	     //  linear form
  + on(1,2,3,4,uh=g) ;                      //  bou  ndary condition form

  laplace; // solve the problem plot(uh); // to see the result
 
  plot(uh,value=true); 
   verbosity= 1;
   assert(abs(uh[].max - 0.0730987)< 0.01);
}

// FFCS: need to declare it globally to print out its value for regression tests
complex[int] lastx(4);

for(int i=0;i<3;++i)
{
  if(i==0)  cout << "resolution SuperLU" <<endl; 
  if(i==1)  cout << "resolution GMRES" <<endl;
  if(i==2)  cout << "resolution UMFPACK" <<endl; 
  {
    matrix A = 
      [[ 0,  1,  0, 10],
       [ 0,  0,  2,  0],
       [ 0,  0,  0,  3],
       [ 4,  0,  0,  0]];
    real[int] xx = [ 4,1,2,3], x(4), b(4); // xb(4),bbb(4);
    b=A*xx;
    cout << "b="  << b  << endl;
    cout << "xx=" << xx << endl;
    set(A,solver="SUPERLU",sparams="DiagPivotThresh=0.05,ColPerm=MMD_AT_PLUS_A,Equil=NO"); 
    x = A^-1*b;	
    cout << "x=" << endl; cout << x << endl;	
  }
  
  {
    matrix<complex> A = 
      [[  0, 1i,  0, 10],
       [  0,  0, 2i,  0],
       [  0,  0,  0, 3i],
       [ 4i,  0,  0,  0]];
    complex[int] xx = [ 4i,1i,2i,3i], x(4), b(4);
    b = A*xx;
    cout << "b="  << b << endl;
    cout << "xx=" << xx << endl;
    set(A,solver=sparsesolver);
    x = A^-1*b;
    cout << "x=" << endl; cout << x << endl;
    lastx=x;
  }
  if(i==0) DefaultSolver="GMRES";
  if(i==1) DefaultSolver="UMFPACK";
}
cout << " fin.. \n";




load "Element_Mixte"

mesh Th=square(2,2);

fespace Vh(Th,RT0dc);

Vh [u1,u2];
Vh [v1,v2];
int nerr=0; 
for (int i=0;i<Vh.ndof;++i)
{
	u1[]=0;
	u1[][i]=i;
	[v1,v2]=[u1,u2];
	plot([u1,u2],wait=1,cmm=" dof "+i);
	real[int] d=u1[]-v1[]; 
	real err= d.linfty ;
	if (err > 1e-10)
	{
		nerr++;
		cout << " bug dof"<< i << " "<< v1[] << endl; 
	}
	
}
assert(nerr==0); 
/* solves the 3D Helmholtz equation with finite-differences using the
   27-point stencil from Operto, S., Virieux, J., Amestoy, P., L’Excellent,
   J. Y., Giraud, L., & Ali, H. B. H. (2007). 3D finite-difference
   frequency-domain modeling of visco-acoustic wave propagation using a 
   massively parallel direct solver: A feasibility study.
   Geophysics, 72(5), SM195-SM211. */

// for the make check:
// PARAM -nppwl 4 -npml 4

load "Helmholtz_FD"

include "cube.idp"
include "getARGV.idp"

load "medit"
load "MUMPS_seq"

real freq = getARGV("-frequency",1.); // frequency
int nppwl = getARGV("-nppwl",8); // number of points per wavelength
int npml = getARGV("-npml",8); // number of points in pml

real omega = 2.*pi*freq;
real c = 1;
real mu = c^2;
real k = omega/c;

real lambda = (1./freq)*c;
real h = lambda/nppwl;

cout << "lambda = " << lambda << ", h = " << h << endl;

real lengthpml = npml*lambda/nppwl;

/* dimensions of the domain */
real lengthx = 6;
real lengthy = 2;
real depth = 10;

/* point source coordinates */
real xs = lengthx/2.;
real ys = lengthy/2.;
real zs = -depth/2.;

real nloc = nppwl*lengthx/lambda;

int nplx = nloc*(lengthx+2*lengthpml)/lengthx;
int nply = nloc*(lengthy+2*lengthpml)/lengthx;
int npd = nloc*(depth+2*lengthpml)/lengthx;
nplx = nplx+nplx%2;
nply = nply+nply%2;
npd = npd+npd%2;

int[int] N=[nplx,nply,npd];
real [int,int] B=[[-lengthpml,lengthx+lengthpml],[-lengthpml,lengthy+lengthpml],[-depth-lengthpml,lengthpml]];
int [int,int] L=[[11,12],[13,14],[15,16]];

mesh3 Th=Cube(N,B,L);

/* tag the source node: */
real disti, dist = 1e+30;
real idist = -1;
for (int i=0; i<Th.nv; i++) {
  disti =(Th(i).x-xs)^2+(Th(i).y-ys)^2+(Th(i).z-zs)^2;
  if (disti < dist){
    dist = disti; 
    idist = i;
  }
}

func supp = sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2) > lambda;
func pml = (x>=lengthx)+(x<=0)+(y>=lengthy)+(y<=0)+(z>=0)+(z<=-depth);

func exact = exp(1i*k*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2))/(1e-20+4*pi*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2));

fespace Uh(Th,P1);

Uh<complex> rhs = 0;
rhs[][idist] = -1./(h^3);

int[int] npmls(6);
npmls = npml;
matrix<complex> A = HelmholtzFD(Th,omega,mu,npml=npmls);
set(A,solver=sparsesolver);

Uh<complex> u, uexact = exact*supp;

u[] = A^-1*rhs[];

Th = trunc(Th,pml==0);

u = u*supp;

real err = sqrt(abs(int3d(Th,qfV=qfV1lump)(supp*(u-exact)^2))) / sqrt(abs(int3d(Th,qfV=qfV1lump)(supp*exact^2)));

cout << "relative L2 error = " << err << endl;

medit("u.re uexact.re",Th,real(u),real(uexact));
load "Element_P3"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P3);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    if(0)
      {
      load "medit"
      meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
      medit("mm",Th3); 
      //savemesh(th,"mm",[x,y,vi*0.5]);   //save *.points and *.faces file for medit
      //if(!NoGraphicWindow) exec("ffmedit mm");
      //exec(" rm mm.faces mm.points");
      }	
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "Element_P3"
load "NewSolver"
verbosity=3;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "Element_P2bulle3"
load "medit"
mesh3 Th=cube(2, 3, 4);
//mesh3 Th = readmesh3("./T1.mesh");
mesh3 Thf = trunc(Th,1,split=2);
func bool fv(real[int] & v, ofstream of)
{
	of<< " ( ";
	for(int i=0; i< v.n; ++i)
	if(abs(v[i])>1e-10) of << i << " " << v[i] << ", " ;
	of << " ) \n";
	return 1; 
}
func f = x+2*y+3*z;                                            //sin(x) + sin(2*y)+sin(3*z);
fespace Vh(Th,P2b3d);
fespace Vh2(Thf,P1);

Vh u =0,v,w;
//verbosity=10;
int err=0;
for(int i=0; i< u[].n; ++i)
{
	//cout << "\n\t******  i = " << i << endl;
	u=0; u[][i]=1; 
	Vh2 u2 = u; 
	v =u;
	w[]=u[]-v[];
	//plot(u2,cmm=" i =" + i ,wait=1,nbiso = 10);
	if( w[].linfty> 1e-5)
	{
		err++;
	  cout << i << " "<< v[][i] <<" ==" << v[].imax  ; fv(v[],cout); 
     }
	
}
assert(err==0);
u=f; 
real err1 = int3d(Thf)(sqr(f-u)) ;
cout << " err1=" << err1 << endl; 
//cout << u[] << endl;

Vh2 u2 = u; 
plot(u2);
// cout << " u2 bounad = " << u2[].min << " " << u2[].max << endl; 
real err2 = int3d(Th)(sqr(f-u2)) ;
cout << " err2=" << err2 << endl; 
//cout << u2[] << endl;

 

load "mat_psi"
border a(t=0, 2*pi)     {    x = cos(t);    y = sin(t);  };
mesh th2 = buildmesh(a(70));
mesh3 th=  buildlayers(th2,5,zbound=[0,1]);
fespace Vh(th,P1);

Vh vh,vo,u1 = y, u2 = -x, v = exp(-10*((x-0.3)^2 +(y-0.3)^2)), u3=0, rhs =0;
Vh wh=0,Bwh;
real dt = 0.001,t=0, tmax=3.14;
int kk=0;
varf aa(v,vh) = int3d(th)(v*vh/dt) ;
matrix  AA= aa(Vh,Vh,solver="SPARSESOLVER");

problem  A(v,vh) = int3d(th)(v*vh/dt)   - int3d(th)(vo*vh/dt) + rhs[];

real[int] viso=[-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,10,100,1000];
verbosity = 4;
if(1)
 cout << "\n\n\n  MatUpWind0 3d not yet implemented FH. (To DO) \n\n\n" << endl; 
else
for ( t=0; t< tmax ; t+=dt)
{
  vo=v;
  matrix B;
  MatUpWind0(B,th,vo,[u1,u2,u3]);
//  cout << B << endl;
  rhs[] = AA* vo[];
  rhs[] += B* vo[] ;
  v[] = AA^-1*rhs[];
 // wh[][50]=1;
  //Bwh[] = B*wh[];
 // plot(wh,Bwh,wait=1);
  plot(v,fill=1,cmm="convection: t="+t + ", min=" + v[].min + ", max=" +  v[].max,viso=viso,wait=0);
};
plot(v,wait=1,value=1,fill=1);
load "distance"
mesh Th=buildmesh("g.gmesh",nbvx=10000);
fespace Vh(Th,P1);
real[int] bb(4); 
boundingbox(Th,bb);
// b[0] xmin, xmax, ymin ymax 
real xc1 = bb[0]*0.6 + bb[1]*0.4;
real xc2 = bb[0]*0.2 + bb[1]*0.8;
real yc = bb[2]*0.3 + bb[3]*0.7;
real r2 = ((bb[3]-bb[2])*.1)^2;
cout << xc1 << " "<< xc2 << " " << yc << "r2 = " << r2 << endl; 
cout << bb << endl;
func f0 = ((x-xc1)^2 + (y-yc)^2- r2)*((x-xc2)^2 + (y-yc)^2 - r2);
Vh u = f0, v;

plot(u, dim=3, value=1,wait=1); 

verbosity=1; 


distance(Th,f0,v[]);

real[int] v0 = [-10,-1,-0.01,0,0.01,1,10];
plot(u,wait=1,viso=v0);
plot(v,wait=1,cmm="distance");
load "lapack"
// test of lapack load file ... 
// .......................
// load "fflapack" obsolete (F. Hecht version 3.8)
// use  load "lapack"  
int nerr=0; // nomber of err .. 
//  to set a full matrix .. 
macro SETM(A,i,j,fij) 
{ 
    for(int i=0;i<A.n;++i) 
      for(int j=0;j<A.m;++j) 
        A(i,j)= (fij) ;
}//EOM 

// The of Eigen Problem ..
NewMacro TEST(Type,Typevp,vtype,ComputeEV)
{     
cout << "\n\n *****************   VP \n\n\n"; 
int n=5;
Type[int,int] A(n,n),A1(n,n),B(n,n),Id(n,n);
SETM(A,i,j,(i==j) ? n+1 : 1); 
SETM(Id,i,j,real(i==j)); 
A(0,n-1)=vtype;

cout << A << endl;
A1=A^-1;
cout << A1 << endl;

Typevp[int] vp(n);
Typevp[int,int] VP(n,n),KK(n,n);

int nn= ComputeEV(A,vp,VP);
 cout << " vp = " << vp << endl;
 cout << " VP = " << VP << endl;
 
 // verification ... 
 KK =0.;
 for(int i=0;i<n;++i)
   for(int j=0;j<n;++j)
     for(int k=0;k<n;++k)
       //KK(i,j) += (A(i,k) - vp[j]* real(i==k) ) *VP(k,j);
       KK(i,j) += (A(i,k) - ((i==k)?vp[j]:0.0) ) *VP(k,j);
 cout <<" ||KK|| " <<  KK.linfty << endl; 
 nerr += KK.linfty > 1e-9; 
B=0;
B = A*A1; // version 3.13
B -= Id; 
cout <<" ||A*A1-Id|| " <<  B.linfty << endl; 
nerr += B.linfty > 1e-9; 
inv(A1);
A1 -= A; 
cout <<  "|| inv(A1) - A ||" << A1.linfty << endl;
nerr += A1.linfty > 1e-9; 
}
EndMacro 

cout << "Testing real complex dgeev..." << endl;
TEST(real,complex,-100.,dgeev)
cout << nerr << endl;
cout << "Testing complex complex zgeev..." << endl;
TEST(complex,complex,100i,zgeev)
cout << nerr << endl;
cout << "Testing real real dsyev..." << endl;
TEST(real,real,1,dsyev)
cout << nerr << endl;
assert(nerr==0); 


// FFCS - value for regression checks
real regtest=0;

{

int n=5;
real [int,int] A(n,n),  B(n,n),  C(n,n);
SETM(C,i,j,1./(1+i+j)) ; 
SETM(B,i,j,i==j?2.:1./n) ;
 
A = B*C;
cout << A << " " << endl;
A = B + C;
real[int]  b(n),c(n);
real[int,int] AA=A;
AA=A;
real [int,int] At=A';

b = A*c;

At =A';
{

real [int,int] A=[[0,-1,2],[4,11,2],[0,-1,2],[4,11,2]];
real [int,int] B=[[3,-1],[1,2],[6,1]];
real [int,int] E=[[11,0],[35,20],[11,0],[35,20]];
real [int,int]  At=A';
real [int,int] C(A.n,B.m);
C=A*B;
cout << " C = " <<  C << endl;
cout << " E = " <<  E << endl;

C -= E;
assert( C.linfty < 1e-10);
C = A*B;
C -=E; 
assert( C.linfty < 1e-10);
}
{

complex [int,int] A=[[0,-1,2],[4,11,2],[0,-1,2],[4,11,2]];
complex [int,int] B=[[3,-1],[1,2],[6,1]];
complex [int,int] E=[[11,0],[35,20],[11,0],[35,20]];

complex [int,int] C(A.n,B.m);
complex [int,int]  At=A';
cout << "At = " << At << endl;
C=A*B;
cout << " C = " <<  C << endl;
cout << " E = " <<  E << endl;

C -= E;
assert( C.linfty < 1e-10);
C = A*B;
C -=E; 
assert( C.linfty < 1e-10);

// FFCS - value for regression checks
regtest=C.linfty;
}
}
// Example of dynamic function load
// --------------------------------
// $Id$
//   Discret Fast Fourier Transform 
// -------------------------------
 load "dfft"
 
int nx=32,ny=16,N=nx*ny;
// warning the fourier space is not exactly the unite square due to periodic condition
mesh Th=square(nx-1,ny-1,[(nx-1)*x/nx,(ny-1)*y/ny]);
// warring  the numbering is of the vertices (x,y) is 
// given by $  i = x/nx + nx* y/ny $

fespace Vh(Th,P1); 

func f1 = cos(2*x*2*pi)*cos(3*y*2*pi);
Vh<complex> u=f1,v;
Vh w=f1;


Vh  ur,ui;
//  in dfft the matrix n,m is in row-major order ann array n,m is 
// store j + m* i ( the transpose of the square numbering ) 
 v[]=dfft(u[],ny,-1);
 u[]=dfft(v[],ny,+1);
 cout << " ||u||_\infty " << u[].linfty << endl;
 u[] *= 1./N; // remark: operator /= bug  before version 2.0-3 (FH)
 cout << " ||u||_\infty " << u[].linfty <<  endl;
  ur=real(u); 
  plot(w,wait=1,value=1,cmm="w");
  plot(ur,wait=1,value=1,cmm="u");
 v = w-u;
cout << " diff = "<< v[].max << " " <<  v[].min << endl;
assert( norm(v[].max) < 1e-10 &&  norm(v[].min) < 1e-10) ;
 // -------  a more hard example ----\hfilll
 // Lapacien en FFT \hfilll
 // $ -\Delta u = f $ with biperiodic condition \hfilll
func f = cos(3*2*pi*x)*cos(2*2*pi*y); // 
func ue =  +(1./(square(2*pi)*13.))*cos(3*2*pi*x)*cos(2*2*pi*y);  // the exact solution 
Vh<complex> ff = f;
Vh<complex> fhat;
fhat[] = dfft(ff[],ny,-1);

Vh<complex> wij,wijm;
// warning in fact we take mode between -nx/2, nx/2 and -ny/2,ny/2
//  thank to the operator ?: \label{?:} 
wij = square(2.*pi)*(square(( x<0.5?x*nx:(x-1)*nx)) + square((y<0.5?y*ny:(y-1)*ny)));
wij[][0] = 1e-5; // to remove div / 0
fhat[] = fhat[]./ wij[];  // 
u[]=dfft(fhat[],ny,1);
u[] /= complex(N);
ur = real(u); // the solution
w = real(ue); // the exact solution 
plot(w,ur,value=1 ,cmm=" ue   ", wait=1); 
w[] -= ur[]; // array sub
real err= abs(w[].max)+abs(w[].min) ;
cout << " err = " << err << endl;
assert( err  < 1e-6);

// version 3.22 ... 

fftwplan p1=plandfft(u[],v[],ny,-1);
fftwplan p2=plandfft(u[],v[],ny,1);
//mapkk(wijm[],ny,cccx*(x*x)+cccy*(y*y));
mapkk(wijm[],P,ny,sqr(2*pi*x)+sqr(2*pi*y)); 
wijm[][0] = 1e-5;
plot(wij,wait=1);
plot(wijm,wait=1);
wij[]-=wijm[];
cout << " err = " << wij[].linfty << endl;
assert( wij[].linfty < 1e-8);
load "Element_P1ncdc"
load "Element_P1dc1"
int errT=0; 

macro Test(Th,FE,nFE)
{
int err=0; 	
fespace Wh(Th,FE);
Wh u=x,v,w;
int[int] I(Wh.ndof), K(Wh.ndof);
for(int k=0; k<Th.nt;++k)
for(int i=0; i< Wh.ndofK;++i)
{  int j = Wh(k,i);
	I[j]= i;
	K[j]=k;
}
for(int i=0; i< Wh.ndof;++i)
{
	if(0) cout << " i "<< i << endl;
	u=0;
	u[][i]=1;
	v=u;
	v[]-=u[];
	err += v[].linfty>1e-7;
	if(v[].linfty>1e-7) {v=u;cout << " err" << i<< " " << "Wh(k,i) " << K[i] << " " << I[i] << v[] << endl;}
}
cout << " ** " << nFE << " Nb err = "<< err<< " " << Wh.ndof << " errT =" << errT << endl; 
errT += err;
}
// 

mesh Th=square(1,1);

{
	fespace Vh(Th,P1bnc);
	

Vh u=x;

for(int i=0; i< Vh.ndof;++i)
{
	u=0;
	u[][i]=1;
plot(u,wait=1,cmm="2d dof="+i,fill=1,dim=3);

}
varf vm(u,v)= int2d(Th,qforder=3)(u*v);
matrix M=vm(Vh,Vh);
//cout << M << endl; 
}

//	Test(Th,P1dcnc,"P1dcnc")
Test(Th,P1dc,"P1dc")
Test(Th,P1dc1,"P1dc1")
Test(Th,P1bnc,"P1bnc")
Test(Th,P1bdcnc,"P1bdcnc")

mesh3 Th3=cube(1,1,1);

Test(Th3,P1dc3d,"P1dc3d")
Test(Th3,P1dc3d1,"P1dc3d1")


meshS ThS=square3(1,1);
fespace VhS(ThS,P1dcS);
VhS uS=x;

for(int i=0; i< VhS.ndof;++i) {
	uS=0;
	uS[][i]=1;
plot(uS,wait=1,cmm="3d surf dof="+i,fill=1);
}
Test(ThS,P1dcS,"P1dcS")
Test(ThS,P1dcS1,"P1dc1S")


meshL ThL=Sline(10);
Test(ThL,P1dcL,"P1dcL")
Test(ThL,P1dcL1,"P1dc1L")



assert(errT==0);

load "Element_P4dc"
load "Element_P4"
load "Element_P3pnc"
func real cc(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];

// the ref triangle 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);


//Th = movemesh(Th,[x+0.1*y,y-0.2*x]);
//Th = movemesh(Th,[x*2,y*2]);

mesh Thg = trunc(Th,1,split=2,label=-1);
plot(Th, wait=1);

int it0=0; 

fespace Lh(Th,P1);
Lh[int] l(3);
l[0][][0]=1;
l[1][][1]=1;
l[2][][2]=1;


fespace Wh(Th,P4dc);
fespace Vh(Th,P3pnc);
Wh[int] mn(12);
int k=0;
real cc7 = 3*4*5*6*7;
func bk = (l[0] - l[1]) * (l[1] - l[2]) * (l[2] - l[0]);
func l0 =l[0];
func l1 =l[1];
func l2 =l[2];

mn[k++]=      l0 * l0 * l0;
mn[k++]=  l1 * l1 * l1;
mn[k++]=  l2 * l2 * l2;                                            //3
mn[k++]=        l0 * l0 * l1;
mn[k++]=   l0 * l0 * l2;
mn[k++]=   l1 * l1 * l0;
mn[k++]=   l1 * l1 * l2;
mn[k++]=   l2 * l2 * l0;
mn[k++]=   l2 * l2 * l1;
  //6
mn[k++]=        l0 * l1 * l2;                                                                       //2
mn[k++]=        bk * l0;
mn[k++]=   bk * l1 ;                                                                    // P4 element


/*
      l0 * l0 * l0, l1 * l1 * l1, l2 * l2 * l2,                                            //3
      l0 * l0 * l1, l0 * l0 * l2, l1 * l1 * l0, l1 * l1 * l2, l2 * l2 * l0, l2 * l2 * l1,  //6
      l0 * l1 * l2,                                                                        //2
      bk * l0, bk * l1                                                                     // P4 element

*/
/*
for(int i=0; i<3;++i)
{
	int i1 = (i+1)%3, i2=(i+3)%3;
	mn[k++]= l[i];
	mn[k++]= l[i1]*l[i2];
	mn[k++]= l[i]*l[i]*l[i];
	
}
mn[k++]= l[0]*l[1]*l[2];
mn[k++]= l[0]*bk;
mn[k++]= l[1]*bk;
*/
Vh u,v;
real[int,int] CC(12,12),C1(12,12);
for (int j=0;j<Vh.ndofK;++j)
{
	Wh u=mn[j];
	int i=0;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge));
		CC(j,i++)=  cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge));
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	CC(j,i++)= cc(int2d(Th,qforder=9)( l[0]*u/area)) ;
	CC(j,i++)= cc(int2d(Th,qforder=9)( l[1]*u/area)) ;
	CC(j,i++)= cc(int2d(Th,qforder=9)( l[2]*u/area)) ;
}
C1=CC		;
CC *=cc7;
cout << " CC =" << CC << endl;
real[int,int] DD =[
  [  -1.2,    -1.2,      1.2,      1.2,         6.,        -15.6,       6.,        1.2,       -15.6,      -9.6,     4.8,      4.8     ], //dof 1
  [   6.,     1.2,      -15.6,     -1.2,        -1.2,       1.2,        1.2,       6.,        -15.6,      4.8,      -9.6,     4.8     ], //dof 2
  [   1.2,    6.,       -15.6,      6.,         1.2,       -15.6,      -1.2,      -1.2,       1.2,        4.8 ,     4.8,      -9.6    ], //dof 3
  [  -8.4,    -73.2,    298.8,      73.2,       10.8,      -306.,      -46.8,      20.4,      97.2,      189.6,    -192.,      2.4    ],  //dof 4
  [  10.8,    75.6,     -205.2,     -63.6,      -46.8,     349.2,      10.8,      -10.8,      -54.,      21.6,      86.4,     -108.   ], //dof 5
  [  10.8,    73.2,     -306.,      -73.2,      -8.4,      298.8,      20.4,      -46.8,      97.2,      -192.,     189.6,    2.4     ], //dof 6
  [ -46.8,    -63.6,    349.2,      75.6,       10.8,      -205.2,     -10.8,     10.8,      -54.,       86.4 ,     21.6,    -108.    ], //dof 7
  [ -10.8,    -73.2,    198.,       37.2,       20.4,      -154.8,     -8.4,      10.8,      46.8,       -24. ,     -81.6,    105.6   ], //dof 8
  [  20.4,    37.2,     -154.8,    -73.2,       -10.8,     198.,       10.8,      -8.4,      46.8,       -81.6 ,    -24.,     105.6   ], //dof 9
  [  12.,     12.,      -180.,      12.,        12.,       -180.,      12.,       12.,       -180.,      60. ,      60.,      60.     ], //dof 10
  [   0.,     -84.,     252.,       84.,        84.,       -504.,     -84.,       0.,        252.,       84.,      -168.,     84.     ], //dof 11
  [ -84.,     -84.,     504.,       84.,        0.,        -252.,     -0.,        84.,      -252.,       168.,     -84.,     -84.     ] //dof 12
   ];
  load "lapack"
inv(C1); 
real[int,int]   Ct =  C1';
cout << " C1 " << C1 << " DD = " << DD << endl; 
   DD -= Ct;
   cout << DD << endl; 
   cout << DD.linfty << endl; 


cout << " C1 =" << C1 << endl;

for (int j=0;j<Vh.ndofK;++j)
{
	int i = Vh(0,j);
	cout << j << " -> " <<  i << " : " ;
    u=0;
	u[][i]=1;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		if ( i2 < i1) swap(i1,i2); 
		cout << " " << cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	cout << " " << cc(int2d(Th,qforder=9)( l[0]*u/area)) << " " << cc(int2d(Th,qforder=9)( l[1]*u/area)) <<" " << cc(int2d(Th,qforder=9)( l[2]*u/area)) << endl; 
	//plot(u,wait=1);
	v=u;
	for (int j=0;j<Vh.ndofK;++j)
	cout << cc(v[][Vh(0,j)]) << " " ;
	cout << endl;

}


 Th=square(5,5);
 u=x*x*y;
 v = u;
 cout << " err = " << sqrt(int2d(Th)(square((u)-(u))));
 solve PL2(u,v)=int2d(Th,qforder=7)(u*v)-int2d(Th,qforder=9)(x*x*y*v);
 // verification  !!!!!
 plot(u,wait=1);
 real err=0,err1=0,err2=0; 
for (int i=0;i<Vh.ndof;++i)
{
    u=0;

	u[][i]=1;
	Wh u3=u;
	v=u;
	v[]-=u[];
	real e  = v[].linfty;
	real e1 = sqrt(int2d(Th)(square(dx(u)-dx(u3))));
	real e2 = sqrt(int2d(Th)(square(dy(u)-dy(u3))));
	Wh dxu=dx(u), dxu3=dx(u3);
	Wh dyu=dy(u), dyu3=dy(u3);
	//plot(dxu,cmm=" dxu ", wait=1);
	//plot(dxu3,cmm=" dxu3 ", wait=1);
	dxu [] -= dxu3[];
	dyu [] -= dyu3[];
	real ee =  dxu []. linfty +  dyu []. linfty + e1 + e2;
	if( ee > 1e-6)
	  cout << i << " " << e << " " << e1 << " " << e2 << " :: " << dxu []. linfty << " " << dyu []. linfty << endl;
	err+= ee;
}
cout << " err=" << err  << endl; ; 
assert( err < 1e-6);
load "mat_psi"
border a(t=0, 2*pi)     {    x = cos(t);    y = sin(t);  };
mesh th = buildmesh(a(70));
fespace Vh(th,P1);

Vh vh,vo,u1 = y, u2 = -x, v = exp(-10*((x-0.3)^2 +(y-0.3)^2)), rhs =0;
Vh wh=0,Bwh;
real dt = 0.001,t=0, tmax=pi/4;
int kk=0;
varf aa(v,vh) = int2d(th)(v*vh/dt) ;
matrix  AA= aa(Vh,Vh,solver=CG);

problem  A(v,vh) = int2d(th)(v*vh/dt)   - int2d(th)(vo*vh/dt) + rhs[];

real[int] viso=[-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,10,100,1000];
verbosity = 4;
for ( t=0; t< tmax ; t+=dt)
{
  vo[]=v[];
  matrix B;
  MatUpWind0(B,th,vo,[u1,u2]);
//  cout << B << endl;
  rhs[] = B* vo[] ;
  rhs[] = -rhs[] ;
  rhs[] += AA* vo[];
  v[] = AA^-1*rhs[];
 // wh[][50]=1;
  //Bwh[] = B*wh[];
 // plot(wh,Bwh,wait=1);
  plot(v,fill=1,dim=3,cmm="convection: t="+t + ", min=" + v[].min + ", max=" +  v[].max,viso=viso,wait=0);
};
plot(v,dim=3,wait=1,value=1,fill=1);
// -*- FreeFEM -*-
// Time-stamp: "2022-10-04 18:08:35 fujiwara"
//
// Example from FreeFEM document
//
//----------------------------------------------------------------------
// Domain
//----------------------------------------------------------------------
border ba(t=0,1.0) { x=t;   y=0;   label=1; };
border bb(t=0,0.5) { x=1;   y=t;   label=2; };
border bc(t=0,0.5) { x=1-t; y=0.5; label=3; };
border bd(t=0.5,1) { x=0.5; y=t;   label=3; };
border be(t=0.5,1) { x=1-t; y=1;   label=2; };
border bf(t=0.0,1) { x=0;   y=1-t; label=1; };

mesh Th = buildmesh( ba(6)+bb(4)+bc(4)+bd(4)+be(4)+bf(6) );

//----------------------------------------------------------------------
// P1 approximation
//----------------------------------------------------------------------
fespace Vh1(Th,P1);
Vh1 u,v;
func f = -1;
solve Poisson(u,v)
  = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))
    - int2d(Th)(f*v) + on(1,u=0) + on(2,u=0) + on(3,u=0);

plot(u,ps="LshapeP1.ps"); // default output

load "plotPDF"  // without semicolon

bool ret = plotPDF( "LshapeP1", Th, u );

assert( ret == true );  // Error check.

plotPDF( "LshapeP1contour", Th, u, gray=true, value=false, meshpage=false, index=false, belabel=false, fill=false ); // only contour (without legend : value=false), monochrome

//------------------------------
// output with options
//------------------------------
plotPDF( "LshapeWithMesh", Th, u, withmesh=0.75 );
plotPDF( "LshapeP1op1", Th, u, index=true, nbiso=36, nbfill=128 );

real[int] contour = [ -0.03,-0.025,-0.020,-0.015,-0.010 ];
real[int] range = [ -0.03, -0.01 ];
plotPDF( "LshapeP1op2", Th, u, index=true, viso=contour, frange=range );

//----------------------------------------------------------------------
// P0 approximation
//----------------------------------------------------------------------
fespace Vh0(Th,P0);
Vh0 u0 = u;
plotPDF( "LshapeP0", Th, u0, fetype="P0" );

//----------------------------------------------------------------------
// P1nc approximation
//----------------------------------------------------------------------
fespace Vh1nc(Th,P1nc);
Vh1nc u1nc,v1nc;
solve PoissonP1nc(u1nc,v1nc)
  = int2d(Th)(dx(u1nc)*dx(v1nc)+dy(u1nc)*dy(v1nc))
    - int2d(Th)(f*v1nc) + on(1,u1nc=0) + on(2,u1nc=0) + on(3,u1nc=0);

plotPDF( "LshapeP1nc", Th, u1nc );

//----------------------------------------------------------------------
// P2 approximation
//----------------------------------------------------------------------
fespace Vh2(Th,P2);
Vh2 u2,v2;
solve PoissonP2(u2,v2)
  = int2d(Th)(dx(u2)*dx(v2)+dy(u2)*dy(v2))
    - int2d(Th)(f*v2) + on(1,u2=0) + on(2,u2=0) + on(3,u2=0);

plotPDF( "LshapeP2", Th, u2, fetype="P2" );

plotPDF( "LshapeP2asP1", Th, u2 ); // u2 is interpreted as P1-approx.

//----------------------------------------------------------------------
// color palette example
//----------------------------------------------------------------------
// Proposed by Paul Tol
// Each triplet is [R,G,B]
// The 1st and the final are colors for minimum and maximum values.
// Between them, RGB is linearly interpolated

real[int,int] BuRd = [
  [ 33,102,172],
  [ 67,147,195],
  [146,197,222],
  [209,229,240],
  [247,247,247],
  [253,219,199],
  [244,165,130],
  [214,96, 77],
  [178,24, 43]
];
plotPDF( "LshapeP2-BuRd", Th, u2, fetype="P2", meshpage=false, palette=BuRd );

//----------------------------------------------------------------------
// vector fields
//----------------------------------------------------------------------
border c(t=0,2*pi) { x=cos(t); y=sin(t); }
//border a(t=0,2*pi) { x=0.3+0.3*cos(t); y=0.3*sin(t); }

int m = 30;
Th = buildmesh( c(m) );
//Th = buildmesh( c(m)+a(m) );

fespace P1h(Th,P1);
P1h uc=x*x+y*y, vc=x*x-y*y;

//verbosity=99;

// plot([uc,vc],Th,ps="vector.eps",wait=1); // default in FreeFem++
plotPDF("vector.pdf",Th,[uc,vc], withmesh=0.2, meshpage=false );
plotPDF("vector-unitarrow.pdf",Th,[uc,vc], unitarrow=true, isoline=false, withmesh=0.2, meshpage=false );

//----------------------------------------------------------------------
// complex-valued functions
//----------------------------------------------------------------------

border recta(t=-pi,pi) { x=t;  y=-1; label=1; };
border rectb(t=-1,1) { x=pi;  y=t;  label=2; };
border rectc(t=-pi,pi) { x=-t; y=1;  label=3; };
border rectd(t=-1,1) { x=-pi; y=-t; label=4; };

int r=20;
mesh Thr = buildmesh( recta(3*r) + rectb(r) + rectc(3*r) + rectd(r) );
fespace Vhr(Thr,P1);

Vhr<complex> sinz = sin( x + y*1i );

plotPDF( "complex.pdf", Thr, sinz, cmm="sin(z)", meshpage=false, zabs=true, zreal=true, zimag=true, zarg=true,fill=false );

//----------------------------------------------------------------------
// End of file
//----------------------------------------------------------------------
load "Element_P3"
load "NewSolver"

//defaulttoUMFPACK();
verbosity=3;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

verbosity=5;
  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "Element_P3"
load "MUMPS_seq"

//defaulttoMUMPSseq();
verbosity=4;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh  uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function
 real[int] rinfo(40);
 int[int] info(40);
 varf laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) - 100*uh*vh   ) //  bilinear form
  + int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form
matrix A=laplace(Vh,Vh,solver=sparsesolverSym);
set(A,solver=sparsesolver,rinfo=rinfo,info=info);
real[int] b=laplace(0,Vh);
cout << " nnz = "<< A.nnz << endl;  
//verbosity=1;
  uh[]=A^-1*b; // solve the problem plot(uh); // to see the result
  cout << "uh[] " << uh[].linfty << endl;
  plot(uh,ps="o/LaplaceP3.eps",value=true);
  if(verbosity>1)
 for(int i=0; i<40;++i)
   {
    cout << " solve: info " << i+1 << " = " << info[i] << " , / r " << rinfo[i] <<endl;
   }
load "distance"
load "medit"
mesh3 Th=cube(10,10,10);
fespace Vh(Th,P1);
Vh u = z;//-0.501; 
func fxy=max(abs(x-y),abs(-1.+x+y));
func fxz=max(abs(x-z),abs(-1.+x+z));
func fyz=max(abs(y-z),abs(-1.+y+z));
func fxyz = max(max(fxy,fxz),fyz);
func ff=max(max(abs(x-0.5),abs(y-0.5)),abs(z-0.5));
u = 0.25-ff;
real[int] v0 = [0.001];
plot(u, dim=3, value=1,viso=v0,wait=1); 
Vh v=0,zz=z;
verbosity=3; 
//cout << v[] << endl; 

distance(Th,u,v[],distmax=1);


plot(u,wait=1,viso=v0);
plot(v,wait=1,cmm="distance",nbiso=10);
cout << " vmin/ vmax  " << v[].min << " "<< v[].max << endl;
verbosity=0;
/*
for( int k=0; k< Th.nt; ++k)
for( int j=0; j< 4; ++j)
{
	int i= Vh(k,j);
if(abs(v[][i]-zz[][i]) > 0.001)
cout << " i "<< i << " k = "<< k << " " << j << endl;
}
//medit("Th-v",Th,v);
*/
load "Element_P3dc"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro DD2(f,hx,hy) ( (-2*f(x1,y1)+f(x1+hx,y1+hy)+f(x1-hx,y1-hy))/(square(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-4;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P3dc);
fespace Eh(Th,P0edge);

Eh  edges;

Vh a1,b1,c1;
 
varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].linfty < 1e-5 );

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1) << " == " << DD2(a1,h,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1) << " == " << DD2(a1,0,h)  << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1)-DD2(a1,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1)-DD2(a1,0,h) ) < 1e-4);



} 

// FFCS: for regression tests
load "ClosePoints"
real regtest;
{
    // example of mesh with a given set of internal point (P)
    // P(i,0) x,
    // P(i,1) y,
    // P(i,2) = mesh density close to x,y not mandatory ..
    verbosity=1;

 real[int,int] P(100,3);
 real[int,int] Q(100,2);
 for(int i=0; i<P.n; ++i)
  {
      P(i,0) = 0.5+0.1*cos(i*0.02*pi);
      P(i,1) = 0.5+0.1*sin(i*0.02*pi);
      Q(i,0)=P(i,0)+i*0.001;
      Q(i,1)=P(i,1);

      P(i,2) = 0.05*0.05*2*pi;// mesh size auron point..
  }
// multy border syntax version 3.30 avril 2014 ...
  real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
  // radius, centre of the 4 circles ..
  real[int] RC=[ 0.1, 0.05, 0.05, 0.1],
            XC= [0.2,0.8,0.2,0.8],
            YC= [0.2,0.8,0.8,0.2];
  int[int]  NC=[-10,-11,-12,13]; //list number of $\pm$ segments
  // of the 4 circles borders

  border bb(t=0,1;i)
  {
  // i is the the index variable of the multi border loop
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 0; ;
  }

  border cc(t=0,2*pi;i)
 {
    x = RC[i]*cos(t)+XC[i];
    y = RC[i]*sin(t)+YC[i];
    label = i+1;
  }
  int[int] nn=[4,4,5,7];// 4 border , with 4,4,5,7 segment respectively .
  plot(bb(nn),cc(NC),wait=1);
  mesh th= buildmesh(bb(nn)+cc(NC), points=P,nbvx=100000) ;
  plot(th,wait=1,ps="o/multy-border+internal.eps"); 
  regtest = th.area;
  real eps= 0.01;
  //dumptable(cout);

  int[int] I= ClosePoints(eps,th,Q);
  //  j=I[i] is a array given number point Q_i in th_j
  cout << " Q_i -> th_j " << I << endl;
  int[int] J= ClosePoints1(eps,th,Q);
  //  j=J[i] is a array given number point th_i in Q_j
  cout << " th_i -> Q_j " << J << endl;
  // same try of
   int[int] II= ClosePoints(eps,Q');// remove point to close is a set {i/ Q[I[i]] }is without commun point at eps
   int[int] JJ= ClosePoints1(eps,Q');// remove point to close and is J[i] == J[j] => the point are to close at eps
   cout << " II=" << II << endl;
   cout << " JJ=" << JJ << endl;
   int[int] KK(II.n);
   KK=JJ(II); // Identity KK(i)==i
   II=0:II.n-1;
   KK-=KK;
   assert(KK.min==0 &&KK.max==0 );
}
{
    verbosity = 100;
     real[int,int] P(10,2);
     real[int,int] Q(11,2);
     for (int i=0; i<P.n; ++i)
       {
        P(i,0)= i;
        P(i,1)= i-1;
        Q(i,0)= P(i,0)+i*0.001;
        Q(i,1)= P(i,1)+i*0.001;
       }
       for (int i=P.n; i<Q.n; ++i)
       {
        Q(i,0)= randreal1();
        Q(i,1)= randreal1();
       }
       Q(P.n,:)=P(0,:);
       Q(P.n-2,:)=P(0,:);
     for (int i=0; i<P.n; ++i)
        cout <<" P " << i << " = " <<P(i,0) << " " << P(i,1) << endl;
        cout << endl;
    for (int i=0; i<Q.n; ++i)
        cout <<" Q " << i << " = " <<Q(i,0) << " " << Q(i,1) << endl;
     int[int][int] ij(10);
     Voisinage(P,Q,0.01,ij);
     cout << " ij: "<< endl;
     for(int i=0; i<Q.n; ++i)
       {
        cout << i << " " << ij[i].n <<" : " ;
        for(int j=0; j<ij[i].n; ++j)
         cout << ij[i][j] << " ";
        cout << endl;
       }

}
// -*- FreeFem++ -*-
// Sample of SaveHB
// Author: fujiwara@acs.i.kyoto-u.ac.jp
mesh Th = square(3,3);
macro Grad(u) [dx(u),dy(u)] // EOM

fespace Vh(Th,P1);
varf vP(u,v) = int2d(Th)(Grad(u)'*Grad(v)) + int2d(Th)(v) + on(1,u=1);

matrix A = vP(Vh,Vh);
real[int] rhs = vP(0,Vh);

load "SaveHB" 
int ret = SaveHB("sample.hb", A, rhs, "sample of SaveHB");
A.CSR; 
cout << A << endl; 
cout << " A = " << A << endl;
cout << " rhs  = " << rhs << endl;

assert(ret == 0); 

// End of file
load "ilut"
mesh Th=square(10,10);
fespace Qh(Th,P1);
fespace Vh(Th,P2);
real nu=1;
varf mp(p,q)=int2d(Th)(p*q/nu);

matrix Mp=mp(Qh,Qh);
real[int] diagMp(Qh.ndof); diagMp=Mp.diag; diagMp=1/nu*diagMp;

// We are putting this here to workaround a bug in freefem++
real[int] ilutOUT(Vh.ndof+Qh.ndof);

// Uses ILUT for the velocity part and the mass matrix for the pressure part
func real[int] ilutMp(real[int] & xx) {
	real[int] uuin(Vh.ndof);
	real[int] ppin(Qh.ndof);

	real[int] uuout(Vh.ndof);
	real[int] ppout(Qh.ndof);

	[uuin,ppin]=xx;

	for(int k=0;k<Qh.ndof;++k)  {
		ppout[k]=ppin[k]/diagMp[k];
	}
	//ppout=Mp^-1*ppin;
	uuout=applyIlutPrecond(uuin);

	ilutOUT=[uuout,ppin];
	return ilutOUT;
}
//dumptable(cout);
// Uses ILUT for the velocity and I for the pressure
func real[int] ilut(real[int] & xx) {
	ilutOUT=applyIlutPrecond(xx);
	return ilutOUT;
}

// Dummy do-nothing preconditioner
func real[int] dummy(real[int] & xx) {
	ilutOUT=xx;
	return ilutOUT;
}
// a trick to build C1 finite element with P3 lagrangre finite element
// like HSIEH-CLOUCH-TOCHER finite element 
// the idee is insure the the jump (dn(u)) on all edges 
// by penalisatison ... 
// not to bad ... 
// F. Hecht juin 2014 ..

load "Element_P3" // for P3
load "splitmesh3" // to splite each triangle in 3 traingle

int n=100,nn=n+10;
real[int] xx(nn),yy(nn);

mesh Th=square(20,20);  // mesh definition of $\Omega$
//Th=splitmesh3(Th);
fespace Vh(Th,P3);      // finite element space

macro bilaplacien(u,v) ( dxx(u)*dxx(v)+dyy(u)*dyy(v)+2.*dxy(u)*dxy(v)) // fin macro 
real f=1;
Vh [u],[v];
real pena = 1e6;
macro dn(u) (dx(u)*N.x+dy(u)*N.y)//
solve bilap([u],[v]) =
    int2d(Th)(  bilaplacien(u,v) ) 
  + intalledges(Th) ( jump(dn(u))*jump(dn(v))*pena) 
   - int2d(Th)(f*v)
   
   + on(1,2,3,4,u=0) 
; 
   
plot(u,cmm="u", wait=1,fill=1);
real umax = u[].max; 
int err =  (abs(umax-0.0012782) > 1e-4); 
cout << " uu max " << umax << " ~  0.0012782  , err = " << err 
     << " " << abs(umax-0.0012782) <<endl; 


for (int i=0;i<=n;i++)
 {
   xx[i]=real(i)/n;
   yy[i]=u(0.5,real(i)/n); // value of uh at point (0.5, i/10.) 
 }
 plot([xx(0:n),yy(0:n)],wait=1);
 assert(err==0); 
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.
cout << "--------- file : load.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "load.edp";
	real TESTload=uh[].max;
		cout<<"load reference value = "<<REFload
				<<" test value ="<<TESTload<<endl;
			assert(TESTload<REFload*(1+0.0001));
				assert(TESTload>REFload*(1-0.0001));
};

cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};

cout << "--------- file : testFEMorley.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFEMorley.edp";
	
};

cout << "--------- file : funcTemplate.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "funcTemplate.edp";
	
};

cout << "--------- file : LapDG3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LapDG3.edp";
	
};

cout << "--------- file : LapDG4.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LapDG4.edp";
	
};

cout << "--------- file : LaplaceP3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP3.edp";
	
};

cout << "--------- file : LaplaceP4.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP4.edp";
	
};

cout << "--------- file : bilapMorley.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "bilapMorley.edp";
	
};

cout << "--------- file : plot-fb-P3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P3.edp";
	
};

cout << "--------- file : plot-fb-P3dc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P3dc.edp";
	
};

cout << "--------- file : plot-fb-P4.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P4.edp";
	
};

cout << "--------- file : plot-fb-P4dc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P4dc.edp";
	
};

cout << "--------- file : splitmesh3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "splitmesh3.edp";
	
};

cout << "--------- file : splitmesh6.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "splitmesh6.edp";
	
};

cout << "--------- file : testFE-PkEdge.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE-PkEdge.edp";
	
};

cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};

cout << "--------- file : testFEMorley.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFEMorley.edp";
	
};



load "Element_P3dc"
load "Element_P3"


//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
macro dn(u) (N.x*dx(u)+N.y*dy(u) ) //  def the normal derivative 

mesh Th = square(3,3); // unite square 
fespace Vh(Th,P3dc);     // Discontinous P2 finite element
fespace Xh(Th,P3);
//  if param = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=1000; // a paramater to add penalisation 
varf Ans(u,v)= 
   int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)  ) // Ok P4 
 + intalledges(Th,qforder=7)(//  loop on all  edge of all triangle 
         // the edge are see nTonEdge times so we / nTonEdge
         // remark: nTonEdge =1 on border edge and =2 on internal 
         // we are in a triange th normal is the exterior normal
         // def: jump = external - internal value,     on border extern - internal value
         //      average = (external + internal value)/2, on border just internal value
             ( jump(v)*average(dn(u)) -  jump(u)*average(dn(v)) 
          + pena*jump(u)*jump(v) ) / nTonEdge 
)
;
func f=1;
func g=0;
Vh u,v;
Xh uu,vv;
problem A(u,v,solver="SPARSESOLVER") = Ans 
- int2d(Th)(f*v) 
- int1d(Th)(g*dn(v)  + pena*g*v) 
;
problem A1(uu,vv,solver=CG) 
= 
 int2d(Th)(dx(uu)*dx(vv)+dy(uu)*dy(vv)) - int2d(Th)(f*vv) + on(1,2,3,4,uu=g);
 
 A; // solve  DG
 A1; // solve continuous

plot(u,uu,cmm="P3 Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
//  example of using the Schur Complement. 
// solve a Poisson problme on on symmetric domain with un hole
// with constant Dichilet Boundary condition par  hole. 
// but we only  just using half domain left Domain to buil matrix.

// for ShurComplement  full matrix 
load "lapack"
// for ShurComplement  sparse matrix 
load "Schur-Complement"

include "ExtractDofsonBorder.idp"
// for  to find dof with  Dirichet Boundary on l lablel 
macro FindDofOnBorder(l,Vh,I)
{
	varf von(u,v) = on(l,u=-1);
    int[int] J=0:Vh.ndof-1;
	real[int] vl = von(0,Vh); 
	sort(vl,J);
	vl = vl ? 1. :0.;
	int n = vl.sum+0.5; 

	I.resize(n);
	I=J(0:n-1);
	if(verbosity) cout << " FindDofOnBorder:n = "<< n << endl; 
}//

if (HaveUMFPACK) //  need UMPACK  computation 
{
macro grad(u) [dx(u),dy(u)] //

real hsize= 0.1; 
real htt = max(hsize/2,0.1);
mesh Th=square(2/hsize,1/hsize,[x*2,y]);

Th=trunc(Th,(abs(x-1)>4*htt)||(abs(y-0.5)>htt),label=10);

mesh Th2=movemesh(Th,[2-(x-2),y]);
plot(Th,Th2,wait=1);
fespace Vh(Th,P1);
fespace Vh2(Th2,P1);
int n = Vh.ndof;
varf va(u,v) = int2d(Th)(grad(u)'*grad(v))+on(1,3,4,u=0);

 matrix A= va(Vh,Vh,sym=0,tgv=-2);
if(verbosity>9) cout << A << endl; 
int[int] I; 
ExtractDofsonBorder(2,Vh,I,1);

real[int,int] B(1,1);

//  model 2 
int[int] I10;//list of  DoD  on label 10. (the hole) 
FindDofOnBorder(10,Vh,I10);
if(verbosity>9) cout << " I10 "<< I10 << endl; 
int[int] If(n);
int In=I.n; 
If=-1;
for [i,Ii:I]
  If[Ii]=i; 
for [i,I10i:I10]
    If[I10i]=In; 
if( verbosity>9) cout << If << endl; 	
real[int,int] S(1,1);

int nfs=SchurComplement(S,A,If,B);

cout << nfs << " "<< In+1  << endl;
if( verbosity>9)  cout << " S = "<<" " << S << endl;  
/*
In S  the dof are from 0 to  In-1 : right side 
  number is    In =  Boundary condition on hole
  PB build by symetry  so   solve  S(Il,Il)+S(Ir,Ir) 
*/
// compute the renumbing of left au right part Il,Ir
// here the the DoF on hole will be differente on left   and  right  part. 
int iclr=nfs; // DOF of B.C on  left part 
int icll=nfs-1;// DOF of B.C on  right part 
int iclS = nfs-1;
int[int] Il=0:nfs;
int[int] Ir=0:nfs;

Ir[iclr]=iclS;
Ir[icll]=-1;

Il[iclr]=-1;
Il[icll]=iclS;
 
int nd = nfs+1;//   Number of Dof on full problem
// need v4.3.2-177-g84744c98
// missing in previoux version : FH: 31th july 2018 
/*  version with sparse matrice
matrix St(nd,nd);
cout << " S ="<< S << endl;
St+=S(Ir,Ir);//  right matrix
St+=S(Il,Il);//  left  matrix
*/
// version with full matrix (need version after  4.4)
real[int,int] St(nd,nd);
St=0.;
Add(St,S,Ir);
Add(St,S,Il);
cout << " St=" <<  St << endl; 
cout << "ic  = "<< icll <<" " << iclr << endl; 
int[int] It=[icll,iclr];
real[int,int] SS(1,1), B0(1,1);
int nfs0=SchurComplement(SS,St,It,B0);

cout << "B0=" << B0 << endl; 
// plot the solution on the 2  meshes. 
for(int j=0; j<B0.m; ++j)
{	
	Vh ul=0;
	Vh2 ur = 0; 
	//  vertical Dof  left aund right part
	for(int i=0; i<nfs-1; ++i)
  	 ur[] +=  B(:,i)*B0(i,j);
	for(int i=0; i<nfs-1; ++i)
 	 ul[] +=  B(:,i)*B0(i,j);
	//  for DoF on Holes (left and right).   
	{
	  ur[] +=  B(:,nfs-1)*B0(nfs-1,j);
	  ul[] +=  B(:,nfs-1)*B0(nfs,j);
	 }   
	plot(ul,ur, wait=1);
}
}
load "MetricPk"

int kDeg=4;
int nIter=5;
mesh Th=square(20,20,[2*x-1,2*y-1]);
real c=5;
func f = x^2*y + y^3 + tanh(c*(-2*x + sin(5*y)));
real ratio = 1.3;
//real massRef=40*Th.nt; //40 : constante pour passer de la masse au nb de triangles (?).
real massRef=Th.nt/2; //The number of triangles is approx twice the mass

fespace Metric(Th,[P1,P1,P1]);
Metric [m11,m12,m22];
for(int i=0; i<nIter; i++){
	plot(Th,wait=true);
	[m11,m12,m22]=[0,0,0];
	m11[]=MetricPk(Th,f,kDeg=kDeg,rDeg=1,mass=massRef,MetricType=1,TriangulationType=1);
	Th = adaptmesh(Th,m11,m12,m22,IsMetric=true);
	massRef=massRef*ratio;
}
plot(Th,wait=true,ps="o/lastMesh.ps");
//load "Element_P3dc"
mesh Th=square(10,10);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P1);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=min(vi[].n,20);i<min(vi[].n,50);++i)
 {
   vi[][i]=1;
   Wh w=vi;
    plot(w,wait=1,cmm=" v"+i,dim=3);	
    //    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "Curvature"
load "isoline"
cout << " tersca " << Tresca(1,2,3,0,0,0) << endl;; 
real R= 1;
real meshsize= 0.1;
border DC(t=pi/2,-pi/2) { x=R*cos(t); y=R*sin(t); label=1;}
border axe(t=R,-R) {x=0; y=t; label=2;}

mesh Th=buildmesh(DC(-R*pi/meshsize)+axe(2*R/meshsize));

fespace Vh(Th,P1); 
Vh ca,c,cc,ccc;;
c[]=curvature(Th,1);
real cmean= int1d(Th,1,qforder=1)(c)/int1d(Th,1,qforder=1)(1.);
cout<< " cmean = " << cmean << " == " << 1/R << endl;
plot(c, wait=1,cmm=" curvature" ); 
verbosity=1000;
ca[]=raxicurvature(Th,1);
verbosity=1;
plot(ca, wait=1,cmm="axi curvature" );
real s=int1d(Th,1,qforder=1)(x*2*pi); 
cout << " s = " << s << " " << 4*pi*R*R << endl; 
real cmeana= int1d(Th,1,qforder=1)(2*pi*ca)/s;
solve AAA(cc,ccc)= int2d(Th)(cc*ccc*1e-10)+ int1d(Th,1)(x*cc*ccc)- int1d(Th,1)(ca*ccc);
//cc = ca/max(x,0.01);
plot(cc,wait=1); 
cout<< " cmeana = " << cmeana << " == " << 2/R << endl;
assert(abs(cmean-1/R)< 0.05/R); 

int[int] ll=[1,2];
real[int,int] b12(1,3); 
real l12=extractborder(Th,ll,b12);
cout << " size b12 = " << b12.n << " x " << b12.m << endl;
border BB(t=0,1){ P=Curve(b12,t);label=3;}
plot(BB(100),wait=1);
load "qf11to25"
load "Element_QF"
{
mesh Th=square(5,5,flags=2);
//Th=trunc(Th, x <0.5);
plot(Th,wait=1);
mesh Thf=square(10,10);
fespace QFh(Th,FEQF5);
fespace Ph(Thf,P0);
func ff = (x+1)^2*(y-2)^3;
QFh ffh=ff;
Ph ffp=ffh;
plot(ffp,wait=1,fill=1); 
QFh xh=x;
QFh yh=y;
if(verbosity>9)
{
cout << " xh = " << xh[] << endl;
cout << " yh = " << yh[] << endl;
}
cout << int2d(Th)(x) << " ==  " << int2d(Th)(xh) << endl; 
cout << int2d(Th)(y) << " == " << int2d(Th)(yh) << endl; 
cout << int2d(Th)(ff) << " == " << int2d(Th)(ffh) << endl; 
//dumptable(cout);
FiniteElement2d EFQF(qf23pT);
fespace Zh(Th,EFQF);
Zh zz=x+y;
plot(zz,fill=1,wait=1,cmm="zz");
}
{
mesh3 Th=cube(2,2,2);
//Th=trunc(Th, x <0.5);
plot(Th,wait=1);
mesh3 Thf=cube(10,10,10);
fespace QFh(Th,FEQF53d);
fespace Ph(Thf,P0);
func ff = (x+1)^2*(y-2)^3*(z+2)^1.5;
QFh ffh=ff;
Ph ffp=ffh;
plot(ffp,wait=1,fill=1); 
QFh xh=x;
QFh yh=y;
QFh zh=z;
if(verbosity>9)
{
cout << " xh = " << xh[] << endl;
cout << " yh = " << yh[] << endl;
cout << " yh = " << yh[] << endl;
}
cout << int3d(Th)(x) << " ==  " << int3d(Th)(xh) << endl; 
cout << int3d(Th)(y) << " == " << int3d(Th)(yh) << endl; 
cout << int3d(Th)(z) << " == " << int3d(Th)(zh) << endl; 
cout << int3d(Th)(ff) << " == " << int3d(Th)(ffh) << endl; 
FiniteElement3d EFQF3(qfVp14);
fespace Zh(Th,EFQF3);
fespace Zh2(Th,[EFQF3,EFQF3]);

}
;

load "Element_P3"
load "qf11to25"
 real umax = 0.0562131; // P2 
verbosity=2;
int[int] l1=[1,1,1,1,1,1];
mesh3 Th=cube(10,10,10, label=l1);
fespace Vh(Th,P3);

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM


problem Lap3d(u,v,solver=CG)  =
  int3d(Th,qfV=qfVp6)(Grad3(v)' *Grad3(u)) //') for emacs  
  - int3d(Th,qfV=qfVp6)(1.*v) 
  + on(1,u=0);
 
  
 
Lap3d;

cout << " u max= " << u[].max << " // " << umax << endl; 
plot(u,wait=1); 
real err= abs(u[].max-umax);
assert( err < 1e-2);

// file adaptsphere.edp
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

meshS Th3=movemesh23(Th,transfo=[f1min,f2min,f3min],orientation=-1);

real[int] domain = [0.,0.,0.,145,0.01];
mesh3 Th3sph=tetg(Th3,switch="paAAQYY",nbofregions=1,regionlist=domain);

int[int] newlabel = [145,18];
real[int] domainrefine = [0.,0.,0.,145,0.0001];

mesh3 Th3sphrefine=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel,nbofregions=1,regionlist=domainrefine,sizeofvolume=0.0001);

int[int] newlabel2 = [145,53];
func fsize = 0.01/(( 1 + 5*sqrt( (x-0.5)^2+(y-0.5)^2+(z-0.5)^2) )^3);
mesh3 Th3sphrefine2=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel2,sizeofvolume=fsize);

medit("sphere",Th3sph);
medit("sphererefinedomain",Th3sphrefine);
medit("sphererefinelocal",Th3sphrefine2);

load "Element_P3dc"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P3dc);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    if(!NoGraphicWindow && 0 )
      {
      load "medit"
      meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
      medit("mm",Th3); 
 
//      savemesh(th,"mm",[x,y,vi*0.5]);   //save *.points and *.faces file for medit
//      exec("ffmedit mm");
//      exec(" rm mm.faces mm.points");
      }	
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
mesh Th=square(3,3);

mesh3 Th3=buildlayers(Th,3);
savemesh(Th3,"lll.mesh");
load "iovtk"
mesh3 Th = cube(1,1,1,region=11);
fespace Vh(Th,P1);
Vh g=x+y*y+z*z*z;
int[int] fforder2=[1,1];
savevtk("bidule.vtk",Th,g,[g,g,g],/*order=fforder2,*/dataname=" b c",bin=1);


{ // restore mesh and data ???
real[int][int] data;	

mesh3 Th=vtkload3("bidule.vtk",fields=data);//  work only with order =1 and vgk file
cout << " " << data.n << " == 2 "<< endl;
}
// Mesh
load "Element_P3"
load "Element_P2pnc_3d"
int[int] lc=[1,1,1,1,1,2];
mesh3 Th=cube(5,5,5,label=lc);
func Pu = P2pnc3d;
func Pm = P1dc; 
fespace VVh(Th,[Pu,Pu,Pu,Pm]);
fespace Vh(Th,P23d);

VVh [u1,u2,u3,p];
VVh [v1,v2,v3,q];

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

solve vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) //)';
		       - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,u1=1,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ;
plot(p,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
plot([u1,u2,u3] ,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
macro dn(u) (N.x*dx(u)+N.y*dy(u) ) //  def the normal derivative 

mesh Th = square(10,10); // unite square 
fespace Vh(Th,P2dc);     // Discontinous P2 finite element
fespace Xh(Th,P2);
//  if param = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=0; // a paramater to add penalisation 
varf Ans(u,v)= 
   int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)  )
 + intalledges(Th)(//  loop on all  edge of all triangle 
         // the edge are see nTonEdge times so we / nTonEdge
         // remark: nTonEdge =1 on border edge and =2 on internal 
         // we are in a triange th normal is the exterior normal
         // def: jump = external - internal value,     on border extern - internal value
         //      average = (external + internal value)/2, on border just internal value
            ( jump(v)*average(dn(u)) -  jump(u)*average(dn(v)) 
          + pena*jump(u)*jump(v) ) / nTonEdge 
)
;
func f=1;
func g=0;
Vh u,v;
Xh uu,vv;
problem A(u,v,solver="SPARSESOLVER") = Ans 
- int2d(Th)(f*v) 
- int1d(Th)(g*dn(v)  + pena*g*v) 
;
problem A1(uu,vv,solver=CG) 
= 
 int2d(Th)(dx(uu)*dx(vv)+dy(uu)*dy(vv)) - int2d(Th)(f*vv) + on(1,2,3,4,uu=g);
 
 A; // solve  DG
 A1; // solve continuous

plot(u,uu,cmm="Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
load "MatrixMarket" 
// small interf	ce to read en small matrix in matrixmarket format 
//and add a binary  version (no ckeck of the endianness to day )
mesh Th=square(1,1);
fespace Vh(Th,P1); 
varf va(u,v)= int2d(Th)(u*v)+on(1,u=0);
string dir="/tmp/";
if (onWIN32) dir="";
{
matrix<complex> A = va(Vh,Vh);
savemtx(dir+"a.mtx",A);
savemtx(dir+"a.mtxb",A,1);

matrix<complex> AA , AB ;

{
readmtx(dir+"a.mtx",AA);
AA.COO;
cout << "A " << A << endl; 
cout << "AA " << AA << endl; 
AA = AA - A;
AA.COO;
cout <<" diff AA -A "<<  AA << endl;
cout << " diff AA"<< AA.linfty << endl;
assert(AA.linfty < 1e-10);
}
readmtx(dir+"a.mtxb",AB,1);

AB = AB - A;
cout << " AB"<< AB.linfty << endl;
assert(AB.linfty < 1e-10);

}

{
matrix<real> A = va(Vh,Vh);
savemtx(dir+"a.mtx",A); //  formatted  form A
savemtx(dir+"a.mtxb",A,1);//  binary  form 

matrix<real> AA , AB ;

{
readmtx(dir+"a.mtx",AA);
AA.COO;
cout << "A " << A << endl; 
cout << "AA " << AA << endl; 
AA = AA - A;
AA.COO;
cout <<" diff AA -A "<<  AA << endl;
cout << " diff AA"<< AA.linfty << endl;
assert(AA.linfty < 1e-10);
}

readmtx(dir+"a.mtxb",AB);

AB = AB - A;
cout << " AB"<< AB.linfty << endl;
assert(AB.linfty < 1e-10);

}
load "mat_edgeP1"
load "Element_PkEdge"
load "Element_Mixte3d"
int err=0;
{ mesh Th=square(3,3);
	fespace Eh(Th,P0edge);
matrix A;
MatrixEdgeP1(A,Th);
cout << "2d " << A.nnz << " " << 2*Eh.ndof << endl;
err+=  A.nnz != 2*Eh.ndof;
if(verbosity>4)
cout << A << endl;
}
{ mesh3 Th=cube(10,10,10);
 fespace Eh(Th,Edge03d );
matrix A;
verbosity=5;
MatrixEdgeP1(A,Th);
if(verbosity>5)
cout << A << endl;
cout << " 3d:: " << A.nnz << " " << 2*Eh.ndof << endl;
cout << " 3d:: " << A.n << " " << Eh.ndof << endl;
err+=  A.nnz != 2*Eh.ndof;
err += A.n != Eh.ndof;

}
assert(err==0);
load "ff-cmaes"

int NP=10;			//Control the mesh quality
func ud=100; 		//Desired temperature in the target zone
real L=2,l=1.5,R=0.075;//L:oven length, l:oven height, R: resistors radius
real eps=1e-2,hugeval=1.e30;		//a small value governing collisions and a huge one for something else
int nbres=6;		//number of resistors (should not be changed) 
int NPres=NP*(2*pi*R);
real[int] pr(nbres+2), K(nbres+2); 
int regi=nbres, rege=nbres+1, lext=1;
K=1;	K[regi]=10;

macro Grad(u) [dx(u),dy(u)]//EOM
macro Resistor(i,cx,cy,lab)
border Res#i(t=0.,2*pi) {x=cx+R*cos(t); y=cy+R*sin(t); label=lab;}//EOM
real pena = 100;
func target = 100.;

real[int] Xmin(3*nbres),Xmax(3*nbres);
for(int i=0;i<nbres;++i)
{
	Xmin[3*i] = -hugeval;
	Xmax[3*i] = hugeval;
	Xmin[3*i+1] = (i%3)*(L/3) +  R+eps/2;
	Xmax[3*i+1] = (i%3 + 1)*(L/3) - (R+eps/2);
	Xmin[3*i+2] = R+eps + (i>2 ? 2*l/3 : 0);
	Xmax[3*i+2] = (i>2 ? l : l/3) - (R+eps);
}
cout << "Xmin: " << Xmin << endl << "Xmax: " << Xmax << endl;

int iter=0;
func real J(real[int] &X)
{
	verbosity=0;
	real[int] XX=X,diff=X;
	for(int i=0;i<X.n;++i)
	{
		XX[i] = X[i]>Xmin[i] ? X[i] : Xmin[i];
		XX[i] = XX[i]<Xmax[i] ? XX[i] : Xmax[i];
	}
	diff -= XX;
	real corr = diff.l2;
	//cout << X << endl << XX << endl << "==>" << corr << endl;
	
	border b1(t=0,1){x=L*t; y=0; label=0;}
	border b2(t=0,1){x=L;   y=l*t; label=0;}
	border b3(t=0,1){x=L*(1-t); y=l; label=0;}
	border b4(t=0,1){x=0;   y=l*(1-t); label=0;}
	Resistor(1,XX[1] ,XX[2] ,1);
	Resistor(2,XX[4] ,XX[5] ,1);
	Resistor(3,XX[7] ,XX[8] ,1);
	Resistor(4,XX[10],XX[11],1);
	Resistor(5,XX[13],XX[14],1);
	Resistor(6,XX[16],XX[17],1);
	border bi1(t=0,2){x=(0.5+t)*L/3; y=l/3; label=1;}
	border bi2(t=0,1){x=5*L/6; y=(1+t)*l/3; label=1;}
	border bi3(t=0,2){x=(2.5-t)*L/3; y=2*l/3; label=1;}
	border bi4(t=0,1){x=L/6; y=(2-t)*l/3; label=1;}
	mesh Th = buildmesh(
		 bi1(2*NP*L/3)+bi2(NP*l/3)+bi3(2*NP*L/3)+bi4(NP*l/3)
		+ Res1(NPres)+Res2(NPres)+Res3(NPres)+Res4(NPres)+Res5(NPres)+Res6(NPres)
		+ b1(NP*L)+b2(NP*l)+b3(NP*L)+b4(NP*l));
	//plot(Th,wait=1);
	
	fespace Vh(Th,P1);
	Vh u,v,reg=region;
	real[int] K(reg[].max+1),pr(reg[].max+1);
	K=1;
	K[Th(L/2,l/2).region] = 10;
	pr=0;
	for(int i=0;i<nbres;++i) pr(Th(XX[3*i+1],XX[3*i+2]).region) = XX[3*i];
	//plot(reg,value=1,fill=1,wait=1);
	
	solve Chaleur(u,v) = int2d(Th)( (dx(u)*dx(v) + dy(u)*dy(v)) * K[region]) + int1d(Th,0)(u*v) - int2d(Th)(pr[region]*v) ;
	if(iter %200 == 199)
	plot(u,fill=1,nbiso=50,wait=0,dim=2);
	real meanu = int2d(Th,Th(L/2,l/2).region)(u)/int2d(Th,Th(L/2,l/2).region)(1.);
	real res = int2d(Th,Th(L/2,l/2).region)(square(u-target));
	cout << "J: iter " << iter++ << "  -  mean=" << meanu << "  -  corr=" << corr << "  -  res=" << res << " ==> " << res+pena*corr << endl;
	cout << "pos : ";
	for(int j=0;j<X.n;++j) cout << " " << X[j];
	cout << endl;
	return res + pena*corr;
}

real[int] grad(3*nbres);
bool plotgrad=1;
func real[int] dJ(real[int] &X)
{
	verbosity=0;
	real[int] XX=X,diff=X;
	for(int i=0;i<X.n;++i)
	{
		XX[i] = X[i]>Xmin[i] ? X[i] : Xmin[i];
		XX[i] = XX[i]<Xmax[i] ? XX[i] : Xmax[i];
	}
	diff -= XX;
	real corr = diff.l2;
	//cout << X << endl << XX << endl << "==>" << corr << endl;
	
	border b1(t=0,1){x=L*t; y=0; label=7;}
	border b2(t=0,1){x=L;   y=l*t; label=7;}
	border b3(t=0,1){x=L*(1-t); y=l; label=7;}
	border b4(t=0,1){x=0;   y=l*(1-t); label=7;}
	Resistor(1,XX[1] ,XX[2] ,0);
	Resistor(2,XX[4] ,XX[5] ,1);
	Resistor(3,XX[7] ,XX[8] ,2);
	Resistor(4,XX[10],XX[11],3);
	Resistor(5,XX[13],XX[14],4);
	Resistor(6,XX[16],XX[17],5);
	border bi1(t=0,2){x=(0.5+t)*L/3; y=l/3; label=6;}
	border bi2(t=0,1){x=5*L/6; y=(1+t)*l/3; label=6;}
	border bi3(t=0,2){x=(2.5-t)*L/3; y=2*l/3; label=6;}
	border bi4(t=0,1){x=L/6; y=(2-t)*l/3; label=6;}
	mesh Th = buildmesh(
		 bi1(2*NP*L/3)+bi2(NP*l/3)+bi3(2*NP*L/3)+bi4(NP*l/3)
		+ Res1(NPres)+Res2(NPres)+Res3(NPres)+Res4(NPres)+Res5(NPres)+Res6(NPres)
		+ b1(NP*L)+b2(NP*l)+b3(NP*L)+b4(NP*l));
	//plot(Th,wait=1);
	
	fespace Vh(Th,P1);
	Vh reg=region;
	real[int] K(reg[].max+1),pr(reg[].max+1);
	K=1;
	K[Th(L/2,l/2).region] = 10;
	pr=0;
	for(int i=0;i<nbres;++i) pr(Th(XX[3*i+1],XX[3*i+2]).region) = XX[3*i];
	//plot(reg,value=1,fill=1,wait=1);
	Vh u,v;
	solve Chaleur(u,v) = int2d(Th)( (dx(u)*dx(v) + dy(u)*dy(v)) * K[region]) + int1d(Th,7)(u*v) - int2d(Th)(pr[region]*v) ;
	int regt = Th(L/2,l/2).region;
	for(int i=0;i<nbres;++i)
	{
		Vh up,ux,uy;
		int thereg = Th(XX[3*i+1],XX[3*i+2]).region;
		//cout << "pr:" << pr[thereg] << endl;
		solve dpchaleur(up,v) = int2d(Th)( (dx(up)*dx(v) + dy(up)*dy(v)) * K[region]) + int1d(Th,7)(up*v) - int2d(Th,thereg)(v);
		grad[3*i] = int2d(Th,regt)(2*up*(u-target)) + 2*pena*diff[3*i];
		solve dxchaleur(ux,v) = int2d(Th)( (dx(ux)*dx(v) + dy(ux)*dy(v)) * K[region]) + int1d(Th,7)(ux*v) - int1d(Th,i)(pr[thereg]*v*N.x);
		grad[3*i+1] = int2d(Th,regt)(2*ux*(u-target)) + 2*pena*diff[3*i+1];
		solve dychaleur(uy,v) = int2d(Th)( (dx(uy)*dx(v) + dy(uy)*dy(v)) * K[region]) + int1d(Th,7)(uy*v) - int1d(Th,i)(pr[thereg]*v*N.y);
		grad[3*i+2] = int2d(Th,regt)(2*uy*(u-target)) + 2*pena*diff[3*i+2];
		if(plotgrad)
		{
			plot(up,nbiso=50,wait=0,cmm="Derivative w.r.t. pr["+i+"]");
			plot(ux,nbiso=50,wait=0,cmm="Derivative w.r.t. x["+i+"]");
			plot(uy,nbiso=50,wait=0,cmm="Derivative w.r.t. y["+i+"]");
		}
	}
	cout << "dJ : " << grad << endl;
	return grad;
}


real pst=5000;
real isdxy=3*L/24.;
real[int] isd  =[1000,isdxy,isdxy,1000,isdxy,isdxy,1000,isdxy,isdxy,1000,isdxy,5*l/6,1000,isdxy,isdxy,1000,isdxy,isdxy];
real[int] start=[pst,L/6,l/6,pst,L/2,l/6,pst,5*L/6,l/6,pst,L/6,5*l/6,pst,L/2,5*l/6,pst,5*L/6,5*l/6];

//dJ(start);
cout << cmaes(J,start,initialStdDevs=isd,stopTolFun=1e-1,stopMaxIter=200,stopMaxFunEval=1000);
//BFGS(J,dJ,start,nbiterline=10,nbiter=3000,eps=1.e-8);
iter = 1000;

// FFCS - regression test reference value
real regtest=J(start);
load "tetgen" 
int nn=100; 
real[int] xx(nn),yy(nn),zz(nn);

for(int i=0; i<nn; ++i)
{
  xx[i] = randreal1();
  yy[i] = randreal1();
  zz[i] = randreal1();
}
mesh3 Th=tetgconvexhull(xx,yy,zz,region=1,label=3);
plot(Th);
load "metis"
mesh Th=square(30,30);
meshS ThS=square3(30,30);
fespace Ph(Th,P0);
fespace Vh(Th,P0edge);
int[int] nupart(Th.nt);
Ph  part;
Vh  p1;
metisdual(p1,10); // new interface .. 
plot(p1,wait=1,fill=1);
metisnodal(p1,10); // new interface .. 
plot(p1,wait=1,fill=1);
metisnodal(nupart,Th,30);

for(int i=0;i<nupart.n;++i)
  part[][i]=nupart[i];
plot(part,fill=1,cmm="nodal",wait=1);

metisdual(nupart,Th,30);
for(int i=0;i<nupart.n;++i)
  part[][i]=nupart[i];
plot(part,fill=1,cmm="dual",wait=1);
bool fast=true;
load "mat_dervieux";  // external module in C++ must be loaded
border a(t=0, 2*pi){ x = cos(t); y = sin(t);  }
mesh th = buildmesh(a(100));
fespace Vh(th,P1);

Vh vh,vold,u1 = y, u2 = -x;
Vh v = exp(-10*((x-0.3)^2 +(y-0.3)^2)), vWall=0, rhs =0;

real dt = 0.025;
// qf1pTlump means mass lumping is used
problem  FVM(v,vh) = int2d(th,qft=qf1pTlump)(v*vh/dt)
                  - int2d(th,qft=qf1pTlump)(vold*vh/dt)
      + int1d(th,a)(((u1*N.x+u2*N.y)<0)*(u1*N.x+u2*N.y)*vWall*vh)
+ rhs[] ;


matrix A;
MatUpWind1(A,th,vold,[u1,u2]);
if(fast)
  {
    varf  vFVM(v,vh) = int2d(th,qft=qf1pTlump)(v*vh/dt)
      - int1d(th,a)(((u1*N.x+u2*N.y)<0)*(u1*N.x+u2*N.y)*vWall*vh)      ;
    real[int] rhs0=vFVM(0,Vh);
    matrix M=vFVM(Vh,Vh,solver=CG);
    A=-A+M;

    for ( real t=0; t< pi ; t+=dt)
      {
	vold=v;
        rhs[]=rhs0;
	rhs[] += A * vold[] ;
	v[]= M^-1*rhs[];
	plot(v,wait=0);
      }
  }
else
for ( real t=0; t< pi ; t+=dt){
  vold=v;
  rhs[] = A * vold[] ;
  FVM;
  plot(v,wait=0);
};
load "distance"
mesh Th;
Th=square(100,100);
if(1)
{
	mesh Th2;
	mesh3 Th3;
	int ltube=1,lup=3,lout=4,lin =2;
	int l3d = 5;
	real D3d=1; 
	{
	int Nbtube= 4; 
    
	real Dx=1,Dy=1,La=3*Dx,Lh=5*Dy;

	int Ndx=19,Ndy=19, Nh=(Lh-Dy)*Ndy/Dy,Na=(La-Dx)*Ndx/Dx ;     

	mesh Th0;
	{
	    int[int] ll0=[1,0,0,1];
	    int[int] llv=[0,1,2,1];
	    int[int] llvv=[0,1,4,1];
	    int[int] llh=[1,3,1,0];
	 Th0 = square(Ndx,Ndy,[x*Dx,y*Dy],label=ll0); 
	mesh Thv = square(Ndx,Nh,[x*Dx,Dy+y*(Lh-Dy)],label=llv); 
	mesh Thvv = square(Ndx,Ndy,[x*Dx,Lh+y*(Dy)],label=llvv); 
	mesh Thh = square(Na,Ndy,[Dx+x*(La-Dx),y*Dy],label=llh); 

	Th=Th0+Thv+Thh;
	Th0=Th;
	Th=Th+Thvv;
	plot(Th,wait=1);
	}

	for(int i=1; i< Nbtube; ++i)
	   Th=Th + movemesh(Th0,[x+La*i,y]);
	   int[int] llabel=[1,ltube,2,lup,3,lout,4,lin] ;
	 Th=change(Th,label=llabel,rmInternalEdges=1);  
	}
	plot(Th,wait=1);
}
fespace Vh(Th,P1);
Vh u = y-0.500; 
u = 0.400-max(abs(x-y),abs(-1.+x+y));
plot(u, dim=3, value=1); 
Vh v=u;
//verbosity=100; 
//cout << v[] << endl; 

distance(Th,u,v[],distmax=100);

real[int] v0 = [-10,-1,-0.01,0,0.01,1,10];
plot(u,wait=1,viso=v0);
plot(v,wait=1,cmm="distance",nbiso=100);
/*

Boggus exemples => No time to correct

See J-M Mirebeau FH 2017 ..

a first correction

--- a/examples/plugin/GeometryQA.cpp    Fri Dec 01 16:53:54 2017 +0100
+++ b/examples/plugin/GeometryQA.cpp    Wed Dec 06 10:05:54 2017 +0100
@@ -376,6 +376,7 @@
     Edge **minEdge= new Edge *[nv_iso]();
     Edge **maxEdge= new Edge *[nv_iso]();
     R2   *eigenVec= new R2[nv_iso];
+    cout << " nv = " << nv() << endl;
     for(int i=0; i<nv_iso; i++) eigenVec[i]=vertices[i].getm().eigensys();

     for(int i=0; i<ne_iso; i++){
@@ -400,10 +401,11 @@
     for(int i=0; i<ne_iso; i++){
         Edge *e=&edges[i];
         if(!e->isRepresentative()) continue;
-
+        cout << " nv = " << nv() << " " << ne_oriented() << endl;
+
         const int indexu = vertices.index(e->getu()), indexv = vertices.index(e->getv());
-        bool extru= (e==minEdge[indexu]) || (e==maxEdge[indexu]);
-        bool extrv= (e==minEdge[indexv]) || (e==maxEdge[indexv]);
+        bool extru= indexu<nv_iso && ( (e==minEdge[indexu]) || (e==maxEdge[indexu]));
+        bool extrv= indexv<nv_iso && ( (e==minEdge[indexv]) || (e==maxEdge[indexv]));

         if(!extru && !extrv) continue;
         Edge *const f=e->hRefine2(h, edges, vertices, metric, NULL); //non recursive split.

but after ...

		CheckPtr:  erreur delete []
		CheckPtr:  erreur delete []
Triangulation::hRefineQA : Intermediate anisotropic triangulation contains 540 triangles.
Triangulation::hRefineQA : Final triangulation contains 547 triangles after refinement of the boundary.
Exporting edges
  current line = 14
Assertion fail : (area>0)
	line :281, in file ./../femlib/fem.hpp
Assertion fail : (area>0)
	line :281, in file ./../femlib/fem.hpp
 err code 5 ,  mpirank 0
Process 26872 exited with status = 5 (0x00000005)
*/
load "FreeFemQA"


mesh Th=square(1,1,[x,y]);

func scal = 1/(x+0.2)^2;

//func scal = 5;

func mxx=100*scal;
func mxy=0;
func myy=scal;

Th=adaptmesh(Th,4*scal,0,4*scal,IsMetric=true);
Th=MeshGenQA(Th,mxx,mxy,myy,exportToMathematica=true,exportMetricToMathematica=true,finalRefine=false);
plot(Th,wait=true,ps="o/IsoFFMesh.ps");

//Th=readmesh("triQA.msh");
plot(Th,ps="o/QAMesh.ps");


//mesh Th=readmesh("/Users/jean-mariemirebeau/Library/Developer/Xcode/DerivedData/DelaunayFlip-deaxqdiomhuvirblsdlxiubujmam/Build/Products/Debug/Th.msh");
//plot(Th);

//Le sens Geometry->FF a l'air de marcher.
//Maintenant, il faut le sens inverse.

//mesh Th=square(1,1,[x,y]);
//savemesh(Th,"ThFF.msh");


;
load "bfstream"

real[int] b(10), bb(1);
for (int i = 0; i < b.n; ++i)
	b[i] = i+pi;
cout << " " << b << endl;
int kk=100;
{
	ofstream f("bfstreamExample.dt",binary);
	f.write(134);
	f.write(1.346888);
	f.write(b);
	f.write(kk);
	writeint(f,10);
}
b = 0;

{
	real r;
	int i,kk,i4;
	ifstream f("bfstreamExample.dt",binary);
	f.read(i);
	f.read(r);
	f.read(bb);
	f.read(kk);
	readint(f,i4);
	
	cout << i << " " << r << " "<< i4 <<  endl;
	cout << bb << endl;
	//cout << b << endl;
}
// (M. Bonazzoli, Nov 2015)

load "medit"
load "Element_Mixte3d" //for Edge13d
//load "P012_3d_Modif" //for Edge13d (my file)

// The boundary value problem:
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

// Mesh data
int nloc = 4;        // number of segments on the smallest dimension
real a = 0.00254, b = 0.00127, c = 0.01;    // dimensions of the waveguide
//real a = 0.00254, b = 0.00127, c = 0.005;   

// Build the mesh
include "cube.idp"
int mx, my, mz;      // to decide the number of seg in the 3 directions 
mx = a/min(a,b);
my = b/min(a,b);
mz = c/min(a,b);
int[int] NN = [mx*nloc, my*nloc, mz*nloc];  // the number of seg in the 3 directions 
int guide = 1, in = 2, out = 3;             // labels for the waveguide
real [int,int] BB = [[0,a],[0,b],[0,c]];    // bounding box
int [int,int] L = [[guide,guide],[guide,guide],[in,out]];  // labels of the 6 parallelipiped faces
mesh3 Th = Cube(NN,BB,L);                   // build the mesh
//medit("mesh", Th);                        // plot the mesh

// Sol data
real f = 94*10^9;                  // frequence (I think omega=2*pi*f)
real er = 1;                       // dielectric constant
real c0 = 299792458;               // speed of light in vacuum
real k = 2*pi*f*sqrt(er)/c0;       // it's the wavenumber if mu_r=1
int m = 1, n = 0;
real beta = sqrt(k^2-(m*pi/a)^2-(n*pi/b)^2); // it comes from the dispersive relation
// (we assume E(x,y,z) = Etilde(x,y)*exp(-i*beta*z))
real Z = sqrt(er)*120*pi; // ?                        

real ukb = 1/(k^2-beta^2);
func expbz = exp(-1i*beta*z);
func ExTE = (1i*k*Z)*ukb*(n*pi)/b*cos(m*pi*x/a)*sin(n*pi*y/b)*expbz;  // (ricorda: k*Z = mu*omega)
func EyTE = -(1i*k*Z)*ukb*(m*pi)/a*sin(m*pi*x/a)*cos(n*pi*y/b)*expbz;
// For the impedance condition at the waveguide entrance:
func Gix = +2*1i*beta*ExTE;                       
func Giy = +2*1i*beta*EyTE;    
func Giz = 0;
// the sign here is + and in the variational formulation it is - int2d(Th,in)(Ginc*v) (all is written on the lhs)

// Finite element space
fespace Nh(Th, Edge23d);
// Edge13d: edge finite elements of degree 2
// (I called the space I introduced like this because the Nedelec elements of degree 1 are called Edge03d)
Nh<complex> [Ex,Ey,Ez], [vx,vy,vz];   // define the vector field and the test function
// (edge elements are vector elements and they give a subspace of Hcurl)

// Macros
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro Nvec(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM //uxN 
macro Curlabs(ux,uy,uz) [abs(dy(uz)-dz(uy)),abs(dz(ux)-dx(uz)),abs(dx(uy)-dy(ux))] //EOM

// Variational formulation of the problem to solve
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

problem waveguide([Ex,Ey,Ez], [vx,vy,vz], solver=sparsesolver) =
                  int3d(Th)(Curl(Ex,Ey,Ez)'*Curl(vx,vy,vz))
                - int3d(Th)(k^2*[Ex,Ey,Ez]'*[vx,vy,vz])
                + int2d(Th,in,out)(1i*beta*Nvec(Ex,Ey,Ez)'*Nvec(vx,vy,vz))
                - int2d(Th,in)([vx,vy,vz]'*[Gix,Giy,Giz])   
                + on(guide,Ex=0,Ey=0,Ez=0);      
waveguide;  // solve the problem

Nh<complex> [Eex,Eey,Eez] = [ExTE,EyTE,0]; // the exact solution
Nh<complex> [Errx,Erry,Errz]; // the error wrt the exact solution
[Errx,Erry,Errz] = [Eex,Eey,Eez]-[Ex,Ey,Ez];

// Norm of the exact solution
real Hcurlerrsqex, Hcurlerrex, L2errsqex, L2errex;
L2errsqex = int3d(Th)(abs(Eex)^2+abs(Eey)^2+abs(Eez)^2);
Hcurlerrsqex = int3d(Th)(Curlabs(Eex,Eey,Eez)'*Curlabs(Eex,Eey,Eez))+L2errsqex;
Hcurlerrex = sqrt(Hcurlerrsqex);
L2errex = sqrt(L2errsqex);
cout << "Hcurl norm of the exact solution = " << Hcurlerrex << endl;
cout << "L2 of the exact solution = " << L2errex << endl << endl;

// Norm of the error
real Hcurlerrsq, Hcurlerr, L2errsq, L2err;
L2errsq = int3d(Th)(abs(Errx)^2+abs(Erry)^2+abs(Errz)^2);
Hcurlerrsq = int3d(Th)(Curlabs(Errx,Erry,Errz)'*Curlabs(Errx,Erry,Errz))+L2errsq;
Hcurlerr = sqrt(Hcurlerrsq);
L2err = sqrt(L2errsq);
cout << "Hcurl norm of the error = " << Hcurlerr << endl;
cout << "L2 norm of the error = " << L2err << endl << endl;

// Relative errors
cout << "relative Hcurl norm of the error = " << Hcurlerr/Hcurlerrex << endl;
cout << "relative L2 norm of the error = " << L2err/L2errex << endl << endl;

// Plot the real part of the solution
medit("real",Th,[real(Ex),real(Ey),real(Ez)]); // in the medit window press h=help, m=data!!

load  "meshtools" 
mesh Th= square(10,10)+ square(10,10,[x+1,y+1]);
mesh3 Th3= cube(2,2,2)+ cube(3,3,3,[x+2,y+3,z+1]);
int[int] cc;
int nbc; 
nbc =ConnectedComponents(Th,cc); //  data on element of the open  set  
cout << " nb cmp cnx = " << nbc << " size of data " << cc.n <<endl; 
nbc =ConnectedComponents(Th,cc,closure=1); //  data on element of the closure set   
cout << " nb cmp cnx = " << nbc << " size of data " << cc.n <<endl; 
nbc =ConnectedComponents(Th,cc,vertices=1); //  data on vertices  
cout << " nb cmp cnx = " << nbc << " size of data " << cc.n << endl; 


fespace Vh(Th,P1);
fespace Ph(Th,P0);
Vh c;
Ph p;
nbc =ConnectedComponents(Th,c[],vertices=1);
 cout << " vertex/ nb cmp cnx = " << nbc << endl; 
 nbc =ConnectedComponents(Th,p[]);
  
plot(c,wait=1,fill=1,cmm="per vertex");
plot(p,wait=1,fill=1,cmm="per adj");


fespace Vh3(Th3,P0);
Vh3 d;
 nbc =ConnectedComponents(Th3,d[]);
 cout << " nb cmp cnx = " << nbc << endl; 
load "Element_HCT"
load "qf11to25" // for tripleQF function

// Parameter
real f = 1;

// Mesh
mesh Th = square(40, 40); //mesh definition of Omega

// Fespaces
fespace Wh(Th, P2);
fespace Vh(Th, HCT);	// HCT finite element space
Vh [u, ux, uy], [v, vx, vy];

// Macro
macro bilaplacien(u, v) (dxx(u)*dxx(v) + dyy(u)*dyy(v) + 2.*dxy(u)*dxy(v))	// end of macro

// Problem
// WARNING: the quadrature formula must be defined on 3 sub triangles
// the function tripleQF build this king of formula from classical quadrature
QF2 qfHCT5 = tripleQF(qf5pT);
solve bilap ([u, ux, uy], [v, vx, vy])
	= int2d(Th, qft=qfHCT5)(bilaplacien(u, v))
	- int2d(Th)(f*v)
	+ on(1, 2, 3, 4, u=0, ux=0, uy=0)
	;

// Plot
plot(u, cmm="u", wait=1, fill=1);
plot(ux, wait=1, cmm="u_x");
plot(uy, wait=1, cmm="u_y");

// Max & Error
Wh uu = u;
real umax = uu[].max;
int err = (abs(umax-0.0012782) > 1e-4);
cout << " uu max = " << umax << " ~ 0.0012782, err = " << err << endl;

// Plot
int n = 100, nn = n+10;
real[int] xx(nn), yy(nn);
for (int i = 0; i <= n; i++) {
	xx[i] = real(i)/n;
	yy[i] = u(0.5, real(i)/n);	// value of uh at point (0.5, i/10.)
}
plot([xx(0:n), yy(0:n)], wait=1);

// End
assert(err == 0);

load "PARDISO" 
load "shell"
//if(ompgetnumthreads() < 2 & getenv("OMP_NUM_THREAD") =="" ) 
//  ompsetnumthreads(10);// set number of thread for PARDISO ..  
//cout << " OMP NUM THREAD = " << ompgetnumthreads()  << " " << ompgetmaxthreads() << endl;; 
int[int] l = [1, 1, 2, 2];
mesh Th = square(100, 100, label = l);
fespace Vh(Th, P1);
Vh u, v;
verbosity = 0;
varf lap(u,v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th)(v) + on(1, u = 1);
varf lapc(u,v) = int2d(Th)((1+1i)*dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th)((1+2i)*v) + on(1, u = 1+3i);
real[int] b = lap(0, Vh);
verbosity = 4;
matrix A = lap(Vh, Vh,solver = "PARDISO",sym=0);
matrix<complex>  C= lapc(Vh, Vh,solver = "PARDISO",sym=0);
matrix B = A;// Warning no solver set in this case => set solver ..
matrix Bspd = A;// Warning no solver set in this case => set solver ..
set(B, solver = "PARDISO",sym=1);// Warning this sym the matrix 
set(Bspd, solver = "PARDISO",sym=1,positive=1);// Warning this sym the matrix 




verbosity = 5;
Vh x;
x[] = A^-1 * b;
cout << " x min /max "<< x[].min << " "<< x[].max << endl;
plot(Th, x, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver unsymmetric", value = 1);

x[] = B^-1 * b;
plot(Th, x, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver symmetric", value = 1);
x[] = Bspd^-1 * b;
plot(Th, x, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver  spd", value = 1);
Vh<complex>  c;
complex[int] bc=lapc(0,Vh); 
c[]= C^-1*bc;
plot(Th, c, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver  complex spd", value = 1);

load "Element_P2pnc"
load "Element_P3dc"

 mesh Th=square(10,10);
 fespace Vh(Th,P2pnc);     // P2+ nc  in P FE space
 cout << " Vh.ndof = "<< Vh.ndof << endl;
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 varf vLap(uh,vh) =                    //  Definion of  the problem
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
   - int2d(Th)( f*vh )                          //  linear form
   + on(1,2,3,4,uh=g) ;                      //  boundary condition form
  ;
  matrix A = vLap(Vh,Vh,solver="SPARSESOLVER");
  real[int] b= vLap(0,Vh);
  //cout << A << endl;
  uh[]=A^-1*b ;// solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP2pnc.eps",value=true);
load "Element_P4"
load "lapack"
load "qf11to25"

include "CC.idp"

int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];
// the fonctions bubble 
int[int] k6=[4,5,  9, 11, 15,16 ]; 
//  the edges function 
int[int] Be=[1,3,2, 8,10,6, 12,17,13];

func NN=[N.x,N.y];

// the ref triangle 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);
//  the 2 base vector [Cx,Cy] for interior DoF
real[int] Dx= [Th(2).x-Th(0).x, Th(0).x-Th(1).x];// 1: 20 et 2: 01 
real[int] Dy= [Th(2).y-Th(0).y, Th(0).y-Th(1).y];
real dJ1 =1/Th.area/2;
real[int] Cx=  Dy*-dJ1;
real[int] Cy=  Dx*dJ1;


fespace Rh(Th,RT0);
fespace P1h(Th,P1); 
fespace Ch(Th,[P4,P4]);// To store momoe function
Rh[int] [phi1,phi2](3);
P1h[int] l(3);

macro pp(i,j)  (l[i]*l[j])// P2 monome
	real err =0;

// Build phi and l basic functions 
real[int] sgf=[1,-1,1];
for(int i=0;i<3;++i)
{
l[i][]=0;     l[i][][i]=1;
phi1[i][]=0;  phi1[i][][i]=sgf[i];
}
Ch[int]  [b1,b2](6*3); //  build all momone functions
int [int,int] bii(18,3);

{   
	int k=0;   
	for(int i=0; i<3;++i)
	  for(int e=0; e<2;++e)//  
	    for(int j=0; j<3;++j)//  
	    {	
		int i1 = j, i2=j; //  sommet
		if(e) {i1 = ne1[j]; i2 =ne2[j];} // vertex of edge j
		bii(k,0) =i;
		bii(k,1) =i1;
		bii(k,2) =i2;
		[b1[k],b2[k]]= [phi1[i],phi2[i]]*pp(i1,i2);
		k++;
		}
}


real[int,int] Cb(15,6); //  coef of monone too be with mass mod 0
Ch[int] [Fb1,Fb2](15);  // the mono funct for verif.
{
	real[int,int] A(18,6);
	for(int i=0;i<18; ++i)
	  for(int j=0;j<3; ++j)
	   for(int k=0;k<2; ++k)
	     A(i,2*j+k) = int2d(Th)( [b1[i],b2[i]]'*[Cx[k],Cy[k]]*l[j]);

	real[int,int]  C(6,6),C1(6,6) ; 

	for( int j=0; j<6; ++j)// ligne 
	 for( int l=0; l<6; ++l)
	  C(j,l)= A(k6(l),j);
	C1=C^-1;


	for( int i=0; i<9; ++i)
	{
		int ki = Be[i];
		real[int] a6(6),b6(6);//
		for( int j=0; j<6; ++j)// ligne
		   b6(j)= -A(ki,j) ;
		a6 = C1*b6;
		Cb(i,:)=a6;
	}
	for( int i=0; i<6; ++i)
	 Cb(9+i,:)=C1(:,i);

	// les fonction bases

	for(int i=0; i< 15; ++i)
	{
		Ch [F1,F2];
		F1[]=0.; 
		if( i<9) 
			F1[] = b1[Be[i]][]; 
		for(int k=0; k< 6; ++k) // 
		  F1[] +=  Cb(i,k)*b1[k6[k]][];
		Fb1[i][]=F1[]; 
	}
}
//  Verif DOF 
// Les flux 
real[int][int] sigma(15);// To store all Dof linear form 
real[int,int] C1(3,3);// the DOf on edge 
{
	real[int,int] CC=[[ 24 , 6 , 4],[6,4,6],[4 , 6  ,24]];//   
	CC /= 120.;
	C1 = CC^-1; 
	int dof =0;
	// Edge dof 
	for (int i=0; i<3; ++i)
	{  	
		int i1 = ne1[i], i2 =ne2[i];
		for(int k=0;k<3;++k)
		{
			int kk = i*3+k;
			func FF=[Fb1[kk],Fb2[kk]];
			
			func fl = C1(0,k)*pp(i1,i1) 
			        + C1(1,k)*pp(i1,i2) 
					+ C1(2,k)*pp(i2,i2);
	
		    varf vdof([uu,vv],[u1,u2]) = int1d(Th,i,qforder=10)( fl*([u1,u2]'*[N.x,N.y]));
			sigma[dof].resize(Ch.ndof);
			sigma[dof++] = vdof(0,Ch);
	    }		
	}
	// Internal Dof 
	for (int j=0; j<6; ++j)
	   {
		   int i=j/2;
		   int k=j%2; 
		   varf vdof([uu,vv],[u1,u2]) = int2d(Th)( l[i]*[u1,u2]'*[Cx[k],Cy[k]]);
		   sigma[dof].resize(Ch.ndof);
		   sigma[dof++] =vdof(0,Ch);
	   }
	   assert(dof==15);
	   //  Check the if DoF and B.F are OK

	   for(int i=0; i<15; ++i)
	   {
	     for(int j=0; j<15; ++j)
		 {
			 real dij = Fb1[i][]'*sigma[j];
			 err = err+ abs( dij-(i==j));
			 cout << c00(dij) << " " ; 
		 }
		 cout << " err=" << err << endl;
       }
	   
}
// data Genaration for  FF++
CCt("cf",Cb); 
CCt("Bii",bii); 
CC("fe",Be);
CC("k6",k6);

CC("c1",C1);
cout << endl;
assert(err< 1e-10); 
include "cube.idp"
load "medit"
int[int, int] LL = [[2,2], [1,1], [1,1]];
real[int, int] BB = [[0,1], [0,1], [0,1]];
int[int] CC = [4, 4, 4];
load "splitmesh12"
mesh3 Th3=Cube(CC, BB, LL);
mesh3 Th12=splitmesh12(Th3);
mesh3 Th12WF=splitmesh12WorseyFarin(Th3);
medit("Th12WF",Th12WF);
assert(Th12.nt == Th3.nt * 12);
cout << Th12.nt << " == 12 x " << Th3.nt << endl;
assert(Th12.nbe == Th3.nbe * 3);
cout << Th12.nbe << " == 3 x " << Th3.nbe << endl;
plot(Th3, cmm="Th3", wait=1);
plot(Th12, cmm="Th12", wait=1);
fespace Vh(Th12, P1);
Vh xyz = x + y + z;
medit("splitmesh12",Th12,xyz);
load "medit"
load "iohdf5"
include "cube.idp"
load "iovtk"
verbosity=2;
int[int]  Nxyz=[20,5,5];
real [int,int]  Bxyz=[[0.,5.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,2],[2,2],[2,2]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM

solve Lame([u1,u2,u3],[v1,v2,v3])=
  int3d(Th)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  - int3d(Th) (gravity*v3)
  + on(1,u1=0,u2=0,u3=0)
  ;
real dmax= u1[].max;
cout << " max deplacement = " << dmax << endl;
real coef= 0.1/dmax;
int[int] ref2=[1,0,2,0];
mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2);
Thm=change(Thm,label=ref2);
plot(Th,Thm, wait=1,cmm="coef  amplification = "+coef );

savemesh(Thm,"beam-3d-def.mesh.h5");
savehdf5sol("beam-3d-def.sol.h5",Thm,u1,"ux",[u1,u2,u3],"U",(epsilon(u1,u2,u3)),"eps");
load "isoline"
real[int,int] xy(3,1);
int[int] be(1);
{
mesh Th=square(10,10);//,[x*.5,y*0.5]);
fespace Vh(Th,P1);
Vh u= sqrt(square(x-0.5)+square(y-0.5));
real iso= 0.2 ;
real[int] viso=[iso];
plot(u,viso=viso,Th);

int nbc= isoline(Th,u,xy,close=1,iso=iso,beginend=be,smoothing=0.0);
/*

  	iso =  value of the iso to compute
	close =  close the iso line this the border (def. 0). 
       smoothing =  nb of smoothing process =  smoothing * len curve ^ratio  
                (def. 0.) 
	   ratio =  (def. 1.) 
	eps =  relative eps (see code ??)  (def 1e-10 )
	beginend =  array to get begin end of sub line 
	file =  filename 

	remark:
        sense  of the  isoline :  the upper part is a the left part  isoline 
        so here : the minimiun is a 0.5,05 => the curve 1 turn in the clockwise sense 
*/
cout << " nb of the line  componant   = " << nbc << endl; 
cout << " n = " << xy.m << endl; // nombre of points 
cout << "be = " << be << endl; //  begin end of the componant

// show the lines 
for( int c=0;c<nbc; ++c) 
{
    int i0 = be[2*c], i1 = be[2*c+1]-1; // begin and end  the  connexe line comp. c       
    if(verbosity>4)          
    for(int i=i0; i<= i1; ++i)
       cout << " x = " <<  xy(0,i) << " y =  " << xy(1,i) << " s =  " << xy(2,i) << endl; 
    plot([xy(0,i0:i1),xy(1,i0:i1)],wait=1,viso=viso,cmm = " curve "+c);
}

border Curve2(t=0,1;i) 
{ int c =i; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 
int[int] NN(nbc);
for(int c=0;c<nbc;++c)
{
        int i0 = be[2*c], i1 = be[2*c+1]-1;   
	
	NN(c)=i1-i0;
}
plot(Curve2(NN),wait=1,cmm="2d nbc="+nbc);

}


cout << " len of the curve 1 = " << xy(2,xy.m-1) << endl;; 


border Curve0(t=0,1) 
{ int c =0; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 

border Curve1(t=0,1) 
{ int c =1; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 

plot(Curve1(100)); 
mesh Th= buildmesh(Curve1(-100));
plot(Th,wait=1);

//  test sur meshS 
{
meshS Th=square3(10,10,[0,x,y]);//,[x*.5,y*0.5]);
fespace Vh(Th,P1);
Vh u= sqrt(square(y-0.5)+square(z-0.5));
real iso= 0.2 ;
real[int] viso=[iso];
plot(u,viso=viso,Th);

int nbc= isoline(Th,u,xy,close=1,iso=iso,beginend=be,smoothing=0.0);

border Curve2(t=0,1;i) 
{ int c =i; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 
// pour afficher toute les iso !!!!
int[int] NN(nbc);
for(int c=0;c<nbc;++c)
   NN(c)=be[2*c+1]-1-be[2*c];

plot(Curve2(NN),wait=1,cmm="nbc="+nbc);

cout << " nb of the line  componant   = " << nbc << endl; 
cout << " n = " << xy.m << endl; // nombre of points 
cout << " m = " << xy.n << endl; // nombre of data 
cout << "be = " << be << endl; //  begin end of the componant

// show the lines 
for( int c=0;c<nbc; ++c) 
{
    int i0 = be[2*c], i1 = be[2*c+1]-1; // begin and end  the  connexe line comp. c  
    if(verbosity>4)      
    for(int i=i0; i<= i1; ++i)
       cout << " x = " <<  xy(0,i) << " y =  " << xy(1,i) << " " << xy(2,i) << " s =  " << xy(3,i) << endl; 
    plot([xy(0,i0:i1),xy(1,i0:i1),xy(2,i0:i1)],wait=1,viso=viso,cmm = " curveS "+c);
}
border Curve1(t=0,1) 
{ int c =1; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 
meshL ThL= buildmeshL(Curve1(-100));
plot(ThL,wait=1,cmm="ThL");

include "buildmeshS.idp"
meshS ThS= buildmeshS(ThL,1,1);
plot(ThS,cmm="ThS",wait=1);


}
// -*- FreeFem++ -*-
// Sample of SaveHB
// Author: fujiwara@acs.i.kyoto-u.ac.jp
mesh Th = square(3,3);
macro Grad(u) [dx(u),dy(u)] // EOM

fespace Vh(Th,P1);
varf vP(u,v) = int2d(Th)(Grad(u)'*Grad(v)) + int2d(Th)(v) + on(1,u=1);

matrix<complex> A = vP(Vh,Vh);
complex[int] rhs = vP(0,Vh);

load "SaveHB" 
int ret = SaveHB("sample_z.hb", A, rhs, "sample of SaveHB");

cout << " A = " << A << endl;
cout << " rhs  = " << rhs << endl;

assert(ret == 0); 

// End of file
//  Fluid-structure interaction for a weighting beam sitting on a
// square cavity filled with a fluid.
load "iohdf5"
int bottombeam = 2;
border a(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
border b(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
border c(t=0,2)  { x=10; y=t ;label=1;};       //  rigth beam
border d(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
real E = 21.5;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
mesh th = buildmesh( b(20)+c(5)+d(20)+a(5));
fespace Vh(th,[P1,P1]);
Vh [uu,vv], [w,s];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 
// definition of 2 macro :
real sqrt2=sqrt(2.);
macro epsilon(u1,u2)  [dx(u1),dy(u2),(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u,v) ( dx(u)+dy(v) ) // EOM

solve bb([uu,vv],[w,s],solver=CG)=
	int2d(th)(  
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
                 )
  - int2d(th) (gravity*s)
  + on(1,uu=0,vv=0)
  ;

//verbosity=100;
plot([uu,vv],wait=1);
plot([uu,vv],wait=1,bb=[[-0.5,2.5],[2.5,-0.5]]);
mesh th1 = movemesh(th, [x+uu, y+vv]);
plot(th1,wait=1);
cout << " max deplacement = " << uu[].linfty << endl;
savemesh(th1,"beam-2d-def.mesh.h5");
savehdf5sol("beam-2d-def.sol.h5",th1,uu,"uu",[uu,vv],"U",(epsilon(uu,vv)),"eps");
load "ff-Ipopt"
int bfgs=0,constraint =1; // aglo .. 
real x0=1.5,y0=0.5; 
mesh Th=square(10,10,[x+1,y]);
fespace Vh(Th,P2);
func g = cos(pi*x)*cos(pi*y);; //acosh(sqrt(x*x+y*y));//cos(pi*x)*cos(pi*y);
Vh ue= g;
macro grad(u) [dx(u),dy(u)]//EOM
func real J(real[int]& X)
{
    Vh u; u[]=X;
    return int2d(Th)(sqrt(1+grad(u)'*grad(u))) ;
}

func real[int]  DJ(real[int]& X)
{
    Vh u; u[]=X;
   
    varf vg(uu,v) = int2d(Th)((grad(u)'*grad(v)) / sqrt(1+grad(u)'*grad(u))) ;
   real[int] G= vg(0,Vh); 
    return G;}
matrix H;//global vairable for Hessien matrix Overwise  => seg fault in Ipopt     
func matrix  HJ(real[int]& X)
{
    Vh u; u[]=X;   
    varf vH(v,w) = int2d(Th)( (grad(w)'*grad(v)) / sqrt(1+grad(u)'*grad(u)) 
     - (grad(w)'*grad(u))*(grad(v)'*grad(u)) *(1+grad(u)'*grad(u))^-1.5 ) ;
    H = vH(Vh,Vh); 
    return H;}  
       
    
varf OnGamma(u,v) = on(1,2,3,4,u=1); 
Vh OnG;
OnG[]=OnGamma(0,Vh,tgv=1); // 1 on Gamma 
Vh lb = OnG!=0 ? g : -1e19 ; // 
Vh ub = OnG!=0 ? g :  1e19 ; //  
Vh u = OnG!=0  ? g : 0 ; //  initial guest ..
Vh clb = 3-square(10*(square(x-x0)+square(y-y0))); //  constraint .. 
if(constraint) lb = max(lb,clb); 
int ret;
if(bfgs) 
  ret = IPOPT(J,DJ,u[],lb=lb[],ub=ub[],bfgs=1); 
else 
  ret = IPOPT(J,DJ,HJ,u[],lb=lb[],ub=ub[]); 

cout << " min = "  << J(u[]) << "  ~ " << J(ue[]) << " ret = " << ret << endl; 
plot(u, wait=1);
load "ff-NLopt"

//A brief script to demonstrate how to use the freefemm interfaced nlopt routines
//The problem consist in solving a simple variational inequality using one of the
//optimization algorithm of nlopt. We restart the algorithlm a few times agter
//performing some mesh adaptation to get a more precise output.
int kas = 3; //    choose of the algo ...

int NN = 6;
mesh Th = square(NN,NN);
func f1=1.;
func f2=-1.;
func g1=0.;
func g2=0.1;
int iter=0;
int nadapt=2;
real starttol=1e-6,bctol=6.e-12;
fespace Vh(Th,P1);
Vh oldu1,oldu2;


for(int al=0;al<nadapt;++al)
{
	
varf BVF(v,w) = int2d(Th)(0.5*dx(v)*dx(w) + 0.5*dy(v)*dy(w));
varf LVF1(v,w) = int2d(Th)(f1*w);
varf LVF2(v,w) = int2d(Th)(f2*w);
matrix A =  BVF(Vh,Vh);
real[int] b1 = LVF1(0,Vh) , b2 = LVF2(0,Vh); 

varf Vbord(v,w) = on(1,2,3,4,v=1);
Vh In,Bord;
Bord[] = Vbord(0,Vh,tgv=1);
In[] = Bord[] ? 0:1;
Vh gh1=Bord*g1,gh2=Bord*g2;

func real J(real[int] &X)
{
	Vh u1,u2;
	u1[] = X(0:Vh.ndof-1);
	u2[] = X(Vh.ndof:2*Vh.ndof-1);
	iter++;
	real[int] Au1 = A*u1[], Au2 = A*u2[];
	Au1 -= b1;
	Au2 -= b2;
	real val = u1[]'*Au1 + u2[]'*Au2;
	if(iter %10==9) 
	plot(u1,u2,nbiso=30,fill=1,dim=3,cmm="adapt level " + al + " - iteration " + iter + " - J = " + val,value=1);
	return val;
}

varf dBFV(v,w) = int2d(Th)(dx(v)*dx(w)+dy(v)*dy(w));
matrix dA = dBFV(Vh,Vh);
func real[int] dJ(real[int] &X)
{
	Vh u1,u2;
	u1[] = X(0:Vh.ndof-1);
	u2[] = X(Vh.ndof:2*Vh.ndof-1);
	
	real[int] grad1 = dA*u1[], grad2 = dA*u2[];
	grad1 -= b1;
	grad2 -= b2;
	real[int] Grad(X.n);
	Grad(0:Vh.ndof-1) = grad1;
	Grad(Vh.ndof:2*Vh.ndof-1) = grad2; 
	return Grad;
}


func real[int] IneqC(real[int] &X)
{
	real[int] constraints(Vh.ndof);
	for(int i=0;i<Vh.ndof;++i) constraints[i] = X[i] - X[i+Vh.ndof];
	return constraints;
}
func real[int,int] dIneqC(real[int] &X)
{
	real[int,int] dconst(Vh.ndof,2*Vh.ndof);//so sparse... shame!
	dconst=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		dconst(i,i) = 1.;
		dconst(i,i+Vh.ndof) = -1.;
	}
	return dconst;
}

real[int] BordIndex(Th.nbe); //Indexes of border d.f.
{
	int k=0;
	for(int i=0;i<Bord.n;++i) if(Bord[][i]) {BordIndex[k]=i; ++k;}
}
func real[int] BC(real[int] &X)
{
	real[int] bc(2*Th.nbe);
	for(int i=0;i<Th.nbe;++i)
	{
		int I = BordIndex[i];
		bc[i] = X[I] - gh1[][I];
		bc[i+Th.nbe] = X[I+Th.nv] - gh2[][I];
	}
	return bc;
}
func real[int,int] dBC(real[int] &X)
{
	real[int,int] dbc(2*Th.nbe,2*Th.nv);//yet sparser...:(
	dbc=0.;
	for(int i=0;i<Th.nbe;++i)
	{
		int I=BordIndex[i];
		dbc(i,I) = 1.;
		dbc(i+Th.nbe,I+Th.nv) = 1.;
	}
	return dbc;
}


real[int] start(2*Vh.ndof),up(2*Vh.ndof),lo(2*Vh.ndof);

if(al==0)
{
	start(0:Vh.ndof-1) = 0.;
	start(Vh.ndof:2*Vh.ndof-1) = 0.01;//comment this two lines and uncomment what follows to use ub and lb
	/*Vh g1i=g1,g2i=g2;
	start(0:Vh.ndof-1) = g1i[];
	start(Vh.ndof:2*Vh.ndof-1) = g2i[]; */
}
else 
{
	start(0:Vh.ndof-1) = oldu1[];
	start(Vh.ndof:2*Vh.ndof-1) = oldu2[]; 
}
up=1000000;
lo=-1000000;
for(int i=0;i<Vh.ndof;++i)
{
	if(Bord[][i])
	{
		up[i] = gh1[][i] + bctol;
		lo[i] = gh1[][i] - bctol;
		up[i+Vh.ndof] = gh2[][i] + bctol;
		lo[i+Vh.ndof] = gh2[][i] - bctol;
	}
}

//Uncomment this to use ub and lb
if(kas<3){
  real[int] diff1 = start - lo , diff2 = up - start;
  for(int i=0;i<diff1.n;++i) 
   {
	if(diff1[i]<0) start[i]=lo[i];
	if(diff2[i]<0) start[i]=up[i]; 
   }
}

real mini=1e100;
if(kas==1)
   mini = nloptAUGLAG(J,start,grad=dJ,lb=lo,ub=up,IConst=IneqC,gradIConst=dIneqC,subOpt="LBFGS",stopMaxFEval=10000,stopAbsFTol=starttol);
else if(kas==2) 
 mini = nloptMMA(J,start,grad=dJ,lb=lo,ub=up,stopMaxFEval=10000,stopAbsFTol=starttol);
else if(kas==3) 
 mini = nloptAUGLAG(J,start,grad=dJ,IConst=IneqC,gradIConst=dIneqC,EConst=BC,gradEConst=dBC,subOpt="LBFGS",stopMaxFEval=200,stopRelXTol=1e-2);
else if(kas==4) 
 mini = nloptSLSQP(J,start,grad=dJ,IConst=IneqC,gradIConst=dIneqC,EConst=BC,gradEConst=dBC,stopMaxFEval=10000,stopAbsFTol=starttol);
Vh best1,best2;
best1[] = start(0:Vh.ndof-1);
best2[] = start(Vh.ndof:2*Vh.ndof-1);

Th = adaptmesh(Th,best1,best2,err=0.05);

oldu1=best1;
oldu2=best2;
}
load "Element_PkEdge"
// a macro the compute numerical derivative
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
mesh Th=square(1,1,flags=0,[10*(x+y/3),10*(y-x/3)]);
Th=square(1,1,flags=0   );
plot(Th,wait=1);
//savemesh(Th,"Th.msh");
real x1=0.4,y1=0.4;//10*(x+y/3),y1=10*(y-x/3), 
real h=1e-5 ;
int it1=Th(x1,y1).nuTriangle; 

// FFCS: store reference value
real regtest;

 macro Check(PkEdge)
{ 
  cout << " Test Finite Element " <<endl << endl;
  fespace Vh(Th,PkEdge);

  Vh a1,b1,c1;
  c1=x+y;
  real[int] viso(100);
  real v0= -100;
  real dv = 200./(viso.n+1);
  for(int i=0;i<viso.n;++i)
     viso[i]=v0+i*dv;
  plot(c1,fill=1,wait=1,viso=viso);
  for (int i=0;i<Vh.ndofK;++i)
    cout << i << " " << Vh(0,i) << endl;
  for (int i=0;i<Vh.ndofK;++i)
    {
      a1[]=0;	
      int j=Vh(it1,i);
      a1[][j]=1;
      plot(a1, wait=1); 
      b1=a1;/* do the interpolation */
      
      
      c1[] = a1[] - b1[];
      cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
      cout << " a = " << a1[] <<endl;
      cout << " b = " << b1[] <<endl;
      assert(c1[].max < 1e-9 && c1[].min > -1e-9); /* check if the interpolation is correct */
      
      /*  check the derivative and numerical derivative */
      /* no derivative in this element.  */
      
      
	cout << " dx(a1)(x1,y1) =  " << dx(a1)(x1,y1) << "  == " 
	   << DD(a1,h,0) << " DD " << " /  " 
	   << (a1(0.001,0.001) -  a1(0.999,0.999))/2 <<endl; 
	assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
	assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
	/*sassert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-5);*/
     
      
    } 
  regtest=a1'*a1;
}  //EOM

Check(P1edge)
Check(P2edge)
Check(P3edge)
Check(P4edge)
Check(P5edge)
// (M. Bonazzoli, Nov 2015)

load "medit"
load "Element_Mixte3d" //for Edge13d
//load "P012_3d_Modif" //for Edge13d (my file)

// The boundary value problem:
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

// Mesh data
int nloc = 4;        // number of segments on the smallest dimension
real a = 0.00254, b = 0.00127, c = 0.01;    // dimensions of the waveguide
//real a = 0.00254, b = 0.00127, c = 0.005;   

// Build the mesh
include "cube.idp"
int mx, my, mz;      // to decide the number of seg in the 3 directions 
mx = a/min(a,b);
my = b/min(a,b);
mz = c/min(a,b);
int[int] NN = [mx*nloc, my*nloc, mz*nloc];  // the number of seg in the 3 directions 
int guide = 1, in = 2, out = 3;             // labels for the waveguide
real [int,int] BB = [[0,a],[0,b],[0,c]];    // bounding box
int [int,int] L = [[guide,guide],[guide,guide],[in,out]];  // labels of the 6 parallelipiped faces
mesh3 Th = Cube(NN,BB,L);                   // build the mesh
//medit("mesh", Th);                        // plot the mesh

// Sol data
real f = 94*10^9;                  // frequence (I think omega=2*pi*f)
real er = 1;                       // dielectric constant
real c0 = 299792458;               // speed of light in vacuum
real k = 2*pi*f*sqrt(er)/c0;       // it's the wavenumber if mu_r=1
int m = 1, n = 0;
real beta = sqrt(k^2-(m*pi/a)^2-(n*pi/b)^2); // it comes from the dispersive relation
// (we assume E(x,y,z) = Etilde(x,y)*exp(-i*beta*z))
real Z = sqrt(er)*120*pi; // ?                        

real ukb = 1/(k^2-beta^2);
func expbz = exp(-1i*beta*z);
func ExTE = (1i*k*Z)*ukb*(n*pi)/b*cos(m*pi*x/a)*sin(n*pi*y/b)*expbz;  // (ricorda: k*Z = mu*omega)
func EyTE = -(1i*k*Z)*ukb*(m*pi)/a*sin(m*pi*x/a)*cos(n*pi*y/b)*expbz;
// For the impedance condition at the waveguide entrance:
func Gix = +2*1i*beta*ExTE;                       
func Giy = +2*1i*beta*EyTE;    
func Giz = 0;
// the sign here is + and in the variational formulation it is - int2d(Th,in)(Ginc*v) (all is written on the lhs)

// Finite element space
fespace Nh(Th, Edge13d);
// Edge13d: edge finite elements of degree 2
// (I called the space I introduced like this because the Nedelec elements of degree 1 are called Edge03d)
Nh<complex> [Ex,Ey,Ez], [vx,vy,vz];   // define the vector field and the test function
// (edge elements are vector elements and they give a subspace of Hcurl)

// Macros
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro Nvec(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM //uxN 
macro Curlabs(ux,uy,uz) [abs(dy(uz)-dz(uy)),abs(dz(ux)-dx(uz)),abs(dx(uy)-dy(ux))] //EOM

// Variational formulation of the problem to solve
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

problem waveguide([Ex,Ey,Ez], [vx,vy,vz], solver=sparsesolver) =
                  int3d(Th)(Curl(Ex,Ey,Ez)'*Curl(vx,vy,vz))
                - int3d(Th)(k^2*[Ex,Ey,Ez]'*[vx,vy,vz])
                + int2d(Th,in,out)(1i*beta*Nvec(Ex,Ey,Ez)'*Nvec(vx,vy,vz))
                - int2d(Th,in)([vx,vy,vz]'*[Gix,Giy,Giz])   
                + on(guide,Ex=0,Ey=0,Ez=0);      
waveguide;  // solve the problem

Nh<complex> [Eex,Eey,Eez] = [ExTE,EyTE,0]; // the exact solution
Nh<complex> [Errx,Erry,Errz]; // the error wrt the exact solution
[Errx,Erry,Errz] = [Eex,Eey,Eez]-[Ex,Ey,Ez];

// Norm of the exact solution
real Hcurlerrsqex, Hcurlerrex, L2errsqex, L2errex;
L2errsqex = int3d(Th)(abs(Eex)^2+abs(Eey)^2+abs(Eez)^2);
Hcurlerrsqex = int3d(Th)(Curlabs(Eex,Eey,Eez)'*Curlabs(Eex,Eey,Eez))+L2errsqex;
Hcurlerrex = sqrt(Hcurlerrsqex);
L2errex = sqrt(L2errsqex);
cout << "Hcurl norm of the exact solution = " << Hcurlerrex << endl;
cout << "L2 of the exact solution = " << L2errex << endl << endl;

// Norm of the error
real Hcurlerrsq, Hcurlerr, L2errsq, L2err;
L2errsq = int3d(Th)(abs(Errx)^2+abs(Erry)^2+abs(Errz)^2);
Hcurlerrsq = int3d(Th)(Curlabs(Errx,Erry,Errz)'*Curlabs(Errx,Erry,Errz))+L2errsq;
Hcurlerr = sqrt(Hcurlerrsq);
L2err = sqrt(L2errsq);
cout << "Hcurl norm of the error = " << Hcurlerr << endl;
cout << "L2 norm of the error = " << L2err << endl << endl;

// Relative errors
cout << "relative Hcurl norm of the error = " << Hcurlerr/Hcurlerrex << endl;
cout << "relative L2 norm of the error = " << L2err/L2errex << endl << endl;

// Plot the real part of the solution
medit("real",Th,[real(Ex),real(Ey),real(Ez)]); // in the medit window press h=help, m=data!!

load "aniso"

// [m11, m12, m22]
real[int] M2 = [1, 0, 100];
// [m11, m21, m22, m31, m32, m33
real[int] M3 = [1, 0, 10, 0, 0, 100];

boundaniso(3, M2, 3);
cout << "M2 = " << M2 << endl;

boundaniso(6, M3, 2);
cout << "M3 = "<< M3 << endl;
//  Solver - Delta u = f , u < g et u = 0 on Gamma 
load "ff-Ipopt";
int nn=20;
mesh Th=square(nn,nn);
fespace Vh(Th,P2);

func f = 1.; //rhs function
real r=0.03,s=0.1; //some parameters for g
func g = r - r/2*exp(-0.5*(square(x-0.5)+square(y-0.5))/square(s));


macro Grad(u) [dx(u),dy(u)]//
varf vP(u,v) = int2d(Th)(Grad(u)'*Grad(v)) - int2d(Th)(f*v);

matrix A = vP(Vh,Vh,solver=CG);
real[int] b = vP(0,Vh);

// Warning the boundary condition are given with lb and ub on border
// equal value ... 
Vh u=0;
Vh lb=-1.e19;
varf vGamma(u,v) = on(1,2,3,4,u=1);
real[int] onGamma=vGamma(0,Vh);
Vh ub=g;
ub[] = onGamma ? 0. : ub[];
lb[] = onGamma ? 0. : lb[];

IPOPT([A,b],u[],lb=lb[],ub=ub[]);
Vh ubb =g;
plot(u,ubb,wait=1);

load "MetricKuate"
mesh Th=square(5,5,[(x-0.5)*2,(y-0.5)*2]);
real x0,y0;//  pour definir l'err  forme n lineare en x0,y0
real coef =1;
fespace Vh(Th,P1);
fespace Wh(Th,P2);
fespace Ph(Th,P0);
real c=10;

func f = tanh(c * (sin( (5 * y)) -  (2 * x))) +  (y * x * x) +   pow( y,  3);;

func fxxx = 0.16e2 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) - 0.32e2 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1);
func fxxy = -0.40e2 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) * cos( (5 * y)) + 0.80e2 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1) * cos( (5 * y)) + 0.2e1;
func fxyy = 0.100e3 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.2e1) - 0.200e3 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.2e1) - 0.100e3 * tanh(c * (sin( (5 * y)) -  (2 * x))) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * c * c * sin( (5 * y));

func fyyy = -0.250e3 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.3e1) + 0.500e3 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.3e1) + 0.750e3 * tanh(c * (sin( (5 * y)) -  (2 * x))) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * c * c * cos( (5 * y)) * sin( (5 * y)) - 0.125e3 * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * c * cos( (5 * y)) + 0.6e1;

/*
real p=20;
real p3=p-3, p321=p*(p-1)*(p-2);
func f= x^p + y^p;
func fxxx = p321*x;
func fyyy = p321*y;
func fxxy=0.;
func fxyy=0.;
*/
func err=(fxxx*x0*x0*x0+3*fxxy*x0*x0*y0+3*fxyy*x0*y0*y0+fyyy*y0*y0*y0 )*coef;

for(int i=1;i<4;i++)
  {
    Vh m11,m12,m22;
    coef = 1;
    Wh f2=f;
    MetricKuate(Th,200,0.0001,3,err,[m11[],m12[],m22[]],[x0,y0]);
   // plot(m11,m22,wait=1,cmm="mmmm");
    real cc=10;
    Th=adaptmesh(Th,cc*m11,cc*m12,cc*m22,IsMetric=1,inquire=1,hmin=0.00001,nbvx=1000000);
    cout << m11[].max << " " << m12[].max << " " << m22[].max << endl;
    plot(Th,wait=1,ps="o/Th.eps");
    plot(f2,wait=1);
    Ph eh = (abs(f2-f));
    Ph leh= log10(eh);
    real[int] viso=[-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1];
    plot(leh,fill=1,wait=1,viso=viso,value=1,ps="o/leh.eps");
    cout << i << " .... " << eh[].min << " "<< eh[].max << " "<< eh[].sum/eh[].n << " "
         << int2d(Th)(eh)/Th.area << " " << Th.nt << " " << Th.nv << endl;
  }
   Th=square(5,5,[(x-0.5)*2,(y-0.5)*2]);

// FFCS - regression tests
real regtest;

 real cerr= 0.005*(0.000961606/0.000582183)^0.66;
  for(int i=1;i<4;i++)
  {
    Vh m11,m12,m22;
    coef = 1;
    Wh f2=f;

    real cc=10;
    Th=adaptmesh(Th,f,err=cerr,inquire=1,hmin=0.00001,nbvx=1000000);
    cout << m11[].max << " " << m12[].max << " " << m22[].max << endl;
    plot(Th,wait=1,ps="o/Th2.eps");
    plot(f2,wait=1);
    Ph eh = (abs(f2-f));
    Ph leh= log10(eh);
    real[int] viso=[-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1];
    plot(leh,fill=1,wait=1,viso=viso,value=1,ps="o/leh2.eps");
    cout << i << " .... " << eh[].min << " "<< eh[].max << " "<< eh[].sum/eh[].n << " "
         << int2d(Th)(eh)/Th.area << " " << Th.nt << " " << Th.nv << endl;
    regtest=eh[]'*eh[];//'
  }
// this exemple is buggus in some case ...
// strange ...  FH.  , S Auliac  (will be correct in test ???)
// remove the test  (no loop)  
int nadapt=0;//  3 is teh previous value..
load "medit";
load "ff-Ipopt";

real alpha=0.9;
int np=30;
mesh Th = square(2*np,np,[2*pi*x,pi*y]);

// FFCS regression reference value
real regtest;

fespace Vh(Th,P1,periodic=[[2,y],[4,y]/*,[1,x],[3,x]*/]);

/*
 * Initial shape definition
 * outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations
 */

Vh startshape=5;//+0.5*(cos(10*x)*sin(10*y)*sin(y));

//uz,lz,lm : dual variables storage for the warmstart
Vh uz=1.,lz=1.;
real[int] lm=[1];



for(int kkk=0;kkk<nadapt;++kkk) //Mesh adaptation loop
{

int iter=0;
func sin2 = square(sin(y));

/*
 * A function which transform Th in 3d mesh (r=rho)
 * a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )
 * then displays the resulting mesh with medit.
 * (often crashs if some values of rho are negative or if freefem is compiled with debug)
 */
func int Plot3D(real[int] &rho,string cmm,bool ffplot)
{
	Vh rhoo;
	rhoo[]=rho;
	//mesh sTh = square(np,np/2,[2*pi*x,pi*y]);
	//fespace sVh(sTh,P1);
	//Vh rhoplot=rhoo;
	try
	{
		meshS Sphere = movemesh23(Th,transfo=[rhoo(x,y)*cos(x)*sin(y),rhoo(x,y)*sin(x)*sin(y),rhoo(x,y)*cos(y)]);
		if(ffplot) plot(Sphere);
		else medit(cmm ,Sphere,wait=0);
	}
	catch(...)
	{
		cout << "cant plot" << endl;
	}
	return 1;
}


/*
 * Surface computation
 * Maybe is it possible to use movemesh23 to have the surface function less complicated
 * However, it would not simplify the gradient and the hessian
 */
func real Area(real[int] &X)
{
	Vh rho;
	rho[] = X;
	Vh rho2 = square(rho);
	Vh rho4 = square(rho2);
	real res = int2d(Th)(sqrt( rho4*sin2 + rho2*square(dx(rho)) + rho2*sin2*square(dy(rho)) ) );
	++iter;
	if(1) plot(rho,value=1,fill=1,cmm="rho(theta,phi) on [0,2pi]x[0,pi] - S="+res,dim=3);
	else Plot3D(rho[],"shape_evolution",1);
	return res;
}
func real[int] GradArea(real[int] &X)
{
	Vh rho,rho2;
	rho[] = X;
	rho2[] = square(X);
	Vh sqrtPsi,alpha;
	{
		Vh  dxrho2 = dx(rho)*dx(rho), dyrho2 = dy(rho)*dy(rho);
		sqrtPsi = sqrt( rho2*rho2*sin2 + rho2*dxrho2 + rho2*dyrho2*sin2 );
		alpha = 2.*rho2*rho*sin2 + rho*dxrho2 + rho*dyrho2*sin2;
	}
	varf dArea(u,v) = int2d(Th)(1./sqrtPsi * (alpha*v + rho2*dx(rho)*dx(v) + rho2*dy(rho)*sin2*dy(v)) );
	real[int] grad = dArea(0,Vh);
	return grad;
}
matrix hessianA;
func matrix HessianArea(real[int] &X)
{
	Vh rho,rho2;
	rho[] = X;
	rho2 = square(rho);
	Vh sqrtPsi,sqrtPsi3,C00,C01,C02,C11,C12,C22,A;
	{
		Vh C0,C1,C2;
		Vh  dxrho2 = dx(rho)*dx(rho), dyrho2 = dy(rho)*dy(rho);
		sqrtPsi = sqrt( rho2*rho2*sin2 + rho2*dxrho2 + rho2*dyrho2*sin2 );
		sqrtPsi3 = ( rho2*rho2*sin2 + rho2*dxrho2 + rho2*dyrho2*sin2 )*sqrtPsi;
		C0 = 2*rho2*rho*sin2 + rho*dxrho2 + rho*dyrho2*sin2;
		C1 = rho2*dx(rho);
		C2 = rho2*sin2*dy(rho);
		C00 = square(C0);
		C01 = C0*C1;
		C02 = C0*C2;
		C11 = square(C1);
		C12 = C1*C2;
		C22 = square(C2);
		A = 6.*rho2*sin2 + dxrho2 + dyrho2*sin2;
	}
	varf d2Area(w,v) =
		int2d(Th)(1./sqrtPsi * (A*w*v + 2*rho*dx(rho)*dx(w)*v + 2*rho*dx(rho)*w*dx(v) + 2*rho*dy(rho)*sin2*dy(w)*v + 2*rho*dy(rho)*sin2*w*dy(v)
								+ rho2*dx(w)*dx(v) + rho2*sin2*dy(w)*dy(v)) 
		+        1./sqrtPsi3 * (C00*w*v + C01*dx(w)*v + C01*w*dx(v) + C02*dy(w)*v + C02*w*dy(v) + C11*dx(w)*dx(v)
								   + C12*dx(w)*dy(v) + C12*dy(w)*dx(v) + C22*dy(w)*dy(v)) );
	hessianA = d2Area(Vh,Vh);
	return hessianA;
}


/*
 * Volume computation
 */
func real Volume(real[int] &X)
{
	Vh rho;
	rho[]=X;
	Vh rho3=rho*rho*rho;
	real res = 1./3.*int2d(Th)(rho3*sin(y));
	return res;
}
func real[int] GradVolume(real[int] &X)
{
	Vh rho;
	rho[]=X;
	varf dVolume(u,v) = int2d(Th)(rho*rho*sin(y)*v);
	real[int] grad = dVolume(0,Vh);
	return grad;
}
matrix hessianV;
func matrix HessianVolume(real[int] &X)
{
	Vh rho;
	rho[]=X;
	varf d2Volume(w,v) = int2d(Th)(2*rho*sin(y)*v*w);
	hessianV = d2Volume(Vh,Vh);
	return hessianV;
}



/*
 * If we want to use the volume as a constraint function
 * we must wrap it in some freefem functions returning the appropriate type 
 * The lagrangian hessian also have to be wrapped since the Volume is not linear with 
 * respect to rho, it will constribbute to the hessian.
 */
func real[int] ipVolume(real[int] &X) {real[int] vol = [Volume(X)]; return vol;}
matrix mdV;
func matrix ipGradVolume(real[int] &X) {real[int,int] dvol(1,Vh.ndof); dvol(0,:)=GradVolume(X); mdV=dvol; return mdV;}
matrix HLagrangian;
func matrix ipHessianLag(real[int] &X,real objfact,real[int] &lambda)
{
	HLagrangian = objfact*HessianArea(X) + lambda[0]*HessianVolume(X);
	return HLagrangian;
}
/*building struct for GradVolume */
int[int] gvi(Vh.ndof),gvj=0:Vh.ndof-1;
gvi=0;


/*
 * The starting value
 */
Vh rc=startshape ;


/*
 * Bounds definition
 */
Vh ub=1.e19;
//Vh lb=1.,ub=3.;


/*
 * make it funnier by puptting some objects inside the shape , where rho has to be greater than a given value
 */
Vh lb=0;
int shapeswitch=1;
real sigma=2*pi/40.,treshold=0.1;
func real Gaussian(real X,real Y,real theta,real phi)
{
	real deltax2 = square((X-theta)*sin(Y)) , deltay2 = square(Y-phi);
	return exp(-0.5 * (deltax2 + deltay2) / (sigma*sigma));
}
real e=0.1,r0=0.25,rr=2-r0;
real E=1./(e*e),RR=1./(rr*rr);
func disc1 = sqrt(1./(RR+(E-RR)*cos(y)*cos(y)))*(1+0.1*cos(7*x));
func disc2 = sqrt(1./(RR+(E-RR)*cos(x)*cos(x)*sin2))  ;
if(1) //doesn't work well...
{
	lb=r0;
	/*{
		func f = rr*Gaussian(x,y,0,0);
		func g = rr*Gaussian(x,y,0,pi);
		lb = max(max(lb,f),g);
	}*/
	for(int q=0;q<5;++q)
	{
		func f = rr*Gaussian(x,y,2*q*pi/5.,pi/3.);
		func g = rr*Gaussian(x,y,2*q*pi/5.+pi/5.,2.*pi/3.);
		lb = max(max(lb,f),g);
	}
	lb = max(lb,rr*Gaussian(x,y,2*pi,pi/3));
}
lb =  max(lb,max(disc1, disc2));
real Vobj = Volume(lb[]);
real Vnvc = 4./3.*pi*pow(lb[].linfty,3);

if(1) Plot3D(lb[],"object_inside",0);
real[int] clb=0.,cub=[(1-alpha)*Vobj + alpha*Vnvc];


/*
 * Call to IPOPT
 */
int res=IPOPT(Area,GradArea,ipHessianLag,ipVolume,ipGradVolume,rc[],ub=ub[],lb=lb[],clb=clb,cub=cub,checkindex=1,maxiter=kkk<nadapt-1 ? 40:150,warmstart=kkk,lm=lm,uz=uz[],lz=lz[],tol=0.00001,structjacc=[gvi,gvj]);
cout << " IPOPT: res =" << res << endl ;
/*
 * Display the final mesh
 */
Plot3D(rc[],"Shape_at_"+kkk,0);
Plot3D(GradArea(rc[]),"ShapeGradient",0);
if(kkk<nadapt-1)
{
	Th = adaptmesh(Th,rc*cos(x)*sin(y),rc*sin(x)*sin(y),rc*cos(y)/*,hmax=pi/np*/,nbvx=50000,periodic=[[2,y],[4,y]/*,[1,x],[3,x]*/]);
	plot(Th,wait=1);
	startshape = rc;
	uz=uz;//dual variables interpolation
	lz=lz;
}

// FFCS regression reference value
regtest=rc[]'*rc[];
}

load "exactpartition"
mesh Th=square(10,10);
mesh3 Th3=buildlayers(Th,10); 
fespace Vh(Th,P1);
fespace Vh3(Th3,P1);
int n=10;
Vh[int] p(n); 
Vh3[int] p3(n); 
real[int][int] pp(n);

for(int i=0; i<n; ++i)
p[i]= lrint(x*y*n/3)== lrint(i*1./3.);
for(int i=0; i<n; ++i)
  p3[i]= lrint(x*y*(1-z)*n/3)== lrint(i*1./3.);
for(int i=0;i<n;++i)
{
    pp[i].resize(Vh.ndof);
    pp[i]=p[i][]; 
}
plot(p, wait=1);
int[int] pj=[3,4,1,8,9,100,8,7,10,11,12]; 
exactpartition(p,pj); 
exactpartition(p3,pj); 
exactpartition(pp,pj); 
Vh s=1;
for(int i=0; i<n;++i)
 s[] -= p[i][];
 
 assert(s[].linfty ==0); 
load "ff-cmaes"


int NN = 5;
mesh Th = square(NN,NN);
func f1=1.;
func f2=-1.;
func g1=0.;
func g2=0.1;
int iter=0;
int nadapt=1;
real starttol=1e-10,bctol=6.e-12;
fespace Vh(Th,P1);
Vh ou1,ou2;
real pena=1000;


for(int al=0;al<nadapt;++al)
{
	
varf BVF(v,w) = int2d(Th)(0.5*dx(v)*dx(w) + 0.5*dy(v)*dy(w));
varf LVF1(v,w) = int2d(Th)(f1*w);
varf LVF2(v,w) = int2d(Th)(f2*w);
matrix A =  BVF(Vh,Vh);
real[int] b1 = LVF1(0,Vh) , b2 = LVF2(0,Vh); 

varf Vbord(v,w) = on(1,2,3,4,v=1);
//real[int] bord = Vbord(0,Vh);
//real[int] in = bord ? 0 : 1;
Vh In,Bord;
Bord[] = Vbord(0,Vh,tgv=1);
In[] = Bord[] ? 0:1;
Vh gh1=Bord*g1,gh2=Bord*g2;



//Function which create a vector of the search space type from
//two finite element functions
func int FEFToSSP(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			ssp[kX] = fef1[i];
			ssp[kX+In[].sum] = fef2[i];
			++kX;
		}
	}
	return 1;
}
//Function spliting a vector from the search space and fills
//two finite element functions with it
func int SSPToFEF(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			fef1[i] = ssp[kX];
			fef2[i] = ssp[kX+In[].sum];
			++kX;
		}
		else
		{
			fef1[i] = gh1[][i];
			fef2[i] = gh2[][i];
		}
	}
	return 1;
}


func real IneqC(real[int] &X)
{
	real[int] constraints(In[].sum);
	for(int i=0;i<In[].sum;++i)
	{
		constraints[i] = X[i] - X[i+In[].sum];
		constraints[i] = constraints[i] <= 0 ? 0. : constraints[i];
	}
	return constraints.l2;
}


func real J(real[int] &X)
{
	Vh u1,u2;
	SSPToFEF(u1[],u2[],X);
	iter++;
	real[int] Au1 = A*u1[], Au2 = A*u2[];
	Au1 -= b1;
	Au2 -= b2;
	real val = u1[]'*Au1 + u2[]'*Au2;
	val +=  pena * IneqC(X);
	if(iter%200==199) 
	plot(u1,u2,nbiso=30,fill=1,dim=3,cmm="adapt level " + al + " - iteration " + iter + " - J = " + val,value=1);
	return val ;
}



real[int] start(2*In[].sum);

if(al==0)
{
	start(0:In[].sum-1) = 0.;
	start(In[].sum:2*In[].sum-1) = 0.1;
}
else FEFToSSP(ou1[],ou2[],start);


real mini = cmaes(J,start,stopMaxFunEval=10000*(al+1),stopTolX=1.e-3/(10*(al+1)),initialStdDev=(0.025/(pow(100.,al))));
Vh best1,best2;
SSPToFEF(best1[],best2[],start);

Th = adaptmesh(Th,best1,best2);
ou1 = best1;
ou2 = best2;

}
load "./lgbmo"
int n=2;
real[int] X(n),DX(n);
real[int] X0(n);
for(int i=0;i<n;++i) X0[i]=0.5;

func real J(real[int] & x)
{
  real s=n;
  x -= X0;
  for (int i=0;i<x.n;i++)
    s +=(x[i]*x[i]-cos(18.*x[i]));
  //cout << " J " << s << "       .... " << x[0] << " " << x[1] << endl;
  return s;
}

func real[int] DJ(real[int] &x)
{
  x -= X0; 
  for (int i=0;i<x.n;i++)
    x[i]=2*x[i]+18*sin(18*x[i]);
  //cout << " dJ "  << "       .... " << x[0] << " " << x[1] << endl;
  return x;  // return of global variable ok 
};

for(int i=0;i<n;++i)
  X[i]=abs(sin((i+1)/(n*2.)));
verbosity=9;

//  buggus.. 
 
real  mm=0;// bmo(J,DJ,X,min=-10,max=10);
cout << " min = " << mm << endl;

cout << " x = " << X << endl;
cout << " X0 = " << X0 << endl;

// Example of dynamic function load
// --------------------------------
// $Id$

 load "myfunction2"
  string toto="xxxx";
 Why(toto);
 Why("qqsdqs.wwc.dqqs");
 cout << f(3.) << endl; 
// ShurComplement  full matrix 
load "lapack"
// ShurComplement  sparse matrix 
load "Schur-Complement"
include "ExtractDofsonBorder.idp"


// popur CL Dirichet
macro FindDofOnBorder(l,Vh,I)
{
	varf von(u,v) = on(l,u=-1);
    int[int] J=0:Vh.ndof-1;
	real[int] vl = von(0,Vh); 
	sort(vl,J);
	vl = vl ? 1. :0.;
	int n = vl.sum+0.5; 

	I.resize(n);
	I=J(0:n-1);
	cout << " n = "<< n << endl; 
}//

macro grad(u) [dx(u),dy(u)] //
real hsize= 0.1; 

real htt = max(hsize/2,0.1);
mesh Th=square(2/hsize,1/hsize,[x*2,y]);

Th=trunc(Th,(abs(x-1)>4*htt)||(abs(y-0.5)>htt),label=10);

mesh Th2=movemesh(Th,[2-(x-2),y]);
plot(Th,Th2,wait=1);
fespace Vh(Th,P1);
fespace Vh2(Th2,P1);
int n = Vh.ndof;
varf va(u,v) = int2d(Th)(grad(u)'*grad(v))+on(1,3,4,u=0);

 matrix A= va(Vh,Vh,sym=0,tgv=-2);
if(verbosity>9) cout << A << endl; 
int[int] I; 
ExtractDofsonBorder(2,Vh,I,1);

real[int,int] B(1,1);

//  model 2 
int[int] I10;
FindDofOnBorder(10,Vh,I10);
if(verbosity>9) cout << " I10 "<< I10 << endl; 
int[int] If(n);
int In=I.n; 
If=-1;
for [i,Ii:I]
  If[Ii]=i; 
for [i,I10i:I10]
    If[I10i]=In; 
if( verbosity>9) cout << If << endl; 	
real[int,int] S(1,1);
int nfs=SchurComplement(S,A,If,B);

cout << nfs << " "<< In+1  << endl;
if( verbosity>9)  cout << " S = "<<" " << S << endl;  
/*
dans S  les dof sont : 0 a In-1 : cote doite vertical 
       In =  cl troue
    PB symetrique => resoudre S+S 
*/
int iclr=nfs;
int icll=nfs-1;
int iclS = nfs-1;
int[int] Il=0:nfs;
int[int] Ir=0:nfs;

Ir[iclr]=iclS;
Ir[icll]=-1;

Il[iclr]=-1;
Il[icll]=iclS;
 
int nd = nfs+1;
//matrix St(nd,nd);// manque une matrix vide 
cout << " S ="<< S << endl;
real[int,int] St(nd,nd);
func real[int,int]  to(int[int] &I,real[int,int] &S)
{
	int n = I.n;
	real[int,int]  A(n,n);
	A=0;
	for(int i=0; i<n; ++i)
		for(int j=0; j<n; ++j)
		if(I[i]>=0 && I[j]>=0 )
	  	  A(i,j) += S(I[i],I[j]);
		  return A;
}
St =0;
{// a ameliorer ... il maque des fonction ff++ 
	//St+=S(Ir,Ir);
	St=to(Ir,S);
	real[int,int] Stt=to(Il,S);
	St+= Stt;
	/*  bug ... in Matrixfull2mapIJ in  v 4.3-1
	{
    matrix Stt = S(Ir,Ir);
    real[int,int] Sb(nd,nd);
    copy(Sb,Stt);
	cout << Ir << endl; 
	cout << "Sbr " << Sb << endl;
     St += Sb; 
    }
	{
    matrix Stt = S(Il,Il);
    real[int,int] Sb(nd,nd);
    copy(Sb,Stt);
	cout << Il << endl; 
	cout << "Sbl " << Sb << endl;
    St += Sb; 
    }
*/
}
cout << " St=" <<  St << endl; 
cout << "ic  = "<< icll <<" " << iclr << endl; 
int[int] It=[icll,iclr];
real[int,int] SS(1,1), B0(1,1);
matrix Stm = St;
int nfs0=SchurComplement(SS,Stm,It,B0);

cout << "B0=" << B0 << endl; 
for(int j=0; j<B0.m; ++j)
{	
	Vh ul=0;
	Vh2 ur = 0; 
	for(int i=0; i<nfs-1; ++i)
  	 ur[] +=  B(:,i)*B0(i,j);
	for(int i=0; i<nfs-1; ++i)
 	 ul[] +=  B(:,i)*B0(i,j);
	{
	  ur[] +=  B(:,nfs-1)*B0(nfs-1,j);
	  ul[] +=  B(:,nfs-1)*B0(nfs,j);
	 }   
	plot(ul,ur, wait=1);
}

load "ppm2rnm"

// Parameters
bool wait = false;
string figName = "fig.pgm";

// Read PPM (method 1)
real[int, int] img1(figName); //Read image and set to an array
int nx = img1.n, ny = img1.m;
mesh Th1 = square(nx-1, ny-1, [(nx-1)*(x)/nx, (ny-1)*(1-y)/ny]);
//Warning:
// the numbering of the vertices (x,y) is
// given by i = x/nx + nx* y/ny
fespace Vh1(Th1, P1);
Vh1 fimg1;
fimg1[] = img1;
plot(fimg1, cmm="method 1", wait=wait);

// Read PPM (method 2)
real[int, int] img2(figName); //Read image and set to an array
int nx2 = img2.n, ny2 = img2.m;
mesh Th2 = square(nx2-1, ny2-1, [(nx2-1)*(x)/nx2, (ny2-1)*(1-y)/ny2]);
fespace Vh2(Th2, P1);
Vh2 fimg2;
fimg2[] = img2;
plot(fimg2, cmm="method 2", wait=wait);

// Save PPM
bool res = savePPM("figout.ppm", img2);
assert(res);

// Difference PPM
real[int, int] imgDiff = diffPPM(img1, img2);
int nxDiff = imgDiff.n, nyDiff = imgDiff.m;
mesh ThDiff = square(nxDiff-1, nyDiff-1, [(nxDiff-1)*(x)/nxDiff, (nyDiff-1)*(1-y)/nyDiff]);
fespace VhDiff(ThDiff, P1);
VhDiff fimgDiff;
fimgDiff[] = imgDiff;
plot(fimgDiff, cmm="difference", wait=wait);
mesh Th=square(100,100,[x*2-1,y*2-1]);
load "isoline"
fespace Vh(Th,P1);
fespace Ph(Th,P0); 
func rr= sqrt(x^2+y^2);
int k =5;
Vh u= sin(k*pi*x)*sin(k*pi*y);//rr*(1-rr);
plot(u, wait=1);
Ph r; 

verbosity=3;
int[int] lm=findalllocalmin(Th,u[],r[],convex=1,eps=0);
plot(r,u,fill=1,wait=1);
// lm.n == number of min
// r  bassin number 
// lm[int(r[k])] is the minimal vertex of the bassin associated 
//cout << r[]<<endl; 

cout << lm << endl; 
include "gsl.idp"
// FFCS - avoid using P2 and P3 which already define something very precise
real [int] p2=[ 2,-3,1];
real [int] p3=[ 8,-10,1,1];
real [int] X(3);
complex[int] Z(4);
real [int] Q4=[ -1,0,0,0,1];
gslpolysolvequadratic(p2,X);
cout << X[0] << " " << X[1] << endl; 
gslpolysolvecubic(p3,X);
cout << X[0] << " " << X[1] << " " << X[2] << endl; 
gslpolycomplexsolve(Q4,Z); 
cout << Z[0] << " " << Z[1] << " " << Z[2] << " " << Z[3] <<endl;

cout << "\n\n gsl random :\n\n";
 cout << " list of generator " << ngslrng << endl;
 for(int i=0; i <ngslrng ; ++i)
   cout << i << " name  " <<  gslname(gslrngtype(i)) << endl; 
gslrng r=gslrngtype(1);// chose a generator 
// cout << r << endl;  no print .. 
for (int i = 0; i < 10; i++) 
   cout << gslrnguniform(r) << endl;;  
 
 real x0=0.2;
 int n=10;
 real[int,int] dspline(2,n+6);
 for(int i=0; i<= n+5; ++i)
  {
    real xx = square(real(i)/n)+x0; 
    real yy = sin(xx*pi*2); 
    dspline(0,i)= xx;
    dspline(1,i)= yy;    
  }
  /*
 the 7  type of spline of gsl are 
  0: gslinterpcspline (default .
  1: gslinterpakima
  2: gslinterpsteffen
  3: gslinterplinear
  4:  gslinterppolynomial
  5: gslinterpcsplineperiodic
  6:  gslinterpakimaperiodic 
  */
  gslspline spline(gslinterplinear,dspline);
  int mm=100;
 real[int] xx(mm+1),yy(mm+1),zz(mm+1),dyy(mm+1),ddyy(mm+1),dzz(mm+1),ddzz(mm+1);
 real err=0; 
 for (int i=0; i<=mm; ++i)
 { xx[i]= real(i)/mm+x0;
   yy[i]= spline(xx[i]);
   dyy[i]= spline.d(xx[i]);
   ddyy[i]= spline.dd(xx[i]);
   zz[i]= sin(pi*xx[i]*2);
   dzz[i]= 2*pi*cos(pi*xx[i]*2);
   ddzz[i]= -2*pi*2*pi*sin(pi*xx[i]*2);
   err = max( err , abs(yy[i]-zz[i]));
   cout << xx[i] << " " << yy[i] << "  ~ " << zz[i] << ",  " << dyy[i] << " ~ " << dzz [i] <<  " , " << ddyy[i] << " " << ddzz[i] <<  endl; 
 }
 //  test out of  bound v 3.50
 // OUT => VALUE AT BOUND ... FH OCT 2015 
 cout << dspline(1,0) << " ==  " << spline(-1) << " " << spline(100) << " == "<< dspline(1,dspline.m-1) << endl; 
 cout << " err = " << err << endl; 
 plot([xx,yy],[xx,zz],cmm= "err = " + err);
 assert(err < 0.3);
bool withmetis=0;
bool RAS=0;
int sizeoverlaps=2; // size off overlap 
int nn=2,mm=2;

func bool AddLayers(mesh & Th,real[int] &ssd,int n,real[int] &unssd)
{
  //  build a continuous function  uussd (P1) :
  //  ssd in the caracteristics function on the input sub domain.
  //  such that : 
  //   unssd = 1 when   ssd =1;
  //   add n layer of element (size of the overlap)
  //   and unssd = 0 ouside of this layer ...
  // ---------------------------------
  fespace Vh(Th,P1);
  fespace Ph(Th,P0);
  Ph s;
  assert(ssd.n==Ph.ndof);
  assert(unssd.n==Vh.ndof);
  unssd=0;
  s[]= ssd;
  //  plot(s,wait=1,fill=1);
  Vh u;
  varf vM(u,v)=int2d(Th,qforder=1)(u*v/area);
  matrix M=vM(Ph,Vh);
  
  for(int i=0;i<n;++i)
    {
      u[]= M*s[];
      // plot(u,wait=1);
      u = u>.1; 
      // plot(u,wait=1);
      unssd+= u[];
      s[]= M'*u[];//';
      s = s >0.1;
    }
  unssd /= (n);
  u[]=unssd;
  ssd=s[];      
  return true;
}

int withplot=3;
mesh Th=square(50,50);
int[int] chlab=[1,1  ,2,1  ,3,1  ,4,1  ];
Th=change(Th,refe=chlab);
int npart= nn*mm;
fespace Ph(Th,P0);
fespace Vh(Th,P1);

Ph  part;
Vh  sun=0,unssd=0;
Ph xx=x,yy=y,nupp;
part = int(xx*nn)*mm + int(yy*mm);
//plot(part,wait=1);
if(withmetis)
  {
    load "metis";
    int[int] nupart(Th.nt);
    metisdual(nupart,Th,npart); 
    for(int i=0;i<nupart.n;++i)
      part[][i]=nupart[i];
  }
if(withplot>1)
plot(part,fill=1,cmm="dual",wait=1);
mesh[int] aTh(npart);
mesh Thi=Th;
fespace Vhi(Thi,P1);
Vhi[int] au(npart),pun(npart);
matrix[int] Rih(npart);
matrix[int] Dih(npart);
matrix[int] aA(npart);
Vhi[int] auntgv(npart);
Vhi[int] rhsi(npart);

for(int i=0;i<npart;++i)
  {
    Ph suppi= abs(part-i)<0.1;
    AddLayers(Th,suppi[],sizeoverlaps,unssd[]);
    Thi=aTh[i]=trunc(Th,suppi>0,label=10,split=1);
    Rih[i]=interpolate(Vhi,Vh,inside=1); //  Vh -> Vhi
    if(RAS)
      {
        suppi= abs(part-i)<0.1;
        varf vSuppi(u,v)=int2d(Th,qforder=1)(suppi*v/area);
        unssd[]= vSuppi(0,Vh);
        unssd = unssd>0.;
        if(withplot>19)
          plot(unssd,wait=1);
      }
    pun[i][]=Rih[i]*unssd[];
    sun[] += Rih[i]'*pun[i][];//';
    if(withplot>9)
      plot(part,aTh[i],fill=1,wait=1);
  }
plot(sun,wait=1,dim=3,fill=1);
for(int i=0;i<npart;++i)
  {
    Thi=aTh[i];
    pun[i]= pun[i]/sun;
    if(withplot>8)
      plot(pun[i],wait=1);    
  }

//  verif partition of unite 

macro Grad(u) [dx(u),dy(u)]//EOM 
  sun=0;

for(int i=0;i<npart;++i)
  {
    cout << " build part :" << i << "/" << npart << endl;
    Thi=aTh[i];
    varf va(u,v) = 
      int2d(Thi)(Grad(u)'*Grad(v))//')
      +on(1,u=1) + int2d(Thi)(v)
      +on(10,u=0) ; 
    
    
    aA[i]=va(Vhi,Vhi);
    set(aA[i],solver="SPARSESOLVER");
    rhsi[i][]= va(0,Vhi);
    Dih[i]=pun[i][];
    real[int]  un(Vhi.ndof);
    un=1.;
    real[int] ui=Dih[i]*un; 
    sun[] += Rih[i]'*ui;;//';
    varf vaun(u,v) = on(10,u=1);
    auntgv[i][]=vaun(0,Vhi); // store arry of tgv on Gamma intern.
  }
if(withplot>5)
  plot(sun,fill=1,wait=1);
cout << sun[].max << " " << sun[].min<< endl;
// verification of the partition of the unite.
assert( 1.-1e-9 <= sun[].min  && 1.+1e-9 >= sun[].max);  

// FFCS: reference value for regression tests
Vh ref;

int nitermax=1000;
{
  Vh un=0;
  for(int iter=0;iter<nitermax;++iter)
    {
      real err=0;
      Vh un1=0;
      for(int i=0;i<npart;++i)
        {
          Thi=aTh[i];
          real[int] ui=Rih[i]*un[];//';
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          real[int] bi = ui .* auntgv[i][];
          bi = auntgv[i][] ? bi :  rhsi[i][];  
          ui=au[i][];
          ui= aA[i] ^-1 * bi;
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          bi = ui-au[i][];
          err += bi'*bi;//';
          au[i][]= ui;
          bi = Dih[i]*ui;
          un1[] += Rih[i]'*bi;//';
        }
      err= sqrt(err);
      cout << iter << " Err = " << err << endl;
      if(err<1e-2) break;
      //    plot(un1,wait=1);
      un[]=un1[];
      if(withplot>2)
        plot(au,dim=3,wait=0,cmm=" iter  "+iter,fill=1 );
    }
  plot(un,wait=1,dim=3,fill=1);
  ref=un;
}
/*
 * Incompressible Navier Stokes
 * with Taylor-Hood Finite element
 * Non linearity : Newton method
 * continuation on Reynols Number
 * Mesh adaptation
*/
if (HaveUMFPACK)
{//  just do with UMPACK fgmres do not converge !!!
load "Element_P3pnc"

// Parameters
real reyini= 500; 
real reymax = 1000;	// ok < 125000

func BCu1 = 4*x*(1-x);
real epsr=1e-6;

// Mesh


mesh Th = square(8, 8);
func PkX = P3pnc;
func PkM = P2dc;

// Fespace
fespace Xh(Th, PkX);
Xh uu1, uu2;
Xh psi, phi;

fespace Mh(Th, PkM);
fespace XXMh(Th, [PkX, PkX, PkM]);
XXMh [u1, u2, p];
XXMh [v1, v2, q];
XXMh [up1, up2, pp];

// Macro
macro div(u1, u2) (dx(u1) + dy(u2)) //
macro grad(u1, u2) [dx(u1), dy(u2)] //
macro ugrad(u1, u2, v) (u1*dx(v) + u2*dy(v)) //
macro Ugrad(u1, u2, v1, v2) [ugrad(u1, u2, v1), ugrad(u1, u2, v2)] //

// Problem Stokes (with solve)
solve Stokes ([u1, u2, p], [v1, v2, q], solver=sparsesolver)
	= int2d(Th,qforder=9)(
		( dx(u1)*dx(v1) + dy(u1)*dy(v1)
		+ dx(u2)*dx(v2) + dy(u2)*dy(v2) )
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);

// Plot
uu1 = u1;
uu2 = u2;
plot(coef=0.2, cmm="[u1, u2] and p" ,p, [uu1, uu2], wait=1);

// Problem stream-lines (with solve)
solve streamlines (psi, phi)
	= int2d(Th,qforder=9)(
		  dx(psi)*dx(phi)
		+ dy(psi)*dy(phi)
	)
	+ int2d(Th,qforder=9)(
		- phi*(dy(u1) - dx(u2))
	)
	+ on(1, 2, 3, 4, psi=0);

// Plot
plot(psi, wait=1);
real nu = 1.;

// Variatonal form definition Navier-Stokes
int i = 0;

varf vDNS ([u1, u2, p], [v1, v2, q])
	= int2d(Th,qforder=9)(
		+ nu * (
			  dx(u1)*dx(v1) + dy(u1)*dy(v1)
			+ dx(u2)*dx(v2) + dy(u2)*dy(v2)
		)
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
		+ Ugrad(u1, u2, up1, up2)'*[v1, v2]
		+ Ugrad(up1, up2, u1, u2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;

varf vNS ([u1, u2, p], [v1, v2, q])	// DF(u)u - F(u)
	= int2d(Th,qforder=9)(
		  Ugrad(up1, up2, up1, up2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;
	real err =0; 
for (real re = reyini ; re <= reymax; re *= 2) {
	real lerr = 1; 
	nu = 1./re;

	if (re > 8000) lerr = 0.2;
	if (re > 10000) lerr = 0.05;
	for (int step = 0; step < 2; step++) {
		// Mesh adaptation & interpolation
		Th = adaptmesh(Th, [dx(u1), dx(u2),dy(u1), dy(u2)], p, err=lerr, nbvx=100000, abserror=0, cutoff=0.01);
		[u1, u2, p] = [u1, u2, p];
		[up1, up2, pp] = [up1, up2, pp];

		// Newton
		for (i = 0; i <= 20; i++) {
			// Update
			up1[] = u1[];

			// Solve
			real[int] b = vNS(0, XXMh);	// build right hand side
			matrix Ans = vDNS(XXMh, XXMh);	// build matrix
			set(Ans, solver=sparsesolver);	// set solver
			u1[] = Ans^-1*b;	// solve linear system

			// Error
			b = u1[]-up1[];
			err = b.l2;
			cout << "iter = "<< i << ", err = " << err << ", rey = " << re << endl;

			// Convergence criteria
			if (err < 1e-4) break;
			if(err > 1e10) break;
		}
		if(err > 1e10) break;
	  
	}
	if(err > 1e10) break;
        
	// Stream-lines
	uu1 = u1;
	uu2 = u2;
	streamlines;
	plot(coef=0.2, cmm="rey="+re+" [u1, u2] and p", psi, [uu1, uu2], wait=0, nbiso=20);
}
}
load "Element_P4"
load "Element_P3"
load "qf11to25"

mesh Th=square(10,10);
mesh3 Th3=cube(10,10,10);
verbosity=4;

for (int i=1;i<=26;i++)
{
  cout <<" int1d order= "<< i ;
  int1d(Th,qforder=i)(1.);
}

for (int i=1;i<=26;i++)
{
 cout <<" int2d order= "<< i ;
  int2d(Th,qforder=i)(1.);
}

for (int i=1;i<=14;i++)
{
 cout <<" int3d order= "<< i ;
  int3d(Th3,qforder=i)(1.);
}

verbosity=1;

 fespace Vh(Th,P4);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf11pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf25pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP4.eps",value=true);

  real[int,int] qq1=[ [0.5,0],
                      [0.5,1]];
  real[int,int] qq2=[[1./3,0,0],[1./3.,1,0],[1./3.,0,1]];
  real[int,int] qq3=[[1./4,0,0,0],[1./4.,1,0,0],[1./4.,0,1,0],[1./4.,0,0,1]];

  QF1 qf1(1,qq1);
  QF2 qf2(1,qq2);
  QF3 qf3(1,qq3);
  real I1 = int1d(Th,qfe=qf1)(x^2) ;
  real I1l = int1d(Th,qfe=qf1pElump)(x^2) ;

  real I2 = int2d(Th,qft=qf2)(x^2) ;
  real I2l = int2d(Th,qft=qf1pTlump)(x^2) ;

  cout << I1 << " == " << I1l << endl;
  cout << I2 << " == " << I2l << endl;
  assert( abs(I1-I1l) < 1e-10);
  assert( abs(I2-I2l) < 1e-10);

load "Element_P3dc"
load "Element_P2pnc"
func real cc(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];

real[int] xx=[0,1,0,0],yy=[0,0,1,0],zz=[0,0,0,1];
 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);


//Th = movemesh(Th,[x+0.1*y,y-0.2*x]);
//Th = movemesh(Th,[x*2,y*2]);

mesh Thg = trunc(Th,1,split=2,label=-1);
plot(Th, wait=1);

int it0=0; 

fespace Lh(Th,P1);
Lh[int] l(3);
l[0][][0]=1;
l[1][][1]=1;
l[2][][2]=1;


fespace Wh(Th,P3dc);
fespace Vh(Th,P2pnc);
Vh u,v;
for (int j=0;j<Vh.ndofK;++j)
{
	int i = Vh(0,j);
	cout << j << " -> " <<  i << " : " ;
    u=0;
	u[][i]=1;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		cout << cc(int1d(Th,k)(u*l[i1]/lenEdge)) << " " << cc(int1d(Th,k)(u*l[i2]/lenEdge)) << " "; 
	}
	cout << cc(int2d(Th)( u/area)) << endl; 
	//plot(u,wait=1);
	v=u;
	for (int j=0;j<Vh.ndofK;++j)
	cout << cc(v[][Vh(0,j)]) << " " ;
	cout << endl;

}
 Th=square(10,10);
 u=x*x*y*y;
 
 solve PL2(u,v)=int2d(Th,qforder=7)(u*v)-int2d(Th,qforder=7)(x*x*y*y*v);

 plot(u,wait=1);
 real err=0,err1=0,err2=0; 
for (int i=0;i<Vh.ndof;++i)
{
    u=0;

	u[][i]=1;
	Wh u3=u;
	v=u;
	v[]-=u[];
	err += v[].linfty;
	err1 += sqrt(int2d(Th)(square(dx(u)-dx(u3))));
	err2 += sqrt(int2d(Th)(square(dy(u)-dy(u3))));
}
cout << " err=" << err << " " << err1 << " " << err2 << endl; 
assert( err+err1+err2 < 1e-10);
// file tetgencube.edp
load "tetgen"
load "medit"

real x0,x1,y0,y1;
x0=1.; x1=2.; y0=0.; y1=2*pi;
mesh Thsq1 = square(5,35,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

int[int] ref31h = [0,12];
int[int] ref31b = [0,11];

meshS Th31h = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1max],region=ref31h,orientation=1);
meshS Th31b = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1min],region=ref31b,orientation=-1);   

//medit("haut",Th31h);
//medit("bas",Th31b);

/////////////////////////////////
x0=1.; x1=2.; y0=0.; y1=1.5;
mesh Thsq2 = square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

int[int] ref32h = [0,13];
int[int] ref32b = [0,14];

meshS Th32h = movemesh23(Thsq2,transfo=[XX2,YY2max,ZZ2],region=ref32h,orientation=-1);  
meshS Th32b = movemesh23(Thsq2,transfo=[XX2,YY2min,ZZ2],region=ref32b,orientation=1);

/////////////////////////////////
x0=0.; x1=2*pi; y0=0.; y1=1.5;
mesh Thsq3 = square(35,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
func XX3min = 1.;
func XX3max = 2.;

func YY3 = x;
func ZZ3 = y;

int[int] ref33h = [0,15];
int[int] ref33b = [0,16];

meshS Th33h = movemesh23(Thsq3,transfo=[XX3max,YY3,ZZ3],region=ref33h,orientation=1);  
meshS Th33b = movemesh23(Thsq3,transfo=[XX3min,YY3,ZZ3],region=ref33b,orientation=-1); 

////////////////////////////////
meshS Th33 = Th31h+Th31b+Th32h+Th32b+Th33h+Th33b; // "gluing" surface meshs to obtain the surface of cube
//medit("glumesh",Th33);
savemesh(Th33,"Th33.mesh");

// build a mesh of a axis parallel box with TetGen
//real[int] domaine = [1.5,pi,0.75,145,0.001];
//mesh3 Thfinal = tetg(Th33,switch="pqaAAYYQ",nbofregions=1,regionlist=domaine);    // Tetrahelize the interior of the cube with tetgen
//medit("tetg",Thfinal);
//savemesh(Thfinal,"Thfinal.mesh");


// build a mesh of a half cylindrical shell of interior radius 1. and exterior radius 2 and heigh 1.5
func mv2x = x*cos(y);
func mv2y = x*sin(y);
func mv2z = z;
//mesh3 Thmv2 = movemesh3(Thfinal, transfo=[mv2x,mv2y,mv2z]);
//savemesh(Thmv2,"halfcylindricalshell.mesh");
verbosity=2;
meshS Thmv2surf = movemesh(Th33, [mv2x,mv2y,mv2z], removeduplicate=0);
cout << "\b\b Thmv2surf.measure=" << Thmv2surf.measure << endl;
cout << " Thmv2surf.bordermeasure=" << Thmv2surf.bordermeasure << endl;

medit("maiAllagesurf",Thmv2surf,wait=1);
//savemesh(Thmv2surf,"maillagesurfacecylindre.mesh");
//medit("maillageplein",Thmv2);



load "BernardiRaugel"
// a macro the compute numerical derivative
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-7;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P2BR);

Vh [a1,a2],[b1,b2],[c1,c2];


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  plot([a1,a2], wait=1); 
  [b1,b2]=[a1,a2];// do the interpolation


  c1[] = a1[] - b1[];
  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;
  assert(c1[].max < 1e-9 && c1[].min > -1e-9); // check if the interpolation is correct

 //  check the derivative and numerical derivative
 

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-5);
  assert( abs(dx(a2)(x1,y1)-DD(a2,h,0) ) < 1e-5);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-5);
  assert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-5);


} 

load "shell"
cout << "pwd = " << getcwd()<< endl;// add version 4.9.1
Directory  c=".";
string ttoto="/tmp/toto";
while(1)
{
	string n=readdir(c);
	if( n != "") 
	  cout << n << " " << isdir(n) << endl; 
	else break; 
}

cout << " login " << getenv("LOGIN") << endl;
setenv("FF_TOTO","toto");
cout << " FF_TOTO  " << getenv("FF_TOTO") << endl;
string pwd=getenv("PWD");
verbosity=3;
cout << " FILE: " <<FILE << endl;
cpfile(FILE,"/tmp");
cout << "basename " << basename(pwd) << endl; 
cout << "dirname " << dirname(pwd) << endl; 
cout << isdir(ttoto) << endl; 
if (isdir(ttoto)<0 )
{
	cout << "mkdir"  << " " << ttoto << endl; 
if  (mkdir(ttoto)==0)
{
	cout << " ls : " ;
	Directory dtoto = "/tmp/toto";
	while(1)
	{
		string n=readdir(dtoto);
		if( n == "") break;
		cout <<  n << " "; 
	}
	cout << endl; 
	cout << " rmdir /tmp/toto" << endl; 
   rmdir("/tmp/toto");//  dir /tmp/toto must be  empty 
}
}
load "ff-Ipopt";

int NN=10;

mesh Th = square(NN,NN);
fespace Vh(Th,P1);
{  // verif no thresholding in operation 1*A; 
	macro grad(u) [dx(u),dy(u)]//
	varf a(u,v) = int2d(Th)(grad(u)'*grad(v));
	matrix A = a(Vh,Vh);
	matrix A1 = 1.*A;
	assert(A.nnz == A1.nnz ); 
}  // end verification 


func f=1;
func g=0;

varf Poiss(u,v) = int2d(Th)(0.5*dx(u)*dx(v) + 0.5*dy(u)*dy(v)) - int2d(Th)(v*f);
varf dPoiss(u,v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) ;
matrix A = Poiss(Vh,Vh);
matrix dA = dPoiss(Vh,Vh);
real[int] b = Poiss(0,Vh);

varf Bord(u,v) = int1d(Th,1,2,3,4)(0.5*u*v) - int1d(Th,1,2,3,4)(v*g);
varf dBord(u,v) = int1d(Th,1,2,3,4)(u*v);
real intg2 = int1d(Th,1,2,3,4)(0.5*g*g);


matrix M = dBord(Vh,Vh);
real[int] bc= Bord(0,Vh);



//cout << M << endl;
//matrix M = Bord(Vh,Vh);

int iter=0;

func real J(real[int] &X)
{
	Vh u;
	u[]=X;
	real[int] Au = A*X;
	Au += b;
	real res = X '* Au;
	plot(u,dim=3,fill=1,cmm="res = "+res+" - iter="+(iter++));
	return res;
}

int nj=0;
func real[int] dJ(real[int] &X)
{
	real[int] Au = dA*X;
	//Au *= 2.;
	Au += b;
	return Au;
}

int nh=0;

matrix MH;
func matrix HJ(real[int] &X,real objfact,real[int] &lm) 
{
	int[int] ia(0),ja(0),ic(0),jc(0);
	real[int] ca(0),cc(0);
	[ia,ja,ca] = dA;
	[ic,jc,cc] = M;
	ca *= (objfact ? objfact : 0.0001);
	cc *= (lm[0] ? lm[0] : 0.0001);
	matrix odA = [ia,ja,ca];
	matrix lmM = [ic,jc,cc];
	MH = odA + lmM;
	return MH;
}
//func matrix HJ(real[int] &X) {return dA;}
//out << dA << end;
int nc=0;
func real[int] C(real[int] &X)
{
	real[int] res=M*X;
	res *= 0.5;
	res += bc;
	real result = X '* res;
	result += intg2;
	real[int] rrr = [result];
	return rrr;
}

int ndc=0;
matrix MdC;
for(int i=0;i<Vh.ndof;++i)
{
	Vh xx=0.;
	xx[][i] = 1.;
	real[int] Mxx = M*xx[];
	real[int,int] MMxx(1,Mxx.n);
	MMxx(0,:) = Mxx;
	matrix MMMxx = MMxx;
	matrix temp = MMMxx;
	if(i==0) MdC = MMMxx;
	else MMMxx = MdC + temp;
	MdC = MMMxx;
}
cout << MdC << endl;
int[int] imdc(0),jmdc(0);
real[int] cmdc(0);
[imdc,jmdc,cmdc] = MdC;
func matrix dC(real[int] &X)
{
	real[int] res = M*X;
	res += bc;
	real[int,int] mdc(1,X.n);
	mdc(0,:) = res;
	for(int i=0;i<res.n;++i) if(res[i]) MdC(0,i) = res[i];
	
	return MdC;
}
//cout << borders << endl;
real[int] Clb(1),Cub(1);
Clb=0.;
Cub=0.;
Vh start=0.;//x*(x-1)*y*(1-y);

real[int] xub(Vh.ndof),xlb(Vh.ndof);
xub=1.e19;
xlb=-1.e19;
//xub = xub .* inside;
//xlb = xlb .* inside;
//cout << "J=" << J(start[]) << endl << " dJ=" << dJ(start[]) << endl << " HJ=" << HJ(start[]) << endl << " C=" << C(start[]) << endl << " dC=" << dC(start[]) << endl;
//cout << "dC = " << dC(start[]) << endl;

//IPOPT(J,dJ,HJ,start[],ConstFunc=C,ConstGrad=dC,clb=Clb,cub=Cub);
/*
real[int] lll=[0.];
cout << HJ(start[],1.,lll) << endl;
lll[0] = 1.;
cout << HJ(start[],0.,lll) << endl;*/


IPOPT(J,dJ,HJ,C,dC,start[],ub=xub, lb=xlb,cub=Cub,clb=Clb);

Vh uff,v;
solve LaplaceFF(uff,v) = int2d(Th)(dx(uff)*dx(v) + dy(uff)*dy(v)) - int2d(Th)(v*f) + on(1,2,3,4,uff=0);
real nl2 = sqrt(int2d(Th)(square(uff-start))), ninf = sqrt(int2d(Th)(square(dx(uff)-dx(start)) + square(dy(uff)-dy(start))));
cout << "||ipopt - ff||_2 = " << nl2 << "   ||grad||_2 = "  << ninf << endl;
// UNCHECK-FILE
/*

 Example of coupling c program and freemfem++ script
 with mmap and semaphore

 the c code is    :   ffmaster.c
 the ff++ code is : ffslave.edp
 and here FreeFEM is a slave process
  the compile step is

 cc -c libff-mmap-semaphore.c
 cc ffmaster.c -o ffmaster  libff-mmap-semaphore.o -g
 #build the freefem++ plugin
  ff-c++ -auto ff-mmap-semaphore.cpp
 # launch
 ./ffmaster


 F. Hecht Feb. 2018   Frederic.Hecht@upmc.fr
 */

load "ff-mmap-semaphore"
Psemaphore smff("ff-slave1",0);
Psemaphore smc("ff-master1",0);
Pmmap sharedata("shared-data",1024);
if(verbosity<4) verbosity =0;
mesh Th=square(10,10);
fespace Vh(Th,P1);
Vh u,v;
int[int] Lab=[1,2,3,4];

macro grad(u) [dx(u),dy(u)] //

int status=1;
//Read(sharedata,8,status);
cout << " ff status = "<< status << endl;
real cff,rff;
problem Pb(u,v) = int2d(Th)(grad(u)'*grad(v))-int2d(Th)(cff*v)+ on(Lab,u=0);
if(verbosity>9) cout << " ff: before ff post\n";
Post(smff); // un lock master fin init


while( 1)
{
	if(verbosity>9) cout << " ff: before ff wait \n";
	Wait(smc); // wait from cint ecriture ok
	Read(sharedata,0,cff);
	Read(sharedata,8,status);


	cout << " After wait ..  ff "<< cff << " " << status << endl;
	if(status<=0) break;
	Pb;
	rff = int2d(Th)(u*u);
	cout << " ** ff "<< cff << " " << rff << endl;

	Write(sharedata,16,rff);
	Post(smff); // unlock cc
}

Post(smff); // wait from cint
cout << " Fin FreeFEM "<< endl;
// file tetgenholeregion_rugby.edp
load "tetgen"
load "medit"
verbosity=2;

// Test 1

// data of rugby ball
real Ra=2.; 
real Rb=2.;
real Rc=1.;

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},\frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a ellipsoid
func f1 = Ra*cos(x)*cos(y);
func f2 = Rb*cos(x)*sin(y);
func f3 = Rc*sin(x);
//  partiel derivative of the parametrization DF
func f1x=Ra*sin(x)*cos(y);   
func f1y=-Ra*cos(x)*sin(y);
func f2x=-Rb*sin(x)*sin(y);
func f2y=Rb*cos(x)*cos(y);
func f3x=Rc*cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of prolate ellipsoide
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

cout << "=====================" << endl;
cout << "=====================" << endl;
meshS Th3sph=movemesh23(Th,transfo=[f1min,f2min,f3min],orientation=1);
cout << "=====================" << endl;
cout << "=====================" << endl;
real Rmax  = 2.;
func f1max = Rmax*f1;
func f2max = Rmax*f2;
func f3max = Rmax*f3;
cout << "=====================" << endl;
cout << "=====================" << endl;
meshS Th3sph2=movemesh23(Th,transfo=[f1max,f2max,f3max],orientation=-1);
cout << "=====================" << endl;
cout << "=====================" << endl;
cout << "addition" << endl;
meshS Th3=Th3sph+Th3sph2;
savemesh(Th3sph,"ellipsoide.mesh");

real[int] domain2 = [1.5*Ra,0.,0.,145,0.001,0.,0.,0.,18,0.001];
cout << "==============================" << endl;
cout << " tetgen call without hole " << endl;
cout << "==============================" << endl;
mesh3 Th3fin=tetg(Th3,switch="paAAYYCCV",nbofregions=2,regionlist=domain2);
cout << "=============================" << endl;
cout << "finish: tetgen call without hole" << endl;
cout <<


 "=============================" << endl;
savemesh(Th3fin,"spherewithtworegion.mesh"); 
medit("maillagetwo",Th3fin);

real[int] hole = [0.,0.,0.];
real[int] domain = [1.5*Ra,0.,0.,53,0.001];
cout << "=============================" << endl;
cout << "  tetgen call with hole   " << endl;
cout << "=============================" << endl;
mesh3 Th3finhole=tetg(Th3,switch="paAAYCCV",nbofholes=1,holelist=hole,nbofregions=1,regionlist=domain);
cout << "=============================" << endl;
cout << "finish: tetgen call with hole   " << endl;
cout << "=============================" << endl;
savemesh(Th3finhole,"spherewithahole.mesh"); 



// Example of dynamic function load
// --------------------------------
// $Id$
//   Discret Fast Fourier Transform 
// -------------------------------
 load "dfft"
 {
int nx=32,ny=32,nz=32,N=nx*ny*nz;
// warning the fourier space is not exactly the unite square due to periodic condition
mesh3 Th=cube(nx-1,ny-1,nz-1,[(nx-1)*x/nx, (ny-1)*y/ny, (nz-1)*z/nz ]);
// warring  the numbering is of the vertices (x,y) is 
// given by $  i = round(x*nx) + nx* round(y*ny) +  nx*ny* round(z*nz);
int nerr=0; 
for(int v=0; v<Th.nv;++v)
{
	P=Th(v).P;
	int i =  round(x*nx) + nx* round(y*ny) +  nx*ny* round(z*nz);
	if( i != v) cout << nerr++ << " err "<< i<< " != "<< v << " "<< P << endl;
	
}
cout << " nerr " << nerr<<endl;
assert(nerr==0);
fespace Vh(Th,P1); 
Vh<complex> u;
 // Lapacien en FFT \hfilll
 // $ -\Delta u = f $ with full periodic condition \hfilll
func f = cos(3*2*pi*x)*cos(2*2*pi*y)*sin(2*pi*z); // 
func ue =  +(1./(square(2*pi)*14.))*cos(3*2*pi*x)*cos(2*2*pi*y)*sin(2*pi*z);  // the exact solution 
Vh<complex> ff = f;
Vh<complex> fhat;
fhat[] = dfft(ff[],ny,nz,-1);

Vh<complex> wij;
// warning in fact we take mode between -nx/2, nx/2 and -ny/2,ny/2
//  thank to the operator ?: \label{?:} 
wij = square(2.*pi)*(  square((x<0.5?x*nx:(x-1)*nx)) 
                     + square((y<0.5?y*ny:(y-1)*ny))
		     + square((z<0.5?z*nz:(z-1)*nz)) );
		    
real c2 = sqr(2*pi);	
//  New wait to set fourier function more simpile 	   
mapkkk(wij[],P,ny,nz,c2*P.norm2);		     
wij[][0] = 1e-5; // to remove constante ..

plot(wij,wait=1);
fhat[] = fhat[]./ wij[];  // 
u[]=dfft(fhat[],ny,nz,1);
u[] /= complex(N);
Vh ur,w;
ur = real(u); // the solution
w = real(ue); // the exact solution 
plot(ur,value=1 ,cmm=" ue   ", wait=1); 
w[] -= ur[]; // array sub
real err= abs(w[].max)+abs(w[].min) ;
cout << " err = " << err << endl;
assert( err  < 1e-6);
}
// test in all dimention ...
 {
int n1=32,n2=32;
mesh Th= square(n1-1,n2-1);
fespace Vh(Th,P1);
Vh<complex> u;
//verbosity=29; 
R3 K; 
mapkk(u[],K,n2,K.norm2);
//cout << u[] << endl; 
plot(u,wait=1);

}
{
int n1=32,n2=32,n3=32;
mesh3 Th= cube(n1-1,n2-1,n3-1);
fespace Vh(Th,P1);
Vh<complex> u;
//verbosity=29; 
R3 K; 
mapkkk(u[],K,n2,n3,K.norm2);
//cout << u[] << endl; 
plot(u,wait=1);

}
{ 
int n1=32;
meshL Th= segment(n1-1);
fespace Vh(Th,P1);
Vh<complex> u;
//verbosity=29; 
R3 K; 
mapk(u[],K,K.norm2);
//cout << u[] << endl; 
plot(u,wait=1);

}

load "MetricPk"

mesh Th=square(3,3,[x,y]);
fespace Metric(Th,[P1,P1,P1]);
Metric [m11,m12,m22];

//fespace Deriv(Th,[P1,P1,P1]);
//Deriv [D1,D2,D3]; 
//m11[]=MetricPk(Th,(x^2+100*y^2)/2,kDeg=1,rDeg=1,Derivatives=D1[]);


fespace Deriv(Th,[P1,P1,P1,P1]);
Deriv [D1,D2,D3,D4]; 
//m11[]=MetricPk(Th,(x^3+2*3*x^2*y+3*3*x*y^2+4*y^3)/6,kDeg=2,rDeg=1,Derivatives=D1[]);
m11[]=MetricPk(Th,(x^3/100+y^3)/6,kDeg=2,rDeg=1,Derivatives=D1[]);

//fespace Deriv(Th,[P1,P1,P1,P1,P1]);
//Deriv [D1,D2,D3,D4,D5]; 
//m11[]=MetricPk(Th,(x^4+2*4*x^3*y+3*6*x^2*y^2+4*4*x*y^3+5*y^4)/24,kDeg=3,rDeg=1,Derivatives=D1[]);
//m11[]=MetricPk(Th,(x^3+2*3*x^2*y+3*3*x*y^2+4*y^3)/6,kDeg=3,rDeg=1,Derivatives=D1[]);

//fespace Deriv(Th,[P1,P1,P1,P1,P1,P1]);
//Deriv [D1,D2,D3,D4,D5,D6]; 
//m11[]=MetricPk(Th,(x^5+2*5*x^4*y+3*10*x^3*y^2+4*10*x^2*y^3+5*5*x*y^4+6*y^5)/120,kDeg=4,rDeg=1,Derivatives=D1[]);
//m11[]=MetricPk(Th,(x^4+2*4*x^3*y+3*6*x^2*y^2+4*4*x*y^3+5*y^4)/24,kDeg=4,rDeg=1,Derivatives=D1[]);


//plot(m11,m12,m22,dim=3,wait=1);
cout << m11[] << endl;
cout << D1[] << endl;

/*
    Test of Incomplete factorization 
    Choleski and LU

    
*/
load "IncompleteCholesky"

int nn=50;
mesh Th=square(nn,nn);
fespace Vh(Th,P1); 
macro grad(u) [dx(u),dy(u)]//
real kconv =0;
complex cc= 1+2i; 
func f = sin(2*pi*x)*sin(2*pi*y);
varf va(u,v) = int2d(Th) (grad(u)'*grad(v) + u*v + kconv*u*dx(v) ) + int2d(Th)( f*v) +on(1,2,3,4,u=0);
varf vac(u,v) = int2d(Th) (cc*grad(u)'*grad(v) + u*v + kconv*u*dx(v) ) + int2d(Th)( f*v) +on(1,2,3,4,u=0);
real teps =1e-8;
if(1)
{
	verbosity=3;
	matrix L ;// to store in incomplet factorizatin. 
	func real[int] PreconIcho(real[int] & b) {// the precondtionner
		icholSolve(L,b);
		return b;}
	
	matrix AI = va(Vh,Vh,solver=CG,precon=PreconIcho);
	matrix A = va(Vh,Vh,solver=CG,sym=1);
	ichol(A,L);//  take the stucture OF a FOR l; 
	real[int] b = va(0,Vh);
	Vh u,ui;
	verbosity = 4;
	real t0=clock();
	u[]= A^-1*b;
	real t1=clock();
	
	ui[]= AI^-1*b;
	real t2=clock();
	cout << " ** GC/  ichol "<< t2-t1 << " GC/diag  " << t1-t0 << " s "<< " ratio = "<<  (t1-t0 )/(t2-t1+teps) << endl;
	plot(u,wait=1);

}
{ // test ILU 
    kconv =50;
	int n = Vh.ndof;
	verbosity=3;
	matrix L,U;// to store in incomplet factorizatin. 
	
	func real[int] PreconILU(real[int] & b) {
		 iluSolve(L,U,b); 
		 return b;}
		 
	matrix AI =	 va(Vh,Vh,solver=GMRES,precon=PreconILU);
	matrix A = va(Vh,Vh,solver=GMRES);
	
	real[int] b = va(0,Vh);
	iLU(AI,L,U);// do the incomplet LU  with sturct of A.
	
    if(nn<10)	
	  cout << "\n\n **L=" << L <<"\n\n  **U " <<  U << endl; 
	Vh u,ui;
	verbosity = 3;
	real t0=clock();
	u[]= A^-1*b;
	real t1=clock();
	ui[]= AI^-1*b;
	real t2=clock();
	cout << " ** GMRES/  iLU "<< t2-t1 << " GMRES/diag  " << t1-t0 << " s "<< " ratio = "<<  (t1-t0 )/(t2-t1+teps) << endl;
	//plot(u,wait=1);
}

{ // test ILU complex ...
	cout << " Complex \n\n" <<endl;
    kconv =50;
    
	int n = Vh.ndof;
	verbosity=3;
	matrix<complex> L,U;// to store in incomplet factorizatin. 
	
	func complex[int] PreconILU(complex[int] & b) {
		 iluSolve(L,U,b); 
		 return b;}
		 
	matrix<complex> AI = vac(Vh,Vh,solver=GMRES,precon=PreconILU);
	matrix<complex> A = vac(Vh,Vh,solver=GMRES);
	
	complex[int] b = vac(0,Vh);
	L=removeHalf(AI,1);  // build the structure of L
		if(nn<10)
    	  cout << " L " <<  L << endl; 
	U=removeHalf(AI,-1); // build the structure of Ut ( transpose of )
	    if(nn<10)	
		  cout << " U " <<  U << endl; 
		
	iLU(AI,L,U);// do the incomplet LU  
	
    if(nn<10)	
	  cout << "\n\n **L=" << L <<"\n\n  **U " <<  U << endl; 
	Vh<complex> u,ui;
	verbosity = 3;
	real t0=clock();
	u[]= A^-1*b;
	real t1=clock();
	ui[]= AI^-1*b;
	real t2=clock();
	cout << " ** GMRES/  iLU "<< t2-t1 << " GMRES/diag  " << t1-t0 << " s "<< " ratio = "<<  (t1-t0 )/(t2-t1+teps) << endl;
	//plot(u,wait=1);
}
load "BernardiRaugel"

// Parameters
real x1 = 0.7;
real y1 = 0.9;
real h = 1e-7;

// Mesh
mesh Th = square(1, 1, [10*(x+y/3), 10*(y-x/3)]);

// Macro
//a macro to compute numerical derivative
macro DD(f, hx, hy) ((f(x1+hx, y1+hy) - f(x1-hx, y1-hy))/(2*(hx+hy))) //

// Fespace
fespace Vh(Th, P2BR);
Vh [a1, a2], [b1, b2], [c1, c2];

for (int i = 0; i < Vh.ndofK; ++i)
	cout << i << " " << Vh(0,i) << endl;

// Test P2BR
int it1 = Th(x1, y1).nuTriangle;
for (int i = 0; i < Vh.ndofK; ++i){
	a1[] = 0;
	int j = Vh(it1, i);
	a1[][j] = 1;
	plot([a1, a2], wait=true);
	[b1, b2] = [a1, a2]; //do the interpolation
	
	c1[] = a1[] - b1[];
	cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;
	cout << " a = " << a1[] << endl;
	cout << " b = " << b1[] << endl;
	assert(c1[].max < 1e-9 && c1[].min > -1e-9); //check if the interpolation is correct
	
	//check the derivative and numerical derivative
	cout << " dx(a1)(x1, y1) = " << dx(a1)(x1, y1) << " == " << DD(a1, h, 0) << endl;
	assert( abs(dx(a1)(x1, y1) - DD(a1, h, 0) ) < 1e-5);
	assert( abs(dx(a2)(x1, y1) - DD(a2, h, 0) ) < 1e-5);
	assert( abs(dy(a1)(x1, y1) - DD(a1, 0, h) ) < 1e-5);
	assert( abs(dy(a2)(x1, y1) - DD(a2, 0, h) ) < 1e-5);
} 

load "Morley"

// Parameter
real f = 1;

// Mesh
mesh Th = square(40, 40); //mesh definition of Omega

// Fespaces
fespace Wh(Th, P2);
fespace Vh(Th, P2Morley);	// HCT finite element space
Vh [u, ux, uy], [v, vx, vy];

// Macro
macro bilaplacien(u, v) (dxx(u)*dxx(v) + dyy(u)*dyy(v) + 2.*dxy(u)*dxy(v))	// end of macro

// Problem
solve bilap ([u, ux, uy], [v, vx, vy])
	= int2d(Th)(bilaplacien(u, v))
	- int2d(Th)(f*v)
	+ on(1, 2, 3, 4, u=0, ux=0, uy=0)
	;

// Plot
plot(u, cmm="u", wait=1, fill=1);
plot(ux, wait=1, cmm="u_x");
plot(uy, wait=1, cmm="u_y");

// Max & Error
Wh uu = u;
real umax = uu[].max;
int err = (abs(umax-0.0012782) > 1e-4);
cout << " uu max = " << umax << " ~ 0.0012782, err = " << err << endl;

// Plot
int n = 100, nn = n+10;
real[int] xx(nn), yy(nn);
for (int i = 0; i <= n; i++) {
	xx[i] = real(i)/n;
	yy[i] = u(0.5, real(i)/n);	// value of uh at point (0.5, i/10.)
}
plot([xx(0:n), yy(0:n)], wait=1);

// End
assert(err == 0);

load "Element_P3"

 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);

real x0=-1.,x1=-0.5;
real y0=-0.5,y1=0.5;

mesh Th1=square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

x0=-0.5;
x1=-0.1;
y0=-1;
y1=1;
mesh Th2=square(10,16,[x0+(x1-x0)*x,y0+(y1-y0)*y]);


int[int] r1=[2,0],  r2=[4,0];
Th1=change(Th1,label=r1);
Th2=change(Th2,label=r2);

plot( Th1, Th2, wait=1 );

verbosity=2;

cout << "================" << endl;
cout << "   gluing mesh  " << endl;
mesh Th2D=Th1+Th2;
cout << "Vertex, Triangle, Border " << Th2D.nv << " "<< Th2D.nt << " " <<  endl; 
//plot( Th2D, wait=1 );
savemesh( Th2D, "glu2D.mesh");


func zmin=0.;
func zmax=1.;
int MaxLayer=10;

mesh3 Th31=buildlayers(Th1,MaxLayer,zbound=[zmin,zmax]); 
savemesh( Th31, "bl31.mesh");

mesh3 Th32=buildlayers(Th2,MaxLayer,zbound=[zmin,zmax]); 
savemesh( Th32, "bl32.mesh");

mesh3 Tht=Th31+Th32;
savemesh( Tht, "glu3D.mesh");

cout << "Vertex, Tet, Triangle " << Tht.nv << " "<< Tht.nt << " " << Tht.nbe << endl; 
cout << "area  border = " << int2d(Tht)(1.) << endl; 
verbosity =3;
Tht = change(Tht,rmInternalFaces=1);
cout << "area  border = " << int2d(Tht)(1.) <<endl;
verbosity =1;
func mv1x = 1+x;
func mv1y = y;
func mv1z = z;
mesh3 Thmvs1 = movemesh3(Tht, transfo=[mv1x,mv1y,mv1z]);
savemesh(Thmvs1,"movemeshglumesh.mesh");
// test of DxWriter  from Sala Lorenzo.
load "DxWriter"
mesh Th=square(5,5);
DxWriter ff("pippo");
Dxaddmesh(ff, Th);
Dxaddtimeseries(ff, "Vx",Th);
fespace Vh(Th, P1);
real t=1.0;
Vh vx=x*y*t;
Dxaddsol2ts(ff,"Vx",t, vx);
t=2.0;
vx=x*y*t;
Dxaddsol2ts(ff,"Vx",t, vx);
cout<<"Hello";
load "ffrandom"
srandomdev();  
//  warning under window this
// change the seed by  randinit(random()) ) so all
// freefem++ random function are change..

cout << random() << endl;
cout << random() << endl;
cout << random() << endl;
srandom(10);
cout << random() << endl;
cout << random() << endl;
cout << random() << endl;


//  august 2015 add 
//  DEF LABEL unit CUBE before transformation 
//  6 face plan label are:
//  y = 0 ) label 1, 
//  x = 1 ) label 2, 
//  y = 1 ) label 3, 
//  x = 0 ) label 4, 
//  z = 0 ) label 5,
//  z = 1 ) label 6.
// the region numbering is 0 by default.
{
	real[int,int] mm= [ [0.5,0.0,0.5], [1.0,0.5,0.5], 
	                    [0.5,1.0,0.5], [0.0,0.5,0.5], 
						[0.5,0.5,0.0], [0.5,0.5,1.0] ];
	int[int] l6=[1,2,3,4,5,6];
	mesh3 Th=cube(2,2,2); //[x*4,y*1+0.1*sin(4*pi*x)]);
	for (int i=1; i< 7; ++i)
	{
		real s = int2d(Th,i)(1.); 
		real mx = int2d(Th,i)(x); 
		real my = int2d(Th,i)(y); 
		real mz = int2d(Th,i)(z); 	
		cout<< i << " " << s <<  " "<< mx << " " << my << " " << mz << endl;
		int j=i-1;
		real err= abs(mx-mm(j,0)) + abs(my-mm(j,1)) + abs(mz-mm(j,2)) ;
		assert(err< 0.1);
	}
}
int[int] l6=[37,42,45,40,25,57];
int r11=11;
mesh3 Th=cube(4,5,6,[x*2-1,y*2-1,z*2-1],label=l6,flags =3,region=r11); 
cout << " volume " << Th.measure << ", border area "<< Th.bordermeasure <<endl; // \index{mesh3!measure} \index{mesh3!bordermeasure}

// Check label dans  region numbering 
int err =0; 
for(int i=0; i<100; ++i)
{
    real s =int2d(Th,i)(1.);
    real sx=int2d(Th,i)(x);
    real sy=int2d(Th,i)(y);
    real sz=int2d(Th,i)(z);
    
    if( s )
    {
     int ix = (sx/s+1.5), iy=(sy/s+1.5), iz=(sz/s+1.5), ii=(ix + 4*(iy+1) + 16*(iz+1) ) ;    
      //  value of ix,iy,iz =>  face min 0 ,  face max 2  , no face 1
      cout <<" label="<< i << " s " << s << " " << ix << iy << iz << " : " << ii << endl; 
      if( i != ii ) err++;
    }
}   
real volr11 = int3d(Th,r11)(1.) ;
cout << " vol region " << 11 << ": " << volr11 << endl; 
if( (volr11 - Th.measure )>1e-8) err++;
plot(Th,fill=0); 
cout << " nb err= " << err <<endl;
assert(err==0); 
// Example of dynamic function load
// --------------------------------
// $Id$

 load "myfunction"
// dumptable(cout);
 mesh Th=square(5,5);
 fespace Vh(Th,P1);
 Vh uh= myfunction(); // warning  do not forget () 
 cout << uh[].min << " " << uh[].max << endl;
 cout << " test io ( " << endl;
 testio();
 cout << " )  end test io .. " << endl;
/*
  Exemple of Mixte furmulation for Lame equation (Linear Elasticity)
   
  The Stress and Strian are  H(div div),  
  for a Sym Stress S we have 
      ( div(div S) in H^-1 
  and S.nn are continuous

  The Displacement u are H(Curl) (    u.tau is continuous )
  where n,tau are normal / tangent 

  This formulation is call TD-NSS
*/
if (HaveUMFPACK) //  need UMPACK  computation 
{
load "Element_Mixte"
load "Element_P3"
int nn=10;
mesh Th= square(nn*4,nn,[x*4,y]);

// caoutchoouc 
//real mu     = 0.012; 
//real lambda = 0.4; 
// rho rho=1e-16;
// ALu
real  mu = 3.8;
real lambda= 6.2;
real rho = 5e-4;
//   s11, s12, s22 
real twomu=mu*2;
real mu1= 1./(twomu);
real lambda1 = 1./(2*(2*lambda+twomu)) - 1./(twomu*2);
macro BItr(a,b)  /* S-> a S + b tr(S) Id */  
[ [ a + b , 0 , 0 ,b       ], 
  [     0 , a , 0 ,0         ], 
  [     0 , 0 , a ,0         ], 
  [   b   , 0 , 0 , a+ b  ]    ] //

func A = BItr(twomu,lambda) ;
func A1 = BItr(mu1,lambda1) ;

real gravity = -9.81*rho;



macro Strain(u)  [dx(u#1),(dy(u#1)+dx(u#2))/2,(dy(u#1)+dx(u#2))/2,dy(u#2)] //EOM
macro Strain2(s)  [s#11, s#12, s#12, s#22] //EOM
macro S(s) [s#11,s#12,s#22]//
  macro U(u) [u#1,u#2] //
  macro dn(u) (U(u)'*[N.x,N.y]) //')
  macro dnn(s) ( [N.x,N.y]' * [[ s#11,s#12] , [s#12, s#22] ] *[N.x,N.y]) //')

fespace Wh(Th,[P2,P2]);
fespace Sh(Th,TDNNS1);
fespace Vh(Th,BDM1Ortho);
Sh S(s),S(t);
Vh U(u),U(v);;
Wh U(w),U(ww);

  solve Lame2([s11,s12,s22,u1,u2],[t11,t12,t22,v1,v2])=
  int2d(Th)( 
	       Strain2(s)'*(A1*Strain2(t)) //' 
	    - Strain(u)'*Strain2(t)  //'
	    - Strain(v)'*Strain2(s) //'
     //      + 1e-6*(u1*v2+u2*v2)
	     )
  +  intalledges(Th)( dnn(t)*dn(u) + dnn(s)*dn(v) ) 
  //  - int1d(Th,4) ( 0*dnn(t) ) // here  0 <=> U_d .n * dnn(t) 
  +  int2d(Th) ( gravity*v2) //-int2d(Th,1,2,3) ( dNtau(t). v.tau) 
  +on(1,2,3,s11=0,s12=0,s22=0)
  +on(4,u1=0,u2=0); 



  solve Lame1([w1,w2],[ww1,ww2])=
  int2d(Th)( 
	      Strain(w)'*(A*Strain(ww)) //' 
	     )
 -int2d(Th)(gravity*ww2)
  +on(4,w1=0,w2=0); 
plot([w1,w2], wait=1);
plot([u1,u2], wait=1);

real errl2 = sqrt(int2d(Th)( square(w1-u1) + square(w2-w2)));
cout << " errL2 = " << errl2 << endl;
}




load "Element_P4"
load "Element_Mixte"
load "Element_PkEdge"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro ccn(f) ( N.x*f#1+N.y*f#2) //
macro cctau(f) ( -N.y*f#1+N.x*f#2) //
macro dnn(f) ( N.x*N.x*f#11+2.*N.y*N.x*f#12+ N.y*N.y*f#22) //
mesh Th=square(1,1,flags=1);//,[10*(x+y/3),10*(y-x/3)]);
Th=trunc(Th,(x+y)<1.1);plot(Th,wait=1);
Th=movemesh(Th,[0.1*(x+y/3),0.1*(y-x/3)]);
Th=movemesh(Th,[0.1*(x),0.1*(y)]);
real x1=0.7,y1=0.9, h=1e-6;
int it1=Th(x1,y1).nuTriangle; 

fespace Zh(Th,P1dc); 
Zh  f11= 1, f12=0, f22=0;

fespace Vh(Th,TDNNS1);
cout << Vh.ndof << endl;
cout << Vh.ndofK << endl;
fespace Eh(Th,P0edge);
fespace Ehdc(Th,P0edgedc);

fespace P3h(Th,[P0,P0,P0]);


Eh  edges;
 macro SS(a) [a#11,a#12,a#22] //

P3h SS(pp);

Vh SS(a),SS(b),SS(c);

varf vFlux([ax11,ax12,ax22],[e]) = intalledges(Th,qforder=1)( dnn(a)*e*lenEdge);
edges=x; 
cout << " x = " << edges[]<< endl; 
edges=y; 
cout << " y = " << edges[]<< endl; 

real gx=1./3., gy(1./3); 


for(int j=0; j<Vh.ndofK;++j)
{int i= Vh(0,j);
 cout << "****" << j << " "  << i << endl; 
 a11[]=0;
 a11[][i]=1;
/*
 x=0; y = 0.5;  N.x = -1; N.y = 0; 
  cout << " ------ dnn (0.,0.5) " << dnn(a) <<  "   " ;
 x=0.5; y = 0.5;  N.x = 1; N.y = 1; 
 cout << " dnn (.5,.5) " << dnn(a) << "     " ;
 x=0.5; y = 0.;  N.x = 0; N.y = -1; 
  cout << " dnn (0.5,0) " << dnn(a) << endl;
  cout << " (0,0.5)  = " << a11(0,0.5) << " " << a12(0,0.5) << " " << a22(0,0.5) << endl;
  cout << " (0.5,0)  = " << a11(0.5,0) << " " << a12(0.5,0) << " " << a22(0.5,0) << endl;
  cout << " (0.5,0.5)  = " << a11(0.5,0.5) << " " << a12(0.5,0.5) << " " << a22(0.5,0.5) << endl;
*/
 // cout << " ...... " << int2d(Th)(a11) << " " << int2d(Th)(a12) << " " <<int2d(Th)(a22) << endl;

// plot(a11,wait=1,cmm="a00 "+i);
// plot(a22,wait=1,cmm="a22 "+i);
// plot(a12,wait=1,cmm="a12 "+i);
edges[]=vFlux(0,Eh);
// cout << a11(gx,gy) << " " << a12(gx,gy) << " " << a22(gx,gy) << " at G "<< " " <<OA
  cout << " ...... " << int2d(Th)(a11) << " " << int2d(Th)(a12) << " " <<int2d(Th)(a22)  << "   --- " ; 
  for(int j=0;j<3;++j)
   cout << edges[](Eh(0,j)) << " " ;
 cout << "   *** Edges flux n.n " << j  << endl;  

}
 
SS(a) =SS(f);
cout << a11[].n << " a = "<< a11[] <<endl; 

 cout << a11(0.6,0.2) << " == " << f11(0.6,0.2) << endl;
 cout << a12(0.6,0.2) << " == " << f12(0.6,0.2) << endl;
 cout << a22(0.6,0.2) << " == " << f22(0.6,0.2) << endl;
 cout << " 00 = " << int2d(Th)(square(a11-f11)) << endl;
 cout << " 00 = " << int2d(Th)(square(a22-f22)) << endl;
 cout << " 00 = " << int2d(Th)(square(a12-f12)) << endl;
//plot(a11,wait=1);

//Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);
//it1=Th(x1,y1).nuTriangle;


for (int i=0;i<Vh.ndofK;++i)
	cout <<  i << " l  -> G " << Vh(0,i) << endl;
 macro diff(err,dd,c,a,s) { real ddd = int2d(Th) (square( dd(a)-dd(c))) ;
  cout << " ddd " << s << " : " <<ddd <<endl;
 if (ddd>1e-10)  err++ ;} //
int err=0;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a11[]=0;	
  int j=Vh(it1,i);
  a11[][j]=1;
  SS(b)=SS(a);
  cout << " b = " << b11[] << endl; 
  b11[]-=a11[];
  edges[]=vFlux(0,Eh);
  cout << "Mean  edges = " << edges[] << "  diff = " << b11[].linfty <<endl; 
  if (b11[].linfty > 1e-10) err++; 
  Zh c11=a11,c12=a12,c22=a22;
 
    
 // plot(a12,wait=1,cmm="a12 "+i );
 // plot(c12,wait=1,cmm="c12 "+i );
  diff(err, ,c11,a11," ");
  diff(err, ,c12,a12," ");
  diff(err, ,c22,a22," ");
  diff(err, dx,c11,a11,"dx");
  diff(err, dx,c12,a12,"dx");
  diff(err, dx,c22,a22,"dx");

  diff(err, dy,c11,a11,"dy");
  diff(err, dy,c12,a12,"dy");
  diff(err, dy,c22,a22,"dy");


  
} 
assert(err==0);
for(int i=0;i<P3h.ndof;++i)
 {
 	cout << " i =" << i << endl;
 	pp11[]=0;
 	pp11[][i]=1;
 	SS(a)=SS(pp);
 	diff(err, ,pp22,a22," ");
 	diff(err, ,pp11,a11," ");
 	diff(err, ,pp12,a12," ");

 }

// FFCS - reference value
real ref;

{
assert(err==0);

NewMacro V(u) [u#1,u#2] EndMacro
NewMacro CheckRT(RT,RTname,xx,yy,pxy,dxxx,V,doassert)
cout << " Check  ***********" << RTname <<  "\n"; 

{
fespace Wh1 (Th,RT);
fespace Ph1 (Th,P1);
fespace Ph2 (Th,P2dc);
fespace Kh (Th,P2);
fespace P4h (Th,P4);
fespace Eh0 (Th,P1nc);
Wh1 V(u), V(w);

int err1=0;
for( int j=0;j<Wh1.ndofK;++j)
{
  int i=Wh1(0,j); 
  u1[] =0;
  u1[][i]=1;
  Ph2 U1=u1,U2=u2;
  U1=u1;
  U2=u2;
  cout << j << " " << i << " int K = " << int2d(Th,qforder=3)(u1) << " --- " << int2d(Th,qforder=3)(u2) << "   ---  " << int1d(Th,qforder=2)( u1*N.x + u2*N.y) << " .. " << err1 <<  endl;
  V(w)=V(u);
  varf veeee(uu,E) = intalledges(Th)( (nTonEdge==2) *E*( jump(dxxx(u))));
  real ddcc=intalledges(Th)( (nTonEdge==2) *square( jump(dxxx(u))));
  if(ddcc > 1e-10) {err1++;  cout << j<< " " << i << " err disc " << ddcc << endl;
  Eh0 eee; eee[]=veeee(0,Eh0);
  plot(eee,cmm=" jump ",fill=1,wait=1); 
   mesh Tg=trunc(Th,1,split=5);
  fespace WWh(Tg,P2dc);
  WWh  gu1=u1,gu2=u2;
   plot([gu1,gu2],wait=1,cmm=" dof "+j+" K=0 ");}
  w1[][i]-=1;
  if(w1[].linfty > 1e-10) { w1[][i]+=1;cout << j << " " << i << " diff = "   << w1[] << " " << err1 << endl;}
  cout << j << " ||w - (\delta_ij)_j=  || " << w1[].linfty << endl;
  assert( w1[].linfty < 1e-10);
  NewMacro diff2(op) int2d(Th)(square(op(u1)-op(U1))+square(op(u2)-op(U2))) EndMacro 
  assert( diff2(  )) ;
  assert( diff2(dx)) ;
  assert( diff2(dy)) ;


}
assert(abs(err1)<1e-10);

Th=square(5,5,[10*(x+y/3),10*(y-x/3)]);
V(u)=[0,0];
V(w)=[0,0];

  P4h p1=pxy;
  P4h uu1 =  1-x+xx*p1;
  P4h uu2 =  2-2*y+yy*p1;


 [u1,u2] = [uu1 ,uu2];
 real eerr1=int2d(Th)( square(uu1-u1) )/ Th.area ,err2=int2d(Th)( square(uu2-u2) )/Th.area;
 real errx1= int2d(Th)( square(dx(uu1)-dx(u1)) )/ Th.area ,errx2=int2d(Th)( square(dx(uu2)-dx(u2)) )/Th.area;
 real erry1= int2d(Th)( square(dy(uu1)-dy(u1)) )/ Th.area ,erry2=int2d(Th)( square(dy(uu2)-dy(u2)) )/Th.area;
 
 cout << "err "+RTname+" "<< eerr1 << " "  << err2  << endl;
 cout << "  dx " <<  errx1 <<" " << errx2 << endl; 
 cout << "  dy " <<  erry1 <<" " << erry2 << endl; 
 plot([u1,u2],wait=1,cmm=RTname);
 real err=eerr1+err2+errx1+errx2+erry1+erry2; 
 if( doassert) assert( err< 1e-6);
for( int i=0;i<Wh1.ndof;++i)
{

  u1[] =0;
  u1[][i]=1;
  V(w)=V(u);
  w1[][i]-=1;
  assert( w1[].linfty < 1e-10);

  // FFCS reference value
  ref=w1[].linfty;
}

cout << " End  Check  ***********" << RTname <<  " Ok .... \n"; 
}
EndMacro
func pxy0=2;
func pxy1=2+x-y*3;
func pxy2 = 2+x+y*2+x*x+2*x*y+-x*x;
CheckRT(RT1,"RT1",x,y,pxy1,ccn,V,1)
CheckRT(RT1Ortho,"RT1Ortho",-y,x,pxy1,cctau,V,1)

CheckRT(RT2,"RT2",x,y,pxy2,ccn,V,1)
CheckRT(RT2Ortho,"RT2Ortho",-y,x,pxy2,cctau,V,1)
CheckRT(BDM1,"BDM1",x,y,pxy0,ccn,V,1)
CheckRT(BDM1Ortho,"BDM1Ortho",-y,x,pxy0,cctau,V,1)
CheckRT(BDM2,"BDM2",x,y,pxy1,ccn,V,1)
//  buggus FH  version 4.13 ??? in test !!!!  
CheckRT(BDM2Ortho,"BDM2Ortho",-y,x,pxy1,cctau,V,1)
	
}
load "ppm2rnm" load "isoline"
string leman="lg.pgm";
real AreaLac =  580.03; // $Km^2$
real hsize= 5;
real[int,int] Curves(3,1);
int[int] be(1);
int nc;// nb of curve
{
  real[int,int] ff1(leman); // read  image and set to an rect. array
  int nx = ff1.n, ny=ff1.m; // grey value between 0 to 1 (dark)
  // build a Cartesian mesh such that the origne is qt the right place.
  mesh Th=square(nx-1,ny-1,[(nx-1)*(x),(ny-1)*(1-y)]);
   // warning  the numbering is of the vertices (x,y) is
   // given by $  i = x/nx + nx* y/ny $
  fespace Vh(Th,P1);
  Vh f1; f1[]=ff1; //  transforme array in finite element function.
  plot(f1,wait=1);
  nc=isoline(Th,f1,iso=0.25,close=1,Curves,beginend=be,smoothing=.1,ratio=0.5);
  verbosity=1;
}
// the longuest isoline
int ic0=be(0), ic1=be(1)-1;
plot([Curves(0,ic0:ic1),Curves(1,ic0:ic1)], wait=1);
int NC= Curves(2,ic1)/hsize;
real xl = Curves(0,ic0:ic1).max-5;
real yl = Curves(1,ic0:ic1).min+5;
border G(t=0,1) {  P=Curve(Curves,ic0,ic1,t);  label= 1 + (x>xl)*2 + (y<yl);}

plot(G(-NC),wait=1);
mesh Th=buildmesh(G(-NC));
plot(Th,wait=1);
real scale = sqrt(AreaLac/Th.area);
Th=movemesh(Th,[x*scale,y*scale]); // resize the  mesh to have the correct scale
cout << " Th.area = " << Th.area << " Km^2 " << " == " << AreaLac <<  "   Km^2 " << endl ;
plot(Th,wait=1,ps="o/leman.eps");
load "Element_Mixte3d"
//load "Element_P1dc1"
/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$

*/
int nn=7;
mesh3 Th=cube(nn,nn,nn);
fespace Wh(Th,P1);
fespace Vh(Th,RT13d);
fespace Ph(Th,P1dc);

func gd = 0.;
func g1n = 1.;
func g2n = 1.;
func g3n = 1.;
func f = 1.;

Vh [u1,u2,u3],[v1,v2,v3];
Ph p,q;
Wh pp,qq;
problem laplaceMixte([u1,u2,u3,p],[v1,v2,v3,q],solver="SPARSESOLVER",eps=1.0e-10,tgv=1e30,dimKrylov=150) =
   int3d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + u3*v3
	   + p*(dx(v1)+dy(v2)+dz(v3)) + (dx(u1)+dy(u2)+dz(u3))*q )
 + int3d(Th) ( f*q)
 - int2d(Th,1,2,3,4,5,6)( gd*(v1*N.x +v2*N.y+ v3*N.z))   //  int on gamma
// + on(4,u1=g1n,u2=g2n,u3=g3n)
 ;
 macro grad(u) [dx(u),dy(u),dz(u)]//
 solve LapP1(pp,qq) = int3d(Th)(grad(pp)'*grad(qq)) - int3d(Th)(f*qq) +on(1,2,3,4,5,6,pp=gd);
 laplaceMixte;
 real err =  int3d(Th)(abs(pp-p));
 cout << "err =" <<  err << " max  "<< pp[].max << " " << p[].max << endl;
 plot(p,wait=1,ps="o/laRTp.eps",value=true);  
 //  BUG after 22 march 2021FH the err increase from 0.005 or 0.01 
 // no raison (possibly due too little chaneg in position of dof ...)
 // err go from 0.002 or 0.006 ????
 assert(err < 0.01);
load "Element_P1bl"
load "splitmesh3"

// 2d OK ???
{
mesh Th=square(1,1);
fespace Vh(Th,P1bl);
cout << Vh.ndofK << " "<< Vh.ndof << endl;
func f=x+2*y+x*(1-x)*y*(1-y)*30;
Vh u=f;
mesh Th2=splitmesh3(Th);
fespace Vh2(Th2,P1dc);
Vh2 u2=u;
Vh2 u2e=f;

plot(u2,u2e,wait=1);
u2[] =- u2e[];
cout << " diff = " << u2[].linfty << endl; 

for(int i=0; i<  Vh.ndof ; ++i)
{
	u[]=0;
	u[][i] = 1;
	u2=u;
	real err1 = int2d(Th2)((dx(u2)-dx(u))^2); 
	real err2 = int2d(Th2)((dy(u2)-dy(u))^2); 
	cout << err1 << " " << err2 << endl; 
	plot(u2,wait=1,cmm="i="+i+" err="+err1+err2 );
	assert(err1+err2< 1e-5); 
}
}

// 3d 

{
mesh3 Th=cube(1,1,1);
fespace Vh(Th,P1bl3d);
fespace Wh(Th,P1b3d);

func f=x+2*y+3*z+x*(1-x)*y*(1-y)*z*(1-z)*100;
Vh u=f;
Wh u2=u;
Vh u2e=f;

plot(u,u2e,wait=1);
u2[] =- u2e[];
cout << " diff = " << u2[].linfty << endl; 
}

int n=10;

/*      Th11
  -----------------	
/Th2 /	|	  /| 
-----------------/ | 
|		|Th5|	| Th6  
|Th1	|  /	|  /
|       |/      | /
-----------------/
        Th22
*/

meshS Th1 = square3(n,n,[2*x,y,1],orientation=-1);
meshS Th2 = square3(n,n,[2*x,y,0],orientation=1);
meshS Th11 = square3(n,n,[2*x,1,y],orientation=1);
meshS Th22 = square3(n,n,[2*x,0,y],orientation=-1);
meshS Th5 = square3(n,n,[1,y,x]);
meshS Th6 = square3(n,n,[2,y,x],orientation=1);

meshS Th = Th1+Th2+Th11+Th22+Th5+Th6;
plot(Th,wait=1);
assert(Th.nbnomanifold==40);

meshS[int] Thglue(6);
Thglue[0] = Th1;
Thglue[1] = Th2;
Thglue[2] = Th11;
Thglue[3] = Th22;
Thglue[4] = Th5;
Thglue[5] = Th6;


meshS Thglued = gluemesh(Thglue);
assert(Thglued.nbnomanifold==40);

plot(Thglued,cmm="2");


load "medit"
load "mmg"

int nn = 15;

mesh3 Th3=cube(nn,2*nn,nn,[x,2*y,z]);

func head = sqrt((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)-0.3;
func ear1 = sqrt((x-0.3)^2+(y-0.5)^2+0.5*(z-0.8)^2)-0.1;
func ear2 = sqrt((x-0.7)^2+(y-0.5)^2+0.5*(z-0.8)^2)-0.1;
func nose = sqrt((x-0.5)^2+0.006*(y-0.9)^2+(z-0.5)^2)-0.03;

fespace Uh(Th3,P1);
Uh Pinocchio = min(min(min(head,ear1),ear2),nose);

Th3 = mmg3d(Th3,metric=Pinocchio[],iso=1,ls=0,hausd=0.008,hgrad=2.3,verbose=10,mem=1000);// 1 G de ram ..
Th3 = buildBdMesh(Th3);
//medit("Th3",Th3);

meshS ThS = Th3.Gamma;
ThS = trunc(ThS,region==10);
ThS = mmgs(ThS,hausd=0.004,hgrad=2.3);
medit("Pinocchio",ThS);
//load "medit"

//load "gmsh"
//load "iovtk"

int n= 10;
int nvb = (n+1)^3 - (n-1)^3;// Nb boundary vertices
int ntb = n*n*12; // Nb of Boundary triangle 
mesh3 Th=cube(n,n,n);
Th = buildBdMesh(Th); // build the surface mesh


int[int] ref2=[1,0,2,0];
mesh3 Thm=change(Th,label=ref2);


meshS Th1 = Th.Gamma;

assert(Th1.nv==602); 
assert(Th1.nt==1200);
assert(Th1.nbe==120);

plot(Th1);
savemesh(Th1, "Th1.mesh");

meshS Th2 = readmeshS("Th1.mesh");

assert(Th1.nv==Th2.nv); 
assert(Th1.nt==Th2.nt);
assert(Th1.nbe==Th2.nbe);
//Validation of Laplace Equation on Torus (Thanks to I. Danaila and G. Sadaka)



real R = 3, r=1; 
real h = 0.2; // 
int nx = R*2*pi/h;
int ny = r*2*pi/h;
func Tx= (R+r*cos(y))*cos(x);
func Ty= (R+r*cos(y))*sin(x);
func Tz= r*sin(y);
macro grad(U) [dx(U)/(R+r*cos(y)),dy(U)/r]//
macro grad3(u) [dx(u),dy(u),dz(u)]  // EOM

// inverse tranformation (Tx,Ty,Tz)
func T1x= atan2(y,x);
func T1y= atan2(z,dist(x,y)-R);
func Jtore = (R+r*cos(y));
// verif transfo inverse : 
cout << " T1x "<< T1x(Tx(0.5,1),Ty(0.5,1),Tz(0.5,1)) << " T1y " << T1y(Tx(0.5,1),Ty(0.5,1),Tz(0.5,1)) << endl;
mesh Th=square(nx,ny,[2*pi*x,2*pi*y]) ;

meshS ThS=movemesh23(Th,transfo=[Tx,Ty,Tz],removeduplicate=1) ;

fespace Vh(Th,P1,periodic=[[1,x],[3,x],[2,y],[4,y]]);
fespace VhS(ThS,P1);
// 
VhS fs = x+y+z;
Vh fh=fs(Tx,Ty,Tz); //  fs on Th 
VhS u,v;
Vh uh;

solve Lap(u,v) = int2d(ThS)( u*v+grad3(u)'*grad3(v)) -int2d(ThS)(fs*v);
plot(u,wait=1,nbiso=20,fill=1);
uh=u(Tx,Ty,Tz);
plot(uh,wait=1);

Vh U,V;

solve Laph(U,V) = int2d(Th)( (U*V+grad(U)'*grad(V))*r*(R+r*cos(y))) -int2d(Th)(fh*V*r*(R+r*cos(y)));

plot(U,uh,wait=1,cmm=" 2 ");
U[] -= uh[];
cout << U[].linfty << endl; 
assert(U[].linfty < 1e-2 );

load "gmsh"

int nn=20;
mesh Th2=square(nn,nn,region=0);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  labelmid=rmid,
  reffaceup = rup,
  reffacelow = rdown);

Th = buildBdMesh(Th); // build the surface mesh
meshS ThS= Th.Gamma;

fespace Vh(ThS,P2);
Vh u,v;

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM
// 
problem Lap3dS(u,v,solver=CG)  =
  int2d(ThS)(Grad3(v)' *Grad3(u)) //') for emacs
  + int1d(ThS,2)(u*v)
  - int2d(ThS)(f*v)
  - int1d(ThS,2) ( ue*v + (uex*N.x +uey*N.y +uez*N.z)*v )
  + on(1,u=ue);
Lap3dS;

plot(u,wait=1);


savegmsh(ThS,"ThS");

 

int nn=100;

mesh Th2=square(nn,nn);
real theta = pi/2;
meshS Th = movemesh23(Th2, transfo=[x, cos(theta)*y-sin(theta)*z, sin(theta)*y+cos(theta)*z]);

func uex=x; func uey=6.*x; func uez=0.;
func uSex=x; func uSey=6.*(cos(theta)*y-sin(theta)*z)-9*x; func uSez=0.;
func f= -18. ;

fespace Vh(Th,P1);
Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM
macro Grad2(u) [dx(u),dy(u)]  // EOM

problem Lap3dS(u,v)  =
  int2d(Th)(Grad3(v)' *Grad3(u))
  + int1d(Th,2)(u*v)  
  - int2d(Th)(f*v) 
  - int1d(Th,2) ((uSex*N.x +uSey*N.y +uSex*N.z)*v )
  + on(1,u=0);
Lap3dS;

plot(u,wait=1);

fespace Vh2(Th2,P1);
Vh2 u2,v2;

problem Lap2d(u2,v2)  =
  int2d(Th2)(Grad2(v2)' *Grad2(u2))
  + int1d(Th2,2)(u2*v2)  
  - int2d(Th2)(f*v2) 
  - int1d(Th2,2) ((uex*N.x +uey*N.y)*v2 )
  + on(1,u2=0);
Lap2d;

cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
cout << " u2 min::   " << u2[]. min << "  max: " << u2[].max << endl;

real[int] err = u[] - u2[];

assert( abs(err.l2) < 1e-6);
plot(u2,wait=1);







int bottombeam = 2;
border a(t=2, 0){x=0; y=t ;label=1;}	// left beam
border b(t=0, 10){x=t; y=0 ;label=bottombeam;}	// bottom of beam
border c(t=0, 2){x=10; y=t ;label=1;}	// rigth beam
border d(t=0, 10){x=10-t; y=2; label=3;}	// top beam
mesh th1 = buildmesh(b(20) + c(5) + d(20) + a(5));
meshS Th=movemesh23(th1,transfo=[x,y,z]);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2.*(1.+sigma));
real lambda = E*sigma/((1.+sigma)*(1.-2.*sigma));
real gravity = -0.05;

cout << "Lambda = " << lambda << endl;
cout << "Mu = " << mu << endl;
cout << "Gravity = " << gravity << endl;

fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
  
solve Lame([u1,u2,u3],[v1,v2,v3])=
  int2d(Th)( lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) )
  - int2d(Th) (gravity*v3)
  + on(1,u1=0,u2=0,u3=0);

real dmax=  u1[].linfty, coef= 1./dmax;

assert(dmax<7.6e-06);
cout << " max deplacement = " << dmax << " " <<coef<<endl;

plot(Th,[u1,u2,u3], wait=1);

// Move mesh
meshS thm = movemesh(Th, [x+coef*u1, y+coef*u2, z+coef*u3]);
plot(Th,thm, wait=1);

include "buildmeshS.idp"
border bc(t=0,2*pi) {  x = 1+cos(t); z= 2+sin(t); y = 3+0.5*sin(5*t);label=1;region=3;}
border bci(t=0,2*pi) {  x = 1+0.5*cos(-t); z= 2+0.5*sin(-t); y = 3+0.1*cos(2*t);label=2;region=4;}
verbosity=1; 
meshL TL= buildmeshL(bc(100)+bci(50));
cout << " TL: regions "<< regions(TL) << endl;
cout << " TL: labels "<< labels(TL) << endl;
meshS Ts=buildmeshSminsurf(TL,1); // minimal  surface 
meshS Tsl=buildmeshSLap(TL,1); // Lapace   surface  
plot(Ts,Tsl,TL,wait=1); 

cout << " TL: regions "<< regions(Ts) << endl;
cout << " TL: labels "<< labels(Ts) << endl;





// Parameters
int nn = 30; // Mesh quality

// Mesh
int[int] labs = [1, 2, 2, 1, 1, 2]; // Label numbering
mesh3 Th = cube(nn, nn, nn, label=labs);
// extract the surface (boundary) of the cube
int[int] llabs = [1, 2]; //  Th = buildSurface(Th); 
meshS ThS = extract(Th,label=llabs);


// Remove the ]0.5,1[^3 domain of the surface cube
ThS = trunc(ThS, (x < 0.5) | (y < 0.5) | (z < 0.5), label=1);
plot(ThS);
// Fespace
fespace Vh(ThS, P1);
Vh u, v;

// Macro
macro Grad(u) [dx(u), dy(u), dz(u)] //

// Define the weak form and solve
solve Poisson(u, v, solver=CG)
    = int2d(ThS)(
          Grad(u)' * Grad(v)
    )
    -int2d(ThS)(
          1 * v
    )
    + on(1, u=0)
    ;

// Plot
plot(u, nbiso=15);
load "medit"
load "ioply"

// Parameters
int nn = 10; // Mesh quality
//example of operator for meshS 

// read the imput mesh, vertice/tetra/triangle/edge 
mesh3 Th3 = cube(nn,nn,nn);
Th3 = buildBdMesh(Th3); // build the surface mesh 
meshS ThS = Th3.Gamma;
//split the extrating surface
//plot(Th3);
meshS ThSsplit = trunc(ThS, 1, split=3);
mesh3 Th3split = trunc(Th3, 1, split=2);
savemesh(Th3split, "Th3split.mesh");

meshS Th3splitG = Th3split.Gamma;

medit("buildFromMesh3Splited",Th3splitG);
medit("buildFromMesh3Initial",ThSsplit);

mesh3 Th3mv = movemesh(Th3,[x+1,y/2,z+y]);
Th3mv=buildBdMesh(Th3mv);
meshS Th3mvG = Th3mv.Gamma;
meshS ThSmv = movemesh(ThS,[x+1,y/2,z+y]);

medit("Th3mvG",Th3mvG);
medit("ThSmv",ThSmv); 

meshS ThS2=plyloadS("plane.ply");
plot(ThS2);
//  version 4.11-1.. 13 sep 2022
meshS Ths = square3(10,10,[x,y,square(2*x-1)+square(2*y-1)]); 
plot(Ths,wait=1);
real[int] gzz;
mesh Th2 = movemesh(Ths,transfo=[x,y,z],getZ=gzz);//  get flat 2d mesh ...
fespace Vh2(Th2,P1);
Vh2 gz; gz[]=gzz;
plot(gz,wait=1);


// c0 lap u + c1 u = f 
// CL u|x=0 = 0
// f = g
// time scheme backward euler 
// [ c0 masse + c1 rigidity ] u^n = fv + rho*epsilon/tau masse  V^n-1
// + [ rho*epsilon/dt^2*(1 + dt alpha) masse + beta*\lambda1/tau rigidity ] u^{n-1}

 
// parameters
real density = 0.9, young = 0.9e5, poisson = 0.4, thickness = 0.1;
real alpha = 0., beta = 0; //(coeff rayleigh)
real dt = 0.0001, iMax = 500.;
//real tgv = 1e30; // a hude value of exact penalisation of boundary condition

func h= sin(pi*x);

real lambda0 = young*thickness/(0.25*(1-poisson*poisson)); 
real lambda1 = young*thickness/(2.*(1.+poisson));   
real c0 = density*thickness/(dt*dt)+lambda0+alpha*density*thickness/dt;
real c1 = lambda1+beta*lambda1/dt;
real a = density*thickness*(1.+dt*alpha)/(dt*dt);
real b = density*thickness/dt;

macro Grad(u) [dx(u),dy(u),dz(u)]  // EOM

// string mesh 
meshS Th=square3(20,50,[x,3.*y,z]);
savemesh(Th,"ThL.mesh");
// FE space
fespace Uh(Th,P1);
Uh u, v, V, uold ;
V=0;uold=0;

func g=10000.; //x^2;//; //10000.
// c0 * mass matrix + c1 stifness matrix
varf m(u,v) = int2d(Th) (u*v);
varf k(u,v) = int2d(Th) (Grad(u)'*Grad(v));
varf mmkk(u,v) = int2d(Th) (c0*u*v + c1*Grad(u)'*Grad(v)) + on(2,u=0);
varf cl(u,v) = on(2,u=0);

matrix mass=m(Uh,Uh);
matrix stifness=k(Uh,Uh);
matrix mk = mmkk(Uh,Uh); //,tgv=tgv,solver="SPARSESOLVER");

varf f(u,v) = int2d(Th)(g*v);
real[int] Force=f(0,Uh);
real[int] CL=cl(0,Uh);
matrix T = a*mass + (beta*lambda1/dt)*stifness;  

//initial condition
u[] = 0;
  
meshS Thmv;
real t=dt;

for (int i=0; i<=iMax; i++) {
	   V[]=(u[]-uold[]);
	   V[]/=dt; 
	   uold[]=u[];
	   //  for the time dependant part
	   real[int] rhs = mass*V[];  	   
	   rhs *= b;
	   rhs += CL;
	   rhs += T*uold[];
	   // apply the external force
	   if(i==1 || i==100)
	   		rhs+=Force;
	   u[] = mk^-1*rhs;
	   t+=dt;
	   // coeff for the visu
	   real coeff=100;
	   Thmv=movemesh(Th,[x,y,u*coeff]);
	   if (verbosity)
	   		cout << " time " << t << " u min "<< u[].min << " u max " << u[].max << endl;
       plot(Th, Thmv, wait=0, cmm=" d = "+t+" iter = "+i,prev=1);


    }


meshS Th=square3(20,20,[x*2*pi,y*2*pi]);
fespace Vh(Th,P1,periodic=[[1,x],[3,x],[2,y],[4,y]]);

func u2e =(sin(x+1)*sin(y+2));
Vh u2,v2,u2h=u2e;
func f2= 2.*u2e;
macro grad3(u) [dx(u),dy(u),dz(u)]//
solve PP2(u2,v2) = int2d(Th)(grad3(u2)'*grad3(v2)+1e-6*u2*v2) - int2d(Th)(f2*v2) ;
plot(u2,u2h,wait=1);
u2[]-=u2h[];

cout << " err 2 = " << u2[].linfty << endl;

assert(u2[].linfty< 0.05);
// test to validate the addition of surfacic finite elements in FreeFEM

load "medit"

/////variational form

/////////////////////////////////
// laplacian 2D
mesh Th = square(10,10);

fespace Vh(Th,P1);
Vh uVar,vVar;
Vh uPb, vPb;
func f = -12.;
func g = P.x*P.x+2.*P.y*P.y;

macro Grad2(uVar) [dx(uVar),dy(uVar)]  // EOM

//with variational form
varf a(uVar,vVar) = int2d(Th)(Grad2(uVar)'*Grad2(vVar))
 + int2d ( Th ) ( f * vVar )
  + on(1,uVar=g);

matrix AVar =a(Vh,Vh);
real[int] bVar = a(0,Vh);
real[int] solVar = AVar^-1*bVar;

// with problem

problem Lap2d(uPb,vPb , solver = CG )  = int2d(Th)(Grad2(uPb)'*Grad2(vPb))
 - int2d ( Th ) ( f * vPb )
  + on(1,uPb=g);
Lap2d;

/////////////////////////////////////
// laplacian Beltrami
// build surface 3D  with Th 2D mesh and move with pi/2 rotation ThSurf
real theta = pi/2;
meshS ThS = movemesh23(Th, transfo=[x, cos(theta)*y-sin(theta)*z, sin(theta)*y+cos(theta)*z]);

fespace VhS(ThS,P1);
VhS uSVar,vSVar;
VhS uSPb,vSPb;

/*(const R3 & P){
    R theta = 3.14; //pi/2.;
    R x=P.x;
    R y=cos(theta)*P.y-sin(theta)*P.z;
    R z=sin(theta)*P.y+cos(theta)*P.z;
    return x*x+2*y*y;} // boundary condition
*/

macro Grad3(uSVar) [dx(uSVar),dy(uSVar),dz(uSVar)]  // EOM

//with variational form
varf aS(uSVar,vSVar) = int2d(ThS)(Grad3(uSVar)'*Grad3(vSVar))
 + int2d ( ThS ) ( f * vSVar )
  + on(1,uSVar=g);
matrix ASVar =aS(VhS,VhS);
real[int] bSVar = aS(0,VhS);
real[int] solSVar = ASVar^-1*bSVar;

// with problem
problem Lap3dS(uSPb,vSPb , solver = CG )  = int2d(ThS)(Grad3(uSPb)'*Grad3(vSPb))
 - int2d ( ThS ) ( f * vSPb )
  + on(1,uSPb=g);
Lap3dS;

savemesh (Th, "Th2D.mesh");
savemesh (ThS, "ThS.mesh");

// check solution for variational forms
real[int] errVar = solVar - solSVar;
cout << "---> norm error l2 for variationnal form " << errVar.l2 << endl;
assert(errVar.l2 < 1e-10);

// check solution with problem
real[int] errPb = uPb[] - uSPb[];
cout << "---> norm error l2 with problem " << errPb.l2;
assert(errPb.l2 < 1e-10);

medit("uSPb",ThS, uSPb);

// test P2b and interpolate 2d->3d surface

fespace Vh2(Th,P2b);
Vh2 u2Var,v2Var;

matrix A2Var =a(Vh2,Vh2);
Vh2 b2Var; b2Var[] = a(0,Vh2);
Vh2 sol2Var; sol2Var[] = A2Var^-1*b2Var[];


ThS=square3(10,10);
fespace Vh2S(ThS,P2b);
Vh2S u2SVar,v2SVar;
matrix A2SVar =aS(Vh2S,Vh2S);
Vh2S b2SVar; b2SVar[] = aS(0,Vh2S);
Vh2S sol2SVar; sol2SVar[] = A2SVar^-1*b2SVar[];

matrix inter=interpolate(Vh2S,Vh2);
Vh2S err2b; err2b[] = inter*sol2Var[];err2b[]-= sol2SVar[];

cout << "---> norm error l2 for variationnal form with P2b" << err2b[].l2 << endl;
assert(err2b[].l2 < 1e-10);

int errT=0; 

macro Test(Th,FE,nFE)
{
int err=0; 	
fespace Wh(Th,FE);
Wh u=x,v,w;

for(int i=0; i< Wh.ndof;++i)
{
	u=0;
	u[][i]=1;
	v=u;
	v[]-=u[];
	err += v[].linfty>1e-7;
}
cout << " ** " << nFE << " Nb err = "<< err<< endl; 
errT += err;
} 
//


meshS ThS=square3(1,1);

Test(ThS,P0,"P0")
Test(ThS,P1,"P1")
Test(ThS,P2,"P2")

//Test(ThS,RT0S,"RT0S");
fespace VhS(ThS,RT0S);
VhS [u1,u2,u3]=[x,y,z], [v1,v2,v3];

for(int i=0; i< VhS.ndof;++i) {
	u1[]=0;
	u1[][i]=1;
plot([u1,u2,u3],wait=1,cmm="3d surf dof="+i,fill=1);

	v1[]=u1[];
	v1[]-=u1[];
	errT += v1[].linfty>1e-7;
}


assert(errT==0);
// basic example io vtk for meshS/meshL
load "iovtk"

mesh Th = square(10,10);
savevtk("Th.vtk",Th,bin=1); 
mesh Th2=vtkload("Th.vtk");
meshS ThS = square3(10,10);

savevtk("ThS.vtk",ThS,bin=0); 
savevtk("ThS.vtu",ThS,bin=1);
meshS ThS2=vtkloadS("ThS.vtk");
plot(Th2);
ThS=buildBdMesh(ThS);
meshL ThL= ThS.Gamma;

savevtk("ThL.vtk",ThL,bin=1); 
savevtk("ThL.vtu",ThL,bin=1); 
meshL ThL2=vtkloadL("ThL.vtk");
/*
Cauchy problem
| Delta u = 0 in Omega
| u = f on Gamma_1 
| du/dn = g on Gamma_1
| u = f on Gamma_2

with  Gamma_0=]0;1]x{1}
Gamma_1=]0;1]x{0}
Gamma_2=d Omega \ (Gamma_0 U Gamma_1)

-->
alternatively solve two problems with well-defined limits, (PC)2n and (PC)2n+1

(PC)2n   | Delta u(2n) = 0 in Omega
		 | u(2n) = v(n) on Gamma_0 
		 | du/dn(2n) = g on Gamma_1
		 | u(2n) = f on Gamma_2
(PC)2n+1 | Delta u(2n+1) = 0 in Omega
		 | du/dn(2n+1) = w(n) on Gamma_0 
		 | u(2n+1) = f on Gamma_1
		 | u(2n+1) = f on Gamma_2
where 
􏰂 v(n) = a(n) (u)2n−1 + (1 − a(n)) v(n−1)
 w(n) = (b)n (du/dn)2n + (1 − b(n)) w(n−1)
    with a(n) and b(n) can be chosen constant or dynamic

*/

macro lap (u,v) (dx(u)*dx(v) + dy(u)*dy(v) + dz(u)*dz(v))//
macro gradn (u) (dx(u)*N.x + dy(u)*N.y + dz(u)*N.z)//


int[int] r=[4,2];
meshS Th = square3(10,10);
Th=change(Th,refedge=r);

fespace Vh(Th,P1);

Vh u, v, w, wn, uprec, uprec2, vprec, vprec2;
Vh uex = cos(x) * cosh(y) + sin(x) * sinh(y);
Vh vn = (1 - x) * uex(0,1,0) + x * uex(1,1,0);
func f = 0.;
real err, eps = 1.e-6;
real erru = 0., errgradv = 0.;
int ii = 0;
real theta = 1.;
real delta = 1.;


problem pair (u,w) = 
	int2d(Th) (lap(u,w))
	- int2d(Th) (f*w)
	- int1d (Th, 1) (gradn(uex)*w)
	+ on (2, u = uex)
	+ on (3, u = vn);

problem impair (v,w) = 
	int2d(Th) (lap(v,w))
	- int2d(Th) (f*w)
	- int1d (Th, 3) (wn*w)
	+ on (1, v = uex)
	+ on (2, v = uex);

err = eps + 1.;

// iterations 1 et 2

pair;

ii++;
wn = dy(u);

impair;

err = sqrt (int1d (Th, 3) ((v-u)^2));

vn = theta*v + (1-theta)*vn;

uprec = u;
uprec2 = u;
vprec = v;
vprec2 = v;

// iterations 3 et 4

pair;

ii++;
wn = delta*dy(u) + (1-delta)*wn;

impair;

err = sqrt (int1d (Th, 3) ((v-u)^2));
theta = ( int1d (Th, 3) ((u-uprec)*(u-uprec-v+vprec)) ) / ( int1d (Th, 3) ((u-uprec-v+vprec)^2) );
vn = theta*v + (1-theta)*vn;

uprec = u;
vprec = v;

// next iterations 

while (err > eps) {
	
	pair;

	erru = sqrt (int1d (Th, 3) ((u-uex)^2));
	errgradv = sqrt (int1d (Th, 3) ((gradn(u)-gradn(uex))^2));
	ii++;

	delta = ( int1d (Th, 3) ((dy(vprec)-dy(vprec2))*(dy(vprec)-dy(vprec2)-dy(uprec)+dy(uprec2))) ) 
	/ ( int1d (Th, 3) ((dy(vprec)-dy(vprec2)-dy(uprec)+dy(uprec2))^2) );

	wn = delta*dy(u) + (1-delta)*wn;
	impair;	

	err = sqrt (int1d (Th, 3) ((v-u)^2));
	theta = ( int1d (Th, 3) ((u-uprec)*(u-uprec-v+vprec)) ) / ( int1d (Th, 3) ((u-uprec-v+vprec)^2) );
	vn = theta*v + (1-theta)*vn;

	uprec2 = uprec;
	uprec = u;
	vprec2 = vprec;
	vprec = v;

}

assert(err < 1e-6);
// écriture à l'écran de l'erreur et du nombre d'itérations

cout << "\n";
cout << "\n";
cout << ii << " iterations pour un ecart de " << err << ".\n";
cout << "Erreur sur u de " << erru << ".\n";
cout << "Erreur sur grad u de " << errgradv << ".\n";

plot (v, cmm = "impair (verification)", value = true);
plot (uex, cmm = "solution exacte", value = true);



















meshS Th=square3(2,2);

  // --------- new stuff -----------------
  int k=0,l=1,e=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int i=0;i<Th.nv;++i)
  cout << i << " : "  << Th(i).x << " "<< Th(i).y << " " << Th(i).z  << endl; 
 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2])
	 << " , label/ region  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<3;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1]   << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 

    R3 O(0.5,0.5,0.5);
    real ss =0;
    for (int k=0;k<Th.nt;++k)
       ss += solidangle(O,Th[k]);
     cout << " solid angle = " << ss << " == 4*pi/6 == " << 4*pi/6 << endl;
    assert( abs(ss-4*pi/6) < 1e-9);
    func real f(R3 A)
    {
	    cout << "P "<< P << " " << nuTriangle << " A = "<< A << endl;
	    return solidangle(A,Th[nuTriangle])/area;
    }
    cout << int2d(Th,qforder=1)(f(O) )<< endl; 
load "Element_Mixte3d"
load "Element_P1dc1"
// never tested ......

/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d,g3d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d,g3d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n,g3n).n$ on $\Gamma_4$

*/

macro divS(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

real theta = pi/2;
meshS ThS = square3(10,10, [x, cos(theta)*y-sin(theta)*z, sin(theta)*y+cos(theta)*z]);
plot(ThS,wait=1);

fespace VhS(ThS,[RT1S,P1dcS]);// bug !!!!!   with RT0 (dim of ThS,[RT0,P0] is wrong 3 not 4 ... 
verbosity=1;

func gd = 1.;
func g1n = 1.;
func g2n = 1.;
func g3n = 0.;
func f = 1.;

VhS [uS1,uS2,uS3,pS], [bS1,bS2,bS3,cS];

varf a([u1,u2,u3,p],[v1,v2,v3,q]) =
   int2d(ThS)( p*q*0e-10+ u1*v1 + u2*v2 + u3*v3 + p*divS(v1,v2,v3) + divS(u1,u2,u3)*q )
 - int2d(ThS) ( f*q)
 + int1d(ThS,1,2,3)( gd*(v1*N.x + v2*N.y + v3*N.z))
 + on(4,u1=g1n,u2=g2n,u3=g3n);


matrix AS=a(VhS,VhS);

set(AS,solver=sparsesolver,eps=1.0e-10,tgv=1e30,dimKrylov=150);
bS1[] = a(0,VhS);
uS1[] = AS^-1*bS1[];

plot([uS1,uS2,uS3], coef=0.1,cmm="u", value=true, wait=1);
plot(pS,fill=1,wait=1,value=true);   


verbosity=0;
real x0=0.0, x1=1.5;
real y0=0.0, y1=2.0;
real xx0=0.5, xx1=1.;
real yy0=0.5, yy1=1.;
int acc,ref, i;
real sH;
ref=10;

border a( t= x0,x1){ x= t ; y= y0; label=1; };
border b( t= y0,y1){ x= x0; y= t ; label=2; };
border c( t= x0,x1){ x= t ; y= y1; label=3; };
border d( t= y0,y1){ x= x1; y= t ; label=4; };
border aa( t= xx0,xx1){ x= t ; y= yy0; label=1; };
border bb( t= yy0,yy1){ x= xx0; y= t ; label=2; };
border cc( t= xx0,xx1){ x= t ; y= yy1; label=3; };
border dd( t= yy0,yy1){ x= xx1; y= t ; label=4; };

//cout << "enter accuracy = ";
//cin >> acc;
acc=0;
// Creation des maillages grossier et fin

//mesh TH=square(ref,ref,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

mesh TH = buildmesh( a(10) + b(-10) + c(-10) + d(+10)
                    +aa(-10) + bb(+10) + cc(+10) + dd(-10) );
plot(TH,wait=1);
end;

{ //    hole 
real pi=4.0*atan(1);
border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;};
border b(t=0,2*pi){ x=0.3+0.3*cos(t); y=0.3*sin(t);label=2;};
mesh Thwithouthole= buildmesh(a(50)+b(+30));
mesh Thwithhole   = buildmesh(a(50)+b(-30));
plot(Thwithouthole,wait=1,ps="Thwithouthole.eps");
plot(Thwithhole,wait=1,ps="Thwithhole.eps");
}
//  bug --
mesh Th=square(1,1);
fespace Vh(Th,P1);
Vh u;
func real  ff( Vh & u) { return u;} 
func real xx(real x){ return x;}
func real yy(func real(real xx)) { return xx(1);}
 
func f=1;
f=2; 
mesh Th=square(10,10);
fespace Vh(Th,P1);
// bug due  to optimisation process .. HARD ....  FH 
Vh u = y ? 1./y : x;
// remark: the sign of p is correct 
// BUG ..... 
bool classique=0;

real s0=clock();
mesh Th=square(10,10);
fespace Vh2(Th,P2);
fespace Vh(Th,P1);
fespace Wh(Th,[P2,P2,P1]);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=1000;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;

real sig = 2*classique-1;

varf vNS([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2)
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th) ( sig*(-alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 ) )
  + on(3,u1=g,u2=0)
  + on(1,2,4,u1=0,u2=0) ;


solve NS ([u1,u2,p],[v1,v2,q],solver="SPARSESOLVER",init=i,save="toto") =   vNS; 

     cout << "-- n " << p[].n << " stokes " << endl;
     cout << "-- u1 : " << u1[].min << " " << u1[].max << endl;
     cout << "-- u2 : " << u2[].min << " " << u2[].max << endl;
     cout << "-- p  : " << p[].min << " " << p[].max << endl;
//plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
dt = 0.1;
int nbiter = 2;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.25^(1./nbiter);
nu=1./reylnods;   
Wh [uu1,uu2,pp];
Wh [vv1,vv2,qq];
Wh [f1,f2,fp];
for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ sig ="<< sig  << endl;
  alpha=1/dt;
  for (i=0;i<=1;i++)
    {
      up1=u1;
      up2=u2;     
      matrix A=vNS(Wh,Wh,solver="SPARSESOLVER");
      //     set(A,solver="SPARSESOLVER"); // set a solver 	
      verbosity=3;
      if(classique) {
	//NS;
	solve NS1 ([uu1,uu2,pp],[vv1,vv2,qq],solver="SPARSESOLVER",init=i,save="toto") =   vNS; 	
      }
      else {
		  [f1,f2,fp]=[0,0,0];
	f1[] = vNS(0,Wh);
	{
	  ofstream tt("tt.matrix");
	  tt << A << endl;
	}
	{
	  ofstream tt("tt.b");
	  tt << f1[]  << endl;
	}
	[uu1,uu2,pp]=[0,0,0];
	cout << uu1[].n << " " << A.n << " x "<< A.m << " "<< f1[].n << endl;
	uu1[]  = A^-1*f1[];
      }
      verbosity=1;
      u1=uu1;
      u2=uu2;
      p = pp;
      
      cout << "-- n " << p[].n << endl;
      cout << "-- u1 : " << u1[].min << " " << u1[].max << endl;
      cout << "-- u2 : " << u2[].min << " " << u2[].max << endl;
      cout << "-- p  : " << p[].min << " " << p[].max << endl;
      
      if ( !(i % 10)) 
	plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
      cout << "CPU " << clock()-s0 << "s " << endl;     
    } 
  
  if (iter>= nbiter) break;
 
  Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],
              abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
//  bug string macro parameter   version < 1.41
// bug in string parameter version before <2.5
// -----------------
 macro tyty(uu) uu//  
cout << tyty("toto") << endl;

// other bug   un func parameter  no correct 

  func string   write(string  fn,real[int] & u)
    {
      cout <<"write :   " <<  fn << " u = "<<  u << endl;  //  delete 2 times before version 2.5 
      return fn; 
    }

  func string   write1(string  fn,real[int] & u)
    {
      cout << "write 1 " << fn << " u = " << u << endl;   
      string toto=fn; ;
      return toto+"dfsdf"; 
    }

 real[int] u(3);
 u=1;

string tt=tyty("toto1"+1+" -- 77");

string t1="0123456789";// write(tt,u);

string t2=  write1(t1,u)+write1(tt,u);

cout << " t2 = " << t2 << endl;

////////////////////////////////////
// Optimisation d'une 'grue'         //
// a volume constant              //
// avec un maillage sous-jacent   //
// qu'on adpate a x^2 et y ^2 mais avec une
// erreur constante //
// plante de temps a autre (depend de niter !!!)
////////////////////////////////////
// Nom du fichier de sauvegarde
string sauve="grue";

// nombre d'iterations
int niter=1;

//nombre de sauvegardes du maillage (<niter)
int nsave=20;

//coefficient d'exageration de la deformation
real exa=1;

//pas
real pas=0.01;

//precision du calcul
real errcalc=0.001;//

//finesse du maillage de structure
real errground=0.01;

//initialisation du compteur des sauvergardes
int nsaved=0;

//compliance
real compliance;

//fonction definissant la zone a optimiser (=1 sur la frontiere optimisable, =0 sinon)
func cutx =(y>1)*(x<4);
func cuty =(y>1)*(x<4);

//definition des bords de la forme
//label =
// 1:Condition de Dirichlet
// 2:Condition Libre
// 3:Condition de Neuman non nulles

border a1(t=8,9) {x=5; y=t;label=3;}; // logement de la charge
border b(t=5,0)  {x=t; y=9;label=2;}; // haut de la grue
border c1(t=1.5,5) {x=t; y=8;label=2;}; //bras de la grue
border d2(t=9,0) {x=-0.5+0.5/9*t; y=t;label=2;}; //cote gauche de la grue
border d1(t=0,8) {x=0.5+t/8; y=t;label=2;} //cote droit de la grue
border e(t=-0.5,0.5) {x=t; y=0;label=1;}; //base de la grue

// forces appliquees 
func g1=0; 
func g2=-1;

// coefficients de Young et de Lame
real lambda=12;
real mu=6;


// coefficients de Lame du materiau
cout <<"lambda,mu ="<<lambda<<","<<mu <<endl; 

// construction du maillage de structure de la forme
mesh Shground= buildmesh(e(5)+d1(20)+c1(10)+a1(5)+b(25)+d2(20));
mesh Sh=Shground;

fespace Vh(Sh,[P1,P1]);
Vh [uu,vv],[w,s];

// Calcul du deplacement de la structure
problem elasticite([uu,vv],[w,s],solver=CG,eps=1.0e-6) =
    int2d(Sh)(
               2*mu*(dx(uu)*dx(w)+dy(vv)*dy(s)+((dx(vv)+dy(uu))*(dx(s)+dy(w)))/2)
              +lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))
	)
    + int1d(Sh,3) (g1*w+g2*s)	
    +on(1,uu=0,vv=0)
;

elasticite;

cout << "adaptation"<<endl;
Sh = adaptmesh  (Sh,[uu,vv],err=errcalc);
plot(Sh,wait=1);

elasticite;//Segmentation Fault !!!
mesh Th = square(10,10); 
fespace Wh(Th,[P2,P2]);	// R2->R2
Wh [F1,F2]; //def de l'inconnu et des fonct tests

F1 = 1;
// il y a un bug ici car dans un element fini vectoriel
// il est impossible defini juste une composante
//  il faut faire:

cout << F1(0.5, 0.6) << endl;
cout << F2(0.5, 0.6) << endl;
cout << F1(0.5, 0.6);
[F1,F2]=[1,2]; 
cout << " -- F1 " <<  F1(0.5, 0.6) << endl;
cout << " -- F2 " << F2(0.5, 0.6) << endl;
// +=====================================================================+
// | Un bug en arithmetique complexe.                                    |
// +---------------------------------------------------------------------+
// | 01/09/02 : Les tableaux de complexes ne sont pas dispos             |
// | 11/09/03, V1.34                                                     |
// |   variable du contexte sont ecrasees c'est le cas de j              |
// |                                                                     |
// +=====================================================================+


   complex z1, z2, j    ;
   real    ReZ, ImZ ;

   j = 0 + 1i ;
   cout << "j = " << j <<" attendu : i" << endl ;

   cout << "trace 1 de j = " << j  << endl ;
   ReZ = 4.5 ; ImZ = 6.7 ; 
   cout << "ReZ = " << ReZ << " attendu : 4.5 " << endl ;
   cout << "ImZ = " << ImZ << " attendu : 6.7 " << endl ;
   cout << "trace 2 de j = " << j  << endl ;
   cout << "Voila, j est ecrase par 0 + (ReZ) i !" << endl ;
   
   cout << endl ;
   cout << "Le meme Pb pour les reels ? " << endl ;

   
   real r1, r2, jR   ;

   jR = 2 ;
   cout << "jR = " << jR <<" attendu : 2" << endl ;

   cout << "trace 1 de jR = " << jR  << endl ;
   ReZ = 4.5 ; ImZ = 6.7 ; 
   cout << "ReZ = " << ReZ << " attendu : 4.5 " << endl ;
   cout << "ImZ = " << ImZ << " attendu : 6.7 " << endl ;
   cout << "trace 2 de jR = " << jR  << endl ;
   cout << "NON jR n'est pas ecrase" << endl ;
   cout << endl ;
 // routine
// bug before  version 1.27 pb passage d'argument
func int myfunction(real  a1)
{
   int i=a1*a1/1;
   return i;
}; 
func real myfunction(real a,real b)
{
   real z =myfunction(a)+b;
   return z;
};
// appele 
cout << myfunction(1.0,3.) << " " << myfunction(1,3)  << endl;
// bug correct in version 1.19
cout << ( 10. < 2 ) << endl;
cout << ( 10. < 2. ) << endl;
mesh Th=square(5,5);
fespace Xh(Th,P2);
Xh v;
v=label;
plot(v,value=1,wait=1);
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface in complex ..
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh<complex> u1,u2;
int n=Vh.ndof; 

complex sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    + int1d(Th)(u1*u2) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix<complex> A= a(Vh,Vh,solver=sparsesolver); 
matrix<complex> B= b(Vh,Vh,solver=sparsesolver); 

func complex[int] FA1(complex[int] & u) { complex[int] Au=A^-1*u;return Au;}
func complex[int] FB(complex[int] & u) { complex[int] Au=B*u;return Au;}
func complex[int] FA(complex[int] & u) { complex[int] Au=A*u;return Au;}
func complex[int] FB1(complex[int] & u) { complex[int] Au=B^-1*u;return Au;}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

complex[int] ev(nev); // to store nev eigein value
Vh<complex>[int] eV(nev);   // to store nev eigen vector


int k=complexEigenValue(n,A1=FA1,B=FB,A=FA,B1=FB1,sigma=sigma,tol=1e-10,maxit=1000,ncv=200,nev=nev,value=ev,vector=eV);
	//,mode=3,which="LM");
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0; 
for (int i=0;i<k;i++)
{
  u1=eV[i];
  complex gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1)) + int1d(Th)(u1*u1);
  complex mm= int2d(Th)(u1*u1) ;
  complex err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) +  int1d(Th)(u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  cout << " ---- " <<  i<< " " << ev[i]  << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=0,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=0);
}

//  laplace with matrix  
verbosity=1;
mesh Th=square(20,20,[2*pi*x,2*pi*y]);
fespace Vh(Th,P2);
Vh u1,u2;
int n=u1.n;
real[int] Bu1(n),Bu2(n);
real[int] Au1(n),Au2(n);

real sigma = 0;                     
real nu=0.1;

varf  op(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0)
;
varf  a(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 )
                    +  on(1,2,3,4,u1=0)
;
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ;//+  on(1,2,3,4,u1=0);


matrix OP= op(Vh,Vh,solver="SPARSESOLVER",factorize=0); 
matrix A= a(Vh,Vh,solver=GMRES); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 
int nev=11;

real[int] ev(nev); // to store 10 eigein value real part
real[int] evi(nev); // to store 10 eigein value imag part
Vh[int] eV(nev);   // to store 10 eigen vector  
/*
 For real nonsymmetric problems, complex eigenvectors are
 given as two consecutive vectors, so if Eigenvalue $k$ and $k+1$ 
 are complex conjugate eigenvalues, 
the vector eV[K] will contain the real part and 
the vector eV[K] the imaginary part of the corresponding 
complex conjugate eigenvectors. 
*/


int k=EigenValue(OP,B,sym=false,sigma=sigma,value=ev,vector=eV,
	         tol=1e-10,maxit=0,ncv=0,ivalue=evi);
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
for (int kk=0;kk<k;kk++)
{ 
  int i=kk;
  u1=eV[i];
  u2=0;
  real er=ev[i],ei=evi[i];
  complex v= er+ei*1i;
  if(ei) { // complex case
    int j=++kk;
    if (j>=k) break; 
    u2 = eV[j];
  }
  cout << " ||u1|| " << u1[].linfty << " || u2|| = " << u2[].linfty << endl;
  Bu1=B*u1[];
  Bu2=B*u2[];
  Au1=A*u1[];
  Au2=A*u2[];
    //  The Rayleigh quotient lambda = x'Ax/x'Bx 
    //  given the eigen value 
  real xBx = u1[]'*Bu1 + u2[]'*Bu2;
  complex xAx = u1[]'*Au1 + u2[]'*Au2 + 1i*(u1[]'*Au2 - u2[]'*Au1);
  complex eigenvalue = xAx/xBx;
  cout << " ---- " <<  i<< " " <<  v <<" eigenvalue= " << eigenvalue << endl;

  // FFCS: add 3D view
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + er + " , " + ei  ,wait=1,value=1,dim=3,fill=1);
}

// FFCS: order of eigenvalues may change, and biggest eigenvalue
// (95.xxx) may not be picked up at all.

real regtest=0;
for(int i=1;i<nev;i++)if(ev[i]<95 && regtest<ev[i])regtest=ev[i];
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh u1,u2;


real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=sparsesolver); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,which="LM"); // which="LM" default 
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
real[int]  eev(36);
eev=1e100;
for(int i=1,k=0;i<6;++i)
for(int j=1;j<6;++j)
  eev[k++]=i*i+j*j;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  if(abs(ev[i]-eev[i]) > 1e-1) nerr++;
  cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,
  //*ps="eigen"+i+".eps",
  dim=3,fill=1,CutPlane=0,ShowAxes=0);
}
assert(nerr==0);
//  Computation of the eigen value and eigen vector of the 
// 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
// Linear elastisitic problem in axisym. model. 
// thank to 
// http://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch02.d/AFEM.Ch02.pdf
//  for the model.
//  the benchmark  case is
// thank form comsol and ansys 
// the comsol sol testcaes:  Eigenfrequency Analysis of a Free Cylinder
// The model is taken from NAFEMS Free Vibration Benchmarks
// 1. F. Abassian, D.J. Dawswell, and N.C. Knowles, Free Vibration Benchmarks, 
// Volume 3, NAFEMS, Glasgow, 1987
//  the comsol data: 
// http://www.comsol.com/model/download/40173/free_cylinder.pdf 
// F. Hecht may 2014 ??
// warning: Axi / 0x   
//  r == y,  
real[int] freqref=[0,243.53,377.41,394.11,397.72,405.28];   
verbosity=0;
real ccc= 1; // coef scale of matrix 
real E =  2.e11*ccc ;// 72e9;
real nu = 0.3;
real rho = 8000*ccc;//2700;//
real freq0 = 100; 
real mu = E/(2.*(1.+nu));
real lambda = E*nu/((1.+nu)*(1.-2.*nu));
real R1 = 1.8, R2 = R1+ 0.4, L = 10;
int nn = 40, nz = 40;
border cc1(t=0,2*pi){ x = R1*cos(t); y=R1*sin(t); }
border cc2(t=0,2*pi){ x = R2*cos(t); y=R2*sin(t); }
int NN = 10; 
mesh Th=square(L*NN,(R2-R1)*NN,[x*L, (1-y)*R1+y*R2]); 
plot(Th, wait=1); 


real shift = 1; // make a shift because 0 mode ... 
real C11=  2*mu  + lambda  ; 
real C12 =  lambda ;
real C44=  2*mu;
func Amat = [  [C11, C12, C12, 0.  ],
               [C12, C11, C12,  0. ],
               [C12, C12, C11,  0. ],
               [0. , 0. , 0.,   C44]
             ];

fespace Vh(Th,[P2,P2]);
Vh [u1,u2], [v1,v2];
func dr=dy; 
func r=y; 

macro Strainaxi(ux,ur)  [dx(ux),dr(ur),ur/r, dr(ux)+dx(ur) ] // EOM
  
varf vLame([u1,u2],[v1,v2])=
  int2d(Th)(  (Strainaxi(v1,v2)'*(Amat*Strainaxi(u1,u2))  
  - ([u1,u2]'*[v1,v2]*rho*shift) )*y )
  ;
varf vMass([u1,u2],[v1,v2])=
  int2d(Th)( ( [v1,v2]'*[u1,u2]*rho )*y );
 
matrix A= vLame(Vh,Vh,solver=sparsesolver); 
matrix B= vMass(Vh,Vh,solver=CG,eps=1e-20); 

int nev=6;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] [eu1,eu2](nev);   // to store nev eigen vector


int k=EigenValue(A,B,sigma=shift,sym=true,value=ev,vector=eu1,tol=1e-20);

k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
for (int i=0;i<k;i++)
{
    real e = ev[i] ;
    real freq = sqrt(abs(e))/(pi*2) ;
    if( abs(freq-freqref[i]) > 0.3) nerr++;
  cout << i << " ev " <<  e << " freq = " << freq  << "Hz, err=" << abs(freq-freqref[i]) <<endl;   
  real coef= 0.5/eu1[i][].linfty;
  mesh Thm=movemesh(Th,[x+eu1[i]*coef,y+eu2[i]*coef]);
  //plot(Th,Thm, wait=1,cmm=i+"/"+k+"coef  amplification = "+coef );
 // medit("Thm-"+ev[i],Thm,wait=1);
 plot(Thm,Th,wait=1,cmm=i+"/"+k+"coef  amplification = "+coef +" freq " + freq + "Hz"  , fill=1);
}
assert(nerr==0);
// test to validate the addition of surfacic finite elements in FreeFEM

load "medit"


/////variational form

/////////////////////////////////
// laplacian 2D
real R = 3, r=1; 
real h = 0.1; // 
int nx = R*2*pi/h;
int ny = r*2*pi/h;
func torex= (R+r*cos(y*pi*2))*cos(x*pi*2);
func torey= (R+r*cos(y*pi*2))*sin(x*pi*2);
func torez= r*sin(y*pi*2);


meshS Th=square3(nx,ny,[torex,torey,torez],removeduplicate=true) ;

fespace Vh(Th,P1);

/*(const R3 & P){
    R theta = 3.14; //pi/2.;
    R x=P.x;
    R y=cos(theta)*P.y-sin(theta)*P.z;
    R z=sin(theta)*P.y+cos(theta)*P.z;
    return x*x+2*y*y;} // boundary condition
*/

macro Grad3(uSVar) [dx(uSVar),dy(uSVar),dz(uSVar)]  // EOM

//with variational form
real sigma = -1; 
varf aS(u,v) = int2d(Th)(Grad3(u)'*Grad3(v)- sigma* u*v);
varf mS(u,v) = int2d(Th)( u*v);
Vh Nx,Ny,Nz;
Vh Mx,My,Mz;
solve Pn([Nx,Ny,Nz],[Mx,My,Mz]) = int2d(Th)( [Nx,Ny,Nz]'*[Mx,My,Mz])- int2d(Th)([Ns.x,Ns.y,Ns.z]'*[Mx,My,Mz]); 

matrix A =aS(Vh,Vh);
matrix B =mS(Vh,Vh,solver=CG);
int nev=100;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,which="LM"); // which="LM" default 

for (int i=0;i<k;i++) 
	plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,dim=3,fill=0,CutPlane=0,ShowAxes=0, nbiso=40);
NoUseOfWait=true;int verbosityy=verbosity;
 cout << "--------- file : BeamEigenValue.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "BeamEigenValue.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : BeamEigenValueperio.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "BeamEigenValueperio.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : LapEigenValue.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "LapEigenValue.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : Stokes-eigen.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "Stokes-eigen.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : neuman.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "neuman.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
//Script for FreeFem++cs  http://www.ann.jussieu.fr/~lehyaric/ffcs/index.htm
//to compute WG eigen vector (magnetic field) and value (wave vector)
// of axially symmetrical dielectric resonators
// See Chaper 9 the example Whispering gallery modes of teh DOC. 


//Developed by I. S. Grudinin at JPL/Caltech
//Copyright 2012 California Institute of Technology. Government sponsorship acknowledged.
//If this script was helpful in a project that resulted in a publication, please cite our paper:
//``Finite element modeling of coupled optical microdisk resonators for displacement sensing,''
//I. S. Grudinin and Nan Yu (2012)
//    J. Opt. Soc. Am. B

//based on "Traceable 2-D finite-element simulation of the whispering-gallery modes of axisymmetric electromagnetic resonators"
//by M. Oxborrow
//IEEE TRANSACTIONS ON MICROWAVE THEORY AND TECHNIQUES  Volume: 55   Issue: 6   Pages: 1209-1218

real radius=36; //approximate radius of the cavity
real yb=-10,yt=-yb; //window yb=bottom and yt=top coordinates
real xl=radius-5,xr=radius+3; //window xl=left and xr=right coordinates
real angle=asin((yt)/radius); //angle of the sphere segment to model in radians
int Nm=60;  	//number of mesh vertices per border 
real ne=1.46; //n_e-extraordinary refractive index (root of permittivity parallel to z-axis, epara)
real no=1.46; //n_o-ordinary refractive index (root of permittivity orthogonal to z-axis, eorto)
real nm=1;     //refractive index of surrounding medium (air)

int nev=4; // number of eigen values to find

int M=213;	//azimuthal mode order ~ 2Pi*n*R/lambda
real alpha=1; 	//penalty term

//describing the mesh:
border W1l(t=0,1) { x=xl+(radius*cos(angle)-xl)*(1-t); y=yt; label=1;}  // window upper border left
border W1r(t=0,1) { x=xr-(xr-radius*cos(angle))*(t); y=yt; label=1;}  	// window upper border right
border W2(t=0,1) { x=xr; y=yb+(yt-yb)*t; label=1;}  			// window right border
border W3l(t=0,1) { x=xl+(radius*cos(angle)-xl)*(t); y=yb; label=1;}  	// window lower border left
border W3r(t=0,1) { x=xr-(xr-radius*cos(angle))*(1-t); y=yb; label=1;}  // window lower border right
border W4(t=0,1) { x=xl; y=yt-(yt-yb)*t; label=1;} 			// window left border
border S(t=0,1) { x=radius*cos((t-0.5)*2*angle); y=radius*sin((t-0.5)*2*angle); label=2;}  //sphere segment
mesh Th = buildmesh(W1r(Nm/4)+W1l(Nm/4)+W4(Nm)+W3l(Nm/4)+W3r(Nm/4)+W2(Nm)+S(Nm));
plot (Th, WindowIndex = 0);


//setting subdomain parameters, i.e. refractive indices of resonator and surrounding air box
fespace Ph(Th, P0);  
Ph reg=region; // function that returns region number of a point XY
int ncav=reg(xl+1, 0);  // cavity
int nair=reg(xr-1, 0);		//air
Ph eorto=no^2*(region==ncav)+nm^2*(region==nair);  //subdomains for epsilon values inside and outside the resonators
Ph epara=ne^2*(region==ncav)+nm^2*(region==nair);  //subdomains for epsilon values inside and outside the resonators

//supplementary variables to store eigenvectors, defined on mesh Th with P2 elements - Largange quadratic.
fespace Supp(Th, P2);
Supp eHsqr;

//3d vector FE space 
fespace Vh(Th,[P2,P2,P2]);
Vh [Hr, Hphi, Hz], [vHr, vHphi, vHz]; //magnetic field components on Vh space and test functions vH

real sigma =(M/(ne*radius))^2+2; // value of the shift (k^2), where the modes will be found

//boundary condition macros
macro EWall(Hr,Hphi, Hz) (dy(Hr)-dx(Hz)+Hr*N.x+Hz*N.y-epara*(Hz*M-dy(Hphi)*x)*N.y+eorto*(Hphi-Hr*M+dx(Hphi)*x)*N.x) // eom
macro MWall(Hr,Hphi, Hz) (Hphi+Hz*N.x-Hr*N.y+epara*(Hz*M-dy(Hphi)*x)*N.x+eorto*(Hphi-Hr*M+dx(Hphi)*x)*N.y ) // eom
//b matrix (see freefem++ manual, section 9 - eigenvalue problems)
varf b([Hr, Hphi, Hz], [vHr, vHphi, vHz]) = int2d(Th)( x*(Hr*vHr+Hphi*vHphi+Hz*vHz) );
// OP = A - sigma B ; // the shifted matrix
varf op([Hr, Hphi, Hz], [vHr, vHphi, vHz])=
int2d(Th)(
(
	(eorto*(vHphi*Hphi-M*(vHphi*Hr+Hphi*vHr)+M^2*vHr*Hr)+epara*M^2*vHz*Hz)/x   //A/r
	+eorto*(dx(vHphi)*(Hphi-M*Hr)+dx(Hphi)*(vHphi-M*vHr))-epara*M*(vHz*dy(Hphi)+Hz*dy(vHphi)) //B
	+x*(eorto*dx(vHphi)*dx(Hphi)+epara*((dx(vHz)-dy(vHr))*(dx(Hz)-dy(Hr))+dy(vHphi)*dy(Hphi))) //C
)/(eorto*epara)
+alpha*(
	(vHr*Hr-M*(vHphi*Hr+Hphi*vHr)+M^2*vHphi*Hphi)/x  //D/r
	+(dx(vHr)+dy(vHz))*(Hr-M*Hphi)+(vHr-M*vHphi)*(dx(Hr)+dy(Hz)) //E
	+x*(dx(vHr)+dy(vHz))*(dx(Hr)+dy(Hz))  //F
)  
-sigma*x*(vHr*Hr+vHphi*Hphi+vHz*Hz)
)
//electric wall boundary condition on the boundary of computation domain
+int1d(Th,1)(EWall(Hr,Hphi,Hz)*EWall(vHr, vHphi, vHz));

//setting sparce matrices and assigning the solver UMFPACK to solve eigenvalue problem
matrix B=b(Vh,Vh,solver="SPARSESOLVER");
matrix OP= op(Vh,Vh,solver="SPARSESOLVER");

real[int] ev(nev); // to store the nev eigenvalue
Vh[int] [eHr,eHphi,eHz](nev); // to store the nev eigenvector
//calling ARPACK on sparce matrices with the assigned solver UMFPACK:
int k=EigenValue(OP,B,sym=true,sigma=sigma,value=ev,vector=eHr,tol=1e-10,maxit=0,ncv=0);

k=min(k,nev); //  sometimes the number of converged eigen values 
              // can be greater than nev;


//file to output mode values
ofstream f("modes.txt");
//setting number of digits in the file output
int nold=f.precision(11);


for (int i=0;i<k;i++)
{
 real lambda=2*pi/sqrt(ev[i]);
 eHsqr=(sqrt(eHr[i]^2+eHphi[i]^2+eHz[i]^2)); // intensity from magnetic field components
 plot(eHsqr,WindowIndex=i, value=1, nbiso=20,LabelColors=1, aspectratio=1, cmm="Mode "+i+", lambda="+lambda+", F="+(299792.458/lambda));
 f << "Mode "<<i<<", ka=" << sqrt(ev[i])*radius << endl;

};
load "lapack"

//  laplace with matrix  
verbosity=1;
int nn=5;
mesh Th=square(nn,nn,[2*pi*x,2*pi*y]);
fespace Vh(Th,P2);
Vh<complex> u1,u2;
Vh ur,ui;
int n=u1.n;
complex[int] Bu1(n),Bu2(n);
complex[int] Au1(n),Au2(n);

real sigma=0.0;                     
complex nu=1.0+1i;

varf op(u1,u2)= int2d(Th)( nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 - sigma* u1*u2 )
              //+ on(1,2,3,4,u1=0)
              ;
varf  a(u1,u2)= int2d(Th)( nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 )
              //+ on(1,2,3,4,u1=0)
              ;
                   
varf b(u1,u2) = int2d(Th)(  u1*u2 
              + 1i*u1*dx(u2)
              );

matrix<complex> OP=op(Vh,Vh,solver=sparsesolver); 
matrix<complex> A=a(Vh,Vh,solver=sparsesolver); 
matrix<complex> B=b(Vh,Vh,solver=sparsesolver); 
int nev=10;

complex[int] ev(nev); // to store eigenvalues 
Vh<complex>[int] eV(nev);   // to store eigenvectors  
  
//int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0); // the default driver is number 4 (M positive definite Hermitian)
int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,driver=2); // driver 2 works when M is arbitrary (non Hermitian)
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
for (int kk=0;kk<k;kk++)
  { 
  int i=kk;	
  u1=eV[i];	
  complex v= ev[i];
  Bu1=B*u1[];
  Au1=A*u1[];
  // The Rayleigh quotient lambda = x'Ax/x'Bx 
  // gives the eigenvalue
  // Vincent Laude, 12/01/2017: don't we need the left and right eigenvectors to form the Rayleigh quotient in the general case? 
  complex xAx = u1[]'*Au1 ;
  complex xBx = u1[]'*Bu1 ;
  //  A u = l * B u
  //Bu1 =   v*Bu1;
  //u1[] = Au1 -Bu1; 
  // Vincent Laude, 12/01/2017: why is a zero sum a good indicator of nullity of a vector? Don't we need a norm instead?
  //if(norm(u1[].sum)>1e-5)
  //      cout << "BUG :::   zero ==  " <<u1[].sum << endl;
  cout << " ---- " <<  i<< " " <<  v << " Rayleigh quotient difference: " << abs(v-xAx/xBx) << endl;
  ur=real(eV[i]);
  ui=imag(eV[i]);
  //  plot(ur,cmm="Eigen  Vector (real)  "+i+" valeur =" + v  ,wait=1,value=1);
  //  plot(ui,cmm="Eigen  Vector (imag)  "+i+" valeur =" + v  ,wait=1,value=1);

  // FFCS: add 3d view
  //plot(eV[i],dim=3,fill=1);
  }
 
// Comparison with lapack (full matrices)
// Doesn't seem to work when the on() condition is used (because of tgv)
complex[int, int] Afull(Vh.ndof,Vh.ndof), Bfull(Vh.ndof,Vh.ndof), EVl(Vh.ndof,Vh.ndof), EVr(Vh.ndof,Vh.ndof);
complex[int] eva(Vh.ndof), evb(Vh.ndof);
int[int] I(1), J(1);
complex[int] C(1);
[I,J,C]=A;
for(int i=0; i<I.n; i++) Afull(I(i),J(i))=C(i);
//cout << Afull << endl;
[I,J,C]=B;
for(int i=0; i<I.n; i++) Bfull(I(i),J(i))=C(i);
//zggev(Afull,Bfull,eva,evb,EVl,EVr);
zggev(Afull,Bfull,eva,evb,EVr);
cout << "\n\n Eigenvalues with LAPACK" << endl;
for (int i=0;i<Vh.ndof;i++) cout << i << " " << eva(i)/evb(i) << endl;
cout << endl;


// Comparison with slepc
// Note: only sigma=0.0 case can be tested
/*
// export matrix A in ascii Morse format
{
  ofstream file("matA.txt");
  file.scientific; 
  file << A << endl;
};	
// converts matrix A to PETSC binary format
exec("ffpp2petsc -fin matA.txt -fout matA.petsc");
// export matrix B in ascii Morse format
{
  ofstream file("matB.txt");
  file.scientific; 
  file << B << endl;
};	
// converts matrix B to PETSC binary format
exec("ffpp2petsc -fin matB.txt -fout matB.petsc");

exec("inveigenpb -f1 matA.petsc -f2 matB.petsc -nval "+nev); 
*/

//  laplace with matrix  
verbosity=1;
mesh Th=square(20,20,[pi*x,pi*y]);
fespace Vh(Th,P2);
Vh<complex> u1,u2;
Vh ur,ui;
int n=u1.n;
complex[int] Bu1(n),Bu2(n);
complex[int] Au1(n),Au2(n);

complex  sigma = 0; //1.000+1i;                     
complex nu=1+1i;

varf  op(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2))  - sigma*u1*u2  )
                    +  on(1,2,3,4,u1=0)
;
varf  a(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2))   )
                    +  on(1,2,3,4,u1=0)
;
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ;//+  on(1,2,3,4,u1=0);


matrix<complex> OP= op(Vh,Vh,solver="SPARSESOLVER"); 
matrix<complex> A= a(Vh,Vh,solver=GMRES); 
matrix<complex> B= b(Vh,Vh,solver=GMRES,eps=1e-20); 
int nev=10;

complex[int] ev(nev); // to store 10 eigen value 
Vh<complex>[int] eV(nev);   // to store 10 eigen vector  

int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,
	         tol=1e-10,maxit=90000,ncv=100);

k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
for (int kk=0;kk<k;kk++)
{ 
  int i=kk;	
  u1=eV[i];	
  complex v= ev[i];
  Bu1=B*u1[];
  Au1=A*u1[];
    //  The Rayleigh quotient lambda = x'Ax/x'Bx 
    //  given the eigen value 
  complex xAx = u1[]'*Au1 ;
  complex xBx = u1[]'*Bu1 ;
  //  A u = l * B u
  Bu1 =   v*Bu1;
  u1[] = Au1 -Bu1; 
  if(norm(u1[].sum)>1e-5)
        cout << "BUG :::   zero ==  " <<u1[].sum << endl;
  cout << " ---- " <<  i<< " " <<  v << endl;
  ur=real(eV[i]);
  ui=imag(eV[i]);
//  plot(ur,cmm="Eigen  Vector (real)  "+i+" valeur =" + v  ,wait=1,value=1);
//  plot(ui,cmm="Eigen  Vector (imag)  "+i+" valeur =" + v  ,wait=1,value=1);

    // FFCS: add 3d view
    plot(eV[i],dim=3,fill=1);
}

//  Eigen Values of Stelov Poincare Problem of Laplacian Operator
// in FreeFEM
int[int] l4=[1,1,1,1];
mesh Th=square(50,50,[x,y],label=l4);
fespace Vh(Th,P1);


macro Grad(u) [dx(u),dy(u)]//
real sigma = 1;//
varf vA(u,v)=int1d(Th)(-sigma*u*v)+int2d(Th)(Grad(v)'*Grad(u)) ; //'
varf vM(u,v)= int1d(Th)(u*v);
matrix A = vA(Vh,Vh,solver=sparsesolver);
matrix B = vM(Vh,Vh);
int nev = 20;
real[int] ev(nev);
Vh[int] eV(nev);
int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV);
k=min(k,nev); //  some time the number of converged eigen value is  greater then nev..
cout << ev <<endl;
for(int i=0;i<k;++i)
 	plot(eV[i],cmm=" vp " + ev[i],wait=1,dim=3,fill=1);
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh u1,u2;
int n=Vh.ndof; 

real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=sparsesolver); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

func real[int] FA(real[int] & u) { real[int] Au=A^-1*u;return Au;}
func real[int] FB(real[int] & u) { real[int] Au=B*u;return Au;}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(n,FA,FB,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
real[int]  eev(36);
eev=1e100;
for(int i=1,k=0;i<6;++i)
for(int j=1;j<6;++j)
  eev[k++]=i*i+j*j;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  if(abs(ev[i]-eev[i]) > 1e-1) nerr++;
  cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,ps="eigen"+i+".eps",dim=3,fill=1,CutPlane=0,ShowAxes=0);
}
assert(nerr==0);
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
int bottombeam = 2;
border aaa(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
border bbb(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
border ccc(t=0,2)  { x=10; y=t ;label=1;};       //  rigth beam
border ddd(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
real E = 21.5;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
mesh Th = buildmesh( bbb(20)+ccc(5)+ddd(20)+aaa(5));
fespace Vh(Th,[P1,P1]);
Vh [uu,vv], [w,s];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 

real shift = -1;  // value of the shift 

varf a([uu,vv],[w,s])=
	int2d(Th)(  
		2*mu*(dx(uu)*dx(w)+dy(vv)*dy(s)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/2 )
               + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))
        - shift* (uu*w + vv*s)      
             )
  + on(1,uu=0,vv=0)
  ;

varf b([uu,vv],[w,s])=
	int2d(Th)(uu*w + vv*s)      ;



matrix A= a(Vh,Vh,solver="SPARSESOLVER"); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] [eV,eW](nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=shift,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for (int i=0;i<k;i++)
{
  [uu,vv]=[eV[i],eW[i]];
  cout << ev[i] << endl; 
  plot([uu,vv],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,ps="eigen"+i+".eps");
}

//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
int bottombeam = 2;
border aaa(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
border bbb(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
border ccc(t=0,2)  { x=10; y=t ;label=4;};       //  rigth beam
border ddd(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
real E = 21.5;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
mesh Th = buildmesh( bbb(20)+ccc(5)+ddd(20)+aaa(5));
fespace Vh(Th,[P1,P1],periodic=[ [bottombeam,x],[3,x],[1,y],[4,y] ]);
Vh [uu,vv], [w,s];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 

real shift = 1;  // value of the shift 

varf a([uu,vv],[w,s])=
	int2d(Th)(  
		2*mu*(dx(uu)*dx(w)+dy(vv)*dy(s)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/2 )
               + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))
        - shift* (uu*w + vv*s)      
             )
//  + on(1,uu=0,vv=0)
  ;

varf b([uu,vv],[w,s])=
	int2d(Th)(uu*w + vv*s)      ;



matrix A= a(Vh,Vh,solver=Crout,factorize=3); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] [eV,eW](nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for (int i=0;i<k;i++)
{
  [uu,vv]=[eV[i],eW[i]];
  plot([uu,vv],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,ps="eigen"+i+".eps");
}

// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(20,20);
fespace Xh(Th,P2);
fespace Mh(Th,P1);
fespace XhxXhxMh(Th,[P2,P2,P1]);

Xh u1,u2;
Mh p;

real alpha=0;
real  nu=1;
int i=0,iter=0;

varf vfStokes ([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + on(1,2,3,4,u1=0,u2=0) 
;
varf b([u1,u2,p],[v1,v2,q]) = int2d(Th)(  u1*v1+u2*v2+p*q*0.) ; // no  Boundary condition

matrix A= vfStokes(XhxXhxMh,XhxXhxMh,solver="SPARSESOLVER",factorize=0); 
matrix B= b(XhxXhxMh,XhxXhxMh,solver=CG,eps=1e-20); 

real sigma=0;
int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
XhxXhxMh[int] [eu1,eu2,ep](nev);   // to store nev eigen vector

int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eu1,tol=1e-10,maxit=0,ncv=0);
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for (int i=0;i<k;i++)
{
  cout << " valeur propre : " << i << "  : " << ev[i] << endl;
  u1=eu1[i];
  u2=eu2[i];
  p=ep[i];

  // FFCS: changed to 3D view
  plot([u1,u2],p,cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,value=1,ArrowSize=-1.6,dim=3,fill=1);
}

cout << "CPU " << clock()-s0 << "s " << endl;     
assert(abs(ev[0]-52.3471) < 0.1); 
mesh Th=square(50,50,[x*pi,y*pi]);
macro grad(u) [dx(u),dy(u)]//
int[int] L=[1,2,3,4];
varf vlapWithBC(u,v)= int2d(Th)(grad(u)'*grad(v))+ on(L,u=0);
varf vlapWithoutBC(u,v)= int2d(Th)(grad(u)'*grad(v));
varf vMass(u,v)= int2d(Th)(u*v);
fespace Vh(Th,P1);
Vh u,v;
u=1; 
matrix Id=u[]; // vMass(Vh,Vh,solver=CG) ;
set(Id,solver=CG,verb=0);
matrix Abc= vlapWithBC(Vh,Vh,solver=sparsesolver);
matrix Ancl= vlapWithoutBC(Vh,Vh,solver=CG);
real[int] aevmin(2),aevmax(2);
int kmin=EigenValue(Abc,Id,sym=true,value=aevmin);
int kmax=EigenValue(Id,Ancl,sym=true,value=aevmax);
real evmin = aevmin(0);
real evmax = 1./aevmax(0);
cout << "VP min = " << evmin << "VP max = " << evmax << " cond number = " << evmax/evmin << endl; 
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on cube  $]0,\pi[^3$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$

int nn=15;
mesh Th2=square(nn,nn,[pi*x,pi*y]);
fespace Vh2(Th2,P1);
int[int] rup=[0,1],  rdown=[0,1], rmid=[4,1,2,1, 1,1 ,3,1];
real zmin=0,zmax=pi;

mesh3 Th=buildlayers(Th2,nn,
		     zbound=[zmin,zmax],
		     // region=r1, 
		     labelmid=rmid, 
		     reffaceup = rup,
		     reffacelow = rdown);
cout << "Th :  nv = " << Th.nv << " nt =" << Th.nt << endl;

fespace Vh(Th,P1);
Vh u1,u2;


real sigma = 00;  // value of the shift 
macro Grad(u) [dx(u),dy(u),dz(u)] // EOM
  varf  a(u1,u2)= int3d(Th)(  Grad(u1)'*Grad(u2)  - sigma* u1*u2 ) //') 
  +  on(1,u1=0.) ;  // Boundary condition
                   
varf b([u1],[u2]) = int3d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver="SPARSESOLVER"); 
cout << " fin A .. " << endl;
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=10;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

int nerr=0;
real[int]  eev(6*6*6);
eev=1e100;
for(int i=1,k=0;i<6;++i)
  for(int j=1;j<6;++j)
    for(int l=1;l<6;++l)
      eev[k++]=i*i+j*j+l*l;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
  {
    u1=eV[i];
    real gg = int3d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) + dz(u1)*dz(u1) );
    real mm= int3d(Th)(u1*u1) ;
    real err = int3d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) + dz(u1)*dz(u1) - (ev[i])*u1*u1) ;
    if(abs(err) > 1e-6) nerr++;
    if(abs(ev[i]-eev[i]) > eev[i]*1e-1) nerr++;
    cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;
    plot(eV[i],cmm="Eigen 3d  Vector "+i+" valeur =" + ev[i]+ " == " + eev[i]    ,wait=1,value=1,ps="eigen"+i+".eps");
  }

// FFCS: avoid this assert because the list of eigenvalues is not
// always sorted in the same way
//assert(nerr==0);
border ccc(t=0,2*pi){x=cos(t);y=sin(t);}
mesh Th=buildmesh(ccc(10));
//mesh Th=readmesh("Th.msh");
fespace Vh(Th,P2);
Vh u1,u2;
real sigma = 1e-5;

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 );

                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=Crout,factorize=3); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector

int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for(int i=0;i<k;i++){
  cout << " Valeur propre " << i << " = " << ev[i] << endl;

  // FFCS: add 3D view
  plot(eV[i],dim=3,fill=1);
}
// test to validate the addition of surfacic finite elements in FreeFEM

load "medit"


/////variational form

/////////////////////////////////
// laplacian 2D
real R = 3, r=1; 
real h = 0.1; // 
int nx = R*2*pi/h;
func torex= (R+r*cos(y*pi*2))*cos(x*pi*2);
func torey= (R+r*cos(y*pi*2))*sin(x*pi*2);
func torez= r*sin(y*pi*2);


meshL Th=segment(nx,[torex,torey,torez],removeduplicate=true) ;
fespace Vh(Th,P1);
macro Grad3(uSVar) [dx(uSVar),dy(uSVar),dz(uSVar)]  // EOM

//with variational form
real sigma = 1; 
varf a(u,v) = int1d(Th)(Grad3(u)'*Grad3(v)- sigma* u*v);
varf m(u,v) = int1d(Th)( u*v);

matrix A =a(Vh,Vh);
matrix B =m(Vh,Vh,solver=CG);
int nev=100;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector

int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,which="LM"); // which="LM" default 

for (int i=0;i<k;i++) 
	plot(eV[i],cmm=" (new plot in test) Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=1, nbiso=40);  

//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh u1,u2;
int n=Vh.ndof; 

real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    + int1d(Th)(u1*u2) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=sparsesolver); 
matrix B= b(Vh,Vh,solver=sparsesolver); 

func real[int] FA1(real[int] & u) { real[int] Au=A^-1*u;return Au;}
func real[int] FB(real[int] & u) { real[int] Au=B*u;return Au;}
func real[int] FA(real[int] & u) { real[int] Au=A*u;return Au;}
func real[int] FB1(real[int] & u) { real[int] Au=B^-1*u;return Au;}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(n,A1=FA1,B=FB,A=FA,B1=FB1,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=1000,ncv=200
	,mode=3,which="LM");
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0; 
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1)) + int1d(Th)(u1*u1);
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) +  int1d(Th)(u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  cout << " ---- " <<  i<< " " << ev[i]  << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=0,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=0);
}

//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
//
// code borrowed from examples/ffddm/heat-torus-3d-surf.edp

load "hpddm"                        // HPDDM plugin
macro dimension()3S// EOM           // 2D, 3D, or 3S
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // two-dimensional gradient
func Pk = P2;                               // finite element space

int s = getARGV("-split", 1);               // refinement factor
real dt = getARGV("-dt", 0.1);              // time step
int iMax = getARGV("-iMax", 50);            // number of iterations

real R = 3, r = 1;
int nx = r*2*pi*getARGV("-global", 5);
int ny = R*2*pi*getARGV("-global", 5);

meshS Th = square3(nx, ny, [(R+r*cos(2*pi*x))*cos(2*pi*y), (R+r*cos(2*pi*x))*sin(2*pi*y), r*sin(2*pi*x)]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
buildMinimalist(Th, intersection, D, Pk)

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> mat;                           // local operator

Wh<real> u = 0;
Wh<real> w = 0;
func f = 100 * exp(-20*(x^2 + (y-(R+r))^2 + z^2));
varf vPb(u, v) = int2d(Th)(u * v + dt * grad(u)' * grad(v)) + int2d(Th)(w * v + f * v);
mat = vPb(Wh, Wh, solver = GMRES);
matrix Neumann = mat;
schwarz A(mat, intersection, D);
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, A = Neumann);
}

for(int i = 0; i < iMax; ++i) {
    rhs = vPb(0, Wh);
    u[] = A^-1 * rhs;
    macro myplot()cmm = "Global solution at iteration " + i, fill = 1, value = 1//
    plotMPI(Th, u, Pk, def, real, myplot);
    w[] = u[];
    mat = vPb(Wh, Wh, solver = GMRES);
    ChangeOperator(A, mat);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro BC(u, val)u = val// EOM       // Dirichlet boundary conditions
func Pk = P1;                       // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d-substructuring.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
int[int] labDirichlet = [1, 3];
{
    int[int] l = [2, 1, 3, 2];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, 10, labDirichlet, labNeumann, s, intersection, Pk, BC, comm, excluded)
}

func f = 10;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(f * v) + on(labDirichlet, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

bdd A(Mat, intersection, communicator = comm);
// this can be replaced by feti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

pair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        AttachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(labDirichlet, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(1);
            Rb[0][] = 1;
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            Wh def(mu) = 1.0;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = mu[]);
        }
        AttachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u) = 0.0;    // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, rhs, u[], excluded = excluded);

if(!excluded)
    OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"                // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat<complex> A;
int s = getARGV("-split", 1);
macro ThRefinementFactor()s//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space

func real wedge(real a, real b) {
    if(y < 0.4 + 0.1 * 0.75 * x)
        return 2;
    else if(y < 0.8 - 0.2 * 0.75 * x)
        return 1.5;
    else
        return 3;
}
real omega = 2 * pi * 5;
func f = 80 * 100 * s * exp(-20 * 100 * s * ((x-0.5)^2 + (y-0.25)^2));
complex[int] rhs(Wh.ndof);                  // local right-hand side
matrix<complex> Loc;                        // local operator
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph val = wedge(x, y);
    Ph k = omega / val;
    varf vPb(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, -111111)(1i * k * u * v) + int1d(Th, 2)(1i * k * u * v) + int2d(Th)(f * v) + on(1, u = 0.0);
    Loc = vPb(Wh, Wh, tgv = -1);
    rhs = vPb(0, Wh, tgv = -1);
}

A = Loc;
if(usedARGV("-optimized_Schwarz") != -1)
    set(A, sparams = "-ksp_view -sub_pc_type lu", O = Loc);
else
    set(A, sparams = "-ksp_view -pc_type lu");
Wh<complex> u;                      // local solution

u[] = A^-1 * rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "medit"
load "PETSc"                        // PETSc plugin
load "parmmg"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

mesh3 Th = cube(getARGV("-global", 30), getARGV("-global", 30), getARGV("-global", 30));
DmeshCreate(Th);
fespace Vh(Th, P1);
{
    mesh3 ThParMmg;
    int[int] n2o;
    int[int][int] communicators;
    ParMmgCreateCommunicators(Th, ThParMmg, n2o, communicators);
    fespace VhParMmg(ThParMmg, P1);
    VhParMmg met = sqrt((x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2) - 0.3;
    real hmin = 2.0e-2;
    real hmax = 1.0e-0;
    met = max(hmin, min(hmax, abs(met)));
    mesh3 ThNew = parmmg3d(ThParMmg, metric = met[], hausd = 0.05, nodeCommunicators = communicators);
    DmeshReconstruct(ThNew);
    DmeshCopy(ThNew, Th);
}
Vh u = sqrt((x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2) - 0.3;
medit("Th", Th, u);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -sizeComm 2 -Dpartitioner=scotch -Dwith=PETSc

IFMACRO(!with)
macro with()PETSc//
ENDIFMACRO
include "DmeshRedistribute.idp"
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int[int] LL = [1,2, 1,2, 1,1];
mesh3 ThBorder, Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb(u, v) = int3d(ThAugmented)(grad(u)' * grad(v)) + int3d(ThAugmented)(v) + on(1, u = 1.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = cube(1, 1, 1, [x, y, z]);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int3d(Th)(grad(u)' * grad(v)) + int2d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 1.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int3d(Th)(grad(u)' * grad(v)) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int2d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

func Pk = P2;

macro def(u)u//
{
    include "macro_ddm.idp"

    mesh ThGlobal = square(getARGV("-global_2d", 40), getARGV("-global_2d", 40));
    fespace Ph(ThGlobal, P0);
    Ph part;
    if(mpirank == 0) {
        partitionerSeq(part[], ThGlobal, mpisize);
    }
    partitionerPar(part[], ThGlobal, mpiCommWorld, mpisize);
    mesh Th = trunc(ThGlobal, abs(part - mpirank) < 1.0e-2, renum = 1, label = -111112);
    DmeshReconstruct(Th);
    fespace Wh(Th, Pk);
    Wh<real> u;
    PartitionCreate(Th, u[], Pk);
    plotMPI(Th, u, Pk, def, real, cmm = "Partition of unity");
}
{
    macro dimension()3// EOM
    include "macro_ddm.idp"

    mesh3 ThGlobal = cube(getARGV("-global_3d", 10), getARGV("-global_3d", 10), getARGV("-global_3d", 10));
    fespace Ph(ThGlobal, P0);
    Ph part;
    if(mpirank == 0) {
        partitionerSeq(part[], ThGlobal, mpisize);
    }
    partitionerPar(part[], ThGlobal, mpiCommWorld, mpisize);
    mesh3 Th = trunc(ThGlobal, abs(part - mpirank) < 1.0e-2, renum = 1, label = -111112);
    DmeshReconstruct(Th);
    fespace Wh(Th, Pk);
    Wh<real> u;
    PartitionCreate(Th, u[], Pk);
    plotMPI(Th, u, Pk, def, real, cmm = "Partition of unity");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"
include "cube.idp"
macro def(i)[i, i#y]// EOM // vector field definition
macro init(i)[i, i]// EOM  // vector field initialization

macro Curl(ux, uy)[dx(uy)-dy(ux)]// EOM
func Pk = RT0Ortho;

int Dirichlet = 1;

int[int] chlab = [Dirichlet, Dirichlet, Dirichlet, Dirichlet];
mesh Th = square(getARGV("-global", 10), getARGV("-global", 10), label = chlab);

fespace Wh(Th, Pk);

int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;
{
    buildMinimalist(Th, intersection, D, Pk)
    Wh def(u);
    varf onG(def(u), def(v)) = on(-111111, u = 10 + x + y, uy = 100 + y - x);
    u[] = onG(0, Wh);
    D = u[];
    for [j, dj : D] dj = abs(dj) > 1e-1 ? 0.0 : 1.0;
}

matrix Loc;
real[int] rhs(Wh.ndof);
{
    varf vPb([Ex,Ey],[vx,vy]) =
        int2d(Th)(Curl(vx,vy)'*Curl(Ex,Ey))
        + int2d(Th)([vx,vy]'*[Ex,Ey])
        + on(Dirichlet, Ex=0,Ey=0);
    Loc = vPb(Wh, Wh, tgv = -1);
    func f = exp(-8.0*((x-0.5)^2+(y-0.5)^2));
    varf vPbRhs([Ex,Ey],[vx,vy]) =
        - int2d(Th)(100*[vx,vy]'*[0,f])
        + on(Dirichlet, Ex=0,Ey=0);
    rhs = vPbRhs(0, Wh, tgv = -1);
}

Mat A(Loc, intersection, D);
set(A, sparams = "-pc_type lu");

Wh def(sol);
sol[] = A^-1 * rhs;
macro params()cmm = "Global solution", wait = 1, fill = 1// EOM
plotMPI(Th, def(sol), Pk, def, real, params);
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

load "hpddm"                        // HPDDM plugin
load "medit"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
/*# DiffMacros #*/
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
/*# DiffMacrosEnd #*/
func Pk = [P1, P1, P1];             // finite element space

/*# DDMoptions #*/
int s = getARGV("-split", 1);                                   // refinement factor

int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
/*# SchwarzMethod #*/
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh3 ThBorder;
    Th = cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, 10, s, 1, intersection, D, Pk, mpiCommWorld, false)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11; // steel
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = intN(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
Mat = vPb(Wh, Wh, sym = 1, tgv = -2);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction balanced -hpddm_variant right -hpddm_verbosity 1 -hpddm_geneo_nu 20");

{
    if(mpisize > 1 &&
       isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        varf vPbNoPen(def(u), def(v)) = intN(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
        matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1, tgv = -2);
        AttachCoarseOperator(mpiCommWorld, A, A = noPen);
    }
}

real alpha = 5.0e3;
Wh def(u), def(d);
real[int] uBlock(u[].n * 2);
real[int] rhsBlock(u[].n * 2);

varf vPbC(def(u), def(v)) = intN(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
rhsBlock(0 * u[].n:1 * u[].n - 1) = vPbC(0, Wh, tgv = -2);

varf vPbB(def(u), def(v)) = intN(Th)(f * vB) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
rhsBlock(1 * u[].n:2 * u[].n - 1) = vPbB(0, Wh, tgv = -2);

uBlock = A^-1 * rhsBlock;

u[] = uBlock(0 * u[].n:1 * u[].n - 1);
d[] = uBlock(1 * u[].n:2 * u[].n - 1);
mesh3 ThMoved1 = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
mesh3 ThMoved2 = movemesh3(Th, transfo = [x + alpha * d, y + alpha * dB, z + alpha * dC]);
macro def1(u)u// EOM
plotMPI(ThMoved1, u, P1, def1, real, cmm = "Global moved solution");
plotMPI(ThMoved2, u, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

real k = getARGV("-waven", 40.0);
func f = 100 * exp(-10 * k * ((x-0.5)^2 + (y-0.5)^2));

real lambda = 2 * pi / k;

real epsilonA = 0;
real epsilonE = 0;

int Dirichlet = 1;
int Robin = 2;

int s = getARGV("-split", 3);
real nw = 15.0 / s;
mesh ThCoarse = square(nw * 1/lambda, nw * 1/lambda);

{
    int[int] chlab = [1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];
    ThCoarse = change(ThCoarse, refe = chlab);
}

mesh Th;
fespace Wh(Th, Pk);
real[int] part;
fespace PhCoarse(ThCoarse, P0);
PhCoarse partCoarse;
if(mpirank == 0)
    partitionerSeq(partCoarse[], ThCoarse, mpisize);
partitionerPar(partCoarse[], ThCoarse, mpiCommWorld, mpisize);
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = trunc(ThCoarse, 1, split = s);
    fespace Ph(Th, P0);
    Ph part;
    part = partCoarse;
    buildWithPartitioning(Th, part[], 1, intersection, D, Pk, mpiCommWorld);
}

real epsilon = epsilonA;
varf vPb(u, v) = int2d(Th)(-(k^2 - 1i*epsilon)*u*v + grad(u)'*grad(v))
               + int1d(Th, Robin)(1i*k*u*v)
               - int2d(Th)(f*v)
               + on(Dirichlet, u = 0);
matrix<complex> Mat = vPb(Wh, Wh, sym = 1);
fespace WhCoarse(ThCoarse, Pk);
matrix<complex> MatCoarse;
{
    mesh ThBackup = Th;
    Th = ThCoarse;
    epsilon = epsilonE;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    epsilon = epsilonA;
    Th = ThBackup;
}
set(MatCoarse, solver = sparsesolverSym, sym = 1);
schwarz<complex> ACoarseSeq(MatCoarse);
set(ACoarseSeq, prefix = "level_2_");
matrix R = interpolate(Wh, WhCoarse);
complex[int] rhs = vPb(0, Wh);

schwarz<complex> A(Mat, intersection, D);
set(A, sparams = "-hpddm_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_schwarz_method ras -hpddm_variant right -hpddm_gmres_restart 200 -hpddm_max_it 200");

Wh<complex> u;
u[] = A^-1 * rhs;
plotMPI(Th, real(u), Pk, def, real, cmm = "Global solution with a one-level method");

set(A, sparams = "-hpddm_verbosity " + (!mpirank ? "3" : "0") + " -hpddm_schwarz_coarse_correction deflated -hpddm_variant flexible -hpddm_level_2_verbosity 0");
func complex[int] correctionExact(complex[int]& in) {
    complex[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    for[i, di: D] in[i] *= di;
    tmp = R' * in;
    mpiAllReduce(tmp, tmpReduced, mpiCommWorld, mpiSUM);
    tmp = ACoarseSeq^-1 * tmpReduced;
    out = R * tmp;
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionExact);

u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, real(u), Pk, def, real, cmm = "Global solution with a redundant coarse correction");

int[int][int] intersectionCoarse;
real[int] DCoarse;
{
    buildWithPartitioning(ThCoarse, partCoarse[], 1, intersectionCoarse, DCoarse, Pk, mpiCommWorld);
    mesh ThBackup = Th;
    Th = ThCoarse;
    epsilon = epsilonE;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    epsilon = epsilonA;
    Th = ThBackup;
}
R = interpolate(Wh, WhCoarse);
schwarz<complex> ACoarse(MatCoarse, intersectionCoarse, DCoarse);
set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_level_2_schwarz_method ras -hpddm_level_2_tol 1e-1 -hpddm_level_2_gmres_restart 200 -hpddm_level_2_max_it 200 -hpddm_level_2_krylov_method gcrodr -hpddm_level_2_recycle 10", prefix = "level_2_");
macro mplot()wait = 1, cmm = "Transfers on the correction at iteration " + ijk//
int ijk = 1;
func complex[int] correctionInexact(complex[int]& in) {
    complex[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        Wh outW;
        for[i, xi: in] outW[][i] = real(xi);
        plotMPI(Th, outW, Pk, def, real, mplot);
    }
    tmpReduced = R' * in;
    exchange(ACoarse, tmpReduced, scaled = true);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        WhCoarse outWCoarse;
        for[i, xi: tmpReduced] outWCoarse[][i] = real(tmpReduced[i]);
        plotMPI(ThCoarse, outWCoarse, Pk, def, real, mplot);
        ++ijk;
    }
    tmp = ACoarse^-1 * tmpReduced;
    out = R * tmp;
    exchange(A, out);
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionInexact);
else
    exit(0);

u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, real(u), Pk, def, real, cmm = "Global solution with a one-level inner coarse correction (two levels in total)");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
macro BC(u, val)u = val, u#B = val// EOM // Dirichlet boundary conditions
func Pk = [P2, P2];                 // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-2d-substructuring.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
{
    int[int] l = [2, 1, 2, 2];
    Th = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, 10, 1, labNeumann, s, intersection, Pk, BC, comm, excluded)
}

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

bdd A(Mat, intersection, communicator = comm);
// this can be replaced by feti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

pair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        AttachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(1, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(3);
            [Rb[0], RbB[0]] = [1, 0];
            [Rb[1], RbB[1]] = [0, 1];
            [Rb[2], RbB[2]] = [y, -x];
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            real strain = 100.0;
            real Young = 1.0e8;
            real poisson = 0.45;
            real tmp = 1.0 + poisson;
            real mu = Young  / (2.0 * tmp);
            real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
            Wh def(muFunc) = mu;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = muFunc[]);
        }
        AttachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u);          // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, rhs, u[], excluded = excluded);

if(!excluded)
    OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]// EOM// vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// two-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];             // finite element space

string deflation = getARGV("-deflation", "geneo");            // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - stokes-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh3 ThBorder, Th = buildlayers(square(1, 1), 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(ThAugmented)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs, eps = -1);
}
ThBorder = buildlayers(square(1, 1), 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_mkl_pardiso_iparm_13 1 --hpddm_schwarz_method oras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 1");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + int2d(Th, fakeInterface)(transmission * ([u, uB, uC]' * [v, vB, vC])) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;
int[int] fforder(2);
fforder = [1, 1];
savevtk("stokes-io-3d.vtu", Th, [u, uB, uC], uD, order = fforder, dataname = "velocity pressure");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "Element_Mixte3d"
load "PETSc"
macro dimension()3//
include "macro_ddm.idp"

include "cube.idp"
int[int] LL = [1,2, 1,2, 1,1];
mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL); // global mesh
mesh3 ThGlobal = Th;

Mat A;
int[int] n2o;
macro ThN2O()n2o//
DmeshCreate(Th);
func Pk = [RT03d, P0];
fespace Wh(Th, Pk);
{
macro def(u)[u, u#B, u#C, u#D]//
macro init(u)[u, u, u, u]//
macro ThPostProcessD(D) {
    Wh def(u), def(v);
    varf onG(def(u), def(v)) = on(-111111, u = 10 + x - z, uB = 100 + y - x, uC = 1000 + z - y);
    v[] = D;
    u[] = onG(0, Wh);
    for [j, dj : u[]] dj = abs(dj) > 1e-2 ? 0.0 : 1.0;
    def(u) = [u, uB, uC, vD];
    D = u[];
}// EOM
MatCreate(Th, A, Pk);
}

macro div(u1, u2, u3)(dx(u1) + dy(u2) + dz(u3))//
varf vMixedLaplace([u1, u2, u3, p], [v1, v2, v3, q]) = int3d(Th)(u1 * v1 + u2 * v2 + u3 * v3 + p*div(v1, v2, v3) + div(u1, u2, u3)*q)
                                                     - int3d(Th)(q)
                                                     + int2d(Th, 1)(v1*N.x + v2*N.y + v3*N.z)
                                                     + on(2, u1 = 2.0, u2 = 3.0, u3 = 4.0);

real[int] rhs = vMixedLaplace(0, Wh, tgv = -1);
A = vMixedLaplace(Wh, Wh, tgv = -1);
set(A, sparams ="-pc_type lu");
Wh [u1, u2, u3, u4];
u1[] = A^-1 * rhs;
fespace WhGlobal(ThGlobal, Pk);
int[int] rest = restrict(Wh, WhGlobal, n2o);
WhGlobal [uG1, uG2, uG3, uG4];
real[int] reduce(uG1[].n);
{
    real[int] tmp;
    ChangeNumbering(A, u1[], tmp);
    ChangeNumbering(A, u1[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u1[][i];
mpiReduce(reduce, uG1[], processor(0), mpiSUM);
if(mpirank == 0) {
    medit("Global solution", ThGlobal, uG4);
}
[u1, u2, u3, u4] = [0.0, 0.0, 0.0, 1.0];
u1[] += 1.0;
set(A, sparams = "-pc_type fieldsplit -ksp_monitor -ksp_view " +
    "-ksp_type fgmres " +
    "-pc_fieldsplit_type schur " +
    "-pc_fieldsplit_schur_fact_type full " +
    "-fieldsplit_0_ksp_type preonly " +
    "-fieldsplit_1_ksp_type gmres " +
    "-fieldsplit_1_ksp_converged_reason -fieldsplit_1_ksp_rtol 1e-4 " +
    "-pc_fieldsplit_schur_precondition selfp " +
    "-fieldsplit_1_pc_type hypre", fields = u1[]);
u1[] = A^-1 * rhs;
{
    real[int] tmp;
    ChangeNumbering(A, u1[], tmp);
    ChangeNumbering(A, u1[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u1[][i];
mpiReduce(reduce, uG1[], processor(0), mpiSUM);
if(mpirank == 0) {
    medit("Global solution", ThGlobal, uG4);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
func Pk = P2;                       // finite element space
func Pkdc = P2dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
mesh ThBackup = Th;
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);
Vh b = 1;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, 3, 4, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, 3, 4, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, 3, 4, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

real[int] xPETSc, bPETSc;
u[] = vC(0, Vh);
ChangeNumbering(A, u[], bPETSc);
xPETSc.resize(bPETSc.n);
xPETSc = 0;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -ksp_monitor_true_residual -snes_max_it 4 -snes_converged_reason -ksp_converged_reason -pc_type lu -snes_view");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = false);
fespace VhG(ThBackup, Pk);
VhG uG, uReduce;
uReduce = u;
mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
if(mpirank == 0) {
    plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
    ThBackup = adaptmesh(ThBackup, uG);
}
broadcast(processor(0), ThBackup);
uG = uG;
plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
{
    Th = ThBackup;
    Mat Adapt;
    MatCreate(Th, Adapt, Pk);
    A = Adapt;
}
u = uG;
macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
xPETSc.resize(0);
ChangeNumbering(A, u[], xPETSc);
u[] = vC(0, Vh);
ChangeNumbering(A, u[], bPETSc);
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_max_it 40 -ksp_monitor_true_residual -snes_converged_reason -ksp_converged_reason -pc_type lu -snes_view");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "mshmet"
load "mmg"
load "aniso"
load "PETSc"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]// EOM
macro init(i)[i, i, i, i]// EOM
func Pk = [P2, P2, P2, P1];
macro grad(u)[dx(u), dy(u), dz(u)]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM

real anisomax = getARGV("-anisomax", 4.0);
bool aniso = bool(anisomax > 1.0);
mesh3 Th;
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    //mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    //ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
}
mesh3 ThG = Th; // need to backup the original global mesh

Mat A;
int[int] n2o;       // need to know how to go from the local to the global mesh
if(mpirank==0) cout << "it = 0, Th.nv = " << ThG.nv << endl;
macro ThN2O()n2o//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk); // complete space [u, v, w, p]
fespace Zh(Th, P2); // velocity space
fespace Qh(Th, P1); // pressure space
Qh onlyP;
Zh onlyU;

varf vPb(def(u), def(v)) = int3d(Th)(
    grad(u)' * grad(v)
    + grad(uB)' * grad(vB)
    + grad(uC)' * grad(vC)
    - div(u) * vD - div(v) * uD
    )
    + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0)
    + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);

Wh def(u);

for(int i = 0; i < 2; ++i) {
    real[int] rhs = vPb(0, Wh, tgv = -1);
    A = vPb(Wh, Wh, tgv = -1);
    set(A, sparams = "-pc_type lu"); // add "-pc_factor_mat_solver_type mumps" to run on 1 proc
    u[] = A^-1*rhs;
    if(!NoGraphicWindow) {
        onlyP = uD;
        macro def1(i)i//
        plotMPI(Th, onlyP, P1, def1, real, cmm = "Pressure for it = " + (i+1));
        onlyU = u;
        plotMPI(Th, onlyU, P2, def1, real, cmm = "x-velocity for it = " + (i+1));
    }
    {
        fespace WhG(ThG, Pk);
        fespace ZhG(ThG, P2);
        fespace QhG(ThG, P1);
        WhG def(uG), def(uReduce);
        u[] .*= A.D;
        int[int] rest = restrict(Wh, WhG, n2o);
        uReduce[](rest) = u[];
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            // Since mshmet cannot regularize FE functions like adaptmesh,
            // first regularize solutions on [0,1];
            ZhG uMag = sqrt(uG^2+uGB^2+uGC^2);
            real unorm = uMag[].max-uMag[].min;
            QhG p = uGD;
            real pnorm = p[].max-p[].min;
            // Define normalized sol'n 
            def(uReduce) = [uG/unorm, uGB/unorm, uGC/unorm, uGD/pnorm];
            // create metric
            real[int] met = mshmet(ThG, [uReduce, uReduceB, uReduceC], uReduceD, normalization = bool(getARGV("-normalization",0)), aniso = aniso, hmin = 1.0e-3, hmax = 0.2, err = 1.0e-2, verbosity = verbosity);
            if(aniso) boundaniso(6, met, anisomax); // restrict anisotropy
            fespace METhG(ThG,[P1,P1,P1,P1,P1,P1]);
            METhG [m11,m21,m22,m31,m32,m33];
            QhG mm;
            if(!aniso) mm[] = met;
            else {
                m11[] = met;
                mm = m11+m22+m33; // trace of anisotropic metric tensor
            }
            plot(mm);
            ThG = mmg3d(ThG, metric = met, hmin = 1.0e-3, hmax = 0.2, hgrad = -1, verbose=verbosity-(verbosity==0));
            cout << "it = " << (i+1) << ", Th.nv = " << ThG.nv << endl;
            plot(ThG);
        }
        broadcast(processor(0), ThG);
        def(uG) = def(uG);
        Th = ThG;
        Mat Adapt;
        MatCreate(Th, Adapt, Pk) // decompose the adapted mesh
        A = Adapt; // replace the old Jacobian
        def(u) = init(0.0); // just to trigger a resize
        rest.resize(u[].n);
        rest = restrict(Wh, WhG, n2o);
        u[] = uG[](rest);
    }
}
DmeshSave(Th, "stokes-adapt-3d");
ofstream sol("stokes-adapt-3d_" + mpirank + "_" + mpisize + ".sol");
sol << u[];
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
real memory = PetscMemoryGetCurrentUsage();
u[] = A^-1 * rhs;
memory = PetscMemoryGetCurrentUsage() - memory;
if(mpirank == 0)
    cout << memory << " bytes of memory in usage" << endl;

real[int] err = A * u[];            // global matrix-vector product
real[int] transpose = A' * u[];
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");

Wh<real> Rb[1];
Rb[0] = 1;
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200", nearnullspace = Rb);
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -freq 2e+8

load "bem"
load "Element_Mixte3d"
load "PETSc-complex"
macro dimension()3S// EOM
include "macro_ddm.idp"
include "cobrameshcavity.idp"

if(!HasType("Mat", "Htool")) exit(0);

func Pk = RT0S;
func Qk = [P1,P1,P1];
real c0     = 299792458;
real f      = getARGV("-freq",5.e+8);
real k      = 2*pi*f/c0;
real lambda = c0/f;

// incident wave
real thetaI   = 2*pi*0./360.;
real[int] dir = [cos(thetaI),0,sin(thetaI)];
func fincx    = 0;
func fincy    = exp(1i*k*(dir[0]*x + dir[1]*y + dir[2]*z));
func fincz    = 0;
int nloc      = 4.0/lambda;

mesh3 Th3 = cube(nloc, nloc, nloc, [x-0.5, y-0.5, z-0.5]);

meshS ThG, ThS = extract(Th3);

Mat<complex> A;
int[int] n2o;
macro ThSN2O()n2o//
ThG = ThS;
DmeshCreate(ThS);
{
    Mat<complex> H, T;
    MatCreate(ThS, H, P1);
    MatCreate(ThS, T, P0);
    CoherentGlobalMesh(T, H, ThS, ThG);
}
{
    macro def(u)[u, u#2, u#3]//
    macro init(u)[u, u, u]//
    macro ThSPkPart()Edge0S//
    macro defPart(u)def(u)//
    macro initPart(u)init(u)//
    MatCreate(ThS, A, Pk);
}
fespace UhG(ThG, Pk);
fespace UhS(ThS, Pk);
// Maxwell is defined on a vector of size three
varf vk( [u1,u2,u3], [v1,v2,v3] ) = int2dx2d(ThG)(ThG)(BEM(BemKernel("MA_SL", k=k), [u1,u2,u3], [v1,v2,v3]));
A = vk(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-3 -mat_htool_eta 10");
varf vRHS([ux, uy, uz], [vx, vy, vz]) = int2d(ThG)([vx, vy, vz]' * [-fincx, -fincy, -fincz]);
UhG<complex> [bx, by, bz], [ux, uy, uz];
bx[] = vRHS(0, UhG);
Mat<complex> C;
string type = HasType("Mat", "ScaLAPACK") ? "scalapack" : "aij";
MatConvert(A, C, type = type);
set(C, sparams = "-pc_type lu");
int[int] range = C.range;
complex[int] rhs(C.n);
rhs = bx[](range(0):range(1)-1);
KSPSolve(C, rhs, rhs);
if(!NoGraphicWindow) {
    if (type == "scalapack") {
        complex[int] before(UhG.ndof), after(UhG.ndof);
        before(range(0):range(1)-1) = rhs;
        mpiAllReduce(before, after, mpiCommWorld, mpiSUM);
        rhs.resize(A.n);
        range = A.range;
        rhs = after(range(0):range(1)-1);
    }
    UhS<complex> [solx, soly, solz];
    bool flg = true;
    if(!flg)
        ChangeNumbering(A, solx[], rhs, inverse = 1, exchange = 1);
    nloc *= 15;
    nloc -= nloc%8;
    meshS ThOutG = square3(nloc, nloc, [4*(x-0.5), 4*(y-0.5), 0]);
    ThOutG = trunc(ThOutG, max(abs(x), abs(y)) > 0.5 + 4.0/nloc);
    meshS ThOutS = ThOutG;
    int[int] n2o;//
    macro ThOutSN2O()n2o//
    DmeshCreate(ThOutS);
    {
        Mat<complex> B, T;
        MatCreate(ThOutS, B, P1);
        MatCreate(ThOutS, T, P0);
        CoherentGlobalMesh(T, B, ThOutS, ThOutG);
    }
    Mat<complex> B;
    {
        macro def(u)[u, u#2, u#3]//
        macro init(u)[u, u, u]//
        MatCreate(ThOutS, B, Qk);
    }
    fespace UhOutG(ThOutG, Qk);
    fespace UhOutS(ThOutS, Qk);
    // Maxwell is defined on a vector of size three
    varf vP([u1,u2,u3], [v1,v2,v3] ) = int2d(ThG)(POT(BemPotential("MA_SL", k=k), [u1,u2,u3], [v1,v2,v3] )) ;
    Mat<complex> P(B, A);
    P = vP(UhG, UhOutG, sparams = "-mat_htool_epsilon 1.0e-3 -mat_htool_eta 10");
    ObjectView(P, format = "info");

    UhOutS<complex> [Ex, Ey, Ez];
    if(flg) {
        complex[int] E(B.n);
        MatMult(P, rhs, E);
        ChangeNumbering(B, Ex[], E, inverse = 1, exchange = 1);
    } else {
        Ex[] = P * solx[];
    }

    fespace Uh(ThOutS, P1);
    Uh Er = sqrt(real(Ex+fincx)^2 + real(Ey+fincy)^2 + real(Ez+fincz)^2);
    macro def1(u)u//
    plotMPI(ThOutS, Er, P1, def1, real, cmm = "Global solution");
}
if(0) {
    UhS<complex> [blx, bly, blz];
    varf vRHSl([ux, uy, uz], [vx, vy, vz]) = int2d(ThS)([vx, vy, vz]' * [-fincx, -fincy, -fincz]);
    blx[] = vRHSl(0, UhS);
    exchange(A, blx[], scaled = 1);
    complex[int] wrhs;
    ChangeNumbering(A, blx[], wrhs);
    wrhs -= rhs;
    cout << wrhs.l2 << endl;
    [blx, bly, blz] = [bx, by, bz];
    exchange(A, blx[], scaled = 1);
    ChangeNumbering(A, blx[], wrhs);
    wrhs -= rhs;
    cout << wrhs.l2 << endl;
    blx[] = vRHSl(0, UhS);
    complex[int] exchge;
    ChangeNumbering(A, blx[], exchge);
    ChangeNumbering(A, blx[], exchge, inverse = 1, exchange = 1);
    ChangeNumbering(A, blx[], wrhs);
    wrhs -= rhs;
    cout << wrhs.l2 << endl;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1, P1, P1]; // finite element space


int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

real f = -9000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
fespace Wh(Th, Pk);                 // local finite element space
matrix Loc = vPb(Wh, Wh);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view -ksp_max_it 100", bs = 3);
Wh<real> def(u);                    // local solution

A = Loc;
u[] = A^-1 * rhs;

real[int] err = A * u[];            // global matrix-vector product
exchange(A, rhs, scaled = true);
err -= rhs;

macro def1(u)u// EOM
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, P1, def1, real, cmm = "Global residual");

Wh<real> def(Rb)[6];
[Rb[0], RbB[0], RbC[0]] = [1, 0, 0];
[Rb[1], RbB[1], RbC[1]] = [0, 1, 0];
[Rb[2], RbB[2], RbC[2]] = [0, 0, 1];
[Rb[3], RbB[3], RbC[3]] = [y, -x, 0];
[Rb[4], RbB[4], RbC[4]] = [-z, 0, x];
[Rb[5], RbB[5], RbC[5]] = [0, z, -y];
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200 -pc_gamg_threshold 0.01", nearnullspace = Rb);
u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
real alpha = 1.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = mpirank;
plotMPI(ThMoved, u, P1, def1, real, cmm = "Global moved solution");
if(HasType("PC", "hpddm")) {
    u[] = 0;
    set(A, sparams = "-pc_type hpddm -pc_hpddm_coarse_p 2 -pc_hpddm_levels_1_eps_nev 20 -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_define_subdomains -pc_hpddm_has_neumann -pc_hpddm_levels_1_pc_type asm -ksp_monitor");
    u[] = A^-1 * rhs;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2//
include "macro_ddm.idp"

macro def(u)u//
macro init(u)u//
border C(t = 0, 2*pi){ x=cos(t); y=sin(t); }
mesh Th = buildmesh(C(getARGV("-global", 100)));

func Pk = P1dc;
fespace Vh(Th, Pk);
Mat dK;
MatCreate(Th, dK, Pk);
Vh v1 = y, v2 = -x;

macro diff(n)(abs(n) - (n))//

varf vK(c, w) = int2d(Th)((v1 * dx(c) + v2 * dy(c)) * w) + intalledges(Th)((1 - nTonEdge) * w * diff(v1 * N.x + v2 * N.y) * 0.5 * jump(c));
varf vM(c, w) = int2d(Th)(c * w);
matrix M = vM(Vh, Vh);
matrix K = vK(Vh, Vh);

dK = K;
Mat dM(dK, M);
set(dM, sparams = "-pc_type jacobi");
Mat dT(dM);

func real[int] funcExplicit(real t, real[int]& in) {
    real[int] temp(in.n), out(in.n);
    MatMult(dK, in, temp);
    temp *= -1;
    KSPSolve(dM, temp, out);
    return out;
}
func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] temp(in.n), out(in.n);
    MatMult(dM, inT, out);
    MatMult(dK, in, temp);
    out += temp;
    return out;
}
real shift = 0;
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    if(abs(a - shift) > 1.0e-10) {
        matrix B = a * M + K;
        dT = B;
        shift = a;
    }
    return 0;
}
Vh w;
string type;
func int funcM(int s, real t, real[int]& u) {
    ChangeNumbering(dT, w[], u, inverse = true, exchange = true);
    plotMPI(Th, w, Pk, def, real, cmm = "Global solution at step " + s + " (time " + t + ") with " + type + " method");
}
for(int j = 0; j < 3; ++j) {
    Vh c = exp(-10 * ((x - 0.3)^2 + (y - 0.3)^2));
    real[int] cPETSc;
    ChangeNumbering(dT, c[], cPETSc);
    real T = 3 * pi;
    string deflt = "-ts_view -ts_max_snes_failures -1 -ts_exact_final_time interpolate -ts_adapt_type basic -ts_max_time " + string(T);
    if(j == 0) {
        type = "explicit";
        TSSolve(dT, funcJ, funcExplicit, cPETSc, sparams = "-ts_type rk -ts_rk_type 5f " + deflt, monitor = funcM);
    }
    else if(j == 1) {
        type = "implicit";
        TSSolve(dT, funcJ, funcRes, cPETSc, sparams = "-ts_type rosw " + deflt, monitor = funcM);
    }
    else {
        type = "semi-implicit";
        TSSolve(dT, funcJ, funcRes, cPETSc, sparams = "-ts_type arkimex -ts_arkimex_type 5 " + deflt, monitor = funcM);
    }
    ChangeNumbering(dT, c[], cPETSc, inverse = true, exchange = true);
    macro params()cmm = "Global solution with " + type + " method", wait = 1, dim = 3, fill = 1// EOM
    plotMPI(Th, c, Pk, def, real, params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

assert(mpisize == 4);
load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro BC(u, val)u = val// EOM       // Dirichlet boundary conditions
func Pk = P1;                       // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d-substructuring.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
int[int] labDirichlet = [1, 3];
{
    int[int] l = [2, 1, 3, 2];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    fespace Ph(Th, P0);
    Ph part;
    part = (x > 0.5 && y > 0.5 ? 3 : (x > 0.5 ? 2 : (y < 0.5 ? 1 : 0)));
    buildSubstructuringWithPartitioning(Th, interfaceNb, part[], 10, labDirichlet, labNeumann, s, intersection, Pk, BC, comm, excluded);
}

func f = 10;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(f * v) + on(labDirichlet, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

bdd A(Mat, intersection, communicator = comm);
// this can be replaced by feti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

pair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        AttachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(labDirichlet, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(1);
            Rb[0][] = 1;
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            Wh def(mu) = 1.0;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = mu[]);
        }
        AttachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u) = 0.0;    // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, rhs, u[], excluded = excluded);

if(!excluded)
    OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");

statistics(A);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P1;                               // finite element space

macro ThRefinementFactor()getARGV("-split", 1)//
int[int] l = [1, 2, 2, 2];
mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);
fespace Wh(Th, Pk);           // local finite element space
Mat T;
MatCreate(Th, T, Pk);

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> Loc;                           // local operator
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph kappa = x < 0.25 ? 10.0 : 1.0;
    varf vPb(u, v) = int2d(Th)(-1.0 * kappa * grad(u)' * grad(v)) + on(1, u = 0.0);
    Loc = vPb(Wh, Wh, tgv = -2);
    rhs = vPb(0, Wh, tgv = -2);
}

func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] out(in.n);
    T = Loc;
    MatMult(T, in, out);
    out = inT - out;
    return out;
}
real shift = 0;
matrix Id;
{
    real[int] D(Loc.n);
    D = 1.0;
    Id = D;
}
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    matrix B = (-1.0) * Loc + a * Id;
    T = B;
    shift = a;
    return 0;
}
Wh w;
func int funcM(int s, real t, real[int]& u) {
    ChangeNumbering(T, w[], u, exchange = true, inverse = true);
    plotMPI(Th, w, Pk, def, real, cmm = "Global solution at step " + s + " (time " + t + ")");
}
w = (0.5 - x)^2 + (0.5 - y)^2 < 0.2 ? 1.0 : 0.0;
real[int] wPETSc;
ChangeNumbering(T, w[], wPETSc);
TSSolve(T, funcJ, funcRes, wPETSc, sparams = "-ts_type beuler -ts_dt 0.1 -ts_max_time 100 -ts_exact_final_time interpolate -ts_max_snes_failures -1 -ts_view -pc_type lu -ts_adapt_type basic -ts_rtol 1e-3", monitor = funcM);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2// EOM
include "macro_ddm.idp"

real c = 6.25;
int N  = 80;

// domain: unit square
border aa(t=0,1) { x=t;   y=0;   };
border bb(t=0,1) { x=1;   y=t;   };
border cc(t=0,1) { x=1-t; y=1;   };
border dd(t=0,1) { x=0;   y=1-t; };

mesh M = buildmesh(aa(N)+bb(N)+cc(N)+dd(N));

load "Element_P3"
func Pk = P1;
Mat A;
macro MRefinementFactor()getARGV("-split", 1)//
MatCreate(M, A, Pk);
fespace Vh(M, Pk);
Vh u;
func BC = cos(pi*x)*cos(pi*y);
varf vInit(w, v) = on(aa, bb, cc, dd, w = BC);
varf vJ(w, v) = int2d(M)(dx(w)*dx(v) + dy(w)*dy(v) - c*exp(u)*w*v) + on(aa, bb, cc, dd, w = 0);
varf vRes(w, v) = int2d(M)(dx(u)*dx(v) + dy(u)*dy(v) - c*exp(u)*v) + on(aa, bb, cc, dd, w = u);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    real[int] out(Vh.ndof);
    out = vRes(0, Vh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vJ(Vh, Vh, tgv = -2);
    return 0;
}
set(A);
if(HasType("PC", "hpddm")) {
    bool stage = usedARGV("-stage") != -1;
    for(int i = 0; i < 3; ++i) {
        string params;
        if(i == 0) {
            params = "";
            if(stage)
                PetscLogStagePush("Everything");
        }
        else if(i == 1) {
            params = "-pc_hpddm_coarse_ksp_reuse_preconditioner";
            Mat B = A;
            A = B;
            if(stage)
                PetscLogStagePush("Fine level");
        }
        else if(i == 2) {
            params = "-pc_hpddm_levels_1_ksp_reuse_preconditioner";
            Mat B = A;
            A = B;
            if(stage)
                PetscLogStagePush("Nothing");
        }
        set(A, sparams = "-pc_type hpddm -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_levels_1_eps_nev 10 -pc_hpddm_define_subdomains -pc_hpddm_has_neumann -ksp_converged_reason -pc_hpddm_levels_1_pc_type asm " + params);
        real[int] bPETSc;
        u[] = vInit(0, Vh, tgv = -2);
        ChangeNumbering(A, u[], bPETSc);
        real[int] xPETSc = bPETSc;
        SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_type newtonls -snes_converged_reason -ksp_converged_reason -snes_view");
        ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
        macro def(u)u//
        plotMPI(M, u, Pk, def, real, cmm = "Global solution");
        set(A, sparams = "-pc_type none");
        if(stage)
            PetscLogStagePop();
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
load "hpddm"

int n = 4;
real[int] b(n), u(n);
func real[int] matId(real[int]& u) { return u; };
func real[int] A(real[int]& u) {
    for(int i = 0; i < u.n; ++i)
        u[i] = (10 * mpirank + i + 1) * u[i];
    return u;
}
func real error(real[int]& u , real[int]& b) {
    real s = 0;
    for(int i = 0; i < u.n; ++i)
        s += abs((10 * mpirank + i + 1) * u[i] - b[i]);
    return s;
}

b = 1;
u = 0;
IterativeMethod(A, b, u, sparams = "-hpddm_tol 1e-6 -hpddm_foo_krylov_method gcrodr -hpddm_foo_recycle 4 -hpddm_foo_variant flexible" + (mpirank == 0 ? " -hpddm_foo_verbosity 4" : ""), prefix = "foo_");
assert(error(u, b) < 1e-5);
u = 0;
IterativeMethod(A, b, u, precon = matId, prefix = "foo_");
assert(error(u, b) < 1e-5);
func real[int] B(real[int]& u) {
    for(int i = 0; i < u.n; ++i)
        u[i] = (2 * mpirank + i + 1) * u[i];
    return u;
}
mpiWtime();
func real[int] time(real[int]& u) {
    for(int i = 0;i < u.n; ++i)
        u[i] *= (1.0 + 1.0 / mpiWtime());
    return u;
}
u = 0;
IterativeMethod(B, b, u, precon = time, prefix = "foo_");
func real errorB(real[int]& u , real[int]& b) {
    real s = 0;
    for(int i = 0; i < u.n; ++i)
        s += abs((2 * mpirank + i + 1) * u[i] - b[i]);
    return s;
}
assert(errorB(u, b) < 1e-5);
// This codes shows how to solve an eigenvalue problems
// in different coordinate systems. The example here is
// the Laplace equation on a toroidal surface embedded
// in R3. The cartesian coordinates on the torus read
//     x = (r1+r2*cos(u))*cos(v)
//     y = (r1+r2*cos(u))*sin(v)
//     z = r2*sin(v)
// with r1>r2 the major and minor radii and u,v \in [0,2\pi]
// The toroidal surface thus maps to a square domain of
// side 2\pi and periodic boundary conditions in both
// coordinates.
//
// Laplace-Beltrami on a torus, using SLEPc.
//
// Is the eigenspectrum known analytically?
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-torus-SLEPc.edp \
//        -split 1 -npts 400 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels = [1,2,3,4]; // labels : bottom, right, top, left sides
int[int] labPeriodic = [Labels[0],Labels[2],Labels[1],Labels[3]];

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

macro Pk() P1, periodic=[[Labels[0],x],[Labels[2],x],[Labels[1],y],[Labels[3],y]]//EOM

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 400) ; // Number of points on the perimeter
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real r1 = getARGV("-r1",2.0); // Large radius of the torus
real r2 = getARGV("-r2",1.0); // Small radius of the torus
if (r1<=r2){if(!mpirank) cout << "Error r1<r2 is a wrong dimensions of the torus"<<endl; exit(1);}
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-torus-SLEPc.edp "        << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts           << endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  Large radius of the torus = " << r1          << endl
        << "  Small radius of the torus = " << r2          << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Thetapts = int(0.25*Npts); // pts on the x-axis sides
    int Phipts   = int(0.25*Npts); // pts on the y-axis sides

    Th = square(Thetapts,Phipts,[2.0*x*pi,2.0*pi*y],label=Labels);
    // .....
    buildPeriodic(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld, // Communicator
            labPeriodic   // Array of labels for periodic boundaries
         );
}
/***********************************************************************/
/*         Coordinate dependant differential operators                 */
/***********************************************************************/
/*              Parametric coordinates in the (u,v)-plane              */
/*                                                                     */
/*                  u  --> x  in [0,2*pi]                              */
/*                  v  --> y  in [0,2*pi]                              */
/*                                                                     */
/*          Jacobian determinant on the bi-periodic square             */
/*        The det(J) = r2*(r1+r2*cos(u)) --> r2(r1+r2*cos(x))          */
/*                                                                     */
macro Jac()( r2*(r1+r2*cos(x)) )            // End Of Macro /*         */
     /*  The Jacobian                                                  */
/*                                                                     */
/*       The gradiant operator on the induced toroidal surface         */
/*                                                                     */
/*       grad =   1/r2*d/du              ->  1/r2*d/dx                 */
/*                1/(r1+r2*cos(u))*d/dv  ->  1/(r1+r2*cos(x)*d/dy      */
/*                                                                     */
macro Grad(u) [dx(u)/r2,dy(u)/(r1+r2*cos(x))]      // End Of Macro /*  */
     /*  The Gradient operator                                         */
macro Lap(u,v) ( Grad(u)'*Grad(v)) //')      // End Of Macro /*        */
     /*  The Laplace-Beltrami operator on the induced surface          */ 
/*                                                                     */
/***********************************************************************/
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
  (Jac*(Lap(uh,vh)))//  Bilinear form
  ;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
  ( Jac*uh*vh )           //  Bilinear form
  ;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type cholesky "       +
  " -st_matstructure same "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
macro grad(u)[dx(u), dy(u), dz(u)]// EOM

func Pk = P1;                       // finite element space
int level = getARGV("-level", 3);
int[int] LL = [1,2, 1,2, 1,1];
mesh3[int] ThTab(level);
ThTab[level - 1] = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [x, y, z], label = LL);
Mat[int] MG(level);
matrix[int] P(level - 1);
buildMatRecursive(ThTab, getARGV("-split", 2), level, P, MG, Pk, mpiCommWorld);
real[int] rhs;
for(int i = 0; i < level; ++i) {
    varf vPb(u, v) = int3d(ThTab[i])(grad(u)' * grad(v)) + int3d(ThTab[i])(v) + on(1, u = 0.0);
    fespace Wh(ThTab[i], Pk);
    MG[i] = vPb(Wh, Wh, tgv = -2);
    if(i == 0) {
        rhs.resize(Wh.ndof);
        rhs = vPb(0, Wh);
    }
}
set(MG, P, sparams = "-pc_type mg");
fespace Wh(ThTab[0], Pk);
Wh u;
u[] = MG[0]^-1 * rhs;
macro def(u)u//
plotMPI(ThTab[0], u, Pk, def, real, cmm = "Global solution");
real[int] tmp(Wh.ndof);
tmp = u[];
for(int i = 0; i < level; ++i) {
    fespace Vh(ThTab[i], Pk);
    Vh w;
    w[] = tmp;
    exchange(MG[i], w[], scaled = true);
    int[int] fforder = [1];
    savevtk("diffusion-mg-3d.vtu", ThTab[i], w, bin = 1, order = fforder, append = i ? true : false);
    if(i == level - 1)
        break;
    tmp.resize(P[i].m);
    tmp = P[i]' * w[];
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
macro trueRestrict()true//
macro removeZeros()true//
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space


mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
mesh ThBackup = Th;
int[int] n2o;
macro ThN2O()n2o//
DmeshCreate(Th);
fespace Wh(Th, Pk);           // local finite element space

varf vPb(u, v) = intN(Th)(u * v + grad(u)' * grad(v) - 10 * dy(v) * u) + intN(Th)(v * x) + on(1, 2, 3, 4, u = 0.0);
varf vPbT(u, v) = intN(Th)(u * v + grad(u)' * grad(v) - 10 * dy(u) * v) + intN(Th)(v * x) + on(1, 2, 3, 4, u = 0.0);
matrix<real> Loc  = vPb(Wh, Wh);
matrix<real> LocT = vPbT(Wh, Wh);
real[int] rhs = vPb(0, Wh);

Mat A;
MatCreate(Th, A, Pk);
A = Loc;
Mat AT(A, LocT);
Wh<real> def(u);  // local solution
Wh<real> def(v);  // local solution

u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = A'^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution transpose");
v[] = AT^-1 * rhs;
u[] -= v[];
real local = u[].linfty;
real norm;
mpiAllReduce(local, norm, mpiCommWorld, mpiMAX);
plotMPI(Th, v, Pk, def, real, cmm = "Global solution transposed problem (linfty of error = " + norm + ")");
if(!NoGraphicWindow) {
    fespace WhBackup(ThBackup, Pk);
    int[int] rest = restrict(Wh, WhBackup, n2o);
    u[] = v[];
    u[] .*= A.D;
    WhBackup sol, solReduced;
    for[i, v : rest] sol[][v] = u[][i];
    mpiReduce(sol[], solReduced[], processor(0), mpiSUM);
    plot(solReduced, wait = 1);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"                // SLEPc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(20, 20);
fespace Vh(Th, Pk);
complex lambda;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v) + lambda^0.5 * u * v);
Mat<complex> A, B;
MatCreate(Th, A, Pk);
func int FormFunction(complex mu) {
    lambda = mu;
    A = vPb(Vh, Vh);
    return 0;
}
func int FormJacobian(complex mu) {
    matrix<complex> Id = eye(Vh.ndof);
    Id = 0.5/mu^0.5 * Id;
    Mat<complex> C(A, Id);
    B = C;
    return 0;
}
FormFunction(1.0);
FormJacobian(1.0);
Vh<complex>[int] vec(1);
NEPSolve(A, FormFunction, B, FormJacobian, vectors = vec, sparams = "-nep_type nleigs -nep_nev 4 -rg_type ellipse -rg_ellipse_center 0.0 -rg_ellipse_radius 0.4 -nep_monitor -nep_view -nep_view_values");
vec.resize(5);
for(int i = 0; i < vec.n; ++i) {
    macro def(u)u//
    plotMPI(Th, vec[i], Pk, def, complex, cmm = "Eigenvector #" + i);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "medit"
macro dimension()3S//
include "macro_ddm.idp"

real R  = 3.0, r = 1.0;
real h  = 0.2;
int nx  = R*2*pi/h;
int ny  = r*2*pi/h;
func tx = (R+r*cos(y*pi*2))*cos(x*pi*2);
func ty = (R+r*cos(y*pi*2))*sin(x*pi*2);
func tz = r*sin(y*pi*2);

meshS Th = square3(nx, ny, [tx,ty,tz], removeduplicate=true);

Mat A;
MatCreate(Th,A,P1);
fespace Vh(Th,P1);

macro Grad3(uvw) [dx(uvw), dy(uvw), dz(uvw)]//

real sigma = 1;
varf aS(u,v) = int2d(Th)(Grad3(u)'*Grad3(v));
varf mS(u,v) = int2d(Th)(u*v);

A = aS(Vh, Vh, sym = 1);
matrix LocB = mS(Vh, Vh, sym = 1, solver = CG);
Mat B(A, LocB);
int nev = 10;
real[int] ev(nev);
Vh[int] eV(nev);

string ssparams =
  " -eps_nev " + nev       +
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   +
  " -st_type sinvert "     +
  " -st_pc_type cholesky " +
  " -eps_view"             +
  " -eps_gen_hermitian";
int k = EPSSolve(A, B, values = ev, vectors = eV, sparams = ssparams);

for(int i = 0; i < k; ++i) {
    macro params()cmm = "Eigenvector #" + i + ", eigenvalue =" + ev[i], wait = 1, fill = 1, value = 1//
    plotD(Th, eV[i], params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "mshmet"
load "PETSc"
macro with()PETSc//
load "parmmg"
load "mmg"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

int n = 12;
int[int] L=[1,1,1,1], LU=[0,2], LD=[1,1], LR=[0,1];
mesh3 Th3 = buildlayers(square(n, n, region=0, label=L), n, zbound=[0,1], labelmid=LD, labelup=LU, labeldown=LR);
Th3 = trunc(Th3, x < 0.5 || y < 0.5 || z < 0.5, label=3);

macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
macro MmgParameters(ThGather, met, rt, verbose)ThGather, metric = met, hgrad = getARGV("-hgrad", 2.3), requiredTriangle = rt, verbose = verbose// EOM
macro ParMmgCommunicatorsAndMetric(Th, met, ThParMmg, metParMmg, communicators) {
int[int] n2o;
ParMmgCreateCommunicators(Th, ThParMmg, n2o, communicators);
int[int] rest(ThParMmg.nv * (met.n / Th.nv));
if(met.n == 6 * Th.nv) {
    fespace VhMet(Th, [P1, P1, P1, P1, P1, P1]);
    fespace VhParMmg(ThParMmg, [P1, P1, P1, P1, P1, P1]);
    rest = restrict(VhParMmg, VhMet, n2o);
}
else if(met.n == Th.nv) {
    fespace VhMet(Th, P1);
    fespace VhParMmg(ThParMmg, P1);
    rest = restrict(VhParMmg, VhMet, n2o);
}
else
    assert(0);
metParMmg.resize(rest.n);
metParMmg = met(rest);
}//

varf vPoisson(u, v) = int3d(Th3)(grad(u)' * grad(v)) + int3d(Th3)(v) + on(1,2,3, u=0);

Mat<PetscScalar> A;
DmeshCreate(Th3);
MatCreate(Th3, A, P1);
fespace Vh(Th3, P1);
Vh<PetscScalar> u;
real err = 8.0e-3;

int iMax = getARGV("-iMax", 1);
int noTransfer = (getARGV("-transfer", 1) == 0);
int niter = getARGV("-niter", 3);
int verbose = getARGV("-verbose", 1);
bool isotropic = (usedARGV("-isotropic") != -1);
int elementsPerProcess = max(getARGV("-elements_per_process", 1), 8000);
int maxP = max(min(getARGV("-max_P", mpisize), mpisize), 1);
int[int] rt(2);
rt = [1,2];
for(int i = 0; i < iMax; ++i) {
    A = vPoisson(Vh, Vh, tgv = -2);
    set(A, sparams = "-ksp_monitor -pc_type gamg");
    PetscScalar[int] rhs = vPoisson(0, Vh, tgv = -1);
    u[] = A^-1 * rhs;
    mesh3 ThParMmg;
    DmeshInitialize(ThParMmg);
    int P = 1;
    if(maxP != 1) {
        fespace Ph(Th3, P0);
        Ph part;
        PartitionCreate(Th3, part[], P0);
        part = abs(part - 1.0) < 1e-1;
        int nt, ntLocal = part[].l1;
        mpiAllReduce(ntLocal, nt, mpiCommWorld, mpiSUM);
        P = min(maxP, min(mpisize, max(1, nt / elementsPerProcess)));
    }
    if(P != mpisize) {
        int div = mpisize / P;
        mpiComm commThGather(mpiCommWorld, (mpirank % div == 0 && mpirank / div < P) ? 0 : mpiUndefined, mpirank / div);
        mpiComm comm(mpiCommWorld, min(mpirank / div, P - 1), mpirank - div * min(mpirank / div, P - 1));
        macro ThGatherComm()commThGather//
        mesh3 ThGather;
        DmeshGather(Th3, comm, ThGather);
        fespace VhGather(ThGather, P1);
        VhGather<PetscScalar> uGather;
        VecGather(Th3, comm, ThGather, P1, u, uGather);
        macro ThGatherParMmgComm()commThGather//
        mesh3 ThGatherParMmg;
        DmeshInitialize(ThGatherParMmg);
        if((mpirank % div == 0 && mpirank / div < P) != 0) {
            real[int] met = mshmet(ThGather, abs(uGather), aniso = !isotropic, hmin = 1.0e-3, hmax = 1.0e-1, err = err);
            if(mpiSize(commThGather) > 1) {
                real[int] metParMmg;
                int[int][int] communicators;
                ParMmgCommunicatorsAndMetric(ThGather, met, ThGatherParMmg, metParMmg, communicators);
                ThGatherParMmg = parmmg3d(MmgParameters(ThGatherParMmg, metParMmg, rt, verbose), nodeCommunicators = communicators, niter = niter, comm = commThGather);
            }
            else
                ThGatherParMmg = mmg3d(MmgParameters(ThGather, met, rt, verbose));
        }
        DmeshScatter(ThGatherParMmg, comm, ThParMmg);
    }
    else {
        real[int] met = mshmet(Th3, abs(u), aniso = !isotropic, hmin = 1.0e-3, hmax = 1.0e-1, err = err);
        real[int] metParMmg;
        int[int][int] communicators;
        ParMmgCommunicatorsAndMetric(Th3, met, ThParMmg, metParMmg, communicators);
        ThParMmg = parmmg3d(MmgParameters(ThParMmg, metParMmg, rt, verbose), nodeCommunicators = communicators, niter = niter);
        DmeshReconstruct(ThParMmg);
    }
    int[int] fforder = [1];
    savevtk("laplace-adapt-dist-3d.vtu", Th3, abs(u), bin = 1, order = fforder, append = i ? true : false);
    if(!noTransfer) {
        fespace VhAdapt(ThParMmg, P1);
        VhAdapt<PetscScalar> uAdapt;
        VecInterpolate(Th3, P1, u, ThParMmg, P1, uAdapt);
        savevtk("laplace-adapt-dist-3d.vtu", ThParMmg, abs(uAdapt), bin = 1, order = fforder, append = true);
    }
    DmeshCopy(ThParMmg, Th3);
    Mat<PetscScalar> Adapt;
    MatCreate(Th3, Adapt, P1);
    A = Adapt;
    u = 0.0;
    err *= 0.5;
}
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with quadratic potential (the
// Quantum Harmonic Oscillator) on a pseudo-1d domain, using SLEPc.
//
// Here, we consider the problem of a 1d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + 0.5*x^2* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is the set half integrers :
//    E_n = n+1/2 (n \in N)
//
//   See e.g. :
//   - Chap. I in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//   - Landau & Lifshitz, Volume 3 : (Quantum Mechanics) Chap. III-23
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-1d-harmonic-oscillator-SLEPc.edp \
//        -split 1 -npts 1600 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 800) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 40.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 1)   ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-1d-harmonic-oscillator-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space
//fespace Vh(Th,Pk,periodic=[[Labels[0],x],[Labels[2],x]]); // Periodic does not work

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts); // pts on the x-axis sides
    int Ypts= 1;             // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= intN(Th)        //  Definion of  the problem
( 0.5*dx(uh)*dx(vh)
  +1000*dy(uh)*dy(vh)   // cheat for pseudo-1d since periodic does not work
  +( 0.5*x^2-sigma)*uh*vh      )//  Bilinear form
//  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
//  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
//  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
//  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= intN(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D, clean = true);
Mat DistB(DistA, B, clean = true);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);              // local finite element space
int[int][int] intersection(0);   // local-to-neighbors renumbering
real[int] D;                     // partition of unity
{
    mesh ThBorder;
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

matrix<real> Mat;                           // local operator
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 1.0);
Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(grad(u)' * grad(v)) + int1d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 1.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(grad(u)' * grad(v)) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err = A * u[]; // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

// sequential script from https://www.um.es/freefem/ff++/pmwiki.php?n=Main.Newton3D
// Navier--Stokes block solved using a modified augmented Lagrangian preconditioner,
// cf. [Moulin et al. 2019] (https://github.com/prj-/moulin2019al)

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
macro trueRestrict()true// EOM
macro removeZeros()true// EOM
include "macro_ddm.idp"             // additional DDM functions

mesh Th = square(getARGV("-global", 30), getARGV("-global", 30));
bool adaptation = usedARGV("-adaptation") != -1;
real gammaAL = 0.3;

macro grad(u)[dx(u), dy(u)]//
macro Grad(u)[grad(u#1), grad(u#2)]//
macro div(u)(dx(u#1) + dy(u#2))//
macro ugrad(u, v)([u#1, u#2]' * grad(v))//
macro UgradV(u, v, T)[ugrad(u, v#1), ugrad(u, v#2), ugrad(u, T)]//
macro Pk()[P2, P2, P1, P1]//
macro def(i)[i, i#B, i#C, i#D]// EOM      // vector field definition
macro init(i)[i, i, i, i]// EOM           // vector field initialization

fespace Wh(Th, [P2, P2, P1, P1]);
real nu        = 1/100.0;
real nuFinal   = 1/1500.0;
real Pr        = 56.2;
real k         = 1/Pr;
real nuCurrent = nu;


real[int] D;
int[int][int] intersection;
mesh ThBackup;
{
    if(adaptation)
        ThBackup = Th;
    int s = getARGV("-split", 1);
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

Wh [u1, u2, p, T] = [0, 0, 0, 1-x];

real c;
varf vPb([uw1, uw2, pw, Tw], [v1, v2, q, TT])
 = int2d(Th)(gammaAL * div(uw) * div(v) + UgradV(u, uw, Tw)' * [v1, v2, TT] + UgradV(uw, u, T)'  * [v1, v2, TT]
         + (Grad(uw) : Grad(v)) * nuCurrent
         + c * Tw * v2 + grad(Tw)' * grad(TT) * k - div(uw) * q - div(v) * pw)
 + int2d(Th)(gammaAL * div(u) * div(v) + UgradV(u, u, T)' * [v1, v2, TT]
         + (Grad(u) : Grad(v)) * nuCurrent
         + c * T * v2 + grad(T)' * grad(TT) * k - div(u) * q - div(v) * p)
 + on(1, 2, 3, 4, uw1 = 0, uw2 = 0) + on(2, 4, Tw = 0);
varf vS(p, q) = int2d(Th, qforder = 3)(-1/(gammaAL + nuCurrent) * p * q);

Mat dA(Wh.ndof, intersection, D);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(dA, u1[], inPETSc, inverse = true, exchange = true);
    real[int] out(Wh.ndof);
    out = vPb(0, Wh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(dA, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(dA, u1[], inPETSc, inverse = true, exchange = true);
    dA = vPb(Wh, Wh, tgv = -2);
    return 0;
}
while(nuCurrent > nuFinal) {
    if(adaptation || nu == nuCurrent) {
        Wh [list1, list2, listP, listT] = [1.0, 1.0, 1.0, 2.0];
        set(dA, sparams = "-ksp_monitor -ksp_max_it 100 -ksp_type fgmres -ksp_rtol 1.0e-2 -pc_type fieldsplit -fieldsplit_1_ksp_type gmres -fieldsplit_1_pc_type hypre", fields = list1[]);
        [list1, list2, listP, listT] = [1.0, 1.0, 2.0, 0.0];
        fespace Qh(Th, P1);
        Qh listS;
        listS[]= 1:Qh.ndof;
        Wh [uw1,uw2,pw,Tw] = [0.0, 0.0, listS, 0.0];
        matrix[int] S(1);
        S[0] = vS(Qh, Qh);
        string[int] names(2);
        names[0] = "v";
        names[1] = "p";
        string paramsNS = "-prefix_push fieldsplit_0_ -prefix_push fieldsplit_v_ -pc_type lu -prefix_pop -prefix_push fieldsplit_p_ -ksp_type cg -ksp_max_it 5 -pc_type jacobi -prefix_pop -ksp_type fgmres " + " -ksp_rtol 1.0e-2 -ksp_gmres_restart 200 -prefix_pop";
        set(dA, fieldsplit = 0, sparams = "-fieldsplit_0_ksp_type fgmres -fieldsplit_0_ksp_max_it 100 -fieldsplit_0_ksp_rtol 1.0e-1 -fieldsplit_0_pc_type fieldsplit " + paramsNS, fields = list1[], schurPreconditioner = S, schurList = uw1[], names = names);
    }
    c = -1/(nuCurrent * Pr);
    real[int] xPETSc;
    ChangeNumbering(dA, u1[], xPETSc);
    SNESSolve(dA, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_type newtonls -snes_rtol 1.0e-4");
    ChangeNumbering(dA, u1[], xPETSc, inverse = true, exchange = !adaptation);
    if(adaptation) {
        fespace VhG(ThBackup, Pk);
        VhG def(uG), def(uReduce);
        def(uReduce) = [u1, u2, p, T];
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0)
            ThBackup = adaptmesh(ThBackup, [uGD,uGD], [uG,uGB], ratio = 2.5);
        broadcast(processor(0), ThBackup);
        def(uG) = def(uG);
        Th = ThBackup;
        intersection.resize(0);
        D.resize(0);
        int s = getARGV("-split", 1);
        build(Th, s, intersection, D, Pk, mpiCommWorld)
        Mat dAdapt(Wh.ndof, intersection, D);
        dA = dAdapt;
        [u1, u2, p, T] = def(uG);
    }
    if(!NoGraphicWindow) {
        fespace Vh(Th, P1);
        Vh only = T;
        macro def1(i)i//
        plotMPI(Th, only, P1, def1, real, cmm = "Global temperature for viscosity = " + nuCurrent);
        only = p;
        plotMPI(Th, only, P1, def1, real, cmm = "Global pressure for viscosity = " + nuCurrent);
        fespace Zh(Th, [P2, P2]);
        Zh [onlyU, onlyV] = [u1, u2];
        macro def2(i)[i, i#B]//
        plotMPI(Th, [onlyU, onlyV], [P2, P2], def2, real, cmm = "Global velocity for viscosity = " + nuCurrent);
    }
    nuCurrent = max(nuFinal, nuCurrent/2.0);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

func Pk = P1;                       // finite element space
macro def(u)u//
func Pkdc = P1dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
mesh ThBackup = Th;
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);
Vh b = 100;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

func fu = sqrt((x - 0.5)^2 + (y - 0.5)^2) < 0.4 ? 0.1 : 1.0;
u[] = 0.0;
int step = 3;
real[int] xPETSc;
for(int i = 0; i < step; ++i) {
    xPETSc.resize(0);
    ChangeNumbering(A, u[], xPETSc);
    u[] = vC(0, Vh, tgv = -1);
    real[int] bPETSc, xuPETSc;
    ChangeNumbering(A, u[], bPETSc);
    {
        Vh xu = fu;
        plotMPI(Th, xu, Pk, def, real, cmm = "Upper bound");
        ChangeNumbering(A, xu[], xuPETSc);
    }
    SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, xu = xuPETSc, sparams = "-snes_monitor -snes_max_it " + (i != step - 1 ? 4 : 40) + " -ksp_converged_reason -snes_view -snes_vi_monitor -snes_type vinewtonrsls -snes_rtol 1.0e-6 -pc_type lu");
    if(i != step - 1) {
        ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = false);
        fespace VhG(ThBackup, Pk);
        VhG uG, uReduce;
        uReduce = u;
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
            ThBackup = adaptmesh(ThBackup, uG);
        }
        broadcast(processor(0), ThBackup);
        uG = uG;
        plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
        {
            Th = ThBackup;
            Mat Adapt;
            MatCreate(Th, Adapt, Pk);
            A = Adapt;
        }
        u = uG;
        plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
    }
}
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"                // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat<complex> A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int2d(Th)(1i*grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
complex[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<complex> u;                      // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

complex[int] err = A * u[];         // global matrix-vector product
complex[int] transpose = A' * u[];
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, complex, cmm = "Global residual");

set(A, sparams = "-pc_type lu");
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2, P1];             // finite element space

mesh Th;
{
    mesh ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]);    // global mesh
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-pc_type lu");
Wh<real> def(u);

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

macro def2(u)[u, u#B]// EOM
macro def1(u)u// EOM
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]// EOM// vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// two-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];             // finite element space

string deflation = getARGV("-deflation", "geneo");            // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - stokes-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh3 ThBorder, Th = buildlayers(square(1, 1), 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(ThAugmented)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs, eps = -1);
}
ThBorder = buildlayers(square(1, 1), 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_mkl_pardiso_iparm_13 1 --hpddm_schwarz_method oras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 1");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + int2d(Th, fakeInterface)(transmission * ([u, uB, uC]' * [v, vB, vC])) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

macro def1(u)u// EOM
plotMPI(Th, u, P2, def1, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

Mat A;
MatLoad(A, format = "binary", name = "stokes-mat-binary");
ObjectView(A, format = "info");
real[int, int] rhsView(1, 1);
MatLoad(rhsView, format = "binary", name = "stokes-rhs-binary");
real[int] rhs = rhsView.asarray;
real[int] x(rhs.n);
set(A, sparams = "-pc_type lu");
KSPSolve(A, rhs, x);
ObjectView(A, object = "ksp");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

load "PETSc-complex"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

assert(mpisize == 1);
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space
func real wedge(real a, real b) {
    if(y < 0.4 + 0.1 * 0.75 * x)
        return 2;
    else if(y < 0.8 - 0.2 * 0.75 * x)
        return 1.5;
    else
        return 3;
}
real omega = 2 * pi * 5;
func f = 80 * 100 * exp(-20 * 100 * ((x-0.5)^2 + (y-0.25)^2));

mesh Th = square(getARGV("-global", 30), getARGV("-global", 30));
fespace Ph(Th, P0);
Ph val = wedge(x, y);
Ph k = omega / val;
varf vPb(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, 2)(1i * k * u * v) + on(1, u = 0.0);

fespace Vh(Th, Pk);
Mat<complex> A(Vh.ndof);
A = vPb(Vh, Vh, tgv = -2);
int n = 10;
Vh<complex>[int]  sol(10);
complex[int] eigenvalues(10);
Vh<complex>[int] lsol(10);
Vh<complex>[int] rsol(10);
real[int] singularvalues(10);
int nconv = EPSSolve(A, values = eigenvalues, vectors = sol, sparams = "-eps_target 0 -eps_target_magnitude -eps_converged_reason -st_type sinvert -eps_nev " + n);
eigenvalues.resize(min(nconv, n));
sol.resize(min(nconv, n));
nconv = SVDSolve(A, values = singularvalues, lvectors = lsol, rvectors = rsol, sparams = "-svd_smallest -svd_converged_reason -svd_type lapack");
singularvalues.resize(min(nconv, n));
lsol.resize(min(nconv, n));
rsol.resize(min(nconv, n));
cout << eigenvalues << endl;
cout << singularvalues << endl;
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
include "macro_ddm.idp"

mesh ThNew, Th = square(getARGV("-global", 20), getARGV("-global", 20));
{
    int N = getARGV("-global", 20) / 2.0;
    border a(t=0,1) { x=t;   y=0;   };
    border b(t=0,1) { x=1;   y=t;   };
    border c(t=0,1) { x=1-t; y=1;   };
    border d(t=0,1) { x=0;   y=1-t; };
    ThNew = buildmesh(a(N)+b(N)+c(N)+d(N));
}
macro ThRefinementFactor()getARGV("-first_split", 1)//
macro ThNewRefinementFactor()getARGV("-second_split", 1)//
DmeshCreate(Th);
DmeshCreate(ThNew);
plotDmesh(Th, cmm = "First mesh");
plotDmesh(ThNew, cmm = "Second mesh");
func Pk = P2;
Mat A, B, P;
MatCreate(Th, A, Pk);
MatCreate(ThNew, B, Pk);
MatInterpolate(ThNew, Pk, B, Th, Pk, A, P);

macro grad(u)[dx(u), dy(u)]// EOM
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
fespace Vh(Th, Pk);
A = vPb(Vh, Vh);
Mat ANew;
MatPtAP(A, P, ANew);
ObjectView(A, format = "info");
ObjectView(ANew, format = "info");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "Morley"
include "macro_ddm.idp"
load "PETSc"

real f = 1;

mesh Th = square(40, 40);

fespace Wh(Th, P2);
fespace Vh(Th, P2Morley);

macro bilaplacian(u, v)(dxx(u)*dxx(v) + dyy(u)*dyy(v) + 2.0*dxy(u)*dxy(v))// EOM

varf vPb([u, ux, uy], [v, vx, vy]) = int2d(Th)(bilaplacian(u, v))
                                   + int2d(Th)(f*v)
                                   + on(1, 2, 3, 4, u=0, ux=0, uy=0);

Mat A;
MatCreate(Th, A, P2) // trick => use P2, not P2Morley!
A = vPb(Vh, Vh, tgv = -2);
real[int] rhs = vPb(0, Vh, tgv = -2);
Vh [u, ux, uy];
set(A, sparams = "-pc_type cholesky");
u[] = A^-1 * rhs;

macro def1(i)i// EOM
plotMPI(Th, u , P2, def1, real, wait = 1);
plotMPI(Th, ux, P2, def1, real, wait = 1);
plotMPI(Th, uy, P2, def1, real, wait = 1);

Wh v = u;
real loc = v[].max;
real glob;
mpiAllReduce(loc, glob, mpiCommWorld, mpiMAX);
int err = (abs(glob-0.0012782) > 1.0e-4);
assert(err == 0);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -sizeComm 2 -Dpartitioner=scotch

include "DmeshRedistribute.idp"
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with an axially symmetric potential
// well of finite depth and diameter, on a 2d domain, using SLEPc.
//
// Here, we consider the problem of a 2d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + V(x,y)* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is not known in general. Yet it features few
//  qualitative properties:
//      - the lowest excitations (eigenstates with the lowest eigenvalues)
//        are bound-states (the eigenstate is localized in the well since
//        it asymptotically goes to zero as a exponential)
//        and they are quantized (discrete eigenvalues)
//      - states with higher energies (when the eigenvalue is larger than
//        the depth of the potential well) are called diffusion states.
//        they are not localized (oscillating functions). This part of
//        the spectrum is also called radiative spectrum.
//        In principle, this is a continuous spectrum.
//
//   for the default values of the potential well, there are 11 bound-states
//   before entering the diffusion spectrum.
//
//   Note that here, the bound-states can be degenerate in energy
//
//   See e.g. :
//   - Complement H-I in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//   - Landau & Lifshitz, Volume 3 : (Quantum Mechanics) Chap. III-22
//   - Complement D-VI in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-2d-axial-well-SLEPc.edp \
//        -split 1 -npts 800 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 600) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 80.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 80.0); // Dimension of the domain
//
int nEV    = getARGV("-nev"  ,  20)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real width = getARGV("-width",10.0) ; // Diameter of the axial well
real depth = getARGV("-depth", 2.0) ; // Depth of the square well
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-2d-axial-well-SLEPc.edp "        << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  diameter of the well = " << width            << endl
        << "  depth of the well = " << depth               << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/
macro V(W,D)(0.5*(sqrt(x^2+y^2)-0.5*W < 0.0 ? 0.0 : D)) // End Of Macro

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( 0.5*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
+( V(width,depth)-sigma)*uh*vh               )//  Bilinear form
//  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
//  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
//  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
//  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type cholesky " +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
macro vectorialfe()P1// EOM
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
/*# DiffMacros #*/
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
/*# DiffMacrosEnd #*/
func Pk = [vectorialfe, vectorialfe, vectorialfe];             // finite element space

/*# DDMoptions #*/
string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));
/*# DDMoptionsEnd #*/

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
/*# SchwarzMethod #*/
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh3 ThBorder;
    Th = cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded, 3)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11; // steel
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
/*# SchwarzMethodEnd #*/

/*# OsmTwolevel #*/
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction balanced -hpddm_variant right -hpddm_verbosity 1 -hpddm_geneo_threshold 0.1");
/*# OsmTwolevelEnd #*/

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = 2 * kZero * mu * (2 * mu + lambda) / (lambda + 3 * mu);
        varf vOptimized(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th, fakeInterface)(transmission * (def(u)' * def(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 &&
       isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int2d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

/*# SolvePlot #*/
Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

mpiBarrier(mpiCommWorld);

macro def1(u)u// EOM
plotMPI(Th, u, vectorialfe, def1, real, cmm = "Global solution");
real alpha = 2000.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = err;
plotMPI(Th, u, vectorialfe, def1, real, cmm = "Global residual");
u[] = mpirank;
plotMPI(ThMoved, u, vectorialfe, def1, real, cmm = "Global moved solution");
/*# SolvePlotEnd #*/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

func Pk = P1;                       // finite element space
func Pkdc = P1dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);
Vh b = 1;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, 3, 4, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, 3, 4, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, 3, 4, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

Vh xu;
xu = sqrt((x - 0.5)^2 + (y - 0.5)^2) < 0.4 ? 0.2 : 1.0;
macro def(u)u//
plotMPI(Th, xu, Pk, def, real, cmm = "Upper bound");
real[int] xPETSc, bPETSc, xuPETSc;
u[] = vC(0, Vh, tgv = -1);
ChangeNumbering(A, u[], bPETSc);
ChangeNumbering(A, xu[], xuPETSc);
xPETSc.resize(bPETSc.n);
xPETSc = 0.1;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, xu = xuPETSc, sparams = "-snes_monitor -ksp_converged_reason -snes_view -snes_vi_monitor -snes_type vinewtonrsls -snes_rtol 1.0e-6 -pc_type lu");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]//    // vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// three-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];         // finite element space

string solver;
if(!HasType("MATSOLVER", "mumps") && !HasType("MATSOLVER", "superlu"))
    exit(0);
else
    solver = (HasType("MATSOLVER", "mumps") ? "mumps" : "superlu");

mesh3 Th;
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
real[int] rhs = vPb(0, Wh, tgv = -1);
Wh<real> def(u) = [1.0, 1.0, 1.0, 2.0];
string[int] names(2);
names[0] = "velocity";
names[1] = "pressure";

A = vPb(Wh, Wh, tgv = -1);
set(A, sparams = "-ksp_type fgmres -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_fact_type lower -pc_fieldsplit_detect_saddle_point -pc_fieldsplit_schur_precondition selfp -fieldsplit_velocity_sub_pc_type lu " + " -fieldsplit_pressure_sub_pc_type lu -fieldsplit_velocity_sub_pc_factor_mat_solver_type " + solver + " -fieldsplit_pressure_sub_pc_factor_mat_solver_type " + solver + " -ksp_monitor -ksp_view " + " -fieldsplit_velocity_ksp_type gmres -fieldsplit_velocity_ksp_max_it 5 -fieldsplit_pressure_ksp_type gmres -fieldsplit_pressure_ksp_max_it 5 -ksp_rtol 1e-6", fields = u[], names = names);
u[] = 0.0;
u[] = A^-1 * rhs;
macro def1(u)u//
plotMPI(Th, u, P2, def1, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

assert(mpisize == 1);
load "PETSc"

real[int, int] B(3, 3);
B = 1e-6;
matrix sp = B;
Mat T(sp);
func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] out(3);
    out[0] = inT[0] - 77.27*(in[1] + in[0]*(1 - 8.375e-6*in[0] - in[1]));
    out[1] = inT[1] - 1/77.27*(in[2] - (1 + in[0])*in[1]);
    out[2] = inT[2] - 0.161*(in[0] - in[2]);
    return out;
}
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    B = [[a - 77.27*((1 - 8.375e-6*in[0] - in[1]) - 8.375e-6*in[0]), -77.27*(1 - in[0]), 0],
         [1/77.27*in[1], a + 1/77.27*(1 + in[0]), -1/77.27],
         [-0.161, 0, a + 0.161]];
    sp = B;
    T = sp;
    return 0;
}
real[int] x(3);
x = [1, 2, 3];
func int funcM(int s, real t, real[int]& u) {
    cout << "step " << s << ", time " << t << ", sol " << u << endl;
}
TSSolve(T, funcJ, funcRes, x, sparams = "-ts_type rosw -ts_max_steps 2000 -ts_max_time 360 -ts_exact_final_time interpolate -ts_max_snes_failures -1 -ts_view -pc_type lu -ts_rtol 1e-3", monitor = funcM);
cout << x << endl;
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM

load "bem"
load "PETSc-complex"
include "macro_ddm.idp"

if(!HasType("Mat", "Htool")) exit(0);

complex k     = getARGV("-k", 10.0);

// incident wave
real[int] dir = [1,0];
func finc     = exp(1i*k*(dir[0]*x + dir[1]*y));
int n         = 1000;
func Pk       = P1;
func Qk       = P1;

border circle(t=0, 2*pi) { x=cos(t); y=sin(t); z=0; }
meshL ThL = buildmeshL(circle(n));
ThL = OrientNormal(ThL, unbounded = 1);
meshL ThG = ThL;
int[int] n2o;
macro ThLN2O()n2o//

fespace UhL(ThL, Pk);
fespace UhG(ThG, Pk);
varf vk(u, v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("SL",k=k), u, v));
Mat<complex> H, MatT, MatV;
{
macro dimension()3L// EOM
MatCreate(ThL, H, Pk);
MatCreate(ThL, MatT, P0);
MatCreate(ThL, MatV, P1);
}
CoherentGlobalMesh(MatT, MatV, ThL, ThG);
MatDestroy(MatT);
MatDestroy(MatV);
H = vk(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-2", sym = 1);
bool mass = usedARGV("-mass") != -1;
matrix<complex> M;
if(mass) {
    varf vM(u, v) = int1d(ThL)(u * v);
    M = vM(UhL, UhL);
}

varf vRHS(u, v) = -int1d(ThL)(finc*v);

UhL<complex> bf;
bf[] = vRHS(0, UhL);
if(mass) {
    set(H, sparams = "-ksp_view_singularvalues -ksp_converged_reason -ksp_gmres_restart 1000 -pc_type asm", O = M);
}
complex[int] u = H^-1 * bf[];
// visualization
if(!NoGraphicWindow) {
    macro dimension()2// EOM
    int np = 200;
    int R = 4;

    border b1(t=-R, R) { x = t ; y = -R; }
    border b2(t=-R, R) { x = R ; y = t; }
    border b3(t=-R, R) { x = -t; y = R; }
    border b4(t=-R, R) { x = -R; y = -t; }
    border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

    mesh ThOutG = buildmesh(b1(np) + b2(np) + b3(np) + b4(np) + circleout(-np*pi/R));
    mesh ThOutL = ThOutG;
    int[int] n2o;//
    macro ThOutLN2O()n2o//
    Mat<complex> B;
    MatCreate(ThOutL, B, Qk);
    MatCreate(ThOutL, MatT, P0);
    MatCreate(ThOutL, MatV, P1);
    CoherentGlobalMesh(MatT, MatV, ThOutL, ThOutG);
    MatDestroy(MatT);
    MatDestroy(MatV);
    fespace UhOutG(ThOutG, Qk);
    fespace UhOutL(ThOutL, Qk);
    varf vp(u, v) = int1d(ThG)(POT(BemPotential("SL", k=k), u, v));
    Mat<complex> HPot(B, H);
    HPot = vp(UhG, UhOutG, sparams = "-mat_htool_epsilon 1.0e-4");
    ObjectView(HPot);
    UhOutL<complex> v, vinc;
    vinc = finc;
    v[] = HPot*u;
    v[] += vinc[];
    UhOutL vr = abs(v);
    plotMPI(ThOutL, vr, P1, def, real, cmm = "Global first kind solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4 

/* ################################################################################## */
/*
    Solution of the Blasius boundary layer local spatial stability eigenproblem
    The eigenvalues exported in the "Blasius_EV.dat" file match those in figure 7.3a, Chapter 7, in

    Schmid, Peter & Henningson, Dan. (2001). Stability and Transition in Shear Flows. 10.1007/978-1-4613-0185-1.
*/
/* ################################################################################## */

load "PETSc-complex"

macro dimension()3L//
include "macro_ddm.idp"

func Pb2 = [P2, P2];
func Pc = [P2, P2, P1];

real ymin = 0.;
real ymax = 15.;
border yline(t=ymin,log(ymax+1)){x=0.;y=exp(t)-1;}
int np = 1000;

meshL thL=buildmeshL(yline(np));
meshL thLzero = thL;
fespace VhC(thL,Pc);
fespace VhBzero(thLzero,Pb2);
VhBzero<complex> [fG1,fG2];

/* ################################################################################## */
/* ######################## Solution of the Blasius equation ######################## */
/* ################################################################################## */
{
    meshL thL2 = thL;
    fespace VhB(thL2,Pb2);
    VhB<complex> [f1, f2];

    varf Resid([u1, u2], [v1, v2]) = int1d(thL2)(
          -dy(f1)*v1 + f2*v1
           +0.5*dy(f2)*f1*v2 - dy(f2)*dy(v2))
    + on(1, u1 = f1-0.)     /*  wall */
    + on(2, u2 = f2-1.)     /*  free stream  */
    + on(1, u2 = f2-0.);    /*  wall */
    varf Jacob([u1, u2], [v1, v2]) = int1d(thL2)(
          -1.*dy(u1)*v1 + u2*v1
           +0.5*dy(f2)*u1*v2 - dy(u2)*dy(v2) +0.5*dy(u2)*f1*v2)
    + on(1, u1 = f1-0.)     /*  wall */
    + on(2, u2 = f2-1.)     /*  free stream  */
    + on(1, u2 = f2-0.);    /*  wall */

    int[int] n2othL2;
    macro thL2N2O()n2othL2//
    Mat<complex> dJ;
    {
        macro def(u)[u, u#B]//EOM
        macro init(i)[i, i]//EOM
        MatCreate(thL2, dJ, Pb2);
    }
    set(dJ, sparams = "-ksp_type preonly -pc_type lu");

    [f1, f2] = [y, 1];

    func complex[int] funcRes(complex[int]& inPETSc) {
        ChangeNumbering(dJ, f1[], inPETSc, inverse = true, exchange = true);
        complex[int] out(VhB.ndof);
        out = Resid(0, VhB, tgv = -1);
        complex[int] outPETSc;
        ChangeNumbering(dJ, out, outPETSc);
        return outPETSc;
    }
    func int funcJ(complex[int]& inPETSc) {
        ChangeNumbering(dJ, f1[], inPETSc, inverse = true, exchange = true);
        dJ = Jacob(VhB, VhB, tgv = -1);
        return 0;
    }

    complex[int] xPETSc;

    ChangeNumbering(dJ, f1[], xPETSc);
    SNESSolve(dJ, funcJ, funcRes, xPETSc, sparams =  "-snes_monitor  -snes_max_it 20 -snes_linesearch_monitor -snes_linesearch_order 2 -snes_atol 1e-10 -snes_rtol 1e-10 -snes_stol 1e-10 -snes_converged_reason");
    ChangeNumbering(dJ, f1[], xPETSc, inverse = true, exchange = true);

    int[int] rest = restrict(VhB, VhBzero, n2othL2);
    f1[].re .*= dJ.D;
    f1[].im .*= dJ.D;
    VhBzero<complex> [fReduce1,fReduce2];
    for[i, v : rest] fReduce1[][v] = f1[][i];
    mpiAllReduce(fReduce1[], fG1[], mpiCommWorld, mpiSUM);

    /* scaling: displacement thickness */
    real Cm = 1.72089;
    [fG1, fG2] = [fG1(x,Cm*y,z), fG2(x,Cm*y,z)];

}

/* ################################################################################## */
/* ########################## Solution of the Eigenproblem ########################## */
/* ################################################################################## */

real Rey = getARGV("-Rey", 1000.);
real omega = getARGV("-omega", 0.26);
real shiftr = getARGV("-shiftr", 0.4);
real shifti = getARGV("-shifti", 0.1);
complex shift = shiftr + 1i*shifti;
int nEV = getARGV("-nEV", 100);
int nKryl = getARGV("-nKryl", 300);

real nu = 1./Rey;

varf A0mat([u1, u2, p], [v1, v2, q]) = int1d(thL)(
    -1i*omega*u1*v1 + nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)) + dy(fG2)*u2*v1
    -1i*omega*u2*v2 + nu*(dx(u2)*dx(v2) + dy(u2)*dy(v2)) + dy(p)*v2 +
    dy(u2)*q)
+ on(1, u1 = 0., u2 = 0.)                              /*  bot wall */
+ on(2, u1 = 0., u2 = 0.);                             /*  Free-stream */

varf A1mat([u1, u2, p], [v1, v2, q]) = int1d(thL)(
    1i*fG2*u1*v1 + 1i*p*v1 +
    1i*fG2*u2*v2 +
    1i*u1*q)
+ on(1, u1 = 0., u2 = 0.)                              /*  bot wall */
+ on(2, u1 = 0., u2 = 0.);                             /*  Free-stream */

varf A2mat([u1, u2, p], [v1, v2, q]) = int1d(thL)(
    nu*u1*v1 +
    nu*u2*v2)
+ on(1, u1 = 0., u2 = 0.)                              /*  bot wall */
+ on(2, u1 = 0., u2 = 0.);                             /*  Free-stream */

Mat<complex>[int] Apep(3);
macro def(u)[u, u#B, u#C]//EOM
macro init(i)[i, i, i]//EOM
{
    MatCreate(thL, Apep[0], Pc);
    MatCreate(thL, Apep[1], Pc);
    MatCreate(thL, Apep[2], Pc);
}

Apep[2] = A2mat(VhC,VhC,tgv=-1);
Apep[1] = A1mat(VhC,VhC,tgv=-1);
Apep[0] = A0mat(VhC,VhC,tgv=-1);

VhC<complex>[int] def(eigenvecVec)(nEV);
complex[int]  eigvalVec(nEV);
real[int]  errestVec(nEV);  
string PEPParamsbase =
  " -pep_basis monomial " +
  " -pep_general " +
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -pep_monitor_all"      ;

string PEPspar = PEPParamsbase + " -pep_target " + shift +
  " -pep_nev " + nEV       +
  " -pep_ncv " + nKryl + " ";

int nEvalConv = PEPSolve(Apep, vectors = eigenvecVec, values = eigvalVec, sparams = PEPspar, errorestimate = errestVec);

if(mpirank==0){
    cout << "Same output manually" << endl;
    cout <<  "    PEP nconv=" << nEvalConv << " Values (Errors)";
    for(int i=0; i<nEvalConv; i++){
        cout << " " << real(eigvalVec[i]) << "+" << imag(eigvalVec[i]) << "i (" << errestVec[i] << ")";
    }
    cout << endl;
}

if(mpirank == 0) {
    ofstream ofile("Blasius_EV.dat");
    ofile.precision(16);
    ofile << eigvalVec << endl;
}

/* ------------------------------------------------------------ */
/*                same problem solution with EPS                */
/* ------------------------------------------------------------ */
 
Mat<complex> dA, dB;

/* -1 factor for the companion matrix */
Apep[0] *= -1;
Apep[1] *= -1;

{
    matrix<complex> Id = eye(VhC.ndof);
    Mat<complex> IMat(Apep[0], Id);
    Mat<complex> dAux;
    dAux = [[IMat, 0],
            [0, Apep[2]]];
    MatConvert(dAux, dB);
    dAux = [[0, IMat],
            [Apep[0], Apep[1]]];
    MatConvert(dAux, dA); 
}

VhC<complex>[int] def(eigenvecCompVec)(nEV);
complex[int]  eigvalCompVec(nEV);  
real[int]  errestCompVec(nEV);  

string EPSParamsbase =            
  " -eps_type krylovschur" +
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_monitor_all"      +
  " -eps_gen_non_hermitian ";

string EPSpar = EPSParamsbase + " -eps_target " + shift +    
  " -eps_nev " + nEV       + 
  " -eps_ncv " + nKryl 	   + " "; 


int nEvalCompConv = EPSSolve(dA, dB, vectors = eigenvecCompVec, values = eigvalCompVec, sparams = EPSpar, errorestimate = errestCompVec); 

if(mpirank==0){
    cout << "Same output manually" << endl;
    cout <<  "    EPS nconv=" << nEvalCompConv << " Values (Errors)";
    for(int i=0; i<nEvalCompConv; i++){
        cout << " " << real(eigvalCompVec[i]) << "+" << imag(eigvalCompVec[i]) << "i (" << errestCompVec[i] << ")";
    }
    cout << endl;
}

//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -freq 1e+9

load "bem"
load "PETSc-complex"
macro dimension()3S// EOM
include "macro_ddm.idp"
include "cobrameshcavity.idp"

if(!HasType("Mat", "Htool")) exit(0);

real sec1   = 0.01;
real angle  = 2*pi*35/360;
real radius = 0.186;
real sec2   = 0.08;
real sec3   = 0.1;
real height = 0.084;
real width  = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0     = 299792458;
real f      = getARGV("-freq", 3.0e+9);
complex k   = 2*pi*f/c0;
real lambda = c0/f;
real distx  = 0.2*lambda;
real disty  = distx;
real distz  = distx;

int labextxm    = 11, labextxM = 12, labextym = 13, labextyM = 14, labextzm = 15, labextzM = 16;
int regint      = 4, regext = 5;
int labtomerge  = 7;
int labmetal    = 1;
int labi        = 2; // label in: entrance n = (-1,0,0)
int labo        = labmetal; // label out

// incident wave
real[int] dir   = [1,0,0];
func finc       = exp(1i*k*(dir[0]*x + dir[1]*y + dir[2]*z));
int nloc        = 10.0*sec3/lambda;

meshS ThS, ThG;
fespace Uh(ThS, P1);
fespace UhG(ThG, P1);
varf vk(u, v) = int2dx2d(ThG)(ThG)(BEM(BemKernel("SL", k=k), u, v));
Mat<complex> H;
{
    mesh3 Th3;
    buildcobramesh(Th3);
    Th3 = buildBdMesh(Th3);

    ThS = Th3.Gamma;
    ThS = trunc(ThS, region == labmetal);
    ThG = ThS;
    int[int] n2o;
    macro ThSN2O()n2o//
    MatCreate(ThS, H, P1);
    Mat<complex> T;
    MatCreate(ThS, T, P0);
    CoherentGlobalMesh(T, H, ThS, ThG);
}
H = vk(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-4");
plotDmesh(ThS, cmm = "Partitioning");
bool mass = usedARGV("-mass") != -1;
matrix<complex> M;
if(mass) {
    varf vM(u, v) = int2d(ThS)(u * v);
    M = vM(Uh, Uh);
}

varf vRHS(u, v) = -int2d(ThS)(finc*v);

Uh<complex> bf;
bf[] = vRHS(0, Uh);
if(mass) {
    set(H, sparams = "-ksp_type fgmres -ksp_view_singularvalues -ksp_converged_reason -ksp_gmres_restart 1000 -pc_type asm", O = M);
}
complex[int] u = H^-1 * bf[];
// visualization
if(!NoGraphicWindow) {
    distx = 2*lambda;
    disty = distx;
    distz = distx;

    int np = 100;
    meshS ThOutG = square3(np,np,
                         [(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3+2*distx)*x-distx,
                          (height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))*y
                          +(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,
                          width/2]);
    meshS ThOutS = ThOutG;
    int[int] n2o;//
    macro ThOutSN2O()n2o//
    Mat<complex> B, T;
    MatCreate(ThOutS, B, P1);
    MatCreate(ThOutS, T, P0);
    CoherentGlobalMesh(T, B, ThOutS, ThOutG);
    MatDestroy(T);
    fespace UhOutG(ThOutG, P1);
    fespace UhOutS(ThOutS, P1);
    varf vp(u, v) = int2d(ThS)(POT(BemPotential("SL", k=k), u, v));
    Mat<complex> HPot(B, H);
    HPot = vp(UhG, UhOutG, sparams = "-mat_htool_epsilon 1.0e-4");
    ObjectView(HPot, format = "ascii_info_detail");
    UhOutS<complex> v, vinc;
    vinc = finc;
    v[] = HPot*u;
    v[] += vinc[];
    UhOutS vr = real(v);
    plotMPI(ThOutS, vr, P1, def, real, cmm = "Global first kind solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2//
include "macro_ddm.idp"

macro def(i)i// EOM
macro init(i)i// EOM
func Pk = P2;
macro grad(u)[dx(u), dy(u)]// EOM

mesh ThNo, Th = square(getARGV("-global", 20), getARGV("-global", 20), [1 + x, y]);
fespace Vh(Th, Pk);
Mat H;
MatCreate(Th, H, Pk);
{
    fespace Ph(Th, P0);
    Ph part;
    PartitionCreate(Th, part[], P0);
    ThNo = trunc(Th, abs(part - 1.0) < 1e-1);
}
func g = cos(pi*x)*cos(pi*y);
func real J(real[int]& X) {
    Vh u;
    ChangeNumbering(H, u[], X, inverse = true, exchange = true);
    real glob, loc = int2d(ThNo)(sqrt(1 + grad(u)'*grad(u)));
    mpiAllReduce(loc, glob, mpiCommWorld, mpiSUM);
    return glob;
}

func real[int] DJ(real[int]& X) {
    Vh u;
    ChangeNumbering(H, u[], X, inverse = true, exchange = true);
    varf vG(w, v) = int2d(Th)((grad(u)'*grad(v)) / sqrt(1 + grad(u)'*grad(u)));
    real[int] out = vG(0, Vh);
    real[int] outPETSc;
    ChangeNumbering(H, out, outPETSc);
    return outPETSc;
}

func int HJ(real[int]& X) {
    Vh u;
    ChangeNumbering(H, u[], X, inverse = true, exchange = true);
    varf vH(v, w) = int2d(Th)((grad(w)'*grad(v)) / sqrt(1 + grad(u)'*grad(u))
            - (grad(w)'*grad(u)) * (grad(v)'*grad(u)) *(1 + grad(u)'*grad(u))^-1.5);
    matrix Loc = vH(Vh, Vh);
    H = Loc;
    return 0;
}
varf onGamma(u, v) = on(1, 2, 3, 4, u = 1);
Vh onG;
onG[] = onGamma(0, Vh, tgv = 1);
real[int] lbPETSc, ubPETSc;
{
    Vh lb = onG != 0 ? g : -1e19;
    Vh ub = onG != 0 ? g :  1e19;
    lb = max(lb, 3-100*(((x-1.5)^2 + (y-0.5)^2))^2);
    ChangeNumbering(H, lb[], lbPETSc);
    ChangeNumbering(H, ub[], ubPETSc);
}

{
    Vh u = onG != 0 ? g : 0;
    real[int] uPETSc;
    ChangeNumbering(H, u[], uPETSc);
    TaoSolve(H, J, DJ, uPETSc, xl = lbPETSc, xu = ubPETSc, sparams = "-tao_monitor -tao_view -tao_type bqnls -tao_max_it 40 -tao_gatol 1e-4");
    ChangeNumbering(H, u[], uPETSc, inverse = true, exchange = true);
    real Ju = J(uPETSc);
    plotMPI(Th, u, Pk, def, real, cmm = "Global solution, J(u) = " + Ju);
}
{
    Vh u = onG != 0 ? g : 0;
    real[int] uPETSc;
    ChangeNumbering(H, u[], uPETSc);
    TaoSolve(H, J, DJ, uPETSc, xl = lbPETSc, xu = ubPETSc, sparams = "-tao_monitor -tao_view -tao_type bnls -tao_max_it 40 -tao_gatol 1e-4", HessianRoutine = HJ);
    ChangeNumbering(H, u[], uPETSc, inverse = true, exchange = true);
    real Ju = J(uPETSc);
    plotMPI(Th, u, Pk, def, real, cmm = "Global solution, J(u) = " + Ju);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM

load "bem"
load "PETSc-complex"
include "macro_ddm.idp"

if(!HasType("Mat", "Htool")) exit(0);

complex k     = getARGV("-k", 10.0);

// incident wave
real[int] dir = [1,0];
func finc     = exp(1i*k*(dir[0]*x + dir[1]*y));
int n         = 1000;

border circle(t=0, 2*pi) { x=cos(t); y=sin(t); z=0; }
meshL ThG, ThL = buildmeshL(circle(n));
ThL = OrientNormal(ThL, unbounded = 1);
ThG = ThL;
int[int] n2o;
macro ThLN2O()n2o//
Mat<complex> A;
{
    macro dimension()3L// EOM
    MatCreate(ThL, A, P1);
    Mat<complex> T;
    MatCreate(ThL, T, P0);
    CoherentGlobalMesh(T, A, ThL, ThG);
}

fespace Uh(ThL, P1);
fespace UhG(ThG, P1);
varf vk(u, v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("SL", k=k), u, v));
A = vk(UhG, UhG);

varf vRHS(u, v) = -int1d(ThL)(finc*v);
Uh<complex> b, u;
b[] = vRHS(0, Uh);
Mat<complex> E, D;
MatConvert(A, E);
MatConvert(E, D);
set(D, sparams = "-ksp_view -ksp_monitor -pc_type cholesky");
ObjectView(D, format = "info");
complex[int] uP, bP;
ChangeNumbering(A, b[], bP);
uP.resize(bP.n);
KSPSolve(D, bP, uP);
ChangeNumbering(A, u[], uP, inverse = true, exchange = true);
// visualization
if(!NoGraphicWindow) {
    macro dimension()2// EOM
    int np = 200;
    int R = 4;

    border b1(t=-R, R) { x = t ; y = -R; }
    border b2(t=-R, R) { x = R ; y = t; }
    border b3(t=-R, R) { x = -t; y = R; }
    border b4(t=-R, R) { x = -R; y = -t; }

    mesh ThOutG, ThOutL = buildmesh(b1(np) + b2(np) + b3(np) + b4(np) + circle(-np*pi/R));
    fespace UhOut(ThOutL, P1);
    int[int] n2o;//
    macro ThOutLN2O()n2o//
    Mat<complex> B, T;
    ThOutG = ThOutL;
    MatCreate(ThOutL, B, P1);
    MatCreate(ThOutL, T, P0);
    CoherentGlobalMesh(T, B, ThOutL, ThOutG);
    MatDestroy(T);
    varf vp(u, v) = int1d(ThL)(POT(BemPotential("SL", k=k), u, v));
    Mat<complex> HPot(B, A);
    fespace UhOutG(ThOutG, P1);
    HPot = vp(UhG, UhOutG);
    UhOut<complex> v, vinc;
    vinc = finc;
    v[] = HPot*u[];
    v[] += vinc[];
    UhOut vr = abs(v);
    plotMPI(ThOutL, vr, P1, def, real, cmm = "Global first kind solution");
}
//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling-PETSc-composite.edp -wg

/* example of wave guiding with gradient-index lenses */

load "bem"
load "PETSc-complex"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int[int] nsl(10); // number of lenses
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

// Fem mesh :
mesh Th = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l)+circle(nsl));

plot(Th, wait=1, dim=2, cmm="FEM mesh Th");

int[int] lab = [interface];
meshL ThL = extract(Th, label=lab); // BEM mesh
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL, wait=1, dim=2, cmm="BEM mesh ThL");

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);
reg = region;

func ind = reg == -1 ? 1 : 2./(1+((x-nsx[max(0.,reg-1)])^2+(y-nsy[max(0.,reg-1)])^2)); // gradient index in lenses

fespace Uh(Th,P1);
fespace UhL(ThL,P1);
fespace Ch=Uh*UhL;

macro Grad(u) [dx(u),dy(u)] // EOM

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (Frhs)
(  mass  -SL ) (ubem)   ( 0  ) */

Uh<complex> ufem,v1;
UhL<complex> ubem,v2;

// problem formulation
varf vfLenses(<[ufem],[ubem]>,<[v1],[v2]>) =
                                int2d(Th)(-ind*k^2*ufem*v1 + Grad(ufem)'*Grad(v1)) // F
                              + int1dx1d(ThL)(ThL)(BEM(BemKernel("TDL",k=k),ubem,v1)) + int1d(ThL)(0.5*ubem*v1) // TDL
                              + int1d(ThL)(ufem*v2)                        // mass
                              + int1dx1d(ThL)(ThL)(BEM(-1*BemKernel("SL",k=k),ubem,v2))  // -SL
                              + int2d(Th)(finc*v1) + on(waveguide,ufem=0) ; // RHS

// the linear system is assembled in parallel ; the distributed matrix is then passed to PETSc as a nested Mat (MatNest)
Mat<complex> HC = vfLenses(Ch,Ch);
complex[int] rhs = vfLenses(0,Ch);

// example of fieldsplit preconditioner ; the fields are automatically deduced from the composite FE space Ch
set(HC,sparams="-ksp_view -ksp_monitor -ksp_type fgmres -ksp_view_final_residual -ksp_gmres_restart 200 -pc_type fieldsplit -fieldsplit_0_pc_type lu "+"-fieldsplit_1_ksp_type gmres -fieldsplit_1_ksp_max_it 20");

complex[int] u = HC^-1*rhs;

[ufem[],ubem[]] = u; // dispatch solution

plot(ufem, fill=1, value=1, wait=1, dim=2, cmm="FEM solution");
plot(ubem, fill=1, value=1, wait=1, dim=2, cmm="BEM ansatz on ThL");

// output mesh for visualization
int np = 200/2;
real R = 20;
real rr = 20;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R/rr)+b2(np)+b3(np*R/rr)+b4(np)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(UhL,UhOut);
if (mpirank == 0) cout << B.infos << endl;

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40, cmm="u");
//  run with MPI:  ff-mpirun -np 4 diffusion-hpddm-2d-PETSc.edp -ns -pc_type cholesky -wg
// Options for -pc_type: cholesky (direct solver), gamg (algebraic multigrid), hpddm (multilevel domain decomposition method with the GenEO coarse problem)
// Options for hpddm via PETSc are given in: https://petsc.org/release/manualpages/PC/PCHPDDM/
// As far as PCHPDDM is concerned, this script implements the GenEO method with a threshold selection criteria for the construction of the coarse problem
// NBPROC 4
// Authors: P. Jolivet, F. Nataf

load "PETSc"
include "macro_ddm.idp"

tgv = -2;

macro grad(u)[dx(u), dy(u)]// EOM
func Pk = P1;

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//

// decompose and distribute the mesh Th, and allocates data structures for the communication of the distributed matrix A
// after this line, Th refers to a local mesh: the one of the subdomain
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk); // local finite element space on the local mesh Th
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);

Wh u, rhs, residual; // local solution, right-hand side, and final residual

// local component of the global right-hand side
rhs[] = vPb(0, Wh);

if(1) {
    // R_i sum R_j^T D_j rhs_j
    exchange(A, rhs[] , scaled = true);
    plotD(Th, rhs, cmm = "Global right-hand side")
}

matrix Neumann = vPb(Wh, Wh); // local matrix with Neumann boundary condition on the interface of the subdomain
// recall that A is a distributed matrix and Neumann is a local one
// the following equal sign '=' means in fact that the entries of the distributed matrix A are filled with the entries of the local Neumann matrix, then A is ready for use
A = Neumann;

// near kernel of the operator (used only by PCGAMG)
Wh Rb[1];
Rb[0] = 1;
// all in one; see at the end of the script the meaning of the parameters
set(A, sparams = " -pc_hpddm_levels_1_sub_pc_type cholesky -pc_hpddm_levels_1_sub_pc_factor_mat_solver_type mumps -pc_hpddm_has_neumann " +
                 " -pc_hpddm_define_subdomains -pc_hpddm_levels_1_pc_asm_type basic -pc_hpddm_coarse_correction additive " +
                 " -pc_hpddm_levels_1_sub_mat_mumps_cntl_4 0.1 -pc_hpddm_levels_1_eps_use_inertia -pc_hpddm_levels_1_eps_threshold 0.5 -pc_hpddm_levels_1_st_share_sub_ksp " +
                 " -ksp_type cg -ksp_monitor_singular_value", nearnullspace = Rb);
u[] = A^-1 * rhs[];

residual[] = A * u[];
residual[] -= rhs[];

plotD(Th, residual, cmm = "Global Residual");
plotD(Th, u, cmm = "Global Solution");

// meaning of some flags in sparams when using PCHPDDM (-pc_type hpddm on the command line)
//  -pc_hpddm_levels_1_sub_pc_type cholesky                - subdomain solver is an exact Cholesky factorization
//  -pc_hpddm_levels_1_sub_pc_factor_mat_solver_type mumps - MUMPS is used for computing local exact factorizations
// -pc_hpddm_levels_1_eps_threshold                        - threshold for selecting the eigenvectors in the GenEO coarse space
//  -pc_hpddm_has_neumann                                  - local matrices passed to PCHPDDM are the Neumann matrices, see https://petsc.org/release/manualpages/PC/PCHPDDMHasNeumannMat/
//  -pc_hpddm_define_subdomains                            - use the FreeFEM overlap to define the preconditioner on the first level
//  -pc_hpddm_levels_1_pc_asm_type basic                   - https://petsc.org/release/manualpages/PC/PCASMType/
//  -pc_hpddm_coarse_correction additive                   - https://petsc.org/release/manualpages/PC/PCHPDDMCoarseCorrectionType/
//  -pc_hpddm_levels_1_sub_mat_mumps_cntl_4 0.1            - static pivoting to get a reliable estimate of the inertia, see CNTL(4) in https://mumps-solver.org/index.php?page=doc
//  -pc_hpddm_levels_1_eps_use_inertia                     - needed when using a threshold for defining the GenEO coarse problem
//  -pc_hpddm_levels_1_st_share_sub_ksp                    - https://petsc.org/release/manualpages/PC/PCHPDDMSetSTShareSubKSP/
//  -ksp_type cg                                           - conjugate gradient as the Krylov solver, see https://petsc.org/release/manualpages/KSP/KSPType/
//  -ksp_monitor_singular_value                            - https://petsc.org/release/manualpages/KSP/KSPMonitorSingularValue/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - helmholtz-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

func real wedge(real a, real b) {
    if(y < 0.4 + 0.1 * 0.75 * x)
        return 2.0;
    else if(y < 0.8 - 0.2 * 0.75 * x)
        return 1.5;
    else
        return 3.0;
}
real omega = 2 * pi * 5;
func f = 80 * 100 * s * exp(-20 * 100 * s * ((x-0.5)^2 + (y-0.25)^2));
complex[int] rhs;                           // local right-hand side
matrix<complex> Mat;                        // local operator
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    fespace PhAugmented(ThAugmented, P0);
    PhAugmented val = wedge(x, y);
    PhAugmented k = omega / val;
    varf vPb(u, v) = int2d(ThAugmented)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(ThAugmented, 2)(1i * k * u * v) + int2d(ThAugmented)(f * v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    complex[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz<complex> A(Mat, intersection, D, scaled = false);

matrix<complex> Opt;                        // local operator with optimized boundary conditions
pair<complex> ret;
{
    int solver = getOption("schwarz_method");
    fespace Ph(Th, P0);
    Ph val = wedge(x, y);
    Ph k = omega / val;
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        varf vOptimized(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, 2)(1i * k * u * v) + int2d(Th)(f * v) + int1d(Th, fakeInterface)(1i *  k * u * v) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, 2)(1i * k * u * v) + int2d(Th)(f * v) + on(1, u = 0.0);
            matrix<complex> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<complex> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<complex> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

complex[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, complex, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

int[int] n2oSaved;
int[int] n2oLoaded;
{
    macro dimension()3//
    include "macro_ddm.idp"
    mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z]);
    Mat A;
    macro ThN2O()n2oSaved//
    MatCreate(Th, A, P1);
    DmeshSave(Th, "dump-3d");
}
{
    macro dimension()2//
    include "macro_ddm.idp"
    mesh Th = square(40, 40);
    Mat A;
    MatCreate(Th, A, P1);
    DmeshSave(Th, "dump-2d");
}
{
    macro dimension()3//
    include "macro_ddm.idp"
    mesh3 Th;
    Mat A;
    macro ThN2O()n2oLoaded//
    DmeshLoad(Th, "dump-3d");
    MatCreate(Th, A, P2);
}
{
    macro dimension()2//
    include "macro_ddm.idp"
    mesh Th;
    Mat A;
    DmeshLoad(Th, "dump-2d");
    MatCreate(Th, A, P0);
}
if(mpisize > 1) {
    n2oLoaded -= n2oSaved;
    assert(n2oLoaded.linfty < 1.0e-12);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

int[int] I(1), J(1);
I(0) = 0;
J(0) = 0;

if(mpisize != 4)
    exit(1);

int[int] Ji;
matrix[int] Ai(0);
if(mpirank == 0) {
    Ji.resize(2);
    Ai.resize(2);
    Ji[0] = 0; Ji[1] = 2;
    real[int] C(1);
    C(0) = 10.0;
    Ai[0] = [I, J, C];
    C(0) = 2.0;
    Ai[1] = [I, J, C];
}
else if(mpirank == 1) {
    Ji.resize(2);
    Ai.resize(2);
    Ji[0] = 1; Ji[1] = 2;
    real[int] C(1);
    C(0) = -10.0;
    Ai[0] = [I, J, C];
    C(0) = 3.0;
    Ai[1] = [I, J, C];
}
else if(mpirank == 2) {
    Ji.resize(2);
    Ai.resize(2);
    Ji[0] = 0; Ji[1] = 2;
    real[int] C(1);
    C(0) = -1.0;
    Ai[0] = [I, J, C];
    C(0) = 5.0;
    Ai[1] = [I, J, C];
}
else if(mpirank == 3) {
    Ji.resize(1);
    Ai.resize(1);
    Ji[0] = 3;
    real[int] C(1);
    C(0) = 7.0;
    Ai[0] = [I, J, C];
}
Mat A(Ai, columns = Ji);
real[int] x(1), b(1);
b = (mpirank + 1) * 10;
x = A^-1 * b;
for(int i = 0; i < mpisize; ++i) { mpiBarrier(mpiCommWorld); if(i == mpirank) cout << "rhs on process #" << mpirank << ": " << b[0] << ", solution: " << x[0] << endl; mpiBarrier(mpiCommWorld); }
real[int] y(1);
y = A * x;
for(int i = 0; i < mpisize; ++i) { mpiBarrier(mpiCommWorld); if(i == mpirank) cout << "A * x on process #" << mpirank << ": " << y[0] << ", rhs: " << b[0] << endl; mpiBarrier(mpiCommWorld); }
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
macro vectorialfe()P2// EOM
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [vectorialfe, vectorialfe];                 // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);              // local finite element space
int[int][int] intersection(0);   // local-to-neighbors renumbering
real[int] D;                     // partition of unity
{
    int[int] l = [2, 1, 2, 2];
    mesh ThBorder;
    Th = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l);    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded, 2)
}

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
Mat = vPb(Wh, Wh, sym = 1);
real[int] rhs = vPb(0, Wh);

schwarz A(Mat, intersection, D);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = 2 * kZero * mu * (2 * mu + lambda) / (lambda + 3 * mu);
        varf vOptimized(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int1d(Th, fakeInterface)(transmission * (def(u)' * def(v))) + on(1, u = 0.0, uB = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
u[] = err;
macro def1(u)u// EOM
plotMPI(Th, u, vectorialfe, def1, real, cmm = "Global residual");
real alpha = 1.0e+1;
mesh ThMoved = movemesh(Th, [x + alpha * u, y + alpha * uB]);
u[] = mpirank;
plotMPI(ThMoved, u, vectorialfe, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2//
include "macro_ddm.idp"
mesh Th = square(80, 80);

Mat A;
func Pk = P2;

{
    fespace Ph(Th, P0);
    Ph reg = (x-0.5)^2 + (y-0.5)^2 < 0.1 ? 2 : 1;
    plot(reg, wait = 1, value = 1, fill = 1);
    Th = change(Th, fregion = reg[][nuTriangle]);
    real[int] part(Ph.ndof);
    {
        Ph cond = region == 1;

        int[int] new2oldCond(1), new2oldNoCond(1);

        mesh ThCond = trunc(Th, abs(cond) > 0.01, new2old = new2oldCond);
        mesh ThNoCond = trunc(Th, abs(cond) < 0.01, new2old = new2oldNoCond);

        fespace PhCond(ThCond, P0);
        fespace PhNoCond(ThNoCond, P0);

        real[int] partCond(PhCond.ndof);
        real[int] partNoCond(PhNoCond.ndof);

        if(mpirank == 0) {
            partitionerSeq(partCond, ThCond, mpisize);
            partitionerSeq(partNoCond, ThNoCond, mpisize);
        }
        partitionerPar(partCond, ThGlCond, mpiCommWorld, mpisize);
        partitionerPar(partNoCond, ThGlNoCond, mpiCommWorld, mpisize);

        for[i, v : partCond]   part[new2oldCond[i]] = v;
        for[i, v : partNoCond] part[new2oldNoCond[i]] = v;

    }
    macro ThUserPartitioning()part// EOM
    DmeshCreate(Th);
    MatCreate(Th, A, Pk);
}

fespace Ph(Th, P0);
Ph cond = region == 2;
int[int] n2o;
mesh ThCond = trunc(Th, abs(cond), new2old = n2o, label = 5);
fespace Vh(Th, Pk);
fespace VhCond(ThCond, Pk);
matrix R;
int[int] restCond = restrict(VhCond, Vh, n2o);
{
    int[int] I = 0:restCond.n - 1;
    real[int] C(I.n);
    C = 1;
    R = [I, restCond, C];
    R.resize(VhCond.ndof, Vh.ndof);
}
Mat B(A, restriction = R);
varf vPb(u, v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th)(v) + on(1,2,3,4, u=0);
VhCond g;
varf vPbCond(u, v) = int2d(ThCond)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(ThCond)(10*v) + on(5, u=10*g);
A = vPb(Vh, Vh, tgv = -2);
B = vPbCond(VhCond, VhCond, tgv = -1);
set(A, sparams = "-pc_type hypre -ksp_converged_reason");
set(B, sparams = "-pc_type hypre -ksp_converged_reason");
Vh u;
real[int] rhs = vPb(0, Vh, tgv = -2);
u[] = A^-1 * rhs;
g[] = u[](restCond);
// g[] = R * u[];
// the two lines above are strictly equivalent! I prefer line 71 because you can see that it's just
// a matter of picking up the correct indices to restrict u into g
real[int] rhsCond = vPbCond(0, VhCond, tgv = -1);
VhCond uCond;
uCond[] = B^-1 * rhsCond;
macro params()cmm = "Solution", wait = 1, dim = 3, value = 1//
plotD(Th, u, params);
plotD(ThCond, uCond, params);
u[] = 0;
u[](restCond) = uCond[];
// u[] = R' * uCond[];
// the two lines above are strictly equivalent! I prefer line 82 because you can see that it's just
// a matter of picking up the correct indices to prolong uCond into u
plotD(Th, u, params);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2, P1];             // finite element space

string deflation = getARGV("-deflation", "geneo");            // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - stokes-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh ThGlobal = square(getARGV("-global", 30), getARGV("-global", 30), [x, y]);    // global mesh
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    varf vPb([u, uB, p], [v, vB, q]) = int2d(ThAugmented)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented);
    real[int] rhsFull = vPb(0, WhAugmented);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs, eps = -1);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_mkl_pardiso_iparm_13 1 -hpddm_schwarz_method oras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 1");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + int1d(Th, fakeInterface)(transmission * ([u, uB]' * [v, vB])) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
        Opt = vOptimized(Wh, Wh);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

macro def2(u)[u, u#B]// EOM
macro def1(u)u// EOM
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure");
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with square potential of finite depth
// and width, on a pseudo-1d domain, using SLEPc.
//
// Here, we consider the problem of a 1d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + V(x)* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is not known in general. Yet it features few
//  qualitative properties:
//      - the lowest excitations (eigenstates with the lowest eigenvalues)
//        are bound-states (the eigenstate is localized in the well since
//        it asymptotically goes to zero as a exponential)
//        and they are quantized (discrete eigenvalues)
//      - states with higher energies (when the eigenvalue is larger than
//        the depth of the potential well) are called diffusion states.
//        they are not localized (oscillating functions). This part of
//        the spectrum is also called radiative spectrum.
//        In principle, this is a continuous spectrum.
//
//   for the default values of the potential well, there are 5 bound-states
//   before entering the diffusion spectrum.
//
//   See e.g. :
//   - Complement H-I in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//   - Landau & Lifshitz, Volume 3 : (Quantum Mechanics) Chap. III-22
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-1d-square-well-SLEPc.edp \
//        -split 1 -npts 400 -nev 10 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 400) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 80.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 1)   ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real width = getARGV("-width",10.0) ; // Width of the square well
real depth = getARGV("-depth", 2.0) ; // Depth of the square well
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-1d-square-well-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  width of the well = " << width               << endl
        << "  depth of the well = " << depth               << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space
//fespace Vh(Th,Pk,periodic=[[Labels[0],x],[Labels[2],x]]); // Periodic does not work

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts); // pts on the x-axis sides
    int Ypts= 1;             // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/
macro V(W,D)(0.5*(abs(x)-0.5*W < 0.0 ? 0.0 : D)) // End Of Macro

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= intN(Th)        //  Definion of  the problem
( 0.5*dx(uh)*dx(vh)
  +1000*dy(uh)*dy(vh)   // cheat for pseudo-1d since periodic does not work
  //  ( 0.5*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
  +( V(width,depth)-sigma)*uh*vh               )//  Bilinear form
  //  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
  //  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
  //  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
  //  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= intN(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D, clean = true);
Mat DistB(DistA, B, clean = true);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

int s = getARGV("-split", 8);       // refinement factor

border aa(t=0,1) { x=t;   y=0;   label=1; };
border bb(t=0,1) { x=1;   y=t;   label=2; };
border cc(t=0,1) { x=1-t; y=1;   label=3; };
border dd(t=0,1) { x=0;   y=1-t; label=4; };

mesh Th, ThCoarse = buildmesh(aa(getARGV("-global", 20)) + bb(getARGV("-global", 20)) + cc(getARGV("-global", 20)) + dd(getARGV("-global", 20)));
fespace Wh(Th, Pk);                 // local finite element space
real[int] part;
fespace PhCoarse(ThCoarse, P0);
PhCoarse partCoarse;
if(mpirank == 0)
    partitionerSeq(partCoarse[], ThCoarse, mpisize);
partitionerPar(partCoarse[], ThCoarse, mpiCommWorld, mpisize);
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = trunc(ThCoarse, 1, split = s);
    fespace Ph(Th, P0);
    Ph part;
    part = partCoarse;
    buildWithPartitioning(Th, part[], 1, intersection, D, Pk, mpiCommWorld);
}

varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1);
fespace WhCoarse(ThCoarse, Pk);
matrix MatCoarse;
{
    mesh ThBackup = Th;
    Th = ThCoarse;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    Th = ThBackup;
}
set(MatCoarse, solver = sparsesolverSym, sym = 1);
matrix R = interpolate(Wh, WhCoarse);
real[int] rhs = vPb(0, Wh);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_verbosity " + (!mpirank ? "3" : "0") + "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_variant flexible");
func real[int] correctionExact(real[int]& in) {
    real[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    in .*= D;
    tmp = R' * in;
    mpiAllReduce(tmp, tmpReduced, mpiCommWorld, mpiSUM);
    tmp = MatCoarse^-1 * tmpReduced;
    out = R * tmp;
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionExact);
}

Wh<real> def(u);    // local solution
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution with a redundant coarse correction");

int[int][int] intersectionCoarse;
real[int] DCoarse;
{
    buildWithPartitioning(ThCoarse, partCoarse[], 1, intersectionCoarse, DCoarse, Pk, mpiCommWorld);
    mesh ThBackup = Th;
    Th = ThCoarse;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    Th = ThBackup;
}
matrix NeumannCoarse = MatCoarse;
R = interpolate(Wh, WhCoarse);
schwarz ACoarse(MatCoarse, intersectionCoarse, DCoarse);
set(A, sparams = "-hpddm_variant flexible -hpddm_verbosity " + (!mpirank ? "3" : "0"));
set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_level_2_schwarz_method ras -hpddm_level_2_tol 1e-10", prefix = "level_2_");
macro mplot()wait = 1, cmm = "Transfers on the correction at iteration " + ijk//
int ijk = 1;
func real[int] correctionInexact(real[int]& in) {
    real[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        Wh outW;
        outW[] = in;
        plotMPI(Th, outW, Pk, def, real, mplot);
    }
    tmpReduced = R' * in;
    exchange(ACoarse, tmpReduced, scaled = true);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        WhCoarse outWCoarse;
        outWCoarse[] = tmpReduced;
        plotMPI(ThCoarse, outWCoarse, Pk, def, real, mplot);
        ++ijk;
    }
    tmp = ACoarse^-1 * tmpReduced;
    out = R * tmp;
    exchange(A, out);
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionInexact);
else
    exit(0);

u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution with a one-level inner coarse correction (two levels in total)");

set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "4" : "0") + " -hpddm_level_2_schwarz_coarse_correction deflated -hpddm_level_2_geneo_nu 10");
AttachCoarseOperator(mpiCommWorld, ACoarse, A = NeumannCoarse);
set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_level_3_verbosity 0");

ijk = 0;
u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution with a two-level inner coarse correction (three levels in total)");

statistics(A);
statistics(ACoarse);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -DCartesianPartitioning=1

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro simple2d(Ph, function, comm, deltaX, deltaY)
    Ph xx = x / deltaX, yy = y / deltaY;
    int i = int(sqrt(mpiSize(comm)));
    while(mpiSize(comm) % i != 0)
        --i;
    int j = mpiSize(comm) / i;
    function = int(j * xx) + int(i * yy) * j;// EOM

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

mesh Th = square(getARGV("-global", 13), getARGV("-global", 13)); // global mesh
Mat A;
fespace Ph(Th, P0);
IFMACRO(!CartesianPartitioning)
Ph part;
{
    simple2d(Ph, part, mpiCommWorld, 1.0, 1.0)
    plot(part, fill = 1, wait = 1);
}
macro ThUserPartitioning()part[]// EOM
ENDIFMACRO
IFMACRO(CartesianPartitioning)
macro ThCartesianPartitioning()// EOM
ENDIFMACRO

DmeshCreate(Th);
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
real[int] rhs = vPb(0, Wh, tgv = -2);
matrix unassembled(Wh.ndof);
Wh<real> u;                         // local solution
A = vPb(Wh, Wh, sym = 0, tgv = -2);
set(A, sparams = "-pc_type asm -sub_pc_type cholesky", O = unassembled);
Mat[int] Q(1);
Mat[int] Z(1);
{
    Mat P(Wh.ndof, communicator = mpiCommSelf);
    Q[0] = P;
    matrix one(Wh.ndof, 1);
    for(int i = 0; i < Wh.ndof; ++i) one(i, 0) = 1.0;
    Mat Wn(one, communicator = mpiCommSelf);
    Z[0] = Wn;
}
set(Q, Z, parent = A, sparams = "-custom_sub_" + mpirank + "_pc_type mg -custom_sub_0_ksp_converged_reason", prefix = "custom_sub_" + mpirank + "_");
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P1;                               // finite element space

macro ThRefinementFactor()getARGV("-split", 1)//
int[int] l = [1, 2, 2, 2];
mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);
fespace Wh(Th, Pk);           // local finite element space
Mat T;
MatCreate(Th, T, Pk);

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> Loc;                           // local operator
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph kappa = x < 0.25 ? 10.0 : 1.0;
    varf vPb(u, v) = int2d(Th)(-1.0 * kappa * grad(u)' * grad(v)) + on(1, u = 0.0);
    Loc = vPb(Wh, Wh, tgv = -2);
    rhs = vPb(0, Wh, tgv = -2);
}

func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] out(in.n);
    T = Loc;
    MatMult(T, in, out);
    out = inT - out;
    return out;
}
real shift = 0;
matrix Id;
{
    real[int] D(Loc.n);
    D = 1.0;
    Id = D;
}
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    matrix B = (-1.0) * Loc + a * Id;
    T = B;
    shift = a;
    return 0;
}
Wh w;
func real[int] funcRHS(real t, real[int]& u) {
    real[int] ret(u.n);
    if(t < 4.0 || t > 20.0)
        w = 0.0;
    else
        w = y < 0.5 ? 0.0 : 1.0;
    ChangeNumbering(T, w[], ret);
    return ret;
}
func int funcM(int s, real t, real[int]& u) {
    ChangeNumbering(T, w[], u, exchange = true, inverse = true);
    plotMPI(Th, w, Pk, def, real, cmm = "Global solution at step " + s + " (time " + t + ")");
}
w = (0.5 - x)^2 + (0.5 - y)^2 < 0.2 ? 1.0 : 0.0;
real[int] wPETSc;
ChangeNumbering(T, w[], wPETSc);
TSSolve(T, funcJ, funcRes, funcRHS, wPETSc, sparams = "-ts_type cn -ts_dt 0.1 -ts_max_time 100 -ts_exact_final_time interpolate -ts_max_snes_failures -1 -ts_view -pc_type lu -ts_adapt_type basic -ts_rtol 1e-3", monitor = funcM);
## Documentation
You can find the PETSc and SLEPc documentation [here](https://doc.freefem.org/documentation/petsc/index.html).

## Examples
### Linear problems
| Filename                                                                                                                                                    | Comments (preconditioners, numerical schemes)                                 |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| [diffusion-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-2d-PETSc.edp)                                     | Distributed LU/Cholesky, domain decomposition and multigrid methods               |
| [diffusion-2d-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-2d-PETSc-complex.edp)                     | &nbsp;                                                                            |
| [heat-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/heat-2d-PETSc.edp)                                               | Transient diffusion equation, same as above                                       |
| [diffusion-periodic-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-periodic-2d-PETSc.edp)                   | Periodic boundary conditions, multigrid methods                                   |
| [diffusion-periodic-balanced-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-periodic-balanced-2d-PETSc.edp) | Better load balancing than above example                                          |
| [diffusion-substructuring-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-substructuring-2d-PETSc.edp)       | Balancing Domain Decomposition with Constraints                                   |
| [diffusion-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-3d-PETSc.edp)                                     | Three-dimensional problem, domain decomposition and multigrid methods             |
| [diffusion-mg-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-mg-2d-PETSc.edp)                               | Geometric non-nested multigrid methods                                            |
| [diffusion-mg-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-mg-3d-PETSc.edp)                               | Geometric nested multigrid methods                                                |
| [helmholtz-2d-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-2d-PETSc-complex.edp)                     | Domain decomposition methods with optimized boundary conditions                   |
| [helmholtz-mg-2d-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-mg-2d-PETSc-complex.edp)               | Geometric multigrid methods                                                       |
| [laplace-RT-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-RT-2d-PETSc.edp)                                   | Vectorial two-dimensional problem with a block preconditioner (fieldsplit)        |
| [laplace-RT-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-RT-3d-PETSc.edp)                                   | Vectorial three-dimensional problem with a block preconditioner (fieldsplit)      |
| [laplace-adapt-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-adapt-3d-PETSc.edp)                             | Three-dimensional problem with *h* adaptivity, multigrid methods using Mmg        |
| [laplace-adapt-dist-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-adapt-dist-3d-PETSc.edp)                   | Three-dimensional problem with fully-distributed *h* adaptivity using ParMmg      |
| [laplace-lagrange-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-lagrange-PETSc.edp)                             | Laplace equation with constraints and a block preconditioner (fieldsplit)         |
| [elasticity-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-2d-PETSc.edp)                                   | Vectorial problem, domain decomposition (GenEO) and multigrid methods             |
| [elasticity-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-3d-PETSc.edp)                                   | &nbsp;                                                                            |
| [elasticity-block-hpddm-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-block-hpddm-2d-PETSc.edp)           | Domain decomposition (GenEO for saddle-point problems)                            |
| [stokes-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-2d-PETSc.edp)                                           | Distributed LU/Cholesky                                                           |
| [stokes-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-3d-PETSc.edp)                                           | &nbsp;                                                                            |
| [stokes-block-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-block-2d-PETSc.edp)                               | Stokes equation defined as a block system with four matrices (fieldsplit)         |
| [stokes-fieldsplit-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-fieldsplit-2d-PETSc.edp)                     | Block preconditioner (fieldsplit)                                                 |
| [stokes-fieldsplit-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-fieldsplit-3d-PETSc.edp)                     | &nbsp;                                                                            |
| [stokes-block-hpddm-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-block-hpddm-2d-PETSc.edp)                   | Domain decomposition (GenEO for saddle-point problems)                            |
| [oseen-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/oseen-2d-PETSc.edp)                                             | Oseen problem preconditioned by Pressure Convection--Diffusion (PCD)              |
| [maxwell-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/maxwell-2d-PETSc.edp)                                         | Direct LU/Cholesky                                                                |
| [maxwell-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/maxwell-3d-PETSc.edp)                                         | Multigrid method                                                                  |
| [maxwell-mg-3d-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/maxwell-mg-3d-PETSc-complex.edp)                   | Two-grid preconditioner                                                           |
| [helmholtz-3d-surf-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-3d-surf-PETSc-complex.edp)           | BEM with hierarchical matrices from Htool on surfaces                             |
| [helmholtz-3d-line-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-3d-line-PETSc-complex.edp)           | BEM with hierarchical matrices from Htool on lines                                |
| [helmholtz-coupled-2d-PETSc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-coupled-2d-PETSc-complex.edp)     | FEM coupled with BEM in a MatNest using a block preconditioner (fieldsplit)       |
| [PtAP-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/PtAP-2d-PETSc.edp)                                               | Parallel interpolation on non-matching grids + P' A P operation                   |
| [restriction-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/restriction-2d-PETSc.edp)                                 | Coupled problems with one being defined on a restriction of the mesh of the other |
| [bilaplace-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/bilaplace-2d-PETSc.edp)                                     | Bilaplacian using Morley finite element                                           |

### Nonlinear problems
| Filename                                                                                                                                                          | Comments (preconditioners, numerical schemes)                                 |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| [bratu-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/bratu-2d-PETSc.edp)                                                   | &nbsp;                                                                        |
| [bratu-hpddm-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/bratu-hpddm-2d-PETSc.edp)                                       | GenEO with reused coarse spaces                                               |
| [newton-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-2d-PETSc.edp)                                                 | &nbsp;                                                                        |
| [newton-adaptmesh-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-adaptmesh-2d-PETSc.edp)                             | Newton method and *h* adaptivity                                              |
| [newton-vi-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-vi-2d-PETSc.edp)                                           | Newton method and a variational inequality                                    |
| [newton-vi-adaptmesh-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-vi-adaptmesh-2d-PETSc.edp)                       | Newton method, *h* adaptivity, and a variational inequality                   |
| [elasticity-SNES-3d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-SNES-3d-PETSc.edp)                               | Linear elasiticty with a Newton method                                        |
| [neo-Hookean-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/neo-Hookean-2d-PETSc.edp)                                       | Nonlinear elasticity                                                          |
| [navier-stokes-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/navier-stokes-2d-PETSc.edp)                                   | Steady-state Navier--Stokes equation for linear stability analysis            |
| [natural-convection-fieldsplit-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/natural-convection-fieldsplit-2d-PETSc.edp)   | Newton method and *h* adaptivity                                              |
| [vi-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/vi-2d-PETSc.edp)                                                         | Variational inequalities                                                      |

### Time steppers and optimizers
| Filename                                                                                                                                      | Comments (preconditioners, numerical schemes) |
|-----------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------|
| [advection-TS-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/advection-TS-2d-PETSc.edp)                 | Implicit and explicit schemes                 |
| [heat-TS-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/heat-TS-2d-PETSc.edp)                           | &nbsp;                                        |
| [heat-TS-RHS-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/heat-TS-RHS-2d-PETSc.edp)                   | &nbsp;                                        |
| [minimal-surface-Tao-2d-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/minimal-surface-Tao-2d-PETSc.edp)   | Minimal surface problem                       |
| [orego-TS-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/orego-TS-PETSc.edp)                               | &nbsp;                                        |
| [toy-Tao-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/toy-Tao-PETSc.edp)                                 | &nbsp;                                        |

### Eigenvalue problems
| Filename                                                                                                                                                              | Comments (preconditioners, numerical schemes) |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| [laplace-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-2d-SLEPc.edp)                                                   | &nbsp;                                                                                          |
| [laplace-spherical-harmonics-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-spherical-harmonics-2d-SLEPc.edp)           | &nbsp;                                                                                          |
| [laplace-torus-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-torus-2d-SLEPc.edp)                                       | &nbsp;                                                                                          |
| [schrodinger-axial-well-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-axial-well-2d-SLEPc.edp)                     | &nbsp;                                                                                          |
| [schrodinger-harmonic-oscillator-1d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-harmonic-oscillator-1d-SLEPc.edp)   | &nbsp;                                                                                          |
| [schrodinger-harmonic-oscillator-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-harmonic-oscillator-2d-SLEPc.edp)   | &nbsp;                                                                                          |
| [schrodinger-square-well-1d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-square-well-1d-SLEPc.edp)                   | &nbsp;                                                                                          |
| [laplace-2d-SLEPc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-2d-SLEPc-complex.edp)                                   | &nbsp;                                                                                          |
| [laplace-beltrami-3d-surf-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-beltrami-3d-surf-SLEPc.edp)                       | Eigenvalue problem on a surface                                                                 |
| [laplace-beltrami-3d-line-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-beltrami-3d-line-SLEPc.edp)                       | Eigenvalue problem on a curve                                                                   |
| [navier-stokes-2d-SLEPc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/navier-stokes-2d-SLEPc-complex.edp)                       | Linear stability analysis of Navier--Stokes equations                                           |
| [stokes-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-2d-SLEPc.edp)                                                     | Inf-sup constant of Stokes equations                                                            |
| [helmholtz-2d-SLEPc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-2d-SLEPc-complex.edp)                               | SVD of the discretized Helmholtz equation                                                       |
| [mf-2d-SLEPc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/mf-2d-SLEPc.edp)                                                              | Matrix-free SVD with user-provided matrix--vector and matrix transpose--vector multiplications |
| [nonlinear-2d-SLEPc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/nonlinear-2d-SLEPc-complex.edp)                                | Nonlinear eigenvalue problem Ax = sqrt(lambda)x                                                |
| [blasius-stability-1d-SLEPc-complex.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/blasius-stability-1d-SLEPc-complex.edp)                | Polynomial eigenvalue problem (A2 lambda^2 x + A1 lambda + A0)x = 0                            |

### Miscellaneous
| Filename                                                                                                                          | Comments (preconditioners, numerical schemes) |
|-----------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
| [transpose-solve-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/transpose-solve-PETSc.edp)     | Solving a transposed system                                              |
| [Schur-complement-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/Schur-complement-PETSc.edp)   | Computing an exact Schur complement                                      |
| [block-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/block-PETSc.edp)                         | &nbsp;                                                                   |
| [buildRecursive.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/buildRecursive.edp)                   | Recursive mesh partitioning (for geometric multigrid)                    |
| [withPartitioning.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/withPartitioning.edp)               | Connectivity construction with a user-supplied partitioning              |
| [PartitionCreate.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/PartitionCreate.edp)                 | Creation of different partitions of unity using the same DD              |
| [Dmesh-Save-Load.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/Dmesh-Save-Load.edp)                 | Saving and loading a distributed mesh for restarting a computation       |
| [transfer.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/transfer.edp)                               | Parallel interpolation of finite element functions                       |
| [DmeshReconstruct.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/DmeshReconstruct.edp)               | Construction of a distributed mesh from sequential nonoverlapping meshes |
| [distributed-parmmg.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/distributed-parmmg.edp)           | Distributed ParMmg interface for mesh adaptation                         |
| [DmeshRedistribute.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/DmeshRedistribute.edp)             | Gather and scatter a Dmesh on different MPI communicators                |
| [DMPlex-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/DMPlex-PETSc.edp)                       | Load and partition a mesh using a DM in two and three dimensions         |
| [function-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/function-PETSc.edp)                   | Custom plugin showing how to directly access PETSc in C++                |
| [convect.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/convect.edp)                                 | Calling the convert FreeFEM function on a distributed mesh               |
| [MatLoad-PETSc.edp](https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/MatLoad-PETSc.edp)                     | Loading a distributed matrix/vector with various formats                 |

### Reproducible science
| Article                                                                                                                                                                                             | Source code                                                   |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------|
| [Augmented Lagrangian preconditioner for large-scale hydrodynamic stability analysis](https://www.sciencedirect.com/science/article/pii/S0045782519301914)                                          | [GitHub repository](https://github.com/prj-/moulin2019al)     |
| [A multilevel Schwarz preconditioner based on a hierarchy of robust coarse spaces](https://hal.archives-ouvertes.fr/hal-02151184/document)                                                          | [GitHub repository](https://github.com/prj-/aldaas2019multi)  |
| [KSPHPDDM and PCHPDDM: extending PETSc with advanced Krylov methods and robust multilevel overlapping Schwarz preconditioners](https://www.sciencedirect.com/science/article/pii/S0898122121000055) | [GitHub repository](https://github.com/prj-/jolivet2020petsc) |
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2]; // finite element space

int[int] l = [2, 1, 2, 2];
mesh Th = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
fespace Wh(Th, Pk);                 // local finite element space
matrix Loc = vPb(Wh, Wh);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view", bs = 2);
Wh<real> def(u);                    // local solution

A = Loc;
u[] = A^-1 * rhs;
if(mpirank == 0)
    cout << "KSPGetIterationNumber = " << KSPGetIterationNumber(A) << endl;

real[int] err = A * u[];            // global matrix-vector product
exchange(A, rhs, scaled = true);
err -= rhs;

plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
u[] = err;
macro def1(u)u// EOM
plotMPI(Th, u, P2, def1, real, cmm = "Global residual");

Wh<real> def(Rb)[3];
[Rb[0], RbB[0]] = [1, 0];
[Rb[1], RbB[1]] = [0, 1];
[Rb[2], RbB[2]] = [y, -x];
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200", nearnullspace = Rb);
u[] = 0.0;
real[int] residuals(200);
KSPSetResidualHistory(A, residuals);
u[] = A^-1 * rhs;
if(mpirank == 0)
    cout << "KSPResidualHistory = " << residuals(0:KSPGetIterationNumber(A)) << endl;
plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
real alpha = 1.0e+1;
mesh ThMoved = movemesh(Th, [x + alpha * u, y + alpha * uB]);
u[] = mpirank;
plotMPI(ThMoved, u, P2, def1, real, cmm = "Global moved solution");
if(HasType("PC", "hpddm")) {
    u[] = 0;
    set(A, sparams = "-pc_type hpddm -pc_hpddm_levels_1_eps_nev 20 -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_define_subdomains -pc_hpddm_has_neumann -pc_hpddm_coarse_p 2 -ksp_monitor");
    u[] = A^-1 * rhs;
}
if(HasType("PC", "fancy_bug")) {
    exit(1);
}
if(HasType("KSP", "fancy_bug_bis")) {
    exit(2);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro removeZeros()true// EOM
macro trueRestrict()true// EOM
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

int s = getARGV("-split", 1);                                   // refinement factor

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);

matrix Loc = vPb(Wh, Wh, tgv = -2);
Mat A(Loc, intersection, D);
Wh<real> def(u);    // local solution

set(A, sparams = "-pc_type lu -ksp_type gmres");
real[int] rhs = vPb(0, Wh, tgv = -2);
real[int] rhsPETSc;
ChangeNumbering(A, rhs, rhsPETSc);
func real[int] funcRes(real[int]& inPETSc) {
    real[int] outPETSc(inPETSc.n);
    MatMult(A, inPETSc, outPETSc);
    outPETSc -= rhsPETSc;
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    return 0;
}
Wh xu;
xu = sqrt((x - 0.5)^2 + (y - 0.5)^2) < 0.4 ? 0.1 : 1.0;
plotMPI(Th, xu, Pk, def, real, cmm = "Upper bound");
real[int] xPETSc, xuPETSc;
u[] = 0;
ChangeNumbering(A, u[], xPETSc);
ChangeNumbering(A, xu[], xuPETSc);
SNESSolve(A, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_view -snes_vi_monitor -snes_type vinewtonrsls", xu = xuPETSc);
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
// NBPROC 4
/***********************************************************************
  > File Name: oseen-2d-PETSc.edp
  > Author: Zhao Gang
  > Mail: zhaog6@lsec.cc.ac.cn
  > Created Time: 2020/10/22 Thursday 10:43:34
  > Run with mpi: ff-mpirun -np 4 script.edp -v 0 (# of Procs: 4)
 ***********************************************************************/

load "PETSc"
include "macro_ddm.idp"

//-----------------
//   Parameters
//-----------------
int n = getARGV("-global", 64);
int[int] labs = [1, 2, 4, 3];
int s = getARGV("-split", 0); // refinement index of mesh
real Re = getARGV("-Re", 100.);
real nu = 1./Re;

//-------------------------
//   Analytic Functions
//-------------------------
func b1 = 2 * (2*y - 1) * (1 - (2*x - 1)^2);
func b2 = -2 * (2*x - 1) * (1 - (2*y - 1)^2);

//--------------------
//   mesh
//--------------------
mesh Th = square(n, n);
DmeshCreate(Th);
fespace Ph(Th, P0);
Ph part;
PartitionCreate(Th, part[], P0);
mesh ThNo = trunc(Th, abs(part-1.0)<1e-1, split=2^s, label=-111111, renum=true);
if(s > 0) {
    Th = ThNo;
    DmeshReconstruct(Th);
}

//------------------------
//   fespace
//------------------------
macro feV [P2, P2] //
macro feQ P1 //
fespace Vh(Th, feV), Qh(Th, feQ);
Vh [uh, vh];
Qh ph;

//------------------------
//   varf
//------------------------
macro grad(u) [dx(u), dy(u)] //
macro Grad(u, v) [dx(u),dy(u), dx(v),dy(v)] //
macro Ugradv(u1, u2, v) ( u1*dx(v) + u2*dy(v) ) //
macro UgradV(u1, u2, v1, v2) [u1*dx(v1) + u2*dy(v1), u1*dx(v2) + u2*dy(v2)] //
macro div(u, v) ( dx(u) + dy(v) ) //
varf vF([u, v], [uu, vv]) = int2d(Th) ( nu*Grad(u, v)'*Grad(uu, vv) + UgradV(b1, b2, u, v)' * [uu, vv] ) + on(labs[3], u=1, v=0) + on(labs(0:2), u=0, v=0);
varf vB([p], [uu, vv]) = int2d(Th) ( - p * div(uu, vv) );
varf vC(p, pp) = int2d(Th) (0.0 * p * pp);  // pressure stabilization

//------------------------
//   Solving Equations
//------------------------
Mat dF, dC;
{
    macro def(u) [u, u#B] // for velocity
    macro init(u) [u, u] // for velocity
    MatCreate(Th, dF, feV);
}
MatCreate(Th, dC, feQ);
dF = vF(Vh, Vh, tgv=-1);
dC = vC(Qh, Qh);
matrix B = vB(Qh, Vh);
Mat dB(dF, dC, B);
{ // for Dirichlet BC on dF
    varf vonBorder([u, v], [uu, vv]) = on(labs, u=1, v=1);
    real[int] onBorder = vonBorder(0, Vh, tgv=-1);
    real[int] onBorderPETSc;
    ChangeNumbering(dF, onBorder, onBorderPETSc);
    MatZeroRows(dB, onBorderPETSc);
}
Mat dA = [[dF,  dB],
          [dB', dC]];
real[int] rhsV = vF(0, Vh, tgv=-1);
real[int] rhsP(Qh.ndof);
rhsP = 0;
real[int] rhsPETSc;
ChangeNumbering([dF, dC], [rhsV, rhsP], rhsPETSc);

// Defining names of velocity and pressure fields
real[int] list(rhsPETSc.n);
list(0 : dF.n-1) = 1;
list(dF.n : list.n-1) = 2;
string[int] names(2);
names[0] = "velocity";
names[1] = "pressure";

// Building PCD preconditioner
varf vAp(p, q) = int2d(Th) (nu * grad(p)' * grad(q));
varf vFp(p, q) = int2d(Th) (nu * grad(p)' * grad(q) + Ugradv(b1, b2, p)' * q);
varf vMp(p, q) = int2d(Th) (p * q);
Mat dAp(dC), dFp(dC), dMp(dC); // all Mat share the same distribution of the pressure space
dAp = vAp(Qh, Qh);
dFp = vFp(Qh, Qh);
dMp = vMp(Qh, Qh, sym = 1);
set(dAp, sparams="-prefix_push stiffness_ -ksp_constant_null_space -pc_type gamg -ksp_type cg -ksp_max_it 5 -prefix_pop", prefix="stiffness_");
set(dMp, sparams="-prefix_push mass_ -pc_type jacobi -ksp_type cg -ksp_max_it 5 -prefix_pop", prefix="mass_");
func real[int] PCD(real[int]& in) {
    real[int] out;
    KSPSolve(dAp, in, out);
    MatMult(dFp, out, in);
    KSPSolve(dMp, in, out);
    out *= -1.0;
    return out;
}

set(dA, sparams="-pc_type fieldsplit -prefix_push fieldsplit_velocity_ -pc_type hypre -ksp_type gmres -prefix_pop " + "-ksp_type fgmres -ksp_gmres_restart 200 -ksp_converged_reason -ksp_view -ksp_monitor", fields=list, names=names);
set(dC, parent=dA, precon=PCD, sparams="-prefix_push fieldsplit_pressure_ -pc_type shell -prefix_pop");

// Solving Oseen problem
real[int] uhPETSc;
KSPSolve(dA, rhsPETSc, uhPETSc);
ChangeNumbering([dF, dC], [uh[], ph[]], uhPETSc, inverse=true, exchange=true);

// Normalizing pressure
real[int] dpAverage(2), pAverage(2);
dpAverage[0] = int2d(ThNo) ( ph );
dpAverage[1] = ThNo.measure;
mpiAllReduce(dpAverage, pAverage, mpiCommWorld, mpiSUM);
ph = ph - pAverage[0]/pAverage[1];

int[int] fforder = [1, 1];
savevtk("oseen-2d.vtu", Th, [uh, vh], ph, dataname="velocity pressure", order=fforder);
load "PETSc"
include "macro_ddm.idp"

macro def2(i)[i, i#B]//
macro init2(i)[i, i]//
macro grad(u)[dx(u), dy(u)]//
macro div(u)(dx(u) + dy(u#B))//

int global = getARGV("-global", 50);
bool sym = usedARGV("-sym") != -1;
int[int] l = [2, 2, 1, 2];
mesh Th = square(global, global, [x, y], label = l, flags = 1); // global mesh
func Vk = P2;
func Pk = P1;

macro ThRefinementFactor()getARGV("-split", 1)//
DmeshCreate(Th);
Mat A, C;
{
    macro def(i)def2(i)//
    macro init(i)init2(i)//
    MatCreate(Th, A, [Vk, Vk]);
}
{
    MatCreate(Th, C, Pk);
}
fespace Wh(Th, [Vk, Vk]);
fespace Ph(Th, Pk);

varf vPbA(def2(u), def2(v)) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB)) + on(1, u = 1.0, uB = 0.0) + on(2, u = 0.0, uB = 0.0);
varf vPbB(def2(u), [q]) = int2d(Th)(-div(u) * q);

tgv = -2.0;
matrix NA;
matrix NB = vPbB(Wh, Ph);
NB.thresholding(1.0E-16);

real[int] rhs(Wh.ndof + Ph.ndof);
rhs(0:Wh.ndof - 1)                 = vPbA(0, Wh);
rhs(Wh.ndof:Wh.ndof + Ph.ndof - 1) = 0.0;
if(tgv < 0.0) {
    assert(abs(tgv + 2.0) < 1.0E-6);
    NA = vPbA(Wh, Wh, tgv = -10.0);
    if (!sym)
        NA.thresholding(1.0E-16);
    varf vPbRHS(def2(u), def2(v)) =                                                  on(1, u = 1.0, uB = 0.0) + on(2, u = 0.0, uB = 0.0);
    real[int] tmp = vPbRHS(0, Wh);
    real[int] rhsA = NA * tmp;
    real[int] rhsB = NB * tmp;
    rhs(0:Wh.ndof - 1) -= rhsA;
    rhs(Wh.ndof:rhs.n - 1) -= rhsB;
    varf vPbG(def2(u), def2(v)) = on(1, 2, u = 1.0, uB = 1.0);
    rhsA = vPbG(0, Wh);
    setBC(NA, rhsA, -2.0);
    if(sym)
        symmetrizeCSR(NA);
    for [i, j, v : NB] if(abs(rhsA(j) - 1.0) < 1.0E-2) v = 0.0;
}
else {
    NA.thresholding(1.0E-16);
    NA = vPbA(Wh, Wh);
}

A = NA;
Mat B(C, A, NB);
Mat Stokes = [[A, B'],
              [B, 0 ]];
set(Stokes, sparams = "-pc_type none");
if(HasType("PC", "hpddm")) {
    string common = " -ksp_converged_reason -ksp_view_final_residual -ksp_monitor_true_residual -ksp_type fgmres";
    set(Stokes, sparams = common + " -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self "
        + "-prefix_push fieldsplit_1_ "
        + " -ksp_type fgmres -pc_type hpddm -pc_hpddm_has_neumann -ksp_monitor -pc_hpddm_ksp_rtol 1.0E-2 -pc_hpddm_schur_precondition geneo "
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 20 -eps_threshold 0.5 -st_share_sub_ksp -eps_gen_non_hermitian -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky -eps_tol 1.0E-2 "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -correction balanced -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop", setup = 1);
    set(A, parent = Stokes, bs = sym ? 1 : 2, sparams =
          "-prefix_push fieldsplit_0_ -pc_type hpddm -ksp_pc_side right -pc_hpddm_has_neumann -pc_hpddm_define_subdomains"
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 40 -eps_threshold 0.3 -st_share_sub_ksp -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop");
    set(C, parent = Stokes);

    real[int] sol(Wh.ndof + Ph.ndof);
    sol = Stokes^-1 * rhs;
    Wh def2(u);
    u[] = sol(0:Wh.ndof - 1);
    Ph p;
    p[] = sol(Wh.ndof:sol.n - 1);
    plotMPI(Th, def2(u), [Vk, Vk], def2, real, cmm = "Global velocity (overlap = 1)");
    plotD(Th, p, cmm = "Global pressure (overlap = 1)");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

int[int] n2o;
macro ThN2O()n2o//
{
    macro dimension()2//
    include "macro_ddm.idp"
    mesh Th = square(60, 60);
    fespace Vh(Th, [P1, P1]);
    fespace Ph(Th, P1);
    Ph u = (x-0.5)^2 + (y-0.5)^2 - 0.1;
    Vh [vx, vy] = [cos(x), sin(y)];
    real dt = 0.2;
    u = convect([vx, vy], dt, u);
    mesh ThG = Th;
    fespace PhG(ThG, P1);
    PhG w;
    w[] = u[];
    DmeshCreate(Th);
    u = (x-0.5)^2 + (y-0.5)^2 - 0.1;
    convectParallel(Th, [vx, vy], dt, u, 20)
    plotD(Th, u, cmm = "Global 2D solution");
    if(mpisize > 1) {
        real[int] D;
        PartitionCreate(Th, D, P1);
        u[] .*= D;
        int[int] map = restrict(Ph, PhG, n2o);
        PhG uG, v;
        uG[](map) = u[];
        mpiAllReduce(uG[], v[], mpiCommWorld, mpiSUM);
        w[] -= v[];
        assert(w[].l2 < 1.0e-2);
    }
}
{
    macro dimension()3//
    include "macro_ddm.idp"
    mesh3 Th = cube(10, 10, 10);
    fespace Vh(Th, [P1, P1, P1]);
    fespace Ph(Th, P1);
    Ph u = (x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2 - 0.1;
    Vh [vx, vy, vz] = [0.5, 0.5, z/2.0];
    real dt = 0.05;
    u = convect([vx, vy, vz], -dt, u);
    mesh3 ThG = Th;
    fespace PhG(ThG, P1);
    PhG w;
    w[] = u[];
    DmeshCreate(Th);
    u = (x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2 - 0.1;
    [vx, vy, vz] = [0.5, 0.5, z/2.0];
    convectParallel(Th, [vx, vy, vz], -dt, u, 20)
    plotD(Th, u, cmm = "Global 3D solution");
    if(0 && mpisize > 1) {
        real[int] D;
        PartitionCreate(Th, D, P1);
        u[] .*= D;
        int[int] map = restrict(Ph, PhG, n2o);
        PhG uG, v;
        uG[](map) = u[];
        mpiAllReduce(uG[], v[], mpiCommWorld, mpiSUM);
        w[] -= v[];
        assert(w[].l2 < 1.0e-2);
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
include "getARGV.idp"
int overlap = getARGV("-overlap", 1);
int s = getARGV("-split", 2);
int[int][int] intersection;
{
    macro dimension()2// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions

    func Pk = P2;                       // finite element space
    int level = 4;
    mesh[int] ThTab(level);
    mesh[int] ThBorderTab(level);
    real[int][int] DTab(level);
    ThTab[level - 1] = square(getARGV("-global", 10), getARGV("-global", 10));
    matrix[int] P(level - 1);
    buildOverlapEdgeRecursive(ThTab, ThBorderTab, 10, s, overlap, level, P, intersection, DTab, Pk, mpiCommWorld, false, Pk, def, init);
    for(int i = 0; i < level; ++i) {
        fespace Vh(ThTab[i], Pk);
        Vh u;
        u[] = DTab[i];
        plotMPI(ThTab[i], u, Pk, def, real, cmm = "Global recursive partition of unity at level " + (i + 1));
    }
}
{
    macro dimension()3// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions

    func Pk = P1;                       // finite element space
    int level = 3;
    mesh3[int] ThTab(level);
    mesh3[int] ThBorderTab(level);
    real[int][int] DTab(level);
    ThTab[level - 1] = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [x, y, z]);
    matrix[int] P(level - 1);
    buildOverlapEdgeRecursive(ThTab, ThBorderTab, -111111, s, overlap, level, P, intersection, DTab, Pk, mpiCommWorld, false, Pk, def, init);
    for(int i = 0; i < level; ++i) {
        fespace Vh(ThTab[i], Pk);
        Vh u;
        u[] = DTab[i];
        plotMPI(ThTab[i], u, Pk, def, real, cmm = "Global recursive partition of unity at level " + (i + 1));
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
macro grad(u)[dx(u), dy(u)]// EOM

func Pk = P1;                       // finite element space

real r = 0.25;
real f = 5.0;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh Th0, Th1, Th2;
macro buildMesh(Th, i) {
    Th#i = buildmesh(a(getARGV("-global", 60) / (f^i)) + b(getARGV("-global", 60) / (f^i)) + c(getARGV("-global", 60) / (f^i)) + d(getARGV("-global", 60) / (f^i)) + e(getARGV("-global", 60)));
} //

for(int i = 0; i < 2; ++i) {
    Mat[int] A(3), P(2);
    buildMesh(Th, 0)
    buildMesh(Th, 1)
    buildMesh(Th, 2)
    if(i == 0) { // naive partitioning
        MatCreate(Th0, A[0], Pk);
        MatCreate(Th1, A[1], Pk);
        MatCreate(Th2, A[2], Pk);
        MatInterpolate(Th1, Pk, A[1], Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, A[2], Th1, Pk, A[1], P[1]);
    }
    else { // efficient (nested) partitioning
        mesh[int] ThGlobal(3);
        ThGlobal[2] = Th2;
        ThGlobal[1] = Th1;
        ThGlobal[0] = Th0;
        fespace Ph2(Th2, P0);
        fespace Ph1(Th1, P0);
        fespace Ph0(Th0, P0);
        Ph2 part2;
        if(mpirank == 0) {
            partitionerSeq(part2[], Th2, mpisize);
        }
        partitionerPar(part2[], Th2, mpiCommWorld, mpisize);
        Ph1 part1 = part2;
        Ph0 part0 = part1;
        macro Th2UserPartitioning()part2[]// EOM
        macro Th1UserPartitioning()part1[]// EOM
        macro Th0UserPartitioning()part0[]// EOM
        MatCreate(Th2, A[2], Pk);
        MatCreate(Th1, A[1], Pk);
        MatCreate(Th0, A[0], Pk);
        macro Th1NestedInTh0()//
        macro Th2NestedInTh1()//
        MatInterpolate(Th1, Pk, A[1], Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, A[2], Th1, Pk, A[1], P[1]);
    }

    real[int] rhs;
    for(int i = 0; i < 3; ++i) {
        mesh Th;
        if(i == 0) Th = Th0;
        else if(i == 1) Th = Th1;
        else Th = Th2;
        varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
        fespace Wh(Th, Pk);
        A[i] = vPb(Wh, Wh, tgv = -2);
        if(i == 0) {
            rhs.resize(Wh.ndof);
            rhs = vPb(0, Wh);
        }
    }
    set(A, P, sparams = "-pc_type mg");
    fespace Wh(Th0, Pk);
    Wh u;
    u[] = A[0]^-1 * rhs;
    plotDmesh(Th0, cmm = "Mesh #0 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th1, cmm = "Mesh #1 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th2, cmm = "Mesh #2 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    macro def(u)u//
    plotMPI(Th0, u, Pk, def, real, cmm = "Global solution with " + (i == 0 ? "naive" : "efficient") + " partitioning");
}
for(int i = 0; i < 2; ++i) {
    Mat[int] A(1), P(2);
    buildMesh(Th, 0)
    buildMesh(Th, 1)
    buildMesh(Th, 2)
    if(i == 0) { // naive partitioning
        MatCreate(Th0, A[0], Pk);
        Mat B, C;
        MatCreate(Th1, B, Pk);
        MatCreate(Th2, C, Pk);
        MatInterpolate(Th1, Pk, B, Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, C, Th1, Pk, B, P[1]);
    }
    else { // efficient (nested) partitioning
        mesh[int] ThGlobal(3);
        ThGlobal[2] = Th2;
        ThGlobal[1] = Th1;
        ThGlobal[0] = Th0;
        fespace Ph2(Th2, P0);
        fespace Ph1(Th1, P0);
        fespace Ph0(Th0, P0);
        Ph2 part2;
        if(mpirank == 0) {
            partitionerSeq(part2[], Th2, mpisize);
        }
        partitionerPar(part2[], Th2, mpiCommWorld, mpisize);
        Ph1 part1 = part2;
        Ph0 part0 = part1;
        macro Th2UserPartitioning()part2[]// EOM
        macro Th1UserPartitioning()part1[]// EOM
        macro Th0UserPartitioning()part0[]// EOM
        Mat B, C;
        MatCreate(Th2, C, Pk);
        MatCreate(Th1, B, Pk);
        MatCreate(Th0, A[0], Pk);
        MatInterpolate(Th1, Pk, B, Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, C, Th1, Pk, B, P[1]);
    }

    real[int] rhs;
    varf vPb(u, v) = int2d(Th0)(grad(u)' * grad(v)) + int2d(Th0)(v) + on(1, u = 0.0);
    fespace Wh(Th0, Pk);
    A[0] = vPb(Wh, Wh, tgv = -2);
    rhs.resize(Wh.ndof);
    rhs = vPb(0, Wh);
    set(A, P, sparams = "-pc_type mg");
    Wh u;
    u[] = A[0]^-1 * rhs;
    plotDmesh(Th0, cmm = "Mesh #0 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th1, cmm = "Mesh #1 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th2, cmm = "Mesh #2 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    macro def(u)u//
    plotMPI(Th0, u, Pk, def, real, cmm = "Global solution with " + (i == 0 ? "naive" : "efficient") + " partitioning");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P2;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
real dt = getARGV("-dt", 0.01);                                 // time step
int iMax = getARGV("-iMax", 10);                                // number of iterations

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int[int] LL = [1,2, 1,1, 1,1];
mesh3 ThBorder, Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb(u, v) = int3d(ThAugmented)(u * v + dt * (grad(u)' * grad(v))) + int3d(ThAugmented)(dt * v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM(u, v) = int3d(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = cube(1, 1, 1, [x, y, z]);

schwarz A(Mat, intersection, D, scaled = false);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int3d(Th)(u * v + dt * (grad(u)' * grad(v))) + int2d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int3d(Th)(u * v + dt * (grad(u)' * grad(v))) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int2d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}
/*# SolvePlot #*/
set(A, sparams = "-hpddm_reuse_preconditioner=1");
Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs);     // newRhs = M * u[]
    newRhs += rhs;

    if(Opt.n > 0)       // optimized Schwarz methods
        DDM(A, newRhs, u[], excluded = excluded, ret = ret, O = Opt);
    else
        u[] = A^-1 * newRhs;

    plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
}
/*# SolvePlotEnd #*/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
int[int] labPeriodic = [2, 4, 1, 3];
macro Pk() P2, periodic=[[labPeriodic[0],x+y], [labPeriodic[1],x+y], [labPeriodic[2],x-y], [labPeriodic[3],x-y]]// EOM
macro PkNoPeriodic() P2// EOM

int s = getARGV("-split", 1);                                   // refinement factor

real r = 0.25;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh Th = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
Mat A;
if(mpisize > 1) {
    fespace Wh(Th, Pk);
    fespace Ph(Th, P0);
    Ph part;
    mesh ThExtended = Th;
    {
        partitionerSeq(part[], Th, mpisize);
        fespace PhExtended(ThExtended, P0);
        PhExtended partExtended;
        partExtended = part;
        for(int i = 0; i < mpisize; ++i) {
            mesh ThLocal = trunc(Th, abs(part - i) < 1e-6 && (y > 1-x-Th.hmax || y < -1-x+Th.hmax || y > 1+x-Th.hmax || y < -1+x+Th.hmax), label = 0);
            int j = 0;
            varf vOn(u, v) = on(labPeriodic[j], u = 1);
            fespace Vh(ThLocal, P1);
            Vh u;
            int[int] touch(4);
            touch = 0;
            for(j = 0; j < labPeriodic.n; ++j) {
                u[] = vOn(0, Vh);
                mesh ThLocalMoved;
                if(u[].linfty > 1e-12) {
                    if(j == 0) {
                        ThLocalMoved = movemesh(ThLocal, [x + 1, y - 1]);
                        touch[0] = 1;
                    }
                    else if(j == 1) {
                        ThLocalMoved = movemesh(ThLocal, [x - 1, y + 1]);
                        touch[1] = 1;
                    }
                    else if(j == 2) {
                        ThLocalMoved = movemesh(ThLocal, [x - 1, y - 1]);
                        touch[2] = 1;
                    }
                    else if(j == 3) {
                        ThLocalMoved = movemesh(ThLocal, [x + 1, y + 1]);
                        touch[3] = 1;
                    }
                }
                if(j == 3) {
                    if(touch[0] == 1 && touch[2] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x, y - 2]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[0] == 1 && touch[3] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x + 2, y]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[1] == 1 && touch[2] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x - 2, y]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[1] == 1 && touch[3] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x, y + 2]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                }
                if(ThLocalMoved.nt > 0) {
                    real[int] backup = partExtended[];
                    ThLocalMoved = trunc(ThLocalMoved, y <= 1-x+ThLocalMoved.hmax && y >= -1-x-ThLocalMoved.hmax && y <= 1+x+ThLocalMoved.hmax && y >= -1+x-ThLocalMoved.hmax);
                    ThExtended = ThExtended + ThLocalMoved;
                    partExtended = 0;
                    partExtended[](0:ThExtended.nt - ThLocalMoved.nt - 1) = backup;
                    partExtended[](ThExtended.nt - ThLocalMoved.nt:ThExtended.nt - 1) = i;
                }
            }
        }
        Th = ThExtended;
        part = partExtended;
    }
    broadcast(processor(0), Th);
    broadcast(processor(0), part[]);
    plot(part, fill = 1, wait = 1);
    int[int][int] intersection;
    real[int] D;
    buildWithPartitioning(ThExtended, part[], s, intersection, D, PkNoPeriodic, mpiCommWorld);
    Th = trunc(ThExtended, y <= 1-x && y >= -1-x && y <= 1+x && y >= -1+x);
    fespace WhExtended(ThExtended, PkNoPeriodic);
    matrix R = interpolate(Wh, WhExtended);
    periodicity(R, intersection, D);
    constructor(A, D.n, intersection, D);
}
else {
    if(s > 1)
        Th = trunc(Th, 1, split = s);
    fespace Wh(Th, Pk);
    constructor(A, Wh.ndof);
}

fespace Wh(Th, Pk);                 // local finite element space
func f = (y+x+1) * (y+x-1) * (y-x+1) * (y-x-1);
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) - int2d(Th)((0.39 - f) * v) + on(0, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]//    // vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// two-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];         // finite element space

mesh3 Th;
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
real[int] rhs = vPb(0, Wh, tgv = -1);

set(A, sparams = "-pc_type lu");
Wh<real> def(u);

A = vPb(Wh, Wh, tgv = -1);
u[] = A^-1 * rhs;

macro def1(u)u// EOM
plotMPI(Th, u, P2, def1, real, cmm = "Global solution");
// This codes shows how to calculate the eigenvalue spectrum of
// the Laplace operator on a 2d square domain, using SLEPc.
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg lplace-complex-2d-SLEPc.edp \
//        -split 1 -npts 400 -nev 10
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc-complex"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , pi)  ; // Dimension of the domain
real Ly    = getARGV("-ly"   , pi)  ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-complex-2d-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
complex sigma = 1.0 + 1i;
complex nu = 1.0 + 1i;
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( nu*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
    -sigma*uh*vh               )//  Bilinear form
    +on(Labels[3], uh = 0.0)    //  Boundary Conditions
    +on(Labels[2], uh = 0.0)    //  Boundary Conditions
    +on(Labels[1], uh = 0.0)    //  Boundary Conditions
    +on(Labels[0], uh = 0.0)    //  Boundary Conditions
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<complex> A = vA(Vh,Vh);
matrix<complex> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat<complex> DistA(A, intersection, D, clean = true);
Mat<complex>   DistB(DistA, B, clean = true);
/***************************************/
/*          Problem resolution         */
/***************************************/
complex[int]     EigenVAL(0);       // array to store eigenvalues
Vh<complex>[int] def(EigenVEC)(1);  // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_pos_gen_non_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<complex> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            complex,// Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "mmg"
load "Element_P4"
load "Element_P3"
macro def1(u)u//

int[int] fforder = [1];
{
    func Pk = P4;                       // finite element space
    func PkNew = P3;                    // finite element space

    macro dimension()2// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions
    mesh ThNew, Th = square(getARGV("-global_2d", 20), getARGV("-global_2d", 20)); // global mesh
    {
        int N = 80;
        border a(t=0,1) { x=t;   y=0;   };
        border b(t=0,1) { x=1;   y=t;   };
        border c(t=0,1) { x=1-t; y=1;   };
        border d(t=0,1) { x=0;   y=1-t; };
        ThNew = buildmesh(a(N)+b(N)+c(N)+d(N));
    }
    DmeshCreate(Th);
    DmeshCreate(ThNew);
    fespace Vh(Th, Pk);
    fespace VhNew(ThNew, PkNew);
    Vh u = cos(8*pi*x) * sin(8*pi*y);
    VhNew uNew;
    VecInterpolate(Th, Pk, u, ThNew, PkNew, uNew);
    plotMPI(Th, u, Pk, def1, real, cmm = "Old FE function");
    plotMPI(ThNew, uNew, PkNew, def1, real, cmm = "New FE function");
    savevtk("transfer_2d.vtu", Th, u, order = fforder);
    savevtk("transfer_2d.vtu", ThNew, uNew, order = fforder, append = true);
}
{
    func PkSingle = P3;
    func Pk = [PkSingle, PkSingle];          // finite element space
    func PkNewSingle = P2;
    func PkNew = [PkNewSingle, PkNewSingle]; // finite element space

    macro dimension()3// EOM            // 2D or 3D
    macro def(u)[u, u#B]//
    macro init(u)[u, u]//
    include "macro_ddm.idp"             // additional DDM functions
    mesh3 ThNew, Th = cube(getARGV("-global_3d", 5), getARGV("-global_3d", 5), getARGV("-global_3d", 5)); // global mesh
    if(mpirank == 0)
        ThNew = mmg3d(Th, hmax = 8.0e-2);
    broadcast(processor(0), ThNew);
    DmeshCreate(Th);
    DmeshCreate(ThNew);
    fespace Vh(Th, Pk);
    fespace VhNew(ThNew, PkNew);
    Vh def(u) = [cos(2*pi*x) * sin(2*pi*y) * cos(2*pi*z), cos(2*pi*z)];
    VhNew def(uNew);
    VecInterpolate(Th, Pk, u, ThNew, PkNew, uNew);
    plotMPI(Th, def1(u), PkSingle, def1, real, cmm = "Old FE function");
    plotMPI(ThNew, def1(uNew), PkNewSingle, def1, real, cmm = "New FE function");
    savevtk("transfer_3d.vtu", Th, u, order = fforder);
    savevtk("transfer_3d.vtu", ThNew, uNew, order = fforder, append = true);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"

macro dimension()2//
include "macro_ddm.idp"

macro def(i)[i, i#B, i#C]//
macro init(i)[i, i, i]//
func Pk = [P2, P2, P1];
macro grad(u)[dx(u), dy(u)]//
macro div(u)(dx(u#1) + dy(u#2))//
macro UgradV(u, v)[[u#1, u#2]' * [dx(v#1), dy(v#1)],
                   [u#1, u#2]' * [dx(v#2), dy(v#2)]]//
real Re = getARGV("-Re", 75.0);
real nu = 1.0/Re;

mesh Th;
fespace Wh(Th, Pk); // complete space [u, v, p]
DmeshLoad(Th, "navier-stokes-2d");
Wh<complex> [uc1, uc2, pc];
ifstream sol("navier-stokes-2d_" + mpirank + "_" + mpisize + ".sol");
sol >> uc1[];
Mat<complex> J;
MatCreate(Th, J, Pk);
varf vJ([u1, u2, p], [v1, v2, q]) = int2d(Th)(
      (UgradV(uc, u) + UgradV(u, uc))' * [v1, v2]
    + nu * (grad(u1)' * grad(v1) +
            grad(u2)' * grad(v2))
    - p * div(v)
    - div(u) * q)
    + on(3, u1 = 0)
    + on(1, 2, u1 = 0, u2 = 0);
{
    matrix<complex> Loc = vJ(Wh, Wh);
    Loc = -Loc; // opposite of the Jacobian because SLEPc solves J*q=sigma*M*q
    J = Loc;
}
varf vM([u1, u2, p], [v1, v2, q]) = int2d(Th)(u1 * v1 + u2 * v2);
matrix<complex> Loc = vM(Wh, Wh);
Mat<complex> M(J, Loc, clean = true);

int nev = 1;
complex[int]     val(nev);      // array to store eigenvalues
Wh<complex>[int] def(vec)(nev); // array to store eigenvectors
complex s = getARGV("-shift_real", 1.0e-6) + getARGV("-shift_imag", 0.6) * 1i;
string params = "-eps_tol 1.0e-6 -eps_nev " + nev + " " +
    "-eps_type krylovschur -st_type sinvert -eps_monitor_all " +
    "-eps_target " + real(s) + "+" + imag(s) + "i";
int k = EPSSolve(J, M, vectors = vec, values  = val, sparams = params);
if(!NoGraphicWindow) {
    fespace Zh(Th, [P2, P2]);
    fespace Qh(Th, P1); // pressure space
    macro def1(i)i//
    Qh only = real(vecC[0]);
    plotMPI(Th, only, P1, def1, real, cmm = "Leading pressure eigenmode for Re = " + Re + ", eigenvalue = " + val[0]);
    macro def2(i)[i, i#B]//
    Zh [onlyU, onlyV] = [real(vec[0]), real(vecB[0])];
    plotMPI(Th, [onlyU, onlyV], [P2, P2], def2, real, cmm = "Leading velocity eigenmode for Re = " + Re + ", eigenvalue = " + val[0]);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1, P1, P1]; // finite element space


int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th =  cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
real f = -9000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);

Wh<real> def(u);                    // local solution

Wh<real> def(Rb)[6];
[Rb[0], RbB[0], RbC[0]] = [1, 0, 0];
[Rb[1], RbB[1], RbC[1]] = [0, 1, 0];
[Rb[2], RbB[2], RbC[2]] = [0, 0, 1];
[Rb[3], RbB[3], RbC[3]] = [y, -x, 0];
[Rb[4], RbB[4], RbC[4]] = [-z, 0, x];
[Rb[5], RbB[5], RbC[5]] = [0, z, -y];
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_pc_side right -ksp_max_it 200 -pc_gamg_threshold 0.01", nearnullspace = Rb, bs = 3);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    real[int] out(Wh.ndof);
    out = A * u[];
    real[int] rhs = vPb(0, Wh, tgv = -2);
    out -= rhs;
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    A = vPb(Wh, Wh, tgv = -2);
    return 0;
}
real[int] xPETSc;
u[] = 0;
ChangeNumbering(A, u[], xPETSc);
SNESSolve(A, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_linesearch_monitor -snes_type newtonls");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
macro def1(u)u// EOM
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
real alpha = 1.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = mpirank;
plotMPI(ThMoved, u, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

assert(mpisize == 1);
load "PETSc"
{
    real[int, int] A(2, 2);
    A(0, 0) = 2;
    A(0, 1) = 4;
    A(1, 1) = -4;
    A(1, 0) = 0.3;
    matrix sp = A;
    Mat dA(sp);
    real[int] list(2);
    list = 0;
    list(1) = 1;
    real[int, int] S(1, 1);
    set(dA, sparams = "-ksp_type preonly -pc_type lu -pc_factor_mat_solver_type mumps", schurList = list, schurComplement = S);
    cout << S << endl;
    assert(abs(S(0, 0) - (A(1, 1) - 1.0 / A(0, 0) * A(1, 0) * A(0, 1))) < 1e-10);
}
include "ExtractDofsonBorder.idp"
macro grad(u) [dx(u), dy(u)]//
real h = 0.1;
mesh Th = square(2/h, 1/h, [2*x, y]);
Th = trunc(Th, (abs(x-1) > 3*h) || (abs(y-0.45) > h/2), label = 10);
plot(Th, wait = 1);
fespace Vh(Th,P1);
varf vA(u,v) = int2d(Th)(grad(u)' * grad(v)) + on(1, 3, 4, u = 0);
{
    matrix A = vA(Vh, Vh, tgv = -2);
    Mat dA(A);
    int[int] I;
    ExtractDofsonBorder(2, Vh, I, 1);
    real[int] list(Vh.ndof);
    for [j, ij : I] list[ij] = j + 1;
    real[int, int] S(1, 1);
    set(dA, sparams = "-ksp_type preonly -pc_type lu -pc_factor_mat_solver_type mumps", schurList = list, schurComplement = S);
    cout << S << endl;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P2;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    fespace Ph(ThAugmented, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = int2d(ThAugmented)(u * v + dt * (grad(u)' * grad(v))) + int2d(ThAugmented)(dt * f *  v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM(u, v) = int2d(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + int1d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

set(A, sparams = "-hpddm_reuse_preconditioner=1");
Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs);
    newRhs += rhs;

    if(Opt.n > 0)       // optimized Schwarz methods
        DDM(A, newRhs, u[], excluded = excluded, ret = ret, O = Opt);
    else
        u[] = A^-1 * newRhs;

    plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "medit"

int[int] out;
int[int] part;
if(1) {
    DM dm("circle.msh");
    mesh localMesh2D = dm;
    if(mpirank == 0)
        cout << labels(localMesh2D) << endl;
    macro dimension()2//
    include "macro_ddm.idp"
    plotDmesh(localMesh2D, cmm = "Distributed 2D mesh");
    DmeshReconstruct(localMesh2D);
    fespace Vh(localMesh2D, P1);
    Vh u;
    PartitionCreate(localMesh2D, u[], P1);
    plotD(localMesh2D, u, cmm = "Reconstructed 2D partition of unity");
}
if(1) { // not sure why this doesn't work on Jenkins
if(mpirank == 0) {
    DM dm("cube_5tets.cas", communicator = mpiCommSelf);
    mesh3 Th = dm;
    medit("Fluent .cas", Th);
}
DM dm("sphere.msh", overlap = 0, neighbors = out, partition = part);
mesh3 localMesh3D = dm;
if(mpirank == 0)
    cout << labels(localMesh3D) << endl;
fespace Ph(localMesh3D, P0);
Ph plt;
for[i, v : part] plt[][i] = v;
mesh3 Th;
localMesh3D = Th;
localMesh3D = dm;
macro dimension()3//
include "macro_ddm.idp"
plotDmesh(localMesh3D, cmm = "Distributed 3D mesh");
DmeshReconstruct(localMesh3D);
fespace Vh(localMesh3D, P1);
Vh u;
PartitionCreate(localMesh3D, u[], P1);
plotD(localMesh3D, u, cmm = "Reconstructed 3D partition of unity");
DM overlap("sphere.msh", overlap = 1, prefix = "with_overlap_", sparams = "-petscpartitioner_type ptscotch");
localMesh3D = overlap;
plotDmesh(localMesh3D, cmm = "Distributed 3D mesh");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
load "mat_edgeP1"
load "Element_Mixte3d"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"
include "cube.idp"

macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
func Pk = Edge03d;
func PkNode = P1;

int Dirichlet = 1;

mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10));
int[int] chlab = [1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet, 5, Dirichlet, 6, Dirichlet];
Th = change(Th, refface = chlab);

fespace Wh(Th, Pk);

Mat A;
int[int] n2o;
macro ThN2O()n2o// EOM
DmeshCreate(Th);
{
    macro ThPkPart()Edge03ds0// EOM special FE for the domain partitioning
    MatCreate(Th, A, Pk);
}

real[int] rhs(Wh.ndof);
varf vPb([Ex,Ey,Ez],[vx,vy,vz]) =
    int3d(Th)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
    + int3d(Th)([vx,vy,vz]'*[Ex,Ey,Ez])
    + on(Dirichlet, Ex=0, Ey=0, Ez=0);
A = vPb(Wh, Wh);
func f = exp(-2.0*((x-0.5)^2+(y-0.5)^2+(z-0.5)^2));
varf vPbRhs([Ex,Ey,Ez],[vx,vy,vz]) =
    - int3d(Th)([vx,vy,vz]'*[0,0,f])
    + on(Dirichlet, Ex=0,Ey=0,Ez=0);
rhs = vPbRhs(0, Wh);

{
    Mat B;
    MatCreate(Th, B, P1);
    fespace VhNode(Th, PkNode);
    matrix GLoc;
    MatrixEdgeP1(GLoc, Th);
    Mat G(A, B, GLoc);
    VhNode coord = x;
    real[int] tmp;
    ChangeNumbering(B, coord[], tmp);
    real[int, int] coordPETSc(3, tmp.n);
    for(int j = 0; j < 3; ++j) {
        for[i, ui : tmp] coordPETSc(j, i) = ui;
        if(j == 0)
            coord = y;
        else if(j == 1)
            coord = z;
        ChangeNumbering(B, coord[], tmp);
    }
    set(A, sparams = "-pc_type hypre -pc_hypre_type ams -ksp_monitor -ksp_view -ksp_max_it 40", coordinates = coordPETSc, gradient = G);
}

Wh [solx, soly, solz];
solx[] = A^-1 * rhs;
if(!NoGraphicWindow) {
    real[int] sol;
    ChangeNumbering(A, solx[], sol);
    ChangeNumbering(A, solx[], sol, inverse = true);
    mesh3 ThPlt = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10));
    fespace WhPlt(ThPlt, Pk);
    WhPlt [pltx, plty, pltz];
    WhPlt [reducex, reducey, reducez];
    int[int] rest = restrict(Wh, WhPlt, n2o);
    for[i, v : rest] pltx[][v] = solx[][i];
    mpiReduce(pltx[], reducex[], processor(0, mpiCommWorld), mpiSUM);
    if(mpirank == 0)
        medit("Global solution", ThPlt, [real(reducex), real(reducey), real(reducez)]);
}
// This codes shows how to calculate the eigenvalue spectrum of
// the Laplace operator on a 2d square domain, using SLEPc.
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-SLEPc.edp \
//        -split 1 -npts 400 -nev 10 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , pi)  ; // Dimension of the domain
real Ly    = getARGV("-ly"   , pi)  ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( dx(uh)*dx(vh)+dy(uh)*dy(vh)  )//  Bilinear form
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D, clean = true);
Mat DistB(DistA, B, clean = true);

real[int, int] space(DistA.n, 1);
space = 1;

/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1);  // array to store eigenvectors
string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_view_values"             +
  " -eps_gen_nonhermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 // values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams, // Parameters for the distributed EigenValue solver
 deflation = space
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

if(0)
for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                  // SLEPc plugin
macro dimension()2// EOM      // 2D or 3D
include "macro_ddm.idp"       // additional DDM functions

macro def2(u)[u, u#B]// EOM
macro init2(u)[u, u]// EOM
macro def1(u)u// EOM
macro init1(u)u// EOM
macro grad(u)[dx(u), dy(u)]// EOM // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func PkV = [P2, P2];          // finite element space for the velocities
func PkP = P1;                // finite element space for the pressure

int s = getARGV("-split", 1); // refinement factor

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]);
fespace VhV(Th, PkV);         // local finite element space for the velocities
fespace VhP(Th, PkP);         // local finite element space for the pressure
DmeshCreate(Th);
Mat A, M;
{
    macro def(u)def2(u)//
    macro init(u)init2(u)//
    MatCreate(Th, A, PkV);
}
{
    macro def(u)def1(u)//
    macro init(u)init1(u)//
    MatCreate(Th, M, PkP);
}

varf vPbA([u, uB], [v, vB]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB)) + on(1, 2, 4, u = 0, uB = 0) + on(3, u = 1.0, uB = 0);
varf vPbB([q], [u, uB]) = int2d(Th)(-div(u) * q);
varf vPbM(p, q) = int2d(Th)(-p * q);
A = vPbA(VhV, VhV, tgv = -2);
M = vPbM(VhP, VhP);
Mat B(A, M);
Mat Z(A);
{
    B = vPbB(VhP, VhV);
    real[int] diag(VhV.ndof);
    matrix zeros = diag;
    Z = zeros;
    varf onGamma([u, uB], [v, vB]) = on(1, 3, 5, u = 1, uB = 1) + on(2, u = 1, uB = 1);
    VhV def2(g);
    g[] = onGamma(0, VhV, tgv = -1);
    real[int] gPETSc;
    ChangeNumbering(A, g[], gPETSc);
    MatZeroRows(B, gPETSc);
}
Mat LHS = [[A , B],
           [B', 0]];
Mat RHS = [[Z, 0],
           [0, M]];
int nV, nP;
{
    real[int] in(VhV.ndof), out;
    ChangeNumbering(A, in, out);
    nV = out.n;
    in.resize(VhP.ndof);
    ChangeNumbering(M, in, out);
    nP = out.n;
}
real[int] list(nV + nP);
list(0:nV - 1) = 1.0;
list(nV:nV + nP - 1) = 2.0;
real[int] nev(1);
EPSSolve(LHS, RHS, sparams = "-eps_gen_non_hermitian -st_pc_type fieldsplit -st_fieldsplit_1_pc_type jacobi -st_fieldsplit_0_pc_type hypre -st_ksp_type gmres -st_ksp_rtol 1e-1 " + " -eps_error_relative ::ascii_info_detail -st_ksp_converged_reason -eps_target_magnitude -st_type sinvert -eps_target 1.0e-5 -eps_nev 1", fields = list, values = nev);
assert(nev[0] > 0);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                  // PETSc plugin
macro dimension()2// EOM      // 2D or 3D
include "macro_ddm.idp"       // additional DDM functions

macro def2(u)[u, u#B]// EOM
macro init2(u)[u, u]// EOM
macro def1(u)u// EOM
macro init1(u)u// EOM
macro grad(u)[dx(u), dy(u)]// EOM // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func PkV = [P2, P2];          // finite element space for the velocities
func PkP = P1;                // finite element space for the pressure

int s = getARGV("-split", 1); // refinement factor

mesh Th = square(1, 1);
fespace VhV(Th, PkV);         // local finite element space for the velocities
fespace VhP(Th, PkP);         // local finite element space for the pressure
Mat dA, dC;
{
    mesh ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]);
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
    DmeshCreate(Th);
    {
        macro def(u)def2(u)//
        macro init(u)init2(u)//
        MatCreate(Th, dA, PkV);
    }
    {
        macro def(u)def1(u)//
        macro init(u)init1(u)//
        MatCreate(Th, dC, PkP);
    }
}

varf vPbA([u, uB], [v, vB]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB)) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
varf vPbB([q], [u, uB]) = int2d(Th)(-div(u) * q);
int vPETSc;
int pPETSc;
{
    matrix B = vPbB(VhP, VhV);
    real[int] rhsV = vPbA(0, VhV);

    dA = vPbA(VhV, VhV);
    Mat dB(dA, dC, B);
    Mat dS = [[dA , dB],
              [dB', 0 ]];
    ObjectView(dS);
    set(dS, sparams = "-pc_type lu");
    real[int] rhs(rhsV.n + VhP.ndof);
    rhs(0:rhsV.n - 1) = rhsV;
    real[int] sol = dS^-1 * rhs;
    VhV def2(solV);
    solV[] = sol(0:sol.n - VhP.ndof - 1);
    VhP solP;
    solP[] = sol(sol.n - VhP.ndof:sol.n - 1);
    plotMPI(Th, def2(solV), PkV, def2, real, cmm = "Global velocity");
    plotMPI(Th, solP, PkP, def1, real, cmm = "Global pressure");
}
{
    matrix B = vPbB(VhP, VhV);
    real[int] rhs = vPbA(0, VhV);

    Mat dB(dA, dC, B);
    Mat dS = [[dA , dB],
              [dB', 0 ]];
    Mat dF;
    MatConvert(dS, dF);
    set(dF, sparams = "-pc_type lu");
    real[int] sol;
    real[int] rhsPETScV, rhsPETScP;
    VhV def2(solV);
    VhP solP;
    ChangeNumbering(dA, rhs, rhsPETScV);
    ChangeNumbering(dC, solP[], rhsPETScP);
    vPETSc = rhsPETScV.n;
    pPETSc = rhsPETScP.n;
    real[int] rhsPETSc = [rhsPETScV,
                          rhsPETScP];
    {
        ObjectView(dF, format = "binary", name = "stokes-mat-binary");
        real[int, int] rhsView(rhsPETSc.n, 1);
        rhsView(:, 0) = rhsPETSc;
        ObjectView(rhsView, format = "binary", name = "stokes-rhs-binary");
        if(0) { // very costly
            ObjectView(dF, format = "ascii", name = "stokes-mat-ascii");
            ObjectView(dF, format = "matlab", name = "stokes-mat-matlab");
            ObjectView(rhsView, format = "ascii", name = "stokes-rhs-ascii");
            ObjectView(rhsView, format = "matlab", name = "stokes-rhs-matlab");
        }
    }
    KSPSolve(dF, rhsPETSc, sol);
    ChangeNumbering([dA, dC], [solV[], solP[]], sol, inverse = true, exchange = true);
    plotMPI(Th, def2(solV), PkV, def2, real, cmm = "Global velocity");
    plotMPI(Th, solP, PkP, def1, real, cmm = "Global pressure");
}
matrix<real> B = vPbB(VhP, VhV);

dA = vPbA(VhV, VhV, tgv = -1);
Mat dB(dA, dC, B);
{
    varf onGamma([u, uB], [v, vB]) = on(1, 3, 5, u = 1, uB = 1) + on(2, u = 1, uB = 1);
    VhV def2(g);
    g[] = onGamma(0, VhV, tgv = -1);
    real[int] gPETSc;
    ChangeNumbering(dA, g[], gPETSc);
    MatZeroRows(dB, gPETSc);
}
matrix BT = B';
Mat dBT(dC, dA, BT);
Mat dS = [[dA , dB],
          [dBT, 0 ]];
real[int] rhsPETSc;
VhV def2(solV);
VhP solP;
{
    real[int] rhs = vPbA(0, VhV, tgv = -1);
    ChangeNumbering([dA, dC], [rhs, solP[]], rhsPETSc);
}
for(int i = 0; i < 2; ++i) {
    real[int] sol;
    if(i == 0) {
        Mat dF;
        MatConvert(dS, dF);
        set(dF, sparams = "-pc_type lu");
        KSPSolve(dF, rhsPETSc, sol);
    }
    else {
        varf vSAL(p, q) = int2d(Th)(p * q);
        matrix SAL = vSAL(VhP, VhP);
        Mat[int] tab(1);
        Mat dSAL(dC, SAL);
        tab[0] = dSAL;
        real[int] list(rhsPETSc.n);
        list(0:vPETSc - 1) = 1.0;
        list(vPETSc:list.n - 1) = 2.0;
        set(dS, sparams = "-pc_type fieldsplit -ksp_type fgmres -ksp_view -ksp_monitor -fieldsplit_0_pc_type hypre -fieldsplit_0_ksp_type gmres -fieldsplit_0_ksp_rtol 1e-2 " + " -fieldsplit_0_ksp_monitor -fieldsplit_1_pc_type jacobi -fieldsplit_1_ksp_type cg -fieldsplit_1_ksp_max_it 5", fields = list, schur = tab);
        KSPSolve(dS, rhsPETSc, sol);
    }
    ChangeNumbering([dA, dC], [solV[], solP[]], sol, inverse = true, exchange = true);
    string plus = (i == 1 ? " + mAL preconditioning" : "");
    plotMPI(Th, def2(solV), PkV, def2, real, cmm = "Global velocity with tgv = -1" + plus);
    plotMPI(Th, solP, PkP, def1, real, cmm = "Global pressure with tgv = -1" + plus);
}
{
    ObjectView(dS);
    real c = 20.0;
    real[int] v, vPETSc;
    v.resize(VhV.ndof);
    v = mpirank;
    ChangeNumbering(dA, v, vPETSc);
    {
        Mat dSC = [[dA     , dB, vPETSc],
                   [dBT    , 0 , 0     ],
                   [vPETSc', 0 , c     ]];
        ObjectView(dSC);
    }
    {
        Mat dSC = [[dA     , vPETSc],
                   [vPETSc', c     ]];
        ObjectView(dSC);
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def1(i)i// EOM
macro def2(i)[i, i#B]// EOM
macro def(i)[i, i#B, i#C]// EOM
macro init(i)[i, i, i]// EOM
load "Element_Mixte"
func PkV = RT2;
func PkP = P2dc;
func Pk = [PkV, PkP];               // finite element space
border a(t=0,1) { x = -t+1; y = t; label = 1; };
border b(t=0,1) { x = -t; y = 1-t; label = 2; };
border c(t=0,1) { x = t-1; y = -t; label = 3; };
border d(t=0,1) { x = t; y = -1+t; label = 4; };
mesh Th = buildmesh(a(getARGV("-global", 20)) + b(getARGV("-global", 20)) + c(getARGV("-global", 20)) + d(getARGV("-global", 20)));
mesh ThGlobal = Th;
fespace Wh(Th, Pk);           // local finite element space
Mat A;
int[int] n2o;
macro ThN2O()n2o//
DmeshCreate(Th);
{
macro ThPostProcessD(D) {
    Wh def(u), def(v);
    varf onG(def(u), def(v)) = on(-111111, u = 10 + x + y, uB = 100 + y - x);
    v[] = D;
    u[] = onG(0, Wh);
    for [j, dj : u[]] dj = abs(dj) > 1e-2 ? 0.0 : 1.0;
    def(u) = [u, uB, vC];
    D = u[];
}// EOM
MatCreate(Th, A, Pk);
}

varf vMixedLaplace([u1, u2, p], [v1, v2, q]) = int2d(Th)(u1 * v1 + u2 * v2 + p*(dx(v1) + dy(v2)) + (dx(u1) + dy(u2))*q)
                                             + int2d(Th)(q)
                                             - int1d(Th, 1, 2, 3)(v1*N.x + v2*N.y)
                                             + on(4, u1 = 1.0, u2 = 1.0);

real[int] rhs = vMixedLaplace(0, Wh, tgv = -1);
A = vMixedLaplace(Wh, Wh, tgv = -1);
set(A, sparams ="-pc_type lu");
Wh def(u);
u[] = A^-1 * rhs;
macro params()// EOM
fespace WhGlobal(ThGlobal, Pk);
int[int] rest = restrict(Wh, WhGlobal, n2o);
WhGlobal def(uGlobal);
real[int] reduce(uGlobal[].n);
{
    real[int] tmp;
    ChangeNumbering(A, u[], tmp);
    ChangeNumbering(A, u[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u[][i];
mpiReduce(reduce, uGlobal[], processor(0), mpiSUM);
if(mpirank == 0) {
    plot(ThGlobal, def2(uGlobal), cmm = "Global solution", wait = 1, fill = 1);
    plot(ThGlobal, uGlobalC, cmm = "Global solution", wait = 1, fill = 1);
}
[u, uB, uC] = [0.0, 0.0, 1.0];
u[] += 1.0;
set(A, sparams = "-pc_type fieldsplit -ksp_monitor -ksp_view " +
    "-ksp_type fgmres " +
    "-pc_fieldsplit_type schur " +
    "-pc_fieldsplit_schur_fact_type full " +
    "-fieldsplit_0_ksp_type preonly " +
    "-fieldsplit_1_ksp_type gmres " +
    "-fieldsplit_1_ksp_converged_reason -fieldsplit_1_ksp_rtol 1e-4 " +
    "-pc_fieldsplit_schur_precondition selfp " +
    "-fieldsplit_1_pc_type hypre", fields = u[]);
u[] = A^-1 * rhs;
{
    real[int] tmp;
    ChangeNumbering(A, u[], tmp);
    ChangeNumbering(A, u[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u[][i];
mpiReduce(reduce, uGlobal[], processor(0), mpiSUM);
if(mpirank == 0) {
    plot(ThGlobal, def2(uGlobal), cmm = "Global solution", wait = 1, fill = 1);
    plot(ThGlobal, uGlobalC, cmm = "Global solution", wait = 1, fill = 1);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -ns -nw -v 0 -frequency 2 -Dpartitioner=parmetis -parmetis_worker 2 -ksp_view -log_view

load "PETSc-complex"
load "Element_Mixte3d"
macro dimension()3// EOM
include "macro_ddm.idp"
include "cube.idp"

macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
macro def(i)[i, i#y, i#z]// EOM
macro init(i)[i, i, i]// EOM
macro defPart(i)i// EOM
macro initPart(i)i// EOM

int level = 2;
int s = 2;

Mat<complex>[int] MG(level);
mesh3[int] Th(level);
matrix[int] P(level - 1);
int Robin = 2;
int[int] LL = [Robin, Robin, Robin, Robin, Robin, Robin];
real freq = getARGV("-frequency", 1.);
int nppwl = 10;
int n = freq*nppwl/s;
Th[level - 1] = cube(n, n, n, [x, y, z], label = LL);
func Pk = Edge03d;
func PkPart = Edge03ds0;

real[int] timesi(4), times(4);

real ttime = mpiWtime();
buildMatEdgeRecursive(Th, s, level, P, MG, Pk, mpiCommWorld, PkPart, defPart, initPart);
timesi[0] = mpiWtime() - ttime;

func k = 2 * pi * freq;
func f = exp(-50 * k * ((x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2));

complex[int] rhs;
matrix<complex>[int] Opt(level);

ttime = mpiWtime();
for(int i = 0; i < level; ++i) {
    fespace Vh(Th[i], Pk);
    varf vPb([Ex,Ey,Ez], [vx,vy,vz]) =
        int3d(Th[i],qforder=2)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
      + int3d(Th[i],qforder=2)(-k^2*[vx,vy,vz]'*[Ex,Ey,Ez])
      + int2d(Th[i],Robin,qforder=2)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
      + int2d(Th[i],-111111,qforder=2)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez));
    Opt[i] = vPb(Vh, Vh, sym = 1);
    MG[i] = Opt[i];
    if(i == 0) {
        varf vRHS([Ex,Ey,Ez],[vx,vy,vz]) = -int3d(Th[i])([vx,vy,vz]'*[0,0,f]);
        rhs.resize(Vh.ndof);
        rhs = vRHS(0, Vh);
    }
}
timesi[1] = mpiWtime() - ttime;

mpiBarrier(mpiCommWorld);
ttime = mpiWtime();
set(MG, P, sparams = "-pc_type mg -ksp_monitor -ksp_view_final_residual -ksp_type fgmres -ksp_gmres_restart 200 -ksp_max_it 200");
set(MG, 0, sparams = "-mg_coarse_ksp_type gmres -mg_coarse_ksp_rtol 1e-1 -mg_coarse_ksp_pc_side right " + " -mg_coarse_ksp_max_it 50 -mg_coarse_ksp_converged_reason -mg_coarse_pc_type asm -mg_coarse_sub_pc_factor_mat_solver_type mumps -mg_coarse_sub_pc_type cholesky -mg_coarse_pc_asm_type restrict", O = Opt[level - 1]);

set(MG, level - 1, sparams = "-mg_levels_ksp_type richardson -mg_levels_ksp_pc_side left -mg_levels_pc_type asm -mg_levels_sub_pc_type cholesky -mg_levels_sub_pc_factor_mat_solver_type mumps -mg_levels_pc_asm_type restrict", O = Opt[0]);
fespace Vh(Th[0], Pk);
Vh<complex> def(u);
u[] = MG[0]^-1 * rhs;
timesi[2] = mpiWtime() - ttime;

ttime = mpiWtime();
mesh3 ThFine = Th[0];
fespace VhFine(ThFine, P1);
if(!NoGraphicWindow) {
    VhFine plt = sqrt(real(u)^2 + real(uy)^2 + real(uz)^2);
    plotD(ThFine, plt, cmm = "Solution");
}
int[int] fforder = [1, 1];
savevtk("maxwell-mg-3d.vtu", ThFine, [real(u), real(uy), real(uz)], [imag(u), imag(uy), imag(uz)], order = fforder, bin = 1);
timesi[3] = mpiWtime() - ttime;

mpiReduce(timesi, times, processor(0,mpiCommWorld), mpiMAX);

if (mpirank == 0) {
    cout << "mesh partitioning: " << times[0] << "s" << endl;
    cout << "assembly: " << times[1] << "s" << endl;
    cout << "solution: " << times[0] << "s" << endl;
    cout << "vtk export: " << times[0] << "s" << endl;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1, P1, P1];             // finite element space

int s = getARGV("-split", 1);                                   // refinement factor

int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(6 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [6 * x, y, z], label = LL);
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11;
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
int dirichlet = 1;
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(dirichlet, u = 0.0, uB = 0.0, uC = 0.0);
matrix<real> Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_coarse_correction balanced -hpddm_geneo_nu 10");

int solver = getOption("schwarz_method");
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    matrix<real> noPen = vPb(Wh, Wh, sym = 1);
    AttachCoarseOperator(mpiCommWorld, A, A = noPen);
}

Wh<real> def(u);    // local solution

u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

mpiBarrier(mpiCommWorld);

macro def1(u)u// EOM
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
real alpha = 20000.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = err;
plotMPI(Th, u, P1, def1, real, cmm = "Global residual");
u[] = mpirank;
plotMPI(ThMoved, u, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = intN(Th)(grad(u)' * grad(v));
func f = 1 + x - y;
varf vL(u, v)  = intN(Th)(f * v);
varf vb(u, v)  = intN(Th)(v);
real[int] F = vL(0, Wh);
real[int] B = vb(0, Wh);
real[int] pB, pF, pSol;
A = vPb(Wh, Wh);
ChangeNumbering(A, B, pB);
ChangeNumbering(A, F, pF);

Mat N = [[ A  , pB ],
         [ pB', 0  ]];
if(mpirank == 0) {
    pF.resize(pF.n + 1);
    pF = [pF(0:pF.n - 2), 0];
    F.resize(F.n + 1);
    F = [F(0:F.n - 2), 0];
}
{
    set(N, sparams = "-pc_type lu");
    real[int] x = N^-1 * F;
    if(mpirank == 0)
        x.resize(x.n - 1);
    Wh sol;
    sol[] = x;
    macro params()cmm = "Global solution #1", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
{
    Mat C;
    MatConvert(N, C);
    set(C, sparams = "-pc_type lu");
    KSPSolve(C, pF, pSol);
    if(mpirank == 0)
        pSol.resize(pSol.n - 1);
    Wh sol;
    ChangeNumbering(A, sol[], pSol, inverse = true, exchange = true);
    macro params()cmm = "Global solution #2", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
{
    set(N, sparams = "-ksp_view_pre -pc_type fieldsplit -fieldsplit_0_pc_type lu -fieldsplit_0_mat_mumps_cntl_3 1e-12 -fieldsplit_0_mat_mumps_icntl_24 1 -pc_fieldsplit_detect_saddle_point");
    KSPSolve(N, pF, pSol);
    if(mpirank == 0)
        pSol.resize(pSol.n - 1);
    Wh sol;
    ChangeNumbering(A, sol[], pSol, inverse = true, exchange = true);
    macro params()cmm = "Global solution #3", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
{
    Mat M = [[ 0 , pB'],
             [ pB, A  ]];
    set(M, sparams = "-pc_type lu");
    if(mpirank == 0) {
        real[int] tmp = F(0:F.n - 2);
        F(0) = 0;
        F(1:F.n - 1) = tmp;
    }
    real[int] x = M^-1 * F;
    if(mpirank == 0) {
        real[int] tmp = x(1:F.n - 1);
        x.resize(x.n - 1);
        x = tmp;
    }
    Wh sol;
    sol[] = x;
    macro params()cmm = "Global solution #4", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
int[int] labPeriodic = [2, 4, 1, 3];
macro Pk() P2, periodic=[[labPeriodic[0],x+y], [labPeriodic[1],x+y], [labPeriodic[2],x-y], [labPeriodic[3],x-y]]// EOM

real r = 0.25;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh Th = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
Mat A;
int[int] n2o;
macro ThPeriodicity()labPeriodic//
macro ThN2O()n2o//
DmeshCreate(Th);
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
func f = (y+x+1) * (y+x-1) * (y-x+1) * (y-x-1);
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) - int2d(Th)((0.39 - f) * v) + on(0, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

real[int] err = A * u[];            // global matrix-vector product
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");

set(A, sparams = "-pc_type gamg -ksp_type gmres -pc_gamg_threshold -1.0 -ksp_max_it 200");
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
if(!NoGraphicWindow) {
    real[int] sol;
    ChangeNumbering(A, u[], sol);
    ChangeNumbering(A, u[], sol, inverse = true);
    mesh ThPlt = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
    fespace WhPlt(ThPlt, Pk);
    WhPlt plt;
    WhPlt reduce;
    int[int] rest = restrict(Wh, WhPlt, n2o);
    plt[](rest) = u[];
    mpiReduce(plt[], reduce[], processor(0, mpiCommWorld), mpiSUM);
    if(mpirank == 0)
        plot(reduce);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u), dz(u)]// // three-dimensional gradient
func Pk = P1;                       // finite element space

int[int] LL = [1,2, 1,2, 1,1];
mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);    // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int3d(Th)(grad(u)' * grad(v)) + int3d(Th)(v) + on(1, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

real[int] err = A * u[];            // global matrix-vector product
real[int] transpose = A' * u[];
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");

Wh<real> Rb[1];
Rb[0] = 1;
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200", nearnullspace = Rb);
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "bem"
load "PETSc-complex"
include "macro_ddm.idp"

if(!HasType("Mat", "Htool")) exit(0);

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int[int] nsl(10); // number of lenses
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

mesh Thwaveguide = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l));

mesh Thlenses = buildmesh(circle(nsl));
// we do not want any region with label 0 for the lenses, as 0 is the waveguide region in Thwaveguide :
Thlenses = change(Thlenses,fregion=region+1);

mesh Th = Thwaveguide + Thlenses; // FEM mesh

meshL ThG = extract(Th);
ThG = trunc(ThG,region==interface);
ThG = OrientNormal(ThG,unbounded=1); // BEM mesh

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1;
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);

func ind = region == -1 ? 1 : 2./(1+((x-nsx[region-1])^2+(y-nsy[region-1])^2)); // gradient index in lenses

plot(ThG);
Mat<complex> A, T;
if(usedARGV("-user_partitioning") == -1) {
    MatCreate(Th, A, P1);
    MatCreate(Th, T, P0);
}
else {
    int[int] n2o;
    mesh withBEM = trunc(Th, (x-3.2)^2+y^2 > 0.6, new2old = n2o);
    fespace PhPart(withBEM, P0);
    PhPart partWithBEM;
    partitionerSeq(partWithBEM[], withBEM, mpisize - 1);
    partitionerPar(partWithBEM[], withBEM, mpiCommWorld, mpisize - 1);
    Ph part;
    part[] = mpisize - 1;        // last rank has no BEM unknown
    part[](n2o) = partWithBEM[]; // no need for restrict since using P0
    plot(part);
    macro ThUserPartitioning()part[]//
    MatCreate(Th, A, P1);
    MatCreate(Th, T, P0);
}
meshL ThL;
{
    int[int] labels=labels(Th);
    if(labels.max > 0) {
        fespace PhL(ThG, P0);
        PhL u = (region==interface)*chi(Th);
        ThL = trunc(ThG,abs(u-1.0)<1.0e-2);
    }
}
fespace Vh(Th, P1);
macro Grad(u) [dx(u),dy(u)] // EOM
varf varfA(u,v) = int2d(Th)(-ind*k^2*u*v+Grad(u)'*Grad(v)) + on(waveguide,u=0);
A = varfA(Vh, Vh, tgv = -1);
fespace VhS(ThL, P1);
matrix RVtoS = interpolate(VhS, Vh);
Mat<complex> ASurf(A, restriction = RVtoS);
{
    fespace PhS(ThL, P0);
    matrix PVtoS = interpolate(PhS, Ph);
    Mat<complex> TSurf(T, restriction = PVtoS);
    CoherentGlobalMesh(TSurf, ASurf, ThL, ThG);
    MatDestroy(T);
}
matrix<complex> Mass;
if(ThL.nt) {
    varf varfMass(u,v) = int1d(Th,interface)(u*v) + on(waveguide,u=0);
    Mass = varfMass(Vh, Vh, tgv = -10);
    matrix IdV = eye(Vh.ndof);
    renumbering(Mass, RVtoS, R = IdV);
}
Mat<complex> TDL(ASurf);
{
    fespace UhG(ThG, P1);
    varf varfTDL(u,v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("TDL",k=k),u,v)) + int1d(ThG)(0.5*u*v);
    TDL = varfTDL(UhG, UhG);
    varf varfSL(u,v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("SL",k=k),u,v));
    ASurf = varfSL(UhG, UhG, sym = 1, sparams = "-mat_htool_epsilon 1.0e-3");
    ASurf *= -1.0;
}
Mat<complex> VtoS(ASurf, A, Mass);
Mat<complex> StoV(A, ASurf);
{
    matrix<complex> PStoV = RVtoS;
    PStoV = PStoV';
    StoV = PStoV;
}
complex[int] rhs(Vh.ndof + VhS.ndof);
varf varfRHS(u,v) = int2d(Th)(finc*v) + on(waveguide,u=0);
rhs(0:Vh.ndof - 1) = varfRHS(0, Vh, tgv = -1);
Mat<complex> N;
if(usedARGV("-aij") == -1) {
    N = [[A,    StoV*TDL],
         [VtoS, ASurf   ]];
    real[int] list(N.n);
    list(0:A.n-1) = 1.0;
    if(ThL.nt)
        list(A.n:list.n-1) = 2.0;
    set(N, sparams = "-ksp_view -ksp_monitor -ksp_type fgmres -ksp_view_final_residual -fieldsplit_1_ksp_max_it 2000 -ksp_gmres_restart 200 -pc_type fieldsplit "+" -fieldsplit_0_pc_type asm -fieldsplit_0_sub_pc_type lu -fieldsplit_0_ksp_type gmres -fieldsplit_1_ksp_type gmres -fieldsplit_1_ksp_gmres_restart 2000 "+" -prefix_push fieldsplit_1_ -ksp_pc_side right -ksp_max_it 20 -prefix_pop", fields = list);
}
else {
    Mat<complex> DTDL;
    MatConvert(TDL, DTDL);
    Mat<complex> R;
    MatMatMult(StoV, DTDL, R);
    N = [[A,    R    ],
         [VtoS, ASurf]];
    set(N, sparams = "-pc_type lu");
}
complex[int] x = N^-1 * rhs;
Vh<complex> plt;
plt[] = x(0:Vh.ndof-1);
macro def(u)u//
plotMPI(Th, real(plt), P1, def, real, cmm = "FEM solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "mshmet"
load "mmg"
load "medit"
load "PETSc"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

int n = 12;
int[int] L=[1,1,1,1], LU=[0,2], LD=[1,1], LR=[0,1];
mesh3 Th3 = buildlayers(square(n, n, region=0, label=L), n, zbound=[0,1], labelmid=LD, labelup=LU, labeldown=LR);
Th3 = trunc(Th3, x < 0.5 || y < 0.5 || z < 0.5, label=3);

macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient

varf vPoisson(u, v) = int3d(Th3)(grad(u)' * grad(v)) + int3d(Th3)(v) + on(1,2,3, u=0);

mesh3 ThBackup = Th3;
Mat A;
int[int] n2o;
NewMacro Th3N2O() n2o EndMacro
DmeshCreate(Th3);
MatCreate(Th3, A, P1);
fespace Vh(Th3, P1);
Vh u;
real err = 1.0e-2;

int iMax = 4;
int[int] rt(2);
rt = [1,2];
for(int i = 0; i < iMax; ++i) {
    A = vPoisson(Vh, Vh, tgv = -2);
    set(A, sparams = "-ksp_monitor -pc_type hypre");
    real[int] rhs = vPoisson(0, Vh, tgv = -1);
    u[] = A^-1 * rhs;
    int[int] fforder = [1];
    savevtk("laplace-adapt-3d.vtu", Th3, u, bin = 1, order = fforder, append = i ? true : false);
    if(i < iMax - 1) {
        fespace VhBackup(ThBackup, P1);
        VhBackup h, hReduced;
        u[] .*= A.D;
        int[int] rest = restrict(Vh, VhBackup, n2o);
        for[i, v : rest] h[][v] = u[][i];
        mpiAllReduce(h[], hReduced[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            real[int] met = mshmet(ThBackup, hReduced, aniso = 0, hmin = 1.0e-3, hmax = 2.0e-1, err = err);
            plot(hReduced);
            Th3 = mmg3d(ThBackup, metric = met, hgrad = 3.0, requiredTriangle = rt);
            medit("U-adapt-iso-" + i, Th3, hReduced);
        }
        broadcast(processor(0), Th3);
        ThBackup = Th3;
        Mat Adapt;
        MatCreate(Th3, Adapt, P1);
        A = Adapt;
        u = 0.0;
        err *= 0.5;
    }
}
//  run with MPI:  ff-mpirun -np 4 diffusion-hpddm-3d-PETSc.edp -ns -pc_type lu -wg
// Options for -pc_type: lu (direct solver), gamg (algebraic multigrid), hpddm (multilevel domain decomposition method with the GenEO coarse problem)
// Options for hpddm via PETSc are given in: https://petsc.org/release/manualpages/PC/PCHPDDM/
// As far as PCHPDDM is concerned, this script implements the GenEO method with a fixed number of eigenvectors per subdomain for the construction of the coarse problem
// NBPROC 4
// Authors: P. Jolivet, F. Nataf

load "PETSc"
macro dimension()3// EOM
include "macro_ddm.idp"

tgv = -1;

macro grad(u)[dx(u), dy(u) , dz(u)]// EOM
func Pk = P1;

mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10)); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//

// decompose and distribute the mesh Th, and allocates data structures for the communication of the distributed matrix A
// after this line, Th refers to a local mesh: the one of the subdomain
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk); // local finite element space on the local mesh Th
varf vPb(u, v) = int3d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);

Wh u, rhs, residual; // local solution, right-hand side, and final residual

// local component of the global right-hand side
rhs[] = vPb(0, Wh);

if(1) {
    // R_i sum R_j^T D_j rhs_j
    exchange(A, rhs[] , scaled = true);
    plotD(Th, rhs, cmm = "Global right-hand side")
}

matrix Neumann = vPb(Wh, Wh); // local matrix with Neumann boundary condition on the interface of the subdomain
// recall that A is a distributed matrix and Neumann is a local one
// the following equal sign '=' means in fact that the entries of the distributed matrix A are filled with the entries of the local Neumann matrix, then A is ready for use
A = Neumann;

// near kernel of the operator (used only by PCGAMG)
Wh Rb[1];
Rb[0] = 1;
// all in one; see at the end of the script the meaning of the parameters
set(A, sparams = " -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_levels_1_sub_pc_factor_mat_solver_type mumps -pc_hpddm_has_neumann -pc_hpddm_define_subdomains " +
                 " -pc_hpddm_levels_1_sub_mat_mumps_cntl_4 0.1 -pc_hpddm_levels_1_eps_use_inertia -pc_hpddm_levels_1_eps_threshold 0.5 -pc_hpddm_levels_1_st_share_sub_ksp " +
                 " -ksp_type gmres -ksp_pc_side right -ksp_monitor", nearnullspace = Rb);
u[] = A^-1 * rhs[];

residual[] = A * u[];
residual[] -= rhs[];

plotD(Th, residual, cmm = "Global Residual");
plotD(Th, u, cmm = "Global Solution");

// meaning of some flags in sparams when using PCHPDDM (-pc_type hpddm on the command line)
//  -pc_hpddm_levels_1_sub_pc_type lu                      - subdomain solver is an exact LU factorization
//  -pc_hpddm_levels_1_sub_pc_factor_mat_solver_type mumps - MUMPS is used for computing local exact factorizations
//  -pc_hpddm_has_neumann                                  - local matrices passed to PCHPDDM are the Neumann matrices, see https://petsc.org/release/manualpages/PC/PCHPDDMHasNeumannMat/
//  -pc_hpddm_define_subdomains                            - use the FreeFEM overlap to define the preconditioner on the first level
//  -pc_hpddm_levels_1_sub_mat_mumps_cntl_4 0.1            - static pivoting to get a reliable estimate of the inertia, see CNTL(4) in https://mumps-solver.org/index.php?page=doc
//  -pc_hpddm_levels_1_eps_use_inertia                     - needed when using a threshold for defining the GenEO coarse problem
//  -pc_hpddm_levels_1_st_share_sub_ksp                    - https://petsc.org/release/manualpages/PC/PCHPDDMSetSTShareSubKSP/
//  -ksp_type gmres                                        - GMRES as the Krylov solver, see https://petsc.org/release/manualpages/KSP/KSPType/
//  -ksp_pc_side right                                     - the preconditioner is to be applied on the right, see https://petsc.org/release/manualpages/PC/PCSide/
//  -ksp_monitor                                           - https://petsc.org/release/manualpages/KSP/KSPMonitor/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

int[int] l = [1, 1, 1, 1];
mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
real[int] rhs(Wh.ndof);             // local right-hand side
matrix<real> M;                     // local mass matrix
{                                   // local weak form
    fespace Ph(Th, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + int2d(Th)(dt * f *  v) + on(1, u = 0.0);
    A = vPb(Wh, Wh, tgv = -1);
    rhs = vPb(0, Wh, tgv = -1);
    varf vPbM(u, v) = int2d(Th)(u * v);
    M = vPbM(Wh, Wh);
}

set(A, sparams = "-ksp_view");
Wh<real> u = 0.0;                   // local solution

for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    newRhs = M * u[];
    newRhs += rhs;

    u[] = A^-1 * newRhs;

    macro def(u)u//
    plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro trueRestrict()true// EOM
macro removeZeros()true// EOM
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
func Pk = P2;                       // finite element space
func Pkdc = P2dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);
fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);

Vh b = 1;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vdJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, 3, 4, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, 3, 4, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, 3, 4, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vdJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

real[int] xPETSc, bPETSc;
u[] = vC(0, Vh);
ChangeNumbering(A, u[], bPETSc);
xPETSc.resize(bPETSc.n);
xPETSc = 0;
int ret;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -ksp_monitor_true_residual -snes_converged_reason -ksp_converged_reason -pc_type lu -snes_view", reason = ret);
assert(ret == 3);
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");

xPETSc = 0;
Vh v;
int j;
real absTol = 1e-2;
macro myplot() cmm = "Global " + (j == 0 ? "solution" : "decrement") + " at iteration " + it, wait = 1, fill = 1, dim = 3// EOM
func int funcMonitor(int it, real xnorm, real gnorm, real f, real[int]& u, real[int]& du) {
    ChangeNumbering(A, v[], u, inverse = true, exchange = true);
    j = 0;
    plotMPI(Th, v, Pk, def, real, myplot);
    ChangeNumbering(A, v[], du, inverse = true, exchange = true);
    j = 1;
    plotMPI(Th, v, Pk, def, real, myplot);
    real abs = du.linfty, red;
    mpiAllReduce(abs, red, mpiCommWorld, mpiMAX);
    return it > 0 && red < absTol ? 2 : 0; // reasons defined there https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESConvergedReason.html
}
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_converged_reason", monitor = funcMonitor, reason = ret);
assert(ret == 2);
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro trueRestrict()true// EOM
macro removeZeros()true// EOM
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
func Pk = [P1, P1];                 // finite element space

//  Macros for the gradient of a vector field (u1, u2)
macro grad11(u1, u2) (dx(u1)) //
macro grad21(u1, u2) (dy(u1)) //
macro grad12(u1, u2) (dx(u2)) //
macro grad22(u1, u2) (dy(u2)) //

//  Macros for the deformation gradient
macro F11(u1, u2) (1.0 + grad11(u1,u2)) //
macro F12(u1, u2) (0.0 + grad12(u1,u2)) //
macro F21(u1, u2) (0.0 + grad21(u1,u2)) //
macro F22(u1, u2) (1.0 + grad22(u1,u2)) //

//  Macros for the incremental deformation gradient
macro dF11(varu1, varu2) (grad11(varu1, varu2)) //
macro dF12(varu1, varu2) (grad12(varu1, varu2)) //
macro dF21(varu1, varu2) (grad21(varu1, varu2)) //
macro dF22(varu1, varu2) (grad22(varu1, varu2)) //

//  Macro for the determinant of the deformation gradient
macro J(u1, u2) (
F11(u1, u2)*F22(u1, u2) - F12(u1, u2)*F21(u1, u2)
) //

//  Macros for the inverse of the deformation gradient
macro Finv11 (u1, u2) (
F22(u1, u2) / J(u1, u2)
) //
macro Finv22 (u1, u2) (
F11(u1, u2) / J(u1, u2)
) //
macro Finv12 (u1, u2) (
-F12(u1, u2) / J(u1, u2)
) //
macro Finv21 (u1, u2) (
-F21(u1, u2) / J(u1, u2)
) //

//  Macros for the square of the inverse of the deformation gradient
macro FFinv11 (u1, u2) (
Finv11(u1, u2)^2 + Finv12(u1, u2)*Finv21(u1, u2)
) //

macro FFinv12 (u1, u2) (
Finv12(u1, u2)*(Finv11(u1, u2) + Finv22(u1, u2))
) //

macro FFinv21 (u1, u2) (
Finv21(u1, u2)*(Finv11(u1, u2) + Finv22(u1, u2))
) //

macro FFinv22 (u1, u2) (
Finv12(u1, u2)*Finv21(u1, u2) + Finv22(u1, u2)^2
) //

//  Macros for the inverse of the transpose of the deformation gradient
macro FinvT11(u1, u2) (Finv11(u1, u2)) //
macro FinvT12(u1, u2) (Finv21(u1, u2)) //
macro FinvT21(u1, u2) (Finv12(u1, u2)) //
macro FinvT22(u1, u2) (Finv22(u1, u2)) //

macro B11(u1, u2)
(
F11(u1, u2)^2 + F12(u1, u2)^2
)//

macro B12(u1, u2)
(
F11(u1, u2)*F21(u1, u2) + F12(u1, u2)*F22(u1, u2)
)//

macro B21(u1, u2)
(
F11(u1, u2)*F21(u1, u2) + F12(u1, u2)*F22(u1, u2)
)//

macro B22(u1, u2)
(
F21(u1, u2)^2 + F22(u1, u2)^2
)//

macro d0Aux11 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * F11(u1, u2) + dF12(varu1, varu2) * F12(u1, u2)
)//

macro d0Aux12 (u1, u2, varu1, varu2)
(
dF21(varu1, varu2) * F11(u1, u2) + dF22(varu1, varu2) * F12(u1, u2)
)//

macro d0Aux21 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * F21(u1, u2) + dF12(varu1, varu2) * F22(u1, u2)
)//

macro d0Aux22 (u1, u2, varu1, varu2)
(
dF21(varu1, varu2) * F21(u1, u2) + dF22(varu1, varu2) * F22(u1, u2)
)//

////  The tensor quantity D1 = D0 + D0^T
macro d1Aux11 (u1, u2, varu1, varu2)
(
2.0 * d0Aux11 (u1, u2, varu1, varu2)
)//

macro d1Aux12 (u1, u2, varu1, varu2)
(
d0Aux12 (u1, u2, varu1, varu2) + d0Aux21 (u1, u2, varu1, varu2)
)//

macro d1Aux21 (u1, u2, varu1, varu2)
(
d1Aux12 (u1, u2, varu1, varu2)
)//

macro d1Aux22 (u1, u2, varu1, varu2)
(
2.0 * d0Aux22 (u1, u2, varu1, varu2)
)//

////  The tensor quantity D2 = F^{-T}_{n} dF_{n+1}
macro d2Aux11 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * FinvT11(u1, u2) + dF21(varu1, varu2) * FinvT12(u1, u2)
)//

macro d2Aux12 (u1, u2, varu1, varu2)
(
dF12(varu1, varu2) * FinvT11(u1, u2) + dF22(varu1, varu2) * FinvT12(u1, u2)
)//

macro d2Aux21 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * FinvT21(u1, u2) + dF21(varu1, varu2) * FinvT22(u1, u2)
)//

macro d2Aux22 (u1, u2, varu1, varu2)
(
dF12(varu1, varu2) * FinvT21(u1, u2) + dF22(varu1, varu2) * FinvT22(u1, u2)
)//

////  The tensor quantity D3 = F^{-2}_{n} dF_{n+1}
macro d3Aux11 (u1, u2, varu1, varu2, w1, w2)
(
dF11(varu1, varu2) *FFinv11(u1, u2) *grad11(w1, w2) + dF21(varu1, varu2) *FFinv12(u1, u2)
*grad11(w1, w2)
+ dF11(varu1, varu2) *FFinv21(u1, u2) *grad12(w1, w2) + dF21(varu1, varu2) *FFinv22(u1, u2) *grad12(w1, w2)
)//

macro d3Aux12 (u1, u2, varu1, varu2, w1, w2)
(
dF12(varu1, varu2) *FFinv11(u1, u2) *grad11(w1, w2) + dF22(varu1, varu2) *FFinv12(u1, u2)
*grad11(w1, w2)
+ dF12(varu1, varu2) *FFinv21(u1, u2) *grad12(w1, w2) + dF22(varu1, varu2) *FFinv22(u1, u2) *grad12(w1, w2)
)//

macro d3Aux21 (u1, u2, varu1, varu2, w1, w2)
(
dF11(varu1, varu2) *FFinv11(u1, u2) *grad21(w1, w2) + dF21(varu1, varu2) *FFinv12(u1, u2)
*grad21(w1, w2)
+ dF11(varu1, varu2) *FFinv21(u1, u2) *grad22(w1, w2) + dF21(varu1, varu2) *FFinv22(u1, u2) *grad22(w1, w2)
)//

macro d3Aux22 (u1, u2, varu1, varu2, w1, w2)
(
dF12(varu1, varu2) *FFinv11(u1, u2) *grad21(w1, w2) + dF22(varu1, varu2) *FFinv12(u1, u2)
*grad21(w1, w2)
+ dF12(varu1, varu2) *FFinv21(u1, u2) *grad22(w1, w2) + dF22(varu1, varu2) *FFinv22(u1, u2) *grad22(w1, w2)
)//

////  The tensor quantity D4 = (grad w) * Finv
macro d4Aux11 (w1, w2, u1, u2)
(
Finv11(u1, u2)*grad11(w1, w2) + Finv21(u1, u2)*grad12(w1, w2)
)//

macro d4Aux12 (w1, w2, u1, u2)
(
Finv12(u1, u2)*grad11(w1, w2) + Finv22(u1, u2)*grad12(w1, w2)
)//

macro d4Aux21 (w1, w2, u1, u2)
(
Finv11(u1, u2)*grad21(w1, w2) + Finv21(u1, u2)*grad22(w1, w2)
)//

macro d4Aux22 (w1, w2, u1, u2)
(
Finv12(u1, u2)*grad21(w1, w2) + Finv22(u1, u2)*grad22(w1, w2)
)//

//  The Kirchhoff stress tensor
macro StressK11(u1, u2)
(
mu * (B11(u1, u2) - 1.0)
)//

//  The Kirchhoff stress tensor
macro StressK12(u1, u2)
(
mu * B12(u1, u2)
)//

//  The Kirchhoff stress tensor
macro StressK21(u1, u2)
(
mu * B21(u1, u2)
)//

//  The Kirchhoff stress tensor
macro StressK22(u1, u2)
(
mu * (B22(u1, u2) - 1.0)
)//

//  The tangent Kirchhoff stress tensor
macro TanK11(u1, u2, varu1, varu2)
(
mu * d1Aux11(u1, u2, varu1, varu2)
)//

macro TanK12(u1, u2, varu1, varu2)
(
mu * d1Aux12(u1, u2, varu1, varu2)
)//

macro TanK21(u1, u2, varu1, varu2)
(
mu * d1Aux21(u1, u2, varu1, varu2)
)//

macro TanK22(u1, u2, varu1, varu2)
(
mu * d1Aux22(u1, u2, varu1, varu2)
)//

//  Elastic coefficients
real mu = 5.e2; //  kg/cm^2

//  Stress loads
real Pa = -3.e2;

//  The wound radius
real InnerRadius = 1.e0;

//  The outer (truncated) radius
real OuterRadius = 4.e0;

//  Extension of the inner ellipse ((major axis) - (minor axis))
real InnerEllipseExtension = 1.e0;

int m = 40, n = 20;

border InnerEdge(t = 0, 2.0*pi) {x = (1.0 + InnerEllipseExtension) * InnerRadius * cos(t); y = InnerRadius * sin(t); label = 1;}

border OuterEdge(t = 0, 2.0*pi) {x = (1.0 + 0.0 * InnerEllipseExtension) * OuterRadius * cos(t); y = OuterRadius * sin(t); label = 2;}

mesh Th = buildmesh(InnerEdge(-m) + OuterEdge(n));

plot(Th);
fespace Vh(Th, Pk);
Vh [u1n,u2n];

varf neoHookeanInc ([varu1, varu2], [w1, w2]) =
int2d(Th, qforder=1)
( // BILINEAR part
-(
  StressK11 (u1n, u2n) * d3Aux11(u1n, u2n, varu1, varu2, w1, w2)
+ StressK12 (u1n, u2n) * d3Aux12(u1n, u2n, varu1, varu2, w1, w2)
+ StressK21 (u1n, u2n) * d3Aux21(u1n, u2n, varu1, varu2, w1, w2)
+ StressK22 (u1n, u2n) * d3Aux22(u1n, u2n, varu1, varu2, w1, w2)
)
+ TanK11 (u1n, u2n, varu1, varu2) * d4Aux11(w1, w2, u1n, u2n)
+ TanK12 (u1n, u2n, varu1, varu2) * d4Aux12(w1, w2, u1n, u2n)
+ TanK21 (u1n, u2n, varu1, varu2) * d4Aux21(w1, w2, u1n, u2n)
+ TanK22 (u1n, u2n, varu1, varu2) * d4Aux22(w1, w2, u1n, u2n)
)
+
 int2d(Th, qforder=1)
( // LINEAR part
  StressK11 (u1n, u2n) * d4Aux11(w1, w2, u1n, u2n)
+ StressK12 (u1n, u2n) * d4Aux12(w1, w2, u1n, u2n)
+ StressK21 (u1n, u2n) * d4Aux21(w1, w2, u1n, u2n)
+ StressK22 (u1n, u2n) * d4Aux22(w1, w2, u1n, u2n)
)

//  Choose one of the following two boundary conditions involving Pa:

// Load vectors normal to the boundary:
 + int1d(Th,1)( Pa * (w1*N.x + w2*N.y) )

//  Load vectors tangential to the boundary:
// + int1d(Th,1)( Pa * (w1*N.y - w2*N.x) )

   + on(2, varu1 = 0, varu2 = 0);

int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    int s = getARGV("-split", 1);
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

Mat A(Vh.ndof, intersection, D, bs = 2);
Vh<real> def(Rb)[3];
[Rb[0], RbB[0]] = [1, 0];
[Rb[1], RbB[1]] = [0, 1];
[Rb[2], RbB[2]] = [y, -x];
set(A, sparams = "-ksp_converged_reason -pc_type gamg", nearnullspace = Rb);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u1n[], inPETSc, inverse = true, exchange = true);
    real[int] out(Vh.ndof);
    out = neoHookeanInc(0, Vh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u1n[], inPETSc, inverse = true, exchange = true);
    A = neoHookeanInc(Vh, Vh, tgv = -2);
    return 0;
}
real[int] xPETSc;
[u1n, u2n] = [0.0, 0.0];
ChangeNumbering(A, u1n[], xPETSc);
SNESSolve(A, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_linesearch_monitor -snes_type newtonls -snes_converged_reason -snes_view -snes_rtol 1e-4");
ChangeNumbering(A, u1n[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, [u1n, u2n], Pk, def, real, cmm = "Global solution");
real alpha = 1.0;
mesh ThMoved = movemesh(Th, [x + alpha * u1n, y + alpha * u2n]);
u1n[] = mpirank;
macro def1(u)u// EOM
plotMPI(ThMoved, u1n, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro partitioner()metis// EOM      // metis, scotch, or parmetis
macro dimension()3// EOM            // 2D or 3D
load "Element_Mixte3d"
include "macro_ddm.idp"
include "cube.idp"

macro def(i)[i, i#y, i#z]// EOM             // vector field definition
macro init(i)[i, i, i]// EOM                // vector field initialization
macro defPart(u)u// EOM                     // partition of unity definition
macro initPart(u)u// EOM                    // partition of unity initialization
macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
func Pk = Edge03d;
func PkPart = Edge03ds0;

int Dirichlet = 1, Robin = 2;

int overlap = getARGV("-overlap", 2);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - maxwell-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int [int,int] LL = [[1,2], [3,4], [5,6]];
real[int, int] BB = [[0,1], [0,1], [0,1]];
int[int] NN = [getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10)];
int[int] CC = [1, 1, 1];
mesh3 Th = Cube(NN, BB, LL);
func k = 6 * pi;
int[int] chlab = [1, Robin, 2, Robin, 3, Robin, 4, Robin, 5, Robin, 6, Robin];
Th = change(Th, refface = chlab);

fespace Wh(Th, Pk);

mesh3 ThBorder;
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;
{
    buildOverlapEdge(Th, ThBorder, 10, s, overlap, intersection, D, Pk, mpiCommWorld, 0, PkPart, defPart, initPart)
}

matrix<complex> Mat;
matrix<complex> Opt;
complex[int] rhs(Wh.ndof);
{
    mesh3 ThAugmented = Th + ThBorder;
    ThBorder = Cube(CC, BB, LL);
    fespace WhAugmented(ThAugmented, Pk);
    varf vPb([Ex,Ey,Ez],[vx,vy,vz]) =
        int3d(ThAugmented)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
        - int3d(ThAugmented)(k^2*[vx,vy,vz]'*[Ex,Ey,Ez])
        - int2d(ThAugmented, Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
        + on(Dirichlet, Ex=0, Ey=0, Ez=0);
    Mat = vPb(WhAugmented, WhAugmented, solver=GMRES);
    func f = exp(-((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)*60);
    varf vPbRhs([Ex,Ey,Ez],[vx,vy,vz]) =
        - int3d(ThAugmented)([vx,vy,vz]'*[0,0,f])
        + on(Dirichlet, Ex=0,Ey=0,Ez=0);
    if(mpisize > 1) {
        complex[int] rhsFull(WhAugmented.ndof);
        rhsFull = vPbRhs(0, WhAugmented);
        matrix R = interpolate(Wh, WhAugmented);
        R.thresholding(1.0e-10);
        renumbering(Mat, R, rhsFull, rhs);
    }
    else
        rhs = vPbRhs(0, WhAugmented);
}

schwarz<complex> A(Mat, intersection, D, scaled = false, communicator = mpiCommWorld);
set(A, sparams = "-hpddm_schwarz_method oras");

complex[int] nEx(Wh.ndof);
nEx = 0.0;

int solver = getOption("schwarz_method");
if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
    varf vPbOpt([Ex,Ey,Ez],[vx,vy,vz]) =
        int3d(Th)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
        - int3d(Th)(k^2*[vx,vy,vz]'*[Ex,Ey,Ez])
        - int2d(Th, Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
        - int2d(Th, fakeInterface)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
        + on(Dirichlet, Ex=0, Ey=0, Ez=0);
    Opt = vPbOpt(Wh, Wh);
}
DDM(A, rhs, nEx, O = Opt);
Wh<complex> def(sol);
sol[] = nEx;
medit("Global solution", Th, [real(sol), real(soly), real(solz)]);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2// EOM
include "macro_ddm.idp"

real c = 6.25;
int N  = 80;

// domain: unit square
border aa(t=0,1) { x=t;   y=0;   };
border bb(t=0,1) { x=1;   y=t;   };
border cc(t=0,1) { x=1-t; y=1;   };
border dd(t=0,1) { x=0;   y=1-t; };

mesh M = buildmesh(aa(N)+bb(N)+cc(N)+dd(N));

load "Element_P3"
func Pk = P3;
Mat A;
macro MRefinementFactor()getARGV("-split", 1)//
MatCreate(M, A, Pk);
fespace Vh(M, Pk);
Vh u;
func BC = cos(pi*x)*cos(pi*y);
varf vInit(w, v) = on(aa, bb, cc, dd, w = BC);
varf vJ(w, v) = int2d(M)(dx(w)*dx(v) + dy(w)*dy(v) - c*exp(u)*w*v) + on(aa, bb, cc, dd, w = 0);
varf vRes(w, v) = int2d(M)(dx(u)*dx(v) + dy(u)*dy(v) - c*exp(u)*v) + on(aa, bb, cc, dd, w = u);
set(A, sparams = "-pc_type asm -sub_pc_type lu -ksp_converged_reason");
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    real[int] out(Vh.ndof);
    out = vRes(0, Vh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vJ(Vh, Vh, tgv = -2);
    return 0;
}
real[int] bPETSc;
u[] = vInit(0, Vh, tgv = -2);
ChangeNumbering(A, u[], bPETSc);
real[int] xPETSc = bPETSc;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_linesearch_monitor -snes_type newtontr -snes_converged_reason -snes_view");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
macro def(u)u//
plotMPI(M, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "function-PETSc"
int isInitialized = PetscInitialized();
assert(isInitialized == 1);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

mesh Th;
{
    real R = 5, L = 35;
    border a(t=0, 2*pi) {x=2.0+cos(t)/2; y=sin(t)/2; label=1;}
    border b(t=pi/2, 3*pi/2) {x=cos(t)*R; y=sin(t)*R; label=2;}
    border c(t=0, 1) {x=t^0.9*L; y=-R; label=3;}
    border d(t=1, 0) {x=t^0.9*L; y=R; label=3;}
    border e(t=-R, R) {x=L; y=t; label=0;}
    real ratio = 1.0;
    Th = buildmesh(a(-70*ratio) + b(30*ratio) + c(80*ratio) + d(80*ratio) + e(20*ratio));
    plot(Th);
}

macro dimension()2//
include "macro_ddm.idp"

macro def(i)[i, i#B, i#C]//
macro init(i)[i, i, i]//
func Pk = [P2, P2, P1];
macro grad(u)[dx(u), dy(u)]//
macro div(u)(dx(u#1) + dy(u#2))//
macro UgradV(u, v)[[u#1, u#2]' * [dx(v#1), dy(v#1)],
                   [u#1, u#2]' * [dx(v#2), dy(v#2)]]//
real Re = getARGV("-Re", 50.0);
real nu;
fespace Wh(Th, Pk); // complete space [u, v, p]
fespace Qh(Th, P1); // pressure space for Schur complement

Mat J;
int[int] n2o;       // need to know how to go from the local to the global mesh
mesh ThBackup = Th; // need to backup the original global mesh
macro ThN2O()n2o//
MatCreate(Th, J, Pk);
Wh [uc1, uc2, pc] = [1, 0, 0];
varf vRes([u1, u2, p], [v1, v2, q]) = int2d(Th)(
      nu * (grad(uc1)' * grad(v1) +
            grad(uc2)' * grad(v2))
    + UgradV(uc, uc)' * [v1, v2]
    - pc * div(v) - div(uc) * q)
    + on(3, u1 = uc1-1)
    + on(1, u1 = uc1-0, u2 = uc2-0)
    + on(2, u1 = uc1-1, u2 = uc2-0);
varf vJ([u1, u2, p], [v1, v2, q]) = int2d(Th)(
      (UgradV(uc, u) + UgradV(u, uc))' * [v1, v2] +
      nu * (grad(u1)' * grad(v1) +
            grad(u2)' * grad(v2))
    - p * div(v) - div(u) * q)
    + on(3, u1 = uc1-1)
    + on(1, u1 = uc1-0, u2 = uc2-0)
    + on(2, u1 = uc1-1, u2 = uc2-0);
set(J, sparams = "-pc_type lu");
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(J, uc1[], inPETSc, inverse = true, exchange = true);
    real[int] out(Wh.ndof);
    out = vRes(0, Wh, tgv = -1);
    ChangeNumbering(J, out, inPETSc);
    return inPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(J, uc1[], inPETSc, inverse = true, exchange = true);
    J = vJ(Wh, Wh, tgv = -1);
    return 0;
}
for(int i = 0; i < 50 && Re < 100.0; ++i) {
    real[int] xPETSc;
    ChangeNumbering(J, uc1[], xPETSc);
    nu = 1.0/Re;
    SNESSolve(J, funcJ, funcRes, xPETSc, sparams = "-snes_monitor ");
    ChangeNumbering(J, uc1[], xPETSc, inverse = true, exchange = true);
    if(!NoGraphicWindow) {
        Qh only = pc;
        macro def1(i)i//
        plotMPI(Th, only, P1, def1, real, cmm = "Pressure for Re = " + Re);
        fespace Zh(Th, [P2, P2]);
        Zh [onlyU, onlyV] = [uc1, uc2];
        macro def2(i)[i, i#B]//
        plotMPI(Th, [onlyU, onlyV], [P2, P2], def2, real, cmm = "Velocity for Re = " + Re);
    }
    Re *= 1.5;
    if(usedARGV("-adaptation") != -1) {
        fespace WhBackup(ThBackup, Pk);
        WhBackup def(uG), def(uReduce);
        uc1[] .*= J.D; // scale the solution by the partition of unity to avoid multiple summations on the overlap
        int[int] rest = restrict(Wh, WhBackup, n2o);
        for[i, v : rest] uReduce[][v] = uc1[][i]; // going from local to global
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            ThBackup = adaptmesh(ThBackup, def(uG));
            plot(ThBackup, wait = 1);
        }
        broadcast(processor(0), ThBackup);
        def(uG) = def(uG);
        Th = ThBackup;
        Mat Adapt;
        MatCreate(Th, Adapt, Pk) // decompose the adapted mesh
        J = Adapt; // replace the old Jacobian
        rest = restrict(Wh, WhBackup, n2o);
        [uc1, uc2, pc] = [0, 0, 0]; // just to trigger a resize
        for[i, v : rest] uc1[][i] = uG[][v]; // going from global to local
    }
}
DmeshSave(Th, "navier-stokes-2d");
ofstream sol("navier-stokes-2d_" + mpirank + "_" + mpisize + ".sol");
sol << uc1[];
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with quadratic potential (the
// Quantum Harmonic Oscillator) on a 2d domain, using SLEPc.
//
// Here, we consider the problem of a 1d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + 0.5*(x^2+y^2)* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is the set integrers :
//    E_n = n+1 (n \in N)
//  in 2d, the eigenstates are degenerate with degeneracy n+1.
//  In other words, the eigenspectrum is
//    E_0 = 1 deg(0)=1  ->  ground-state (unique)
//    E_1 = 2 deg(1)=2  ->  first excited states (two)
//    E_2 = 3 deg(1)=3  ->  second excited states (three)
//    ....
//
//   See e.g. :
//   - Complement D-VI in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-2d-harmonic-oscillator-SLEPc.edp \
//        -split 1 -npts 800 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 800) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 20.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 20.0); // Dimension of the domain
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-2d-harmonic-oscillator-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( 0.5*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
+( 0.5*(x^2+y^2)-sigma)*uh*vh)//  Bilinear form
//  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
//  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
//  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
//  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro BC(u, val)u = val// EOM       // Dirichlet boundary conditions
func Pk = P1;                       // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d-substructuring-PETSc.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
{
    int[int] l = [2, 1, 2, 2];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, 10, 1, labNeumann, s, intersection, Pk, BC, mpiCommWorld, false)
}

func f = 10;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(f * v) + on(1, u = 0.0);
matrix<real> Loc = vPb(Wh, Wh, sym = 1, tgv = -2); // local operator
real[int] rhs = vPb(0, Wh, tgv = -2);              // local right-hand side

MatIS A(Loc, intersection, interfaceNb, communicator = mpiCommWorld);
Wh<real> def(u) = 0.0;    // local solution

int[int] numbering;
GlobalNumbering(A, numbering);
cout << "GlobalNumbering  " <<  numbering.n << " " << u[].n <<  endl; 
for(int i = 0; i < u[].n; ++i)
    u[][i] = numbering[i];
OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global numbering");

set(A, sparams = "-pc_type bddc -ksp_monitor");
u[] = A^-1 * rhs;

OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "medit"
macro dimension()3L//
include "macro_ddm.idp"

real R  = 3.0, r = 1.0;
real h  = 0.1;
int nx  = R*2*pi/h;
int ny  = r*2*pi/h;
func tx = (R+r*cos(y*pi*2))*cos(x*pi*2);
func ty = (R+r*cos(y*pi*2))*sin(x*pi*2);
func tz = r*sin(y*pi*2);

meshL Th = segment(nx, [tx,ty,tz], removeduplicate=true);

Mat A;
int[int] n2o;
macro ThN2O()n2o//
MatCreate(Th,A,P1);
fespace Vh(Th,P1);

macro Grad3(uvw) [dx(uvw), dy(uvw), dz(uvw)]//

real sigma = 1;
varf aS(u,v) = int1d(Th)(Grad3(u)'*Grad3(v));
varf mS(u,v) = int1d(Th)(u*v);

matrix LocA = aS(Vh, Vh);
A = LocA;
matrix LocB = mS(Vh, Vh);
Mat B(A, LocB);
int nev = 10;
real[int] ev(nev);
Vh[int] eV(nev);

string ssparams =
  " -eps_nev " + nev       +
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   +
  " -st_type sinvert "     +
  " -st_pc_type cholesky " +
  " -eps_view"             +
  " -eps_gen_hermitian";
int k = EPSSolve(A, B, values = ev, vectors = eV, sparams = ssparams);

for(int i = 0; i < k; ++i) {
    macro params()cmm = "Eigenvector #" + i + ", eigenvalue =" + ev[i], wait = 1, fill = 1, value = 1//
    plotD(Th, eV[i], params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

macro dimension()2// EOM
include "macro_ddm.idp"

border circle(t=0, 2*pi) { x=cos(t); y=sin(t); label=1; }
mesh Th = buildmesh(circle(100));

IFMACRO(paraview)
load "hpddm"
ENDIFMACRO

real[int] D;
PartitionCreate(Th, D, P0);
fespace Ph(Th, P0);
fespace Vh(Th, P1);
fespace Wh(Th, P2);
Ph p;
p[] = D;
PartitionCreate(Th, D, P1);
Vh v;
v[] = D;
PartitionCreate(Th, D, P2);
Wh w;
w[] = D;
macro def(u)u// EOM
plotMPI(Th, p, P0, def, real, cmm = "P_0 partition of unity");
plotMPI(Th, v, P1, def, real, cmm = "P_1 partition of unity");
plotMPI(Th, w, P2, def, real, cmm = "P_2 partition of unity");
IFMACRO(paraview)
int[int] fforder = [0, 1, 1];
savevtk("PartitionCreate.vtu", Th, p, v, w, dataname = "p v w", order = fforder);
ENDIFMACRO
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
int[int] labPeriodic = [2, 4, 1, 3];
macro Pk() P2, periodic=[[labPeriodic[0],x+y], [labPeriodic[1],x+y], [labPeriodic[2],x-y], [labPeriodic[3],x-y]]// EOM

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-periodic-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

real r = 0.25;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh ThBorder, Th = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    buildOverlapPeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded, labPeriodic)
}

func f = (y+x+1) * (y+x-1) * (y-x+1) * (y-x-1);
real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    varf vPb(u, v) = int2d(ThAugmented)(grad(u)' * grad(v)) - int2d(ThAugmented)((0.39 - f) * v) + on(0, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(grad(u)' * grad(v)) + int1d(Th, fakeInterface)(transmission * (u * v));
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(grad(u)' * grad(v)) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension 3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

int s = getARGV("-split", 1);                                   // refinement factor

int[int] LL = [2,2, 1,2, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);      // global mesh
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

varf vPb(u, v) = int3d(Th)(grad(u)' * grad(v)) + int3d(Th)(v) + on(1, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

int solver = getOption("schwarz_method");
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    matrix<real> noPen = vPb(Wh, Wh, sym = 1);
    AttachCoarseOperator(mpiCommWorld, A, A = noPen);
}

Wh<real> def(u);    // local solution

u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2, P1];             // finite element space

mesh Th;
{
    mesh ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]); // global mesh
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);
varf vPb([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
real[int] rhs = vPb(0, Wh, tgv = -1);
Wh<real> def(u) = [1.0, 1.0, 2.0];
string[int] names(2);
names[0] = "velocity";
names[1] = "pressure";

A = vPb(Wh, Wh, tgv = -1);
set(A, prefix = "block_", sparams = "-block_pc_type fieldsplit -block_ksp_type fgmres -block_pc_fieldsplit_type schur -block_pc_fieldsplit_detect_saddle_point "
+ " -block_fieldsplit_velocity_pc_type lu "
+ " -block_ksp_monitor -block_ksp_view", fields = u[], names = names);
u[] = 0.0;
u[] = A^-1 * rhs;
macro def2(u)[u, u#B]// EOM
macro def1(u)u// EOM
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity with fieldsplit preconditioner");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure with fieldsplit preconditioner");
set(A, prefix = "monolithic_", sparams = "-monolithic_pc_type lu -monolithic_ksp_view -monolithic_ksp_rtol 1e-6");
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity with monolithic preconditioner");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure with monolithic preconditioner");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

include "macro_ddm.idp"
load "PETSc"

mesh Th = square(40, 40);
func Pk = P1;
fespace Vh(Th, Pk);
varf vPb(u, v) = int2d(Th)(dx(u) * dx(v) + dy(u) * dy(v)) + on(1, 2, 3, 4, u = 0.0);
DmeshCreate(Th);
Mat A;
MatCreate(Th, A, Pk);
matrix Loc = vPb(Vh, Vh, tgv = -2);
A = Loc;
mesh ThTrunc;
matrix R;
real[int] bb(4);
boundingbox(Th, bb);
fespace VhTrunc(ThTrunc, Pk);
matrix prod;
if(bb[0] < 0.5) { // careful because some subdomains may not satisfy this condition!
    int[int] n2o;
    ThTrunc = trunc(Th, x < 0.5, new2old = n2o);
    int[int] rest = restrict(VhTrunc, Vh, n2o);
    real[int] V(VhTrunc.ndof);
    V = 1;
    int[int] I = 0:VhTrunc.ndof-1;
    R = [I, rest, V];
    R.resize(VhTrunc.ndof, Vh.ndof);
    prod = Loc * R';
}
Mat B(A, restriction = R); // if the above condition is not met,
Mat C(A, B, prod);         // these two distributed matrices won't have any local unknowns
real[int] values;
Vh[int] lvec(10);
VhTrunc[int] rvec(10);
int nsv = SVDSolve(C, sparams = "-svd_largest -svd_view_values -svd_type cyclic -svd_nsv 10", values = values, lvectors = lvec, rvectors = rvec);
func real[int] prodFunc(real[int]& up) {
    real[int] u;
    ChangeNumbering(B, u, up, inverse = true, exchange = true); // from PETSc to FreeFEM numbering + need to exchange ghost values
    real[int] v = R' * u;
    u.resize(Loc.n);
    u = A * v;
    ChangeNumbering(A, u, up); // from FreeFEM to PETSc numbering
    return up;
}
func real[int] prodFuncTranspose(real[int]& utp) {
    real[int] ut;
    ChangeNumbering(A, ut, utp, inverse = true, exchange = true); // from PETSc to FreeFEM numbering + need to exchange ghost values
    real[int] v = A' * ut;
    ut.resize(R.n);
    ut = R * v;
    ChangeNumbering(B, ut, utp); // from FreeFEM to PETSc numbering
    return utp;
}
Mat MF(A, B, prodFunc, transpose = prodFuncTranspose); // defines a "rectangular" operator (I = A.size and J = B.size)
ObjectView(MF, format = "info");
real[int] valuesMF;
real[int, int] lvecMF(A.n, 10);
real[int, int] rvecMF(B.n, 10);
int nsvMF = SVDSolve(MF, sparams = "-svd_largest -svd_type cyclic -svd_nsv 10", values = valuesMF, larray = lvecMF, rarray = rvecMF);
values -= valuesMF;
assert(values.linfty < 1.0e-4 && nsv == nsvMF);

Vh u, uMF, du;
VhTrunc v, vMF, dv;
for (int idSV = 0; idSV < nsv; ++idSV)
{
  // check same (or opposite) left vectors
  ChangeNumbering(A, uMF[], lvecMF(:,idSV), inverse = true, exchange = true);
  du[] = lvec[idSV][] - uMF[];
  if(du[].linfty >= 1.0e-6) { // sign flip?
      du[] = lvec[idSV][];
      du[] *= -1.0;
      du[] -= uMF[];
  }
  assert(du[].linfty < 1.0e-4);

  // check same (or opposite) right vectors
  ChangeNumbering(B, vMF[], rvecMF(:,idSV), inverse = true, exchange = true);
  dv[] = rvec[idSV][] - vMF[];
  if(dv[].linfty >= 1.0e-6) {
      dv[] = rvec[idSV][];
      dv[] *= -1.0;
      dv[] -= vMF[];
  }
  assert(dv[].linfty < 1.0e-4);

  // check C v = sigma u
  real[int] temp1(A.n), temp2(lvecMF.n);
  MatMult(MF, rvecMF(:,idSV), temp1); // rectangular MF, so use vectors un PETSc numbering + MatMult
  temp2 = valuesMF[idSV] * lvecMF(:,idSV);
  temp2 -= temp1;
  assert(temp2.linfty < 1.0e-4);
  MatMult(MF, rvecMF(:,idSV), temp2);
  ChangeNumbering(A, temp1, temp2, inverse = true, exchange = true);
  temp2.resize(uMF[].n);
  temp2 = MF * vMF[];
  temp2 -= temp1;
  assert(temp2.linfty < 1.e-4);
}
//  run with MPI:  ff-mpirun -np 2 script.edp
// NBPROC 2

macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro def2(i)[i, i#B]// EOM
macro init2(i)[i, i]// EOM
func Pk = P1;                               // finite element space
func Zk = [P1, P2];                         // finite element space

mesh3 Th = cube(1, 1, 1);
fespace Wh(Th, Pk);            // local finite element space
fespace Qh(Th, Zk);            // local finite element space
int[int][int] intersectionP;   // local-to-neighbors renumbering
int[int][int] intersectionZ;   // local-to-neighbors renumbering
real[int] DP;                  // partition of unity
real[int] DZ;                  // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    mesh3 ThBorder;
    Th = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5));    // global mesh
    fespace Ph(Th, P0);
    real[int] part(Ph.ndof);
    if(mpirank == 0)
        partitionerSeq(part, Th, mpisize);
    partitionerPar(part, Th, mpiCommWorld, mpisize);
    buildOverlapWithPartitioning(Th, ThBorder, part, 11111, 1, 1, intersectionZ, DP, Pk, mpiCommWorld, false);
    Th = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5)); // need to reload the global mesh because it is destroyed in ''build*''
    buildOverlapEdgeWithPartitioning(Th, ThBorder, part, 22222, 1, 1, intersectionP, DZ, Zk, mpiCommWorld, false, Zk, def2, init2);
    ThBorder = cube(1, 1, 1);
}
// This codes shows how to solve an eigenvalue problems
// in different coordinate systems. The example here is
// the Laplace equation in spherical coordinates, in the
// [theta,phi] plane. Solutions are the spherical harmonics.
// the [theta,phi] plane is a 2d domain, using SLEPc.
//
// Here, we consider the problem in spherical coordinates
// \theta \in [0,\pi] and \phi \in [0,2\pi], for  a fixed
// radius: -\nabla^2 u = E u
//
//  The eigenspectrum is :
//    E_n = n(n+1)  ;  deg(n) = 2n+1
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-spherical-harmonics-SLEPc.edp \
//        -split 1 -npts 400 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels = [1,2,3,4]; // labels : bottom, right, top, left sides
int[int] labPeriodic = [Labels[0],Labels[2]];

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

macro Pk() P1, periodic=[[Labels[0],x],[Labels[2],x]]//EOM

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real radius = getARGV("-radius",1.0); // Radius of the sphere
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-spherical-harmonics-SLEPc.edp "   << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts           << endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  Radius of the sphere = " << radius           << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Thetapts = int(Npts/6.0); // pts on the x-axis sides
    int Phipts   = int(Npts/3.0); // pts on the y-axis sides

    Th = square(Thetapts,Phipts,[x*pi,2.0*pi*y],label=Labels);
    // .....
    buildPeriodic(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld, // Communicator
            labPeriodic   // Array of labels for periodic boundaries
         );
}
/***********************************************************************/
/*         Coordinate dependant differential operators                 */
/***********************************************************************/
/*        Spherical coordinates in the (theta,phi)-plane               */
/*                                                                     */
/*                  r     --> not used                                 */
/*                  theta --> x  in [0,pi]                             */
/*                  phi   --> y  in [0,2*pi]                           */
/*                                                                     */
/*           Jacobian determinant on the half-plane                    */
/*              The det(J) = r^2*sin(theta) --> r^2*sin(x)             */
/*                                                                     */
macro Jac()( radius^2*sin(x) )             // End Of Macro /*          */
     /*  The Jacobian                                                  */
/*                                                                     */
/*        The gradiant operator in spherical coordinates               */
/*                                                                     */
/*                d/dr                                                 */
/*       grad =   1/r*d/dtheta              ->  1/radius*d/dx          */
/*                1/(r*sin(theta))*d/dphi   ->                         */
/*                                   1/(radius*sin(x)*d/dy             */
/*                                                                     */
macro Grad(u) [dx(u)/radius,dy(u)/(radius*sin(x))] // End Of Macro /*  */
     /*  The Gradient operator                                         */
macro Lap(u,v) ( Grad(u)'*Grad(v)) //')      // End Of Macro /*        */
     /*  The Laplace operator                                          */
/*                                                                     */
/*                                                                     */
/***********************************************************************/
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
  (Jac*(Lap(uh,vh)))//  Bilinear form
  ;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
  ( Jac*uh*vh )           //  Bilinear form
  ;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type cholesky "       +
  " -st_matstructure same "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A − sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp[] = EigenVEC[i][];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P2;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    fespace Ph(ThAugmented, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = int2d(ThAugmented)(u * v + dt * (grad(u)' * grad(v))) + int2d(ThAugmented)(dt * f *  v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM(u, v) = int2d(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + int1d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

set(A, sparams = "-hpddm_reuse_preconditioner=1");
Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs);
    newRhs += rhs;

    if(Opt.n > 0)       // optimized Schwarz methods
        DDM(A, newRhs, u[], excluded = excluded, ret = ret, O = Opt);
    else
        u[] = A^-1 * newRhs;

    int[int] fforder = [1];
    savevtk("heat-io-2d.vtu", Th, u, order = fforder, append = i ? true : false);
}
include "getARGV.idp"
IFMACRO(with,PETSc)
load "PETSc"
ENDIFMACRO
IFMACRO(!with)
macro PetscScalar()real//
ENDIFMACRO

int sizeComm = max(1, min(mpisize, getARGV("-sizeComm", mpisize)));
int div = mpisize / sizeComm;
mpiComm commThGather(mpiCommWorld, (mpirank % div == 0 && mpirank / div < sizeComm) ? 0 : mpiUndefined, mpirank / div);
mpiComm comm(mpiCommWorld, min(mpirank / div, sizeComm - 1), mpirank - div * min(mpirank / div, sizeComm - 1));
macro ThGatherComm()commThGather//
func Pk = [P2, P2];
macro def(u)[u, u#B]//
macro init(u)[u, u]//
{
    include "macro_ddm.idp"             // additional DDM functions
    mesh Th = square(getARGV("-global_2d", 20), getARGV("-global_2d", 20)); // global mesh
    DmeshCreate(Th);
    mesh ThGather, ThScatter;
    DmeshGather(Th, comm, ThGather);
    plotDmesh(Th, cmm = "Original Dmesh");
    plotDmesh(ThGather, cmm = "Gathered Dmesh");
    DmeshScatter(ThGather, comm, ThScatter);
    plotDmesh(ThScatter, cmm = "Scattered Dmesh");
    fespace Vh(Th, Pk);
    fespace VhGather(ThGather, Pk);
    fespace VhScatter(ThScatter, Pk);
    Vh<PetscScalar> def(u);
    VhGather<PetscScalar> def(uGather);
    VhScatter<PetscScalar> def(uScatter);
    VhScatter<PetscScalar> def(uTransfer);
    def(u) = [cos(2*pi*x)*sin(pi*y), sin(2*pi*y)];
    plotD(Th, u, cmm = "Original solution");
    VecGather(Th, comm, ThGather, Pk, u, uGather);
    plotD(ThGather, uGather, cmm = "Gathered solution");
    VecScatter(ThGather, comm, ThScatter, Pk, uGather, uScatter);
    plotD(ThScatter, uScatter, cmm = "Scattered solution");
    VecInterpolate(Th, Pk, u, ThScatter, Pk, uTransfer);
    plotD(ThScatter, uTransfer, cmm = "Transferred solution");
    uTransfer[] -= uScatter[];
    real max, tmp = uTransfer[].linfty;
    mpiAllReduce(tmp, max, mpiCommWorld, mpiMAX);
    assert(max < 1.0e-6);
}
{
    macro dimension()3// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions
    mesh3 Th = cube(getARGV("-global_3d", 10), getARGV("-global_3d", 10), getARGV("-global_3d", 10)); // global mesh
    DmeshCreate(Th);
    mesh3 ThGather, ThScatter;
    DmeshGather(Th, comm, ThGather);
    plotDmesh(Th, cmm = "Original Dmesh");
    plotDmesh(ThGather, cmm = "Gathered Dmesh");
    DmeshScatter(ThGather, comm, ThScatter);
    plotDmesh(ThScatter, cmm = "Scattered Dmesh");
    fespace Vh(Th, Pk);
    fespace VhGather(ThGather, Pk);
    fespace VhScatter(ThScatter, Pk);
    Vh<PetscScalar> def(u);
    VhGather<PetscScalar> def(uGather);
    VhScatter<PetscScalar> def(uScatter);
    VhScatter<PetscScalar> def(uTransfer);
    def(u) = [cos(2*pi*x)*sin(2*pi*y), sin(2*pi*y)*cos(2*pi*z)];
    plotD(Th, u, cmm = "Original solution");
    VecGather(Th, comm, ThGather, Pk, u, uGather);
    plotD(ThGather, uGather, cmm = "Gathered solution");
    VecScatter(ThGather, comm, ThScatter, Pk, uGather, uScatter);
    plotD(ThScatter, uScatter, cmm = "Scattered solution");
    VecInterpolate(Th, Pk, u, ThScatter, Pk, uTransfer);
    plotD(ThScatter, uTransfer, cmm = "Transferred solution");
    uTransfer[] -= uScatter[];
    real max, tmp = uTransfer[].linfty;
    mpiAllReduce(tmp, max, mpiCommWorld, mpiMAX);
    assert(max < 1.0e-6);
}
load "PETSc"
include "macro_ddm.idp"

macro def2(i)[i, i#B]//
macro init2(i)[i, i]//
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]//
macro div(u)(dx(u) + dy(u#B))//

int global = getARGV("-global", 10);
int n = getARGV("-n", global);
bool sym = usedARGV("-sym") != -1;
mesh ThPressure = square(5 * global, global, [5 * x, y]); // global mesh
func Vk = P2;
func Pk = P0;

macro ThPressureRefinementFactor()getARGV("-split", 1)//
macro ThPressureOverlap()2// need two layers of overlap in each direction for the pressure
DmeshCreate(ThPressure);
Mat AUnneeded, C;
{
    macro def(i)def2(i)//
    macro init(i)init2(i)//
    MatCreate(ThPressure, AUnneeded, [Vk, Vk]); // this Mat won't be needed, we will only consider a restriction
                                                // with a single layer of overlap in each direction for the velocity
}
{
    MatCreate(ThPressure, C, Pk);
}
matrix two2one; // two layers of overlap to one layer of overlap
mesh ThVelocity; // build this mesh using ThPressure and by removing the extra layer of overlap (label = -111111)
fespace Wh(ThVelocity, [Vk, Vk]);
fespace Ph(ThPressure, Pk);
{
    fespace Qh(ThPressure, P1);
    varf vGamma(u, v) = on(-111111, u = 1.0);
    Qh gamma;
    gamma[] = vGamma(0, Qh, tgv = -1.0);
    int[int] n2o;
    if(gamma[].linfty > 1.0E-6)
        ThVelocity = trunc(ThPressure, abs(gamma) < 1.0E-2, label = -111111, new2old = n2o);
    else {
        ThVelocity = ThPressure;
        n2o.resize(ThVelocity.nt);
        n2o = 0:ThVelocity.nt - 1;
    }
    fespace WhUnneeded(ThPressure, [Vk, Vk]); // again, unneeded velocity space since this has two layers of overlap
    int[int] restriction = restrict(Wh, WhUnneeded, n2o);
    int[int] I = 0:restriction.n - 1;
    real[int] C(I.n);
    C = 1;
    two2one = [I, restriction, C];
    two2one.resize(Wh.ndof, WhUnneeded.ndof);
}
Mat A(AUnneeded, restriction = two2one); // proper Mat for the velocity with a single layer of overlap

real f = -100.0;
func nu = int(y * n) % 2 == 0 ? 0.4999 : 0.35;
func E = int(y * n) % 2 == 0 ? 1.0E+7 : 200.0E+9;
func mu = E / (2.0*(1.0 + nu));
func lambda = E*nu / ((1.0 + nu)*(1.0 - 2.0*nu));
varf vPbA(def2(u), def2(v)) = int2d(ThVelocity)(2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(ThVelocity)(f * vB) + on(4, u = 0.0, uB = 0.0);
varf vPbC([p], [q]) = int2d(ThPressure)(-1.0/lambda * p * q);
varf vPbB(def2(u), [q]) = int2d(ThPressure)(div(u) * q);

tgv = -2.0;
matrix NA;
matrix NB = vPbB(Wh, Ph);
NB.thresholding(1.0E-16);
matrix NC = vPbC(Ph, Ph);
NC.thresholding(1.0E-16);

real[int] rhs(Wh.ndof + Ph.ndof);
rhs(0:Wh.ndof - 1)                 = vPbA(0, Wh);
rhs(Wh.ndof:Wh.ndof + Ph.ndof - 1) = 0.0;
if(tgv < 0.0) {
    assert(abs(tgv + 2.0) < 1.0E-6);
    NA = vPbA(Wh, Wh, tgv = -10.0);
    NA.thresholding(1.0E-16);
    varf vPbRHS(def2(u), def2(v)) =                                                                                  on(4, u = 0.0, uB = 0.0);
    real[int] tmp = vPbRHS(0, Wh);
    real[int] rhsA = NA * tmp;
    real[int] rhsB = NB * tmp;
    rhs(0:Wh.ndof - 1) -= rhsA;
    rhs(Wh.ndof:rhs.n - 1) -= rhsB;
    varf vPbG(def2(u), def2(v)) = on(4, u = 1.0, uB = 1.0);
    rhsA = vPbG(0, Wh);
    setBC(NA, rhsA, -2.0);
    if(sym)
        symmetrizeCSR(NA);
    for [i, j, v : NB] if(abs(rhsA(j) - 1.0) < 1.0E-2) v = 0.0;
}
else {
    NA.thresholding(1.0E-16);
    NA = vPbA(Wh, Wh);
}

A = NA;
Mat B(C, A, NB);
C = NC;
Mat Elas = [[A, B'],
            [B, C ]];
set(Elas, sparams = "-pc_type none");
if(HasType("PC", "hpddm")) {
    string common = " -ksp_converged_reason -ksp_view_final_residual -ksp_monitor_true_residual -ksp_type fgmres";
    set(Elas, sparams = common + " -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self "
        + "-prefix_push fieldsplit_1_ "
        + " -ksp_type fgmres -ksp_rtol 1.0E-1 -pc_type hpddm -pc_hpddm_has_neumann -ksp_monitor -pc_hpddm_ksp_pc_side right -pc_hpddm_ksp_rtol 1.0E-1 -pc_hpddm_schur_precondition geneo "
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 10 -eps_threshold 0.5 -st_share_sub_ksp -eps_gen_non_hermitian -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky -eps_tol 1.0E-2 "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -correction balanced -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop", setup = 1);
    set(A, parent = Elas, bs = sym ? 1 : 2, sparams =
          "-prefix_push fieldsplit_0_ -pc_type hpddm -ksp_pc_side right -pc_hpddm_has_neumann -pc_hpddm_define_subdomains"
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 20 -eps_threshold 0.3 -st_share_sub_ksp -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop");
    set(C, parent = Elas);

    real[int] sol(Wh.ndof + Ph.ndof);
    sol = Elas^-1 * rhs;
    Wh def2(u);
    u[] = sol(0:Wh.ndof - 1);
    Ph p;
    p[] = sol(Wh.ndof:sol.n - 1);
    plotMPI(ThVelocity, def2(u), [Vk, Vk], def2, real, cmm = "Global velocity (overlap = 1)");
    real alpha = 1.0E4;
    mesh ThMoved = movemesh(ThVelocity, [x + alpha * u, y + alpha * uB]);
    u[] = mpirank;
    plotMPI(ThMoved, u, P2, unneeded, real, cmm = "Global moved solution");
    plotD(ThPressure, p, cmm = "Global pressure (overlap = 2)");
    p = nu;
    plotMPI(ThPressure, p, P0, unneeded, real, cmm = "Material coefficient");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

real k = getARGV("-waven", 40.0);
func f = 100 * exp(-10 * k * ((x-0.5)^2 + (y-0.5)^2));

real lambda = 2 * pi / k;

real epsilonA = 0;
real epsilonE = 0;

int Dirichlet = 1;
int Robin = -111111;

int s = getARGV("-split", 2);
int level = getARGV("-level", 2);
mesh[int] ThTab(level);
int nloc = (20.0 * k) / ((level - 1) * s * 2 * pi);
ThTab[level - 1] = square(nloc, nloc);
{
    int[int] chlab = [1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];
    ThTab[level - 1] = change(ThTab[level - 1], refe = chlab);
}
Mat<complex>[int] MG(level);
matrix[int] P(level - 1);
buildMatRecursive(ThTab, s, level, P, MG, Pk, mpiCommWorld);

complex[int] rhs;
matrix<complex>[int] Opt(level);
for(int i = 0; i < level; ++i) {
    real epsilon = (i == level - 1 ? k : 0);
    varf vPb(u, v) = int2d(ThTab[i])(-(k^2 - 1i*epsilon)*u*v + grad(u)'*grad(v))
                   + int1d(ThTab[i], Robin)(1i*k*u*v)
                   - int2d(ThTab[i])(f*v)
                   + on(Dirichlet, u = 0);
    fespace Wh(ThTab[i], Pk);
    matrix<complex> Loc = vPb(Wh, Wh, tgv = -2, sym = 1);
    Opt[i] = Loc;
    MG[i] = Loc;
    if(i == 0) {
        rhs.resize(Wh.ndof);
        rhs = vPb(0, Wh);
    }
}
set(MG, P, sparams = "-pc_type mg -ksp_monitor -ksp_view -ksp_type fgmres -ksp_gmres_restart 200 -ksp_max_it 200");
set(MG, 0, sparams = "-mg_coarse_ksp_type gmres -mg_coarse_ksp_rtol 1e-1 -mg_coarse_ksp_pc_side right -mg_coarse_ksp_gmres_restart 100 " + " -mg_coarse_ksp_max_it 100 -mg_coarse_ksp_converged_reason -mg_coarse_pc_type cholesky -mg_coarse_pc_asm_type restrict");
set(MG, level - 1, sparams = "-mg_levels_ksp_type gmres -mg_levels_ksp_max_it 1 -mg_levels_ksp_pc_side right -mg_levels_pc_type asm -mg_levels_sub_pc_type icc -mg_levels_pc_asm_type restrict");
fespace Wh(ThTab[0], Pk);
Wh<complex> u;
u[] = MG[0]^-1 * rhs;
macro def(u)u//
plotMPI(ThTab[0], real(u), Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

assert(mpisize == 1);
load "PETSc"
int n = 2;
real[int] D(n);
D = 1;
int[int][int] restriction(1);
restriction[0].resize(0);
matrix sp = D;
Mat H(sp, restriction, D);
func real J(real[int]& in) {
    return (in[0]-2.0)^2 + (in[1]-2.0)^2 - 2.0*(in[0]+in[1]);
}
func real[int] DJ(real[int]& in) {
    real[int] out(in.n);
    out[0] = 2.0*(in[0]-2.0) - 2.0;
    out[1] = 2.0*(in[1]-2.0) - 2.0;
    return out;
}
real[int] xl = [-1, -1];
real[int] xu = [ 2,  2];
int me = 1;
D.resize(1);
D = 1;
sp = D;
Mat E(sp, restriction, D);
real[int, int] full(1, 2);
full = 1;
sp = full;
Mat JE(E, H, sp);
func real[int] funcE(real[int]& in) {
    real[int] out(me);
    out[0] = in[0]^2 + in[1] - 2.0;
    return out;
}
func int funcJE(real[int]& in) {
    real[int, int] full(me, in.n);
    full(0, 0) = 2 * in[0];
    full(0, 1) = 1;
    matrix sp = full;
    JE = sp;
    return 0;
}
string solver;
if(!HasType("MATSOLVER", "mumps") && !HasType("MATSOLVER", "superlu"))
    exit(0);
else
    solver = (HasType("MATSOLVER", "mumps") ? "mumps" : "superlu");
{
    func int funcH(real[int]& in) {
        real[int] diag(n);
        diag = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    for(int i = 0; i < 2; ++i) {
        real[int] x = [0, 0];
        if(i == 0)
            TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type bqnls -pc_type lu -pc_factor_mat_solver_type " + solver);
        else
            TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type bnls -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcH);
        cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << endl;
    }
}
{
    func int funcH(real[int]& in, real[int]& DE) {
        real[int] diag(n);
        diag[0] = 2 * (1+DE[0]);
        diag[1] = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    real[int] x = [0, 0];
    TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type ipm -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcH, EqualityConstraints = funcE, JacobianEquality = funcJE, JE = JE);
    cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << ", E(x) = " << funcE(x)[0] << " (= 0)" << endl;
}
{
    int mi = 2;
    D.resize(mi);
    D = 1;
    full.resize(mi, mi);
    full = 1;
    sp = full;
    Mat I(sp, restriction, D);
    Mat JI(I, H, sp);
    func int funcHnoE(real[int]& in, real[int]& DI) {
        real[int] diag(n);
        diag[0] = 2 * (1+DI[0]-DI[1]);
        diag[1] = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    func int funcH(real[int]& in, real[int]& DE, real[int]& DI) {
        real[int] diag(n);
        diag[0] = 2 * (1+DE[0]+DI[0]-DI[1]);
        diag[1] = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    func real[int] funcI(real[int]& in) {
        real[int] out(mi);
        out[0] = in[0]^2 - in[1];
        out[1] = -in[0]^2 + in[1] + 1.0;
        return out;
    }
    func int funcJI(real[int]& in) {
        real[int, int] full(mi, in.n);
        full(0, 0) = 2 * in[0];
        full(0, 1) = -1;
        full(1, 0) = -2 * in[0];
        full(1, 1) = 1;
        matrix sp = full;
        JI = sp;
        return 0;
    }
    real[int] x = [0, 0];
    TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type ipm -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcHnoE, InequalityConstraints = funcI, JacobianInequality = funcJI, JI = JI);
    cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << ", I(x) = [" << funcI(x)[0] << ", " << funcI(x)[0] << "] (>= [0, 0])" << endl;
    x = [0, 0];
    TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type ipm -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcH, EqualityConstraints = funcE, JacobianEquality = funcJE, JE = JE, InequalityConstraints = funcI, JacobianInequality = funcJI, JI = JI);
    cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << ", E(x) = " << funcE(x)[0] << " (= 0), I(x) = [" << funcI(x)[0] << ", " << funcI(x)[0] << "] (>= [0, 0])" << endl;
}
---
name: potential
category:fluid mechanics
layout: example
---
## Potential flow around an airfoil with thermal effects.

Potential flow is
$$
\nabla\times\vec u=0,~~\nabla\cdot \vec u=0~~,i.e.~~\vec u=\nabla\times\psi,~~\Delta\psi=0.
$$
The flow is tangent to the airfoil, so $~~\vec u\cdot n=0,~i.e.~~\psi=a$ constant.
At infinity the flow is given: $\phi=y\cos\alpha-x\sin\alpha$ where $\alpha$ is the angle of incidence.  
The airfoil is a NACA0012 given as a function $x\to \pm y(x)$.
~~~freefem
real S = 99;

border C(t=0, 2*pi){x=3*cos(t); y=3*sin(t);} // Label 1,2 
border Splus(t=0, 1){x=t-0.5; y=0.17735*sqrt(t) - 0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4); label=S;}
border Sminus(t=1, 0){x=t-0.5; y=-(0.17735*sqrt(t) - 0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4)); label=S;}
mesh Th = buildmesh(C(50) + Splus(70) + Sminus(70));
// Fespace
fespace Vh(Th, P2);
~~~
Joukowski tells us that the pressure $p=-\frac12|\vec u|^2$ is continuous at the trailing edege P. As $\vec u\cdot\vec n|_P=0$, it implies that the tangent velocity is continuous: the jump from the lower side to the upper side at P is zero: $[\vec u\cdot\vec s]|_P=0$.  The trick is to define
$$
\begin{align*}&
\Delta\psi^0=0,~~ \psi^0|_C=0,~~\psi^0|_\infty=y\cos\alpha-x\sin\alpha
\cr&
\Delta\psi^1=0,~~ \psi^1|_C=1,~~\psi^1|_\infty=0
\end{align*}
$$
and search by superposition for $\psi=\psi_0+\beta\psi_1$ and adjust $\beta$ to satisfy the Joukowsky condition.
See https://doc.freefem.org/models/static-problems.html#aerodynamics

Here we assume that $\beta$ is given and we concentral on thermal effects.

Let $\Omega$ be a the bounded open set of $R^2$ approximating $\infty$ by a circle and having the airfoil near the center of the circle.  Consider the variational formulations to apply the finite element method
$$
\int_\Omega\nabla\psi\nabla\hat\psi =0~~\forall \hat\psi\in  H^1_0(\Omega);~~\psi-\psi_\Gamma^i\in H^1_0(\Omega).
$$
~~~freefem
Vh psi, w;
real cost = cos(5.*pi/180.), sint=sin(5.*pi/180.);// incidence 5 degres
// Problem
solve potential(psi, w)
  = int2d(Th)(dx(psi)*dx(w)+dy(psi)*dy(w))
  + on(C, psi = cost*y-sint*x) 
  + on(S, psi=0);

plot(psi, wait=1);
~~~
For the temperature equation we work with a different mesh on because the temperature varies also inside the airfoil.
~~~freefem
border D(t=0, 2.){x=0.5+t*cost; y=+t*sint;}
mesh Sh = buildmesh(C(25) + Splus(-90) + Sminus(-90) + D(200));
int steel = Sh(0.5, 0).region, air = Sh(-1, 0).region;
// Change label to put BC on In flow 
fespace Wh(Sh, P1);
Wh  vv;

fespace W0(Sh, P0);
W0 k = 0.01*(region == air) + 0.1*(region == steel);
W0 u1 = dy(psi)*(region == air), u2 = -dx(psi)*(region == air);
Wh v = 120*(region == steel), vold;
// pul label 10 on inflow boundary to inforce the temperature.
Sh = change(Sh,flabel = (label == C &&  [u1,u2]'*N<0) ? 10 : label);
~~~
The time dependent heat equation is solved by an implicit Euler time scheme.
$$
\frac1{dt} v -\nabla\cdot(k\nabla v) + a(u_1\partial_x v + u_2\partial_y v) =\frac1{dt} v_{old}
$$
where $[u_1,u_2]^T=\nabla\times\psi$.
~~~freefem
int i;
real dt = 0.005, nbT = 50;
problem thermic(v, vv, init=i, solver=LU)
  = int2d(Sh)(
      v*vv/dt + k*(dx(v)*dx(vv) + dy(v)*dy(vv))
    + 10*(u1*dx(v) + u2*dy(v))*vv
  )
  - int2d(Sh)(vold*vv/dt)
  + on(10, v= 0);
  

for(i = 0; i < nbT; i++) {
    vold[]= v[];
    thermic;
    plot(v);
}
plot(v, wait=1,fill=1,value=1);
~~~
---
name: thermal
category: thermodynamics
layout: example
---

# The time dependent nonlinear heat equation

The time dependent heat equation  with a discontinuous thermal diffusion and nonlinear dissipation is integrated in a rectangle:
~~~freefem
mesh Th = square(30, 5, [6*x, y]);
~~~
$$
\partial_t u - \nabla\cdot(k\nabla u)=0, ~~u|_{\Gamma_1}=u_\Gamma,~~k\frac{\partial u}{\partial n}|_{\Gamma_2}+b(u)(u-u_e)=0,~~u_{t=0}=u_0.
$$
In this example $k=1.8~{\bf 1}_{y<0.5}+0.2$ where ${\bf 1}_x$ is the Heaviside function.  The time varies from 0 to 5. Finally $u_e=20$.  The function $b$ corresponds to the linearization of a $T^4$ law.
~~~freefem
func u0 = 10+90*x/6;
func k = 1.8*(y<0.5) + 0.2;
real ue = 25, alpha = 0.25, T = 5, dt = 0.1;
real rad = 1e-8, uek = ue + 273.;

// Fespace
fespace Vh(Th,P1);
Vh vold, w, v=u0-ue, b;

problem thermradia(v, w)
  = int2d(Th)(
      v*w/dt
    + k*(dx(v)*dx(w) + dy(v)*dy(w))
  )
  + int1d(Th, 1, 3)(b*v*w)
  - int2d(Th)(vold*w/dt)
  + on(2, 4, v=u0-ue);
~~~
An implicit Euler scheme is used to integrate the equation in time with time step 0.1. A loop is used for the nonlinearity.
~~~freefem
for(real t = 0; t < T; t+=dt) {
  vold = v;
  for (int m = 0; m < 5; m++) {
    b = alpha + rad*(v + 2*uek)*((v+uek)^2 + uek^2);
    thermradia;
  }
}
vold = v + ue;

// Plot
plot(vold);
~~~

| The temperature   |
| ----------------- |
| ![][_solution]    |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/thermic/solution.png
---
name: NSprojection
category: Fluid Mechanics
layout: example
---

## Time dependent incompressible Navier-Stokes Equations solved with Newton's method

The Navier-Stokes equations are solved for a flow over a backward facing step.
The time independent Navier-Stokes equations for an incompressible fluid are
$$
\frac{\partial u}{\partial t}-\nu\Delta u +u\cdot\nabla u -\nabla p =0,~~~\nabla\cdot u=0~~~in ~ \Omega
$$

The velocity is specified on the left vertical side of the pipe (inlet) and free on the vertical side on the right (outlet). There is a noslip condition on the lateral walls.
The geometry is as follows. Note the trick $t^{1.2}$ to refine the mesh near the corner of the step.
~~~freefem
verbosity=0;
int n = 1;

// Mesh
border a0(t=1, 0){x=-2; y=t; label=1;} // inlet
border a1(t=-2, 0){x=t; y=0; label=2;}
border a2(t=0, -0.5){x=0; y=t; label=2;}
border a3(t=0, 1){x=18*t^1.2; y=-0.5; label=2;}
border a4(t=-0.5, 1){x=18; y=t; label=3;} // outlet
border a5(t=1, 0){x=-2+20*t; y=1; label=4;}

mesh Th = buildmesh(a0(3*n) + a1(20*n) + a2(10*n) + a3(150*n) + a4(5*n) + a5(100*n));
plot(Th);

// Fespace
fespace Vh(Th, P1);
Vh w, u = 0, v = 0, p = 0, q = 0;

real nu = 0.0025; // Reynolds=200
real dt = 0.2;
real epsv = 1e-6, epsu = 1e-6, epsp = 1e-6;
~~~

| The mesh   |
| ---------- |
| ![][_mesh] |

The matrices dtMx and dtMy are used to project $[u,v]^T$ on the space of divergence free functions
~~~freefem
matrix dtM1x, dtM1y;

macro  BuildMat()
  { /* for memory managenemt */
    varf vM(unused, v) = int2d(Th)(v) ;
    varf vdx(u, v) = int2d(Th)(v*dx(u)*dt) ;
    varf vdy(u, v) = int2d(Th)(v*dy(u)*dt) ;

    real[int] Mlump = vM(0, Vh);
    real[int] one(Vh.ndof); one = 1;
    real[int] M1 = one ./ Mlump;
    matrix dM1 = M1;
    matrix Mdx = vdx(Vh, Vh);
    matrix Mdy = vdy(Vh, Vh);
    dtM1x = dM1*Mdx;
    dtM1y = dM1*Mdy;
  }// end of macro
BuildMat
~~~
In the follwing time loop, ${\bf u}=[u,v]^T$ are computed at every time steps by using the method of characteristics implemented in the operator $\texttt{convect}$:
$$
\partial_t{\bf u}+{\bf u}\cdot\nabla{\bf u}|_{x,t}\approx \frac1{\delta t}[{\bf u}(x,t)-{\bf u}(x-{\bf u}(x,t-\delta t)\delta t,t-\delta t)]
$$
~~~freefem
real err = 1, outflux = 1;
for(int n = 0; n < 200; n++) {
  Vh uold = u, vold = v, pold = p;

  solve pb4u(u, w, init=n, solver=CG, eps=epsu)
    = int2d(Th)(
      u*w/dt + nu*(dx(u)*dx(w) + dy(u)*dy(w))
    )
    - int2d(Th)(
      (convect([uold, vold], -dt, uold)/dt - dx(p))*w
    )
    + on(1, u=4*y*(1-y))
    + on(2, 4, u=0);
  plot(u);

  solve pb4v(v, w, init=n, solver=CG, eps=epsv)
    = int2d(Th)(
      v*w/dt + nu*(dx(v)*dx(w) + dy(v)*dy(w))
    )
    - int2d(Th)(
      (convect([uold, vold], -dt, vold)/dt - dy(p))*w
    )
    + on(1, 2, 3, 4, v=0);

  solve pb4p(q, w, solver=CG, init=n, eps=epsp)
    = int2d(Th)(dx(q)*dx(w) + dy(q)*dy(w))
    - int2d(Th)((dx(u) + dy(v))*w/dt)
    + on(3, q=0);

  // to have absolute epsilon in CG algorithm.
  epsv = -abs(epsv);
  epsu = -abs(epsu);
  epsp = -abs(epsp);
~~~
And then ${\bf u}$ is projected with $q$ by $M$ , i.e. ${\bf u}+M(\nabla q)\delta t$ is divergence free.
~~~freefem
p = pold-q;
u[] += dtM1x*q[];
v[] += dtM1y*q[];
~~~
For better precosion the mesh is adapted to the flow
~~~freefem
if(n%50 == 49) {
    Th = adaptmesh(Th, [u, v], q, err=0.06, nbvx=100000);
    plot(Th, wait=true);
    BuildMat // rebuild mat.
}
~~~
The stopping criteria to exit the loop:
~~~freefem
err = sqrt(int2d(Th)(square(u - uold) + square(v - vold))/Th.area);
  outflux = int1d(Th)([u, v]'*[N.x, N.y]) ;
  cout << " iter " << n << " Err L2 = " << err << " - Outflow = " << outflux << endl;
  if (err < 1e-3) break;
}
assert(abs(outflux) < 5e-3); // verification
plot(p, wait=1, ps="NSprojP.ps");
plot(u, wait=1, ps="NSprojU.ps");
~~~

| The u-component of the velocity |
| ------------------------------- |
| ![][_u]                         |

| The pressure |
| ------------ |
| ![][_p]      |

[_mesh]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/NSprojection/mesh.png

[_u]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/NSprojection/u.png

[_p]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/NSprojection/p.png
---
name: dist-projection
category: Tools
layout: example
---

# Test the function "dist"
## and the projection on a curve built with meshL
The function $\texttt{dis(C)}$ returns the distance from the current point to $C$. Let us build a triangulation of a curve (here a cercle)  $C$, i.e. cut the circle into 20 segments.
~~~freefem
load "msh3"
border C(t=0,2*pi){ x= cos(t); y=sin(t); label=1; region =1;}
meshL Lh =buildmeshL(C(20));
~~~
Let us build a finite element space of $P^1$ functions on a square centered at (0,0) of size 3$\times$3.
~~~freefem
mesh Th= square(20,20,[(x-0.5)*3,(y-0.5)*3]);
fespace Vh(Th,P1);
Vh d=dist(Lh);
~~~
The last line defines a $P^1$ function on the square which is equal to the distance to $C$ of any point in the square Th.
Next, $U=[U_x,U_y]^T$ is the vector which starts from $P=[x,y]^T$ and ends at the projection of $P$ on $C$.
~~~freefem
Vh Ux = projection(Lh).x-x;
Vh Uy = projection(Lh).y-y;
plot(d, [Ux,Uy],Lh, wait=1);
~~~
The plot displays the level curves of $d$ in 3D and $U$.
![][_Ud]
Now the same is done with another triangulation of a square, Th2. Parameters nu containes the triangle number of the projection and ph the projection point. So Th2[nu][0] is the first vertex of triangle nu.
~~~freefem
int nu;
R3 ph;
mesh Th2= square(10,10,[(x-0.5)*3,(y-1.06)*3]);
Ux = projection(Th2,nu=nu,Phat=ph).x-x;
Uy = projection(Th2,nu=nu,Phat=ph).y-y;
x=0;y=0;z=0;
 cout << projection(Th2,nu=nu,Phat=ph) <<", " << nu <<","<< ph << endl; 
 cout << Th2[nu][0].x << endl;
 cout << Th2[nu][0].y  << endl;
 cout << Th2[nu][1].x << endl;
 cout << Th2[nu][1].y  << endl;
 cout << Th2[nu][2].x << endl;
 cout << Th2[nu][2].y  << endl;
plot([Ux,Uy],Th2, wait=1);
~~~

| The function d to Th2 |
| --------------------- |
| ![][_plot2]           |

Finally some more advanced operations are done in 3D: signeddist(ThS) is the distance from points in the cube to the square ThS.
~~~freefem
load "msh3";
//meshL Lh2 = extract(Th2);
meshS ThS= square3(10,10,[(x-0.5)*3,(y-1.06)*3,(x+y)/2]);
mesh3 Th3=cube(10,10,10,[(x-0.5)*3,(y-1.06)*3,z*2-1]);
fespace Uh(Th3,P1);
Uh d3=signeddist(ThS);
plot(d3,wait=1);
~~~

| The signeddist function |
| ----------------------- |
| ![][_plot3]             |

[_Ud]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/dist-projection/Ud.png

[_plot2]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/dist-projection/plot2.png

[_plot3]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/dist-projection/plot3.png
---
name: BlackScholes2D
category: finance
layout: example
---

# The Black-Scholes equation for financial derivatives

In the documentation,
https://doc.freefem.org/models/evolution-problems.html#d-black-scholes-equation-for-an-european-put-option

the following modeling equation for an European Put $u$ is to be integrated in  $( 0 , T ) \times R^+ \times R$:
$$
\left\{
\begin{align*}&
\partial_t u + \frac{(\sigma_1 x)^2}2\frac{\partial^2 u}{\partial x^2} + \frac{(\sigma_2 y)^2}2\frac{\partial^2 u}{ \partial y^ 2} + \sigma_1\sigma_2 x y \frac{\partial^2 u}{\partial x \partial y} + r x \frac{\partial u}{\partial x} + r y \frac{\partial u}{ \partial y} +r u = 0 ,
\cr&
u ( x , y , T ) = ( K - \max ( x , y ) )^+
\end{align*}
\right.
$$
The 2 underlying asset (e.g. Renault and Peugeot shares) are valued at $x$ and $y$.

The interest rate is $r$, the volatilities are $\sigma_1,\sigma_2$, the correlation is $\rho$. $K$ is the strike price.
For example,
~~~freefem
real sigma1 = 0.3;
real sigma2 = 0.3;
real rho = 0.3;
real r = 0.05;
real K = 40;
~~~
Notice that the problem is backward in time because final conditions are given and the signs of the differential operator is positive.  We will change $t$ to $T-t$ to work forward in tome.

As usual we must work on the variational formulation: find $u\in V:=  L^2(0,T,H^1(\Omega))$ such that
$$
\begin{aligned}&
\int_\Omega\left\{\left(\partial_t u + r u+ ( -x r + x\sigma_1^2 + \frac12 x\rho\sigma_1\sigma_2)\partial_x u +(-y r + y\sigma_2^2 + \frac12 y\rho\sigma_1\sigma_2)\partial_y u\right) v
\right.\cr&\left. + \frac{(\sigma_1 x)^2}2\partial_x u\partial_x v + \frac{(\sigma_2 y)^2}2{\partial_y u}{\partial_y v} + \frac{ρ}2\sigma_1\sigma_2 x y[ {\partial_x u}{\partial_y v}  +{\partial_y u}{\partial_x v}]\right\} = 0\quad \forall v\in V,
\cr&
u ( x , y , 0) = ( K − \max ( x , y ) )^+
\end{aligned}
$$
Boundary conditions  are not needed at $x=0$ and $y=0$ because the differential operator degenerates. At infinity there are implicit Neumann conditions.  In practice the problem must be localized, so $R^+\times R^+$ is replaced by $(0,L)\times(0,LL)$. Hence the mesh and the FEM space are  built as follows:
~~~freefem
int m = 30;
int L = 80;
int LL = 80;
int j = 100;
mesh th = square(m, m, [L*x, LL*y]);
// Fespace
fespace Vh(th, P1);
Vh u = max(K - max(x, y), 0.);
Vh xveloc, yveloc, v, uold;
~~~
An implicit in time Euler scheme is used, but in addition for stability and avoiding upwinding, we use the method of characteristics:
$$
\begin{aligned}&
\partial_t u + r u+ ( -x r + x\sigma_1^2 + \frac12 x\rho\sigma_1\sigma_2)\partial_x u +(-y r + y\sigma_2^2 + \frac12 y\rho\sigma_1\sigma_2)\partial_y u
\cr&
\approx
\frac{1}{\delta t}(u^{n+1}-u^n(x-U\delta t,y-V\delta t) ) \text{ where }
\cr&
U=-x r + x\sigma_1^2 + \frac12 x\rho\sigma_1\sigma_2,
\quad
V=-y r + y\sigma_2^2 + \frac12 y\rho\sigma_1\sigma_2.
\end{aligned}
$$
So the implementation is
~~~freefem
real dt = 0.01;
for (int n = 0; n*dt <= 1.0; n++) {
    xveloc = -x*r + x*sigma1^2 + x*rho*sigma1*sigma2/2;
    yveloc = -y*r + y*sigma2^2 + y*rho*sigma1*sigma2/2;
    // Update
    uold = u;
    // Solve
    solve eq1(u, v, init=j, solver=LU)
        = int2d(th)(
              u*v*(r + 1/dt)
            + dx(u)*dx(v)*(x*sigma1)^2/2
            + dy(u)*dy(v)*(y*sigma2)^2/2
            + dy(u)*dx(v)*rho*sigma1*sigma2*x*y/2
            + dx(u)*dy(v)*rho*sigma1*sigma2*x*y/2
        )
        + int2d(th)(
            - v*convect([xveloc, yveloc], dt, uold)/dt
        )
        + on(2,3,u=0)
        ;
}
~~~
Notice the parameters in solve to indicate that the factorized matrix can be reused.  With the default solver of FreeFem this is no longer much of an optimization.
Visualization is as usual
~~~freefem
plot(u, fill=true, wait=true, value=true);
~~~
One could add mesh adaptation by inserting above the line

// update

the following:
~~~freefem
   // Mesh adaptation
    j = j + 1;
    if (j > 20) {
        th = adaptmesh(th, u, verbosity=1, abserror=1, nbjacoby=2,
        err=0.001, nbvx=5000, omega=1.8, ratio=1.8, nbsmooth=3,
        splitpbedge=1, maxsubdiv=5, rescaling=1) ;
        j = 0;
        u = u;
        plot(th, wait=true);
    }
~~~

## Results
| The price of the Put |
| -------------------- |
| ![][_solution]       |

| Mesh adapted to the solution |
| ---------------------------- |
| ![][_adaptedmesh]            |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/BlackScholes2D/solution.png
[_adaptedmesh]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/BlackScholes2D/adaptedmesh.png
---
name: schwarz
category: mathematics
layout: example
---

## Domain Decomposition Method: solution by Schwarz iterations
The Laplace equation is solved in a domain which is the union of a circle and a rectangle.
~~~freefem
real n = 4; // Mesh quality

// Mesh
border a(t=0, 1){x=t; y=0;}
border a1(t=1, 2){x=t; y=0;}
border b(t=0, 1){x=2; y=t;}
border c(t=2, 0){x=t; y=1;}
border d(t=1, 0){x=0; y=t;}
border e(t=0, pi/2){x=cos(t); y=sin(t);}
border e1(t=pi/2, 2*pi){x=cos(t); y=sin(t);}

//Omega1 (rectangle)
mesh th = buildmesh(a(5*n) + a1(5*n) + b(5*n) + c(10*n) + d(5*n));
fespace Vh(th, P1);
Vh v, u=0;

//Omega2 (circle)
mesh TH = buildmesh(e(5*n) + e1(25*n));
fespace VH(TH,P1);
VH V, U=0;
~~~
The Schwarz algorithm solves iteratively and alternatively on the circle and the rectangle. The trace on the rectangle of the solution on the circle becomes the boundary conditon for thee problem on the rectangle and ssimilarly for the circle.
~~~freefem
for (int i = 0; i < 4; i++) {
  plot(U, u, wait=1, cmm="Iteration "+i);
  // Solve on Omega2
  solve AA(U, V)
    = int2d(TH)(dx(U)*dx(V) + dy(U)*dy(V))
    - int2d(TH)(V)
    + on(e, U=u)
    + on(e1, U=0);

  // Solve on Omega1
  solve aa(u, v)
    = int2d(th)(dx(u)*dx(v) + dy(u)*dy(v))
    - int2d(th)(v)
    + on(a, d, u=U)
    + on(a1, b, c, u=0);
}

plot(U, u, wait=1, cmm="Final solution");
~~~

| The solution at iteration 1 |
| --------------------------- |
| ![][_solone]                |

| The solution at iteration 4 |
| --------------------------- |
| ![][_solfour]               |

[_solone]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/schwarz/solone.png

[_solfour]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/schwarz/solfour.png
---
name: Stokes_composite
category: fluid
layout: example
---

# The Stokes system for creeping flow solved with composite FE
The system is set in 2 dimensions:
$$
-\Delta u + \nabla p =\vec f, \quad
 \nabla\cdot u = 0   \hbox{ in }\Omega ,~~
 u _{|\Gamma}= \vec g
 $$
with $\Omega$ the  square $(0,2\pi)\times(0,2\pi)$, $\vec f=[0,-4\cos x\sin y]^T$ and $\vec g=[\sin x\cos y,-\cos x \sin y]^T$.

A possible variational formulation is
$$∀(v,q),~~∫_Ω ∇u:∇v−∫_Ωp\nabla\cdot v=∫_Ωf\cdot v,
−∫_Ω\nabla\cdot u q−∫_Ωϵpq=0.
$$
~~~freefem
macro grad(u) [dx(u),dy(u)]//
macro Grad(u1,u2) [ grad(u1), grad(u2)]//
macro div(u1,u2) (dx(u1)+dy(u2))//

// definition of the boundary condition 
func g1 = sin(x)*cos(y);
func g2 = -cos(x)*sin(y);

// defintion of the right hand side
func f1 = 0;
func f2 = -4*cos(x)*sin(y);

int nn = 30; // number of edge in each direction
mesh Th=square(nn,nn,[2*pi*x,2*pi*y],flags=3);
mesh ThP=Th;                    // Pressure mesh
mesh ThU=trunc(ThP,1,split=2);  // Velocity mesh

fespace Uh(ThU,[P1,P1]);
fespace Ph(ThP,P1);
~~~
While it is unecessary to use flags=3, it does the following:
it will produce a mesh where all quads are split with diagonal $x-y=$ constant and forbids of a 3 vertices on the boundary at corners.

Using different meshes for the velocity and pressure is also not necessary but it is given to illustrate composite elements as explained in the documentation here

https://doc.freefem.org/documentation/composite.html

The solver is standard.  The penalization of $pq$ is needed to avoid the singularity of the system because in Stokes' equations, pressure is defined up to a constant.
~~~freefem
Uh [u1,u2],[v1,v2];
Ph p,q;

solve Stokes ( <[u1,u2],[p]>, <[v1,v2],[q]>) = int2d(ThU)( (Grad(u1,u2):Grad(v1,v2)) )
+ int2d(ThU)( - div(u1,u2)*q - div(v1,v2)*p )
+ int2d(ThP)( -1e-10*p*q )
- int2d(ThU) ( [f1,f2]'*[v1,v2] )
+ on(1,2,3,4,u1=g1,u2=g2);

plot( u1, cmm="u1" );
plot( u2, cmm="u2" );
plot( p,  cmm="p" );
~~~
## Results

| Isovalue lines of the pressure |
| ------------------------------ |
| ![][_solution]                 |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/stokes_composite/solution.png
---
name: NSNewton
category: Fluid Mechanics
layout: example
---

## Stationary incompressible Navier-Stokes Equation solved with Newton's method
The time independent Navier-Stokes equations for an incompressible fluid are
$$
-\nu\Delta u +u\cdot\nabla u -\nabla p =0,~~~\nabla\cdot u=0~~~in ~ \Omega
$$
We are interested by the flow around a cylinder in an infinite fluid (approximated by a rectangle with a round side on the left and a circle in the center).
Dirichlet boundary conditons are imposed on boundaries 2 (the cylinder)  and 1, the left  (inflow) and lateral sides (tangent flow)  of the rectangle.

Here $\Omega$ is a cylinder.
~~~freefem
verbosity=0; //To minimize messages at execution

real R = 5, L = 15;

// Mesh
border cc(t=0, 2*pi) {x=cos(t)/2; y=sin(t)/2; label=2;}
border ce(t=pi/2, 3*pi/2) {x=cos(t)*R; y=sin(t)*R; label=1;}
border beb(tt=0, 1) {real t=tt^1.2; x=t*L; y=-R; label=1;}
border beu(tt=1, 0) {real t=tt^1.2; x=t*L; y=R; label=1;}
border beo(t=-R, R) {x=L; y=t; label=0;}
border bei(t=-R/4, R/4) {x=L/2; y=t; label=0;}
mesh Th = buildmesh(cc(-40) + ce(20) + beb(15) + beu(15) + beo(8) + bei(10));
plot(Th);
~~~

| The mesh   |
| ---------- |
| ![][_mesh] |

To resolve the nonlinearity we use a linearization
$$
\begin{align*}
-\nu\Delta (u+du) +u\cdot\nabla(u+du)+du\cdot\nabla v-\nabla q =0,
\\
\nabla\cdot (u+du)=0~~~in ~ \Omega
\end{align*}
$$
This, then, is the Newton method:  given $u=u^n$ compute $du,dq$ then set $u^{n+1}=u+du$
In variational form: find $du_1,du_2,dq$,
$$\begin{align*}
\int_{\Omega}\left(\nu\nabla du:\nabla v + (u\cdot\nabla du + du\cdot\nabla u +\nabla dq )v+\epsilon dq\cdot r\right))=0,~~\forall v, r
\end{align*}
$$
For stability the iterations are started with a large $\nu$ and then $\nu$ is decreased up to its desired value.
~~~freefem
real nu = 1./50, nufinal = 1/200., cnu = 0.5;
macro Grad(u1, u2) [dx(u1), dy(u1), dx(u2), dy(u2)]//
macro UgradV(u1, u2, v1, v2) [[u1, u2]'*[dx(v1), dy(v1)], [u1, u2]'*[dx(v2), dy(v2)] ]//
macro div(u1, u2)  (dx(u1) + dy(u2))//

fespace Xh(Th, P2);
Xh u1, u2, v1, v2, du1, du2, u1p, u2p;
fespace Mh(Th, P1);
Mh p, q, dp, pp;

// Intial guess with B.C.
u1 = (x^2+y^2) > 2;
u2 = 0;

// numerical parameters
real eps = 1e-4;

func bb = [[-1, -2], [4, 2]]; // bounding box for the plot

// Loop on vicosity
while(1) {
	int n;
	real err = 0;
	// Newton Loop
	for (n = 0; n < 15; n++) {
		solve Oseen([du1, du2, dp], [v1, v2, q])
			= int2d(Th)(
					nu*(Grad(du1,du2)'*Grad(v1,v2))
				+ UgradV(du1,du2, u1, u2)'*[v1,v2]
				+ UgradV( u1, u2,du1,du2)'*[v1,v2]
				- div(du1,du2)*q - div(v1,v2)*dp
				- 1e-8*dp*q // stabilization term
			)
			- int2d(Th)(
				  nu*(Grad(u1,u2)'*Grad(v1,v2))
				+ UgradV(u1,u2, u1, u2)'*[v1,v2]
				- div(u1,u2)*q - div(v1,v2)*p
				- 1e-8*p*q
			)
			+ on(1,2,du1=0,du2=0)
			;

		u1[] -= du1[];
		u2[] -= du2[];
		p[] -= dp[];

		real Lu1 = u1[].linfty, Lu2 = u2[].linfty, Lp = p[].linfty;
		err = du1[].linfty/Lu1 + du2[].linfty/Lu2 + dp[].linfty/Lp;

		cout << n << " err = " << err << " " << eps << " rey  = " << 1./nu << endl;
		if(err < eps) break; // converge
		if( n > 3 && err > 10.) break; // Blowup ?
	}
	if(err < eps) {// if converge  decrease nu (more difficult)
		plot([u1, u2], p, wait=1, cmm=" rey = " + 1./nu, coef=0.3, bb=bb);
		if(nu == nufinal) break;
		if(n < 4) cnu = cnu^1.5; // fast converge => change faster
		nu = max(nufinal, nu*cnu); // new vicosity
		u1p = u1;
		u2p = u2;
		pp = p; // save correct solution
	}
	else {  // if blowup, increase nu (more simple)
		assert(cnu < 0.95); // final blowup
		nu = nu/cnu; //  get previous value of viscosity
		cnu = cnu^(1./1.5); // no conv. => change lower
		nu = nu* cnu;  // new vicosity
		cout << " restart nu = " << nu << " Rey = " << 1./nu << "  (cnu = " << cnu << " ) \n";
		// restore correct solution
		u1 = u1p;
		u2 = u2p;
		p = pp;
	}
}
cout << " CPU "<< clock()<< " s " << endl;
~~~
| The solution   |
| -------------- |
| ![][_solution] |

[_mesh]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/NSNewton/mesh.png

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/NSNewton/solution.png
---
name: Muwave
category:Electromagnetism
layout: example
---

## Compute the stationary electromagnetic wave for a microwave oven

The domain is a square box with a rectangle inside to simulate the object (called meast below) which is heated by the wave.  The electromagnetic source is from the top boundary
~~~freefem
int n = 2;
real a = 20, b = 20, c = 15, d = 8, e = 2, l = 12, f = 2, g = 2;

// Mesh
border a0(t=0, 1) {x=a*t; y=0; label=1;}
border a1(t=1, 2) {x=a; y= b*(t-1); label=1;}
border a2(t=2, 3) {x=a*(3-t); y=b; label=1;}
border a3(t=3, 4) {x=0; y=b-(b-c)*(t-3); label=1;}
border a4(t=4, 5) {x=0; y=c-(c-d)*(t-4); label=2;}
border a5(t=5, 6) {x=0; y= d*(6-t); label=1;}

border b0(t=0, 1) {x=a-f+e*(t-1); y=g; label=3;}
border b1(t=1, 4) {x=a-f; y=g+l*(t-1)/3; label=3;}
border b2(t=4, 5) {x=a-f-e*(t-4); y=l+g; label=3;}
border b3(t=5, 8) {x=a-e-f; y=l+g-l*(t-5)/3; label=3;}

mesh Th = buildmesh(a0(10*n) + a1(10*n) + a2(10*n) + a3(10*n) + a4(10*n) + a5(10*n)
  + b0(5*n) + b1(10*n) + b2(5*n) + b3(10*n));
~~~

| The geometry   |
| -------------- |
| ![][_geometry] |

The wave is solution of a PDE in the complex domain for which the variational formulation is
$$
\begin{align*}
\int_\Omega(
      (1+R)v w
    -(1-0.5i)(\partial_x v\partial_x w+ \partial_y v \partial_y w )=0
   \\
     ~~~~~ \forall  w~:~w|_{\Gamma_1\cup\Gamma_2}=0,
    \\
    v|_{\Gamma_1}=0,~~~~
 v|_{\Gamma_2}=\sin(\pi\frac{y-c}{c-d})
    \end{align*}
$$
and where $R$ takes a different value in the meat. This is implemented as follows
~~~freefem
real meat = Th(a-f-e/2, g+l/2).region,
     air= Th(0.01, 0.01).region;
plot(Th, wait=1);

fespace Vh(Th, P1);
Vh R = (region-air)/(meat-air);
Vh<complex> v, w;

solve muwave(v, w)
  = int2d(Th)(
      v*w*(1+R)
    -(dx(v)*dx(w)+dy(v)*dy(w))*(1-0.5i)
  )
  + on(1, v=0)
  + on(2, v=sin(pi*(y-c)/(c-d)));

Vh vr = real(v), vi = imag(v);
plot(vr, wait=1, ps="rmuonde.ps", fill=true);
plot(vi, wait=1, ps="imuonde.ps", fill=true);
~~~
Notice that the linear system is complex and could be singular (resonance).

| Real part      |
| -------------- |
| ![][_realpart] |

| Imaginary part    |
| ----------------- |
| ![][_imaginepart] |

To compute the temperature in the meat we solve
$$
\begin{align*}
\int_\Omega(
     (\partial_x u\partial_x w+ \partial_y u \partial_y w )= \int_\Omega|v|^2w
   \\
     ~~~~~ \forall  w~:~w|_{\Gamma_1\cup\Gamma_2}=0,
    \\
    v|_{\Gamma_1\cup\Gamma_2}=0,
    \end{align*}
$$
~~~freefem
fespace Uh(Th,P1);
Uh u, uu, ff=1e5*(vr^2 + vi^2)*R;

solve temperature(u, uu)
  = int2d(Th)(
      dx(u) * dx(uu)
    + dy(u) * dy(uu)
  )
  - int2d(Th)(ff*uu)
  + on(1, 2, u=0);

plot(u, wait=1, ps="tempmuonde.ps", fill=true);
~~~

| The temperature   |
| ----------------- |
| ![][_heat] |

[_geometry]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/muwave/geometry.png

[_realpart]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/muwave/realpart.png

[_imaginepart]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/muwave/imaginepart.png

[_heat]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/muwave/heat.png
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


---
name: Lamé
category: Solid Mechanics
layout: example
---

## Compute the deflection of a 2d elastic beam
The geometry is a rectangle, clamped on the left vertical side and pulled down by itsown weight.
The equations are
$$
\displaystyle{
	\begin{align*}&
  \int_{\Omega}[2\mu~\epsilon(u)\cdot\epsilon(v) +\lambda (\nabla\cdot u )(\nabla\cdot v)]  = \int_{\partial\Omega}{f u_2},
  \quad \forall v\in V(\Omega)
  \cr&
  \nabla\cdot u= \partial_x u_1+\partial_y u_2,
  \cr&
  \epsilon(u)=[\partial_x u_1,\partial_y u_2, \frac1{\sqrt{2}}(\partial_y u_1 + \partial_x u_2)].
  \end{align*}
}
$$
where $V(\Omega)=\{ v\in (H(\Omega)^2): v|_S=0\}$ and $S\subset\partial\Omega$ is the portion of the boundary where the beam is clamped.
$\mu$ and $\lambda$ are computed from the Young and Poisson constants $E,\sigma$,
$$
\mu = \frac{E}{(2(1 + \nu))}, \quad
\lambda =\frac{E~\nu}{((1 + \nu)(1 - 2\nu))}
$$


~~~freefem
real E = 21e5, nu = 0.28;
real f = -1;
real mu = E/(2*(1 + nu));
real lambda = E*nu/((1 + nu)*(1 - 2*nu));

mesh Th = square(10, 10, [20*x, 2*y-1]);

fespace Vh(Th, P2);
Vh u, v, uu, vv;

real sqrt2 = sqrt(2.);
macro epsilon(u1, u2) [dx(u1), dy(u2), (dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u, v) (dx(u) + dy(v)) // EOM

solve lame([u, v], [uu, vv])
  = int2d(Th)(  lambda*div(u,v)*div(uu,vv)
              + 2.*mu*(epsilon(u,v)'*epsilon(uu,vv)) )
  - int2d(Th)(f*vv) + on(4, u=0, v=0);

real coef=100;
plot([u, v], wait=1, ps="lamevect.ps", coef=coef);
~~~

| The displacement vectors |
| ------------------------ |
| ![][_solution]           |

A better way to display the result is to move the mesh by the displacement $[u,v]^T$.
~~~freefem
mesh th1 = movemesh(Th, [x+u*coef, y+v*coef]);
plot(th1, wait=1, ps="lamedeform.eps");

real dxmin = u[].min;
real dymin = v[].min;
cout << "   displacement  max x = " << dxmin << " y = " << dymin << endl;
cout << "   displacement (20,0) = " << u(20,0) << " " << v(20,0) << endl;
~~~

| The displaced beam |
| ------------------ |
| ![][_dispbeam]     |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/lame/solution.png

[_dispbeam]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/lame/dispbeam.png
---
name: heatex
category: physics
layout: example
---
# The time independent  Heat Equation

The heat equation  with a discontinuous thermal diffusion is integrated:
$$
-\nabla\cdot(\kappa\nabla u)=0, ~~u|_{\Gamma_1}=u_\Gamma.
$$
In this example the domain $\Omega$ is a circle minus 2 rectangles on which boundary the temperature is imposed.
The thermal diffusion is $\kappa=1+4~{\bf 1}_{x\in(-2,-1)\times(-3,3)}$ where ${\bf 1}_x$ is the Heaviside function. Finally $u=20$ on the outer circle and 100 one the right rectangle. The left rectangle is there only to define $\kappa$. It corresponds to the following FreeFem script

~~~freefem
int C1 = 99, C2 = 98; // could be anything

// Mesh
border C0(t=0, 2*pi){x=5*cos(t); y=5*sin(t);}

border C11(t=0, 1){x=1+t;  y=3;      label=C1;}
border C12(t=0, 1){x=2;    y=3-6*t;  label=C1;}
border C13(t=0, 1){x=2-t;  y=-3;     label=C1;}
border C14(t=0, 1){x=1;    y=-3+6*t; label=C1;}

border C21(t=0, 1){x=-2+t; y=3;      label=C2;}
border C22(t=0, 1){x=-1;   y=3-6*t;  label=C2;}
border C23(t=0, 1){x=-1-t; y=-3;     label=C2;}
border C24(t=0, 1){x=-2;   y=-3+6*t; label=C2;}

mesh Th=buildmesh(C0(50)
  + C11(5) + C12(20) + C13(5) + C14(20)
  + C21(-5) + C22(-20) + C23(-5) + C24(-20));
plot(Th, wait=1, ps="heatexTh.ps");

// Fespace
fespace Vh(Th, P1);
Vh u, v;
Vh kappa = 1 + 4*(x<-1)*(x>-2)*(y<3)*(y>-3);

// Problem
solve a(u, v)
  = int2d(Th)(
    kappa*(dx(u)*dx(v) + dy(u)*dy(v))
  )
  + on(C0, u=20)
  +on(C1, u=100);

// Plot
plot(u, value=true, wait=1, fill=true);
~~~

| The solution   |
| -------------- |
| ![][_solution] |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/heatex/solution.png
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

verbosity=0;

// Parameters
real theta = 4.*pi/3.;
real a = 1., b = 1.; // the length of the semimajor axis and semiminor axis
func f = -4*(cos(x^2+y^2-1) - (x^2+y^2)*sin(x^2+y^2-1));

// Mesh
border Gamma1(t=0, theta)    {x=a*cos(t); y=b*sin(t);}
border Gamma2(t=theta, 2*pi) {x=a*cos(t); y=b*sin(t);}

// Exact solution
func phiexact = sin(x^2+y^2-1);

// Solve loop
real[int] L2error(2);
for(int n = 0; n < 2; n++) {
  mesh Th = buildmesh(Gamma1(40*(n+1)) + Gamma2(20*(n+1)));
  fespace Vh(Th, P2);
   Vh phi, w;

  solve laplace(phi, w)
    =int2d(Th)(
        dx(phi)*dx(w)
      + dy(phi)*dy(w)
    )
    - int2d(Th)(f*w)
    - int1d(Th,Gamma2)(2*w)
    + on(Gamma1, phi=0);
  plot(Th, phi, wait=true, ps="membrane.eps"); //Plot Th and phi

  L2error[n] = sqrt(int2d(Th)((phi - phiexact)^2));
}

for(int n = 0; n < 2; n++)
  cout << " L2error " << n << " = " <<  L2error[n] << endl;

cout << " convergence rate = " << log(L2error[0]/L2error[1])/log(2.) << endl;
---
name: optimcontrol
category:optimization using BFGS
layout: example
---
# Optimal control with 3 parameters solved by BFGS

Let $\Omega$ be a bounded open set of $R^2$. Let $u_d$ and $w$ be given.  Consider
$$
\begin{align*}&
J(z)=\min_{z\in Z}\int_\Omega|u-u_d|^2 \hbox{where $u$ is solution of}
\cr&
\int_\Omega\nu(z)\nabla u\nabla\hat u =0~~~\forall \hat u\in  H^1_0(\Omega);~~u-w\in H^1_0(\Omega)
\cr&
\end{align*}
$$
where $\nu(z)$ is some given function of $z$.
$\texttt{BFGS}$ is an optimization module which can be called to find a local minimum of $J$ but it requires the derivative of $J$ with respect to $z$.

In this example $\Omega$ is a disk of radius 5.  The optimization space $Z$ is the set of functions which are constant on 3 smaller disks, $D_0,D_1,D_2$ of radius 1 in $\Omega$ and 1 outside these smaller disk.  Thus the dimension of $Z$ is 3:
$$
Z=\{z: ~ z(x,y)=1+z_0{\bf 1}_{D_0}+z_0{\bf 1}_{D_1}+z_0{\bf 1}_{D_2}\}
$$
where ${\bf 1}_{D_i}$ is the characteristic function of $D_i$.
In the follwoing example, $w=x^3-y^3$.
~~~freefem
border aa(t=0, 2*pi) {x = 5*cos(t); y = 5*sin(t);}
border bb(t=0, 2*pi) {x = cos(t); y = sin(t);}
border cc(t=0, 2*pi) {x = -3+cos(t); y = sin(t);}
border dd(t=0, 2*pi) {x = cos(t); y = -3+sin(t);}
mesh th = buildmesh(aa(70) + bb(35) + cc(35) + dd(35));

// Fespace
fespace Vh(th, P1);
Vh Ib = ((x^2+y^2)<1.0001),
   Ic = (((x+3)^2+ y^2)<1.0001),
   Id = ((x^2+(y+3)^2)<1.0001),
   Ie = (((x-1)^2+ y^2)<=4),
   ud, u, uh, du;

// Problem
real[int] z(3);
problem A(u, uh)
  = int2d(th)(
    (1 + z[0]*Ib + z[1]*Ic + z[2]*Id)*(dx(u)*dx(uh) + dy(u)*dy(uh))
  )
  + on(aa, u=x^3-y^3);

// A test
z[0] = 2; z[1] = 3; z[2] = 4;
A;
plot(u, wait=1);
~~~
The test will also be our target
![][_test]
BFGS requires $J$ and $J'_z$ to be defined as C-functions
~~~freefem
ud = u;
ofstream f("J.txt");

func real J(real[int] & Z) {
    for (int i = 0;i < z.n; i++) z[i] = Z[i];
    A;
    real s = int2d(th)(Ie*(u-ud)^2);
    f << s << "   "; // so that every time J is called this is printed
    return s;
}

real[int] dz(3), dJdz(3);

problem B(du, uh)
  =int2d(th)(
    (1 + z[0]*Ib + z[1]*Ic + z[2]*Id)*(dx(du)*dx(uh) + dy(du)*dy(uh))
  )
  +int2d(th)(
    (dz[0]*Ib + dz[1]*Ic + dz[2]*Id)*(dx(u)*dx(uh) + dy(u)*dy(uh))
  )
  +on(aa, du=0);

func real[int] DJ(real[int] &Z) {
  for(int i = 0; i < z.n; i++) {
    for(int j = 0; j < dz.n; j++)
      dz[j]=0;
    dz[i] = 1;
    B;
    dJdz[i] = 2*int2d(th)(Ie*(u-ud)*du);
  }
  return dJdz;
}
~~~
We are now ready to call BFGS with initial value for the optimization parameter $Z[i]=1$, $i=0,1,2$.
~~~freefem
real[int] Z(3);
for(int j = 0; j < z.n; j++) Z[j] = 1;

BFGS(J, DJ, Z, eps=1.e-6, nbiter=15, nbiterline=20);
~~~
The results are printed and plotted:
~~~freefem
cout << "BFGS: J(z) = " << J(Z) << endl;
for(int j = 0; j < z.n; j++) cout << z[j] << endl;
plot(ud, value=1, ps="u.ps");
~~~

| The solution   |
| -------------- |
| ![][_solution] |

[_test]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/optimcontrol/test.png

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/optimcontrol/solution.png
---
name: Convects
category: PDE
layout: example
---

# Convection using 2 different methods
### - Characteristics-Galerkin methods
### - discontinuous Galerkin methods
A unit bell rotates in a disk, according to
$$
\partial_t c + u\nabla c =0,
\quad
c(x,0) =e^{-\lambda[|x-x_0|^2-|y-y_0|^2]}
$$
where $u=[u_1,u_2]^T$ is the convective velocity assumed to be that of an incompressible fluid (i.e.$\nabla\cdot u=0$) tangent to the boundary of the disk, $u\cdot n=0$ on $\partial\Omega$, where $n$ is the normal to the boundary.
The mesh is generated by
~~~freefem
border C(t=0, 2*pi){x=cos(t); y=sin(t);}
mesh Th = buildmesh(C(100));
~~~
The problem has an analytical solution : $c$ is constant on the curves $t\to X(t)$
$$
\dot X(t)=u(X(t),t), \quad \frac{d c(X(t),t)}{d t}=0
$$
From these it is easy to show that
$$
c(x,t)\approx c(x-u_1(x,t)\delta t,y-u_2(x,t)\delta t,t-\delta t)
$$
In our example $u_1=y,~u_2=-x, x_0=0.3, y_0=0.3$.
~~~freefem
verbosity = 1;
real dt = 0.17;
fespace Uh(Th, P1);
Uh cold, c = exp(-10*((x-0.3)^2 +(y-0.3)^2));
Uh u1 = y, u2 = -x;
~~~
The FreeFem function convect does the following computation
$$
\begin{align*}&
\texttt{convect}([u_1,u_2],-dt,c)
\cr&=c(x-u_1(x,t)\delta t,y-u_2(x,t)\delta t,t-\delta t)
\end{align*}
$$
Consequently, the solver is the time loop
~~~freefem
real t = 0;
for (int m = 0; m < 2*pi/dt; m++) {
	t += dt;
	cold = c;
	c = convect([u1, u2], -dt, cold);
	plot(c, cmm=" t="+t + ", min=" + c[].min + ", max=" +  c[].max);
}
~~~
However the following is much less diffusive, at the cost of a linear solver at each time step
~~~freefem
Uh ch;
t=0;
c = exp(-10*((x-0.3)^2 +(y-0.3)^2));
for (int m = 0; m < 2*pi/dt; m++) {
	t += dt;
	cold = c;
	solve a(c,ch) = int2d(Th)(c*ch)
	      - int2d(Th)(convect([u1, u2], -dt, cold)*ch);
	plot(c, cmm=" t="+t + ", min=" + c[].min + ", max=" +  c[].max);
}
~~~
Finally one may improve the computing time by reusing the matrice (although FreeFem does it behind the scene) but the method is again too diffusive because it has one extra interpolation.
~~~freefem
varf aa(c,ch)= int2d(Th)(c*ch) ;
varf rhs(c, ch) = int2d(Th)(c*ch);

matrix  A = aa(Uh, Uh, verb=1);
matrix B = rhs(Uh, Uh);
c = exp(-10*((x-0.3)^2 +(y-0.3)^2));
for (t = 0; t < 2*pi ; t += dt) {
	cold = c;
	Uh f=convect([u1, u2], -dt, cold);
	ch[] = B* f[];
	c[] = A^-1*ch[];
	plot(c, fill=1, cmm="t="+t + ", min=" + c[].min + ", max=" +  c[].max);
}
~~~
The same problem can be solved with a Discontinuous Galerkin method
~~~freefem
real u, al=0.5;
dt = 0.05;

fespace Vh(Th, P1dc);
Vh w, ccold, v1 = y, v2 = -x, cc = exp(-10*((x-0.3)^2 +(y-0.3)^2));

macro n()(N.x*v1+N.y*v2) //
problem  Adual(cc, w, init=t)
	= int2d(Th)((cc/dt + (v1*dx(cc) + v2*dy(cc)))*w)
	+ intalledges(Th)((1-nTonEdge)*w*(al*abs(n) - n/2)*jump(cc))
//  - int1d(Th, C)((n(u)<0)*abs(n(u))*cc*w)
// unused because cc=0 on d(Omega)^-
	- int2d(Th)(ccold*w/dt);

for (t = 0; t < 2*pi; t += dt) {
	ccold = cc;
	Adual;
	plot(cc, fill=1, cmm="t="+t + ", min="
	+ cc[].min + ", max=" +  cc[].max);
}
~~~
To force the level lines at fixed values one can define viso:
~~~freefem
real [int] viso=[-0.1, 0, 0.05, 0.1, 0.15, 0.2,
0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65,
0.7, 0.75, 0.8, 0.9, 1];
plot(c,cc, wait=1, value=1, ps="convectDG.ps", viso=viso);
~~~
Another implementation of the DG to speed up computing time:
~~~freefem
varf aadual(cc, w)
	= int2d(Th)((cc/dt + (v1*dx(cc) + v2*dy(cc)))*w)
	+ intalledges(Th)((1-nTonEdge)*w*(al*abs(n) - n/2)*jump(cc));

varf bbdual(ccold, w) = -int2d(Th)(ccold*w/dt);

matrix  AA = aadual(Vh, Vh, verb=1);
matrix BB = bbdual(Vh, Vh);

// Loop
Vh f = 0;
for (t = 0; t < 2*pi ; t += dt) {
	ccold = cc;
	f[] = BB* ccold[];
	cc[] = AA^-1*f[];
	plot(cc, fill=0, cmm="t="+t + ", min=" + cc[].min + ", max=" +  cc[].max);
}

// Plot
plot(cc, wait=1, fill=1, value=1, ps="convectDG.eps", viso=viso);
~~~
---
name: Membrane
category: Solid Mechanics
layout: example
---

## Compute the deflection of a 2d clamped membrane
The geometry is an ellipse, clamped on ${\Gamma_1}$  at altitude $z$ and  pulled down by a volumic force f.
~~~freefem
func z = x;
// Mesh
real theta = 4.*pi/3.;
real a = 2., b = 1.; // Half the length of the major and minor axis
border Gamma1(t=0, theta)    {x=a*cos(t); y=b*sin(t);}
border Gamma2(t=theta, 2*pi) {x=a*cos(t); y=b*sin(t);}
mesh Th = buildmesh(Gamma1(100) + Gamma2(50));
// Fespace
fespace Vh(Th,P2); // P2 conforming triangular finite element space
Vh phi, w, f = 1;
~~~
Note that $z$ is a reserved word (used for 3D applications) but it can be overriden.

The equations for the membrane are
$$
-\Delta \phi=f, ~~\phi|_{\Gamma_1}=z,
$$
And in variational form,
$$
  \int_{\Omega}\nabla \phi \cdot\nabla w = \int_\Omega f w,\quad  ~\phi|_{\Gamma_1}=z,
$$
for all $w\in V$, where $V(\Omega)=\{ w\in (H(\Omega)^2): w|_{\Gamma_1}=0\}$.
~~~freefem
solve Laplace(phi, w)
       =int2d(Th)(  dx(phi)*dx(w) + dy(phi)*dy(w))
       - int2d(Th)(f*w) + on(Gamma1, phi=z);

// Plot
plot(Th,phi, wait=true, fill=true,dim=3,ps="membrane.ps");
~~~
The graphics in FreeFem are minimal.

![][_solution]

Publication quality graphics can be generated by calling Paraview or gnuplot.
Here is an example of export to gnupot
~~~freefem
{
  ofstream ff("graph.txt");
  for (int i = 0; i < Th.nt; i++) {
    for (int j = 0; j < 3; j++)
      ff << Th[i][j].x  << "    " << Th[i][j].y << "  " << phi[][Vh(i,j)] << endl;
  ff << Th[i][0].x << "    " << Th[i][0].y << "  " << phi[][Vh(i,0)] << endl << endl << endl;
  }
}
// Save the mesh. Could be reused in another script with readmesh
savemesh(Th, "Th.msh");
~~~
Then call gnuplot in a terminal window and type
set palette rgbformulae 30,31,32
splot "graph.txt" w l pal
![][_gnuplot]

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/membrane/solution.png

[_gnuplot]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/membrane/gnuplot.png
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/
// Your first program

// Define a boundary
border C(t=0, 2*pi){x=cos(t); y=sin(t);}

// Build the mesh from boundary
mesh Th = buildmesh(C(50));

// Create a finite element space of order 2
fespace Vh(Th, P2);
// Defines u and v, piecewise-P2 continuous functions
Vh u, v;

// Define an algebraic function
func f = x*y;

real cpu = clock();

// Define and solve a PDE
solve Poisson(u, v, solver=LU)
  = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) // bilinear part
  - int2d(Th)(f*v) // right hand side
  + on(C, u=0); // Dirichlet boundary condition

// Plot the solution
plot(u, wait=1, cmm="Solution");

// Display the CPU time
cout << " CPU time = " << clock()-cpu << endl;

// FOR THE PRO: The same problem solved with total control over the algebra
varf a(u, v) // the weak form
  = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
  + on(C, u=0);
matrix A = a(Vh, Vh); // stiffness matrix

varf b(u,v) = int2d(Th)(u*v);
matrix B = b(Vh, Vh);

Vh F = f;
v[] = B*F[];
u[] = A^-1*v[];
plot(u, wait=1, cmm="PRO Solution");
---
name: heat
category: thermodynamics
layout: example
---
## Time dependent heat equation  with a discontinuous thermal diffusion
The time dependent heat equation  with a discontinuous thermal diffusion is integrated:
$$
\partial_t u - \nabla\cdot(k\nabla u)=0, ~~u|_{\Gamma_1}=u_\Gamma,~~k\frac{\partial u}{\partial n}|_{\Gamma_2}+k_f(u-u_e)=0,~~u_{t=0}=0.
$$
In this example the domain $\Omega$ is a rectangle $(0,3)\times(0,1)$; $k=1.8~{\bf 1}_{y<0.5}+0.2$, $k_f=1$ where ${\bf 1}_x$ is the Heaviside function.  The time varies from 0 to 5. Finally $u_e=20$. It corresponds to the FreeFem script
~~~freefem
func k = 1.8*(y < 0.5) + 0.2;
real kf = 1, ue = 20, T = 5, dt = 0.1;

// Mesh
mesh Th = square(150, 50, [3*x, y]);

// Fespace
fespace Vh(Th, P1);
Vh u, uold, v, usave;
~~~
An Euler imlicit scheme is used for the time. After time discretisation, the variational formulation for $u=u^{n+1}$ is
$$
\int_\Omega\frac u{\delta t} \hat u+ k\nabla u\nabla\hat u + \int_{\Gamma_2}k_f u \hat u =\int_\Omega\frac{u^n}{\delta t}\hat u + \int_{\Gamma_2}k_f u_e\hat u,~~~u|_{\Gamma_1}=u_\Gamma,
~~\forall \hat u~\hbox{ s.t. }\hat u_h|_{\Gamma_2}=0.
$$
~~~freefem
int kk=0;
problem Heat(u, v, init=kk)
  = int2d(Th)(
      u*v/dt
    + k*(dx(u)*dx(v) + dy(u)*dy(v))
  )
  + int1d(Th, 1, 3)(kf*v*u)
  - int1d(Th, 1, 3)(kf*v*ue)
  - int2d(Th)(uold*v/dt)
  + on(2, 4, u=30);

bool withplot = 0;
real cpu1, cpu2;
real cpu = clock();

// Initialization
u = 0;

// Basic time loop
for (real t = 0; t < T; t += dt) {
  uold = u;
  Heat;
  kk++;
  if (withplot) plot(u);
}

cpu1 = clock()-cpu;
plot(u);
usave[] = u[];
~~~
$\texttt{cpu}$ gives a measure of the computing time. $\texttt{usave}$ will be used later to compare with iteration integration method.  Notice that $u[]$ addresses the array of values at the vertices of $u$.

Now the same problem is solved using an explicit construction of the linear system.  We begin with the matrix A:
~~~freefem
varf vA(u, v) = int2d(Th)( u*v/dt
    + k*(dx(u)*dx(v) + dy(u)*dy(v))
    )
  + int1d(Th, 1, 3)(kf*v*u)
  + on(2, 4, u=30);
 matrix A = vA(Vh, Vh, solver=sparsesolver);
~~~
The righthandside is also a matrix B times a vector plus another vector vL.
~~~freefem
varf vB(u, v) = int2d(Th)(u*v/dt) ;
varf vRHS(u, v) = int1d(Th, 1, 3)(kf*v*ue);
varf vL(u, v) = on(2, 4, u=30);

  cpu = clock();
  real[int] rhsbc = vL(0, Vh);
  real[int] rhs0 = vRHS(0, Vh);
  matrix B = vB(Vh, Vh);

  // Initialization
  u = 0;

  // Optimized time loop (speed of C language)
  for (real t = 0; t < T; t += dt) {
    real[int] b = B*u[];
    b += rhs0;
    b = rhsbc ? rhsbc : b;
    u[] = A^-1*b;
    if(withplot) plot(u);
  }
  cpu2 = clock() - cpu;

plot(u, cmm="u2");
cout << " cpu method 1 = " << cpu1 << " cpu method matrix = " << cpu2 << " ratio = " <<  cpu1/cpu2 << endl;
~~~
![](https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/Heat/solution.png)
---
name: condensator
category: electrostatics
layout: example
---

# The Black-Scholes equation for financial derivatives

In the documentation,
https://doc.freefem.org/tutorials/heatExchanger.html#heat-exchanger

It is quite easy to compute the electrostatic potential $u$ between 2 plates, one at potential -1 and the other at potential 1.  The plates $C_1,C_3$ are inside a round container $C_2$.

The geometry is a bit painful to describe with the keyword border.
~~~freefem
int C1 = 1; // labels to identify the 2 plates C1,C3 and the containner C2
int C2 = 2; // could be any number
int C3 = 3;
// Mesh
border C0(t=0, 2*pi){x=5*cos(t); y=5*sin(t); label=C2;}

border C11(t=0, 1){ x=1+t;  y=3;      label=C1;}
border C12(t=0, 1){ x=2;    y=3-6*t;  label=C1;}
border C13(t=0, 1){ x=2-t;  y=-3;     label=C1;}
border C14(t=0, 1){ x=1;    y=-3+6*t; label=C1;}

border C21(t=0, 1){ x=-2+t; y=3;      label=C3;}
border C22(t=0, 1){ x=-1;   y=3-6*t;  label=C3;}
border C23(t=0, 1){ x=-1-t; y=-3;     label=C3;}
border C24(t=1, 0){ x=-2;   y=-3+6*t; label=C3;}

mesh Th=buildmesh(C0(50)
    +C11(5)+C12(20)+C13(5)+C14(20)
    +C21(5)+C22(20)+C23(5)+C24(-20));
plot(Th, wait=true);
~~~

![][_mesh]

The electrostatic potential equation in absence of volumic charges is
$$
\Delta u =1,\quad u|_{C_1}=-1,\quad u|_{C_2}=0,\quad u|_{C_3}=1,
$$
The variational formulation is: find $u\in H^1(\Omega)$ with $u|_{C_i}=i-2, i=1,2,3$,
$$
\int_\Omega\nabla u\cdot\nabla v=0\quad \forall v\in H^1_0(\Omega).
$$
~~~freefem
fespace Vh(Th, P1);
Vh u, v;

// Problem
solve a(u, v)
    = int2d(Th)(
          dx(u)*dx(v) + dy(u)*dy(v)
    )
    + on(C1, u=1) + on(C2, u=0) + on(C3, u=-1);

// Plot
plot(u, value=true, ps="condersor.ps");
~~~
Notice that the solution is stored in a file condensor.eps in postscript format next to the program file. The extension .ps means it is a postcript format (don't use .eps at this elvel). To insert it in a publication you may use the linux command
    ps2eps condersor.ps
    epstopdf condensor.eps

![][_solution]

[_mesh]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/condensor/mesh.png

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/condensor/solution.png
---
name: sound
category: physics
layout: example
---

# The wave equation and some eigen modes
The geometry is a 2D perpendicular cross section of a concert hall. It is generated by a polygon.
~~~freefem
real kc2 = 1; // try this value 19.4256
func g = y*(1-y);
real sigma = 20; // value of the shift
int nev = 2; // number of computed eigen value close to sigma

// Mesh
border a0(t=0, 1) { x=5; y=1+2*t;}
border a1(t=0, 1) { x=5-2*t; y=3;}
border a2(t=0, 1) { x=3-2*t; y=3-2*t;}
border a3(t=0, 1) { x=1-t; y=1;}
border a4(t=0, 1) { x=0; y=1-t;}
border a5(t=0, 1) { x=t; y=0;}
border a6(t=0, 1) { x=1+4*t; y=t;}

mesh Th=buildmesh(a0(20) + a1(20) + a2(20) + a3(20) + a4(20) + a5(20) + a6(20));

// Fespace
fespace Vh(Th, P1);
Vh u,v;
Vh u1, u2;
~~~
The wave equation for the amplitude of a time periodic signal of frequency $\omega$, is
$$
\omega^2 u -\Delta u=0,~~\texttt{ in } \Omega,~\partial_n u|_{\Gamma_4}=g
$$
In variational form it is
~~~freefem
solve sound(u, v)
  =int2d(Th)(u*v*kc2 - dx(u)*dx(v) - dy(u)*dy(v))
  - int1d(Th, a4)(g*v);

plot(u, wait=1, ps="sound0.ps");
~~~
To find the resonnances frequencies $\sigma$ one must solve an eigen value problem $A u = \sigma B u$ where $A$ is the matrix of the Laplace operator and $B$ is the mass matrix.
~~~freefem
varf op(u1, u2)
  = int2d(Th)(dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2);

varf b([u1], [u2])
  = int2d(Th)(u1*u2); // no boundary condition

matrix OP = op(Vh, Vh, solver=Crout);  // crout solver because the matrix in not positive
matrix B = b(Vh, Vh, solver=CG, eps=1e-20);

real[int] ev(nev); // to store the nev eigenvalue
Vh[int] eV(nev); // to store the nev eigenvector

int k = EigenValue(OP, B, sym=true, sigma=sigma, value=ev, vector=eV,
  tol=1e-10, maxit=0, ncv=0);
cout << ev(0) << " 2 eigen values " << ev(1) << endl;
v = eV[0];
plot(v, wait=1, ps="eigen.eps");
~~~

| Sound pressure lines |
| -------------------- |
| ![][_pressure]       |

| One eigen mode |
| -------------- |
| ![][_eigen0]   |

[_pressure]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/sound/pressure.png

[_eigen0]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/sound/eigen0.png
---
name: thermal
category: thermodynamics
layout: example
---

# Heat Equation
The domain is a disk with 2 rectangles inside. One is a hole the other one is a region with a different heat diffusion parameter.
$$
\kappa= 1 + 4{\bf 1}_{(x<-1)\cap(x>-2)\cap(y<3)\cap(y>-3)}.
$$
~~~freefem
border C0(t=0, 2*pi){x=5*cos(t); y=5*sin(t);}
int C1 = 99, C2 = 98; // could be anything
border C11(t=0, 1){x=1+t;  y=3;      label=C1;}
border C12(t=0, 1){x=2;    y=3-6*t;  label=C1;}
border C13(t=0, 1){x=2-t;  y=-3;     label=C1;}
border C14(t=0, 1){x=1;    y=-3+6*t; label=C1;}

border C21(t=0, 1){x=-2+t; y=3;      label=C2;}
border C22(t=0, 1){x=-1;   y=3-6*t;  label=C2;}
border C23(t=0, 1){x=-1-t; y=-3;     label=C2;}
border C24(t=0, 1){x=-2;   y=-3+6*t; label=C2;}

mesh Th=buildmesh(C0(50)
  + C11(5) + C12(20) + C13(5) + C14(20)
  + C21(-5) + C22(-20) + C23(-5) + C24(-20));
plot(Th, wait=1);

// Fespace
fespace Vh(Th, P1);
Vh u, v;
Vh kappa = 1 + 4*(x<-1)*(x>-2)*(y<3)*(y>-3);
~~~

| The mesh   |
| ---------- |
| ![][_mesh] |

The heat equation is
$$
-\nabla\cdot(\kappa\nabla u)=0,~~u|_{C_0}=20,~~u|_{C_1}=100.
$$
~~~freefem
solve a(u, v)
  = int2d(Th)(kappa*(dx(u)*dx(v) + dy(u)*dy(v)))
  + on(C0, u=20)
  + on(C1, u=100);
plot(u, value=true, wait=1, fill=true);
~~~

| The temperature |
| --------------- |
| ![][_solution]  |

[_mesh]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/thermal/mesh.png

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/thermal/solution.png
---
name: Stokes
category: fluid
layout: example
---

# The Stokes system for creeping flow
The system is set in 2 dimensions:
$$
-\Delta u + \nabla p =\vec f, \quad
 \nabla\cdot u = 0   \hbox{ in }\Omega ,~~
 u _{|\Gamma}= \vec g
 $$
with $\Omega$ the  unit square, $\vec f=[0,0]^T$ and $\vec g={\bf 1}_{\Gamma_3}[1,0]^T$.

A possible variational formulation is
$$∀(v,q),~~∫_Ω ∇u:∇v−∫_Ωp\nabla\cdot v=0,
−∫_Ω\nabla\cdot u q−∫_Ωϵpq=0.
$$
The velocity is approximated with the $P^1+bubble$ element and the pressure by $P^1$ continuous functions.
A small penalization parameter is added to the formuation to secure uniqueness.
~~~freefem
int n = 3; // mesh quality
mesh Th = square(10*n, 10*n);

// Fespace
fespace Uh(Th, P1b);
Uh u, v;
Uh uu, vv;
fespace Ph(Th, P1);
Ph p, pp;

// Problem
solve stokes([u, v, p], [uu, vv, pp])
  = int2d(Th)(
      dx(u)*dx(uu) + dy(u)*dy(uu)
    + dx(v)*dx(vv) + dy(v)*dy(vv)
    + dx(p)*uu + dy(p)*vv
    + pp*(dx(u) + dy(v))
    -1e-10*p*pp
  )
  + on(1, 2, 4, u=0, v=0)
  + on(3, u=1, v=0)
  ;

// Plot
plot([u,v],p,wait=1);
~~~
## Results

| Isovalue lines of the pressure and vector display of the velocity |
| --------------                                                    |
| ![][_solution]                                                    |

[_solution]: https://raw.githubusercontent.com/FreeFem/FreeFem-markdown-figures/main/examples/examples/stokes/solution.png
---
name: stokes_periodic_composite
category: fluid
layout: example
---

# The Stokes system for creeping flow with periodic conditions

This is a continuation of the previous example, but now there are
- periodic boundary condition in x-direction
- Dirichlet boundary condition in y-direction
These are chosen from a manufacture solution
$$
u=\sin x\cos y,~v=-\cos x\sin y,~p=2\cos x\cos y
$$
~~~freefem
mesh Th=square(60,60,[2*pi*x,2*pi*y],flags=3);
mesh ThU=trunc(Th,1,split=2);
mesh ThP=Th;

fespace UhPerio(ThU,[P1],periodic=[[2,y],[4,y]]);
fespace Uh(ThU,[P1]);
fespace Ph(Th,P1);

fespace Vh=UhPerio*Uh*Ph; // definition of the composite FE space

cout << "ndof = " << Vh.ndof << endl;

UhPerio u1;
Uh u2;
Ph p;

func g1 = sin(x)*cos(y);
func g2 = -cos(x)*sin(y);

func f1 = 0;
func f2 = -4*cos(x)*sin(y);
func fp = 2*cos(x)*cos(y);

~~~
To illustrate a different method, here "solve" or "problem" is not used; the linear system is built with "varf"
~~~freefem
macro grad(u) [dx(u),dy(u)]//
macro Grad(u1,u2) [grad(u1), grad(u2)]//
macro div(u1,u2) (dx(u1)+dy(u2))//

varf Stokes ( [u1,u2,p], [v1,v2,q] )
= int2d(Th)( (Grad(u1,u2):Grad(v1,v2)) ) + int2d(Th)( - div(u1,u2)*q - div(v1,v2)*p ) + int2d(Th)( -1e-10*p*q )
+ int2d(Th) ( [f1,f2]'*[v1,v2] )
+ on(1,2,3,4,u2=g2) + on(1,3,u1=g1);

matrix A = Stokes(Vh,Vh);
real[int] b1 = Stokes(0,Vh);
real[int] sol = A^(-1)*b1;
~~~
To retrieve the velocity and the pressure from the compound vector sol, do
~~~freefem
[u1[],u2[],p[]]=sol;

plot( u1, cmm="u1" );
plot( u2, cmm="u2");
plot( p,  cmm="p" );
~~~
The rest of the script is devoted to the computation of the $L^2$ error
$$\|[u,v,p]-[u_e,v_e,p_e]\|.$$
~~~freefem
fespace VhU(ThU,P1);
fespace VhP(ThP,P1);

VhU ue1=g1;
VhU ue2=g2;
VhP pe=fp;

cout << " int2d(Th) (dx(fu1)+dy(fu2)) =" << int2d(Th)(dx(ue1)+dy(ue2)) << endl;

cout << "error L2 (u) = " << int2d(Th)( (u1-ue1)^2 + (u2-ue2)^2 ) << endl;
cout << "error L2 (p) = " << int2d(Th)( (p-pe)^2 ) << endl;
cout << "error L2 relative (u) = " << int2d(Th)( (u1-ue1)^2 + (u2-ue2)^2 ) / int2d(Th)( ue1^2+ue2^2 ) << endl;
cout << "error L2 relative (p) = " << int2d(Th)( (p-pe)^2 ) / int2d(Th)( pe^2 ) << endl;
~~~
