real REFaadaptation=0.000319439;
real REFaalapacien=1;
real REFaalaplaceXnc=1713.48;
real REFaamove=0.070846;
real REFaaRT=280.926;
real REFarrayoFVh=4560.74;
real REFbilap=33.835;
real REFD2=0;
real REFdemo1=1.31154;
real REFdemo=0.136436;
real REFfunct=4;
real REFlapacienprecon=122059;
real REFlapXmat=85.3776;
real REFNSP1P1b=0.046197;
real REFNSP1P1=0.0392512;
real REFNSP1P2=0.0453672;
real REFparareal=1383.27;
real REFRichard=95.9004;
real REFteste=1;
real REFwaferXheatingXlaserXaxi=285;
//  a example to test the level of optimisation
// --------------------------------------------
// PARAM -n 100
include "getARGV.idp"

int nn=getARGV("-n",300);
 mesh Th=square(nn,nn);
verbosity=5;
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function

 problem laplace0(uh,vh,solver=Cholesky,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplace1(uh,vh,solver=CG,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplaceLU(uh,vh,solver=LU,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplaceCrout(uh,vh,solver=Crout,tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

real cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap Cholesky " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
uh=0;
cpu=clock() ;
laplace1; // solve the problem plot(uh); // to see the result
cout << "-- lap CG       " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
uh=0;

cpu=clock() ;
laplaceLU; // solve the problem plot(uh); // to see the result
cout << "-- lap LU       " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
uh=0;

cpu=clock() ;
laplaceCrout; // solve the problem plot(uh); // to see the result
cout << "-- lap Crout    " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;

// FFCS: reference value for regression tests
real regtest=uh[].max;

uh=0;

if(HaveUMFPACK){
  problem laplace2(uh,vh,solver="SPARSESOLVER",tgv=1e30) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
    + int1d(Th,1)( uh*vh) 
    + int1d(Th,1)( - vh)
    + int2d(Th)( -f*vh )                          //  linear form
    + on(2,3,4,uh=g) ;                      //  boundary condition form

  cpu=clock(); 
  laplace2; // solve the problem plot(uh); // to see the result
  cout << "-- lap UMFPACK  " << nn << "x" << nn << "  : "
       <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
}
else{
  cout << "-- lap UMFPACK  " << nn << "x" << nn << "  : "
       <<  "not available" << endl;
}

//  plot(uh,ps="lap1-cpu.eps",value=true);
mesh Th=square(40,40,flags=3);

fespace Vh(Th,P1nc);
fespace Pdh(Th,P0);
fespace Pch(Th,P1);
fespace Ph(Th,P1dc);
macro grad(u) [dx(u),dy(u)]//
macro Grad(u) [grad(u#1),grad(u#2)]//
macro div(u) (dx(u#1)+dy(u#2))//

Vh u1,u2,v1,v2;
Pdh pd,qd;
Pch pc,qc;
real eps = 1e-8; 
solve Stokes( [u1,u2,pc,pd],[v1,v2,qc,qd])
= int2d(Th) ( (Grad(u):Grad(v)) - pd*div(v) - qd*div(u) + [v1,v2]'*grad(pc) + [u1,u2]'*grad(qc)
   -eps*pc*qc -eps*pd*qd)
+  on(3,u1=(1-x)*x,u2=0)   
+ on(1,2,4,u1=0,u2=0);

plot([u1,u2],wait=1);

Ph p = pd+pc;
plot(p, wait=1);
// Warning we forgot to remove 3 pointer in this exemple
// precon=Precon correct in version 1.26 
verbosity=4;

mesh Th=square(10,10,[10*x,5*y]);
fespace Vh(Th,P1);

Vh u,v;

u=0;
func f= 0;
func g= 5*x+y;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
varf vAA(u,v) =    
   int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int1d(Th,1) ( u*v ) 
  + on(3,4,u=0) ;
int pprc=1;
matrix AA = vAA(Vh,Vh,solver=CG);
func real[int]  Precon(real[int] & xx)
{
 cout << xx[0] << " -----" ;
//  xx[0]=1001;
   
   real[int] xpre = xx;
   if(pprc) xpre = AA^-1*xx;
  return xpre;
};

problem Probem1(u,v,solver=CG,init=i,eps=1.0e-6,precon=Precon) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int1d(Th,1) ( u*v ) 
  + int2d(Th) ( v*f ) 
  + int1d(Th,2) (-5*v)
  + int1d(Th,1) ( (+1-g)*v)
  + on(3,4,u=g)  ;
  
real cpu=clock();
Probem1; // SOLVE THE PROBLEM 1
plot(u);
cout << " CPU = " << clock()-cpu << endl;
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




ofstream ref("ref.edp");





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


cout << "--------- file : aadaptation.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aadaptation.edp";
	real TESTaadaptation=regvalue;
		ref<<"real REFaadaptation="<<TESTaadaptation<<";"<<endl;
};
;
cout << "--------- file : aalapacien.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalapacien.edp";
	real TESTaalapacien=1+err;
		ref<<"real REFaalapacien="<<TESTaalapacien<<";"<<endl;
};
;
cout << "--------- file : aalaplace-nc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalaplace-nc.edp";
	real TESTaalaplaceXnc=u[]'*u[];
		ref<<"real REFaalaplaceXnc="<<TESTaalaplaceXnc<<";"<<endl;
};
;
cout << "--------- file : aamove.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aamove.edp";
	real TESTaamove=u[]'*u[];
		ref<<"real REFaamove="<<TESTaamove<<";"<<endl;
};
;
cout << "--------- file : aaRT.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aaRT.edp";
	real TESTaaRT=u1[]'*u1[];
		ref<<"real REFaaRT="<<TESTaaRT<<";"<<endl;
};
;
cout << "--------- file : arrayoFVh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "arrayoFVh.edp";
	real TESTarrayoFVh=u[]'*u[];
		ref<<"real REFarrayoFVh="<<TESTarrayoFVh<<";"<<endl;
};
;
cout << "--------- file : bilap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "bilap.edp";
	real TESTbilap=xx(0:n)'*xx(0:n);
		ref<<"real REFbilap="<<TESTbilap<<";"<<endl;
};
;
cout << "--------- file : D2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "D2.edp";
	real TESTD2=w[]'*w[];
		ref<<"real REFD2="<<TESTD2<<";"<<endl;
};
;
cout << "--------- file : demo1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo1.edp";
	real TESTdemo1=u[]'*u[];
		ref<<"real REFdemo1="<<TESTdemo1<<";"<<endl;
};
;
cout << "--------- file : demo.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo.edp";
	real TESTdemo=u[]'*u[];
		ref<<"real REFdemo="<<TESTdemo<<";"<<endl;
};
;
cout << "--------- file : funct.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "funct.edp";
	real TESTfunct=myfunction(1.0,3.);
		ref<<"real REFfunct="<<TESTfunct<<";"<<endl;
};
;
cout << "--------- file : lapacienprecon.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lapacienprecon.edp";
	real TESTlapacienprecon=u[]'*u[];
		ref<<"real REFlapacienprecon="<<TESTlapacienprecon<<";"<<endl;
};
;
cout << "--------- file : lap_mat.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lap_mat.edp";
	real TESTlapXmat=u1[]'*u1[];
		ref<<"real REFlapXmat="<<TESTlapXmat<<";"<<endl;
};
;
cout << "--------- file : NSP1P1b.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1b.edp";
	real TESTNSP1P1b=int2d(Th)(square(u1)+square(u2));
		ref<<"real REFNSP1P1b="<<TESTNSP1P1b<<";"<<endl;
};
;
cout << "--------- file : NSP1P1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1.edp";
	real TESTNSP1P1=int2d(Th)(square(u1)+square(u2));
		ref<<"real REFNSP1P1="<<TESTNSP1P1<<";"<<endl;
};
;
cout << "--------- file : NSP1P2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P2.edp";
	real TESTNSP1P2=int2d(Th)(square(u1)+square(u2));
		ref<<"real REFNSP1P2="<<TESTNSP1P2<<";"<<endl;
};
;
cout << "--------- file : parareal.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "parareal.edp";
	real TESTparareal=pu'*pu;
		ref<<"real REFparareal="<<TESTparareal<<";"<<endl;
};
;

 cout << "--------- file : Richard.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "Richard.edp";
	real TESTRichard=hmax;
		ref<<"real REFRichard="<<TESTRichard<<";"<<endl;
};
;

cout << "--------- file : teste.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "teste.edp";
	real TESTteste=P.x;
		ref<<"real REFteste="<<TESTteste<<";"<<endl;
};
;
cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};
;
cout << "--------- file : wafer-heating-laser-axi.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "wafer-heating-laser-axi.edp";
	real TESTwaferXheatingXlaserXaxi=xx'*xx;
		ref<<"real REFwaferXheatingXlaserXaxi="<<TESTwaferXheatingXlaserXaxi<<";"<<endl;
};
;
//  laplace with matrix  
verbosity=10;
mesh Th=square(10,10);
fespace Vh(Th,P1);
Vh u1,u2;
                    
varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(1,2,3,4,u1=1);
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 );

matrix A= a(Vh,Vh,solver=CG); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

Vh bb ,bc,rhs;
bc[]= a(0,Vh);       // to save the
u1=x;
bb[] = bc[] .* u1[];
u1[] = A^-1*bb[];
//plot(u1,cmm="solution = x ",wait=1,value=1);
u1=x*y;
bb[] = bc[] .* u1[];
u1[] = A^-1*bb[];
//plot(u1,cmm="solution = x*y ",wait=1,value=1);
u1=-4;  //  $-\Delta (x^2 + y^2) $
bb[] = B*u1[];
u1= x^2 + y^2 ;
bb[] += bc[] .* u1[];
u1[] = A^-1*bb[];
u2= x^2 + y^2;

cout << "  u1(1,2) =" <<  u1(.1,.2) << " ~= " << u2(.1,.2) 
     << " ==  " << .1^2+.2^2 <<  endl;
plot(u1,cmm="solution = $x^2 + y^2$ ",wait=1,value=1);
real[int] T=1:5;
real[int,int] RR= [ [0,1,0,0,0 ], 
[0,0,1,0,0 ], 
[0,0,0,0,1 ]];
real[int,int] CC= [ [0,1,0,0,0 ], 
[0,1,1,0,0 ], 
[0,2,0,0,1 ],
[0,3,0,0,1 ],
[0,4,0,0,1 ]];

real[int] r(1),ra(1); 
matrix R=RR; 
matrix C=CC;
cout << R << endl;
cout << " T = " << T << endl;

renumbering(R,T,r);
cout << " r= " << r << endl; 
renumbering(C,R,T,ra);
cout << " ra= " << ra << endl; 
cout << C << endl;
assert( C.n==3 && C.m ==3);
assert(ra.n==3 && r.n==3);
verbosity=2;
border aaa(t=0,1){x=t;y=0;};
border bbb(t=0,0.5){x=1;y=t;};
border ccc(t=0,0.5){x=1-t;y=0.5;};
border ddd(t=0.5,1){x=0.5;y=t;};
border eee(t=0.5,1){x=1-t;y=1;};
border fff(t=0,1){x=0;y=1-t;};
mesh Th = buildmesh (aaa(6) + bbb(4) + ccc(4) +ddd(4) + eee(4) + fff(6));
fespace Vh(Th,P1);

Vh u,v,zero;

u=0;
u=0;
zero=0;
func f= 1;
func g= 0;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
problem Probem1(u,v,solver=CG,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(aaa,bbb,ccc,ddd,eee,fff,u=g)  ;
  
real cpu=clock();

for (i=0;i< 5;i++)
{ 
  
  real d = clock();
  Probem1; 
  plot(u,zero,wait=1,ps="Lm"+i+".eps");
  plot(u,zero,wait=1,ps="Lu"+i+".eps");
  Th=adaptmesh(Th,u,inquire=1,err=error);
  cout << " CPU = " << clock()-d << endl;
  error = error * coef;
} ;

 cout << " CPU = " << clock()-cpu << endl;
//  for regtest 
real regvalue=int2d(Th)(u*u);
cout<<"regvalue="<<regvalue<<endl;
real Ks=0.01,
     hg=30,
     thetas=0.3,
     eta = 6.55,
     m = 0.173,
     n = 2/(1-m);
     
     
real z0=215;
real q0=15/3600.;
real dt=60;
real hmax=0;

// $A(h) - \partial h / \partial t - div(K(h)(\nabla(h-y)) = f $ dans $ \Omega$
//  -K(h)(\nabla(h-y)). n = q0 $ sur $ \Gamma_1$
//  h = h_0$ sur $\Gamma_0$
//  + condition initial $d_d$
//   A(h) = h <0 ? C(h) : 0; 
//  


// remarque z == y 
real xmax = 300, ymax=300, x0=60, y0= 215;

border ba(t=0,ymax)   { x=0; y=ymax-t ;label=2;};  // gauche   
   
border bb1(t=x0,0)    { x=t; y=ymax ;label=1;};   // haut     1 
border bb2(t=xmax,x0) { x=t; y=ymax ;label=2;};  // haut   2   
 
border bc1(t=y0,0) { x=xmax; y=ymax-t ;label=2;};  // droite     
border bc2(t=ymax,y0) { x=xmax; y=ymax-t ;label=3;};  // droite  
   
border bd(t=0,xmax)   { x=t; y=0; label=4;};   // bas

int Gamma0=3;
int Gamma1=1;

int nn=20;
int nn1=nn*x0/xmax,nn2=nn-nn1;
int ny1=nn*y0/ymax,ny2=nn-ny1;
plot(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn),wait=1);
mesh Th=buildmesh(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn));
plot(Th,wait=1);

fespace Vh(Th,P1);
Vh h,v,hhh;

macro theta(h) (thetas*(1+((abs(h)/hg))^n)^(-m))//
macro dtheta(h) (m*n*thetas*(1+((abs(h)/hg))^n)^(-m-1)*(((abs(h)/hg))^(n-1))/hg)
//
macro A(h)  ( (h<=0)* dtheta(h) ) 
//
macro K(h) (Ks*((h<=0)*((theta(h)/thetas)^eta)+ (h>0)))
//

Vh hd= -y0+(ymax-y); // bof bof ????
Vh hn=hd,hh;
Vh Ahdt,Kh;

int nbiso=20;
real[int] viso(3+(75+110/2)/5);

{int k=0;
for(int i=-75;i<0;i+=5)
 viso(k++)=i;
 viso(k++)=-0.5;
 viso(k++)=0.;
 viso(k++)=0.5;
for(int i=5;i<=110;i+=5*2)
 viso(k++)=i;
}
/* 
problem Richard(h,v) =
  int2d(Th)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(Th)( Ahdt* hn*v - Kh* dy(v) )
- int1d(Th,Gamma1)(q0*v)
+ on(3,h=(ymax-y)-y0)
;
*/

real pena=1e10;
problem Richard(h,v) =
  int2d(Th)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(Th)( Ahdt* hn*v - Kh* dy(v) )
- int1d(Th,Gamma1)(q0*v)
 +int1d(Th,3)(pena*h*v)-int1d(Th,3)(pena*((ymax-y)-y0)* v)

;


plot(hn,wait=1,cmm=" hd ");

Ahdt=0; Kh=1;
// Richard;
// plot(hd,wait=1,cmm="hd ----");
real temps=0;
for(int i=0;i<100;i++)
{
  string scmm="h + temps "+int(temps)/3600+"h "+ ((temps)%3600/60.) + "mn ";
  for(int k=0;k<3;k++) 
  {
  Kh=K(h);
  Ahdt=A(h)/dt;
  
  cout << " "<< Kh[].min << " " << Kh[].max << endl;
 // plot(Ahdt,fill=1,value=1,wait=1,cmm="Ahdt");
 // plot(Kh,fill=1,value=1,wait=1,cmm="Kh");
 // plot(Kh,wait=1,cmm="Kh");
  Richard;
  cout << " h: min " << h[].min << " max  " << h[].max <<endl;
  hmax=h[].max ;
  // plot(h,wait=0,cmm=scmm,viso=viso);
//  hhh = h <0;
  }
  if(i%10==1) {
  Th=adaptmesh(Th,h,ratio=1.1,nbvx=100000);
//  plot(Th,h,cmm="h ",value=1,wait=1);
  }
 // plot(hhh,wait=1,cmm="h < 0");
  plot(h,wait=0,cmm=scmm,viso=viso,value=1);
//  plot(h,cmm="h ",value=1);
  hn=h;
  temps += dt;
}

cout <<  " hmax = " << hmax << endl;
//int Nh=20;
// d u /dt = cos(t), u= sin(t) + u0
//  avec de methode para reel.
// schema euler explicite 
//   (u,v)' = (v,-u) 
//    u_n+1 - u_n = v_n*dt,  u_n+1 = u_n + v_n*dt
//    v_n+1 - v_n = -u_n*dt,
//   u=cos(t)  u' = - sin(t) = v
//   v=sin(t), v' = cos(t) = u
// ----------------------------
real DT=0.4;
int nbT=50;   // nb de big time step 
int ksub=50;  // nb of small time step 
int Nbig=20;  // max  number of Big iteration
real T0=0;    // initial time
real tol=1e-5; // tolerance 
// ----------------------------------------------------
int nbt=ksub*nbT;
real dt=DT/ksub;
//  array for plotting 
real[int] pt(nbt+1),pT(nbT+1),pu(nbt+1),pU(nbT+1);

//  gros maillage
mesh TH=square(3,3);
// maillage fin
mesh Th=trunc(TH,1,split=1);
fespace VH(TH,P1);
fespace Vh(Th,P1);
int n=2;
int N=2;

func real Norm(real[int] & U)
{
  return sqrt(square(U[10])+square(U[11]));
}
// restriction
func bool h2H(real[int] & u,real[int] & U)
{
 U=0;
 U[10+0]=u[0];
 U[10+1]=u[1];

 return true;
}
//  prolongement
func bool H2h(real[int] & U,real[int] & u)
{
 u=0;
 u[0]=U[10+0];
 u[1]=U[10+1];
 return true;
}

func bool initG(real[int]  & U)
{
  U=0;
  U[10+0]=1;// cos(0)
  U[10+1]=0;// sin(0)
}
// un pas de temps  FIN

func bool  F(real[int]  & u,real[int]  & up)
{
   u[0] = up[0] + up[1]*dt;
   u[1] = up[1] - up[0]*dt;
//   cout << up[0] << " " << up[1] << endl;
   return true;
}

// pas de temps grossier
func bool  G(real[int]  & U,real[int]  & Up)
{
   U[0+10] = Up[0+10] + Up[1+10]*DT;
   U[1+10] = Up[1+10] - Up[0+10]*DT;
//   cout << Up[10] << " " << Up[11] << endl;
   return true;
}

func bool AddGp(real[int]  & U,int I)
{
  pT[I]= T0+I*DT;
  pU[I]=U[10];
  return true;
}
func bool AddFp(real[int]  & u,int I,int i)
{
  pt[I*ksub+i]= T0+I*DT+i*dt;
  pu[I*ksub+i]= u[0];
  return true;
}

Vh ustart[nbT+1],uend[nbT]; // start 
VH Uend[nbT];
VH U0,U1;



real t=T0,T=T0; // temps courant
int it=0,iT=0; 
pt[it]=t;
pT[iT]=T;
initG(U0[]);
AddGp(U0[],iT);
H2h(U0[], ustart[iT][]);

//  initial 
for (int I=0;I<nbT;I++)
  {
    G(U1[],U0[]);
    U0[]=U1[];
    Uend[I][]=U1[];
    H2h(U0[],ustart[I+1][]);
    AddGp(U1[],I+1); 
  }
cout << pT.max << " " << pU.min << " " << pU.max << endl;


real[int] exact(nbt+1),fu(nbt+1);
{
Vh u0,u1; 
u0[]=ustart[0][];
for (int i=0;i<=nbt;i++)
 {
   pt[i]=T0+i*dt;
   exact[i]=cos(pt[i]);
   F(u1[],u0[]);
   u0[]=u1[];
   AddFp(u0[],0,i);
 }
}
fu=pu;
plot([pT,pU],[pt,exact],[pt,fu],wait=1);
// big loop 
for (int K=0;K< Nbig;K++)
{

//  para real loop --

for (int I=0;I<nbT;I++)
 {
    Vh u0,u1;
    u0[]=ustart[I][];
    AddFp(u0[],I,0);
    for (int i=0;i<ksub;i++)
     {
      F(u1[],u0[]);
      u0[]=u1[];
      AddFp(u0[],I,i+1);
     }
    uend[I][]=u0[];
 }

plot([pT,pU],[pt,pu],[pt,exact],cmm="iteration "+K);
 
// update loop  
ustart[K+1]=uend[K];
real err=0;
for (int I=K+1;I<nbT;I++)
 {
   // Attention  pb fin grossier 
   VH U0,U1;
   h2H(ustart[I][],U0[]);
   AddGp(U0[],I); 
   G(U1[],U0[]);
   AddGp(U1[],I+1); 
   U0[]=U1[];
   U1[] -=Uend[I][]; // U1=U1-U1(old)
   err += Norm(U1[]);
   Uend[I][]=U0[]; // save U1 
   Vh u1;
   H2h(U1[],u1[]);
   ustart[I+1][] = u1[]+ uend[I][] ;     
 }

 cout << "\n\n big iteration " <<  K << "  err= " << err << endl;
 if (err < tol) break;
//plot([pT,pU],wait=1,clean=0);

}
plot([pt,pu],[pt,exact],[pt,fu],wait=1,cmm=" final fin");
plot([pT,pU],[pt,exact],[pt,fu],wait=1,cmm=" final grossier");
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


cout << "--------- file : aadaptation.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aadaptation.edp";
	real TESTaadaptation=regvalue;
		cout<<"aadaptation reference value = "<<REFaadaptation
				<<" test value ="<<TESTaadaptation<<endl;
			assert(TESTaadaptation<REFaadaptation*(1+0.1));
				assert(TESTaadaptation>REFaadaptation*(1-0.1));
};
;
cout << "--------- file : aalapacien.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalapacien.edp";
	real TESTaalapacien=1+err;
		cout<<"aalapacien reference value = "<<REFaalapacien
				<<" test value ="<<TESTaalapacien<<endl;
			assert(TESTaalapacien<REFaalapacien*(1+0.00001));
				assert(TESTaalapacien>REFaalapacien*(1-0.00001));
};
;
cout << "--------- file : aalaplace-nc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aalaplace-nc.edp";
	real TESTaalaplaceXnc=u[]'*u[];
		cout<<"aalaplace-nc reference value = "<<REFaalaplaceXnc
				<<" test value ="<<TESTaalaplaceXnc<<endl;
			assert(TESTaalaplaceXnc<REFaalaplaceXnc*(1+0.1));
				assert(TESTaalaplaceXnc>REFaalaplaceXnc*(1-0.1));
};
;
cout << "--------- file : aamove.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aamove.edp";
	real TESTaamove=u[]'*u[];
		cout<<"aamove reference value = "<<REFaamove
				<<" test value ="<<TESTaamove<<endl;
			assert(TESTaamove<REFaamove*(1+0.1));
				assert(TESTaamove>REFaamove*(1-0.1));
};
;
cout << "--------- file : aaRT.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "aaRT.edp";
	real TESTaaRT=u1[]'*u1[];
		cout<<"aaRT reference value = "<<REFaaRT
				<<" test value ="<<TESTaaRT<<endl;
			assert(TESTaaRT<REFaaRT*(1+0.1));
				assert(TESTaaRT>REFaaRT*(1-0.1));
};
;
cout << "--------- file : arrayoFVh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "arrayoFVh.edp";
	real TESTarrayoFVh=u[]'*u[];
		cout<<"arrayoFVh reference value = "<<REFarrayoFVh
				<<" test value ="<<TESTarrayoFVh<<endl;
			assert(TESTarrayoFVh<REFarrayoFVh*(1+0.1));
				assert(TESTarrayoFVh>REFarrayoFVh*(1-0.1));
};
;
cout << "--------- file : bilap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "bilap.edp";
	real TESTbilap=xx(0:n)'*xx(0:n);
		cout<<"bilap reference value = "<<REFbilap
				<<" test value ="<<TESTbilap<<endl;
			assert(TESTbilap<REFbilap*(1+0.1));
				assert(TESTbilap>REFbilap*(1-0.1));
};
;
cout << "--------- file : D2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "D2.edp";
	real TESTD2=w[]'*w[];
		cout<<"D2 reference value = "<<REFD2
				<<" test value ="<<TESTD2<<endl;
			assert(TESTD2<REFD2+1e-20);
				assert(TESTD2>REFD2-1e-20);
};
;
cout << "--------- file : demo1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo1.edp";
	real TESTdemo1=u[]'*u[];
		cout<<"demo1 reference value = "<<REFdemo1
				<<" test value ="<<TESTdemo1<<endl;
			assert(TESTdemo1<REFdemo1*(1+0.1));
				assert(TESTdemo1>REFdemo1*(1-0.1));
};
;
cout << "--------- file : demo.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "demo.edp";
	real TESTdemo=u[]'*u[];
		cout<<"demo reference value = "<<REFdemo
				<<" test value ="<<TESTdemo<<endl;
			assert(TESTdemo<REFdemo*(1+0.1));
				assert(TESTdemo>REFdemo*(1-0.1));
};
;
cout << "--------- file : funct.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "funct.edp";
	real TESTfunct=myfunction(1.0,3.);
		cout<<"funct reference value = "<<REFfunct
				<<" test value ="<<TESTfunct<<endl;
			assert(TESTfunct<REFfunct*(1+0.1));
				assert(TESTfunct>REFfunct*(1-0.1));
};
;
cout << "--------- file : lapacienprecon.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lapacienprecon.edp";
	real TESTlapacienprecon=u[]'*u[];
		cout<<"lapacienprecon reference value = "<<REFlapacienprecon
				<<" test value ="<<TESTlapacienprecon<<endl;
			assert(TESTlapacienprecon<REFlapacienprecon*(1+0.1));
				assert(TESTlapacienprecon>REFlapacienprecon*(1-0.1));
};
;
cout << "--------- file : lap_mat.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "lap_mat.edp";
	real TESTlapXmat=u1[]'*u1[];
		cout<<"lap_mat reference value = "<<REFlapXmat
				<<" test value ="<<TESTlapXmat<<endl;
			assert(TESTlapXmat<REFlapXmat*(1+0.1));
				assert(TESTlapXmat>REFlapXmat*(1-0.1));
};
;
cout << "--------- file : NSP1P1b.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1b.edp";
	real TESTNSP1P1b=int2d(Th)(square(u1)+square(u2));
		cout<<"NSP1P1b reference value = "<<REFNSP1P1b
				<<" test value ="<<TESTNSP1P1b<<endl;
			assert(TESTNSP1P1b<REFNSP1P1b*(1+0.2));
				assert(TESTNSP1P1b>REFNSP1P1b*(1-0.2));
};
;
cout << "--------- file : NSP1P1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P1.edp";
	real TESTNSP1P1=int2d(Th)(square(u1)+square(u2));
		cout<<"NSP1P1 reference value = "<<REFNSP1P1
				<<" test value ="<<TESTNSP1P1<<endl;
			assert(TESTNSP1P1<REFNSP1P1*(1+10));
				assert(TESTNSP1P1>REFNSP1P1*(1-10));
};
;
cout << "--------- file : NSP1P2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSP1P2.edp";
	real TESTNSP1P2=int2d(Th)(square(u1)+square(u2));
		cout<<"NSP1P2 reference value = "<<REFNSP1P2
				<<" test value ="<<TESTNSP1P2<<endl;
			assert(TESTNSP1P2<REFNSP1P2*(1+0.2));
				assert(TESTNSP1P2>REFNSP1P2*(1-0.2));
};
;
cout << "--------- file : parareal.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "parareal.edp";
	real TESTparareal=pu'*pu;
		cout<<"parareal reference value = "<<REFparareal
				<<" test value ="<<TESTparareal<<endl;
			assert(TESTparareal<REFparareal*(1+0.1));
				assert(TESTparareal>REFparareal*(1-0.1));
};
;

 cout << "--------- file : Richard.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "Richard.edp";
	real TESTRichard=hmax;
		cout<<"Richard reference value = "<<REFRichard
				<<" test value ="<<TESTRichard<<endl;
			assert(TESTRichard<REFRichard*(1+0.1));
				assert(TESTRichard>REFRichard*(1-0.1));
};
;

cout << "--------- file : teste.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "teste.edp";
	real TESTteste=P.x;
		cout<<"teste reference value = "<<REFteste
				<<" test value ="<<TESTteste<<endl;
			assert(TESTteste<REFteste*(1+0.1));
				assert(TESTteste>REFteste*(1-0.1));
};
;
cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};
;
cout << "--------- file : wafer-heating-laser-axi.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "wafer-heating-laser-axi.edp";
	real TESTwaferXheatingXlaserXaxi=xx'*xx;
		cout<<"wafer-heating-laser-axi reference value = "<<REFwaferXheatingXlaserXaxi
				<<" test value ="<<TESTwaferXheatingXlaserXaxi<<endl;
			assert(TESTwaferXheatingXlaserXaxi<REFwaferXheatingXlaserXaxi*(1+0.1));
				assert(TESTwaferXheatingXlaserXaxi>REFwaferXheatingXlaserXaxi*(1-0.1));
};
;
int n = 40;
mesh Th=square(n,n,[2*x-1,2*y-1]);
fespace Xh(Th,P2);
Xh x2=x^2,y2=y^2,xy=x*y;
Xh w,ww;

w=dxx(x2); cout << "dxx(x2) " << w[].max << " " << w[].min << endl;
w=dyy(y2); cout << "dyy(y2) " << w[].max << " " << w[].min << endl;
w=dyy(xy); cout << "dyy(xy) " << w[].max << " " << w[].min << endl;

w=dxy(xy); cout << "dxy(xy) " << w[].max << " " << w[].min << endl;
w=dyx(xy); cout << "dyx(xy) " << w[].max << " " << w[].min << endl;
w=dyx(x2); cout << "dyx(x2) " << w[].max << " " << w[].min << endl;
//  for regtest 
real regvalue=int2d(Th)(w*w);
// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(10,10);
fespace Vh2(Th,P2);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=1000;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
solve NS ([u1,u2,p],[v1,v2,q],solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.1;
int nbiter = 5;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.25^(1./nbiter);
nu=1./reylnods;   

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=50;i++)
   {
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
     cout << "CPU " << clock()-s0 << "s " << endl;     
   } 
 
  if (iter>= nbiter) break;
 
  Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],
              abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
// correct pressure sign 
// correct for LU solver a -1r6*p*q term  FH. mars/2018  Thank to armand.favrot@yahoo.fr
real s0=clock();
mesh Th=square(50,50);
fespace Vh2(Th,P1);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;
problem Pu1(u1x,vv,solver=CG) = int2d(Th)( u1x*vv) + int2d(Th)(-vv*u1);
problem Pu2(u2x,vv,solver=CG) = int2d(Th)( u2x*vv) + int2d(Th)(-vv*u2);

up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
solve NS ([u1,u2,p],[v1,v2,q],init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            - (dx(p)*dx(q)+dy(p)*dy(q))*(area/nu) // stabilization term (Change signe and value  jun 2020 FH.)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
            - 1e-6*p*q
			
           )
  + int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],value=1);

dt = 0.1;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.4;
real tol=0.05,coeftol = 0.5^(1./nbiter);
nu=0.01;   

for (iter=0;iter<nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=10;i++)
   { 
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps",value=1);  
     cout << "CPU " << clock()-s0 << "s " << " Th.nv " << Th.nv << endl;     
   } 
 
  if (iter>= nbiter) break;
 
  u1x=0;u1y=0;
  Pu1;Pu2;
  plot([u1x,u2x],wait=1);
  Th=adaptmesh(Th,[u1x,u2x],abserror=0,cutoff=cut,err=tol, inquire=0,nbvx=100000);
  u1=u1;
  u2=u2;
  p=p; 
  plot(Th);
  dt = dt*coefdt;
  if( Th.nv < 1000)
  {
  tol = tol *coeftol;
  cut = cut *coefcut;
  }
}
cout << "CPU " << clock()-s0 << "s " << endl;     
// Profiling script, adapted from
// examples/tutorial/NSUzawaCahouetChabart.edp
// (chosen for the large amount of graphics it displays)

// correct bug in CahuetChabard routine
// sign of pressure correct
// and change Bx, By in Bx' By' (back and forth) in  version>1.18
//  correction in CahouetChabard routine in version 1.26

assert(version>1.18); //  for big bug is non symetric matrix see HISTORY
real s0=clock();
mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;
real[int] pwork(p.n);

int i=0;
real one =1;
varf bx(u1,q) = int2d(Th,qforder=4)( dx(u1)*q );

varf by(u1,q) = int2d(Th,qforder=4)( dy(u1)*q );

varf a(u1,u2)= int2d(Th,qforder=4)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                   +  on(3,u1=1)  +  on(1,2,4,u1=0)  ;


varf vfMass(p,q) = int2d(Th)(p*q);
matrix MassMh=vfMass(Mh,Mh,solver=CG);
p[]=1;
ppp[]= MassMh*p[];
real aire = ppp[].sum;
cout << " area of Omega = " << aire << endl;
Xh bc1; bc1[] = a(0,Xh);
Xh b;

matrix A= a(Xh,Xh,solver=CG);
matrix Bx= bx(Xh,Mh); //  Mh corresponding to line and Xh to column
matrix By= by(Xh,Mh);
Xh bcx=(1-x)*x*4,bcy=0;
Xh b1=0,b2=0;  //  right hand side (0) for Stokes

func real[int] divup(real[int] & pp)
{
   pwork= MassMh*pp;
   cout << " pp moy = " << pwork.sum/aire << " " ;
   pp -= pwork.sum/aire;;
   b = b1; b[]  += Bx'*pp; b[] += bc1[] .*bcx[];
   u1[] = A^-1*b[];
   b = b2; b[]  += By'*pp; b[] += bc1[] .*bcy[];
   u2[] = A^-1*b[];
   ppp[]  =   Bx*u1[];
   ppp[] +=   By*u2[];
   pwork= MassMh*ppp[];
   cout << " moy = " << pwork.sum/aire << endl;
 //   ppp[] -=  pwork.sum/aire;
   return ppp[] ;
};


p=0;q=0;u1=0;v1=0;
//cout << " -------- A = " << A << endl;

LinearCG(divup,p[],q[],eps=1.e-6,nbiter=50);
divup(p[]);

plot([u1,u2],p,wait=0,value=true,coef=0.1);

real dt=0.05, alpha=1/dt;
if ( alpha > 1e30) exit(1);
real xnu=1./400.;
cout << " alpha = " << alpha << " nu = " << xnu << endl;
cout << "------------------------------------------ " << endl;
varf at(u1,u2)=   int2d(Th)( xnu*dx(u1)*dx(u2) + xnu*dy(u1)*dy(u2)  + u1*u2*alpha  )
               +  on(3,u1=1)  +  on(1,2,4,u1=0)  ;

A = at(Xh,Xh,solver=CG);
//cout << " -------- AA = " << AA << endl;

varf  vfconv1(uu,vv)  = int2d(Th,qforder=5) (convect([u1,u2],-dt,u1)*vv*alpha);
varf  vfconv2(v2,v1)  = int2d(Th,qforder=5) (convect([u1,u2],-dt,u2)*v1*alpha);
int idt;
real temps=0;

Mh pprec,prhs;

varf vfLap(p,q)  = int2d(Th)(dx(p)*dx(q) + dy(p)*dy(q) + p*q*1e-3);
matrix LapMh= vfLap(Mh,Mh,solver=Cholesky,factorize=true);

real[int] unMh(pprec.n);
pprec[]=1;
unMh = MassMh*pprec[];



func real[int]  CahouetChabart(real[int] & xx)
{   //  xx = \int (div u) w_i
   //   $ \alpha \Delta^{-1}  + \nu I $
   //   $ \alpha \LapMh ^{-1}  + \nu MassMh^-1 $
   real mxx= unMh'*xx;
   xx -= mxx*Th.area;
   pprec[]= LapMh^-1* xx;
   prhs[] =  MassMh^-1*xx;
   pprec[] = alpha*pprec[]+xnu* prhs[];
//   xx = LapMh*pprec[];
//   pprec[] -= xx.sum;
   return pprec[];
};

Xh up1,up2;
for (idt = 1; idt < 50; idt++)
 {
    up1=u1;
    up2=u2;
   temps += dt;
   cout << " --------- temps " << temps << " \n ";
   b1[] =  vfconv1(0,Xh);
   b2[] =  vfconv2(0,Xh);
   cout << "  min b1 b2  " << b1[].min << " " << b2[].min
        << "  max b1 b2  " << b1[].max << " " << b2[].max << endl;
   LinearCG(divup,p[],q[],eps=-1.e-6,nbiter=50,precon=CahouetChabart);
   divup(p[]);
   real errl2 = sqrt(int2d(Th)( (u1-up1)^2 + (u2-up2)^2 ) );
   cout << " errl2 " << errl2 << endl;
   plot([u1,u2],p,wait=0,value= 1,coef=0.1,cmm="[u1,u2],p || u^n+1 - u^n ]]_L2 ="+errl2);
   if (errl2 < 1e-4) break;
 }
//  -----  
real eps =  0.0001;
real h=1;
real hmin=0.05;
func f = 10.0*x*x*x+y*y*y+h*atan2(eps,sin(5.0*y)-2.0*x);

func fx = 30.0*x*x+h*2.0*eps/pow(sin(5.0*y)-2.0*x,2.0)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0));

func  fy =  3.0*y*y-h*5.0*eps/pow(sin(5.0*y)-2.0*x,2.0)*cos(5.0*y)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0));

func  fxy =  h*(-20.0*eps/pow(sin(5.0*y)-2.0*x,3.0)*cos(5.0*y)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0))
+20.0*eps*eps*eps/pow(sin(5.0*y)-2.0*x,5.0)*cos(5.0*y)/pow(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0),2.0));

func  fxx= 60.0*x+h*(8.0*eps/pow(sin(5.0*y)-2.0*x,3.0)/(1.0+eps*eps/pow(sin(5.0*y)
-2.0*x,2.0))-8.0*eps*eps*eps/pow(sin(5.0*y)-2.0*x,5.0)/pow(1.0+eps*eps/pow(sin(
5.0*y)-2.0*x,2.0),2.0));

func  d = fx*fy - fxy*fxy;
func  fyy= 6.0*y+h*(50.0*eps/pow(sin(5.0*y)-2.0*x,3.0)*pow(cos(5.0*y),2.0)/(1.0+
eps*eps/pow(sin(5.0*y)-2.0*x,2.0))+25.0*eps/pow(sin(5.0*y)-2.0*x,2.0)*sin(5.0*y
)/(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0))-50.0*eps*eps*eps/pow(sin(5.0*y)-2.0*x
,5.0)*pow(cos(5.0*y),2.0)/pow(1.0+eps*eps/pow(sin(5.0*y)-2.0*x,2.0),2.0));

border cercle(t=0,2*pi){ x=cos(t);y=sin(t);}
mesh Th=buildmesh(cercle(20));
fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P2);
Vh fh=f;
int i;
real coef=10;
for ( i=0;i<5;i++)
 {
 //  Th=adaptmesh(Th,f);
      verbosity=4;
      Th=adaptmesh(Th,fxx*coef,fxy*coef,fyy*coef,IsMetric=1,nbvx=10000,hmin=hmin);

   fh=f;
   Ph e=abs(fh-f);
   Vh dh=(d>0)*2-1;
   plot(Th,fh,dh,wait=1);
   plot(e,fill=1,value=1,wait=1);
   savemesh(Th,"Th"+i+".mesh");
   savemesh(Th,"Thh"+i,[x,y,fh/2]);
 {   ofstream file("Th"+i+".gbb");
   file << "2 1 1 "<< fh[].n << " 2 \n";
   int j;
   for (j=0;j<fh[].n ; j++)  {
     file << fh[][j] << endl; }
 }	
  if(!NoGraphicWindow)  exec("ffmedit `pwd`/Thh"+i);
 }
// Parameters
func f = 1;
func g = 0;

int nMeshAdapt = 5;	//Warning: higher value is time consuming and require `nbvx`>default value in `adaptmesh`

// Mesh
border aaa(t=0, 1){x=t; y=0; label=1;}
border bbb(t=0, 0.5){x=1; y=t; label=2;}
border ccc(t=0, 0.5){x=1-t; y=0.5; label=3;}
border ddd(t=0.5, 1){x=0.5; y=t; label=4;}
border eee(t=0.5, 1){x=1-t; y=1; label=5;}
border fff(t=0, 1){x=0; y=1-t; label=6;}
mesh Th = buildmesh(aaa(6) + bbb(4) + ccc(4) +ddd(4) + eee(4) + fff(6));
mesh Th2 = movemesh(Th,[x+1.1, y]);

// Fespace
fespace Vh(Th, P1);
Vh u, v, zero;

fespace Vh2(Th2, P2);
Vh2 u2, v2;

fespace Vh21(Th2, P1);
Vh21 dxu2, dyu2;

// Initialization
u = 0;
u2 = 0;
zero = 0;

// Problem
int i = 0;
problem Probem1(u, v, solver=CG, init=i, eps=-1.0e-6)
	= int2d(Th)(
		  dx(u)*dx(v)
		+ dy(u)*dy(v)
	) 
	+ int2d(Th)(
		  v*f
	)
	+ on(1, 2, 3, 4, 5, 6, u=g)
	;

problem Probem2(u2, v2, solver=CG, init=i, eps=-1.0e-6)
	= int2d(Th2)(
		  dx(u2)*dx(v2)
		+ dy(u2)*dy(v2)
	)
	+ int2d(Th2)(
		  v2*f
	)
	+ on(1, 2, 3, 4, 5, 6, u2=g)
	;

// Mesh adaptation loop
real cpu=clock();
real error = 0.1;
real coef = 0.1^(1./5.);
for (i = 0; i < 5; i++) { 
	cout << "Iteration " << i << endl;
	real d = clock();
	
	// Solve
	Probem1;
	Probem2;
	
	// Plot
	plot(Th, u, Th2, u2, wait=true);
	
	// Mesh adpatation
	Th = adaptmesh(Th, u, inquire=1, err=error);
	
	dxu2 = dx(u2);
	dyu2 = dy(u2);
	Th2 = adaptmesh(Th2, dxu2, dyu2, inquire=1, err=error, ratio=1.5, hmin=1e-5);

	cout << " CPU = " << clock()-d << endl;
	error = error * coef;
}

cout << " CPU = " << clock()-cpu << endl;

 // routine
func real myfunction(real a,real b)
{
   real z =a+b;
   return z;
};
{
real[int] matx(10),b(10),x(10); 
func real[int] mat(real[int] &x)
{ int i;
  for (i=0;i<x.n;i++)
    matx[i]=(i+1)*x[i];
  matx -= b; // sub the right hand side
  return matx;  // return of global variable ok 
};
func real[int] matId(real[int] &x) { return x;};
b=1; x=0; // set  right hand side and initial gest
LinearCG(mat,x,eps=1.e-6,nbiter=20,precon=matId);
cout << x;
  for (int i=0;i<x.n;i++)
    assert(abs(x[i]*(i+1) - b[i]) < 1e-5);
b=1; x=0; // set  right hand side and initial gest
NLCG(mat,x,eps=1.e-6,nbiter=20,precon=matId);
cout << x;
  for (int i=0;i<x.n;i++)
    assert(abs(x[i]*(i+1) - b[i]) < 1e-5);

};
 cout << myfunction(1.0,3.) << " " << myfunction(1,3)  << endl;
//   a array 
{
border a(t=0,1){x=t;y=0;};
border b(t=0,0.5){x=1;y=t;};
border c(t=0,0.5){x=1-t;y=0.5;};
border d(t=0.5,1){x=0.5;y=t;};
border e(t=0.5,1){x=1-t;y=1;};
border f(t=0,1){x=0;y=1-t;};
mesh th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
plot(th,wait=1,fill=1);

};
cout << (1==2) * 3. + (1==1)*4. << endl;

real [int] tab(10), tab1(10); // 2 array of 10 real 
//  real [int] tab2; //  bug 
tab = 1;  //  set all the array to 1
tab[1]=2;
cout << tab[1] << " " << tab[9] << " size of tab = " << tab.n << endl;
tab1=tab;
tab=tab+tab1;
tab=2*tab+tab1*5;
tab1=2*tab-tab1*5;
tab+=tab;
cout << tab << endl;
cout << tab[1] << " " << tab[9] <<  endl;
real [string] map; //  a dynamique array
cout << "-------------------------------------------------------------" << endl;
x=cos(0.1);
y=1.1;
z=2.1;
cout << z << " ==  " << P << endl;
{real z;
 func f=z+1;
z=1;
cout << " entre z=?" ;
//cin >> z;
cout << " z = " << z << " f=" << f << endl;};
{
mesh Th = square(5,5);
fespace Vh(Th); // P1
Vh uh;
uh=2*x+10*y; //  do P1 interpolation
x=0.5;
y=0.9;
real uhxy=uh; // get the value of uh at point (x,y)= 0.5,0.9
cout << "uh at (0.5,0.9) =" << uhxy << endl; 
};

{
  ofstream f("toto.txt");
  f << "coucou'\n";
};
{
  ofstream f("toto.txt",append);
  f << "add coucou'\n";
};


// no current mesh 

map["1"]=2.0;
map[2]=3.0; //  2 is automaticaly cast to the string "2"

cout << " map[\"1\"] = " << map["1"] << "; "<< endl;
cout << " map[2] = " << map[2] << "; "<< endl;
{
  real a,b,c;
  int i,j,k;  
};
string str,str1;
 str="abc+";
 str1="+abcddddd+";
 str=str + str1;
 str = str + 2 ;
cout << "str=  " << str << "== abc++abcddddd+2;\n";

real  x=3.14,y;
int  i,j;
complex c;

cout << " x = " << x << "\n";

x = 1;y=2;
x=y;

i=0;j=1;

cout << 1 + 3 << "\n";
cout << 10 ^10   << "\n";
cout << 10 ^-10   << "\n";
cout << -10^-2+5   << "== 4.99 \n";
cout << 10^-2+5    << "==  5.01 \n";
cout << "------------------ complex ---- \n" ;
cout << 10-10i   << " \n";
cout << " -1^(1/3) = " << (-1+0i)^(1./3.)   << " \n";
cout << " 8^(1/3)= " << (8)^(1./3.)   << " \n";
cout << " sqrt(-1) = " << sqrt(-1+0i) << " \n";

cout << " ++i =" <<  ++i ;
cout <<  " i=" << i << "\n";
cout << " i++ = "<< i++ << "\n";
cout << " i   = " << i << "\n";
cout << " for (i=0;i<10;i=i+1) \n";

for (int i=0;i<100;i=i+1)
  {
    if (i>=10) break;
    real a=i;
    tab[i] = i*i;
    if (i>5) continue;
    cout << i << " " << tab[i] << "\n";
  };
  
R3 P;
P.x=1;
x=P.x;
cout << P.x << "\n";  
verbosity=4;

mesh Th=square(10,10,[10*x,5*y]);
fespace Vh(Th,P1);

Vh u,v;

u=0;
func f= 0;
func g= 5*x+y;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
// exact solution  is g in this exemple : 
//  remark $dg/dn = -1$ on $Gamma_1$ (lower side)   $n=(0,-1)$ 
//  remark $dg/dn = 5$ on $Gamma_2$ (left side)   $n=(1,0)$ 
//  u + du/dn = g - 1 , because du
// $$ - \Delta u = 0,\quad  u_{|\Gamma_3 \cup \Gamma_4} = g, \frac{\partial u}{\partial n} + u = g-1 \mbox{on}\Gamma_4$$
problem Probem1(u,v,solver=LU,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int1d(Th,1) ( u*v )        //  $ \frac{\partial u}{\partial n} + u  = \ldots $
  + int1d(Th,1) ( (+1-g)*v)    //  $ \ldots  = g-1 $ 
  + int2d(Th) ( v*f )  
  + int1d(Th,2) (-5*v)  //  $ \frac{\partial u}{\partial n} = 5 $ 
  + on(3,4,u=g)  ;
  
real cpu=clock();
Probem1; // SOLVE THE PROBLEM 1
plot(u);
real err= sqrt( int2d(Th)( (u-g)^2) );
cout << "err L^2=" << err <<endl;
assert(err<1e-5); //  check the solution 
cout << " CPU = " << clock()-cpu << endl;
verbosity=1;
mesh Th=square(5,5);
fespace Vh(Th,P1);
Vh u,v;
real[int] X(9);  // array of 9 real
X=5; // fill X with 1
cout << "  norme^2 of X  " <<  sqrt(X' * X) <<  " == 15 \n";
Vh[int] uu(10);  // array of 10 solution 
/*  to do 
mesh[int] aTh(10); // array of 10 meshes 
aTh[1]= square(2,2);
*/ 
int i;
for ( i=0;i<10;i++)
 uu[i]=x+i*y; 

func f= 0;
func g= x*x+y*y*2;
u=0; 
// dcl the problem and solve
solve a(u,v,solver=CG) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(1,2,3,4,u=g+i); 

cout << "-------------------" << endl;  
plot(u);

// exemple de calcul de semi norme H_1
varf  lap(u,v)  = int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v) ); 
matrix A= lap(Vh,Vh);
cout <<  " (semi norme H^1)^2 of u =" << (v[]=A*u[])' * u[] << endl; 
cout <<  " (semi norme H^1)^2 of u =" << int2d(Th)(  dx(u)*dx(u) + dy(u)*dy(u) ) << endl; 

for ( i=0;i<10;i++)
 cout << "|x +"<< i <<"y|_H_1 = " << sqrt((v[]=A*uu[i][])' * uu[i][])  << endl;
// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(20,20);
  Th=adaptmesh(Th,1./20.,IsMetric=1,splitpbedge=1);
fespace Vh2(Th,P1b);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=400;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
solve NS ([u1,u2,p],[v1,v2,q],solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.05;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.5^(1./nbiter);
nu=1./reylnods;   

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=50;i++)
   {
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
     cout << "CPU " << clock()-s0 << "s " << endl;     
   } 
 
  if (iter>= nbiter) break;
   Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],splitpbedge=1,abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
 // routine
func int fi(real  a1)
{
   int i=a1*a1/1;
   return i;
}; 
func real myfunction(real a,real b)
{
   real aa=a;
   real z =fi(aa)+b;
   return z;
};
// appele 
cout << myfunction(1.0,3.) << " " << myfunction(1,3)  << endl;
// simulation of wafer heating by a laser.
/**************************************************************
From:  Fabian Dortu

Materials and Components Analysis group (MCA)
SPDT division

IMEC, Kapeldreef 75, B-3001 Leuven, Belgium
tel: +32/16 28 8774
e-mail: Fabian.Dortu@imec.be <mailto:Fabian.Dortu@imec.be> 
**************************************************************/
// The poisson equation (here the heat equation) is solved in cylindrical coordinates:
//   $ \Delta u = 1/r \partial_r(r \partial_r u) + \partial_{zz} u +  1/r^2 \partial_{\theta^2} u $
// so the variationnal formulation is after integer on the 3d cylinder 
// rotation invariant given $\partial_{\theta} u =0$
//  $ - \Delta u = f $
//  on the 1/2 plan $ \theta =0$ 
//  $ \int r ( \partial_r u \partial_r v + \partial_z u \partial_z v ) = \int r f v  - \int_{\Gamma} r \partial_n u v $  
//  the radial coordinate 'r' is called 'x'.
//  the depth coordinate 'z' is called 'y'.
// The wafer stuck is a rectangle with upper left corner at (0,0)
//  and lower right corner at (radius,-thickness)
// The laser beam it the surface from top to bottom at the center (0,0). 
// The units assumed for the distance is the micrometer (um)


//***********************
//*** User parameters ***
//***********************

real radius=1000;   // the wafer radius (um)
real thick=600;     // the wafer thickness (um)
real thC=1.5e-4;    // the thermal conductivity (W/K/um)
real beamr=2;     // the laser beam radius (in the sens of a gaussian)
real refl=0.55;     // reflection coefficient Air/Silicon
real Eg=1.12;       // Band gap of Silicon (eV)
real En=1.49;       // Energy of laser (eV) - must be greater than Eg.
real I0=1e-2;       // Laser beam intensity (W/um^2)
real alpha=0.2;     // absorption coefficient (um^-1)
func f=I0 * (1-refl) * (En-Eg)/En * alpha * exp(alpha*y) * exp(-x*x/beamr/beamr);
                    // the heat generation function: a laser beam of radius 'beamr'
                    // lateral shape is gaussian.
                    // in depth shape is decreasing exponential because of absorption.
real g=300;          // temperature at right and bottom surfaces (in Kelvin)

//********************************
//*** Geometry/Mesh definition ***
//********************************


//--- less basic mesh ---
border bottom1(t=0,radius/5) {x=t; y=-thick; label=1;}
border bottom2(t=radius/5,radius) {x=t; y=-thick; label=2;}
border right1(t=-thick,0) {x=radius; y=t; label=3;};  // 'right' actually means external surface
border top1(t=radius,radius/5*3) {x=t; y=0; label=4;};
border top2(t=radius/5*3,radius/5) {x=t; y=0; label=5;}
border top3(t=radius/5,0) {x=t; y=0; label=6;};
border left1(t=0,-thick/5) {x=0; y=t; label=7;}; // 'left' actually means center of cylinder
border left2(t=-thick/5,-thick) {x=0; y=t; label=8;}; // 'left' actually means center of cylinder
mesh Th = buildmesh ( bottom1(20) + bottom2(10) + right1(20) + top1(10) + top2(20) + top3(50) + left1(50) + left2(25) );

plot(Th,wait=1,fill=1,ps="wafer_mesh2.eps");
//savemesh(Th,"wafer_stuck.msh");


//**************************
//*** Problem definition ***
//**************************



fespace Vh(Th,P1);
Vh u,v,zero;

u=0;     // The temperature variable.
v=0;     // The weight function.
zero=0;  // used to set initial condition
int i=0; // variable used for mesh reconstruction
real error=0.1, coef=0.1^(1./5.);


//--- Variational Form ----
problem Problem1(u,v,solver=CG,init=i,eps=1.0e-8) =
int2d(Th) ( x*dx(u)*dx(v) + x*dy(u)*dy(v) )
  + int2d(Th) ( -v*x*f/thC )    // the source term = laser heating 
  + on( 1,2,3,u=g ) ;             // fixed temperature at bottom and right surface.



//*************
//*** Solve ***
//*************


real cpu=clock();

cout << "***USER*** " << "Begin solve/adapt iterations" << endl;

for (i=0;i<10;i++)
{
  cout << "***USER*** " << "Iteration number: " << i << endl;
  real d = clock();
  Problem1;
  plot(u,wait=1);
  Th=adaptmesh(Th,u,inquire=1,err=error);
  cout << " CPU = " << clock()-d << endl;

  error = error * coef;
  
} ;

plot(Th,wait=1,bb=[[0,0],[-10,-10]],nbiso=20,ps="adaptedmesh.eps"); // plot the last adapted mesh
plot(u,wait=1,bb=[[0,0],[-10,-10]],nbiso=20,ps="temperature.eps"); // plot the solution


//Plot a cut section at r=0
real[int] xx(10),yy(10);
for (i=0;i<10;i++)
{
  x=0.; y=i/10.; // this line is used by the next one 
  xx[i]=i;
  yy[i]=u; // value of u at point (0. , i/10.)
}

plot([xx,yy],ps="likegnu.eps",wait=true);


cout << " CPU = " << clock()-cpu << endl;
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
// build square $]-1,1[^2$
mesh Th2=square(2,2,[2*x-1,2*y-1]); 
mesh Th=square(100,100,[2*x-1,2*y-1]); 
fespace Wh(Th2,P0edge);
Wh w=0;

fespace Vh(Th,P1);

w[]=0;
w[][6]=1;
Vh u=w;

plot(u,Th2,wait=1);
   savemesh(Th,"mm",[x,y,u*.5]); //  save mm.points and mm.faces file for medit
   // build a mm.bb file 
	{ ofstream file("mm.bb"); 
	file << "2 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << u[][j] << endl; 
    }  
    // call ffmedit command 	
   if(!NoGraphicWindow) exec("ffmedit mm");
    // clean files
    exec("rm mm.bb mm.faces mm.points");
    


//  -----  
real eps =  0.0001;
real h=1;
real hmin=0.000005;
real val=50; 
real coef=50; // err = 1/100
int nbiter=10,firstplot=3;
func f = y*x*x+y*y*y+h*tanh(val*(sin(5.0*y)-2.0*x));
ofstream fff("err.dat");
cout << atanh(1) << endl;
func fx = .0*y*x-0.2E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val;
func fy =  x*x+3.0*y*y+0.5E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val*cos(0.5E1*y);

func  fxy =   2.0*(x*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)+10.0*h*val*val*cos(5.0*y)
		   *sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  fxx= 2.0*(y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-4.0*h*val*val
		*sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  d = fx*fy - fxy*fxy;
func  fyy=(6.0*y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-50.0*h*val*val*
	   pow(cos(5.0*y),2.0)*sinh(val*sin(5.0*y)-2.0*val*x)-25.0*h*val*sin(5.0*y)*cosh(val*
           sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);
           
border cercle(t=0,2*pi){ x=cos(t);y=sin(t);}
mesh Th=buildmesh(cercle(20));

fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P2);
Vh fh=f;
plot(fh,wait=0); //
real err;
for (int i=0;i<nbiter;i++)
{
  //  Th=adaptmesh(Th,f);
  verbosity=4;
  Vh fxxh=fxx, fxyh=fxy, fyyh = fyy;
  cout << " min max f_xx :  " <<  fxxh[].min << " " << fxxh[].max << endl;
  cout << " min max f_yy :  " <<  fyyh[].min << " " << fyyh[].max << endl;
  cout << " min max f_xy :  " <<  fxyh[].min << " " << fxyh[].max << endl;
  Th=adaptmesh(Th,f,err=0.1);
  fh=f;
  err=sqrt(int2d(Th)(square(fh-f)));
  fff  << i<< " " << err << " " << Th.nt << " " << Th.nv <<  endl;  
}
//  for regtest 
real regvalue=err;

mesh Th("torture.msh");
plot(Th,wait=1);
mesh Tb=square(200,40,[1-x*11,y]);
fespace Vb(Tb,P1);
fespace Pb(Tb,P0);
Vb b=chi(Th);
Pb xx=x, yy=y;
plot(b,wait=1);
searchMethod=1;
Vb bb= chi(Th);
bb[]-=b[];
assert( bb[].linfty==0); 	
{ include "funct.edp"; cout << " ---------- \n";  }
{ include "aamove.edp";  }
verbosity=4;
border a(t=0,1){x=t;y=0;label=1;};
border b(t=0,0.5){x=1;y=t;label=1;};
border c(t=0,0.5){x=1-t;y=0.5;label=1;};
border d(t=0.5,1){x=0.5;y=t;label=1;};
border e(t=0.5,1){x=1-t;y=1;label=1;};
border f(t=0,1){x=0;y=1-t;label=1;};
func uu= sin(y*pi)/10;
func vv= cos(x*pi)/10;

mesh Th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
Th=movemesh(Th,[x+uu,y+vv]);
plot(Th,wait=1,fill=1);
fespace Vh(Th,P2);

Vh u,v;

u=0;
func ff= 1;
func gg= 0;
int i=0;
problem Probem1(u,v,solver=LU,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*ff ) 
  + on(1,u=gg)  ;
  
real cpu=clock();
Probem1; // SOLVE THE PROBLEM 1
plot(u,wait=1);
cout << " CPU = " << clock()-cpu << endl;
border aaa(t=0,1){x=t;y=0;label=1;};
border bbb(t=0,0.5){x=1;y=t;label=2;};
border ccc(t=0,0.5){x=1-t;y=0.5;label=3;};
border ddd(t=0.5,1){x=0.5;y=t;label=4;};
border eee(t=0.5,1){x=1-t;y=1;label=5;};
border fff(t=0,1){x=0;y=1-t;label=6;};
mesh Th = buildmesh (aaa(6) + bbb(4) + ccc(4) +ddd(4) + eee(4) + fff(6));
// mesh Th2 = movemesh(Th,[x+1.1,y]);
fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace Vh2(Th,P2);
fespace Vh21(Th,P1);

Vh u,v,zero;
Vh2 u2,v2;
Vh21 dxu2,dyu2;
Ph eh;
u=0;
u2=0;
zero=0;
func f= 1;
func g= 0;
int i=0;
real error=0.1, coef= 0.1^(1./5.);
problem Probem1(u,v,solver=CG,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(1,2,3,4,5,6,u=g)  ;
  
problem Probem2(u2,v2,solver=CG,init=i,eps=-1.0e-6) =
    int2d(Th)(  dx(u2)*dx(v2) + dy(u2)*dy(v2)) 
  + int2d(Th) ( v2*f ) 
  + on(1,2,3,4,5,6,u2=g)  ;
  
real cpu=clock();

for (i=0;i< 10;i++)
{ 
  
  real d = clock();
  Probem1; 
  Probem2; 
  plot(Th,u,wait=1);
  eh= abs(u-u2);
  plot(Th,eh,fill=1,wait=1);
  
  Th=adaptmesh(Th,u,inquire=1,err=error,anisomax=1e6);
  
  cout << " CPU = " << clock()-d << endl;
  error = error * coef;
} ;

 cout << " CPU = " << clock()-cpu << endl;
load "Element_P1bl"
load "qf11to25"
// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(20,20);
  Th=adaptmesh(Th,1./20.,IsMetric=1,splitpbedge=1);
fespace Vh2(Th,P1bl);
fespace Vh(Th,P1);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=400;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
QF2 qf31 = tripleQF(qf1pT);
QF2 qf35 = tripleQF(qf5pT);
solve NS ([u1,u2,p],[v1,v2,q],init=i) =
    int2d(Th,qft=qf35)(
             alpha*( u1*v1 + u2*v2) )
    + int2d(Th,qft=qf31)(	     
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th,qft=qf35) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0) 
  + on(1,2,4,u1=0,u2=0) ;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.05;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.5^(1./nbiter);
nu=1./reylnods;   

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  for (i=0;i<=20;i++)
   {
     up1=u1;
     up2=u2;
     NS;
     if ( !(i % 10)) 
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
     cout << "CPU " << clock()-s0 << "s " << endl;     
   } 
 
  if (iter>= nbiter) break;
   Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],splitpbedge=1,abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
real regtest;// for FFCS regression tests
// exact solution is [x*x,y]  -Delta [x*x,y] = [-2,0]
// This exemple is buggus before version 1.26
{ 
// test of product of same FE
  verbosity = 2;
 mesh Th=square(2,2);
 fespace Vh(Th,P2);
 
 Vh uHx=0;
 Vh uHy=0;
 Vh vHx;
 Vh vHy;
 
 solve  deuxlap([uHx,uHy],[vHx,vHy],solver=CG) =
    int2d(Th)(    dx(uHx)*dx(vHx) + dy(uHx)*dy(vHx)
               +  dx(uHy)*dx(vHy) + dy(uHy)*dy(vHy)  )
    - int2d(Th)( -2* vHx )        
    +  on(1,2,3,4,uHx=x*x,uHy=y);
   // plot(uHx, uHy,wait=1);
    real err2= sqrt( int2d(Th)(square(uHx-x*x)+square(uHy-y)));
    cout << " Error in L2 norme " << err2 << endl ;
    assert(err2 < 1e-10);
}

{ 
// test of product of different  FE
verbosity = 2;
 mesh Th=square(2,2);
 fespace Vh(Th,P2);
 fespace Vh1(Th,P1);
 
 Vh uHx=0;
 Vh1 uHy=0;
 Vh vHx;
 Vh1 vHy;
 
 solve  deuxlap([uHx,uHy],[vHx,vHy],solver=CG) =
    int2d(Th)(    dx(uHx)*dx(vHx) + dy(uHx)*dy(vHx)
               +  dx(uHy)*dx(vHy) + dy(uHy)*dy(vHy)  )
    - int2d(Th)( -2* vHx )        
    +  on(1,2,3,4,uHx=x*x,uHy=y);
   // plot(uHx, uHy,wait=1);
    real err2= sqrt( int2d(Th)(square(uHx-x*x)+square(uHy-y)));
    cout << " Error in L2 norme " << err2 << endl ;
    assert(err2 < 1e-10);
    regtest=err2;
}
//  -----  
real eps =  0.0001;
real h=1;
real hmin=0.000005;
real val=10; 
real coef=50; // err = 1/100
int nbiter=6,firstplot=3;
func f = y*x*x+y*y*y+h*tanh(val*(sin(5.0*y)-2.0*x));

cout << atanh(1) << endl;
func fx = .0*y*x-0.2E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val;
func fy =  x*x+3.0*y*y+0.5E1*h*(1.0-pow(tanh(val*(sin(0.5E1*y)-0.2E1*x)),2.0))*val*cos(0.5E1*y);

func  fxy =   2.0*(x*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)+10.0*h*val*val*cos(5.0*y)
		   *sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  fxx= 2.0*(y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-4.0*h*val*val
		*sinh(val*sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);

func  d = fx*fy - fxy*fxy;
func  fyy=(6.0*y*pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0)-50.0*h*val*val*
	   pow(cos(5.0*y),2.0)*sinh(val*sin(5.0*y)-2.0*val*x)-25.0*h*val*sin(5.0*y)*cosh(val*
           sin(5.0*y)-2.0*val*x))/pow(cosh(val*sin(5.0*y)-2.0*val*x),3.0);
           
border cercle(t=0,2*pi){ x=cos(t);y=sin(t);}
mesh Th=buildmesh(cercle(20));

fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P2);
Vh fh=f;
plot(fh,wait=0); //

for (int i=0;i<nbiter;i++)
{
  //  Th=adaptmesh(Th,f);
  verbosity=4;
  Vh fxxh=fxx, fxyh=fxy, fyyh = fyy;
  cout << " min max f_xx :  " <<  fxxh[].min << " " << fxxh[].max << endl;
  cout << " min max f_yy :  " <<  fyyh[].min << " " << fyyh[].max << endl;
  cout << " min max f_xy :  " <<  fxyh[].min << " " << fxyh[].max << endl;
  Th=adaptmesh(Th,fxx*coef,fxy*coef,fyy*coef,IsMetric=1,nbvx=10000,hmin=hmin,ratio  = 5, 
	       nbsmooth = 0, omega = 1);
  fh=f;
  Ph e=log10(abs(fh-f));
  Vh dh=(d>0)*2-1;
  plot(Th,fh,dh);
  real[int] vviso(20);
  for (int i=0;i<20;i++)
    vviso[i]=(-20+i)/2.;
  cout << " min max fh " << fh[].min << " " << fh[].max << endl;  
  cout << " min max log(e) " << e[].min << " " << e[].max << endl;  

  if (i>=firstplot) 
    {
      plot(e,fill=1,value=1,wait=0,viso=vviso,cmm="log10(e) err="+1./coef);
      savemesh(Th,"Thh"+i+".mesh");
      savemesh(Th,"Th"+i,[x,y,fh/2]);
      { 
        Vh eh=e;
	ofstream file("Th"+i+".BB");
	file << "2 1 1 "<< fh[].n << " 2 \n";
	int j;
	for (j=0;j<fh[].n ; j++)  {
	  file << eh[][j] << endl; }
      }	
     if(!NoGraphicWindow) exec("ffmedit `pwd`/Th"+i);
    }
}
int n=100,nn=n+10;
real[int] xx(nn),yy(nn);

mesh Th=square(40,40);  // mesh definition of $\Omega$
fespace Vh(Th,P1);      // finite element space
macro laplacien(u,v) (dx(u)*dx(v)+dy(u)*dy(v)) // fin macro 
real f=1;
Vh u,uu,v,vv;

solve bilap([u,uu],[v,vv],solver=sparsesolver,eps=1.0e-6) =
    int2d(Th)(  laplacien(u,vv)+uu*vv //  - Delta u + uu =0 (vv)
    	         + laplacien(uu,v)  )     //  - Delta uu = 1 (v)
    	        
   - int2d(Th)(f*v)
   + on(1,2,3,4,u=0); // => v=0 also on 1,2,3,4
   
plot(u,wait=1);

for (int i=0;i<=n;i++)
 {
   xx[i]=real(i)/n;
   yy[i]=u(0.5,real(i)/n); // value of uh at point (0.5, i/10.) 
 }
 plot([xx(0:n),yy(0:n)],wait=1);

mesh Th=square(10,10);
fespace Vh(Th,P1nc);
Vh u,v;
u=0;
plot(u);
func f= 0;
func g= x*x+y*y*2;
u=0; 
int i=0;
// dcl the problem 
problem a(u,v,solver=CG,init=i) =
    int2d(Th)(  dx(u)*dx(v) + dy(u)*dy(v)) 
  + int2d(Th) ( v*f ) 
  + on(1,2,3,4,u=g+i); 
cout << "-------------------" << i << endl;  
i++;
a; //  solve  the problem 
cout << "-------------------" << endl;  
plot(u);
verbosity=4;

mesh Th=square(10,10,[10*x,5*y]);
fespace Vh(Th,RT0);
fespace Rh(Th,RT0Ortho);
fespace Ph(Th,P0);

Vh [u1,u2],[v1,v2];
Rh [r1,r2];
Ph p,q; 
cout << 1. / 2. << endl;
[u1,u2]= [1+x,2+y];
[r1,r2]= [-2-y,1+x];
//  verification of the finite function 
cout << "   [u1,u2]  = ["<< u1(1,2) << "," << u2(1,2) << "]  == [2,4] \n";
cout << "dx([u1,u2]) = ["<< dx(u1)(1,2) << "," << dx(u2)(1,2) << "]  == [1,0] \n";
cout << "dy([u1,u2]) = ["<< dy(u1)(1,2) << "," << dy(u2)(1,2) << "]  == [0,1] \n";
//  verification of the finite function 
cout << "   [r1,r2]  = ["<< r1(1,2) << "," << r2(1,2) << "]  == [-4,2] \n";
cout << "dx([r1,r2]) = ["<< dx(r1)(1,2) << "," << dx(r2)(1,2) << "]  == [0,1] \n";
cout << "dy([r1,r2]) = ["<< dy(r1)(1,2) << "," << dy(r2)(1,2) << "]  == [-1,0] \n";
 
plot(u1,u2,[u1,u2],wait=1);
plot(r1,r2,[r1,r2],wait=1);

problem Probem1(u1,u2,v1,v2,solver=LU,eps=-1.0e-6) =
    int2d(Th)(  u1*v1+u2*v2 + dx(u1)*v1+ u2*dx(v2)) 
  + int2d(Th) ( x*v1+y*v2 + v1 + y*dx(v2) ) 
  
  + on(1,2,3,4,u1=-x,u2=-y)  ;

problem Probem2(p,q,solver=LU,eps=-1.0e-6) =
    int2d(Th)(  p*q ) + int2d(Th) ( q ) 
  ;

cout << " probem 1 \n";
Probem1; // solve problem1
cout << " probem 2 \n";
Probem2; // solve problem2

plot(u1,u2,[u1,u2]);

problem lap(u1,u2,p,v1,v2,q,solver=LU,eps=1.0e-30) =
    int2d(Th)( p*q*1e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
    + int2d(Th) ( q)
   + int1d(Th)( (v1*N.x +v2*N.y)/-2);

cout << " lap RT \n";
    
lap;

plot([u1,u2],wait=1); 
   
plot(p,fill=1,wait=1);    
    
cout << " int2d(Th)(p-0.5) " << int2d(Th)(p-0.5) << "  == 0 " << endl;

cout << " int2d(Th)(x+y) " << int2d(Th)(x+y) << " ==  " << (10*5)*(10+5)/2 <<  endl;
cout << " -------------\n\n " << endl;
// meditddm.edp
load "medit"

/********************************************
 Initial Problem:
Resolution of the following EDP:
$- \Delta u = f$ on   $\Omega =\{ (x,y) |  1 \leq sqrt(x^2+y^2) \geq 2}$
$- \Delta u = f1$ on  $\Omega_{1} =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
$u = 1$ on $\Gamma$  +  Null Neumman condition on $\Gamma_{1}$ and on $\Gamma_{2}$	
We find the solution $u$ in solving two EDP defined on domain $\Omega$ and $\Omega_{1}$
This solution is vizualize with ffmedit 
*********************************************/
verbosity=3;

border Gamma(t=0,2*pi){x=cos(t); y=sin(t); label=1;};
border Gamma1(t=0,2*pi){x=2*cos(t); y=2*sin(t); label=2;};
border Gamma2(t=0,2*pi){x=0.5*cos(t); y=0.5*sin(t); label=3;};

// construction of mesh of domain $\Omega$
mesh Th=buildmesh(Gamma1(40)+Gamma(-40)); 

fespace Vh(Th,P2);
func f=sqrt(x*x+y*y);
Vh us,v;
macro Grad2(us) [dx(us),dy(us)]  // EOM

problem Lap2dOmega(us,v,init=false)=int2d(Th)(Grad2(v)' *Grad2(us)) - int2d(Th)(f*v)+on(Gamma,us=1) ;
//  Resolution of EDP defined on the domain $\Omega$
// $- \Delta u = f$ on $\Omega$ 
//      $u = 1$  on $\Gamma
//   + Null Neumann condition on $\Gamma_{1}$
Lap2dOmega;

// construction of mesh of domain $\Omega1 =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
mesh Th1=buildmesh(Gamma(40)+Gamma2(-40));

fespace Vh1(Th1,P2);
func f1=10*sqrt(x*x+y*y);
Vh1 u1,v1;
macro Grad21(u1) [dx(u1),dy(u1)]  // EOM

problem Lap2dOmega1(u1,v1,init=false)=int2d(Th1)(Grad21(v1)' *Grad21(u1)) - int2d(Th1)(f1*v1)+on(Gamma,u1=1) ;
//   Resolution of EDP defined on the domain $\Omega_{1}$
// $- \Delta u = f1$ on $\Omega_{1}$ 
//      $u = 1$ on $\Gamma$
//   + Null Neumann condition on $\Gamma_{2}$
Lap2dOmega1; 

// vizualisation of solution of the initial problem
medit("solution",Th,us,Th1,u1,order=1,meditff="ffmedit",save="testsavemedit.solb",wait=1);	
// test of mmg3d for move objets in a mesh ...
load "msh3" 
load "tetgen" 
load "medit" 
load "mmg3d-v4.0"                                                               
include "MeshSurface.idp"

// build mesh of a box (311)  wit 2 holes  (300,310)

real hs = 0.8; 
int[int]  N=[4/hs,8/hs,11.5/hs];
real [int,int]  B=[[-2,2],[-2,6],[-10,1.5]];
int [int,int]  L=[[311,311],[311,311],[311,311]];
meshS ThH = SurfaceHex(N,B,L,1);
meshS ThSg = Sphere(1,hs,300,-1); // "gluing" surface meshs to tolat boundary meshes
meshS ThSd = Sphere(1,hs,310,-1); 

plot (ThH,ThSg,ThSd);
ThSd=movemesh(ThSd,[x,4+y,z]);

meshS ThHS=ThH+ThSg+ThSd;
medit("ThHS", ThHS);

real voltet=(hs^3)/6.;
cout << " voltet = " << voltet << endl;
real[int] domaine = [0,0,-4,1,voltet];
real [int] holes=[0,0,0,0,4,0];
mesh3 Th = tetg(ThHS,switch="pqaAAYYQ",regionlist=domaine,holelist=holes);    
medit("Box-With-two-Ball",Th);
// End build mesh 

// int[int] opt=[9,0,64,0,0,3];   // options  of mmg3d see freeem++ doc 

real[int] vit=[0,0,-0.3];
func zero = 0.;
func dep  = vit[2];

fespace Vh(Th,P1); 
macro Grad(u) [dx(u),dy(u),dz(u)] //

Vh uh,vh; //  to compute the displacemnt field 
problem Lap(uh,vh,solver=CG) = int3d(Th)(Grad(uh)'*Grad(vh))  //') for emacs
				  + on(310,300,uh=dep) +on(311,uh=0.); 

for(int it=0; it<29; it++){ 
  cout<<"  ITERATION       "<<it<<endl;
  Lap;
  plot(Th,uh);
  Th=mmg3dv4(Th,opt="-O 9",displacement=[zero,zero,uh]); 
 }
verbosity=2;

mesh3 Th("dodecaedre01");
fespace Vh(Th,P23d);
func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func f= -18. ;
//Vh uhe = ue; // bug ..
//cout << " uhe min:  " << uhe[]. min << " max:" << uhe[].max << endl;
/*
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);


Vh u,v;

//uhe = ue;
macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)=int3d(Th)(Grad3(v)' *Grad3(u)) - int3d(Th)(f*v) + - int3d(Th)(f*v) + on(0,1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
cout << int3d(Th)(1.) << " = " << Th.measure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
Vh2 u2=u;
plot(u2,wait=1);
plot(u2,wait=1);
	{ ofstream file("dd.bb"); 
	file << "3 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << d[][j] << endl; 
    }  
*/
load "msh3"
load "medit"
searchMethod=1; // more safe seach algo .. (FH for PICHON ??) 
verbosity=1;
real a=1, d=0.5, h=0.5;
border b1(t=0.5,-0.5) {x=a*t; y=-a/2; label=1;};
border b2(t=0.5,-0.5) {x=a/2; y=a*t; label=2;};
border b3(t=0.5,-0.5) {x=a*t; y=a/2; label=3;};
border b4(t=0.5,-0.5) {x=-a/2; y=a*t; label=4;};
border i1(t=0,2*pi) {x=d/2*cos(t); y=-d/2*sin(t); label=7;};
int nnb=7, nni=10; 
mesh Th=buildmesh(b1(-nnb)+b3(nnb)+b2(-nnb)+b4(nnb)+i1(nni));//, fixedborder=true);
//Th=adaptmesh(Th,0.1,IsMetric=1,periodic=[[1,x],[3,x],[2,y],[4,y]]);
int nz=3;
{ // for cleanning  memory..
int[int] old2new(0:Th.nv-1);
fespace Vh2(Th,P1);
Vh2 sorder=x+y; 
sort(sorder[],old2new);
int[int]  new2old=old2new^-1;   // inverse the permuation 
//for(int i=0;i< Th.nv;++i) // so by hand. 
//  new2old[old2new[i]]=i;
Th= change(Th,renumv=new2old);
sorder[]=0:Th.nv-1;
}
{
  fespace Vh2(Th,P1);
  Vh2 nu;
  nu[]=0:Th.nv-1;
  plot(nu,cmm="nu=",wait=1);
}
int[int] rup=[0,5], rlow=[0,6], rmid=[1,1,2,2,3,3,4,4,7,7], rtet=[0,41];
func zmin=0;
func zmax=h;
mesh3 Th3=buildlayers(Th, nz, zbound=[zmin,zmax],
reftet=rtet,reffacemid=rmid, reffaceup=rup, reffacelow=rlow);
for(int i=1;i<=6;++i)
  cout << " int " << i << " :  " << int2d(Th3,i)(1.) << " " << int2d(Th3,i)(1./area) << endl;
savemesh(Th3,"Th3.mesh");
plot(Th3,wait=1);
medit("Th3",Th3);

fespace Vh(Th3,P2, periodic=[[1,x,z],[3,x,z],[2,y,z],[4,y,z],[5,x,y],[6,x,y]]);
verbosity=1;
load "msh3"
load "tetgen"
load "medit"
include "MeshSurface.idp"

mesh3 Th;
try {
  Th=readmesh3("Th-hex-sph.mesh");
 }
catch(...)
  { 
    real hs = 0.2;  // mesh size on sphere 
    int[int]  NN=[11,9,10];
    real [int,int]  BB=[[-1.1,1.1],[-.9,.9],[-1,1]];
    int [int,int]  LL=[[1,2],[3,4],[5,6]];
    
    ////////////////////////////////
    meshS ThHS = SurfaceHex(NN,BB,LL,1)+Sphere(0.5,hs,7,1); // "gluing" surface meshs to tolat boundary meshes
    real voltet=(hs^3)/6.;
    cout << " voltet = " << voltet << endl;
    real[int] domaine = [0,0,0,1,voltet,0,0,0.7,2,voltet];
    
    Th = tetg(ThHS,switch="pqaAYY",nbofregions=2,regionlist=domaine);    
    // Tetrahelize the interior of the cube with tetgen
    medit("tetg",Th,wait=1);
    savemesh(Th,"Th-hex-sph.mesh");
    // FFCS: testing 3d plots
    plot(Th,wait=1);
 }



fespace Ph(Th,P0);
verbosity=50;
fespace Vh(Th,P1,periodic=[[3,x,z],[4,x,z],[1,y,z],[2,y,z],[5,x,y],[6,x,y]]);// back and front
verbosity=1;
Ph reg=region;

cout << "  centre = " << reg(0,0,0) << endl;
cout << " exterieur = " << reg(0,0,0.7) << endl;

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

Vh uh,vh;
real x0=0.3,y0=0.4,z0=06;
func f= sin(x*2*pi+x0)*sin(y*2*pi+y0)*sin(z*2*pi+z0);
real gn = 1.;
real cf= 1;
problem P(uh,vh,solver=sparsesolver)=
     int3d(Th,1)( Grad(uh)'*Grad(vh)*100) 
  +  int3d(Th,2)( Grad(uh)'*Grad(vh)*2) 
  + int3d(Th) (vh*f)
//  + on(-1,uh=-1) + on(1,uh=1) 
//  + int2d(Th,2,-2)(vh*gn)
//  + int2d(Th,3,-3)(cf*vh*uh)
  ; 
  
  P;

plot(uh,wait=1, nbiso=6);
medit("   uh ",Th, uh,wait=1); 


verbosity=2;
mesh3 Th("dodecaedre01");
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);
int nbtets=Th.nt;
cout << " Th mes " << Th.measure << " border mes " << Th.bordermeasure << endl;
cout << " nb of Tets = " << nbtets << endl;
if(1) {
  nbtets=2;
  for (int i=0;i<nbtets;i++)
    for (int j=0; j <4; j++)
      cout << i << " " << j << " Th[i][j] = "
	   << Th[i][j] << "  x = "<< Th[i][j].x  << " , y= "<< Th[i][j].y 
	   << ",  label=" << Th[i][j].label << endl;
	    
//   Th(i)   return   the vextex i of Th
//   Th[k]   return   the tet k of Th.

  // get vertices information : 
  int nbvertices=Th.nv;
  //nbvertices=2;
  cout << " nb of vertices = " << nbvertices << endl;
  for (int i=0;i<nbvertices;i++)
	cout << "Th(" <<i  << ") : "   // << endl;	
	     << Th(i).x << " " << Th(i).y  << " " << Th(i).z << " " << Th(i).label // version 2.19 
	  << endl;
 // version >3.4-1
  // --------- new stuff -----------------
  int k=0,l=1,e=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the tet contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th[k].adj(e) ; // return adjacent tet to k by face e, and change the value of e to \hfilll
  // the corresponding face in the adjacent tet
  Th[k] == Th[k].adj(e) ;// non adjacent tet return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent tet 
  Th.be(k).N;   // return the Normal  of  boundary element k \hfilll
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2]) 
         << " " <<  int(Th[k][3])
	 << " , label  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<4;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N=" << Th.be(k).N << endl; 
    
	  
savemesh(Th,"dd.meshb");
 }
fespace Vh(Th,P23d);
Vh xx=x;
if(xx[].n == Th.nv)
  for(int i=0;i<Th.nv;++i)
    assert(abs(Th(i).x-xx[][i])<1e-6);

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func f= -18. ;
Vh u=f,b,d,uhe=ue,bc;
cout << " Vh.ndof =  " <<  Vh.ndof << endl;
cout << "  Vh.ndofK " << Vh.ndofK << endl;
cout << Th[5].region << endl;
// cout << Th(0,0,0).region << endl;  a faire ...
cout << Th[5][3] << endl;  // ok.. 


for(int i=0;i<Vh.ndofK;++i )
  cout << Vh(11,i) << " ";
 cout << endl;

cout << ue(0.1,0.2,0.3)<< "  == " << f(0.1,0.2,0.3) << endl; ;
macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

varf vbc(u,v) =  on(0,u=1);
varf vlap(u,v) = int3d(Th)(Grad3(v)' *Grad3(u)) + int3d(Th)(f*v) + on(0,u=ue);
varf vBord(u,v,solver=CG) = int2d(Th)(u*v) ;
verbosity=10; 
matrix A=vlap(Vh,Vh);
matrix B=vBord(Vh,Vh);
verbosity=1; 
b[]=vlap(0,Vh);
//bc[]=vbc(0,Vh);
//cout << bc[] <<endl;
{
ofstream fa("A.txt");
ofstream fb("B.txt");
fa << A ;
fb << b[] ;
}


cout << b[]. min << " " << b[].max << endl;
u[]=A^-1*b[];
cout << u[]. min << " " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
d= ue-u;
cout <<  " err = " << err <<  " " << d[].linfty << endl;
cout << " u (0,0,0) "<< u(0.,0.,0.) << endl;
cout << " dx(u) (0,0,0) "<< dx(u)(0.,0.,0.) << endl;
cout << " dy u (0,0,0) "<< dy(u)(0.,0.,0.) << endl;
cout << " dz u (0,0,0) "<< dz(u)(0.,0.,0.) << endl;
Vh2 u2=u(x,y,0.);
plot(u2,wait=1);
plot(u2,wait=1);
	{ ofstream file("dd.bb"); 
	file << "3 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << d[][j] << endl; 
    }  
//  example to build a mesh a cone 
load "msh3"
load "medit"
// cone using buildlayers with a triangle 
real LX=1,LY=1,LXY=sqrt(LX*LX+LY*LY),HH=1; 
border Hypo(t=1,0){x=LX*t;y=LY*(1-t);label=1;};
border Vert(t=LY,0){x=0;y=t;label=0;};
border Hori(t=0,LX){x=t;y=0;label=0;};

int nn=10;
real h= 1./nn;
plot(Vert(LY*nn)+ Hypo(LXY*nn) + Hori(LX*nn),wait=1);
mesh Th2=buildmesh( Vert(LY*nn)+ Hypo(LXY*nn) + Hori(LX*nn) ) ;
 Th2 = Th2 + movemesh(Th2,[x,-y])+ movemesh(Th2,[-x,-y])+  movemesh(Th2,[-x,y]);
plot(Th2,wait=1);
func fpyramide= (1-abs(x)/LX-abs(y)/LY)*HH;
fespace Vh2(Th2,P1);
Vh2 fp2=fpyramide;
plot(fp2,wait=1,dim=3);


int[int] r1T=[0,0], r2up=[0,1],r2down=[0,1];
int[int] r4T=[0,2]; 
mesh3 Th3=buildlayers(Th2,coef= max(fpyramide/HH,0.01), nn,zbound=[0,fpyramide],
 region=r1T, labelup=r2up, labeldown=r2down);

medit("Pyramide",Th3,wait=1);
// FFCS: testing 3d plots
plot(Th3);
load "msh3"
load "tetgen"
load "medit"
// Maillage d'un cylindre d'axe 0x
// 
int nx=10; // nombre de points le long de l'axe
int nth=50; // nombre de points sur la circonference
real xmin=1.,xmax=3.;
// Maillage de cercles pour les deux faces
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Thcercle = buildmesh(cc(nth));

// Maillage de carre qui va etre applique au bord du cylindre ave movemesh23
mesh Thcarre=square(nx,nth,[xmin+x*(xmax-xmin),2*pi*y]);
//plot(Thcarre);

// parametrisation d'un cylindre d'axe Ox
func f1 = x;
func f2 = cos(y);
func f3 = sin(y);
meshS Thsurf1=movemesh23(Thcarre,transfo=[f1,f2,f3],orientation=-1);
meshS Thsurf2=movemesh23(Thcercle,transfo=[xmin,x,y],orientation=-1);
meshS Thsurf3=movemesh23(Thcercle,transfo=[xmax,x,y],orientation=1);
meshS Thsurf=Thsurf1+Thsurf2+Thsurf3;
real voltet= ( ( (2*pi)/50 )^3 )/6.;
cout << "  voltet = " << voltet << endl;
real[int] domaine = [1.5,0.,0.,1,voltet];
mesh3 Th=tetg(Thsurf,switch="pqaaAAYYQ",nbofregions=1,regionlist=domaine);

savemesh(Th,"cyl.mesh");
medit("cyl",Th,wait=1);
// FFCS: testing 3d plots
plot(Th,cmm="cyl");
// first DG test case .. 
//  with just penalisation of jump ...
load "msh3"

macro grad(u) [dx(u),dy(u),dz(u)] //
macro dn(u) (N'*grad(u) ) //  def the normal derivative 

int nn=10; 
mesh3 Th= cube(nn,nn,nn); // unite square 

int[int] labs=labels(Th);
fespace Vh(Th,P1dc);     // Discontinous P1 finite element
real pena=1e5; // a paramater to add penalisation 

func f=1;
func g=1;
Vh u,v;
solve A(u,v,solver=sparsesolver) = 
  int3d(Th)( grad(u)'*grad(v))
+ intallfaces(Th)( pena*jump(u)*jump(v) ) 
- int2d(Th,labs)(pena*g*v)
+ int2d(Th,labs)(pena*u*v)
- int3d(Th)( f*v)
;

plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
mesh3 Th("dodecaedre01.mesh");
fespace Vh(Th,P23d);
Vh[int] u(10);
u[1]=x;
cout << " u[1].l2 =" << u[1][].l2 << endl;

{
load "msh3"
load "tetgen"
load "mshmet"
load "medit"
load "mmg"

int nn  = 6;

int[int] lc=[1,2,2,1,1,2]; //  label numbering 

mesh3 Th3=cube(nn,nn,nn,label=lc);
Th3 = trunc(Th3,(x<0.5) | (y < 0.5) | (z < 0.5) ,label=1);

fespace Vh(Th3,P1);
fespace Mh(Th3,[P1,P1,P1,P1,P1,P1]);
Vh u,v,usol,h3;
Mh [m11,m21,m22,m31,m32,m33];
macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

problem Poisson(u,v,solver=CG) = int3d(Th3)( Grad(u)'*Grad(v) )  // ') for emacs 
  -int3d(Th3)( 1*v ) + on(1,u=0);

real lerr=0.05;
verbosity=4;

for(int ii=0; ii<4; ii++) //  BUG trap  in interation 3 
{
  Poisson;
  plot(u,wait=1);
  h3=0;
  [m11,m21,m22,m31,m32,m33]=[0,0,0,0,0,0];
  cout <<" u min, max = " <<  u[].min << " "<< u[].max << endl;
  real cc=(u[].max-u[].min);// rescale coefficiant 
 
  real[int] met=mshmet(Th3,u,hmin=1e-3,hmax=0.2,err=lerr,aniso=1);
  m11[]=met;
//  savemesh(Th3,"oo/Th3.mesh");
//  savesol("oo/Th3.sol",Th3, [m11,m21,m22,m31,m32,m33]);
//  exec("mmg3d_O3 oo/Th3.mesh -sol oo/Th3.sol -hgrad 2.3 -bucket 700 -v 3");
  Th3=mmg3d(Th3,metric=m11[],hgrad=2.3);//("oo/Th3.o.mesh");
  
  lerr *= 0.6;// change the level of error
  cout << " Th3" << Th3.nv < " " << Th3.nt << endl;
   u=u;
  if(ii>3) medit("U-adap-iso-"+ii,Th3,u,wait=1);

}
cout <<"end Laplace  Adapt aniso 3d. edp " <<endl;


}
/*
  Exemple of homogenious Dirichket Boundary condition on some Edge in 3d ..
 in linear elasticity.
 The two edge are intersection of face with label 2,5 (resp.  4,5)
 
*/
load "msh3" 
mesh3 Th=cube(20,5,5,[x*4,y,z]);
fespace Wh(Th,[P2,P2,P2]) ;
// appuie simple sur les bord interfece face 5 et4 ( arete x == 0 )   et 5 et 2  et (x == 1) ( arete x == 0 ) 

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -100;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
Wh [u1,u2,u3],[v1,v2,v3];
varf von5([u1,u2,u3],[v1,v2,v3]) = on(5,u1=1,u2=1,u3=1);
varf von24([u1,u2,u3],[v1,v2,v3]) = on(2,4,u1=1,u2=1,u3=1);

Wh [au1,au2,au3];
{
	real[int] w5=von5(0,Wh, tgv=1); //  find dof on face 5 
	real[int] w24=von24(0,Wh, tgv=1); //  find dof on face 2 and 4 
	au1[] = w5 .* w24; // 1 do intersect  face 5 and 2 4 
	plot(au3,wait=1); // see for debugging 
}
// so array au1[] is non zero on dof on edges  (2,5) and (4,5)

varf  Lame([u1,u2,u3],[v1,v2,v3])=
  int3d(Th)(  
	     lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  + int3d(Th) (gravity*v3)
  
  ;

  matrix A = Lame(Wh,Wh,sym=1,positive=1,solver="CG");
  cout << " half "<< A.half << " nnz "<< A.nnz << endl; 
  real[int] b= Lame(0,Wh); 
  //  put tgv = -2 on matrix A 
  setBC(A,au1[],-2);   // 1 on diagonal and  0 on row  i et column i if  au1[][i] !=0  
  b =  au1[] ? 0 : b;
  set(A,solver= "CHOLMOD"); 
  cout << A.nnz << endl; 
   u1[] = A^-1*b;
 cout << " || u|| =" << u1[].linfty << endl;
 real cc = 0.5/u1[].linfty;
 mesh3 Thm = movemesh(Th,[x+u1*cc,y+u2*cc,z+u3*cc]) ;
 plot(Th,Thm,wait=1);
  

// file tetgenholeregion.edp
load "msh3"
load "tetgen"
load "medit"
//verbosity=2;

// Test 1

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},\frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
//plot(Th,wait=1);
medit("squaremesh",Th,wait=1);
plot(Th); // FFCS: testing 3d plots
verbosity=2;

// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

cout << "=====================" << endl;
cout << "=====================" << endl;
savemesh(Th,"Th.mesh");
meshS Th3sph=movemesh23(Th,transfo=[f1min,f2min,f3min],orientation=-1);
cout << "=====================" << endl;
cout << "=====================" << endl;
savemesh(Th3sph,"sphereR1.mesh");
medit("sphereR1",wait=1,Th3sph);
plot(Th3sph); // FFCS: testing 3d plots
real Rmax  = 2.;
func f1max = Rmax*f1;
func f2max = Rmax*f2;
func f3max = Rmax*f3;
cout << "=====================" << endl;
cout << "=====================" << endl;
meshS Th3sph2=movemesh23(Th,transfo=[f1max,f2max,f3max],orientation=1);
cout << "=====================" << endl;
cout << "=====================" << endl;
savemesh(Th3sph2,"sphereR2.mesh");
cout << "addition" << endl;
meshS Th3=Th3sph+Th3sph2;
savemesh(Th3,"sphereAdd.mesh");
medit("sphereSurfaceAdd",wait=1,Th3);
plot(Th3); // FFCS: testing 3d plots


real[int] domain2 = [1.5,0.,0.,145,0.001,0.5,0.,0.,18,0.01];
cout << "==============================" << endl;
cout << " tetgen call without hole " << endl;
cout << "==============================" << endl;
mesh3 Th3fin=tetg(Th3,switch="paAAYYCCV",nbofregions=2,regionlist=domain2);
cout << "=============================" << endl;
cout << "finish: tetgen call without hole" << endl;
cout << "=============================" << endl;
savemesh(Th3fin,"spherewithtworegion.mesh"); 
medit("spherewithtworegion",wait=1,Th3fin);
plot(Th3fin); // FFCS: testing 3d plots

real[int] hole = [0.,0.,0.];
real[int] domain = [1.5,0.,0.,53,0.001];
cout << "=============================" << endl;
cout << "  tetgen call with hole   " << endl;
cout << "=============================" << endl;
mesh3 Th3finhole=tetg(Th3,switch="paAAYCCV",nbofholes=1,holelist=hole,nbofregions=1,regionlist=domain);
cout << "=============================" << endl;
cout << "finish: tetgen call with hole   " << endl;
cout << "=============================" << endl;
savemesh(Th3finhole,"spherewithahole.mesh"); 
medit("spherewithahole",wait=1,Th3finhole);
plot(Th3finhole); // FFCS: testing 3d plots




bool withmetis=1;
bool RAS=0;
int sizeoverlaps=2; // size off overlap 
int nnx=2,nny=2,nnz=2;

func bool AddLayers(mesh3 & Th,real[int] &ssd,int n,real[int] &unssd)
{
  //  build a continuous function  uussd (P1) :
  //  ssd in the caracteristics function on the input sub domain.
  //  such that : 
  //   unssd = 1 when   ssd =1;
  //   add n layer of element (size of the overlap)
  //   and unssd = 0 ouside of this layer ...
  // ---------------------------------
  fespace Vh(Th,P1);
  fespace Ph(Th,P0);
  Ph s;
  assert(ssd.n==Ph.ndof);
  assert(unssd.n==Vh.ndof);
  unssd=0;
  s[]= ssd;
  //  plot(s,wait=1,fill=1);
  Vh u;
  varf vM(u,v)=int3d(Th,qforder=1)(u*v/volume);
  matrix M=vM(Ph,Vh);
  
  for(int i=0;i<n;++i)
    {
      u[]= M*s[];
      // plot(u,wait=1);
      u = u>.1; 
      // plot(u,wait=1);
      unssd+= u[];
      s[]= M'*u[];//';
      s = s >0.1;
    }
  unssd /= (n);
  u[]=unssd;
  ssd=s[];      
  return true;
}

int withplot=3;
include "cube.idp" 
 int[int]  NN=[25,25,25]; //  the number of step in each  direction                                                                                                                    
 real [int,int]  BB=[[0,1],[0,1],[0,1]]; // bounding box                                                                                                             
 int [int,int]  L=[[1,1],[1,1],[1,1]]; // the label of the 6 face left,right,
//  front, back, down, right
mesh3 Th=Cube(NN,BB,L);
int npart= nnx*nny*nnz;
fespace Ph(Th,P0);
fespace Vh(Th,P1);

Ph  part;
Vh  sun=0,unssd=0;
Ph xx=x,yy=y,zz=z,nupp;
//part = int(xx*nnx)*nny + int(yy*nny);
part = int(xx*nnx)*nny*nnz + int(yy*nny)*nnz + int(zz*nnz);
//plot(part,wait=1);
if(withmetis)
  {
    load "metis";
    int[int] nupart(Th.nt);
    metisdual(nupart,Th,npart); 
    for(int i=0;i<nupart.n;++i)
      part[][i]=nupart[i];
  }
if(withplot>1)
plot(part,fill=1,cmm="dual",wait=1);
mesh3[int] aTh(npart);
mesh3 Thi=Th;
fespace Vhi(Thi,P1);
Vhi[int] au(npart),pun(npart);
matrix[int] Rih(npart);
matrix[int] Dih(npart);
matrix[int] aA(npart);
Vhi[int] auntgv(npart);
Vhi[int] rhsi(npart);

for(int i=0;i<npart;++i)
  {
    Ph suppi= abs(part-i)<0.1;
    AddLayers(Th,suppi[],sizeoverlaps,unssd[]);
    Thi=aTh[i]=trunc(Th,suppi>0,label=10,split=1);
    Rih[i]=interpolate(Vhi,Vh,inside=1); //  Vh -> Vhi
    if(RAS)
      {
        suppi= abs(part-i)<0.1;
        varf vSuppi(u,v)=int3d(Th,qforder=1)(suppi*v/volume);
        unssd[]= vSuppi(0,Vh);
        unssd = unssd>0.;
        if(withplot>19)
          plot(unssd,wait=1);
      }
    pun[i][]=Rih[i]*unssd[];
    sun[] += Rih[i]'*pun[i][];//';
    if(withplot>9)
      plot(part,aTh[i],fill=1,wait=1);
  }
real[int] viso=[0,0.1,0.2,0.3];  
plot(sun,wait=1,dim=3,fill=1,viso=viso);
for(int i=0;i<npart;++i)
  {
    Thi=aTh[i];
    pun[i]= pun[i]/sun;
    if(withplot>8)
      plot(pun[i],wait=1);    
  }

//  verif partition of unite 

macro Grad(u) [dx(u),dy(u),dz(u)]//EOM 
  sun=0;

for(int i=0;i<npart;++i)
  {
    cout << " build part :" << i << "/" << npart << endl;
    Thi=aTh[i];
    varf va(u,v) = 
      int3d(Thi)(Grad(u)'*Grad(v))//')
      +on(1,u=1) + int3d(Thi)(v)
      +on(10,u=0) ; 
    
    cout << i << " -----------Vhi.ndof " << Vhi.ndof << endl;
    aA[i]=va(Vhi,Vhi);
      cout << i << " -----------Vhi.ndof " << Vhi.ndof << endl;
  
    set(aA[i],solver="SPARSESOLVER");
    rhsi[i][]= va(0,Vhi);
    Dih[i]=pun[i][];
    real[int]  un(Vhi.ndof);
    un=1.;
    real[int] ui=Dih[i]*un; 
    sun[] += Rih[i]'*ui;;//';
    varf vaun(u,v) = on(10,u=1);
    auntgv[i][]=vaun(0,Vhi); // store array of tgv on Gamma intern.
  }
if(withplot>5)
  plot(sun,fill=1,wait=1);
cout << sun[].max << " " << sun[].min<< endl;
// verification of the partition of the unite.
assert( 1.-1e-9 <= sun[].min  && 1.+1e-9 >= sun[].max);  

int nitermax=1000;
{
  Vh un=0;
  for(int iter=0;iter<nitermax;++iter)
    {
      real err=0;
      Vh un1=0;
      for(int i=0;i<npart;++i)
        {
          Thi=aTh[i];
          real[int] ui=Rih[i]*un[];//';
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          real[int] bi = ui .* auntgv[i][];
          bi = auntgv[i][] ? bi :  rhsi[i][];  
          ui=au[i][];
          ui= aA[i] ^-1 * bi;
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          bi = ui-au[i][];
          err += bi'*bi;//';
          au[i][]= ui;
          bi = Dih[i]*ui;
          un1[] += Rih[i]'*bi;//';
        }
      err= sqrt(err);
      cout << iter << " Err = " << err << endl;
      if(err<1e-3) break;
      //    plot(un1,wait=1);
      un[]=un1[];
      if(withplot>2)
        plot(au,dim=3,wait=0,cmm=" iter  "+iter,fill=1 );
    }
  plot(un,wait=1,dim=3,fill=1);
}
// build de mesh of a Sphere
// -------------------------- 
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  de  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;
real[int] domaine =[0.,0.,0.,1,0.01];
mesh3 Th3=tetgtransfo(Th,transfo=[f1,f2,f3],nbofregions=1,regionlist=domaine);
//savemesh(Th3,"sphere.meshb");
medit("sphere",Th3);

// FFCS - check 3D plots
plot(Th3,cmm="sphere");

fespace Vh(Th3,P23d);
func ue =   2*x*x + 3*y*y + 4*z*z+ 5*x*y+6*x*z+1;
func f= -18. ;
Vh uhe = ue; // bug ..
cout << " uhe min:  " << uhe[].min << " max:" << uhe[].max << endl;
cout << uhe(0.,0.,0.) << endl;


//savesol("f3.sol",Th3,ue,ue,[f,ue,f],order=1);
//int bb=meditmeshsol("sol",Th3,solution=1,scalar=uhe);


border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)=int3d(Th3)(Grad3(v)' *Grad3(u)) - int3d(Th3)(f*v) + on(0,1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th3)( square(u-ue) );
cout << int3d(Th3)(1.) << " = " << Th3.measure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
Vh2 u2=u,u2e=ue;
plot(u2,wait=1);
plot(u2,u2e,wait=1);

// FFCS - check 3D plots
plot(u);

assert(err < 1e-9);
load "msh3"

mesh3 Th=cube(1,1,1);

  // --------- new stuff -----------------
  int k=0,l=1,e=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th.be(k).measure ;   // return the measure of be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  Th[k].measure ; // return  the measure of element k \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int i=0;i<Th.nv;++i)
  cout << i << " : "  << Th(i).x << " "<< Th(i).y << " " << Th(i).z  << endl; 
 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2])<< " " <<  int(Th[k][2])
	 << " , label/ region  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<4;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " " << Th.be(k)[2]  << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 
R3 O(0.5,0.5,0.5);
real ss =0;
 for (int k=0;k<nbboundaryelement;++k)
  ss += solidangle(O,Th.be(k));
 cout << " solid angle = " << ss << " == 4*pi == " << 4*pi << endl;
 assert( abs(ss-4*pi) < 1e-9);
 
 {
 Th = cube(3,3,3);
 func real f(R3 A)
 {
    assert(nuFace>=0); 	 
    cout << "P "<< P << " " << nuTriangle << " " << nuFace << " A = "<< A << endl;
    return solidangle(A,Th[nuTet],nuFace)/area;
 }
 cout << " integral " << int2d(Th,qforder=1)(f(O) )<< " " << 4*pi <<  endl; 
}
load "msh3" load "tetgen" load "mshmet" load "medit"
//build initial mesh
int nn  = 6;
int[int] l1111=[1,1,1,1],l01=[0,1],l11=[1,1];//   label numbering 
mesh3 Th3=buildlayers(square(nn,nn,region=0,label=l1111),
      nn,  zbound=[0,1],  labelmid=l11,   labelup = l01,  labeldown = l01);
Th3 = trunc(Th3,(x<0.5) | (y < 0.5) | (z < 0.5) ,label=1);// remove the $]0.5,1[^3 cube$
//end of build initial mesh
fespace Vh(Th3,P1);
Vh u,v,usol;

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

problem Poisson(u,v,solver=CG) = int3d(Th3)( Grad(u)'*Grad(v) )  // ') for emacs 
  -int3d(Th3)( 1*v ) + on(1,u=0);

real errm=1e-2;// level of error 

for(int ii=0; ii<5; ii++)
{
  Poisson;
  cout <<" u min, max = " <<  u[].min << " "<< u[].max << endl;
  Vh h ;
  h[]=mshmet(Th3,u,normalization=1,aniso=0,nbregul=1,hmin=1e-3,hmax=0.3,err=errm);//loptions=MSHloptions,doptions=MSHdoptions);
  cout <<" h min, max = " <<  h[].min << " "<< h[].max << " " << h[].n << " " << Th3.nv << endl;
  // FFCS: add 3D view parameters
  plot(u,wait=1,fill=0,boundary=0,CutPlane=0,ShowMeshes=1,LabelColors=0);
  errm*= 0.8;// change the level of error
  cout << " Th3" << Th3.nv < " " << Th3.nt << endl;
  Th3=tetgreconstruction(Th3,switch="raAQ",sizeofvolume=h*h*h/6.);
  medit("U-adap-iso-"+ii,Th3,u,wait=1);
}



load "msh3"

int nn=8;

mesh Th2=square(nn,nn,[x*2.-1.,y*2.-1.]);
fespace Vh2(Th2,P1);
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=-1,zmax=1.;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
func  real hill(real r2){return exp(-10.*(r2));};

fespace Vh(Th,P13d);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

Vh v,vo;
Vh2 v2;
real x0=0.3,y0=0.3,z0=0;
vo=hill(square(x-x0)+square(y-y0)+square(z-z0));

real t=0;
v2=vo(x,y,0);
plot(v2,cmm=" cut y = 0.5, time ="+t,wait=1);
real dt=0.1;
func u1=1.;
func u2=2.;
func u3=3.;
verbosity = 1;
v=convect([u1,u2,u3],-dt,vo);
verbosity = 1;
v2=v(x,y,0);
t += dt;
plot(v2,cmm=" cut y = 0.5, time ="+t,wait=1);
// verification ...
int err=0; 
macro Verif(w,val)
{
   real so= int3d(Th)(vo);
   real soi= int3d(Th)(vo*w);
   real sv= int3d(Th)(v);
   real svi= int3d(Th)(v*w);

   cout  << Stringification(w) << "  old " <<  soi/so << " new " << svi/sv << " delta " << (svi/sv  - soi/so )/dt << " ~ " <<  val << endl; 
   err += (abs((svi/sv  - soi/so )/dt - val)> 0.2);
}   
//EOF

Verif(x,1)
Verif(y,2)
Verif(z,3)     
assert(err==0);
 
// F. HECHT example to check eps in trunc check mesh

load "msh3"
real theta = 1*pi/180.; // 0.7 degree  limit to build the 2d mesh if no refinement in zero
real xt = cos(theta),yt=sin(theta);
cout << xt << " " << yt << endl;
border C(t=theta, 2*pi-theta) { x = cos(t); y=sin(t); label=1;}
border Ss(t=0,1;i){ t= t; x= t*xt; y = t*yt;if(i) y = -y; label=2+i;}
real hs = 0.05;
int nC = (2*pi-2*theta)/hs;
int ns = (1./hs)/1;//   
int[int] nS=[ ns,-ns ];
func bord = C(nC)+Ss(nS); 
plot(bord,wait=1);
mesh Th2 = buildmesh(bord,nbvx=1000000);
plot(Th2);
int nt,nv; 
nt = Th2.nt;
nv = Th2.nv;
Th2=trunc(Th2,1);// verif to close point
assert(nt==Th2.nt);
assert(nv==Th2.nv);


mesh3 Th = buildlayers(Th2,1./hs);
plot(Th,wait=1);
 nt = Th.nt;
 nv = Th.nv;
// check mesh
Th=checkmesh(Th);
assert(nt==Th.nt);
assert(nv==Th.nv);
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.
cout << "--------- file : 3d-Leman.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "3d-Leman.edp";
	real TEST3dXLeman=vregtest;
		cout<<"3d-Leman reference value = "<<REF3dXLeman
				<<" test value ="<<TEST3dXLeman<<endl;
			assert(TEST3dXLeman<REF3dXLeman*(1+0.1));
				assert(TEST3dXLeman>REF3dXLeman*(1-0.1));
};



verbosity=1;
load "msh3"
load "tetgen"
load "medit"

 
// 
meshS ThHex;
real volumetet;  // use in tetg.
{
	//  first  build the 6 faces of the hex.
real x0=-1,x1=1;
real y0=-1.1,y1=1.1;
real z0=-1.2,z1=1.2;

int nx=19,ny=20,nz=21;
//  a  volume  of  on tet. 
volumetet= (x1-x0)*(y1-y0)*(z1-z0)/ (nx*ny*ny) /6.;

mesh Thx = square(ny,nz,[y0+(y1-y0)*x,z0+(z1-z0)*y]);
mesh Thy = square(nx,nz,[x0+(x1-x0)*x,z0+(z1-z0)*y]);
mesh Thz = square(nx,ny,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

int[int] refz=[0,5];  //  bas
int[int] refZ=[0,6];   //  haut
int[int] refy=[0,3];  //  devant
int[int] refY=[0,4];   // derriere
int[int] refx=[0,1];  // gauche
int[int] refX=[0,2];   // droite 


meshS Thx0 = movemesh23(Thx,transfo=[x0,x,y],orientation=-1,region=refx,removeduplicate=false); 
meshS Thx1 = movemesh23(Thx,transfo=[x1,x,y],orientation=1,region=refX,removeduplicate=false);
meshS Thy0 = movemesh23(Thy,transfo=[x,y0,y],orientation=+1,region=refy,removeduplicate=false);
meshS Thy1 = movemesh23(Thy,transfo=[x,y1,y],orientation=-1,region=refY,removeduplicate=false);
meshS Thz0 = movemesh23(Thz,transfo=[x,y,z0],orientation=-1,region=refz,removeduplicate=false);
meshS Thz1 = movemesh23(Thz,transfo=[x,y,z1],orientation=+1,region=refZ,removeduplicate=false);

//medit("  --- ", Thx0,Thx1,Thy0,Thy1,Thz0,Thz1);
 ThHex = Thx0+Thx1+Thy0+Thy1+Thz0+Thz1;
 
}
meshS Thsph; // 

{
mesh  Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a paratrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  de  partiel derivatrive of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  // to store the periodic condition 

// the intial mesh
savemesh(Th,"sphere",[f1,f2,f3]);

real R=0.5,hh=0.1/R;// hh  taille du maille sur la shere unite. 
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,inquire=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);

Thsph = movemesh23(Th,transfo=[f1*R,f2*R,f3*R],orientation=-1,removeduplicate=false);
}


////////////////////////////////
meshS ThS = ThHex+Thsph; // "gluing" surface meshs to tolat boundary meshes
medit("Bounday mesh",ThS,wait=1);

// build a mesh of a axis parallel box with TetGen

real[int] domaine = [0,0,0,1,volumetet,0,0,0.7,2,volumetet];
mesh3 Th = tetg(ThS,switch="pqaAAYYQ",nbofregions=2,regionlist=domaine);    
// Tetrahelize the interior of the cube with tetgen
medit("tetg",Th,wait=1);
savemesh(Th,"Th-hex-sph.mesh");

fespace Ph(Th,P03d);
fespace Vh(Th,P13d);
Ph reg=region;

cout << "  centre = " << reg(0,0,0) << endl;
cout << " exterieur = " << reg(0,0,0.7) << endl;

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

Vh uh,vh;
real f=1.;
real gn = 1.;
real cf= 1;
problem P(uh,vh)=
   int3d(Th,1)( Grad(uh)'*Grad(vh)*100) 
  +  int3d(Th,2)( Grad(uh)'*Grad(vh)*2) 
  + int3d(Th) (vh*f)
  + on(-1,uh=-1) + on(1,uh=1) 
  + int2d(Th,2,-2)(vh*gn)
  + int2d(Th,3,-3)(cf*vh*uh)
  ; 
  
  P;
  
// FFCS: with 3D view parameters
real[int] CameraPositionValue = [3.50634,-2.51489,2.60313];
real[int] CameraFocalPointValue = [0.0604689,-0.304636,-0.256484];
real[int] CameraViewUpValue = [0.7198,0.502367,-0.479078];
real[int] CutPlaneOriginValue = [-0.5,-0.55,0.0335184];
real[int] CutPlaneNormalValue = [0,0,1];
plot(uh,wait=1, nbiso=6,
	BorderAsMesh = 1,
	CameraPosition=CameraPositionValue,
	CameraFocalPoint=CameraFocalPointValue,
	CameraViewUp=CameraViewUpValue,
	CutPlaneOrigin=CutPlaneOriginValue,
	CutPlaneNormal = CutPlaneNormalValue);
medit("   uh ",Th, uh,wait=1); 


// file adaptsphere.edp
load "msh3"
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

meshS ThS=movemesh23(Th,transfo=[f1min,f2min,f3min]);

real[int] domain = [0.,0.,0.,145,0.01];
mesh3 Th3sph=tetg(ThS,switch="paAAQYY",nbofregions=1,regionlist=domain);

int[int] newlabel = [145,18];
real[int] domainrefine = [0.,0.,0.,145,0.0001];
mesh3 Th3sphrefine=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel,nbofregions=1,regionlist=domainrefine,sizeofvolume=0.0001);

int[int] newlabel2 = [145,53];
func fsize = 0.01/(( 1 + 5*sqrt( (x-0.5)^2+(y-0.5)^2+(z-0.5)^2) )^3);
mesh3 Th3sphrefine2=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel2,sizeofvolume=fsize);

 medit("sphere",Th3sph,wait=1);
 medit("sphererefinedomain",wait=1,Th3sphrefine);
  medit("sphererefinelocal",wait=1,Th3sphrefine2);

// FFCS: testing 3d plots
plot(Th3sph);
plot(Th3sphrefine);
plot(Th3sphrefine2);
load "medit"
include "cube.idp"
int[int]  Nxyz=[20,5,5];
real [int,int]  Bxyz=[[0.,5.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,2],[2,2],[2,2]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
  
solve Lame([u1,u2,u3],[v1,v2,v3])=
  int3d(Th)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  - int3d(Th) (gravity*v3)
  + on(1,u1=0,u2=0,u3=0)
  ;
real dmax= u1[].max;
cout << " max deplacement = " << dmax << endl;
real coef= 0.1/dmax;
int[int] ref2=[1,0,2,0];
mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2);
Thm=change(Thm,label=ref2);
plot(Th,Thm, wait=1,cmm="coef  amplification = "+coef );

load "msh3"
newconvect=1;
real nu=0.01,dt=0.3;
real alpha=1./dt,alpha2=sqrt(alpha);

int nn=5;

mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);

fespace VVh(Th,[P23d,P23d,P23d,P13d]);
fespace Vh(Th,P23d);
fespace Ph(Th,P13d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  
  varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3)
             - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
 +  on(2,u1=1.,u2=0,u3= 0)
 + on(1,u1=0,u2=0,u3=0)
 ;

cout << "b  mat " << endl;

matrix A=vStokes(VVh,VVh);
cout << "e  mat " << endl;
set(A,solver=sparsesolver,dimKrylov=1000);
cout << "e fac  mat " << endl;
real[int] b= vStokes(0,VVh);

VVh [u1,u2,u3,p];
VVh [X1,X2,X3,Xp];
VVh [x1,x2,x3,xp]=[x,y,z,0];



u1[]= A^-1 * b;

ux= u1(x,0.5,y);
uz= u3(x,0.5,y);
p2= p(x,0.5,y);
plot([ux,uz],p2,cmm=" cut y = 0.5",wait=1);
macro XX1() (x-u1*dt)//
macro XX2() (y-u2*dt)//
macro XX3() (z-u3*dt)//

  varf vNS([uu1,uu2,uu3,p],[v1,v2,v3,q]) = 
  int3d(Th)( alpha*(uu1*v1+uu2*v2+uu3*v3) + nu*(Grad(uu1)'*Grad(v1) +  Grad(uu2)'*Grad(v2) +  Grad(uu3)'*Grad(v3))
  - div(uu1,uu2,uu3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,uu1=1,uu2=0,uu3=0)
  + on(1,uu1=0,uu2=0,uu3=0)
 
    +  int3d(Th,optimize=1,qforder=4)(   alpha*(  convect([u1,u2,u3],-dt,u1)*v1  +   convect([u1,u2,u3],-dt,u2)*v2  +   convect([u1,u2,u3],-dt,u3)*v3 )  ) ;
  //   +  int3d(Th,optimize=1)(   alpha*(  u1(X1,X2,X3)*v1  +  u2(X1,X2,X3)*v2  +  u3(X1,X2,X3)*v3 )  ) ;
//  +  int3d(Th,optimize=1)(   alpha*(  u1(XX1,XX2,XX3)*v1  +  u2(XX1,XX2,XX3)*v2  +  u3(XX1,XX2,XX3)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1(x,y,z)*v1  +  u2(x,y,z)*v2  +  u3(x,y,z)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1*v1  +  u2*v2  +  u3*v3 )  ) ;

cout << " build  A" << endl;
A = vNS(VVh,VVh);
cout << " fac A" << endl;

set(A,solver=sparsesolver,dimKrylov=1000);
real t=0;
for(int i=0;i<10;++i)
  {
    t += dt;
    cout << " iteration " << i << " t = " << t << endl;
    X1[]=x1[]+u1[]*(-dt);
    //    verbosity=1000;
    b=vNS(0,VVh);
    verbosity=2;
    u1[]= A^-1 * b;
    ux= u1(x,0.5,y);
    uz= u3(x,0.5,y);
    p2= p(x,0.5,y);
    plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=0);
    if(i%5==6)
    {
      exec("mkdir dd");
      string prefu="dd/u-"+(100+i);
      string prefp="dd/p-"+(100+i);
      savemesh(Th,prefu+".mesh");
      savemesh(Th,prefp+".mesh");
     
      ofstream file(prefu+".bb"); 
      ofstream filep(prefp+".bb"); 
      Ph up1=u1,up2=u2,up3=u3,pp=p;
      file << "3 1 3 "<< up1[].n << " 2 \n";
      filep << "3 1 1 "<< pp[].n << " 2 \n";
      for (int j=0;j<up1[].n ; j++)  
	{
	  file << up1[][j] <<" " <<up2[][j] <<" "<< up3[][j] <<"\n";
	  filep << pp[][j] <<  endl; 
	}  
    }
  }
plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=1);
// Sphere from a  partir d'un icosahedron
// Guillaume Vergez. 
load "msh3"
load "medit" 
load "tetgen"
load "mmg"


include "MeshSurface.idp"
real R= 2;
real hsize= 0.1; 
real areaT = hsize*hsize*sqrt(3)/2.;
real areaS= 4*pi*R*R;
real nn = sqrt(areaS/areaT/20.); 
cout << nn << endl; 
meshS Thb=Sphere20(2.,nn,1,0);// sphere of  Raduis 2 ..
real[int] bb(6);
boundingbox(Thb,bb);
cout << " BB = " << bb << endl;
plot(Thb,wait=1);//Thb=mmgs(Thb,hmin=hsize,hmax=hsize,hgrad=1.1);

real[int] domain = [0.,0.,0.,1,hsize^3/6];
mesh3 Th3sph=tetg(Thb,switch="paAAQYY",nbofregions=1,regionlist=domain);


 plot(cmm="sphere",Th3sph,wait=1);
/*
   $ - \Delta p = f $   on $\Omega$, 
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{1}$ 
   $ p = gd  $ on $\Gamma_{2}$    
   with de Mixte finite element formulation 

   Find $p\in L^2(\Omega) $  and $u\in H(div) $ such than 
   $$  u - Grad p = 0    $$
   $$ - div u =  f $$
   $$  u. n = (g1d,g2d). n   \mbox{ on } \Gamma_{2}$$
   $$ p = gd  \mbox{ on }\Gamma_{1}$$
   the variationnel form is: 
                                                                                                                   
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{2} $:  

  $ \int_\Omega  u v + p div v -\int_{\Gamma_{1}} gd* v.n  = 0 $ 
 $\forall q\in L^2$:   $  +\int_\Omega q div u = -\int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_2$

*/
include "cube.idp"
    int[int]  Nxyz=[10,10,10];
    real [int,int]  Bxyz=[[0,1],[0,1],[0,1]];
    int [int,int]  Lxyz=[[1,1],[1,1],[2,1]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);
fespace Vh(Th,P1);
fespace Rh(Th,RT03d);
fespace Nh(Th,Edge03d);//  Nedelec Finite element. 
fespace Ph(Th,P0);

func gd = 1.;

func g1n = 2.;
func g2n = 3.; 
func g3n = 4.; 

func f = 1.;

Rh [u1,u2,u3],[v1,v2,v3];
Nh [e1,e2,e3];
[u1,u2,u3]=[1+100*x,2+100*y,3+100*z];

// a + b ^ x = 
/*
  b1    x     a1 + b2*z - b3*y 
  b2 ^  y  =  a2 - b1*z + b3*x
  b3    z     a3 + b1*y - b2*x
*/
real b1=30,b2=10,b3=20;
func ex1=100+b2*z-b3*y;

func ex1x=0.;
func ex1y=-b3+0;
func ex1z=b2+0;

func ex2=200.- b1*z + b3*x ;
func ex2x= b3 +0;
func ex2y= 0. ;
func ex2z= -b1 +0;
func ex3=300.+b1*y - b2*x ;
func ex3x= -b2 +0;
func ex3y= b1 +0;
func ex3z= 0. ;
[e1,e2,e3]=[ex1,ex2,ex3]; 

int k=Th(.1,.2,.3).nuTriangle ;
cout << " u = " << u1(.1,.2,.3)  << " " << u2(.1,.2,.3) << " " << u3(.1,.2,.3) << endl;
cout << " dx u = " << dx(u1)(.1,.2,.3)  << " " << dy(u2)(.1,.2,.3) << " " << dz(u3)(.1,.2,.3) << endl;

cout << " e  = " << e1(.1,.2,.3)  << " " << e2(.1,.2,.3) << " " << e3(.1,.2,.3) << endl;
cout << " ex = " << ex1(.1,.2,.3)  << " " << ex2(.1,.2,.3) << " " << ex3(.1,.2,.3) << endl;


cout << " dx,dy,dz   e1x= " << ex1x(.1,.2,.3)  << " " << ex1y(.1,.2,.3) << " " << ex1z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2x= " << ex2x(.1,.2,.3)  << " " << ex2y(.1,.2,.3) << " " << ex2z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3x= " << ex3x(.1,.2,.3)  << " " << ex3y(.1,.2,.3) << " " << ex3z(.1,.2,.3) << endl;

cout << " dx,dy,dz   e1 = " << dx(e1)(.1,.2,.3)  << " " << dy(e1)(.1,.2,.3) << " " << dz(e1)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2 = " << dx(e2)(.1,.2,.3)  << " " << dy(e2)(.1,.2,.3) << " " << dz(e2)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3 = " << dx(e3)(.1,.2,.3)  << " " << dy(e3)(.1,.2,.3) << " " << dz(e3)(.1,.2,.3) << endl;


cout << " k = " << k << endl;
cout << Rh(k,0) << " " <<Rh(k,1) << " " <<Rh(k,2) << " " <<Rh(k,3) << endl;
cout << " df = " << u1[][Rh(k,0)] <<  " " << u1[][Rh(k,1)]  <<" " << u1[][Rh(k,2)]  << " " << u1[][Rh(k,2)] << endl;
// cout << u1[] << endl;

Vh P,Q;
Ph p,q; 
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //
macro Grad(u) [dx(u),dy(u),dz(u)]  //
  problem laplace(P,Q,solver=CG) = 
  int3d(Th) ( Grad(P)'*Grad(Q)) //') for emacs
  - int3d(Th)(f*Q) 
  + on(1,P=gd) 
  - int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q);

fespace RPh(Th,[RT03d,P0]);
varf von1([u1,u2,u3,p],[v1,v2,v3,q])  = 
   int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 - int3d(Th) ( f*q)
 + int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);

RPh [vv1,vv2,vv3,qq];
// some verification Boundary Condition
// and interpolation ...
real[int]  ron=von1(0,RPh);
vv3[]=von1(0,RPh);
cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << endl;
[vv1,vv2,vv3,qq]=[g1n,g2n,g3n,100];
[v1,v2,v3]=[g1n,g2n,g3n];

cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << " " << qq(.1,.2,.001) << endl;
cout << " v : = " << v1(.1,.2,.001)  << " " << v2(.1,.2,.001) << " " << v3(.1,.2,.001)  << endl;

// end of verification of Boundary Condition ... 

problem laplaceMixte([u1,u2,u3,p],[v1,v2,v3,q],eps=1.0e-10,tgv=1e30,dimKrylov=1000) =
   int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 + int3d(Th) ( f*q)
 - int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);

laplace;

// FFCS: add 3D view parameters
real[int] CameraPositionValue = [0.0165449,3.23891,-0.991528];
real[int] CameraFocalPointValue = [0.5,0.5,0.5];
real[int] CameraViewUpValue = [0.671735,0.442219,0.594318];
real[int] CutPlaneOriginValue = [0.5,0.5,1.01];
real[int] CutPlaneNormalValue = [0.689523,0.722423,0.0516115];
plot(P,fill=0,boundary=0,ShowMeshes=1,CutPlane=1,
	CameraPosition=CameraPositionValue,
	CameraFocalPoint=CameraFocalPointValue,
	CameraViewUp=CameraViewUpValue,
	CutPlaneOrigin=CutPlaneOriginValue,
	CutPlaneNormal = CutPlaneNormalValue);

laplaceMixte;

real errL2=sqrt(int3d(Th)(square(P-p))) ;
cout << " int 2 x,yz "<<int2d(Th,2)(x) << " " << int2d(Th,2)(y) << " " << int2d(Th,2)(z) << endl;
cout << " int 2 gn "<<int2d(Th,2)(g1n) << " " << int2d(Th,2)(g2n) << " " << int2d(Th,2)(g3n) << endl;
cout << " int 2 U  "<<int2d(Th,2)(u1) << " " << int2d(Th,2)(u2) << " " << int2d(Th,2)(u3) << endl;
cout << " int 2 V  "<<int2d(Th,2)(vv1) << " " << int2d(Th,2)(vv2) << " " << int2d(Th,2)(vv3) << endl;
cout << " int 2 DP "<<int2d(Th,2)(dx(P)) << " " << int2d(Th,2)(dy(P)) << " " << int2d(Th,2)(dz(P)) << endl;
  
cout << "  diff: u Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (u1*N.x +u2*N.y + u3*N.z) ) ) ) <<endl;
cout << "  diff: P Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (dx(P)*N.x +dy(P)*N.y + dz(P)*N.z) ) ) ) <<endl;
cout << " diff err L2 :" << errL2 << endl;
cout << "    P     L2 :" <<sqrt(int3d(Th)(square(P))) << endl;
cout << "    p     L2 :" <<sqrt(int3d(Th)(square(p))) << endl;
assert(errL2<0.05);
load "msh3"
load "medit"
load "gsl"
load "tetgen"
real hh=.15;// mesh size

real Htube=8; 
real Hneck=2;
real Hbot=Htube+Hneck;

real Rext = 1.;// External radius
real Rneck= 0.2; // Radius of the neck of the bootle
int labtop =3, labbottom =2, labcyl = 1;

meshS Ths;
{
meshS Th3c,Th3bottom, Th3top;
{
// form of the neck ... 	
real[int,int] srneck= 
[
 [Htube-0.001,Htube,Htube+Hneck*0.1, Htube+Hneck*0.3  , Htube+Hneck*0.7   , Htube+Hneck*0.9, Htube+Hneck+0.1],
 [Rext       ,Rext ,Rext           , Rext*.7+Rneck*.3 , Rext*.1 + Rneck*.9, Rneck          , Rneck  ]]
;
gslspline rneck(gslinterpcspline,srneck);// Curve of tthe bollte form z = 0 to Hbot neck of the bottle

//  il faut adapte le maillage 2 pour qu'il soit beau
mesh Th2c= square(Hbot/hh,2*pi*Rext/hh,[x*Hbot,y*2*pi]);
fespace V2x(Th2c,P1);
macro Dx(u) [dx(u#1),dx(u#2),dx(u#3)] //
macro Dy(u) [dy(u#1),dy(u#2),dy(u#3)] //
// The transformation 
func E1 = rneck(x)*cos(y);
func E2 = rneck(x)*sin(y);
func E3 = x;
V2x ex1,ex2,ex3;
// the metric
real hh2 = hh*hh;
func  em11 = Dx(ex)'*Dx(ex)/hh2;
func  em21 = Dx(ex)'*Dy(ex)/hh2;
func  em22 = Dy(ex)'*Dy(ex)/hh2;
func perio=[[1,x],[3,x]];
for(int i=0;i<4;++i)
{
 ex1=E1;ex2=E2;ex3=E3; 
 Th2c=adaptmesh(Th2c,em11,em21,em22,IsMetric=1,periodic=perio,nbvx=100000);
}
Th2c=change(Th2c,fregion=labcyl); 
Th3c = movemesh23(Th2c,transfo=[E1 , E2 , E3]);// maillage exterieur 
medit("Th3c",Th3c); 
}
// extraction of the border of the bottle
int[int] databoder(1);
int ncb= getborder(Th3c,databoder); 
int ktop= Th3c(databoder[databoder[1]]).z < Th3c(databoder[databoder[0]]).z; 
int  kbot=1-ktop;
real Zbot = Th3c(databoder[databoder[kbot]]).z; 
real Ztop = Th3c(databoder[databoder[ktop]]).z; 
cout << " Z  top  " << Zbot  << endl; 
cout << " Z  bot  " << Ztop << endl; 
assert( ncb ==2);
macro DefBorder(bname,kk,Th3,bb,ll)
int n#bname= bb[kk+1]-bb[kk];
border bname(t=bb[kk], bb[kk+1])
{
	real iv = int(t);
	if( iv == bb[kk+1]) iv = bb[kk];

    cout << t << " iv = " << iv << endl;
		iv = bb[iv];
	x= Th3(iv).x ;
	y= Th3(iv).y ;
	label = ll;	
}//
DefBorder(btop,ktop,Th3c,databoder,1)
DefBorder(bbot,kbot,Th3c,databoder,1)
cout << " btop " << nbtop << " bot: " << nbbot << endl;

plot(btop(nbtop)+bbot(-nbbot),wait=1);
Th3bottom=movemesh23(change(buildmesh(bbot(nbbot),fixeborder=1),fregion=labbottom),transfo=[x,y,Zbot],orientation=-1);
Th3top=movemesh23(change(buildmesh(btop(-nbtop),fixeborder=1),fregion=labtop),transfo=[x,y,Ztop],orientation=1);
Ths = Th3c + Th3bottom + Th3top; 
}

real[int] domaine = [0,0,Htube,1,hh^3/6.];
mesh3 Th=tetg(Ths,switch="pqaAYY",regionlist=domaine);
medit("Th",Th);
verbosity=2;

mesh3 Th("dodecaedre01");
fespace Vh(Th,P23d);
func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;
Vh uhe = ue; // bug ..
cout << " uhe min:  " << uhe[]. min << " max:" << uhe[].max << endl;

border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2=buildmesh(cc(50));
fespace Vh2(Th2,P2);


Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM

problem Lap3d(u,v,solver=CG)=int3d(Th)(Grad3(v)' *Grad3(u)) - int3d(Th)(f*v) 
+ on(0,1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
cout << int3d(Th)(1.) << " = " << Th.measure << endl;
plot(u,wait=1);
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
Vh2 u2=u,u2e=ue;
plot(u2,wait=1);
plot(u2,u2e,wait=1);

// test new plot ... 
plot(Th,wait=1);
plot(u,wait=1);

/*
	{
 ofstream file("dd.bb"); 
	file << "3 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << d[][j] << endl; 
    }
*/  
assert(err < 1e-9);
load "msh3"
load "medit" 
real sqrt2=sqrt(2.);
real onesqrt2=sqrt2/2.;

mesh TS= square(10,10);
TS=adaptmesh(TS,sqrt(1+x*x+y*y),err=0.003,periodic=[[4,y],[1,x],[2,y],[3,x]]);
TS=adaptmesh(TS,sqrt(1+x*x+y*y),err=0.003,periodic=[[4,y],[1,x],[2,y],[3,x]]);
TS=TS+movemesh(TS,[-x,y])+movemesh(TS,[x,-y])+movemesh(TS,[-x,-y]);//  build symetrique mesh
plot(TS,wait=1); 
int orientation=1;
func f = 1;
int[int]  ref=[0,1]; 
meshS Thx0 = movemesh23(TS,transfo=[-f,x,y],orientation=-orientation,label=ref);
meshS Thx1 = movemesh23(TS,transfo=[+f,x,y],orientation=+orientation,label=ref);
meshS Thy0 = movemesh23(TS,transfo=[x,-f,y],orientation=+orientation,label=ref);
meshS Thy1 = movemesh23(TS,transfo=[x,+f,y],orientation=-orientation,label=ref);
meshS Thz0 = movemesh23(TS,transfo=[x,y,-f],orientation=-orientation,label=ref);
meshS Thz1 = movemesh23(TS,transfo=[x,y,+f],orientation=+orientation,label=ref);
meshS Tcube= Thx0+Thx1+Thy0+Thy1+Thz0+Thz1;
//savemesh(Tcube,"T.mesh");
//exec("ffmedit T.mesh");
medit("Tcube",Tcube);
plot(Tcube,wait=1);
func R = sqrt(x*x+y*y+z*z); 
meshS Th = movemesh(Tcube,[x/R,y/R,z/R]);
plot(Th,wait=1);
//savemesh(Th,"T.mesh");
//exec("ffmedit T.mesh");
medit("Th",Th);

// FFCS: testing 3d plots
plot(Th);
load "msh3"
load "medit"
border BC(t=0,2*pi){ x=cos(t);y=sin(t);label=1;}
mesh TC= buildmesh(BC(100));
func r
 = (1e-5+abs(1-square(x)-square(y)))^0.5;
real cc=100;
//TC=adaptmesh(TC,[cc*x/r,0,cc*y/r],IsMetric=1);
plot(TC,wait=1);
meshS Thup=movemesh23(TC,transfo=[x,y,sqrt(abs(1-square(x)-square(y)))]);
meshS Thdown=movemesh23(TC,transfo=[x,y,-sqrt(abs(1-square(x)-square(y)))], orientation=-1);
verbosity=10;
meshS Th= Thup+Thdown;


if(1)
  {
    medit("Thup",Thup,wait=1);
    medit("Thdown",Thdown,wait=1);
    medit("Th",Th,wait=1);
 
   // FFCS: removing medit calls for regression tests will empty the
   // curly brackets
   1;
  }
// FFCS: testing 3d plots
plot(Thup);
plot(Thdown);
plot(Th);

savemesh(Th,"toto.mesh");
include "ball-buildlayer.idp"

load "medit"
{
real RR=4.8828; 
real h= 0.2; // mesh size 
mesh3 Th=BuildBall(RR,h,2);
cout << " region = "<< regions(Th)<< endl;
cout << " label = "<< labels(Th)<< endl;
medit("Th",Th);
plot(Th,wait=1);
}
{
real RR=4.8828; 
real h= 0.2; // mesh size 

border Taxe(t=-RR,RR){x=t;y=0;label=0;}
border CC(t=0,pi){x=RR*cos(t);y=RR*sin(t);label=2+(x>0);}
mesh Th2=buildmesh(  Taxe(2*RR/h)+ CC(pi*RR/h) ) ;
mesh3 Th=BuildAxiOx(Th2,h);
cout << " region = "<< regions(Th)<< endl;
cout << " label = "<< labels(Th)<< endl;
medit("Th",Th);
plot(Th,wait=1);
}
//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
load "msh3"
macro grad(u) [dx(u),dy(u),dz(u)] //
macro dn(u) (N'*grad(u) ) //  def the normal derivative 
int nn=5;
mesh3 Th = cube(nn,nn,nn); // unite square 
//savemesh(Th,"cube10.mesh");
//mesh3 Th("cube10.mesh");
int[int] labs=labels(Th);
fespace Vh(Th,P2dc3d);     // Discontinous P2 finite element
fespace Xh(Th,P2);
//  if param = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=1e2; // a paramater to add penalisation 
func f=1;
func g=0;
Vh u,v;
Xh uu,vv;
problem A(u,v,solver=sparsesolver) = 
   int3d(Th)( grad(u)'*grad(v))
 + intallfaces(Th)(//  loop on all  edge of all triangle 
           ( jump(v)*mean(dn(u)) -  jump(u)*mean(dn(v)) 
          + pena*jump(u)*jump(v) ) / nElementonB 
)
 
- int3d(Th)(f*v) 
- int2d(Th)(g*dn(v)  + pena*g*v) 

;
problem A1(uu,vv,solver=sparsesolver) 
= 
 int3d(Th)(grad(uu)'*grad(vv)) - int3d(Th)(f*vv) + on(labs,uu=g);
 
 A; // solve  DG
 A1; // solve continuous

 real err= sqrt(int3d(Th) ( sqr(u-uu)));
 cout << " err= "<< err<< " " << u[].linfty << " " << uu[].linfty << endl; 
plot(u,uu,cmm="Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
assert(err< 0.01);
load "msh3"

mesh3 Th3 = cube(10,10,10,[x*2*pi,y*2*pi,z*2*pi]);

verbosity=10;
fespace Vh3(Th3,P1, periodic=[[1,x,z],[3,x,z],[2,y,z],[4,y,z],[5,x,y],[6,x,y]]);
macro grad3(u) [dx(u),dy(u),dz(u)]//
cout << " Vh3 ndof " << Vh3.ndof << endl; 
func u3e =(sin(x+1)*sin(y+2)*sin(z+3));
Vh3 u3,v3,u3h=u3e;
func f3= 3.*u3e;
solve P3(u3,v3) = int3d(Th3)(grad3(u3)'*grad3(v3)+1e-6*u3*v3) - int3d(Th3)(f3*v3) ;
//plot(u3,u3h,cmm=1);
//plot(u3h,cmm=1);
u3[]-=u3h[];
cout << " err3  = " << u3[].linfty << endl;
assert(u3[].linfty < 0.07);
load "msh3"
load "medit"
int nn=10;

border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2= buildmesh(cc(100));
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
func zmin= 2-sqrt(4-(x*x+y*y));
func zmax= 2-sqrt(3.);

mesh3 Th=buildlayers(Th2,nn,
  coef=  (zmax-zmin)/zmax,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);


func u=x^2+y^2;

mesh3 Th3=trunc(Th,(u-0.5)>1.e-10,split=1,label=135);
medit("Lac",wait=1,Th);
plot(Th); // FFCS: testing 3d plots
medit("LacTruncated",Th3,wait=1);
plot(Th3); // FFCS: testing 3d plots
//  example to build a mesh a cone 
include "ball-buildlayer.idp"
load "medit"
// cone using buildlayers with a triangle 
real RR=1,HH=1; 
border Taxe(t=0,HH){x=t;y=0;label=0;};
border Hypo(t=1,0){x=HH*t;y=RR*t;label=1;};
border Vert(t=0,RR){x=HH;y=t;label=2;};

int nn=10;
real h= 1./nn;
mesh Th2=buildmesh(  Taxe(HH*nn)+ Hypo(sqrt(HH*HH+RR*RR)*nn) + Vert(RR*nn) ) ;

mesh3 Th3T=BuildAxiOx(Th2,h);
medit("cone",Th3T,wait=1);
// FFCS: testing 3d plots
plot(Th3T,cmm="cone");
load "msh3"
load "medit"
int nn=10;
border cc(t=0,2*pi){x=cos(t);y=sin(t);label=1;}
mesh Th2= buildmesh(cc(100));
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
func zmin= 2-sqrt(4-(x*x+y*y));
func zmax= 2-sqrt(3.);

mesh3 Th=buildlayers(Th2,nn,
  coef=  (zmax-zmin)/zmax ,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
medit("Lac",Th,wait=1);
// FFCS: testing 3d plots
plot(Th,cmm="Lac");
/*
   Warning in before version 3.2-1 the nomarl are interal normal
   after the signe is correct and now the noral was exterior normal. 
 */
verbosity=2;
load "msh3"
int nn=20;
mesh Th2=square(nn,nn,region=0);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);


fespace Vh(Th,P2);

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;
Vh uhe = ue; //

cout << " uhe min:  " << uhe[].min << " max:" << uhe[].max << endl;

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM


  problem Lap3d(u,v,solver=CG)  =
  int3d(Th)(Grad3(v)' *Grad3(u)) //') for emacs 
  + int2d(Th,2)(u*v)  
  - int3d(Th)(f*v) 
  - int2d(Th,2) ( ue*v + (uex*N.x +uey*N.y +uez*N.z)*v )
  + on(1,u=ue);
Lap3d;
cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
real err= int3d(Th)( square(u-ue) );
real aa1= int3d(Th,qfV=qfV1)(u) ;
real aa2= int3d(Th,qfV=qfV1lump)(u) ;

cout << " aa1 = " << aa1 << endl;
cout << " aa2 = " << aa2 << endl;
cout << int3d(Th)(1.) << " = " << Th.measure << endl;
cout << int3d(Th,qfV=qfV1)(1.) << " = " << Th.measure << endl;
cout << int3d(Th,qfV=qfV1lump)(1.) << " = " << Th.measure << endl;
Vh d= ue-u;
cout <<  " err = " << err <<  " diff l^\intfy = " << d[].linfty << endl;
real  aire2=int2d(Th,2)(1.); // bug correct in version 3.0-4 
cout << " aire2 = " << aire2 << endl;
func uuu= 2.+x;
cout << uuu(1,1,1) << endl;
assert( abs(aire2-1.) < 1e-6);
plot(u,wait=1);

assert( err < 1e-6);

load "msh3" load "medit"
func f=2*((0.1+(((x/3))*(x-1)*(x-1)/1+x/100))^(1/3.)-(0.1)^(1/3.));
real yf=f(1.2,0); 
border up(t=1.2,0.){ x=t;y=f;label=0;}
border axe2(t=0.2,1.15) { x=t;y=0;label=0;}
border hole(t=pi,0) { x= 0.15 + 0.05*cos(t);y= 0.05*sin(t); label=1;}
border axe1(t=0,0.1) { x=t;y=0;label=0;}
border queue(t=0,1) { x= 1.15 + 0.05*t; y = yf*t; label =0;}
int np= 100;
func bord= up(np)+axe1(np/10)+hole(np/10)+axe2(8*np/10)+ queue(np/10);
plot( bord); 
mesh Th2=buildmesh(bord);
plot(Th2,wait=1);
int[int] l23=[0,0,1,1]; 
mesh3 Th=buildlayers(Th2,coef= max(.15,y/max(f,0.05)), 50 ,zbound=[0,2*pi]
   ,transfo=[x,y*cos(z),y*sin(z)],facemerge=1,labelmid=l23);
macro Grad(u) [dx(u),dy(u),dz(u)] //
fespace Vh(Th,P1);  Vh u,v;
solve Poisson(u,v) = int3d(Th)( Grad(u)'*Grad(v) ) - int3d(Th)( v) + on(1,u=1);
plot(u,wait=1,nbiso=20,value=1);
medit("u",Th,u,wait=1);
// file tetgencube.edp
load "msh3"
load "tetgen"
load "medit"

real x0,x1,y0,y1;
x0=1.; x1=2.; y0=0.; y1=2*pi;
mesh Thsq1 = square(5,35,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

int[int] ref31h = [0,12];
int[int] ref31b = [0,11];

meshS Th31h = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1max],region=ref31h,orientation=1);
savemesh(Th31h,"Th31h.mesh");
meshS Th31b = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1min],region=ref31b,orientation=-1);   


/////////////////////////////////
x0=1.; x1=2.; y0=0.; y1=1.5;
mesh Thsq2 = square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

int[int] ref32h = [0,13];
int[int] ref32b = [0,14];

meshS Th32h = movemesh23(Thsq2,transfo=[XX2,YY2max,ZZ2],region=ref32h,orientation=-1);  
meshS Th32b = movemesh23(Thsq2,transfo=[XX2,YY2min,ZZ2],region=ref32b,orientation=1);

/////////////////////////////////
x0=0.; x1=2*pi; y0=0.; y1=1.5;
mesh Thsq3 = square(35,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
func XX3min = 1.;
func XX3max = 2.;

func YY3 = x;
func ZZ3 = y;

int[int] ref33h = [0,15];
int[int] ref33b = [0,16];

meshS Th33h = movemesh23(Thsq3,transfo=[XX3max,YY3,ZZ3],region=ref33h,orientation=1);  
meshS Th33b = movemesh23(Thsq3,transfo=[XX3min,YY3,ZZ3],region=ref33b,orientation=-1); 

////////////////////////////////
meshS Th33 = Th31h+Th31b+Th32h+Th32b+Th33h+Th33b; // "gluing" surface meshs to obtain the surface of cube
//medit("glumesh",Th33);
Th33=change(Th33, rmInternalEdges=true);
savemesh(Th33,"Th33.mesh");

// build a mesh of a axis parallel box with TetGen
//real[int] domaine = [1.5,pi,0.75,145,0.001];
//mesh3 Thfinal = tetg(Th33,switch="pqaAAYYQ",nbofregions=1,regionlist=domaine);    // Tetrahelize the interior of the cube with tetgen
//medit("tetg",Thfinal);
//savemesh(Thfinal,"Thfinal.mesh");


// build a mesh of a half cylindrical shell of interior radius 1. and exterior radius 2 and heigh 1.5
func mv2x = x*cos(y);
func mv2y = x*sin(y);
func mv2z = z;

plot(Th33,wait=1);

meshS Thmv2surf = movemesh(Th33,[mv2x,mv2y,mv2z]);
meshS Thmv2surfclean = movemesh(Th33,[mv2x,mv2y,mv2z],cleanmesh=true, removeduplicate=true);

savemesh(Thmv2surfclean,"Thmv2surfclean.mesh");
plot(Thmv2surf,wait=1,cmm="th without clean mesh");
plot(Thmv2surfclean,wait=1,cmm="th with clean mesh and remove all multiples ");

//assert( Th33.nt-Thmv2surfclean.nt == Thsq2.nt); 
load "msh3" load "medit"
int nn=3;
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);  Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],  labelmid=rmid, 
  reffaceup = rup,     reffacelow = rdown);
  
medit("c10x10x10",Th,wait=1);

// FFCS: testing 3d plots
plot(Th);

fespace VVh(Th,[P2,P2,P2,P1]);
fespace Vh(Th,P23d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

VVh [u1,u2,u3,p];
VVh [v1,v2,v3,q];
func fup = (1-x)*(x)*y*(1-y)*16;
solve vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) //)';
		       - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,u1=fup,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ;
plot(p,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
plot([u1,u2,u3] ,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
//  to see the 10 cup plan in 2d 
for(int i=1;i<10;i++)
  {
    real yy=i/10.;
    ux= u1(x,yy,y);
    uz= u3(x,yy,y);
    p2= p(x,yy,y);
    plot([ux,uz],p2,cmm=" cut y = "+yy,wait= 1);
  }

// FFCS: testing 3d plots
plot(u1);
plot(u2);
plot(u3);
plot(p);
load "msh3"
int nn=10;;
mesh Th2=square(nn,nn,region=0);
fespace Vh2(Th2,P2);
// // label  face  numbering 
//      1 :  ( x == xmin)        2 :  ( x == xmax) 
//      3 :  ( y == ymin)        4 :  ( y == ymax) 
//      5 :  ( z == zmin)        6 :  ( z == zmax) 
// ---
int[int] rup=[0,5],  rdown=[0,6], rmid=[4,1,2,2, 1,3 ,3,4];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
cout << "Th :  nv = " << Th.nv << " nt =" << Th.nt << endl;
savemesh(Th,"Th.mesh");
verbosity=10;

//  the Finite element space with full periodic condition in 3 axes
fespace Vh(Th,P2,periodic=[[1,y,z],[2,y,z],[3,x,z],[4,x,z],[5,x,y],[6,x,y]]);
verbosity=2;

// a  code to build some verification ....
fespace Vhh(Th,P2);

int[int] num(Vhh.ndof);
num=-1;
int er=0;
for(int k=0;k<Th.nt;++k)
  {
    int err=0;
    for(int i=0;i<4;i++) 
      {
	if(num[Vhh(k,i)]== -1)
	  num[Vhh(k,i)] = Vh(k,i);
	else if(num[Vhh(k,i)] != Vh(k,i))
	  {
	    ++err;
	    cout << " bug " << k <<  " : " << num[Vh(k,i)]  << " !=  " << Vhh(k,i) << endl; 
	  }
      }
    if(err)
      {
	for(int i=0;i<4;i++) cout << Vh(k,i) << " ";     cout << endl;
	for(int i=0;i<4;i++) cout << Vhh(k,i) << " ";    cout << endl << endl;;
      }
    er+=err;
  }

// ++++++
int  n1 = nn+nn+1; //   P2 =>  
int  n2 = n1-1; //
int  nnn=n2*n2*n2;
int nnn1=n1*n1*n1;
cout << " ndf pare= " << Vh.ndof << " " << nnn << endl;
cout << " ndf  = " << Vhh.ndof << " " << nnn1 << endl;
assert(er==0 && nnn == Vh.ndof && nnn1 == Vhh.ndof); // some verification ...
  Vh u,v,uu;
  real x0=2*pi/3,y0=2*pi/4,z0=2*pi*2/3;
  func ue= sin(2*pi*x+x0)*sin(2*pi*y+y0)*sin(2*pi*z+z0);
  real cc= -3*(2*pi)^2 ;
  func f = -cc*ue;
  uu=ue;
macro Grad(u) [dx(u),dy(u),dz(u)] //;
  solve P(u,v,solver=CG)= int3d(Th)(Grad(u)'*Grad(v)) - int3d(Th)(f*v); //') ;
cout << "Err L2 = " << sqrt(int3d(Th)( square(u-uu)) ) << endl;

// FFCS: add 3D view

///Vh2 u0=u(x,y,0);
///Vh2 u1=u(x,y,1);
///plot(u0,u1,wait=1);

plot(u,nbiso=10);
load "msh3"
load "medit"
int n= 10;
int nvb = (n+1)^3 - (n-1)^3;// Nb boundary vertices
int ntb = n*n*12; // Nb of Boundary triangle 
mesh3 Th=cube(n,n,n);
int[int] ll=labels(Th);//  get all labels of the mesh .. 
cout << " the labels "<< ll << endl;
cout << Th.nbe << endl; 
meshS ThS=extract(Th,label=ll);// extract boundary of 3d Mesh with given label
cout <<"  mesh nv, nt, nbe" <<  ThS.nv << " - " << ThS. nt << " - " << ThS.nbe << endl; 
cout <<"  computed by hand: " << ntb  << " " << nvb  << endl; 
assert( ThS.nt == ntb) ;
assert( ThS.nv == nvb);
load "medit"
include "cube.idp"
real surfS1 = 4*pi;
real volS1 =surfS1/3.; 
int nn= 16; 
int[int]  Nxyz=[nn,nn,nn];
real [int,int]  Bxyz=[[-2.,2.],[-2.,2.],[-2.,2.]];
int [int,int]  Lxyz=[[1,1],[1,1],[1,1]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

int err=0;
real eps = 0.5;
func r = sqrt(x*x +y*y+z*z);

real lc ;
verbosity=3;
lc = int2d(Th,levelset=r-1.)(1.) ; 
cout << " area of the level set = " <<  lc  << " =  surfS1 " << surfS1 ;
cout << ", Ok = " << (abs(lc-surfS1) < eps) << endl; 
if( abs(lc-surfS1) > eps) err++;
fespace Vh(Th,P1);
// test linear and bilinear ... 
varf vl(u,v) = int2d(Th,levelset=r-1.)(v) + int2d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh);

cout << " area of the level set (varf linear ) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1 ;
cout  << ", Ok = " << (abs(lc-surfS1) < eps) << endl;
if( abs(lc-surfS1) > eps) err++; 
real[int]  one(Vh.ndof); 
one=1.;
matrix VV=vl(Vh,Vh); //  matrix with levelset
vv = VV*one;
cout << " area of the level set (varf bilinear same) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1;
cout << ", Ok = " << (abs(lc-surfS1) < eps) << endl;; 
if( abs(lc-surfS1) > eps) err++;

//  just for test a idea approximation of int of negative part of levelset 
//   to we just change the measure of the element not the quadrature point 
{ // test new stuff for level set  ... 
    macro grad(u) [dx(u),dy(u),dz(u)] //
    Vh u,v;
    solve Pxx(u,v) = int3d(Th) ( grad(u)'*grad(v)*1e-8 ) + int3d(Th, levelset= 1-r) ( grad(u)'*grad(v) ) + on(1,u=0) + int3d(Th, levelset= 1-r) ( 1*v);
    plot(u,wait=1);   
    varf vxx(u,v) =  int3d(Th, levelset= 1-r) ( u*v ) + int3d(Th, levelset= 1-r) ( 1*v);
  matrix XX=vxx(Vh,Vh);
  real[int] xx=vxx(0,Vh);
  real vol1= int3d(Th, levelset= 1-r)(1.);
  cout << "   vol1 = " << vol1 << "  ~= " << Th.measure - volS1 << endl;
  err += (abs(vol1-(Th.measure - volS1)) > eps); 
  cout << " xx.sum = " << xx.sum << " == " << vol1 <<endl;
  err += (abs(vol1-xx.sum) > 1e-8); 
  
  real[int] yy(Vh.ndof); yy=1;
  xx= XX*yy;
  cout << " XX.sum = " << xx.sum << " == " << vol1 << endl;
  err += (abs(vol1-xx.sum) > 1e-8); 

}



if(0)
{// test on diff mesh3  not wet implemented (FH  frev 2014)
mesh3 Th1=Cube(Nxyz,Bxyz,Lxyz);
mesh3 Th2=Cube(Nxyz,Bxyz,Lxyz);
fespace Vh1(Th1,P1);
fespace Vh2(Th2,P1);

varf vl(u,v) = int2d(Th,levelset=r-1.)(v) + int2d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh2);

cout << " area of the level set (varf linear diff    ) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1 ;
cout  << ", Ok = " << (abs(lc-surfS1) < eps) << endl;
if( abs(lc-surfS1) > eps) err++; 
real[int]  one(Vh1.ndof); 
one=1.;
// sorry not implemented to day ... FH 
//verbosity=10000;
matrix VV=vl(Vh1,Vh2); // no build of matrix with levelset 
vv = VV*one;
cout << " area of the level set (varf bilinear diff ) = " <<  (lc=vv.sum)  << "=  surfS1 " << surfS1;
cout << ", Ok = " << (abs(lc-surfS1) < eps) << endl;; 
if( abs(lc-surfS1) > eps) err++;

}
cout << " Nb err " << err << endl;
assert(err==0);

load "msh3"// buildlayer
load "medit"// buildlayer

border C(t=0,2*pi) { x = cos(t); y=sin(t); label=1;}
mesh Baseh = buildmesh(C(20));
plot(Baseh,wait=1);

int[int] rup=[0,1],  rdown=[0,2], rmid=[1,3];
func zmin= 1;
func zmax= 10;
int nlayer=100;
mesh3 Th=buildlayers(Baseh,nlayer,
  coef= 1.,
  zbound=[zmin,zmax],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
medit("Cyl",Th,wait=1);
// FFCS: testing 3d plots
plot(Th,cmm="Cyl");
verbosity=1;
load "msh3"
load "tetgen"
load "medit"
include "MeshSurface.idp"


    real hs = 0.1;  // mesh size  
	real Lex=1,Lin =0.5;
	int nLex = 2*Lex/hs; 

	
    int[int]  Nex=[nLex,nLex,nLex];
    real [int,int]  Bex=[[-Lex,Lex],[-Lex,Lex],[-Lex,Lex]];
    int [int,int]  Lbex=[[1,1],[1,1],[1,1]] ;
     int  Ls=2 ;
    
    ////////////////////////////////
    meshS ThHS = SurfaceHex(Nex,Bex,Lbex,1)+Sphere(Lin,hs,Ls,1); // "gluing" surface meshs to total boundary meshes
    real voltet=(hs^3)/6.;
    cout << " voltet = " << voltet << endl;
    real[int] domaine = [0,0,0,2,voltet,0,0,(Lex+Lin)/2,1,voltet]; 
    
    mesh3 Th = tetg(ThHS,switch="pqaAYY",regionlist=domaine);  
	Th= trunc(Th,region==1);  
    // Tetrahelize the interior of the cube with tetgen
    medit("tetg",Th,wait=1);
    savemesh(Th,"Th.mesh");
load "msh3"
load "medit"
int nn=10;
// a pententiel flow on a lac .. 
//  a first freefem++ 3d example 
// ------  not to bad ......
verbosity=3;
mesh Th2("lac-leman-v4.msh");
fespace Vh2(Th2,P1);
Vh2 deep;
{  Vh2 v; 
	macro Grad(u) [dx(u),dy(u)] //
	solve P(deep,v)= int2d(Th2)(Grad(deep)'*Grad(v))+int2d(Th2)(v)
	+on(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,deep=-1);
	deep = deep*5/abs(deep[].min);
	plot(deep,wait=1);
}
Vh2 ux,uz,p2;
int[int] rup=[0,200],  rdown=[0,100],rmid(17*2);
for(int i=0;i<rmid.n;++i)
  rmid[i]=1+i/2;
cout << rmid << endl;
real maxdeep = deep[].min;
mesh3 Th=buildlayers(Th2,nn,
  coef= deep/maxdeep,
  zbound=[deep,0],
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);
if(!NoUseOfWait)medit("Leman",Th);
fespace Vh(Th,P13d);
Vh p,q;
//  (-deep[].min)*c = 0.5 Km
//  c = 
real cc=(0.5/-deep[].min);
cout << cc << " cc = " << endl;
cc=1; //  otherwise bug in boundaing condition ... 
macro Grad(u) [dx(u),dy(u),cc*dz(u)] //

real ain=int2d(Th,1)(1.);
real aout=int2d(Th,2)(1.);
cout << " area " << ain << " " << aout << endl;
real din=1./ain;
real dout=-1./aout;
solve P(p,q)= int3d(Th)(Grad(p)'*Grad(q)+1e-5*p*q)-int2d(Th,1)(q*din)+int2d(Th,2)(q*dout);

plot(p,wait=1,nbiso=30,value=1);
if(!NoUseOfWait) medit("potentiel",Th,p,wait=1);

real vregtest = p[].max ;
cout << " p max " << vregtest << endl; 
load "msh3"
real nu=0.01,dt=0.3;
real alpha=1./dt,alpha2=sqrt(alpha);

int nn=5;

mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);

fespace VVh(Th,[P23d,P23d,P23d,P13d]);
fespace Vh(Th,P23d);
fespace Ph(Th,P13d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  
  varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3)
             - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
 +  on(2,u1=1.,u2=0,u3= 0)
 + on(1,u1=0,u2=0,u3=0)
 ;

cout << "b  mat " << endl;

matrix A=vStokes(VVh,VVh);
cout << "e  mat " << endl;
set(A,solver=sparsesolver);
cout << "e fac  mat " << endl;
real[int] b= vStokes(0,VVh);

VVh [u1,u2,u3,p];
VVh [X1,X2,X3,Xp];
VVh [x1,x2,x3,xp]=[x,y,z,0];



u1[]= A^-1 * b;

ux= u1(x,0.5,y);
uz= u3(x,0.5,y);
p2= p(x,0.5,y);
plot([ux,uz],p2,cmm=" cut y = 0.5",wait=1);
macro XX1() (x-u1*dt)//
macro XX2() (y-u2*dt)//
macro XX3() (z-u3*dt)//

  varf vNS([uu1,uu2,uu3,p],[v1,v2,v3,q]) = 
  int3d(Th)( alpha*(uu1*v1+uu2*v2+uu3*v3) + nu*(Grad(uu1)'*Grad(v1) +  Grad(uu2)'*Grad(v2) +  Grad(uu3)'*Grad(v3))
  - div(uu1,uu2,uu3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,uu1=1,uu2=0,uu3=0)
  + on(1,uu1=0,uu2=0,uu3=0)
   +  int3d(Th,optimize=1)(   alpha*(  u1(X1,X2,X3)*v1  +  u2(X1,X2,X3)*v2  +  u3(X1,X2,X3)*v3 )  ) ;
//  +  int3d(Th,optimize=1)(   alpha*(  u1(XX1,XX2,XX3)*v1  +  u2(XX1,XX2,XX3)*v2  +  u3(XX1,XX2,XX3)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1(x,y,z)*v1  +  u2(x,y,z)*v2  +  u3(x,y,z)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1*v1  +  u2*v2  +  u3*v3 )  ) ;

cout << " build  A" << endl;
A = vNS(VVh,VVh);
cout << " fac A" << endl;
set(A,solver=sparsesolver);
real t=0;
for(int i=0;i<10;++i)
  {
    t += dt;
    cout << " iteration " << i << " t = " << t << endl;
    X1[]=x1[]+u1[]*(-dt);
    //    verbosity=200;
    b=vNS(0,VVh);
    verbosity=2;
    u1[]= A^-1 * b;
    ux= u1(x,0.5,y);
    uz= u3(x,0.5,y);
    p2= p(x,0.5,y);
    plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=0);
    if(0)
    {
      exec("mkdir dd");
      string prefu="dd/u-"+(100+i);
      string prefp="dd/p-"+(100+i);
      savemesh(Th,prefu+".mesh");
      savemesh(Th,prefp+".mesh");
     
      ofstream file(prefu+".bb"); 
      ofstream filep(prefp+".bb"); 
      Ph up1=u1,up2=u2,up3=u3,pp=p;
      file << "3 1 3 "<< up1[].n << " 2 \n";
      filep << "3 1 1 "<< pp[].n << " 2 \n";
      for (int j=0;j<up1[].n ; j++)  
	{
	  file << up1[][j] <<" " <<up2[][j] <<" "<< up3[][j] <<"\n";
	  filep << pp[][j] <<  endl; 
	}  
    }
  }
plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=1);
real REFadapt=0.238852;
real REFadaptindicatorP1=0.23912;
real REFadaptindicatorP2=0.239362;
real REFalgo=0.283072;
real REFaXtutorial=1.00032;
real REFbeam=2.19089;
real REFcavity=0.423606;
real REFconvect2=2.59152;
real REFconvectXapt=0.0016933;
real REFconvect=10.2173;
real REFFE=84.7687;
real REFfluidStructAdapt=3.87121;
real REFfluidStruct=1.25804;
real REFLapDG2=2.04648;
real REFLaplace=0.167397;
real REFLaplaceP1bis=3.4845e-14;
real REFLaplaceP1=2.34669;
real REFLaplaceP1P2h=8.60123;
real REFLaplaceRT=0.433835;
real REFmovemesh=42.35;
real REFnolinearXelas=1.00047;
real REFNSUzawaCahouetChabart=2.02821;
real REFonde=146.865;
real REFplot=85.3776;
real REFreadmesh=107.273;
real REFregion=0.01116;
real REFschwarzXgc=3.25892;
real REFschwarzXnoXoverlap=5.07864;
real REFschwarzXoverlap=5.05857;
real REFsparseXmatrix=116.382;
real REFsparseXcmatrix=232.764;
real REFStokesUzawa=32.7781;
real REFtablefunction=66.5851;
real a;
try { 
  a=1./0.;
}
catch  (...) 
{
  cout << " get a ExecError " << endl;
  a =0;
}

verbosity=10;

int nn=5	;
mesh Th=square(nn,nn);
verbosity=5;
fespace Vh(Th,P1);     // P1 FE space
Vh uh,vh;              // unkown and test function. 
func f=1;                 //  right hand side function 
func g=0;                 //  boundary condition function
real   cpu=clock(); 
problem laplace(uh,vh,solver=Cholesky,tolpivot=1e-6) =                    //  definion of  the problem 
int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int2d(Th)( -f*vh )                          //  linear form
  ;

try {
  cout << " Try Cholesky \n";
  laplace; // solve the problem plot(uh); // to see the result
  cout << "-- lap Cholesky " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
} 
catch(...) {
  cout << " Catch cholesky PB " << endl;
}


/*
   Solving the following Poisson problem 
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$, 
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$ 
   $ p = gd  $ on $\Gamma_{1}$ 
  with de Mixte finite element formulation 
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than  
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $ 
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$ 

*/
mesh Th=square(10,10);
fespace Vh(Th,RT0);
fespace Ph(Th,P0);

func gd = 1.;
func g1n = 1.;
func g2n = 1.; 
func f = 1.;

Vh [u1,u2],[v1,v2];
Ph p,q; 

problem laplaceMixte([u1,u2,p],[v1,v2,q],solver=sparsesolver,eps=1.0e-10,tgv=1e30,dimKrylov=150) =
   int2d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
 + int2d(Th) ( f*q)
 - int1d(Th,1,2,3)( gd*(v1*N.x +v2*N.y))   //  int on gamma 
 + on(4,u1=g1n,u2=g2n);

 laplaceMixte;
 plot([u1,u2],coef=0.1,wait=1,ps="lapRTuv.eps",value=true); 
 plot(p,fill=1,wait=1,ps="laRTp.eps",value=true);  
 mesh Th=square(10,10,[2*x*pi,2*y*pi]);
 fespace Vh(Th,P2,periodic=[[2,y],[4,y],[1,x],[3,x]]);     // the label 2 and 4 are periodic
 //  [a1,b1,b2,f1],[b,fb] the degree of freedom of of the border a1,b1,c1 and b are equivalent 
 //  via fonctions f1 and f2 
 //  here full periodic in x and y direction
 Vh uh,vh;              // unkown and test function. 
 func f=sin(x+pi/4.)*cos(y+pi/4.);                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int2d(Th)( -f*vh )                          //  linear form
;                

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="period.eps",value=true);
assert(version>=1.24); //  for big bug is non symetric matrix see HISTORY, and sign in int1d 
int method1=0;
int iwait=0;
include "beam.edp"
// Stokes on square  b,e,f,g  driven cavite on left side g 
border e(t=0,10) { x=t; y=-10; label= 1; };      //  bottom
border f(t=0,10) { x=10; y=-10+t ; label= 1; };   //  right
border g(t=0,10) { x=0; y=-t ;label= 2;};       //  left
border h(t=0,10) { x=t; y=vv(t,0)*( t>=0.001 )*(t <= 9.999); label=3;};   //  top of cavity deforme 

real err=10;
mesh sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
plot(sh,wait=iwait);

fespace Xh(sh,P2),Mh(sh,P1);
fespace V1h(sh,P2);

Xh u1,u2,v1,v2;
Mh p,q,ppp;

real veps=1e-4;
varf bx(u1,q) = int2d(sh)( -(dx(u1)*q)); 

varf by(u1,q) = int2d(sh)( -(dy(u1)*q));

varf Lap(u1,u2)= int2d(sh)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                   +  on(2,u1=1) +  on(1,3,u1=0)   ;

varf Mass(p,q)=int2d(sh)(p*q);

Xh bc1; 
Xh brhs;
string solver="UMFPACK";
if(!HaveUMFPACK) solver="CHOLESKY";
                   
matrix A= Lap(Xh,Xh,solver=solver); 
matrix M= Mass(Mh,Mh,solver=solver); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);
func cly =(-y)*(10.+y)/25.;
Xh bcx=0,bcy=cly;
func real[int] divup(real[int] & pp)
{ //  
  int verb=verbosity;
   verbosity=1;
   brhs[]  = Bx'*pp; brhs[] += bc1[] .*bcx[];
   u1[] = A^-1*brhs[];
   brhs[]  = By'*pp; brhs[] += bc1[] .*bcy[];
   u2[] = A^-1*brhs[];
   ppp[] = M^-1*pp;
   ppp[] = 1.e-6*ppp[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   return ppp[] ;
};
p=0;q=0;u1=0;v1=0;

int i;
 th1 = movemesh(th, [x+uu, y+vv]);
for( i=0;i<6;i++)
 {    
 bc1=0; 
 brhs=0;
 bc1[] = Lap(0,Xh);
 q=0;   
 verbosity=50;
 LinearCG(divup,p[],veps=veps,nbiter=100);
 divup(p[]);
 verbosity=1;
 plot([u1,u2],p,wait=iwait,value=true,coef=0.1);

 real coef=0.2;

Vh [uu1,vv1];
[uu1,vv1]=[uu,vv];

if(method1==1)
 {
 V1h sigma11,sigma22,sigma12;

  sigma11([x+uu,y+vv]) = (2*dx(u1)-p);
  sigma22([x+uu,y+vv]) = (2*dy(u2)-p);
  sigma12([x+uu,y+vv]) = (dx(u2)+dy(u1));

solve  bbst([uu,vv],[w,s],init=i)  = 
    int2d(th)(
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
              )
  + int2d(th) (-gravity*s)
  + int1d(th,bottombeam)( coef*(sigma11*N.x*w + sigma22*N.y*s + sigma12*(N.y*w+N.x*s) )  )
  + on(1,uu=0,vv=0) 
  ;
  }
 else
 {
 // this piece of code is crucial to mixe adaptation and fluid structure 
 fespace  Vh11(th1,[P1,P1]);
 varf vFS([yyyy],[w,s])= int1d(th1,bottombeam)( 
     coef*((2*dx(u1)-p)*N.x*w + (2*dy(u2)-p)*N.y*s + (dx(u1)+dy(u2))*(N.y*w+N.x*s)) 
   );
 Vh11 [FS,FS1];[FS,FS1]=[0,0];
 FS[]= vFS(0,Vh11);
 cout << FS[].min << " " << FS[].max << endl;
 
 plot([FS,FS1],wait=iwait,value=1);
 solve  bbst2([uu,vv],[w,s],init=i)  = 
    int2d(th)(
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
              )
  + int2d(th) (-gravity*s)
  + FS[] // + int1d(th,bottombeam)( coef*(sigma11*N.x*w + sigma22*N.y*s + sigma12*(N.y*w+N.x*s) )  )
  + on(1,uu=0,vv=0) 
  ;
   
 }
 //plot([uu,vv],wait=1);
  err = sqrt(int2d(th)( (uu-uu1)^2 + (vv-vv1)^2 )); 
 cout << " ----- Iteration = " << i <<  " Erreur L2 = " << err << "----------\n";
 cout << " max deplacement " << uu[].linfty << endl;
 bool iadapt=err>0.05;
 if(iadapt)
 th = adaptmesh(th,[uu,vv],err=1.e-2);
 [uu,vv]=[uu,vv];
 [w,s]=[0,0];
 
 th1 = movemesh(th, [x+uu, y+vv]);
 //plot(th1,wait=1);
 if(method1==1)
   sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
 else 
  {
    fespace VVh(sh,P1);VVh  uh,vh;
    solve lapllll(uh,vh,solver=sparsesolver,tgv=1e5) =                    //  definion of  the problem 
    //  compute a deformation field for moving the fluid mesh
    
    //  x -> vv(x,0) is the new deformation y 
    //  x -> y is the position of the mesh on border 3
    int2d(sh)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
    + on(1,2,uh=0)+ on(3,uh=(vv(x,0)-y)*( x>=0.001 )*(x <= 9.999))  ;    //  boundary condition form
    
    sh = movemesh(sh,[x,y+uh]);
   if(iadapt)
    {
    sh = adaptmesh(sh,[u1,u2],p,err=2.e-2);
    lapllll;  
    sh = movemesh(sh,[x,y+uh]);    
    }
    plot(th1,sh,wait=iwait);
    p=p;
    u1=u1; 
    u2=u2;
    A= Lap(Xh,Xh,solver=sparsesolver); 
    M= Mass(Mh,Mh,solver=sparsesolver); 
    Bx= bx(Xh,Mh);
    By= by(Xh,Mh);
    bcx=0;
    bcy=cly;
  }


 p=p;q=q;u1=u1;u2=u2;brhs=brhs;ppp=ppp;
 A= Lap(Xh,Xh,solver=sparsesolver); 
 M= Mass(Mh,Mh,solver=sparsesolver); 
 Bx= bx(Xh,Mh);
 By= by(Xh,Mh);
 bc1=0;  // for resize
 bc1[] = Lap(0,Xh);
}
cout << " max deplacement " << uu[].linfty << endl;
// Mesh
border a(t=0, 1.0){x=t;   y=0;   label=1;}
border b(t=0, 0.5){x=1;   y=t;   label=2;}
border c(t=0, 0.5){x=1-t; y=0.5; label=3;}
border d(t=0.5, 1){x=0.5; y=t;   label=4;}
border e(t=0.5, 1){x=1-t; y=1;   label=5;}
border f(t=0.0, 1){x=0;   y=1-t; label=6;}
mesh Th = buildmesh (a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
savemesh(Th, "th.msh");

// Fespace
fespace Vh(Th, P1);
Vh u, v;

// Problem
problem Probem1(u, v, solver=CG, eps=1.0e-6)
	= int2d(Th, qforder=2)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	+ int2d(Th, qforder=2)((x-y)*v)
	;

// Adaptation loop
int i;
real error = 0.01;
for (i = 0; i < 4; i++) {
	// Solve
	Probem1;
	cout << u[].min << " " << u[].max << endl;

	// Plot
	plot(u,wait=1);

	// Mesh adaptation
	Th = adaptmesh(Th, u, err=error);
	plot(Th, wait=1);

	// Interpolation
	// on the new mesh
	u = u;

	// Error update
	error = error/2;
}
assert(version>=1.24); //  for big bug is non symetric matrix see HISTORY, and sign in int1d 
include "beam.edp"
// Stokes on square  b,e,f,g  driven cavite on left side g 
border e(t=0,10) { x=t; y=-10; label= 1; };      //  bottom
border f(t=0,10) { x=10; y=-10+t ; label= 1; };   //  right
border g(t=0,10) { x=0; y=-t ;label= 2;};       //  left
border h(t=0,10) { x=t; y=vv(t,0)*( t>=0.001 )*(t <= 9.999); label=3;};   //  top of cavity deforme 


mesh sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
plot(sh,wait=1);

fespace Xh(sh,P2),Mh(sh,P1);
fespace V1h(sh,P1dc);

Xh u1,u2,v1,v2;
Mh p,q,ppp;


varf bx(u1,q) = int2d(sh)( -(dx(u1)*q)); 

varf by(u1,q) = int2d(sh)( -(dy(u1)*q));

varf Lap(u1,u2)= int2d(sh)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                   +  on(2,u1=1) +  on(1,3,u1=0)   ;

varf Mass(p,q)=int2d(sh)(p*q);

Xh bc1; 
Xh brhs;
string solver="UMFPACK";
if(!HaveUMFPACK) solver="CHOLESKY";
                   
matrix A= Lap(Xh,Xh,solver=solver); 
matrix M= Mass(Mh,Mh,solver=solver); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);

Xh bcx,bcy;
func real[int] divup(real[int] & pp)
{ //  
  int verb=verbosity;
   verbosity=1;
   brhs[]  = Bx'*pp; brhs[] += bc1[] .*bcx[];
   u1[] = A^-1*brhs[];
   brhs[]  = By'*pp; brhs[] += bc1[] .*bcy[];
   u2[] = A^-1*brhs[];
   ppp[] = M^-1*pp;
   ppp[] = 1.e-6*ppp[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   return ppp[] ;
};
p=0;q=0;u1=0;v1=0;

int i;
for( i=0;i<2;i++)
 {    
bcx=0;
bcy= (-y)*(10.+y)/25.;

 cout << " loop " << i << endl; 
 bc1[] = Lap(0,Xh);
 q=0;   
 verbosity=50;
 LinearCG(divup,p[],eps=1.e-3,nbiter=50);
 divup(p[]);
 verbosity=1;
 plot([u1,u2],p,wait=1,value=true,coef=0.1,cmm="[u1,u2],p");

 real coef=0.2;

V1h sigma11,sigma22,sigma12;
Vh [uu1,vv1];
  [uu1,vv1]=[uu,vv];

  sigma11([x+uu,y+vv]) = (2*dx(u1)-p);
  sigma22([x+uu,y+vv]) = (2*dy(u2)-p);
  sigma12([x+uu,y+vv]) = (dx(u2)+dy(u1));


solve  bbst([uu,vv],[w,s],init=i)  = 
    int2d(th)(
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
             )
  + int2d(th) (-gravity*s)
  + int1d(th,bottombeam)( coef*(sigma11*N.x*w + sigma22*N.y*s + sigma12*(N.y*w+N.x*s) )  )
  + on(1,uu=0,vv=0) 
  ;
cout << " max deplacement " << uu[].linfty << " " << uu[].min << " " << uu[].max <<endl;
 plot([uu,vv],wait=1);
 real  err = sqrt(int2d(th)( (uu-uu1)^2 + (vv-vv1)^2 )); 
 cout << " ----- Iteration = " << i <<  " Erreur L2 = " << err << "----------\n";
 th1 = movemesh(th, [x+uu, y+vv]);
 plot(th1,wait=1);
 sh = buildmesh(h(-20)+f(10)+e(10)+g(10));
 plot(sh);
 p=p;q=q;u1=u1;u2=u2;brhs=brhs;ppp=ppp;
 A= Lap(Xh,Xh,solver=sparsesolver); 
 M= Mass(Mh,Mh,solver=sparsesolver); 
 Bx= bx(Xh,Mh);
 By= by(Xh,Mh);
 bc1=0;  // for resize
 bc1[] = Lap(0,Xh);
}
cout << " max deplacement " << uu[].linfty << endl;
assert(  abs(0.219964 -uu[].linfty ) < 5e-2); // 0.176678
real [int,int] a(10,10);
real [int,int] aa(2,3);
for [i,j,aij : aa] 
{
   aij= 1.+i+2*j;
   cout << i << " "<< j << " " << aij << endl; 
}
	
real [int] b(10);
for [i,bi : b] {bi=i+1; cout << i << " " << bi << endl;}
cout << " b="<< b<< endl;  
for [i,j,aij : a] 
{
   aij= 1.+i+2*j;
   if(abs(i-j)>2) aij=0;
}
cout << a(1,2) << " == " << 1.+1+2*2 << endl; 
assert(abs(a(1,2)- (1.+1+2*2))<1e-9);
cout << " a= "<< a << endl; 
matrix A=a;
string[string] ss;
ss["1"]= 1;
ss["2"]= 2;
ss["3"]= 5;
for [i,bi : ss] 
    ss[i]=bi+i+6+"-dddd"; 
cout <<" ss = "<< ss << endl;
int[string] si;
si[1]=2;
si[50]=1;
for [i,vi : si]
   {
   cout << " i " << setw(3) << i << " " << setw(10) <<vi << endl;
    vi= atoi(i)*2;
    }

cout <<" si = "<< si << endl;
for [i,j,aij : A]
{
    cout << i<< " " << j <<" " <<  aij << endl; 
    aij= -aij;
}
cout << A << endl; 
real[string] sd;
sd["1"]= 1;
sd["2"]= 2;
sd["3"]= 5;
for [i,bi : sd] 
    bi=bi*bi;
cout << "sd=\n"<< sd <<endl ;
// FFCS: for regression tests
real regtest;
{
 // build from bamg geometrie

  { // build the geom file
    ofstream ff("g.mesh");
    int n = 8;
    real h = 0.1;
    ff <<"MeshVersionFormatted 0\n";
    ff <<"AngleOfCornerBound 46\n";
    ff <<"Dimension 2 \n";
    ff << "Vertices "<< n <<  endl;
    for (int i=0;i<n;i++)
      ff << cos(i*pi*2./n) << " " << sin(i*pi*2./n) << " 1\n"; 
    
    ff << "Edges "<< n<< endl;
    for (int i=0;i<n;i++)
      ff << i+1 << " " << (i+1)%n +1 << " 1\n";
    
    ff << "hVertices"<< endl;
    for (int i=0;i<n;i++)
      ff << h << endl;
  }
  
  mesh Th=buildmesh("g.mesh",nbvx=100000);
  plot(Th,wait=1);
}

//    example for mesh work 
// --------------------------
{ // square 
  real x0=1.2,x1=1.8;
  real y0=0,y1=1;
  int n=5,m=20;
  mesh Th=square(n,m,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
  int[int] lab=[5,5,5,5]; // the 4 side 1,2,3,4 have label 5
  mesh th=square(4,5,label=lab,region=1);
  plot(Th,th,ps="twosquare.eps");

}
// ------------------------------------------------------------
{ //    hole 
real pi=4*atan(1);
border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
border b(t=0,2*pi){ x=0.3+0.3*cos(t); y=0.3*sin(t);label=2;}
border c(t=0,2*pi){ x=0.3+0.0001*cos(t); y=0.0001*sin(t);label=2;}
mesh Thwithouthole= buildmesh(a(50)+b(+30));
mesh Thwithhole   = buildmesh(a(50)+b(-30));
// to change the default maximun number of vertices to 100000
mesh Thwithtinyhole   = buildmesh(a(50)+c(-5),nbvx=100000); 
plot(Thwithouthole,wait=1,ps="Thwithouthole.eps");
plot(Thwithhole,wait=1,ps="Thwithhole.eps");
plot(Thwithtinyhole,wait=1,ps="Thwithtinyhole.eps");

}
// ------------------------------------------------------------
{ //  square with border and no edge with two vextices on border 
border a(t=0,2){x=t; y=0;label=1;};
border b(t=0,1){x=2; y=t;label=1;};
border c(t=2,0){x=t; y=1;label=1;};
border d(t=1,0){x=0; y=t;label=1;};
int n = 20;
plot(a(2*n)+b(n)+c(2*n)+d(n),wait=1,ps="squarebb.eps");
mesh th= buildmesh(a(2*n)+b(n)+c(2*n)+d(n),splitpbedge=1); 
plot(th,ps="squareb.eps",wait=1,cmm=" with splitpbedge=1");
}
// ------------------------------------------------------------
// bug before version 2.24
{ // L shape 
border a(t=0,1){x=t;y=0;label=1;};
border b(t=0,0.5){x=1;y=t;label=1;};
border c(t=0,0.5){x=1-t;y=0.5;label=1;};
border d(t=0.5,1){x=0.5;y=t;label=1;};
border e(t=0.5,1){x=1-t;y=1;label=1;};
border f(t=0,1){x=0;y=1-t;label=1;};
assert(version >= 2.24);
 func abc=  a(6) + b(4) + c(4)  ;
 func def = d(4) + e(4) + f(6);
 plot(abc  + def,wait=1);
mesh rh = buildmesh (abc  + def );
plot(rh,ps="lshape.eps");

}
// ------------------------------------------------------------
{ // readmesh 
  mesh th("aile.msh");
  plot(th);
  
}
// ------------------------------------------------------------
{ // movemesh 
  real Pi=atan(1)*4;
  verbosity=4;
  border a(t=0,1){x=t;y=0;label=1;};
  border b(t=0,0.5){x=1;y=t;label=1;};
  border c(t=0,0.5){x=1-t;y=0.5;label=1;};
  border d(t=0.5,1){x=0.5;y=t;label=1;};
  border e(t=0.5,1){x=1-t;y=1;label=1;};
  border f(t=0,1){x=0;y=1-t;label=1;};
  func uu= sin(y*Pi)/10;
  func vv= cos(x*Pi)/10;
  
  mesh Th = buildmesh ( a(6) + b(4) + c(4) +d(4) + e(4) + f(6));
  
  // find a good deformation coef. 
  // ---------------------------------
  // return the minimal area of a triangle of Th 
  real okareamin = checkmovemesh(Th,[x,y])/10;
  // we accept to divide by 10 the area of the smallest triangles
  real coef=1000,cc=0;
  while (okareamin > (cc=checkmovemesh(Th,[x+coef*uu,y+coef*vv]) ) )
    {
      cout << " coef = " << coef << " min area " << cc << endl;
      coef /=2;
    }
  
  
  Th=movemesh(Th,[x+coef*uu,y+coef*vv]);
  plot(Th,wait=1,fill=1,ps="movemesh.eps");
  
  // save mesh 
  int i=12;
  string filename="Th"+i+".msh";
  savemesh(Th,filename);
}
// ------------------------------------------------------------
{  //  trunc mesh  tools exemples 
  mesh Th=square(3,3);
  int[int] n2o(1); 
  fespace Vh(Th,P1);
  Vh u;	
  int i,n=u.n;
  u=0;
  for (i=0;i<n;i++)
    {
      u[][i]=1;
      plot(u,wait=1);
      mesh Shi=trunc(Th,abs(u)>1e-10,split=2,label=2,new2old=n2o,fregion=i+0);
      int [int] lr = regions(Shi);
	  cout<< "regions " <<  i << " :: " << lr.n << " " << lr[0] << endl; 
	  assert( lr.n ==1 && lr[0] == i);
      plot(Th,Shi,wait=1,ps="trunc"+i+".eps");                    
      cout << " n2o " << n2o << endl; // where the element come
      u[][i]=0;
    }
}
// ------------------------------------------------------------
{  //  new stuff 2004 splitmesh (version 1.37)
  assert(version>=1.37);
  border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
  mesh Th=buildmesh(a(20));
  plot(Th,wait=1,ps="nosplitmesh.eps");
  plot(Th,wait=1);
  Th=splitmesh(Th,1+5*(square(x-0.5)+y*y));
  plot(Th,wait=1,ps="splitmesh.eps");
}

// ------------------------------------------------------------
{  //  new stuff 2004 emptymesh (version 1.40)
 // -- usefull to build Multiplicator space 
 //  build a mesh without internal point
 // with the same boundary 
 //  -----
  assert(version>=1.40);
  border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
  mesh Th=buildmesh(a(20));
  plot(Th,wait=1,ps="nosplitmesh.eps");
  plot(Th,wait=1);
  Th=emptymesh(Th);
  plot(Th,wait=1,ps="emptymesh-1.eps");
}
{  //  new stuff 2004 emptymesh (version 1.40)
 // -- usefull to build Multiplicator space 
 //  build a mesh without internal point
 //   if the adj triangle 
 //  -----
  assert(version>=1.40);
  mesh Th=square(10,10);
  int[int] ssd(Th.nt);
  fespace Ph(Th,P0);
   Ph sd;
  for(int i=0;i<ssd.n;i++)
   {  int iq=i/2;   // because 2 traingle per quad 
      int ix=iq%10;
      int iy=iq/10;  
    ssd[i]= 1 + (ix>=5) +  (iy>=5)*2;
    sd[][i]=ssd[i];
   }
  plot(sd,fill=1,wait=1);
  Th=emptymesh(Th,ssd);
  plot(Th,wait=1,ps="emptymesh-2.eps");
  savemesh(Th,"emptymesh-2.msh");
}

  // ------------------------------------------------------------
{  // get mesh information (version 1.37)
  mesh Th=square(2,2);
  // get data of the mesh 
  int nbtriangles=Th.nt;
  cout << " nb of Triangles = " << nbtriangles << endl;
  for (int i=0;i<nbtriangles;i++)
    for (int j=0; j <3; j++)
      cout << i << " " << j << " Th[i][j] = "
	   << Th[i][j] << "  x = "<< Th[i][j].x  << " , y= "<< Th[i][j].y 
	   << ",  label=" << Th[i][j].label << endl;
	    
//   Th(i)   return   the vextex i of Th
//   Th[k]   return   the triangle k of Th.
//   Th.be(i)  return  the boundary element 
  fespace femp1(Th,P1);
  femp1 Thx=x,Thy=y; 
  // get vertices information : 
  int nbvertices=Th.nv;
  cout << " nb of vertices = " << nbvertices << endl;
  for (int i=0;i<nbvertices;i++)
	cout << "Th(" <<i  << ") : "   // << endl;	
	     << Th(i).x << " " << Th(i).y  << " " << Th(i).label // version 2.19 
	     << "       old method: " << Thx[][i] << " " << Thy[][i] << " == R3  "  
	     << Th(i).P << endl; // version 4.10.1  jan 2022

// method to find information of point (0.55,0.6) 
  int it00 = Th(0.55,0.6).nuTriangle;// then triangle numbe 
  int nr00 = Th(0.55,0.6).region;
  
  real area00 = Th[it00].area; // new in version 2.19 
  real nrr00 = Th[it00].region; // new in version 2.19 
  real nll00 = Th[it00].label; // same as region in this case.
      
 //Hack  to get a triangle contening point x,y
  //     or   region number
  // -----------------------------------------
  fespace femp0(Th,P0);
  femp0 nuT; // a P0 function  to get triangle numbering
    for (int i=0;i<Th.nt;i++)
     nuT[][i]=i; 
  femp0 nuReg=region; // a P0 function to get the region number
  //  inquire 
  int it0=nuT(0.55,0.6); //  number of triangle Th's contening point (0.55,0,6);
  int nr0=nuReg(0.55,0.6); //  number of region of Th mesh contening point (0.55,0,6);
  // dump  
  cout << "  point (0.55,0,6) :triangle number " << it00 << " " << it00 
       << ", region = " << nr0 << " == " << nr00 << ",  area K " << area00 << endl;

  // new method to get boundary inforamtion 
 
  // version >3.4-1
  // --------- new stuff -----------------
  int k=0,l=1,e=1,v=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th(v).P; // coordinate of vetices v in R3 ::  22 jan 2022
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2])
	 << " , label  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<3;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1] << " , label " << Th.be(k).label 
	   <<  " tria  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 

regtest=Th.nv;
}
//   test to catch bogus boundary ( just a test)
{
int err;
real c0,c1;
c0=0;
c1=0;
mesh Th;
for( int i=0;i<=4;i++)
{
    c1=sin(i*pi/8);
try 
{
err=0; 
border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;}
border b(t=0,2*pi){ x=c0+0.3*cos(t); y=c1+0.3*sin(t);label=2;}
plot(a(50)+b(30),wait=1);
Th   = buildmesh(a(50)+b(30));
}
catch(...)
{
  err=1;
  plot(a(50)+b(30),wait=1,cmm="bogus border ",ps="bogusborder.eps");  
}
if(err==0)
  plot(Th,wait=1,cmm="mesh ok");
}
}
// <<multiborder>>
// in test ... 
{ 
// multy border syntax version 3.30 avril 2014 ... 
  real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
  // radius, centre of the 4 circles .. 
  real[int] RC=[ 0.1, 0.05, 0.05, 0.1],
            XC= [0.2,0.8,0.2,0.8],
            YC= [0.2,0.8,0.8,0.2];
  int[int]  NC=[-10,-11,-12,13]; //list number of $\pm$ segments
  // of the 4 circles borders  

  border bb(t=0,1;i) 
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 0; ; 
  }
  
  border cc(t=0,2*pi;i) 
 {
    x = RC[i]*cos(t)+XC[i];
    y = RC[i]*sin(t)+YC[i];
    label = i+1; 
  }
  int[int] nn=[4,4,5,7];// 4 border , with 4,4,5,7 segment respectively . 
  plot(bb(nn),cc(NC),wait=1);
  mesh th= buildmesh(bb(nn)+cc(NC)) ; 
  plot(th,wait=1,ps="multy-border.eps");
  // version 3.44-1
  cout << " th max mesh size = h = " << th.hmax << endl;
  cout << " th min mesh size     = " << th.hmin<< endl;
}
{
	include "movemeshsmooth.idp"
	mesh Th=square(3,3);
	int[int] lab=[1,2,3,4]; 
	Th=adaptmesh(Th,0.1,IsMetric=1);
	fespace Vh(Th,P1); 

	Vh u=x,v=y;
	verbosity=5;// 1000 debbug => plot 
	Th=movemeshsmooth(Th,lab,u[],v[],100);
	verbosity=1;
}
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
// build square $]-1,1[^2$
mesh Th=square(10,10,[2*x-1,2*y-1]); 
fespace Vh(Th,P1);
Vh u=2-x*x-y*y;
// old code ::
if(1)
{
   savemesh(Th,"mm",[x,y,u*.5]); //  save mm.points and mm.faces file for medit
   // build a mm.bb file 
	{ ofstream file("mm.bb"); 
	file << "2 1 1 "<< u[].n << " 2 \n";
	int j;
	for (j=0;j<u[].n ; j++)  
	  file << u[][j] << endl; 
    }  
    // call ffmedit command 	
    if(!NoGraphicWindow) exec("ffmedit mm");
    // clean files
    exec("rm mm.bb mm.faces mm.points");
}
else 
{
// new code 
load "medit" load "msh3"  
    meshS Th3= movemesh23(Th,transfo=[x,y,u*0.5]);
    medit("mm",Th3);// bug un color of u ... FH 
}

// FFCS: testing 3D plots
plot(u);
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
//  \url{from:   http://en.wikipedia.org/wiki/HSV_color_space} 
//The HSV (Hue, Saturation, Value) model, 
//   defines a color space in terms of three constituent components:
//
//HSV color space as a color wheel
//Hue, the color type (such as red, blue, or yellow):
//   Ranges from 0-360 (but normalized to 0-100% h ere)
// Saturation, the "vibrancy" of the color: Ranges     from 0-100%
//    The lower the saturation of a color, the more "grayness" is present 
//    and the more faded the color will appear.
// Value, the brightness of the color:
//   Ranges from 0-100%
// 
real[int] colorhsv=[  // color hsv model
  4./6., 1 , 0.5, // dark blue
  4./6., 1 , 1, //  blue
  5./6., 1 , 1, //  magenta
  1, 1. , 1, //  red
  1, 0.5 , 1 // light red 
   ];
mesh Th=square(5,5);
fespace Vh(Th,P2);
Vh uh=x*x+y*y,vh=-y^2+x^2;
assert(n+1 < nn);
//  compute a cut 
for (int i=0;i<=n;i++)
 {
   xx[i]=i;
   yy[i]=uh(real(i)/n,real(i)/n); // value of uh at point (i/10. , i/10.) 
 }
 
 plot(Th,uh,[uh,vh],value=true,ps="three.eps",wait=true); // plot mesh, isovalue, and vector
 //  zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]
 plot(uh,[uh,vh],bb=[[0.1,0.2],[0.5,0.6]],wait=true,grey=1,fill=1,value=1,ps="threeg.eps");  // in grey with filling
 plot([xx(0:n),yy(0:n)],[xx(0:n:5),yy(0:n:5)],ps="likegnu.eps",wait=true); //  like gnuplot plot a cut of uh

 real[int] viso(31);
 
 for (int i=0;i<viso.n;i++)
   viso[i]=i*0.1;
   
 plot(uh,viso=viso(0:viso.n-1),value=1,fill=1,wait=1,hsv=colorhsv,ps="threehsv.eps");

   
//  signe of pressure if correct 
assert(version>1.18); 
mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;


varf bx(u1,q) = int2d(Th)( (dx(u1)*q)); 

varf by(u1,q) = int2d(Th)( (dy(u1)*q));

varf a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(1,2,4,u1=0)  +  on(3,u1=1) ;

Xh bc1; bc1[] = a(0,Xh);
Xh b;
                   
matrix A= a(Xh,Xh,solver=CG); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);
Xh bcx=1,bcy=0;
Mh f=x;
Xh g=sin(x);
b[]  = Bx'*f[]; 
b[] += bc1[] .*bcx[];
u1[] = A^-1*b[];
// This test shows some powerful features of FreeFEM on a
// simple example: -\Delta(u) = 1 in the unit cercle with u=0 on the
// border of the unit cercle. This problem has an analytical solution
// u = (1-x^2-y^2)/4

// Mesh
real pi = 4*atan(1);
border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}

mesh disk = buildmesh(a(50));
plot(disk);

// Fespace
fespace femp1(disk, P1);
femp1 u, v;

// Problem
problem laplace(u, v)
	= int2d(disk)(	// bilinear form
		  dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	+ int2d(disk)(	// linear form
		- 1*v
	)
	+ on(1, u=0)	// boundary condition
	;

// Solve
laplace;

// Error
femp1 err = u - (1-x^2-y^2)/4;

// Plot
plot(u, value=true, wait=true);
plot(err, value=true, wait=true);

// Display (on terminal)
cout << "error L2 = " << sqrt(int2d(disk)( (u-(1-x^2-y^2)/4)^2 )) << endl;
cout << "error H10 = " << sqrt(int2d(disk)((dx(u)+x/2)^2)
							 + int2d(disk)((dy(u)+y/2)^2) )<< endl;

// Mesh adaptation
disk = adaptmesh(disk, u, err=0.01);
plot(disk, wait=1);

// Solve
laplace;

// Error
err =u-(1-x^2-y^2)/4;

// Plot
plot(u, value=true, wait=true);
plot(err, value=true, wait=true);

// Display
cout << "error L2 = " << sqrt(int2d(disk)( (u-(1-x^2-y^2)/4) ^2 )) << endl;
cout << "error H10 = " << sqrt(int2d(disk)((dx(u)+x/2)^2)
							 + int2d(disk)((dy(u)+y/2)^2)) << endl;
//  test of diff kind of freefem++ function
// work if version >= 3.3 

verbosity=500;

real[int] G=[7,8,9];

func mesh carre(int n) 
{ mesh th=square(n,n);
  return th;}
  
  
func real[int]   aaa(int n) 
{ real[int] a(n);
  a=0;
  a[2]=n;
  return a;}
  
  
 func real[int]   bb(real[int] &a) 
{ cout << " sum " <<a.sum <<endl;
  return a;}
 func real[int]   bbb(real[int] a) 
{ cout << " sum " <<a.sum <<endl;
  a[0]=100; // change the value of the parameter  
  return a;}

 func real[int]   GG(int i) 
{ G[1]=i;
  return G;}
 
 func real[int]   GGG(int i) 
{ G[1]=i;
  return G(1:2);} 

  
  
mesh Th=  carre(2);
carre(3); // the mesh is lose 
cout << Th.nt << endl;
cout << aaa(3) << endl;
  
real[int] A=[1,4,7];
cout << bb(A) << endl;
real[int] aa=bb(A);
real[int] ac=bbb(A); //  warning A[0] is set to 100.
cout << " xxxx "<< endl;
cout << aa << " == "  << A <<endl;
assert(A[0]==100);
cout << ac << " == " << A << endl;
cout << GG(3) << endl;
cout << GGG(5) << endl;

verbosity=1;

//  test Nan and inf  version 3.19 

real x=1e1000;
cout << x << " " << isInf(x) << " " << isNaN(x) << " " << isNormal(x) <<endl;
x =1;
cout << x << " " << isInf(x) << " " << isNaN(x) << " " << isNormal(x)<<endl;
x = NaN();
cout << x << " " << isInf(x) << " " << isNaN(x) << " " << isNormal(x)<<endl;
//  sparse matrix test  ---
// example of the new matrix feature in version 1.40
// -------------------------------------------------

// ALH - for regression test
real regtest;

for(int step=0; step <2; ++step)
  {
    mesh  TH = square(3,4);
    mesh  th = square(2,3);
    mesh  Th = square(4,4);

    complex ccc;
    ccc= 1;
    cout << ccc << endl;
    fespace VH(TH,P1);
    fespace Vh(th,P1);
    fespace Wh(Th,P1);

    matrix RB= interpolate(VH,Vh);  // build interpolation matrix Vh->Vh 
    matrix RBB= interpolate(Wh,Vh);  // build interpolation matrix
    matrix<complex> B=RB;
    B = B*(1+2i);
    B(0,4)=1i;
    matrix<complex> BB=RBB;

    varf vA(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+ int1d(Th)(u*v); 
    matrix<complex> A=vA(Wh,Wh);
    Vh<complex> ml=0;
    cout << " ml " << ml[] << endl;
    varf vML(u,v) = int2d(th)(1.*v);
    ml[]=vML(0,Vh); // build the P1 mass lump of P1
    cout << ml[] << endl;
    matrix<complex> ML(ml[]); // matrix diagonal
    cout << "ML="<<ML << endl;
    cout << "B="<<B << endl;
    matrix<complex> BML=B*ML; // a faire 
    matrix<complex> tB=B';        //'; transpose and conjugate 
	cout << " trace tB=" << tB.trace << " trace B  " << B.trace << endl;
    matrix<complex> MLtB=ML'*B'; // 
    assert( imag(tB.trace) * imag(B.trace) < 0) ;
	{
		
		 matrix<complex> BtB = B'*B, tBtB= BtB';
		 matrix<complex> ZZ =  BtB - tBtB;
		 cout << " BtB hermitain  "<< ZZ.linfty <<  endl; 
		 ZZ =  BtB - BtB';
		 cout << " BtB hermitain  "<< ZZ.linfty <<  endl; 
		 assert( ZZ.linfty < 1e-10);
	}
	
    cout << "BML="<<BML << endl;
    cout << "MLtB=" << MLtB << endl;

    // WARNING if sparsesolver is not install
    // the sparsesolver solver is replace by LU 
    //  but LU need skyline matrix 
    string typesolver="sparsesolver";
    if(!HaveUMFPACK) typesolver="GMRES"; 
    set(A,solver=typesolver); // set a solver 

    VH<complex> uH=0;
    Vh<complex> uh=x+y+1i*(x-y);
    uH[]= B*uh[];
    Vh uHr = imag(uH);
    plot(uHr,wait=1);
    matrix<complex> BtA = BB'*A;//';
	cout << BtA << endl; 
    matrix<complex> BtAB = BtA*BB;
    if(HaveUMFPACK)  
      set(BtAB,solver=sparsesolver);  
    else 
      set(BtAB,solver=GMRES);  
    Vh<complex> ff=1+1i;
    Vh<complex> xx;
    Vh xxr;
    cout << " ------ " << endl;

    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    xxr=imag(xx);
    plot(xxr, wait=1);

    // ALH - For regression test
    regtest=real(xx[]'*xx[]); //');
      
    {
      int N=10;
      complex [int,int] A(N,N);
      complex [int] a(N),b(N),bb(N);
      A =0;
      for (int i=0;i<N;i++)
	{
	  A(i,i)=1.+i;
	  if(i+1 < N)    A(i,i+1)=-i-1i*i;
	  a[i]=i*(1.+2i);
	}
      b=A*a;
  
      cout << " b =" << b << endl ;
      cout << " a =" << a << endl ;
      cout << " b'*b (hermissian product) = " << b'*b << endl; //';
      cout << " a'*a = " << a'*a << endl;//';;
      assert( abs(imag(b'*b)) <1e-5);//')));
      cout << "xxxx\n"; 
      matrix<complex> sparseA=A;
  
      cout << sparseA << endl;
      sparseA = 2*sparseA+sparseA;
      sparseA = 4*sparseA+sparseA*(5+1i); //  * 27
      matrix<complex> sparseB=sparseA;//+sparseA+sparseA; ;
      cout << sparseA << endl;
      cout << sparseB << endl; // *81 
      cout << "sparseB = " << sparseB(0,0) << endl;
      // ajoute version  2.0-2
      sparseA=A;
      verbosity=4;
      if(HaveUMFPACK)		
	set(sparseA,solver=sparsesolver,tolpivot=1e-10,tolpivotsym=1e-9);  
      else 
	set(sparseA,solver=GMRES);  
      bb=sparseA^-1*a;
      verbosity=1;
      b = sparseA*bb;
      b -= a;
      cout << " nb coef sparseA " << sparseA.nbcoef << endl; 
      cout << " ||b.||_1  " << b.l1 << endl;
      cout << " ||b.||_2  " << b.l2 << endl;
      cout << " ||b.||_infty  " << b.linfty << endl;
      assert(b.l1 < 1e-10);
    }
    {// version 3.8    
      mesh Th=square(2,2);
      fespace Xh(Th,P1);
      varf vv(u,v)= int2d(Th)( ((2+1i)*u*v)')+int2d(Th)((3+2i)*v);//');
      varf vr(u,v)= int2d(Th)( u*v);//');

      matrix<complex> A=vv(Xh,Xh);
      matrix  Ar=vr(Xh,Xh);
      complex[int] vc=vv(0,Xh);
      real[int] vrr=vc.re,vii=vc.im;
      vrr=vc.re;
      vii=vc.im;
  // bugus ::s
 // vrr=real(vc);
 // vii=imag(vc);
  cout << "vc[0] = " <<vc[0] 
    << " = " << vc.re[0]  << " +i " << vc.im[0] 
    << " :: = " << vrr[0]  << " +i " << vii[0] 
    
    <<endl;
  
      cout << [ 1i, 1i]'*[ 1i, 1i] <<endl;//'; 
      // real part un complex par of matrix . 
      Ar = A.re;
      cout <<" A(0,0) = " << A(0,0)  << "   ";
      cout << " A.re(0.0) = " << Ar(0,0) << "   " ;
      Ar = A.im; 
      cout << " A.im(0.0) = " << Ar(0,0) << endl  ;

  
      macro Grada(u) [  phia*dx(u) + phiax*u ,dy(u) ]// ...
	func phia = exp(-2i*pi*x);
      func phiax = -2i*pi*exp(-2i*pi*x);

      varf va(u,v)= int2d(Th)( Grada(v)'*Grada(u) ) ;//');
      A = va(Xh,Xh);
      matrix<complex> At=A';//';
      cout << A(1,2)' << " ==  " << At(2,1) << endl;//';
      A = A+ (-1)*At;
      cout << A << endl;
      // copy and initialisation of complex matric with real matrix. 
      A = Ar; 
      matrix<complex> Ac=Ar; 
    }
  }
{  // version 3.46
  mesh Th=square(2,2);
  fespace Xh(Th,P1);
  varf vr(u,v)= int2d(Th)( u*v);//');
  matrix A=vr(Xh,Xh); 
  Xh<complex> u=(1+2i)*x*y;
  Xh ur=x*y;
  complex[int]  Au=A*u[];
  real[int]  Aur=A*ur[];
  Au.re -= Aur;
  Au.im -= 2.*Aur;
  cout << Au.linfty << endl; 
  assert(Au.linfty < 1e-10); 
}
// This a the rotating hill problem with one turn.
// First 1/2 turn is a convection equation and second 1/2 a convection diffusion

border a(t=0, 2*pi)     {    x = cos(t);    y = sin(t);  }; // the unit circle
mesh th2 = buildmesh(a(35));                                 // triangulates the disk
mesh th= trunc(th2,1,split=2);
fespace Vh(th,P1);
fespace Vh2(th2,P2);
Vh2 v = exp(-10*((x-0.3)^2 +(y-0.3)^2));                  // initial condition
plot(v);

real dt = 0.17,t=0;                                                 // time step
Vh u1 = y, u2 = -x;                                        // rotation velocity
int i;
Vh2 vv,vo; // work  Finite element function 
for ( i=0; i< 20 ; i++) {
    t += dt;
    vo=v;
    v=convect([u1,u2],-dt,vo);                          // convect v by u1,u2, dt seconds, results in f
 // convec(u1,u2,dt,v,v) won't work
    plot(v,cmm="convection: t="+t + ", min=" + v[].min + ", max=" +  v[].max,wait=0);
};

problem  A(v,vv,solver=CG) = int2d(th2)(v*vv/dt + 0.01*(dx(v)*dx(vv)+dy(v)*dy(vv)) )
  + int2d(th2)(-vv*convect([u1,u2],-dt,vo)/dt)  + on(a,v=0);
  
for ( i=0; i< 20 ; i++) 
{ 
    t += dt;
  vo=v;
  A; // solve le problem A
  plot(v,cmm="convection& diffusive: t="+t + ", min=" + v[].min + ", max=" +  v[].max);
};  

plot(v,wait=1);
// FFCS: making a numerical value visible for regression tests
real regtest;

{ // ---  a real non linear test ---
mesh Th=square(10,10);  // mesh definition of $\Omega$
Th = adaptmesh(Th,0.05,IsMetric=1,splitpbedge=1);

//plot(Th,wait=1);
//Th = adaptmesh(Th,0.1,IsMetric=1,splitpbedge=1);
plot(Th,wait=0);
fespace Vh(Th,P1);      // finite element space
fespace Ph(Th,P1dc);      // make optimization 

Vh b=1;  // to defined b 
// $ J(u) = 1/2 \int_\Omega f(|\nabla u|^2) - \int\Omega  u b $
// $ f(x) = a*x + x-ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) =  \frac{1}{(1+x)^2}$
real a=0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u);}
func real ddf(real u) { return 1/((1+u)*(1+u));}

Vh u=0; //  the current value of the solution
Ph alpha; // to store  $ (|\nabla u|^2)$
Ph dfalpha; // to store  $f' (|\nabla u|^2)$
Ph ddfalpha ; //to store = $2 f''( |\nabla u|^2) $  optimisation

int iter=0;


//   methode of  Newton Ralphson to solve dJ(u)=0;
//    $$ u^{n+1} = u^n - (\frac{\partial dJ}{\partial u_i})^{-1}*dJ(u^n) $$ 
//   ---------------------------------------------
  // the variationnal form of evaluate  dJ 
  // --------------------------------------
  //  dJ =  f'()*( dx(u)*dx(vh) + dy(u)*dy(vh) 
  varf vdJ(uh,vh) =  int2d(Th)( dfalpha*( dx(u)*dx(vh) + dy(u)*dy(vh) ) - b*vh)
  + on(1,2,3,4, uh=0);
  // the variationnal form of evaluate  ddJ   
  // hJ(uh,vh) =  f'()*( dx(uh)*dx(vh) + dy(uh)*dy(vh)
  //            + f''()( dx(u)*dx(uh) + dy(u)*dy(uh) ) * (dx(u)*dx(vh) + dy(u)*dy(vh)) 
  varf vhJ(uh,vh) = int2d(Th)( dfalpha*( dx(uh)*dx(vh) + dy(uh)*dy(vh) )
   +  ddfalpha*( dx(u)*dx(vh) + dy(u)*dy(vh)  )*( dx(u)*dx(uh) + dy(u)*dy(uh) ) )
   + on(1,2,3,4, uh=0);
   
 // the newton algorithm  
  Vh v,w; 
  u=0;
  for (int i=0;i<100;i++)
   {
    alpha = dx(u)*dx(u) + dy(u)*dy(u);// optimization
    dfalpha = df( alpha ) ; // optimization
    ddfalpha = 2*ddf(alpha ) ; // optimization
    v[]= vdJ(0,Vh);
    real res= v[]'*v[]; //'
    cout << i <<  " residu^2 = " <<  res  << endl;
    matrix H;
    if( res< 1e-12) break;
    H= vhJ(Vh,Vh,factorize=3,solver=LU);
    w[]=H^-1*v[];
    u[] -= w[];
    plot (u,wait=0,cmm="solution with Newton Raphson");

    // FFCS: regression tests
    regtest=u[]'*u[]; //'
   }

load "medit" load "msh3"  
    meshS Th3= movemesh23(Th,transfo=[x,y,u*1.5]);
    medit("N",Th3);
}
/*
  Incompressible Navier Stokes 
    with Taylor-Hood Finite element
    No linearity : Newton method 
    continuation on Reynols Number
    Mesh adaptation 
    
    Test case Laminar Flow over a Backward Facing Step  Gamm Workshop
    
     K.Morgan, J.Priaux and F.Thomasset, Analysis of laminar flow over a backward facing step, Vol9 of Notes on Num. Fluid Mech., Vieweg, 1984. 
    
*/

// FFCS regression test value
real regtest;

real[int] Reynold=[50,150,300,400,500];
real[int] HH=[1.5,1]; 
real[int,int] reattachP=[ [ 2.8, 2 ], [ 5.16, 3.7 ]] ;  // reattachP[irey,cas]  
int nerr=0; 
bool adapt=1; // do adap or not 
bool dplot=0; // debug plot 
for(int cas=0;cas<2;++cas)
{
real h=HH[cas]-0.5,H=HH[cas],l=3,L=22;
int[int] ll=[3,2,5,1];
// label 1 in
//       2  out 
//       3  down wall
//       4   step 
//       5   up wall 
func zoom=[[2.5,0],[10,H]];
mesh Th=square(22,6,[x*22,y*H],label=ll);
Th=trunc(Th, (x>l) | (y >0.5),label=4); 
func meshsize= 2*max(0.05,max(max(x-l,0.0)/19./5.,max(l-x,0.0)/3./8. ));
func uin=(H-y)*(y-0.5)/square((H-0.5)/2.);
Th=adaptmesh(Th,meshsize,IsMetric=1);
Th=adaptmesh(Th,meshsize,IsMetric=1);
plot(Th,wait=0);
fespace Xh(Th,P2);
fespace Mh(Th,P1);
fespace XXMh(Th,[P2,P2,P1]);
XXMh [u1,u2,p];
XXMh [v1,v2,q]; 

macro div(u1,u2) (dx(u1)+dy(u2))//
macro grad(u1,u2) [dx(u1),dy(u2)]//
macro ugrad(u1,u2,v) (u1*dx(v)+u2*dy(v)) //
macro Ugrad(u1,u2,v1,v2) [ugrad(u1,u2,v1),ugrad(u1,u2,v2)]//

solve Stokes ([u1,u2,p],[v1,v2,q],solver=sparsesolver) =
    int2d(Th)( ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*div(v1,v2)-q*div(u1,u2)
           )
  + on(1,u1=uin,u2=0) 
  + on(3,4,5,u1=0,u2=0);

 Xh uu1=u1,uu2=u2;  
plot(coef=0.2,cmm="Stokes [u1,u2] et p  ",p,[uu1,uu2],wait=0);
plot(coef=0.2,cmm="Stokes  p  ",p,wait=0);
Mh psi,phi;


solve streamlines(psi,phi) = 
      int2d(Th)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
   +  int2d(Th)( -phi*(dy(u1)-dx(u2)))
   +  on(3,4,psi=0)+ on(5,psi=-2./3.*(H-0.5))
   ;
real[int] psiviso(31);
{int k=0;
for(int i=-20;i<0;i++)
 psiviso[k++] = i*2./3.*(H-0.5)/20;
for(int i=0;i<=10;i++)
 psiviso[k++] = i*2./3.*(H-0.5)/100/(H*H*H);
}

plot(psi,wait=0,viso=psiviso);
int i=0;
real  nu=1./100.;
real dt=0.1;
real alpha=1/dt;





XXMh [up1,up2,pp];
varf   vDNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
            
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
            + Ugrad(u1,u2,up1,up2)'*[v1,v2]
            + Ugrad(up1,up2,u1,u2)'*[v1,v2]
           )
  + on(1,3,4,5,u1=0,u2=0) 
;


varf   vNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
          
            + nu * ( dx(up1)*dx(v1) + dy(up1)*dy(v1)
            +  dx(up2)*dx(v2) + dy(up2)*dy(v2) )
            + pp*q*(0.000001) 
            + pp*dx(v1)+ pp*dy(v2)
            + dx(up1)*q+ dy(up2)*q
            + Ugrad(up1,up2,up1,up2)'*[v1,v2]//'
	      )
  + on(1,3,4,5,u1=0,u2=0) 
  ;

for(int krey=0;krey<Reynold.n;++krey)
  { 
    real re=Reynold[krey];
    real lerr=0.01;
    
    for(int step=0;step<(adapt?2:1) ;step++)
      {
     if(adapt)
     {
	  Th=adaptmesh(Th,[u1,u2],p,abserror=1,cutoff=1e-5,err=lerr,nbvx=100000,hmin=0.01);
	  if(dplot) plot(Th,wait=0,bb=zoom);
     }
	[u1,u2,p]=[u1,u2,p];
	[up1,up2,pp]=[up1,up2,pp];
	
	for (i=0;i<=20;i++)
	  {
	    nu = (H-h)/re;
	    up1[]=u1[];
	    real[int] b = vNS(0,XXMh);
	    matrix Ans=vDNS(XXMh,XXMh);
	    set(Ans,solver=sparsesolver);
	    real[int] w = Ans^-1*b;
	    u1[] -= w;
	    cout << " iter = "<< i << "  " << w.l2 <<  " rey = " << re << endl;
	    if(w.l2<1e-6) break; 
	    // uu1=u1;uu2=u2;
	    if(dplot) plot(coef=0.2,cmm="H="+H+" re "+re+ " [u1,u2] et p  ",p,[uu1,uu2],bb=zoom);  
	    
	  } ;
      }
    uu1=u1;uu2=u2;
    streamlines;
    real rp1=1./(H-h)*int1d(Th,3)( real( (x>=l & x < (l+0.5)) | (x>(l+0.4)) & (x<10)& (dy(psi) >= 1e-5)) ) ;
    real rp2=1./(H-h)*int1d(Th,3)( real( (x>=l & x < (l+0.5)) | (x>(l+0.4)) & (x<10)& (dy(psi) >= -1e-5)) ) ;
    real rp3=1./(H-h)*int1d(Th,3)( real( (x>=l & x < (l+0.5)) | (x>(l+0.4)) & (x<10)& (dy(u1)<=0)       ) ) ;
    cout << " Reattach point " << rp2 << " " << rp2 << " " << rp3 << endl;
    real rp = (rp1+rp2)/2;
    real rppaper =  krey < 2 ? reattachP(krey,cas) : rp; 
    real err= abs(rppaper - rp)/rp;
    if( err>0.5 ) nerr++;//  
    cout << "\n\n\n";
    cout << "H= " << H << " Re " << re << " Reattach point " << rp << " paper=" << rppaper << " err "<< err 
         << "  psi max = " << psi[].max <<endl; 
    cout << "\n\n\n";
    plot(coef=0.2,cmm="H="+H+", rey="+re+" [u1,u2] et p  ",p,[uu1,uu2],wait=0,nbiso=20,bb=zoom);//,ps="Upstep-"+H+"-"+re
    plot(coef=0.2,cmm="H="+H+", rey="+re+" [u1,u2] et p  ",p,[uu1,uu2],wait=0,nbiso=20,bb=zoom);//,ps="Upstep-"+H+"-"+re+".ps");  
    plot(coef=0.2,cmm="H="+H+", rey="+re+" [u1,u2] et p  ",psi,bb=zoom,viso=psiviso);//,ps="psi-step-"+H+"-"+re+".ps");  

    // FFCS regression test value
    regtest=uu1[]'*uu1[];//'
     }
}
assert(nerr==0); 
/*
  Example to cumpute min max of min size of edge on each triangle.
*/
mesh Th=square(10,10,[x,y*(1+x)]);
fespace Ph(Th,P0);
fespace Eh(Th,P0edge);
Ph hmin = hTriangle;

varf vle(u,v)=intalledges(Th)(v*1./nTonEdge);

real[int] lenedges = vle(0,Eh);
cout << " min / max len edges " << lenedges.min << " "  << lenedges.max <<endl; 

for(int k=0; k< Th.nt; ++k)
for(int i=0; i<3; ++i)
{
	hmin[][k]= min(hmin[][k],lenedges[Eh(k,i)]);
}
plot(hmin,fill=1,value=1);
real hminmin = 0.1, hminmax= 0.141421;
cout << " hmin = " << hmin[].min << " max = " << hmin[].max << endl;
assert(abs(hmin[].min-hminmin) < 0.0001); 
assert(abs(hmin[].max-hminmax) < 0.0001); 
//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
//  on intalledges :
// the edge are see nTonEdge times so we / nTonEdge
// remark: nTonEdge =1 on border edge and =2 on internal 
// we are in a triangle normal is the exterior normal
// def: jump = external - internal value,     on border extern  - internal value
//      mean = (external + internal value)/2, on border just mean internal value

macro dn(u) (N.x*dx(u)+N.y*dy(u) ) //  def the normal derivative 

mesh Th = square(10,10); // unite square 
fespace Vh(Th,P2dc);     // Discontinous P2 finite element
fespace Xh(Th,P2);
//  if pena = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=100; // a paramater to add penalisation 

func f=x+2*y;
func g=x-y;
Vh u,v;
Xh uu,vv;
solve A(u,v,solver=sparsesolver) = 
   int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)  )
 + intalledges(Th)(//  loop on all  edge of all triangle 
          ( jump(v)*mean(dn(u)) -  jump(u)*mean(dn(v)) 
          + pena*jump(u)*jump(v) ) / nTonEdge 
          ) 
- int2d(Th)(f*v) 
- int1d(Th)(g*dn(v)  + pena*g*v) 
;

solve A1(uu,vv,solver=CG) 
= 
 int2d(Th)(dx(uu)*dx(vv)+dy(uu)*dy(vv)) - int2d(Th)(f*vv) + on(1,2,3,4,uu=g);
 

plot(u,uu,cmm="Continuous and Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
Vh eh= u-uu;
real err =eh[].linfty/u[].linfty; 
cout << " ||err|| relative: " << err << " " <<uu[].linfty  <<  endl;

assert( err < 1e-2);

//  bug string macro parameter   version < 1.41
// bug in string parameter version before <2.5
// -----------------

 macro tyty(uu) uu//  
cout << tyty("toto") << endl;

func string   write(string  fn,real[int] & u)
{
  cout <<"write :   " <<  fn << " u = "<<  u << endl;  //  delete 2 times before version 2.5 
  return fn; 
}

func string   write1(string  fn,real[int] & u)
{
  cout << "write 1 " << fn << " u = " << u << endl;   
  string toto=fn; ;
  return toto+"dfsdf"; 
}

real[int] u(3);
u=1;

string tt=tyty("toto1"+1+" -- 77");

string t1="0123456789";// write(tt,u);

string t2;


  {
    t2=  write1(t1,u)+write1(tt,u); // 
    // because the local variable of write1 are  delete 2 times at the  ;
    cout << " t2 = " << t2 << endl;
  }
if(0)
   { // the correct way
     t2=  write1(t1,u);
     t2=t2 + write1(tt,u); 
    cout << " t2 = " << t2 << endl;
   }
// new operator
t2 ="12340005678";
t2(4:3) = "abcdefghijk-"; 
string t55=t2(4:3);
//t2 = "12340abcdefghijk-005678";
cout << t2 << endl;
cout << "  find abc " << t2.find("abc") << endl;
cout << "r find abc " << t2.rfind("abc") << endl;
cout << " find abc from 10  " << t2.find("abc",10) << endl;
cout << " ffind abc from 10 " <<t2.rfind("abc",10) << endl;
cout << "   " << string("abcc").length << endl; 
cout << " t55 " << t55 << endl;
{  // add getline version 3.0-6 jan 2009 FH
string s;
ifstream toto("xyf");
for (int i=0;i<10;++i)
  {
   getline(toto,s);
   cout << i << " : " << s << endl;
  }
}
// add  3.29 + Stringification, LINE, FILE, ltime ..

macro aa()  "tyty"  //
cout << aa << endl; 

// <<Stringification>> reference example

cout << "in " << FILE << " line " << LINE << "    -- '" << Stringification( "zzz" aa  () {} +  /* */  bb cc) << "'" << endl;

cout << " unix time = " << time() << " " << ltime() << endl;

 
//  compute the solution of a Laplace operator in a Semi infini domain.
//  with coupling of Boundary element with periodicity BC in x . 
// -------------------------------------------------------------
include "ExtractDofsonBorder.idp"
real eps0=1;
int labup=3, labdown=1;
int nharm= 10; // Number of  Harmonique

func ug= max(0.,-(x-0.5)*(x-0.75)); // boundary condition.. 

macro Grad(u) [dx(u),dy(u)] // eom


real Xmax=1,Ymax=0.3;
int NNx=100,NNy=NNx*Ymax;
mesh Th=square(NNx,NNy,[x*Xmax,y*Ymax]); 
fespace Vh(Th,P1,periodic=[[2,y],[4,y]]);

Vh uref; // la solution de reference. 

{ // calcule de la solution de reference in  Huge Domaine.
mesh Th1=square(NNx,NNx*10,[x*Xmax,10*Xmax*y]); // pour la solution de reference 
fespace Uh(Th1,P1,periodic=[[2,y],[4,y]]);
Uh uu,vv;
solve Pref(uu,vv)=int2d(Th1)(eps0*(Grad(uu)'*Grad(vv)))+on(labdown,uu=ug);
 uref=uu; 
 plot(uu,wait=1,cmm=" ref sol / large Th ");
} // pour nettoyer la memoire

plot(uref,wait=1,cmm=" ref sol / Th");


varf vP(u,v)=int2d(Th)(eps0*(Grad(u)'*Grad(v)))+on(labdown,u=ug);
varf vF(u,v)=on(labdown,u=ug);
matrix<complex> A=vP(Vh,Vh);  // la matrice sans BEM. 

complex[int] b=vF(0,Vh);
Vh<complex> u;

{// for cleanning all local varaible at end of block.
 // computation of the matrice BEM
  // nb of  DoF on border 
 int[int] IdfB2Vh(1); // for numbering IdfB2Vh[i]==i 
 ExtractDofsonBorder(labup,Vh,IdfB2Vh,-1)
 int kdfBEM=IdfB2Vh.n;
 // verif
 if(0)  { Vh X=x;
     real[int] xx(IdfB2Vh.n);
     xx=X[](IdfB2Vh);
     cout << IdfB2Vh << endl; 
     cout << xx << endl; 
   }
//  end of the numbering computation
 // so  IdfB2Vh[ibem] = iVh where ibem is a df of on bem , and iVh is a df in Vh space. 
   real perio=Xmax;
   complex  deuxpii=2*pi*1i;
   int n=0;// 
   // Use of higher order Quadarture formular ...
   varf vWn(u,w)=int1d(Th,labup,qforder=10)(exp(-deuxpii*(n)*x)*w);
      
   //complex[int] wn=vWn(0,Vh);//  with Vh numbering.. 

   complex[int,int] ABemFull(kdfBEM,kdfBEM);// the full bem matrix in Bem numbering.
   ABemFull=0;//  set of 0 
   for ( n=-nharm;n<=nharm;++n)
    {
    	complex[int] wwn(kdfBEM);
    	complex[int] wn=vWn(0,Vh);
    	wwn=wn(IdfB2Vh);//  wwn(i) = wn(IdfB2Vh(i))  i=0 a wwn.n -1 
        complex Gs=+2.*pi*abs(n/perio/perio)*eps0;
    	ABemFull += Gs*wwn*wwn';
    }
    
 
  matrix<complex> ABem=ABemFull(IdfB2Vh^-1,IdfB2Vh^-1); // Build the sparse BEm matrix
   //  ABem(IdfB2Vh(ib),IdfB2Vh(jb)) = ABemFull(ib,jb) 
  A = A + ABem;
  }// for cleanning all local varaible at end of block. ABem ABemFull
  set(A,solver=sparsesolver);
  u[]=A^-1*b;
  Vh ur=real(u),ui=imag(u);
  Vh  err=ur-uref;
  cout << " err Linty=" << err[].linfty << " /  " <<  uref[].linfty << endl; 

  plot(ur,uref,wait=1,cmm="ur + uref ");

    
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


cout << "--------- file : adapt.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "adapt.edp";
	real TESTadapt=u[].max-u[].min;
		cout<<"adapt reference value = "<<REFadapt
				<<" test value ="<<TESTadapt<<endl;
			assert(TESTadapt<REFadapt*(1+0.01));
				assert(TESTadapt>REFadapt*(1-0.01));
};

cout << "--------- file : adaptindicatorP1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "adaptindicatorP1.edp";
	real TESTadaptindicatorP1=u[].max-u[].min;
		cout<<"adaptindicatorP1 reference value = "<<REFadaptindicatorP1
				<<" test value ="<<TESTadaptindicatorP1<<endl;
			assert(TESTadaptindicatorP1<REFadaptindicatorP1*(1+0.01));
				assert(TESTadaptindicatorP1>REFadaptindicatorP1*(1-0.01));
};

cout << "--------- file : adaptindicatorP2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "adaptindicatorP2.edp";
	real TESTadaptindicatorP2=u[].max-u[].min;
		cout<<"adaptindicatorP2 reference value = "<<REFadaptindicatorP2
				<<" test value ="<<TESTadaptindicatorP2<<endl;
			assert(TESTadaptindicatorP2<REFadaptindicatorP2*(1+0.01));
				assert(TESTadaptindicatorP2>REFadaptindicatorP2*(1-0.01));
};

cout << "--------- file : algo.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "algo.edp";
	real TESTalgo=umax;
		cout<<"algo reference value = "<<REFalgo
				<<" test value ="<<TESTalgo<<endl;
			assert(TESTalgo<REFalgo*(1+0.01));
				assert(TESTalgo>REFalgo*(1-0.01));
};

cout << "--------- file : array.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "array.edp";
	
};

cout << "--------- file : a_tutorial.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "a_tutorial.edp";
	real TESTaXtutorial=1+max(err[].max,-err[].min);
		cout<<"a_tutorial reference value = "<<REFaXtutorial
				<<" test value ="<<TESTaXtutorial<<endl;
			assert(TESTaXtutorial<REFaXtutorial*(1+0.001));
				assert(TESTaXtutorial>REFaXtutorial*(1-0.001));
};

cout << "--------- file : beam.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "beam.edp";
	real TESTbeam=uu[]'*uu[];
		cout<<"beam reference value = "<<REFbeam
				<<" test value ="<<TESTbeam<<endl;
			assert(TESTbeam<REFbeam*(1+5e-2));
				assert(TESTbeam>REFbeam*(1-5e-2));
};

cout << "--------- file : calculus.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "calculus.edp";
	
};

cout << "--------- file : cavity.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "cavity.edp";
	real TESTcavity=psi[]'*psi[];
		cout<<"cavity reference value = "<<REFcavity
				<<" test value ="<<TESTcavity<<endl;
			assert(TESTcavity<REFcavity*(1+1e-2));
				assert(TESTcavity>REFcavity*(1-1e-2));
};

cout << "--------- file : convect2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "convect2.edp";
	real TESTconvect2=v[]'*v[];
		cout<<"convect2 reference value = "<<REFconvect2
				<<" test value ="<<TESTconvect2<<endl;
			assert(TESTconvect2<REFconvect2*(1+1e-1));
				assert(TESTconvect2>REFconvect2*(1-1e-1));
};

cout << "--------- file : convect-apt.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "convect-apt.edp";
	real TESTconvectXapt=error;
		cout<<"convect-apt reference value = "<<REFconvectXapt
				<<" test value ="<<TESTconvectXapt<<endl;
			assert(TESTconvectXapt<REFconvectXapt*(1+5e-1));
				assert(TESTconvectXapt>REFconvectXapt*(1-5e-1));
};

cout << "--------- file : convect.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "convect.edp";
	real TESTconvect=v[]'*v[];
		cout<<"convect reference value = "<<REFconvect
				<<" test value ="<<TESTconvect<<endl;
			assert(TESTconvect<REFconvect*(1+1e-1));
				assert(TESTconvect>REFconvect*(1-1e-1));
};

cout << "--------- file : dumptable.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "dumptable.edp";
	
};

cout << "--------- file : ex-vf.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "ex-vf.edp";
	
};

cout << "--------- file : FE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "FE.edp";
	real TESTFE=wdc[]'*wdc[];
		cout<<"FE reference value = "<<REFFE
				<<" test value ="<<TESTFE<<endl;
			assert(TESTFE<REFFE*(1+1e-2));
				assert(TESTFE>REFFE*(1-1e-2));
};

cout << "--------- file : fluidStructAdapt.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "fluidStructAdapt.edp";
	real TESTfluidStructAdapt=uu[]'*uu[];
		cout<<"fluidStructAdapt reference value = "<<REFfluidStructAdapt
				<<" test value ="<<TESTfluidStructAdapt<<endl;
			assert(TESTfluidStructAdapt<REFfluidStructAdapt*(1+2e-1));
				assert(TESTfluidStructAdapt>REFfluidStructAdapt*(1-2e-1));
};

cout << "--------- file : fluidStruct.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "fluidStruct.edp";
	real TESTfluidStruct=uu[]'*uu[];
		cout<<"fluidStruct reference value = "<<REFfluidStruct
				<<" test value ="<<TESTfluidStruct<<endl;
			assert(TESTfluidStruct<REFfluidStruct*(1+2e-1));
				assert(TESTfluidStruct>REFfluidStruct*(1-2e-1));
};




cout << "--------- file : LapDG2.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LapDG2.edp";
	real TESTLapDG2=u[]'*u[];
		cout<<"LapDG2 reference value = "<<REFLapDG2
				<<" test value ="<<TESTLapDG2<<endl;
			assert(TESTLapDG2<REFLapDG2*(1+1e-2));
				assert(TESTLapDG2>REFLapDG2*(1-1e-2));
};

cout << "--------- file : Laplace.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "Laplace.edp";
	real TESTLaplace=uh[]'*uh[];
		cout<<"Laplace reference value = "<<REFLaplace
				<<" test value ="<<TESTLaplace<<endl;
			assert(TESTLaplace<REFLaplace*(1+1e-2));
				assert(TESTLaplace>REFLaplace*(1-1e-2));
};

cout << "--------- file : LaplaceP1bis.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP1bis.edp";
	real TESTLaplaceP1bis=u[]'*u[];
		cout<<"LaplaceP1bis reference value = "<<REFLaplaceP1bis
				<<" test value ="<<TESTLaplaceP1bis<<endl;
			assert(TESTLaplaceP1bis<REFLaplaceP1bis*(1+1e-2));
				assert(TESTLaplaceP1bis>REFLaplaceP1bis*(1-1e-2));
};

cout << "--------- file : LaplaceP1.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP1.edp";
	real TESTLaplaceP1=uh[]'*uh[];
		cout<<"LaplaceP1 reference value = "<<REFLaplaceP1
				<<" test value ="<<TESTLaplaceP1<<endl;
			assert(TESTLaplaceP1<REFLaplaceP1*(1+1e-2));
				assert(TESTLaplaceP1>REFLaplaceP1*(1-1e-2));
};

cout << "--------- file : LaplaceP1P2h.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP1P2h.edp";
	real TESTLaplaceP1P2h=u2h[]'*u2h[];
		cout<<"LaplaceP1P2h reference value = "<<REFLaplaceP1P2h
				<<" test value ="<<TESTLaplaceP1P2h<<endl;
			assert(TESTLaplaceP1P2h<REFLaplaceP1P2h*(1+1e-2));
				assert(TESTLaplaceP1P2h>REFLaplaceP1P2h*(1-1e-2));
};

cout << "--------- file : LaplaceRT.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceRT.edp";
	real TESTLaplaceRT=u1[]'*u1[];
		cout<<"LaplaceRT reference value = "<<REFLaplaceRT
				<<" test value ="<<TESTLaplaceRT<<endl;
			assert(TESTLaplaceRT<REFLaplaceRT*(1+1e-2));
				assert(TESTLaplaceRT>REFLaplaceRT*(1-1e-2));
};

cout << "--------- file : mesh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "mesh.edp";
	
};

cout << "--------- file : movemesh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "movemesh.edp";
	real TESTmovemesh=u[]'*u[];
		cout<<"movemesh reference value = "<<REFmovemesh
				<<" test value ="<<TESTmovemesh<<endl;
			assert(TESTmovemesh<REFmovemesh*(1+1e-2));
				assert(TESTmovemesh>REFmovemesh*(1-1e-2));
};

cout << "--------- file : nolinear-elas.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "nolinear-elas.edp";
	real TESTnolinearXelas=(1+errb);
		cout<<"nolinear-elas reference value = "<<REFnolinearXelas
				<<" test value ="<<TESTnolinearXelas<<endl;
			assert(TESTnolinearXelas<REFnolinearXelas*(1+1e-3));
				assert(TESTnolinearXelas>REFnolinearXelas*(1-1e-3));
};

cout << "--------- file : NSUzawaCahouetChabart.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "NSUzawaCahouetChabart.edp";
	real TESTNSUzawaCahouetChabart=u1[].linfty;
		cout<<"NSUzawaCahouetChabart reference value = "<<REFNSUzawaCahouetChabart
				<<" test value ="<<TESTNSUzawaCahouetChabart<<endl;
			assert(TESTNSUzawaCahouetChabart<REFNSUzawaCahouetChabart*(1+1e-2));
				assert(TESTNSUzawaCahouetChabart>REFNSUzawaCahouetChabart*(1-1e-2));
};

cout << "--------- file : onde.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "onde.edp";
	real TESTonde=u[]'*u[];
		cout<<"onde reference value = "<<REFonde
				<<" test value ="<<TESTonde<<endl;
			assert(TESTonde<REFonde*(1+1e-2));
				assert(TESTonde>REFonde*(1-1e-2));
};



cout << "--------- file : plot.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot.edp";
	real TESTplot=uh[]'*uh[];
		cout<<"plot reference value = "<<REFplot
				<<" test value ="<<TESTplot<<endl;
			assert(TESTplot<REFplot*(1+1e-2));
				assert(TESTplot>REFplot*(1-1e-2));
};

cout << "--------- file : readmesh.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "readmesh.edp";
	real TESTreadmesh=u[]'*u[];
		cout<<"readmesh reference value = "<<REFreadmesh
				<<" test value ="<<TESTreadmesh<<endl;
			assert(TESTreadmesh<REFreadmesh*(1+2e-1));
				assert(TESTreadmesh>REFreadmesh*(1-2e-1));
};

cout << "--------- file : region.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "region.edp";
	real TESTregion=u[]'*u[];
		cout<<"region reference value = "<<REFregion
				<<" test value ="<<TESTregion<<endl;
			assert(TESTregion<REFregion*(1+1e-1));
				assert(TESTregion>REFregion*(1-1e-1));
};

cout << "--------- file : saverestore.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "saverestore.edp";
	
};

cout << "--------- file : schwarz-gc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "schwarz-gc.edp";
	real TESTschwarzXgc=u1[]'*u1[];
		cout<<"schwarz-gc reference value = "<<REFschwarzXgc
				<<" test value ="<<TESTschwarzXgc<<endl;
			assert(TESTschwarzXgc<REFschwarzXgc*(1+5e-2));
				assert(TESTschwarzXgc>REFschwarzXgc*(1-5e-2));
};

cout << "--------- file : schwarz-no-overlap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "schwarz-no-overlap.edp";
	real TESTschwarzXnoXoverlap=u[]'*u[];
		cout<<"schwarz-no-overlap reference value = "<<REFschwarzXnoXoverlap
				<<" test value ="<<TESTschwarzXnoXoverlap<<endl;
			assert(TESTschwarzXnoXoverlap<REFschwarzXnoXoverlap*(1+5e-2));
				assert(TESTschwarzXnoXoverlap>REFschwarzXnoXoverlap*(1-5e-2));
};

cout << "--------- file : schwarz-overlap.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "schwarz-overlap.edp";
	real TESTschwarzXoverlap=u[]'*u[];
		cout<<"schwarz-overlap reference value = "<<REFschwarzXoverlap
				<<" test value ="<<TESTschwarzXoverlap<<endl;
			assert(TESTschwarzXoverlap<REFschwarzXoverlap*(1+5e-2));
				assert(TESTschwarzXoverlap>REFschwarzXoverlap*(1-5e-2));
};

cout << "--------- file : sparse-matrix.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "sparse-matrix.edp";
	real TESTsparseXmatrix=regtest;
		cout<<"sparse-matrix reference value = "<<REFsparseXmatrix
				<<" test value ="<<TESTsparseXmatrix<<endl;
			assert(TESTsparseXmatrix<REFsparseXmatrix*(1+5e-2));
				assert(TESTsparseXmatrix>REFsparseXmatrix*(1-5e-2));
};

cout << "--------- file : sparse-cmatrix.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "sparse-cmatrix.edp";
	real TESTsparseXcmatrix=real(regtest);
		cout<<"sparse-cmatrix reference value = "<<REFsparseXcmatrix
				<<" test value ="<<TESTsparseXcmatrix<<endl;
			assert(TESTsparseXcmatrix<REFsparseXcmatrix*(1+5e-2));
				assert(TESTsparseXcmatrix>REFsparseXcmatrix*(1-5e-2));
};

cout << "--------- file : StokesUzawa.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "StokesUzawa.edp";
	real TESTStokesUzawa=u1[]'*u1[];
		cout<<"StokesUzawa reference value = "<<REFStokesUzawa
				<<" test value ="<<TESTStokesUzawa<<endl;
			assert(TESTStokesUzawa<REFStokesUzawa*(1+5e-2));
				assert(TESTStokesUzawa>REFStokesUzawa*(1-5e-2));
};

cout << "--------- file : tablefunction.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "tablefunction.edp";
	real TESTtablefunction=fxy[]'*fxy[];
		cout<<"tablefunction reference value = "<<REFtablefunction
				<<" test value ="<<TESTtablefunction<<endl;
			assert(TESTtablefunction<REFtablefunction*(1+1e-2));
				assert(TESTtablefunction>REFtablefunction*(1-1e-2));
};

cout << "--------- file : AdjointSolve.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "AdjointSolve.edp";
	
};
// variationnal inequality 
// --------------------------
//  Probleme:
//  $ - \Delta u = f , \quad u=g \on \Gamma, \quad u < umax  $
//  algo of   Primal-Dual Active set strategy as a semi smoth Newton Method
//   HinterMuller , K. Ito, K. Kunisch 
//  to appeared in SIAM Option
// Thank to O. Pironneau 
// --------------------------
// F. Hecht
//  -----------------------
 mesh Th=square(10,10);
 real eps=1e-10;
 fespace Vh(Th,P1);     // P1 FE space
 int n = Vh.ndof; // number of Degree of freedom
 Vh uh,uhp,Ah;              // unkown and test function. 
real[int] rhs(n);
real cc=1000; 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 func gmax=0.05;
 Vh umax=gmax;
//
real tol=0.05,tolmin=0.002;  
real tgv = 1e30;
real res=0;
 varf a(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form
varf vM(uh,vh) = int2d(Th)(uh*vh);


matrix A=a(Vh,Vh,tgv=tgv,solver=CG);
matrix AA=a(Vh,Vh);
matrix M=vM(Vh,Vh);
rhs = a(0,Vh,tgv=tgv);
real[int] Aii(n),Aiin(n),Ah1(n),b(n);

Aii=A.diag; // get the diagonal of the matrix 
//cout << " Aii= " << Aii << endl;
Ah =0;
uhp=0;
Vh lh=0;
int kadapt=0,kkadapt=0;
for(int iter=0;iter<100;++iter)
{
  
  // solve the problem plot(uh); // to see the result
  b = rhs;
  //  add new lock condition on i / if (Ah[i] ==1 )
  Ah1= 1.; Ah1  -= Ah[];  // Ah1  = ! Ah 
  b = Ah[] .* umax[];  b *= tgv;       b  -=  Ah1 .* rhs;
  Aiin = Ah[] *  tgv; Aiin  +=  Ah1  .* Aii;
  A.diag = Aiin;
  set(A,solver=CG); // important to change precondiconning 
  uh[] = A^-1* b;
  lh[] = AA * uh[];
  lh[] += rhs;
  //  plot(lh,wait=1);
  Ah = ( lh + cc*( umax- uh)) < 0.; 
  
  // plot(Ah, wait=1,cmm=" lock ",value=1 );
  plot(uh,wait=1,cmm="uh");
  real[int] d(n),Md(n);
  d= uh[]-uhp[];    
  Md = M*d;
  real err = sqrt(Md'*d);
  Md=M*uh[];
  Ah1=1.;
  real intuh  = (Ah1'*Md); // int uh; 
  cout << " err norm L2 " << err << " "
       << " int uh = " << intuh  
      <<  " kkadapt =" << kkadapt <<endl;
  res = intuh;
  if(err< eps && kkadapt ) break;
  bool adapt = err< eps || (iter%5 == 4)  ;
  if(adapt)
    { 
      kadapt++;
      Th=adaptmesh(Th,uh,err=tol);
      kkadapt = tol == tolmin; // we reacht  the bound       
      tol = max(tol/2,tolmin);
       cout << " ++ tol = " << tol << "  " << kadapt << " " << kkadapt <<endl;
      plot(Th,wait=0);
      uhp=uhp;
      n=uhp.n;	
      uh=uh;
      Ah=Ah;
      lh=lh;
      umax = gmax; 
      A=a(Vh,Vh,tgv=tgv,solver=CG);
      AA=a(Vh,Vh);
      M=vM(Vh,Vh);
      Aii.resize(n);	
      Aiin.resize(n);
      Ah1.resize(n);
      b.resize(n);
      rhs.resize(n); 
      Aii=A.diag; // get the diagonal of the matrix 
      rhs = a(0,Vh,tgv=tgv);
    }
  uhp[]=uh[];
} 
savemesh(Th,"mm",[x,y,uh*10]);
{
  int nn=100;

  real[int] xx(nn+1),yy(nn+1),pp(nn+1);
  for (int i=0;i<=nn;i++)
   {
   
     xx[i]=i/real(nn);
     yy[i]=uh(0.5,i/real(nn));
    }
   plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
}

Aiin=M*uh[];
Aii=1.;
cout << " -- int uh = " << res  << endl;
assert( abs(res-0.0288611) < 0.001);  
   
  
  
include "ElasticLaw2d.idp"

// ================================================================

//  I[0] = trace(C) +1 
//  I[1] = (trace(C)^2 - trace(C^2) )/2
//  I[2] = det(C) 
//  Model from wiki https://en.wikipedia.org/wiki/Neo-Hookean_solid
// the  materail coef ..
real mu = 5.e2; //  kg/cm^2
real lambda= 2e3;
real C1 = mu/2;
real D1 = lambda/2;
// log(sqrt(a)*sqrt(a)) = log(sqrt(a))+log(sqrt(a)) 
// 2 log(sqrt(a)) = log(a)
// J=sqrt(I3) =>   (sqrt(I3)-1)^2 ' =  sqrt(I3)' (sqrt(I3)-1) = 0.5 I3' (1-1/sqrt(I3))
// -1/sqrt(I3)'  = 0.5 I3''/(sqrt(I3)*I3)
// the enarge ... 
macro W(I) ( 
	C1*(I[0] - 4. - log(I[2]) ) 
      + D1 *sqr(1.-sqrt(I[2])) )   //EOM  (J-1)^2 
          
macro dW(I,dI)  ( 
	  C1*    (dI[0] - dI[2]/I[2] )
	+ 0.5*D1*dI[2]*(1.-1/sqrt(I[2])  )
	)    //EOM
// EOM
macro ddW(I,dI,ddI) ( 
	+C1/sqr(I[2])*ddI[2]*dI[2] 
	+ 0.25*D1* dI[2]*ddI[2]/(sqrt(I[2])*I[2])
	)   //EOM
 // EOM

// ************************************************
// THE (BIO)MECHANICAL PARAMETERS: Begin

//  Elastic coefficients


//  Stress loads
real Pa = -3.e2;


// THE (BIO)MECHANICAL PARAMETERS: End
// ************************************************


// ************************************************
// THE COMPUTATIONAL PARAMETERS: Begin

//  The wound radius
real InnerRadius = 1.e0;

//  The outer (truncated) radius
real OuterRadius = 4.e0;

//  Tolerance (L^2)
real tol = 1.e-4;

//  Extension of the inner ellipse ((major axis) - (minor axis))
real InnerEllipseExtension = 1.e0;

int m = 100, n = 50;

border InnerEdge(t = 0, 2.0*pi) {x = (1.0 + InnerEllipseExtension) * InnerRadius * cos(t); y = InnerRadius * sin(t); label = 1;}

border OuterEdge(t = 0, 2.0*pi) {x = (1.0 + 0.0 * InnerEllipseExtension) * OuterRadius * cos(t); y = OuterRadius * sin(t); label = 2;}

mesh Th = buildmesh(InnerEdge(-m) + OuterEdge(n));
plot(Th,wait=1);
int bottom=1, right=2,upper=3,left=4;

int Nnewton     = 20;
real epsNewton  = 1.e-10;

fespace Wh(Th,[P2,P2]);

// methode de Newton ..

 Wh [d1,d2]=[0,0/100]; // Ok CL sirichlet homogene . 
 Wh [w1,w2],[v1,v2];
 
    cout << 0  << "  Energie  = " << int2d(Th)(W2d([d1,d2])) - int1d(Th,1)( Pa * ([d1,d2]'*[N.x,N.y]) )  << endl;
    
 for(int i=0;i<Nnewton;++i)
 {
  
    solve dWW([w1,w2],[v1,v2]) = 
         int2d(Th)( ddW2d([d1,d2],[w1,w2],[v1,v2]) ) 
       - int2d(Th)( dW2d([d1,d2],[v1,v2]) )
       - int1d(Th,1)( Pa * (N'*[v1,v2]) ) 
       
       // -[v1,v2]'*[f1,f2] ) 
      + on(2,w1=0,w2=0); 
      
     d1[] -= w1[];
     plot([d1,d2],coef=1/d1[].linfty, cmm=d1[].linfty);
     real err = w1[].linfty;
     cout << i << " err Nw = " << err << " d max = " << d1[].linfty 
          << "  Energie  = " << int2d(Th)(W2d([d1,d2]))  - int1d(Th,1)( Pa * ([d1,d2]'*[N.x,N.y]) )  << endl;
     if(err< epsNewton) break;
     assert(err < 1e5);  
 
  }
{
       real amplify= 0.3/d1[].linfty;
       mesh Thm=movemesh(Th,[x+d1*amplify,y+d2*amplify]);
       plot(Thm,wait=1,[d1,d2],coef=amplify);
}
  
 
 // Laplace operator with RHS sum of Dirac 
 //  f = sum  cdelta_i \delta_i
 real[int] xdelta = [0.25,0.6];//  coord x de delta_i
 real[int] ydelta = [0.25,0.6];//  coord x de delta_j
 real[int] cdelta=[1.,2.];//  coef    delta_i
  mesh Th=square(10,10);
  verbosity=0;

// Reference value for FFCS regression tests
real ref;

 for(int iter=0;iter < 11;iter++)
 {

 fespace Vh(Th,P1);     // P1 FE space
 
 matrix D = interpolate(Vh,xdelta,ydelta); // the interpolation matrix  
 // at point (xdelta[j],ydelta[i] ) \hfilll
 // so $D_ij = w^i((xdelta[j],ydelta[j]) $ where $w^i$ are the basic function of $V_h$. 
 
 Vh uh,vh;  // unkown and test function. 
 func g=0;                 //  boundary condition function
 Vh b;
 b[]= D*cdelta;
 b[]= -b[];
 problem laplace(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + b[]                         //  linear form of the rhs (so an array)
  + on(1,2,3,4,uh=0) ;          //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  cout <<iter << "max uh = " << uh[].max << " nv =  "<< Th.nv <<  endl; 
  plot(uh,wait=1,dim=3,fill=1);
  Th=adaptmesh(Th,uh,nbvx=100000,err= 0.01*1.15^-iter);
  
  // Reference value for FFCS regression tests
  ref=uh[]'*uh[];//'
  }
int n=20,nn=n+10;
real[int] xx(nn),yy(nn);
mesh Th=square(5,5);
fespace Vh(Th,P2);
Vh uh=x*x+y*y,vh=-y^2+x^2;
assert(n+1 < nn);
//  compute a cut 
for (int i=0;i<=n;i++)
 {
   xx[i]=i;
   yy[i]=uh(real(i)/n,real(i)/n); // value of uh at point (i/10. , i/10.) 
 }
 
 plot(Th,uh,[uh,vh],value=true,ps="three.eps",wait=true); // plot mesh, isovalue, and vector
 plot([xx(0:n),yy(0:n)],[xx(0:n:5),yy(0:n:5)],ps="likegnu.eps",wait=true); //  like gnuplot plot a cut of uh
// file for gnuplot
{
  ofstream gnu("plot.gp");
for (int i=0;i<=n;i++)
 {
  gnu <<  xx[i] << " " << yy[i] << endl;
 }
}
savegnuplot(Th,"Th.gp");
exec("echo 'plot \"Th.gp\" w l, \"\" w labels offset 1.5 \
pause 5 \
set term postscript \
set output \"gnuTh.eps\" \
replot \
quit' | gnuplot"); 
//  to call gnuplot command and wait 5 second (tanks to unix command)
//  and make postscipt plot 
exec("echo 'plot \"plot.gp\" w l \
pause 5 \
set term postscript \
set output \"gnuplot.eps\" \
replot \
quit' | gnuplot"); 
// Mesh
border ba(t=0, 1.0){x=t;   y=0;  label=1;}
border bb(t=0, 0.5){x=1;   y=t;  label=2;}
border bc(t=0, 0.5){x=1-t; y=0.5;label=3;}
border bd(t=0.5, 1){x=0.5; y=t;  label=4;}
border be(t=0.5, 1){x=1-t; y=1;  label=5;}
border bf(t=0.0, 1){x=0;   y=1-t;label=6;}
mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));
savemesh(Th, "th.msh");

// Fespace
fespace Vh(Th, P2);
fespace Nh(Th, P0);
Vh u, v;
Nh rho, logrho;

// Variables
real[int] viso(21);
for (int i = 0; i < viso.n; i++)
	viso[i]=10.^(+(i-16.)/2.);

// Functions
func f = (x-y);

// Problem
problem Probem1 (u, v, solver=CG, eps=1.0e-6)
	= int2d(Th, qforder=5)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	+ int2d(Th, qforder=10)(-f*v)
	;

varf indicator2 (uu, chiK)
	= intalledges(Th)(
		  chiK*lenEdge*square(jump(N.x*dx(u) + N.y*dy(u)))
	  )
	+ int2d(Th)(
		  chiK*square(hTriangle*(f+dxx(u)+dyy(u)))
	)
	;

// Adaptation loop
real error = 0.01;
for (int i = 0; i < 4; i++) {
	// Solve
	Probem1;
	cout << u[].min << " " << u[].max << endl;

	// Plot
	plot(u, wait=1);

	// Indicator
	rho[] = indicator2(0, Nh);
	rho = sqrt(rho);
	logrho = log10(rho);
	cout << "rho min = " << rho[].min << ", rho max = " << rho[].max << endl;

	// Plot
	plot(rho, fill=1, wait=1, cmm="indicator density ", value=1, viso=viso, nbiso=viso.n);
	plot(logrho, fill=1, wait=1, cmm="log 10 indicator density ", value=1, nbiso=10);

	// Mesh adaptation
	Th = adaptmesh(Th, [dx(u), dy(u)], err=error, anisomax=1);
	plot(Th, wait=1);

	// Interpolation
	u = u;
	rho = rho;

	// Update error
	error = error/2;
}
//  non linear elasticity model 
//   
//  -------------------------------
//  with huge utilisation of  macro  new version
// more simple 
// ---------------------------
//   optimize version 
// ------------
//  problem is  find $(uu,vn)$  minimizing  $J$
//  $ min J(un,vn) = \int 1/2 (F2) -  int Pa * un $
//   $ dJ(u,u,uu,vv) = int dF2(u,v,uu,vv) df(F2(u,v)) $
//   where $F2 =  (^t {E}  A {E} ) $,
//   $E(U) =  1/2 (\nabla U + \nabla U^t + \nabla U^t  \nabla U) $
//         ($u_1$)
//  with U=(   )
//         ($u_2$)
// so: 
//$$ E_ij = 0.5 ( d_i u_j + d_j u_i ) + \sum_k d_i u_k * d_j*u_k  \leqno(1)$$
//  the symetric tensor $t_{ij}$ are a vector  [t11,2*t12,t22] 
// date from
/*
Proposal for numerical benchmarking of fluid-structure interaction between an elastic object and laminar incompressible flow

Stefan Turek and Jaroslav Hron
Institute for Applied Mathematics and Numerics, University of Dortmund,
Vogelpothsweg 87, 44227 Dortmund, Germany

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.550.1689&rep=rep1&type=pdf

section 4.2 CSM test: 
*/

macro EL(u,v) [dx(u),(dx(v)+dy(u)),dy(v)] // is $[\epsilon_{11},2\epsilon_{12},\epsilon_{22}]$

macro ENL(u,v) [ 
(dx(u)*dx(u)+dx(v)*dx(v))*0.5,
(dx(u)*dy(u)+dx(v)*dy(v))    ,
(dy(u)*dy(u)+dy(v)*dy(v))*0.5 ] // EOM ENL 

macro dENL(u,v,uu,vv) [(dx(u)*dx(uu)+dx(v)*dx(vv)),
 (dx(u)*dy(uu)+dx(v)*dy(vv)+dx(uu)*dy(u)+dx(vv)*dy(v)),
 (dy(u)*dy(uu)+dy(v)*dy(vv)) ] // 
 
 
macro E(u,v) (EL(u,v)+ENL(u,v)) // is $[\E{11},\sqrt2\E{12},\E{22}]
macro dE(u,v,uu,vv) (EL(uu,vv)+dENL(u,v,uu,vv)) //
macro ddE(u,v,uu,vv,uuu,vvv) dENL(uuu,vvv,uu,vv) //
macro F2(u,v) (E(u,v)'*A*E(u,v)) // 
macro dF2(u,v,uu,vv)  (E(u,v)'*A*dE(u,v,uu,vv) ) //
macro ddF2(u,v,uu,vv,uuu,vvv) (
            (dE(u,v,uu,vv)'*A*dE(u,v,uuu,vvv)) 
          + (E(u,v)'*A*ddE(u,v,uu,vv,uuu,vvv))  )// EOM

//  for hyper elasticity problem 
//  -----------------------------
macro f(u) (u) // end of macro
macro df(u) (1) // end of macro
macro ddf(u) (0) // end of macro

// -------------------------------
//  
//   $  \sigma = 2 \mu E + \lambda tr(E) Id $
//   $   A(u,v)= \sigma(u):\E(v) $
//   
//   ( a b )
//   ( b c )
//
//  tr*Id : (a,b,c) -> (a+c,0,a+c) 
// so the associed matrix is:
//   ( 1 0 1 )
//   ( 0 0 0 )
//   ( 1 0 1 ) 
// ------------------
verbosity=0;

// data CMS 1 
real xp=0.35,yp=0.0;//
real upbench= -0.007187, vpbench= -0.066;

real EE = 1.4e6;
real rho = 1000;
real sigma = 0.4;
real mu = EE/(2*(1+sigma));
real lambda = EE*sigma/((1+sigma)*(1-2*sigma));
real gravity = -2;
int nnn = 10;

mesh Th = square(17*nnn,nnn,[0.35*x,0.02*(y-0.5)]);
cout<<" Th nt : " << Th.nt<<endl;
int bottom=1, right=2,upper=3,left=4;

plot(Th);

real a11= 2*mu +  lambda  ;
real a22= mu ; //  because [0,2*t12,0]' A [0,2*s12,0]  = 2*mu*(t12*s12+t21*s21) = 4*mu*t12*s12
real a33= 2*mu +   lambda ;
real a12= 0 ;
real a13= lambda ;
real a23= 0 ;
//  symetric part
real a21= a12 ;
real a31= a13 ;
real a32= a23 ;
func A = [ [ a11,a12,a13],[ a21,a22,a23],[ a31,a32,a33] ];  





 
fespace Vh(Th,[P2,P2]);






Vh [uu,vv], [w,s],[un,vn];
[un,vn]=[0,0];//  intialisation 
[uu,vv]=[0,0];



real errb=0; 
// Newton's method
// ---------------
for (int i=0;i<10;i++)
{
  cout << "Loop " << i << endl;
  solve NonLin([uu,vv],[w,s])=
    int2d(Th)(        ddF2(un,vn,uu,vv,w,s)  )
     - int2d(Th)(  dF2(un,vn,w,s) - rho*gravity*s)    
     + on(left,uu=0,vv=0);
  ;  
  real res = uu[].linfty ; //  norme  L^2 of [uu,vv]
  errb = max(abs(un(xp,yp)-upbench) , abs(vn(xp,yp)-vpbench));

  un[] -= uu[]; 
  cout << "     Linfty residual = " << res << endl;
  cout << "     u of A =" << un(xp,yp) << " " << vn(xp,yp)  <<  " bench " << upbench  << " "<< vpbench << " err bench =" << errb << endl; 
  plot(movemesh(Th, [x+un, y+vn]),wait=1,cmm=" i =" +i + " err =" + res);

  if (res<1e-10) break;
}

cout << " err bench = " << errb << endl;  
//plot([un,vn],wait=1);
mesh th1 = movemesh(Th, [x+un, y+vn]);
plot(th1,wait=1,ps="nl-elas.eps");
assert( errb < 1e-2);
// irregular boundary condition. 
real Ax=0.9,Ay=1;
real Bx=2,By=1;
real Cx=2.5,Cy=2.5;
real Dx=1,Dy=2;
real gx = (Ax+Bx+Cx+Dx)/4.;
real gy = (Ay+By+Cy+Dy)/4.;

macro  LINEBORDER(A,B,lab) border A#B(t=0,1){real t1=1.-t;x=A#x*t1+B#x*t;y=A#y*t1+B#y*t;label=lab;}//EOM

LINEBORDER(A,B,1)
LINEBORDER(B,C,2)
LINEBORDER(C,D,3)
LINEBORDER(D,A,4)

// , A (1-x)(1-y) B x(1-y)  C: x*y  , D (x-1)*y) 
//mesh Th=square(10,10,[Cx*x*y+ Bx*(1-x)*y + Cx*(1-x)*(1-y) + Dx*(x)*(1-y),Ay*x*y+ By*(1-x)*y + Cy*(1-x)*(1-y) + Dy*(x)*(1-y)]  );
int n=10;
macro dist(ax,ay,bx,by) sqrt(square((ax)-(bx))+ square((ay)-(by)))  // EOM  
real l1=dist(Ax,Ay,Bx,By);
real l2=dist(Bx,By,Cx,Cy);
real l3=dist(Cx,Cy,Dx,Dy);
real l4=dist(Dx,Dy,Ax,Ay);
func s1=dist(Ax,Ay,x,y)/l1;
func s2=dist(Bx,By,x,y)/l2;
func s3=dist(Cx,Cy,x,y)/l3;
func s4=dist(Dx,Dy,x,y)/l4;
cout << " l1:4 = "<< l1 << " " << l2 << " "<< l3 << " " <<l4 << endl;
cout << "  s1:4 (final point: :)= " << s1(Bx,By) << " " 
     << s2(Cx,Cy) << " " 
     << s3(Dx,Dy) << " " 
     << s4(Ax,Ay) << "\n "; 

mesh Th=buildmesh(AB(n)+BC(n)+CD(n)+DA(n),fixedborder=1);

verbosity=6;// to see the abscisse value pour the periodic condition.
fespace Vh(Th,P1,periodic=[[1,s1],[3,s3],[2,s2],[4,s4]]);
verbosity=1;
macro Grad(u) [dx(u),dy(u)]//EOM
Vh u,v;

real cc=0;
cc= int2d(Th)((x-gx)*(y-gy)-cc)/Th.area;
cout << " compatibility =" << int2d(Th)((x-gx)*(y-gy)-cc) <<endl;

solve Poission(u,v)=int2d(Th)(Grad(u)'*Grad(v)+ 1e-10*u*v)-int2d(Th)(10*v*((x-gx)*(y-gy)-cc));
plot(u,wait=1,value=1);

// Mesh
border ba(t=0, 1.0){x=t;   y=0;  label=1;}
border bb(t=0, 0.5){x=1;   y=t;  label=2;}
border bc(t=0, 0.5){x=1-t; y=0.5;label=3;}
border bd(t=0.5, 1){x=0.5; y=t;  label=4;}
border be(t=0.5, 1){x=1-t; y=1;  label=5;}
border bf(t=0.0, 1){x=0;   y=1-t;label=6;}
mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));
savemesh(Th, "th.msh");

// Fespace
fespace Vh(Th, P1);
fespace Nh(Th, P0);
Vh u, v;
Nh rho;

// Variables
real[int] viso(21);
for (int i = 0; i < viso.n; i++)
	viso[i] = 10.^(+(i-16.)/2.);

// Functions
func f = (x-y);

// Problem
problem Probem1 (u, v, solver=CG, eps=1.0e-6)
	= int2d(Th, qforder=5)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
		)
	+ int2d(Th, qforder=5)(-f*v)
	;

varf indicator2 (uu, chiK)
	= intalledges(Th)(
		  chiK*lenEdge*square(jump(N.x*dx(u) + N.y*dy(u)))
	)
	+ int2d(Th)(
		  chiK*square(hTriangle*(f + dxx(u) + dyy(u)))
	)
	;

// Adaptation loop
real error = 0.01;
for (int i = 0; i < 4; i++) {
	// Solve
	Probem1;
	cout << u[].min << " " << u[].max << endl;

	// Plot
	plot(u, wait=1);

	// Indicator
	rho[] = indicator2(0, Nh);
	rho = sqrt(rho);
	cout << "rho min = " << rho[].min << ", rho max = " << rho[].max << endl;

	// Plot
	plot(rho, fill=1, wait=1, cmm="indicator density", value=1, viso=viso, nbiso=viso.n);

	// Mesh adaptation
	Th = adaptmesh(Th, u, err=error, anisomax=1);
	plot(Th, wait=1);

	// Interpolation
	u = u;
	rho = rho;

	// Update error
	error = error/2;
}
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=CG) =          //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  - int1d(Th,1)( vh)
  - int2d(Th)( f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="LaplaceP1P2h.eps",value=true);
//  if error on macos version codeworrior 
//  remove in panal  PPC linker FreeFEm++ Setting Dead-strip Static Initializition Code Flag
  fespace V2h(Th,P2);
 V2h u2h,v2h;              // unkown and test function. 

 problem errorh (u2h,v2h,solver=CG) =           //  definion of  the problem 
    int2d(Th)( dx(u2h)*dx(v2h) + dy(u2h)*dy(v2h) ) //  bilinear form
  + int1d(Th,1)( u2h*v2h) 
  - int1d(Th,1)( v2h)
  - int2d(Th)( f*v2h )                          //  linear form
  + on(2,3,4,u2h=g) ;                      //  boundary condition form
 errorh;
plot(u2h,ps="ErrorHerachical.ps",value=true,wait=1);
real D=0.1, H=0.41;
real cx0 = 0.2, cy0 = 0.2; // center of cyl. 
real xa = 0.15, ya=0.2, xe = 0.25,ye =0.2;
border fr1(t=0,2.2){x=t; y=0; label=1;}
border fr2(t=0,H){x=2.2; y=t; label=2;}
border fr3(t=2.2,0){x=t; y=H; label=1;}
border fr4(t=H,0){x=0; y=t; label=1;}
border fr5(t=2*pi,0){x=cx0+D*sin(t)/2; y=cy0+D*cos(t)/2; label=3;}
int nn=15;
 
mesh Th=buildmesh(fr1(5*nn)+fr2(nn)+fr3(5*nn)+fr4(nn)+fr5(-nn*3));
real Um= 1.5;// max velocity (Rey 100) 
func Ub = Um*2./3.; 
real nu = 1e-3; 
real Rey = Ub*D/nu;
// Boundary condition 
func U1 = 4.*Um*y*(H-y)/(H*H)  ;
func U2 = 0. ;

 real T=2,t=0; 
 real dt = D/nn/Um;// CFL = 1 
 cout << " dt = " << dt <<endl;
real alpha=1/dt,epspq=1e-10;


fespace Mh(Th,[P1]);
fespace Xh(Th,[P2]);
fespace Wh(Th,[P1dc]);
macro grad(u) [dx(u),dy(u)] //
macro div(u1,u2) (dx(u1)+dy(u2)) //

 
 varf von1([u1,u2,p],[v1,v2,q]) =  on(3,u1=0,u2=0) + on(1,u1=U1,u2=U2);

//remark : the value 1000 in next line is manualy fitted, because free outlet. 
 varf vA(p,q) =int2d(Th)((grad( p ) '*grad(q)) ) + int1d(Th,2)(1000*p*q) ;
 varf vM(p,q) =int2d(Th,qft=qf2pT)(  p*q );

 varf vu([u1],[v1]) = int2d(Th)(alpha*(u1*v1)+nu*(grad(u1)'*grad(v1) )) 
                       + on(1,3,u1=0) ;
 varf vu1([p],[v1]) = int2d(Th)(p*dx(v1)) ;
 varf vu2([p],[v1]) = int2d(Th)(p*dy(v1)) ;
   
 string solver="UMFPACK";
 if(!HaveUMFPACK) solver="CHOLESKY";
 matrix pAM=vM(Mh,Mh,solver=solver); 
 matrix pAA=vA(Mh,Mh,solver=solver); 
 matrix AU=vu(Xh,Xh,solver=solver); 
 matrix B1=vu1(Mh,Xh);
 matrix B2=vu2(Mh,Xh);
 Xh u1,u2;
 Mh p;
varf vonu1([u1],[v1]) =  on(1,u1=U1) + on(3,u1=0);
varf vonu2([u1],[v1]) =  on(1,u1=U2) + on(3,u1=0);


real[int] brhs1 = vonu1(0,Xh);
real[int] brhs2 = vonu2(0,Xh);
 
varf  vrhs1(uu,vv)  = int2d(Th) (convect([u1,u2],-dt,u1)*vv*alpha)+vonu1 ;
varf  vrhs2(v2,v1)  = int2d(Th) (convect([u1,u2],-dt,u2)*v1*alpha)+vonu2;


func  real[int]   JUzawa(real[int] & pp) 
{
	real[int] b1=brhs1; b1 += B1*pp;
	real[int] b2=brhs2; b2 += B2*pp;
	u1[] = AU^-1 * b1;
	u2[] = AU^-1 * b2;
	pp  = B1'*u1[];
	pp += B2'*u2[];
	pp = -pp; 
	return pp; 
}

func  real[int]   Precon(real[int] & p)
 {  
    real[int] pa= pAA^-1*p;
    real[int] pm= pAM^-1*p;
    real[int] pp= alpha*pa+nu*pm;
 
  	return pp;
 }

 verbosity = 0; 
 p=0;
 
   
 Wh w; // to store voticity ..
  
 real eps=1e-6;
 int ndt = T/dt;
 for(int i=0;i<ndt;++i)
 {
     brhs1 = vrhs1(0,Xh);
     brhs2 = vrhs2(0,Xh);
     int res=AffineCG(JUzawa,p[],precon=Precon,nbiter=100,verbosity=10,veps=eps); 
     assert(res==1) ; 
     eps = -abs(eps); 
     w = -dy(u1)+dx(u2);
     plot(w,fill=1,wait=0, nbiso=40,WindowIndex=0);
    
     dt = min(dt,T-t);
     t += dt; 
     if( dt < 1e-10*T) break;  
	 if( clock()>50)  break; // to remove CPU limit exceed on some slow machine  
 }
 plot(w,fill=1,wait=0, nbiso=40,ps="NScahouetChabart.eps");
 cout << " u1 max " << u1[].linfty 
      << " u2 max " << u2[].linfty 
      << " p max = " << p[].max << endl; 
 
// FFCS: for regression tests
real regtest;
{
    // example of mesh with a given set of internal point (P)
    // P(i,0) x,
    // P(i,1) y,
    // P(i,2) = mesh density close to x,y not mandatory ..
    verbosity=1;
   
 real[int,int] P(100,3);
 for(int i=0; i<P.n; ++i)
  {
      P(i,0) = 0.5+0.1*cos(i*0.02*pi);
      P(i,1) = 0.5+0.1*sin(i*0.02*pi);
      P(i,2) = 0.05*0.02*2*pi;// mesh size auron point..
  }
// multy border syntax version 3.30 avril 2014 ... 
  real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
  // radius, centre of the 4 circles .. 
  real[int] RC=[ 0.1, 0.05, 0.05, 0.1],
            XC= [0.2,0.8,0.2,0.8],
            YC= [0.2,0.8,0.8,0.2];
  int[int]  NC=[-10,-11,-12,13]; //list number of $\pm$ segments
  // of the 4 circles borders  

  border bb(t=0,1;i) 
  {
  // i is the the index variable of the multi border loop 
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 0; ; 
  }
  
  border cc(t=0,2*pi;i) 
 {
    x = RC[i]*cos(t)+XC[i];
    y = RC[i]*sin(t)+YC[i];
    label = i+1; 
  }
  int[int] nn=[4,4,5,7];// 4 border , with 4,4,5,7 segment respectively . 
  plot(bb(nn),cc(NC),wait=1);
  mesh th= buildmesh(bb(nn)+cc(NC), points=P,nbvx=100000) ; 
  plot(th,wait=1,ps="multy-border+internal.eps"); 
  regtest = th.area; 
}
// macro the get the current mesh size
// parameters
// input:
//   - Th: the mesh
//   - Vh: P1 fespace on Th
// output:
//   - h: the Vh finite element finite set to the current mesh size
macro  MeshSizecomputation(Th, Vh, h)
{	/*Th mesh
	 * Vh P1 finite element space
	 * h the P1 mesh size value
	 */
	real[int] count(Th.nv);
	/* mesh size (lenEdge = int_e 1) */
	varf vmeshsizen(u, v) = intalledges(Th, qfnbpE=1)(v);
	/* number of edge / par vertex */
	varf vedgecount(u, v) = intalledges(Th, qfnbpE=1)(v/lenEdge);
	/* computation of the mesh size */
	count = vedgecount(0, Vh);
	h[] = 0.;
	h[] = vmeshsizen(0, Vh);
	cout << "count min = " << count.min << ", max = " << count.max << endl;
	h[] = h[]./count;
    cout << "bound meshsize = " << h[].min << " " << h[].max << endl;
} // end of macro MeshSizecomputation

// macro to remesh according the de residual indicator
// input:
//   - Th: the mesh
//   - Ph: P0 fespace on Th
//   - Vh: P1 fespace on Th
//   - vindicator: the varf to evaluate the indicator to ^2
//   - coef: coef on etameam
macro  ReMeshIndicator(Th, Ph, Vh, vindicator, coef)
{
	Vh h = 0;
	/* evalutate the mesh size  */
	MeshSizecomputation(Th, Vh, h);
	Ph etak;
	etak[] = vindicator(0, Ph);
	cout << "global  Eta: " << sqrt(etak[].sum) << "  ......... " <<  Th.nv<< endl;
	etak[] = sqrt(etak[]);
	plot(etak, ps="arei-etak.eps", fill=1, value=1);
	real etastar = coef*(etak[].sum/etak[].n);
	cout << "etastar = " << etastar << ", sum = " << etak[].sum << " " << endl;

	/* here etaK is discontinous
	 * we use the P1 L2 projection with mass lumping
	 */

	 Vh fn, sigma;
	varf veta(unused, v) = int2d(Th)(etak*v);
	varf vun(unused, v) = int2d(Th)(1*v);
	fn[] = veta(0, Vh);
	sigma[] = vun(0, Vh);
	fn[] = fn[] ./ sigma[];
	fn =  max(min(fn/etastar, 3.), 0.3333) ;

	/* new mesh size */
	h = h / fn ;
	Th = adaptmesh(Th, IsMetric=1, h, splitpbedge=1, nbvx=10000);
}

// Mesh
border ba(t=0, 1.0){x=t;   y=0;  label=1;}
border bb(t=0, 0.5){x=1;   y=t;  label=2;}
border bc(t=0, 0.5){x=1-t; y=0.5;label=3;}
border bd(t=0.5, 1){x=0.5; y=t;  label=4;}
border be(t=0.5, 1){x=1-t; y=1;  label=5;}
border bf(t=0.0, 1){x=0;   y=1-t;label=6;}
mesh Th = buildmesh (ba(6) + bb(4) + bc(4) +bd(4) + be(4) + bf(6));

// Fespace
fespace Vh(Th, P1); // for the mesh size
Vh u, v;
fespace Ph(Th, P0); // for the indicator

// Mesh adaptation
real hinit = 0.2; //
Vh   h = hinit; // the FE fonction  for the mesh size
// to build a mesh with a given mesh size: meshsize
Th = adaptmesh(Th, h, IsMetric=1, splitpbedge=1, nbvx=10000);
plot(Th, wait=1, ps="RRI-Th-init.eps");

// Functions
func f = (x-y);

// Problem
problem Poisson (u, v)
	= int2d(Th, qforder=5)(
		  u * v * 1.0e-10
		+ dx(u)*dx(v)
		+ dy(u)*dy(v)
	)
	- int2d(Th, qforder=5)(f*v)
	;

varf indicator2 (unused, chiK)
	= intalledges(Th)(
		  chiK*lenEdge*square(jump(N.x*dx(u) + N.y*dy(u)))
	)
	+int2d(Th)(
		  chiK*square(hTriangle*(f + dxx(u) + dyy(u)))
	)
	;

// Adaptation loop
for (int i = 0; i < 10; i++) {
	// Solve
	Poisson;

	// Plot
	plot(Th, u, wait=1);

	// Mesh adaptation
	real cc=0.7;
	if (i > 5) cc = 1;
	if (i < 9) {
		ReMeshIndicator(Th, Ph, Vh, indicator2, cc);
		u=u;
	}
	
	// Plot
	plot(u, Th, wait=1, ps="arei-Thu.eps", value=1);
}
//  
//   calcul d'une zone saturation en eau (nappe phratique)
//
real L=10;        // longueur du domaine					   	
real q=0.02;      // flux entrant
real K=0.5;	      //permeabilit	

real  erradap=0.001;
real  coef=1;



real h=2.1;	 // hauteur du bord gauche
real h1=0.35;    // hauteur du bord droite

//  maillage d'un tapeze
border a(t=0,L){x=t;y=0;};       // bas			   	
border b(t=0,h1){x=L;y=t;};      // droite
border f(t=L,0){x=t;y=t*(h1-h)/L+h;}; //  free surface
border d(t=h,0){x=0;y=t;};      // gauche

int n=10;
mesh Th=buildmesh (a(L*n)+b(h1*n)+f(sqrt(L^2+(h-h1)^2)*n)+d(h*n));
plot(Th,ps="dTh.eps");

fespace Vh(Th,P1);
int j=0,ii=0;

Vh u,v,uu,vv;

problem Pu(u,uu,solver=CG) = int2d(Th)( dx(u)*dx(uu)+dy(u)*dy(uu)) 
  + on(b,f,u=y) ;

problem Pv(v,vv,solver=CG) = int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  on (a, v=0) + int1d(Th,f)(vv*((q/K)*N.y- (dx(u)*N.x+dy(u)*N.y))); 
  

real errv=1;
verbosity=1;
while(errv>1e-6)
{
  j++;       
  Pu;
  Pv;
  plot(Th,u,v ,wait=0);
  errv=int1d(Th,f)(v*v);
  
//  if (j%10==0)
//    Th=adaptmesh(Th,u,err=erradap ) ;
  real coef=1;
  real mintcc = checkmovemesh(Th,[x,y])/5.; 
  real mint = checkmovemesh(Th,[x,y-v*coef]); 
  
  if (mint<mintcc ||  j%10==0) {  
    Th=adaptmesh(Th,u,err=erradap ) ;
    v=v;
    u=u;
    mintcc = checkmovemesh(Th,[x,y])/5.;     
  }
  
  while (1) 
  {  	    
    real mint = checkmovemesh(Th,[x,y-v*coef]); 
    
    if (mint>mintcc) break;
    
    cout << " min |T]  " << mint << endl;    
    coef /= 1.5;
  }
  
  Th=movemesh(Th,[x,y-coef*v]); // calcul de la deformation 
  cout << "\n\n"<<j <<"------------ errv = " << errv << "\n\n";

}
plot(Th,ps="d_Thf.eps");
plot(u,wait=1,ps="d_u.eps",fill=1);
// version 3.18-2 ...
real[int] a,b(10);
a.resize(b.n); // `
a=b;  
a=[1,2];
a.resize(5); //  Pas init a voir ??? 
cout << "a="<<a << endl;
real[int,int][int] m(10);
real[int][int] v(10);
for(int i=0;i<v.n;++i)
{
  v[i].resize(i+1);
  for(int j=0;j<v[i].n;++j)
    v[i][j] = 100*i + j;   
}

cout << " v = " << v << endl;
v.resize(4);
cout << " v = " << v << endl;
v.resize(10);
cout << " v = " << v << endl;

// test sub array of full matrix ... 
real[int,int] A(10,5);
for(int i=0;i<A.n;++i)
for(int j=0;j<A.m;++j)
  A(i,j)=i*100+j;

cout << " A( 2:4,1:2) =" << A( 2:4,1:2) << endl;
cout << " A( 2,1:2) =" << A( 2,1:2) << endl;
cout << " A( 1:3,1) =" << A( 1:3,1) << endl;
cout << " A( :,1) =" << A( :,1) << endl;
cout << " A( :,1).sum =" << A( :,1).sum << endl;
cout << " A( :,1).min =" << A( :,1).min << endl;
// This is the rotating hill problem with one turn

// Parameters
real dt = 0.17, t = 0;	// time step

// Mesh
border a(t=0, 2*pi){x=cos(t); y=sin(t);}	// the unit circle
mesh th = buildmesh(a(70));	// triangulates the disk

// Fespace
fespace Vh(th, P1);
Vh v;
Vh u1, u2;
Vh vv, vo; // work Finite element function

// Function
func real hill (real r2){ return exp(-10*(r2)); }

// Initialization
v = hill( (x-0.3)^2 +(y-0.3)^2 );
plot(v);

u1 = y;
u2 = -x;	// rotation velocity
int i;
for (i = 0; i < 20; i++) {
	t += dt;
	vo = v;
	v = convect([u1, u2], -dt, vo);	// convect v by u1,u2, dt seconds, results in f
	plot(v, cmm="convection: t=" + t + ", min=" + v[].min + ", max=" + v[].max, wait=0);
}
// Schwarz without overlapping (Shur complenement Neumann -> Dirichet)  
verbosity=2;
real cpu=clock();
int inside = 2; 
int outside = 1;
border Gamma1(t=1,2){x=t;y=0;label=outside;};
border Gamma2(t=0,1){x=2;y=t;label=outside;};
border Gamma3(t=2,0){x=t ;y=1;label=outside;};

border GammaInside(t=1,0){x = 1-t; y = t;label=inside;};

border GammaArc(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh Th1 = buildmesh( Gamma1(5*n) + Gamma2(5*n) + GammaInside(5*n) + Gamma3(5*n));
mesh Th2 = buildmesh ( GammaInside(-5*n) + GammaArc(25*n) );

plot(Th1,Th2);

fespace Vh1(Th1,P1),      Vh2(Th2,P1);
Vh1 u1=0,v1;              Vh2 u2,v2;
Vh1 lambda=0;  // take $\lambda \in V_{h1}$
/*
Remark, to day is not possible to
defined a function just on a border, so the $\ lambda $
function is defined on the all domain $\Omega_1$
by:
*/
int i=0;  // for factorization optimization 


problem Pb2(u2,v2,init=i,solver=Cholesky) = 
    int2d(Th2)( dx(u2)*dx(v2)+dy(u2)*dy(v2) )
  + int2d(Th2)( -v2) 
  + int1d(Th2,inside)(-lambda*v2) +    on(outside,u2= 0 ) ;
problem Pb1(u1,v1,init=i,solver=Cholesky) = 
    int2d(Th1)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  + int2d(Th1)( -v1) 
  + int1d(Th1,inside)(+lambda*v1) +    on(outside,u1 = 0 ) ;

varf b(u2,v2,solver=CG) =int1d(Th1,inside)(u2*v2);
matrix B= b(Vh1,Vh1,solver=CG);

//  $\lambda \longrightarrow  \int_{\Gamma_i }(u_1-u_2) v_{1}$
func real[int] BoundaryProblem(real[int] &l)
{ 
   lambda[]=l;
   Pb1; 
   Pb2;
   i++;
   v1=-(u1-u2); 
   lambda[]=B*v1[];
   return lambda[] ;
};
/*
Remark, the  difference between the tow notation \ttCC{v1} and \ttCC{v1[]}  is: 
 \ttCC{v1} is the finite element  function and \ttCC{v1[]} 
is the vector in the canonical basis of the   finite element  function  \ttCC{v1} .
*/
Vh1 p=0,q=0; 
//  solve the problem with Conjugue Gradient

LinearCG(BoundaryProblem,p[],q[],eps=1.e-6,nbiter=100);
//  compute the final solution, because CG works with increment
BoundaryProblem(p[]); // solve again  to have right u1,u2
cout << " -- CPU time  schwarz-gc:" <<  clock()-cpu << endl;

plot(u1,u2);

 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=GMRES,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="Laplace.eps",value=true);
border floor(t=0,1){ x=t; y=0; label=1;}; // the unit square
border right(t=0,1){ x=1; y=t; label=5;};
border ceiling(t=1,0){ x=t; y=1; label=5;};
border left(t=1,0){ x=0; y=t; label=5;};
int n=10;
mesh th= buildmesh(floor(n)+right(n)+ceiling(n)+left(n));
savemesh(th,"toto.am_fmt");// format "formated Marrocco"
savemesh(th,"toto.Th");//format database "bamg"
savemesh(th,"toto.dbg");//format debug
savemesh(th,"toto.msh"); //format freefem
mesh th2 = readmesh("toto.msh");
fespace femp1(th,P1);
femp1 f = sin(x)*cos(y),g;
int where;
real xx;
{
  
  ofstream file("f.txt",binary);// for windows add binary version 3.30 
  file.precision(16);
  file << f[] << endl;
  where=file.tellp();
  file << 0.1 ;
  //  file << " " << 0.2 ;
  cout << " where in file " << where << endl;
  file << " # comment bla bla ...  0.3 \n";
  file << 0.2 << endl; 
  file.flush; // to flush the io  buffer of file
}
//  Idea to skip comment in a file ...  start with  # too EOL
func ifstream skipcomment(ifstream &ff)
{
    
    while(1)
    {
    int where = ff.tellg(); // store file position 
    string comment;
    ff >> comment; 
    if ( ! ff.good() ) break; 
    if( comment(0:0)=="#") {
         getline(ff,comment);
         cout << " -- #" << comment << endl;
    }
    else {
        ff.seekg(where); //restore file position 
        break;        
    }    
    }
    return ff;
}


{
  ifstream file("f.txt",binary); // for windows (pb CRNL EOL  translation ) 
  int l = file.length;
  cout << " where " << file.seekg << endl; 
  file.seekg(where);
  file >> xx;
  cout <<  " xx = " << xx << " good ? " << file.good() << endl;
  assert(xx==0.1);
  skipcomment(file) >> xx;
  assert(xx==0.2);
  where =file.tellg();
  assert(!file.eatspace); 
  cout << where << " < " << l << endl; 
  assert(l>=where);
  file.seekg(0);
  cout << " where " << file.tellg() << " " << file.good() << endl; 
  file >> g[] ;
  // nothing after only space
  
}
fespace Vh2(th2,P1);
Vh2 u,v;
plot(g);
solve pb(u,v) =
    int2d(th2)( u*v -dx(u)*dx(v)-dy(u)*dy(v) )
  + int2d(th2)(-g*v) 
  + int1d(th2,5)( -g*v)
  + on(1,u=0) ;
plot (th2,u);
cout << " (u[],u[]) = " << (u[]'*u[]) << endl; 
{
ofstream file("u.txt");
file << u[] << endl;
 file.seekp(100);
 file.flush;
 file  << "xxx "<< endl;
 
}
real r=0.25;
// a diamond with a hole
border a(t=0,1){x=-t+1; y=t;label=1;}; 
border b(t=0,1){ x=-t; y=1-t;label=2;};
border c(t=0,1){ x=t-1; y=-t;label=3;};
border d(t=0,1){ x=t; y=-1+t;label=4;};
border e(t=0,2*pi){ x=r*cos(t); y=-r*sin(t);label=0;};
int n = 10;
mesh Th= buildmesh(a(n)+b(n)+c(n)+d(n)+e(n)); 
plot(Th,wait=1);
real r2=1.732;
func abs=sqrt(x^2+y^2);
//  warning for periodic condition:
//  side a and c \hfilll
//  on side a (label 1) $ x \in [0,1] $ or $ x-y\in [-1,1] $ \hfilll
//  on side c (label 3) $ x \in [-1,0]$ or $ x-y\in[-1,1] $\hfilll
// so the common abcissa can be repectively $x$ and $x+1$
// or you can can try curviline abcissa $x-y$ and $x-y$ 
//  1 first way
// fespace Vh(Th,P2,periodic=[[2,1+x],[4,x],[1,x],[3,1+x]]);     
// 2 second way
 fespace Vh(Th,P2,periodic=[[2,x+y],[4,x+y],[1,x-y],[3,x-y]]);     

 Vh uh,vh;             

 func f=(y+x+1)*(y+x-1)*(y-x+1)*(y-x-1);                
 real intf = int2d(Th)(f);
 real mTh = int2d(Th)(1.);
real moyf =  intf/mTh;
cout << moyf << endl; 
 problem laplace(uh,vh) =                     
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) + 1e-8*uh*vh ) + int2d(Th)( (moyf-f)*vh ) ;                
laplace; 
  plot(uh,wait=1,ps="perio4.eps");
//  test all FEspace
verbosity=10;
mesh Th=square(5,5);
verbosity = 10;
cout << " P0 " << endl;
fespace Ph(Th,P0);
cout << " P1 " << endl;
fespace Vh(Th,P1);
cout << " P2 " << endl;
fespace Wh(Th,P2);
cout << " nb of degre of freedom           : " << Wh.ndof << endl;
cout << " nb of degre of freedom / ELEMENT : " << Wh.ndofK << endl;
//*  don't work to day in progresse
{
 int k= 2;
 int kdf= Wh.ndofK ;
cout << " df of element " << k << ":" ;
for (int i=0;i<kdf;i++)
  cout << Wh(k,i) << " ";
 cout << endl;
}
//int[int] IK=[1,2,4];
//cout << "Wh(IK) = " << Wh(IK) << endl;  
//*/
cout << " P1nc " << endl;
fespace Vnch(Th,P1nc);
Vnch u1nc=x+10*y;
cout << " Interpola P1nc : " << int2d(Th)(square(u1nc-(x+10*y))) << endl;

cout << " P2dc " << endl;
fespace Wdch(Th,P2dc);

cout << " P1dc " << endl;
fespace Vdch(Th,P1dc);
Vdch u1dc=x+10*y;
cout << " Interpola P1dc : " << int2d(Th)(square(u1dc-(x+10*y))) << endl;

Wh w=x*x*y,dxw=2*x*y;

Vdch vdc = dx(w);
Wdch wdc = dx(w)*x;
plot(vdc,dxw,wait=1);
plot(wdc);
Vnch vnc = x*x;
Vh vh = x*x;
Ph p = x*x;

{
func f=x*x+10*y*y+50*x*y;
cout << " P2b " << endl;
fespace Wh2b(Th,P2);
Wh2b vh=f;
cout << " ?? " << vh(0.1,0.4) << " == " << f(0.1,0.4) <<  " diff = " << vh(0.1,0.4) - f(0.1,0.4) <<endl;
assert( abs(vh(0.1,0.4) - f(0.1,0.4)) < 1e-12 );
}

{ // version 3.41 
mesh TTh=Wdch.Th;
plot(TTh,wait=1);
mesh Tw =w.Th; 
}
{// Version 3.58  
	Vh uu=x;
	Vh uuu=uu[]; 
	varf va(u,v) = int2d(Th)(v)+on(1,u=1);
	Vh vu = va(0,Vh,tgv=1);
	plot(vu, wait=1); 

}
/*
 * Incompressible Navier Stokes
 * with Taylor-Hood Finite element
 * Non linearity : Newton method
 * continuation on Reynols Number
 * Mesh adaptation
*/

// Parameters
real reymax = 1600;	// ok < 125000
real nu = 1./100.;
real dt = 0.1;
func BCu1 = 4*x*(1-x);
real epsr=1e-6;

// Mesh
mesh Th = square(8, 8);

// Fespace
fespace Xh(Th, P2);
Xh uu1, uu2;
Xh psi, phi;

fespace Mh(Th, P1);
fespace XXMh(Th, [P2, P2, P1]);
XXMh [u1, u2, p];
XXMh [v1, v2, q];
XXMh [up1, up2, pp];

// Macro
macro div(u1, u2) (dx(u1) + dy(u2)) //
macro grad(u1, u2) [dx(u1), dy(u2)] //
macro ugrad(u1, u2, v) (u1*dx(v) + u2*dy(v)) //
macro Ugrad(u1, u2, v1, v2) [ugrad(u1, u2, v1), ugrad(u1, u2, v2)] //

// Problem Stokes (with solve)
solve Stokes ([u1, u2, p], [v1, v2, q], solver=sparsesolver)
	= int2d(Th)(
		( dx(u1)*dx(v1) + dy(u1)*dy(v1)
		+ dx(u2)*dx(v2) + dy(u2)*dy(v2) )
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);

// Plot
uu1 = u1;
uu2 = u2;
plot(coef=0.2, cmm="[u1, u2] and p" ,p, [uu1, uu2], wait=1);

// Problem stream-lines (with solve)
solve streamlines (psi, phi)
	= int2d(Th)(
		  dx(psi)*dx(phi)
		+ dy(psi)*dy(phi)
	)
	+ int2d(Th)(
		- phi*(dy(u1) - dx(u2))
	)
	+ on(1, 2, 3, 4, psi=0);

// Plot
plot(psi, wait=1);

// Variatonal form definition Navier-Stokes
int i = 0;
real alpha = 1/dt;

varf vDNS ([u1, u2, p], [v1, v2, q])
	= int2d(Th)(
		+ nu * (
			  dx(u1)*dx(v1) + dy(u1)*dy(v1)
			+ dx(u2)*dx(v2) + dy(u2)*dy(v2)
		)
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
		+ Ugrad(u1, u2, up1, up2)'*[v1, v2]
		+ Ugrad(up1, up2, u1, u2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;

varf vNS ([u1, u2, p], [v1, v2, q])	// DF(u)u - F(u)
	= int2d(Th)(
		  Ugrad(up1, up2, up1, up2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;

for (real re = 100; re <= reymax; re *= 2) {
	real lerr = 0.1;
	nu = 1./re;

	if (re > 8000) lerr = 0.05;
	if (re > 10000) lerr = 0.01;
	for (int step = 0; step < 2; step++) {
		// Mesh adaptation & interpolation
		Th = adaptmesh(Th, [u1, u2], p, err=lerr, nbvx=100000, abserror=0, cutoff=0.01);
		[u1, u2, p] = [u1, u2, p];
		[up1, up2, pp] = [up1, up2, pp];

		// Newton
		for (i = 0; i <= 20; i++) {
			// Update
			up1[] = u1[];

			// Solve
			real[int] b = vNS(0, XXMh);	// build right hand side
			matrix Ans = vDNS(XXMh, XXMh);	// build matrix
			set(Ans, solver=sparsesolver);	// set solver
			u1[] = Ans^-1*b;	// solve linear system

			// Error
			b = u1[]-up1[];

			cout << "iter = "<< i << ", err = " << b.l2 << ", rey = " << re << endl;

			// Convergence criteria
			if (b.l2 < 1e-6) break;
		}
	}

	// Stream-lines
	uu1 = u1;
	uu2 = u2;
	streamlines;
	plot(coef=0.2, cmm="rey="+re+" [u1, u2] and p", psi, [uu1, uu2], wait=0, nbiso=20, ps="cavity-"+re+".ps");
}
/*
load "BEC" 
load "BernardiRaugel" 
load "BinaryIO" 
load "CircumCenter" 
load "ClosePoints" 
load "Curvature" 
load "DxWriter" 
load "Element_HCT" 
load "Element_Mixte" 
load "Element_Mixte3d" 
load "Element_P1bl" 
load "Element_P1dc1" 
load "Element_P1ncdc" 
load "Element_P2bulle3" 
load "Element_P2pnc" 
load "Element_P2pnc_3d" 
load "Element_P3" 
load "Element_P3dc" 
load "Element_P3nc" 
load "Element_P3pnc" 
load "Element_P3pnc_3d" 
load "Element_P4" 
load "Element_P4dc" 
load "Element_PkEdge" 
load "Element_QF" 
load "FreeFemQA" 
load "Helmholtz_FD" 
load "IncompleteCholesky" 
load "MUMPS" 
//load "MUMPS_seq" 
load "MatD-VFP0" 
load "MatrixMarket" 
load "MetricKuate" 
load "MetricPk" 
load "Morley" 
load "NewSolver" 
load "SaveHB" 
load "Schur-Complement" 
//load "SuperLu" 
load "UMFPACK64" 
load "VTK_writer" 
//load "VTK_writer_3d" 
load "addNewType" 
load "aniso" 
load "bfstream" 
load "biofunc" 
load "dfft" 
load "distance" 
load "exactpartition" 
load "ff-AiryBiry" 
load "ff-Ipopt" 
load "ff-NLopt" 
load "ff-cmaes" 
load "ff-mmap-semaphore" 
load "ffnewuoa" 
load "ffrandom" 
load "freeyams" 
load "funcTemplate" 
load "geophysics" 
load "gmsh" 
load "gsl" 
load "ilut" 
load "iohdf5" 
load "ioply" 
load "iovtk" 
load "isoline" 
load "lapack" 
load "lgbmo" 
load "mat_dervieux" 
load "mat_edgeP1" 
load "mat_psi" 
load "medit" 
load "meshtools" 
load "metis" 
load "mmg" 
load "mmg3d-v4.0" 
load "msh3" 
load "mshmet" 
load "myfunction" 
load "myfunction2" 
load "pcm2rnm" 
load "pipe" 
load "plotPDF" 
load "ppm2rnm" 
load "qf11to25" 
load "scotch" 
load "shell" 
load "splitedges" 
load "splitmesh12" 
load "splitmesh3" 
load "splitmesh4" 
load "splitmesh6" 
load "tetgen" 
load "vortextools" 
*/
ofstream table("theTables");
dumptable(table);

if (!exec("ls -al theTables")) cout << "execution ok " << endl;

real alpha=1;int Niter=50;

mesh TH;mesh[int] Th(2);int Dirichlet,Interface;
int[int] reg(2);
{
	int n=30;
	Dirichlet=1;Interface=2;
	border a0(t=0,1){x=t;y=0;label=Dirichlet;}
	border a1(t=1,2){x=t;y=0;label=Dirichlet;}
	border b1(t=0,1){x=2;y=t;label=Dirichlet;}
	border c1(t=2,1){x=t;y=1;label=Dirichlet;}
	border c0(t=1,0){x=t;y=1;label=Dirichlet;}
	border b0(t=1,0){x=0;y=t;label=Dirichlet;}
	border d(t=0,1){x=1;y=t;label=Interface;}
	plot(a0(n)+a1(n)+b1(n)+c1(n)+c0(n)+b0(n)+d(n));	
	TH=buildmesh(a0(n)+a1(n)+b1(n)+c1(n)+c0(n)+b0(n)+d(n));	

	reg(0)=TH(0.5,0.5).region;
	reg(1)=TH(1.5,0.5).region;

	for(int i=0;i<2;i++) Th[i]=trunc(TH,region==reg(i));
}

macro f 1 // Volumic flux

int i;
fespace Vh0(Th[0],P1),Vh1(Th[1],P1);
Vh0 u0=0;Vh1 u1=0;

macro grad(u) [dx(u),dy(u)] //

varf a(u,v)=int2d(Th[i])(grad(u)'*grad(v))+int1d(Th[i],Interface)(alpha*u*v)+on(Dirichlet,u=0);
varf b(u,v)=int2d(Th[i])(f*v)+on(Dirichlet,u=0);
varf du1dn(u,v)=-int2d(Th[1])(grad(u1)'*grad(v)-f*v)+int1d(Th[1],Interface)(alpha*u1*v)+on(Dirichlet,u=0);
varf du0dn(u,v)=-int2d(Th[0])(grad(u0)'*grad(v)-f*v)+int1d(Th[0],Interface)(alpha*u0*v)+on(Dirichlet,u=0);

matrix[int] I(2);
I[0]=interpolate(Vh1,Vh0);
I[1]=interpolate(Vh0,Vh1);

matrix[int] A(2); real[int][int] B(2);
i=0; A[0]=a(Vh0,Vh0); B[0].resize(Vh0.ndof); B[0]=b(0,Vh0);
i=1; A[1]=a(Vh1,Vh1); B[1].resize(Vh1.ndof); B[1]=b(0,Vh1);


for(int iter=0;iter<Niter;iter++)
{
 	// Solve on Th[0]
	{
		i=0;// for def of  b
		real[int] b0=B[0];
		real[int] Du1dn=du1dn(0,Vh1);
		real[int] Tdu1dn(Vh0.ndof); Tdu1dn=I[0]'*Du1dn;
		b0+=Tdu1dn;
		u0[]=A[0]^-1*b0;
	}
 	// Solve on Th[1]
	{
		i=1; // for def of  b
		real[int] b1=B[1];
		real[int] Du0dn=du0dn(0,Vh0);
		real[int] Tdu0dn(Vh1.ndof); Tdu0dn=I[1]'*Du0dn;
		b1+=Tdu0dn;
		u1[]=A[1]^-1*b1;
	}
	plot(u0,u1,cmm="iter="+iter);
}
// -Ddim=3   parametre or -D=2
int bar=4;
// valeur par defaut ..
IFMACRO(!dim)
macro dim 2//
ENDIFMACRO

IFMACRO(dim,2) 
macro intO int2d//
macro intG int1d//
macro Mesh mesh//
macro Boite(n) square(n,n)//
macro grad(u) [dx(u),dy(u)]//
macro Grad(u) [ grad(u#1), grad(u#2)]//
macro div(u) (dx(u#1)+dy(u#2))//
macro cnd(u) u#1,u#2//
macro ccd(u) u,u//
macro Vd(u) [u#1,u#2]//
macro myON1(l,u,v) on(l,u#1=0.,u#2=v)//
ENDIFMACRO
IFMACRO(dim,3) 
load  "msh3"
macro intO int3d//
macro intG int2d//
macro Mesh mesh3//
macro Boite(n) cube(n,n,n)//
macro grad(u) [dx(u),dy(u),dz(u)]//
macro Grad(u) [ grad(u#1), grad(u#2),grad(u#3)]//
macro div(u) (dx(u#1)+dy(u#2)+dz(u#3))//
macro cnd(u) u#1,u#2,u#3//
macro ccd(u) u,u,u//
macro Vd(u) [u#1,u#2,u#3]//
macro myON1(l,u,v) on(l,u#1=v,u#2=0.,u#3=0.)//
ENDIFMACRO

Mesh Th=Boite(10);
int[int] ll(4);
if(dim==2) ll=[1,1,2,1,3,2,4,1];
else ll=[1,1,2,1,3,1,4,1,5,1,6,2];

Th=change(Th,label=ll);

plot(Th);
fespace Vh(Th,[ccd(P2),P1]);
Vh [cnd(u),p], [cnd(v),q],[cnd(up),pp];

solve Stokes ([cnd(u),p], [cnd(v),q])
= intO(Th)( (Grad(u):Grad(v)) - div(u)*q - div(v)*p - 1e6*p*q  )
+ myON1(1,u,0.) + myON1(2,u,1.);

plot(p, wait=1);
int i, N=20;
mesh Th=square(N,N);
fespace RTh(Th,RT0);
fespace P0h(Th,P0);
fespace P1h(Th,P1);

RTh [Vx,Vy],[vx,vy];
P0h up,u,um;

real dt=0.125/N, pi=4*atan(1.0);
[Vx,Vy]=[0,0];
um= sin(pi*x)*sin(pi*y);
u=um;

problem prob(Vx,Vy,vx,vy,solver=Cholesky,init=i)
    = int2d(Th) (Vx*vx+Vy*vy) + int2d(Th)(up*(dx(vx)+dy(vy)))
//     + on(1,2,3,4,Vx=pi*cos(pi*x)*sin(pi*y)*cos(i*dt*pi*sqrt(2.))
//                 ,Vy=pi*sin(pi*x)*cos(pi*y)*cos(i*dt*pi*sqrt(2.)) )
;
for (i=0;i<20;i++)
 {
     up = 2*u-um+dt*dt*(dx(Vx)+dy(Vy));
     prob;
     um=u;
     u=up;
     cout<< int2d(Th)((u-sin(pi*x)*sin(pi*y)*cos(i*dt*pi*sqrt(2.)))^2)
     /int2d(Th)((sin(pi*x)*sin(pi*y)*cos(i*dt*pi*sqrt(2.)))^2)<< endl;
//     plot([Vx,Vy],wait=0, value=1);
 }
P1h w,W = 0;
problem prob1(W,w,solver=Cholesky,init=0)
    = int2d(Th) (W*w) + int2d(Th)(up*w);
    prob1;
    plot(W,wait=1,value=1);
assert(version>=4.7 || version >= 4.11);
//   Change empty mesh in meshL form version 4.5
//  warning missing  operator a(Vh,Lh) 

//  Mortar  (4 sub domain) 
//  with matrix -et Precon Conjugade Gradient --
//    Neuman -> Dirichlet . 
//  -------------------------------
load "msh3"
func f=1+x+y;
real g=1; 
int withprecon=1; 
macro Grad(u) [ dx(u), dy(u) ] //
int nbsd=4;

macro Psd(U) U[0],U[1],U[2],U[3] //
int labext= nbsd+1;
real meshsize=0.025; 
real meshsizem=meshsize*1.5; 
bool noconforme=0;// conforme ok ..

// --- begin  meshes  building --------------
real[int] theta(nbsd+1),cost(nbsd),sint(nbsd);

for (int i=0;i<nbsd;i++)
 {
  real t=i*2*pi/nbsd;
  theta[i]= t;
  theta[i+1]= (i+1)*2*pi/nbsd;
  cost[i]=cos(t);
  sint[i]=sin(t);
 }


border gi(t=0,1;i){x=cost[i]*t;y=sint[i]*t;label=1;region=1;};// correct Bug  mai 2021 FH. region = 

border ei(tt=0,1;i){ real t = theta[i]+ tt*(theta[i+1]-theta[i]);
	 x=cos(t);y=sin(t);label=labext;};

 int[int]  Ng(nbsd), Ne(nbsd);
  Ne = 2*pi/nbsd/meshsize ;
  Ng = 1./meshsize ;

plot(gi(Ng)+ei(Ne) ,wait=1);

mesh Tha = buildmesh( gi(Ng)+ei(Ne) , splitpbedge=1);

int [int] regi(4);
for (int i=0;i<4;i++)
  {
    real tt = (theta[i]+theta[i+1])*0.5;
    regi[i]=Tha(0.5*cos(tt),0.5*sin(tt)).region;
  }

Ng = 1./meshsize;
cout << "mortar : " << endl;
meshL Thm=buildmeshL(gi(Ng));
Thm=trunc(Thm,1,split=4); //
meshL Thmm=Thm;
if(noconforme)
  { ; //  need a find mesh to integrate on Thm. 
  //  Thmm=trunc(Thm,split=4,1); // for fine integration
  //  Thmm=emptymesh(Thmm);
   Ng *= 4;
   Thmm=buildmeshL(gi(Ng));
  }
plot(Thm,wait=1);

verbosity=1;


mesh[int] Thsd(nbsd);

for(int sd=0;sd<nbsd;++sd)
 Thsd[sd]=trunc(Tha,region==regi[sd],split=1);// les sous domaines

if(noconforme)
{
for(int sd=0;sd<nbsd;++sd)
 Thsd[sd]=adaptmesh(Thsd[sd],meshsize*(1+sd*0.05),IsMetric=1,nbvx=100000,thetamax=60);// les sous domaines

}
plot(Thsd,Thm,dim=2,wait=1);   // axel: ok

fespace Lh(Thm,P0);// 
fespace RTh(Thm,[P0,P0]);
 RTh [Nmx,Nmy]; // ne marche pas car la normal 
// Warning now only the tangent is defined on meshL because le line is in R3 not in R2 generaly
varf  vNN([ux,uy],[nx,ny]) = int1d(Thm,1)(( -nx*Tl.y + ny*Tl.x)/lenEdge);  // axel: N 2D -> Nt 3D curve 
Nmx[]= vNN(0,RTh);

// les joint P0 sur le squelette 
// -----   \int [q] l + \int[p] m 
Lh  lh=0,rhsl=0;

mesh Thi=Thsd[0];

// remark: operator # is  the concatenation operator in macro 

//   cout << " Domaine " << i<< " --------" << endl;
// OK P1/P0 ;, PB P1/P1,  P1/P0Edge , FH..
fespace Vhi(Thi,P1);
fespace Ehi(Thi,P0);
matrix[int] Asd(nbsd),Csd(nbsd),PAsd(nbsd),PIsd(nbsd),PJsd(nbsd);
Vhi[int] usd(nbsd),vsd(nbsd),rhssd(nbsd), pusd(nbsd),bcsd(nbsd);
Ehi[int] epssd(nbsd);
   
real tgv=1e30;
for(int sd=0;sd<nbsd;++sd)
{
  Thi=Thsd[sd];
  usd[sd]=0;
  vsd[sd]=0;
   
  varf cci([l],[u]) = int1d(Thmm,1,qforder=3)(l*u*epssd[sd]);
  varf vepsi(u,v)= int1d(Thi,1,qforder=10)( (Nmx*N.x + Nmy*N.y)*v/lenEdge);    
  
  varf vLapMi([ui],[vi],tgv=tgv) =
         int2d(Thi)(  Grad(ui)'*Grad(vi)  )
      // + int1d(Thi,1,qfe=qf1pElump)(alpha*ui*vi)
    +  int2d(Thi) (f*vi)   +  on(labext,ui=g);  
    
  varf vPLapMi([ui],[vi],tgv=tgv) =
        int2d(Thi)(  Grad(ui)'*Grad(vi)  )
     // + int1d(Thi,1,qfe=qf1pElump)(alphap*ui*vi)
      + on(labext,1,ui=0);
   ;  

   varf  vrhsMi(ui,vi) =   on(labext,ui=g);

   epssd[sd][]= vepsi(0,Ehi);
   epssd[sd] = -real(epssd[sd] <-0.00001) + real(epssd[sd] >0.00001);
   
   Csd[sd]  = cci(Lh,Vhi);
   Asd[sd]  = vLapMi(Vhi,Vhi,solver=sparsesolver);
   PAsd[sd] = vPLapMi(Vhi,Vhi,solver=sparsesolver);
   matrix IVL=interpolate(Vhi,Lh,inside=1);
   //   v = IVL*l 
   varf vonext(u,v)=on(labext,u=1);
   varf von1(u,v)=on(1,u=1);
   real[int]  onext=vonext(0,Vhi);
   real[int]  on1=von1(0,Vhi);
   on1= on1 ? 1 : 0;
   on1 = onext ? 0 : on1; //  remove df of ext
   matrix I1(on1);//   matrix    tgv $i\in Gamma_1 \ Gamma_e $ , 0 otherwise
   
   PIsd[sd]=  I1*IVL;//  remove of line not on $Gamma_1 \ Gamma_e $
 
    // so PIsd[sd]*l  =  tgv * Interpole l on $Gamma_1 \ Gamma_e $
   I1.diag=on1;
   matrix AA=I1*Asd[sd];//  remove line not on lab 1 
   PJsd[sd]= IVL'*AA;
   
   
   rhssd[sd][]=vLapMi(0,Vhi);

}

plot(epssd,cmm="eps 0,1,2,3",wait=0,value=1);


lh[]=0;
varf  vDD(u,v) = int1d(Thm)(u*v*1e-10);  // axel: int2d -> int1d
varf  vML(u,v) = int1d(Thm)(u*v*1e-10)+int1d(Thm,1)(u*v);   // axel: int2d -> int1d
matrix ML=vML(Lh,Lh);




matrix DD=vDD(Lh,Lh);

matrix M=[ 
  [ Asd[0] ,0      ,0      ,0      ,Csd[0] ],
  [ 0      ,Asd[1] ,0      ,0      ,Csd[1] ],
  [ 0      ,0      ,Asd[2] ,0      ,Csd[2] ],
  [ 0      ,0      ,0      ,Asd[3] ,Csd[3] ],
  [ Csd[0]',Csd[1]',Csd[2]',Csd[3]',DD     ] 
 ];

real[int] xx(M.n);

real[int] bb =[rhssd[0][], rhssd[1][],rhssd[2][],rhssd[3][],rhsl[] ];
set(M,solver=sparsesolver);

xx = M^-1 * bb;

[usd[0][],usd[1][],usd[2][],usd[3][],lh[]] = xx; // dispatch the solution 

plot(usd,cmm="u1,u2,u3,u4",wait=1); 


int itera=0;

varf  vbc(u,v) =   int1d(Thm,labext)(v);
real[int] lbc(Lh.ndof),lbc0(Lh.ndof);
lbc=vbc(0,Lh);
lbc = lbc ? 0 : 1 ; 

func real[int] SkPb(real[int] &l)
{ 
   int verb=verbosity;   verbosity=0;   itera++;
   for(int sd=0;sd<nbsd;++sd)
    {
      Thi=Thsd[sd];  //  for initialisation of vsd with the correct size 
      vsd[sd][]  = rhssd[sd][];
      vsd[sd][] += Csd[sd]* l;
      usd[sd][]  = Asd[sd]^-1*vsd[sd][];

    }
    l=0;
   for(int sd=0;sd<nbsd;++sd)
     	l  += Csd[sd]'*usd[sd][];  
     	
    l= lbc .* l; 
    plot(usd,wait=0,cmm="CG iteration u");
   verbosity=verb; 
   return l ;
};

func real[int] PSkPb(real[int] &l)
{ 
  if(withprecon)
  {  	
   int verb=verbosity;   verbosity=0;   itera++;
   real[int] ll= ML^-1*l;
   ll= lbc .* ll; 
   ll *= tgv;
 
   for(int sd=0;sd<nbsd;++sd)
    {
      Thi=Thsd[sd];              
      pusd[sd][] = PAsd[sd]^-1*(vsd[sd][]= PIsd[sd]* ll);
    }
    ll=0;
   for(int sd=0;sd<nbsd;++sd)
     ll  += PJsd[sd]*pusd[sd][];  
    l = ML^-1*ll; 	
    l= lbc .* l; 
   verbosity=verb; 
  }
  return l ;
};


verbosity=100;
lh[]=0;
LinearCG(SkPb,lh[],eps=1.e-7,nbiter=100,precon=PSkPb);
verbosity=1; 

plot(usd,wait=1,cmm="CG");

// FFCS: for regression tests
real regtest;
{  
fespace Vha(Tha,P1);
Vha vah,uah;
solve vLapMM([uah],[vah]) =
       int2d(Tha)(  Grad(uah)'*Grad(vah) )
    -  int2d(Tha) (f*vah)
    +  on(labext,uah=g)
   ;
verbosity =3;
real errL2=0;
for(int sd=0;sd<nbsd;++sd)
  errL2 += int2d(Thsd[sd])( sqr(uah-usd[sd]));
  errL2 = sqrt(errL2);
plot(uah,usd,cmm="uah err="+errL2,wait=1); 
assert(errL2<1e-4); 
regtest=uah[]'*uah[];
}

//  cleanning version 07/2008  FH in Sevilla.
int nerr =0; 
int debugJ =0; 
int debugdJ =0; 
real umax=0;
{
 func  bool stop(int iter,real[int] u,real[int] g)	
{
  cout << " stop = " << iter << " " << u.linfty << " " << g.linfty << endl;
  return g.linfty < 1e-5 || iter > 15;;
}
  // minimisation of $J(u) = \frac12\sum (i+1) u_i^2 - b_i $	
  // work array 
  real[int] b(10),u(10); 
  
  func real J(real[int] & u)
    {
      real s=0;
      for (int i=0;i<u.n;i++)
	s +=(i+1)*u[i]*u[i]*0.5 - b[i]*u[i];
      if(debugJ) cout << "J ="<< s << " u =" <<  u[0] << " " << u[1] << "...\n" ;
      return s;
    }

//  the grad of J (this is a affine version (the RHS is in  )
  func real[int] DJ(real[int] &u)
    { 
      for (int i=0;i<u.n;i++)
	u[i]=(i+1)*u[i];
      if(debugdJ) cout << "dJ0  ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
      u -= b; 
      if(debugdJ) cout << "dJ-b ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
      return u;  // return of global variable ok 
    };

// the grad of the bilinear part of J (the RHS in remove)
  func real[int] DJ0(real[int] &u)
    { 
      for (int i=0;i<u.n;i++)
	u[i]=(i+1)*u[i];
      if(debugdJ) cout << "dJ0 ="<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;	
      return u;  // return of global variable ok 
    };


  func real error(real[int] & u,real[int] & b)
   {
   real s=0;
     for (int i=0;i<u.n;i++)
	s += abs((i+1)*u[i] - b[i]);
   return s;    
   }
  func real[int] matId(real[int] &u) { return u;};
  int verb=5; // verbosity of algo ..
  b=1. ; u=0.; // set  right hand side and initial gest
  LinearCG(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "LinearGC (Affine) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  b=1; u=0; 
  LinearCG(DJ,u,eps=1.e-15,nbiter=20,precon=matId,verbosity=50,stop=stop);
  cout << "LinearGC (Affine with stop) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  b=1; u=0; // set  right hand side and initial gest
  LinearCG(DJ0,u,b,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "LinearGC (Linear) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		


  b=1; u=0; // set  right hand side and initial gest
  AffineGMRES(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb); // correct in version 3.11 
  cout << "LinearGMRES (Affine) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		

  b=1; u=0; // set  right hand side and initial gest
  LinearGMRES(DJ0,u,b,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "LinearGMRES (Linear) : J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		


  b=1; u=0; // set  right hand side and initial gest
  NLCG(DJ,u,eps=1.e-6,nbiter=20,precon=matId,verbosity=verb);
  cout << "NLCG: J(u) = " << J(u) << " err=" << error(u,b) << endl;
  nerr += !(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		


  // warning BFGS use a full matrix of size nxn (where n=u.n) 
  b=1; u=2; // set  right hand side and initial gest
  BFGS(J,DJ,u,eps=1.e-6,nbiter=20,nbiterline=20);
   cout << "BFGS: J(u) = " << J(u) << " err=" << error(u,b) << endl;
  assert(error(u,b) < 1e-5);
  if(nerr) cout << "    sol: "<< " u =" <<  u[0] << " " << u[1] << " " << u[2]  << "...\n" ;		
 

  assert(nerr==0);
};
{ // ---  a real non linear test ---
mesh Th=square(10,10);  // mesh definition of $\Omega$
fespace Vh(Th,P1);      // finite element space
fespace Ph(Th,P0);      // make optimization

Vh b=1;  // to defined b 
// $ J(u) = 1/2\int_\Omega f(|\nabla u|^2) - \int\Omega  u b $
// $ f(u) = a*u + u-ln(1+u), \quad f'(u) = a+\frac{u}{1+u}, \quad f''(u) =  \frac{1}{(1+u)^2}$
real a=0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u);}
func real ddf(real u) { return 1/((1+u)*(1+u));}

// the functionnal J 

func real J(real[int] & u)
  {
    Vh w;w[]=u; 
    real r=int2d(Th)(0.5*f( dx(w)*dx(w) + dy(w)*dy(w) ) - b*w) ;
    cout << "J(u) =" << r << " " << u.min <<  " " << u.max << endl;
    return r;
  }
// -----------------------

Vh u=0; //  the current value of the solution
Ph alpha; // of store  $df(|\nabla u|^2)$
int iter=0;
alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // optimization 

func real[int] dJ(real[int] & u)
  {
    Vh w;w[]=u; 
    alpha=df( dx(w)*dx(w) + dy(w)*dy(w) ); // optimization 
    varf au(uh,vh) = int2d(Th)( alpha*( dx(w)*dx(vh) + dy(w)*dy(vh) ) - b*vh)
    + on(1,2,3,4,uh=0);
    u= au(0,Vh);  
    return u; // warning no return of local array  
  }

varf alap(uh,vh)=  
   int2d(Th)( alpha *( dx(uh)*dx(vh) + dy(uh)*dy(vh) ))   + on(1,2,3,4,uh=0);

varf amass(uh,vh)=  int2d(Th)( uh*vh)  + on(1,2,3,4,uh=0);

matrix Amass = amass(Vh,Vh,solver=CG);

matrix Alap=  alap(Vh,Vh,solver=Cholesky,factorize=3);   

func real[int] C(real[int] & u)
{
   real[int] w=u;
   u = Alap^-1*w;
   return u; // no return of local array  variable 
}
   int conv=0;
   real eps=1e-6; 
   for(int i=0;i<20;i++)
   {
     conv=NLCG(dJ,u[],nbiter=10,precon=C,veps=eps,verbosity=5); 

     if (conv) break; 
     alpha=df( dx(u)*dx(u) + dy(u)*dy(u) ); // optimization 
     Alap = alap(Vh,Vh,solver=Cholesky,factorize=3);   
     cout << " restart with new preconditionner " << conv << " eps =" << eps << endl;
   }
   plot (u,wait=1,cmm="solution with NLCG");
   umax = u[].max; 

   Vh sss= df( dx(u)*dx(u) + dy(u)*dy(u) ) ;
   plot (sss,wait=0,fill=1,value=1);

// the  method of  Newton Ralphson to solve dJ(u)=0;
//  see Newton.edp example

}
assert(nerr==0); 
int err=0;
mesh Th=square(50,50,[3*x-1.5,3*y-1.5]);
func r = sqrt(x*x +y*y);
// wrong ...
real lc ;
verbosity=0;
lc = int1d(Th,levelset=r-1.)(1.) ; 
cout << " len of the level set = " <<  lc  << " =  2pi " << 2*pi ;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl; 
if( abs(lc-2*pi) > 1e-1) err++;
fespace Vh(Th,P1);
// test linear and bilinear ... 
varf vl(u,v) = int1d(Th,levelset=r-1.)(v) + int1d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh);

cout << " len of the level set (varf linear ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi ;
cout  << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;
if( abs(lc-2*pi) > 1e-1) err++; 
real[int]  one(Vh.ndof); 
one=1.;
matrix VV=vl(Vh,Vh); //  matrix with levelset
vv = VV*one;
cout << " len of the level set (varf bilinear same) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;; 
if( abs(lc-2*pi) > 1e-1) err++;

// FFCS regression test
real ffcsreg;

//  just for test a idea approximation of int of negative part of levelset 
//   to we just change the mesure of the element not the quadrature point 
{ // test new stuff for level set  ... 
    macro grad(u) [dx(u),dy(u)] //
    Vh u,v;
    solve Pxx(u,v) = int2d(Th) ( grad(u)'*grad(v)*1e-8 ) + int2d(Th, levelset= 1-r) ( grad(u)'*grad(v) ) + on(1,u=0) + int2d(Th, levelset= 1-r) ( 1*v);
    plot(u,wait=1);   
    varf vxx(u,v) =  int2d(Th, levelset= 1-r) ( u*v ) + int2d(Th, levelset= 1-r) ( 1*v);
  matrix XX=vxx(Vh,Vh);
  real[int] xx=vxx(0,Vh);
  real area1= int2d(Th, levelset= 1-r)(1.);
  cout << "  area1 = " << area1 << "  ~= " << Th.area - pi << endl;
  assert(abs(area1-(Th.area - pi)) < 0.1); 
  cout << " xx.sum = " << xx.sum << " == " << area1 <<endl;
  assert(abs(area1-xx.sum) < 1e-8); 
  
  real[int] yy(Vh.ndof); yy=1;
  xx= XX*yy;
  cout << " XX.sum = " << xx.sum << " == " << area1 << endl;
  assert(abs(area1-xx.sum) < 1e-8); 

  // FFCS regression tests
  ffcsreg=abs(area1-xx.sum);
}



if(1){// test on diff mesh  not wet implemented (FH  frev 2014)
mesh Th1=square(10,10,[3*x-1.5,3*y-1.5]);
mesh Th2=square(11,11,[3*x-1.5,3*y-1.5]);
fespace Vh1(Th1,P1);
fespace Vh2(Th2,P1);

varf vl(u,v) = int1d(Th,levelset=r-1.)(v) + int1d(Th,levelset=r-1.)(u*v);
real[int] vv=vl(0,Vh2);

cout << " len of the level set (varf linear diff    ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi ;
cout  << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;
if( abs(lc-2*pi) > 1e-1) err++; 
real[int]  one(Vh1.ndof); 
one=1.;
// sorry not implemented to day ... FH 
//verbosity=10000;
matrix VV=vl(Vh1,Vh2); // no build of matrix with levelset 
vv = VV*one;
cout << " len of the level set (varf bilinear diff ) = " <<  (lc=vv.sum)  << "=  2pi " << 2*pi;
cout << ", Ok = " << (abs(lc-2*pi) < 1e-1) << endl;; 
if( abs(lc-2*pi) > 1e-1) err++;

}
cout << " Nb err " << err << endl;
assert(err==0);

real pi=4*atan(1);
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
mesh TH = buildmesh ( e(5*n) + e1(25*n) );
plot(th,TH,ps="schwarz-th.eps");
fespace vh(th,P1);
fespace VH(TH,P1);
vh u=0,v; VH U,V;
int i=0;

problem PB(U,V,init=i,solver=Cholesky) = 
    int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + int2d(TH)( -V) + on(inside,U = u)  +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(th)( -v) + on(inside ,u = U) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 10; i++) 
{   
   PB; 
   pb;
   //if (i==0) 
        plot(U,u,wait=true,ps="schwarz-u"+i+".eps");
};

plot(U,u,ps="schwarz-u.eps");
int i;
real [int] tab(10), tab1(10); // 2 array of 10 real 
complex [int] ctab(10), ctab1(10); // 2 array of 10 complex 
//string [int] stab(10);   pas code ... 


//  real [int] tab2; //  bug 
tab = 1;  //  set all the array to 1
tab[1]=2;
ctab = 1+2i;  //  set all the array to 1+2i
ctab[1]=2;
cout << tab[1] << " " << tab[9] << " size of tab = " << tab.n << endl;
cout << ctab[1] << " " << ctab[9] << " size of ctab = " << ctab.n << endl;

tab1=tab;
tab=tab+tab1;
tab=2*tab+tab1*5;
tab1=2*tab-tab1*5;
tab+=tab;
cout << tab << endl;
cout << tab[1] << " " << tab[9] <<  endl;

ctab1=ctab;
ctab=ctab+ctab1;
ctab=2*ctab+ctab1*5;
ctab1=2*ctab-ctab1*5;
ctab+=ctab;
cout << ctab << endl;
cout << ctab[1] << " " << ctab[9] <<  endl;


real [string] map; //  a dynamique array
 string[string] smap;
for (i=0;i<10;i=i+1)
  {
    tab[i] = i*i;
    cout << i << " " << tab[i] << "\n";
  };

map["1"]=2.0;
map[2]=3.0; //  2 is automaticaly cast to the string "2"

cout << " map[\"1\"] = " << map["1"] << " == 2.0 ; "<< endl;
cout << " map[2] = " << map[2] << " == 3.0 "<< endl;
assert( abs(map["1"]-2.0)<1.e-6);
assert(abs(map[2]-3.0)<1e-6);



real [int] tab2=[1,2,3,3.14];
int  [int] itab2=[1,2,3,5];

cout << tab2 << endl;
cout << itab2 << endl;
tab2.resize(10);
for (int i=4;i<10;i++) tab2[i]=i;
cout << "tab2 = " << tab2 << endl;
tab2 /= 2; // bug  before v2.0-3
cout << "tab2 = " << tab2 << endl;
tab2 *= 2;
cout << "tab2 = " << tab2 << endl;


real [int,int] mat(10,10),mmat(10,10);
mat=0;
for(int i=0;i<mat.n;i++)
  for(int j=0;j<mat.m;j++)
    mat(i,j)=i+100*(j+1);
mmat=mat;
cout << mmat << endl;
mat.resize(15,15);
for(int i=10;i<mat.n;i++)
  for(int j=0;j<mat.m;j++)
    mat(i,j)=i+100*(j+1);
for(int i=0;i<mat.n;i++)
  for(int j=10;j<mat.m;j++)
    mat(i,j)=i+100*(j+1);
cout << mat << endl; // wrong
//mat(0:9,0:9)=mmat;  todo 
//cout << mat << endl; // wrong

// array of mesh 
mesh[int] aTh(10);
aTh[1]= square(2,2);
plot(aTh[1]);

// add 1 sep 2005 FH 
real[int]  a(5),b(5),c(5),d(5);
a = 1;
b = 2;
c = 3;
a[2]=0;
d = ( a ? b : c ); // i = 0, n-1  d[i] = a[i] ? b[i] : c[i] , 
cout << d << endl;
cout << "==   2       2       3       2       2 \n";
d = (a ? 1 : 10);
cout << " (a ? 1 : 10) "<< d << endl;
d = (a ? b : -1);
cout << " (a ? b : -1 ) "<< d << endl;
d = (a ? -2 : c);
cout << " (a ? -2 : c) " <<  d << endl;
d =   1./d; 
cout << " 1/ d == (a ? -2 : c) " <<  d << endl;
d =   a/3.; 
cout << "a/3 ==  " <<  d << endl;

// Liste all array operator and method 
// ok in version 2.0-3 
// they exist in the 3 type of array
// real[int] , long[int], complex[int] 
// ---------------------------------
int N=5;
{
real[int] a(N),b(N),c(N);
a =1; 
 a(0:4:2) = 2;
a(3:4) = 4;
cout <<" a = " << a << endl;
b = a+ a;
cout <<" b = a+a : " << b << endl;
b += a;
cout <<" b += a : " << b << endl;
b += 2*a;
cout <<" b += 2*a : " << b << endl;
b /= 2;
cout <<" b /= 2 : " << b << endl;
b .*= a; // same b = b .* a 
cout << "b*=a; b =" << b << endl;
b ./= a; // same b = b ./ a 
cout << "b/=a; b =" << b << endl;
c = a+b;
cout << " c =a+b : c=" << c << endl;
c = 2*a+4*b;
cout << " c =2*a+4b : c= " << c << endl;

c = a+4*b;
cout << " c =a+4b : c= " << c << endl;
c = -a+4*b;
cout << " c =-a+4b : c= " << c << endl;
c = -a-4*b;
cout << " c =-a-4b : c= " << c << endl;
c = -a-b;
cout << " c =-a-b : c= " << c << endl;

c = a .* b; 
cout << " c =a.*b  : c= " << c << endl;
c = a ./ b; 
cout << " c =a./b  : c= " << c << endl;
c = 2 * b;
cout << " c =2*b   : c= " << c << endl;
c =  b*2 ;
cout << " c =b*2   : c= " << c << endl;

/*  this operator do not exist 
c =  b/2 ;
cout << " c =b/2   : c= " << c << endl;
*/

// ---- the  methods --
cout << " ||a||_1     = " <<  a.l1     << endl;
cout << " ||a||_2     = " <<  a.l2     << endl;
cout << " ||a||_infty = " <<  a.linfty << endl;
cout << " sum a_i     = " <<  a.sum    << endl;
cout << " max a_i     = " <<  a.max  << " a[  " << a.imax << " ] = " << a[a.imax]     << endl;
cout << " imax a_i     = " <<  a.imax  << " a[  " << a.imax << " ] = " << a[a.imax]     << endl;
cout << " min a_i     = " <<  a.min  << " a[  " << a.imin << " ] = " << a[a.imin]    << endl;
cout << " imin a_i     = " <<  a.imin  << " a[  " << a.imin << " ] = " << a[a.imin]    << endl;
cout << " a'*a        = " <<  (a'*a)   << endl;
cout << " a quantile 0.2 =  " <<  a.quantile(0.2) << endl;

// array mapping  after version 2.3
int[int] I=[2,3,4,-1,3];
b=c=-3; 
b= a(I); // for( i=0;i<b.n;i++) if(I[i] >=0)  b[i]=a[I[i]];
c(I)= a; // for( i=0;i<I.n;i++) if(I[i] >=0)  C(I[i])=a[i];
cout << " b = a(I) : " << b << "\n  c(I) = a " << c << endl;
c(I) += a;// for( i=0;i<I.n;i++) if(I[i] >=0)  C(I[i])+=a[i];
cout << " b = a(I) : " << b << "\n  c(I) = a " << c << endl;   


}
{
// bidimensionnal  array
  int N=3,M=4;

  real[int,int] A(N,M),RA(N,M);
  real[int]  b(N),c(M);
  b=[1,2,3];
  c=[4,5,6,7];

  complex[int,int]  C(N,M);
  complex[int]  cb=[1,2,3],cc=[10i,20i,30i,40i];


  b=[1,2,3];

  int [int] I=[2,0,1];
  int [int] J=[2,0,1,3];

  A=1; // set the all matrix
  A(2,:) = 4; //  the full line 2
  A(:,1) = 5; //  the full column 1
  A(0:N-1,2) = 2; // set the column 2
  A(1,0:2) = 3; // set the line 1 from 0 to 2

  cout << " A = " << A << endl;
  // outer product 
  C  =  cb*cc';
  C +=  3*cb*cc';
  C -=  5i*cb*cc';
  cout << " C = " << C << endl;
  // the way to transform a array to a sparce matrix
  matrix B;
  B = A; 
  B=A(I,J); // B(i,j)= A(I(i),J(j))
  B=A(I^-1,J^-1);  // B(I(i),J(j))= A(i,j)  

  A = 2.*b*c'; // outer product  
  cout << " A = " << A << endl;
  cout << " A(1,2) " << A(1,2)  << endl;
  B = b*c'; // outer product  B(i,j)  = b(i)*c(j) 
  B = b*c'; // outer product  B(i,j)  = b(i)*c(j) 
  B = (2*b*c')(I,J); //   outer product  B(i,j)  = b(I(i))*c(J(j)) 
  B = (3.*b*c')(I^-1,J^-1); // outer product  B(I(i),J(j))  = b(i)*c(j) 
  cout << "B = (3.*b*c')(I^-1,J^-1) =  " << B << endl;  
  cout << " b =" <<  b << endl;
  b = exp(b) ;
  cout << " exp(b) =" <<  b << endl;
  cb += complex(10.)*cc(0:2);
  cout << " cb =" <<  cb << endl;
  cb = exp(cb) ;
  cout << " exp(cb) =" <<  cb << endl;
  cout << " exp(cb).re =" <<  cb.re << endl;
  cout << " exp(cb).im =" <<  cb.im << endl;
  cb.im = 0.;
  cout << cb << endl;
  b += cb.re + cb.im;   //  do not work to do
  cout << " b = " << endl; 
  {ofstream FA("A.txt");
  FA << A << endl;
  }
  {ifstream FA("A.txt");
  FA >> RA ;
  cout << RA << endl; 
  RA -= A;
  cout << " RA =  00 == " << RA.linfty  << endl; 
  assert( RA.linfty < 1e-12);
  }
  //  Add april 2018
   	real[int] AV(A.n*A.m);
	for [i,j,aij: A ] AV[i+A.n*j]=aij;
  	int i,j,ii,jj;
  	ijmax(A,ii,jj);
  	i = A.imax;	j=  A.jmax;
  	cout << " max " << i << " " << j << " "<< AV.imax << " " << A.max << endl; 
  	assert( i+A.n*j== AV.imax );
  	assert( ii+A.n*jj == AV.imax );
  	ijmin(A,i,j);
  	ii = A.imin;	jj=  A.jmin;
  	cout << " min  " << i << " " << j << " "<< AV.imin << " " << A.min<< " == " << AV.min << endl; 
  	cout << " minn " << ii << " " << jj << " "<< AV.imin << " " << A.min<< " == " << AV.min << endl; 
  	assert( i+A.n*j == AV.imin  );
  	assert( ii+A.n*jj == AV.imin  );
}
{
// sort array : 
real[int] a=[3,5,7,9,0];
real[int] b(a);
int[int] p=[0,1,2,3,4];

b=a;
cout << " a =" <<a << endl;
sort(b,p);
cout << " b.sort=" <<  b << endl;
cout << " b = " << b << endl;
cout << " p =  " << p << endl;
b=a;
b(0:5:2).sort;
cout << b << endl; 
cout << b(0:5:2)  << endl; 
cout << " quantile(0.2)  = " <<  b.quantile(0.2) << endl; 
p[0] = 1000;
p[1] = 888;
cout << "before    p(1:3).sort  " << p  << endl; 
p(1:3).sort;
cout << "after   p(1:3).sort " << p  << endl; 
p.sort; // version 3.19 ##
cout << "after   p.sort " << p  << endl; 

macro AA [ [1,2],[3,4]] //
macro BB [ [1,2],[5,10]] //
 cout << AA[1][0] << " 3  " << endl;
 cout << trace( AA * BB' + AA - BB' ) <<endl;
}
//  version 3.2  mai 2009
//  like math lab. and scilab
{
int[int] tt(2:10); //  2,3,4,5,6,7,8,9,10  
int[int] t1(2:3:10); // 2,5,8,
cout << " tt(2:10)= " << tt << endl;
cout << " t1(2:3:10)= " << t1 << endl;
tt=1:2:5;
cout << " 1.:2:5 =>  " << tt << endl;
}

{
real[int] tt(2:10); //  2,3,4,5,6,7,8,9,10  
real[int] t1(2.:3:10.); // 2,5,8,
cout << " tt(2:10) = = " << tt << endl;
cout << " t1(2.:3:10.)= " << t1 << endl;
tt=1.:0.5:3.999;
cout << " 1.:0.5:3.999 =>  " << tt << endl;
}
{
complex[int] tt(2.+0i:10.+0i); //  2,3,4,5,6,7,8,9,10  
complex[int] t1(2.:3.:10.); // 2,5,8,
cout << " tt(2.+0i:10.+0i)= " << tt << endl;
cout << " t1(2.:3.:10.);= " << t1 << endl;
cout << " tt.re real part array   " << tt.re << endl ; 
 //  the real part array of the complex array \index{re}\index{array!re}
cout << " tt.im imag part array   " << tt.im << endl ; 
//  the imag part array of the complex array \index{im}\index{array!im}


}
{

real [int] tab(10), tab1(10); // 2 array of 10 real
//real [int] tab2;    //  bug array with no size
tab = 1.03;                //  set all the array to 1.03
tab[1]=2.15;
cout << tab[1] << " " << tab[9] << " size of tab = "
     << tab.n << " min: " << tab.min << "  max:" << tab.max
     << " sum : "   << tab.sum <<   endl; //
tab.resize(12); //  change the size of array tab
  // to 12 with preserving first value
tab(10:11)=3.14; //  set unset value
cout <<" resize tab: " <<  tab << endl;
real [string] tt;
tt["+"]=1.5;
cout<<tt["a"]<<"  "<<tt["+"]<<endl;
real[int]  a(5),b(5),c(5),d(5);
a = 1;
b = 2;
c = 3;
a[2]=0;
d = ( a ? b : c ); // for i = 0, n-1  : d[i] = a[i] ? b[i] : c[i] ,
cout << " d = ( a ? b : c )  is " << d << endl;
d = ( a ? 1 : c );// for i = 0, n-1: d[i] = a[i] ? 1 : c[i] ,   (v2.23-1)
d = ( a ? b : 0 );// for i = 0, n-1: d[i] = a[i] ? b[i] : 0 ,   (v2.23-1)
d = ( a ? 1 : 0 );// for i = 0, n-1: d[i] = a[i] ? 0 : 1 ,     \hfill(v2.23-1)
 tab.sort ; //  sort the array tab  (version 2.18) 
cout << " tab (after sort) "  << tab << endl;
int[int] ii(0:d.n-1); // set array ii to 0,1, ..., d.n-1
d=-1:-5; // set d to  -1,-2, .. -5
sort(d,ii); // sort array d and ii in parallele
cout << " d " << d << "\n ii = " << ii << endl;

}

//  version 3.8-1
for(int i=0;i<ARGV.n;++i)
  {
    cout << ARGV[i] << endl;
  }
// Array of FE.
{
mesh Th=square(2,2);
fespace Vh(Th,P1);// scalar 
fespace Wh(Th,[P1,P1]);// vector
Vh[int] vh(10);
Wh[int] [uh,wh](10); 
vh[2]=x;
[uh[2],wh[2]]=[y,x];
[uh[2],wh[2]]=[y,x]; // set 3rd value 
cout << wh.n << endl;
cout << vh.n <<endl;
vh.resize(20);
cout << vh.n <<endl;
}



{ // version 3.43-3  init of map ...
  cout << " new stuff " << endl; 
  int[string] a=["2",1,"12",4];
  string[string] b= ["-1",1,"13","qsdqdq"];
  cout << " a " << a  << endl;
   cout << " b " << b  << endl; 
// the new kind of loop: 
  for [i,v:a] cout << " a: " << i << " " << v << endl;

  real[int,int] t=[[1,2],[2,3],[3,4],[5,6]]; 
  cout << t << endl;
  cout << t(1:3,0:1)' << endl; 

}
{ // version 3.51-1
  for(real a=-1;a< 2; a+= 0.4)
  cout << projection(-0.1,1,a)<< endl; 
  cout << dist(3,4)<< " " << dist(1,2,3) << " = " << sqrt( 14.  ) << endl; 
}
{ // array of array
	
	real[int][int] a(10);

	for(int i=0; i< a.n; ++i)
	{
	  a[i].resize(10+i);
	  a[i]=1:10+i ;
	}
	cout << a[3] << endl; 
	
	real[int,int][int]  aa(5); //  array of matrix 
	for(int i=0; i< aa.n; ++i)
	{
	  aa[i].resize(10+i,2);
	  aa[i]= 10 ;
	  aa[i](2,1)=2;
	}
	

}
{//    version 4.4-1 
	int n=10; 
	real[int,int] a(10,10);
	int[int] I=[1,3,6];
	for [i,j,aij:a] aij = i + 10 *j; 

	cout << a << endl; 

	real[int] b(I.n);
	b= a(1,:)(I);
	cout << b << endl; 
	real[int] c= a(:,1)(I);
	cout << b << endl; 

	real[int] d = a.diag ; // 
	real[int] aa= a.asarray; //  view full mat as a arry 
	real[int] d1= a.asarray(1:n*n-1:n+1); // build 

	cout <<  " d =" << d <<endl; 
	cout <<  " aa =" << aa <<endl; 
	cout <<  " d1=" << d1  <<endl; // diag shifted to one
	// change the diag of a
	//cout << a(2:5,3:7) <<endl; 
	//cout << " diag " << a(2:5,3:7).diag << endl; // a piece of diag
	a(2:5,3:7).diag= 200;
	a.diag += 100;

	cout << a << endl; 

	assert( a(9,9) == 199 );
	assert( a(5,6) == 200 );
	a =eye(5);
	cout << a << endl;

	matrix A=eye(10);
	cout << A << endl; 
	A=eye(5);
	cout << A << endl; 
	d.rmeps(15.);// put to zero term abs < 15
	cout << d << endl;
		
}
{ // oct 2020 FH.. 
	// all equal value in int array ???
	int[int] XX=[1,2,6,1,1];
	int[int] I;
	findall(XX,10,I);// version 4.7.
	cout << I << endl;
	cout  << " max "<< I.max << " min  " << I.min << " sum " << I.sum << " " << I.n << endl;
	//assert(I.n==0);// attention I.sum bug before v 4.7.1
	verbosity=10; 
	findall(XX,1,I);
	cout << I << " " << I.sum << endl;
         assert(I.sum==0+3+4); //commemt   due  to bug on ubuntu ????? FH ...
	cout  << " max "<< I.max << " min  " << I.min << " sum " << I.sum << endl;
	

}
//  sparse matrix test  ---
// example of the new matrix feature in version 1.40
// -------------------------------------------------

// ALH - for regression test
real regtest;

for(int step=0; step<2; ++step) // make to time the test to find memoire leak ..
  { 
    mesh  TH = square(3,4);
    mesh  th = square(2,3);
    mesh  Th = square(4,4);


    fespace VH(TH,P1);
    fespace Vh(th,P1);
    fespace Wh(Th,P1);

    matrix B= interpolate(VH,Vh);  // build interpolation matrix Vh->Vh 
    matrix BB= interpolate(Wh,Vh);  // build interpolation matrix
    varf vA(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+ int1d(Th)(u*v); 
    matrix A=vA(Wh,Wh);



    Vh ml=0;
    varf vML(u,v) = int2d(th)(1*v);
    ml[]=vML(0,Vh); // build the P1 mass lump of P1
    cout << ml[] << endl;
    matrix ML(ml[]); // matrix diagonal
// check +=  version 3.xx
real sml=ml[].sum;
ml[]+=vML(0,Vh);
real sml2=ml[].sum;
cout << " ### " << sml2 << " " << sml*2 << endl;    
assert((sml*2-sml2) < 1e-10);
ml[]/=2.; 
    cout << "ML="<<ML << endl;
    cout << "B="<<B << endl;
    matrix BML=B*ML;
    matrix tB=B';        //'; transpose 
				//cout << "tB=" << tB << endl;
				matrix MLtB=ML'*B'; // 

    //cout << "BML="<<BML << endl;
    //cout << "MLtB=" << MLtB << endl;

    // WARNING if sparsesolver is not install
    // the sparsesolver solver is replace by LU 
    //  but LU need skyline matrix 
    if(HaveUMFPACK)
      set(A,solver=sparsesolver); // set a solver 
    else 
      set(A,solver=GMRES); // set a solver 
    VH uH=0;
    Vh uh=x+y;
    uH[]= B*uh[];
    plot(uH,wait=1);
    matrix BtA = BB'*A;//';
    matrix BtAB = BtA*BB;
    if(HaveUMFPACK)  
      set(BtAB,solver=sparsesolver);  
    else 
      set(BtAB,solver=GMRES);  
    Vh ff=1;
    Vh xx;
    cout << " ------ " << xx[].n << " = " << BtAB.n << "x" << BtAB.m << " " << ff[].n <<  endl;

    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    xx[]=BtAB^-1*ff[];
    cout << " ------ " << endl;
    plot(xx, wait=1);

    // ALH - for regression test
    regtest=xx[]'*xx[]; //'

      {
	int N=10;
	real [int,int] A(N,N);
	real [int] a(N),b(N),c(N);
	int [int] II(N);
	int [int] JJ(N);
	int [int] III(N);
	int [int] JJJ(N);
	for (int i=0;i<N;i++)
	  {
	    II(i)=i*2;
	    III(i)=(i*1023)%N;
	    JJJ(i)=(i*7)%N;
	    JJ(i)=20-i;
	  }	
	A =0;
	for (int i=0;i<N;i++)
	  {
	    A(i,i)=1+i;
	    if(i+1 < N)    A(i,i+1)=-i;
	    a[i]=i;
	  }
	b=a(III);  //  b(i)=a(iii(i))
	c(III)=a;  //  c(III(i)) = a(i)
	cout << " III = " << III << endl;
	cout << " a(III)     " <<  b << endl;
	cout << " a(III^1) = " << c  << endl;
	for (int i=0;i<N;i++)
	  assert( int(c[int(b[i])]) == i);
  
	matrix sA=A;
	{
	  {
	    ofstream ff("A.matrix");
	    ff  << sA; 
	  }
	  matrix ssA;
	  {
	    ifstream ff("A.matrix");
	    ff >> ssA;
	    ssA = (1.)*sA+ (-1.)*ssA;
	    cout  << ssA << endl; 
	  }
	}
  
	matrix tAA=sA+sA';//';
	matrix ttAA=sA'+sA;//';
	// matrix tttAA=sA'-sA;
	// matrix ttAA=sA'-sA;
	A += 2*a*a';  //'//  produit tensoriel
	matrix A1=   A(II^-1,JJ^-1);   //  do A1(II(i),JJ(j)) = A(i),j) $
	matrix A2=   A(III,JJJ);   //  do   $A2(i,j) = A(III(i),JJJ(i)) $
	matrix sA1=   sA(II^-1,JJ^-1); //  do A1(II(i),JJ(i)) = A( 
	matrix sA2=   sA(III,JJJ);   //  do A = A 
  
	matrix A0 = (a*a')(II^-1,JJ^-1); //');
	matrix A3 = (a*a')(III,JJJ);//');
  
	cout << " ------------------- " << endl;
	// cout <<  " A  = " << A << endl;
	// cout <<  " A1 = " << A1 <<endl;
	cout << " 8,9 -> " <<II[8] << " " <<  JJ[9] <<" " << A(9,8)<< " " << A1(II[9],JJ[8]) << endl;
	assert(A(9,1) == 2*a[9]*a[1]);  
  
	for (int i9=0;i9<N;++i9)
	  for (int j9=0;j9<N;++j9)
	    {
	
	      if( abs(A(j9,i9))> 0.01) 
		assert(A1(II[j9],JJ[i9]) == A(j9,i9));
	      if( abs(A(III(j9),JJJ(i9))) > 0.01) 
		assert(A2(j9,i9) == A(III(j9),JJJ(i9) )) ;
	      //     cout << " i9,j9 -> " <<II[i9] << " " <<  JJ[j9] <<endl;
	      if( abs(a[i9]*a[j9])> 0.01) 
		assert(A0(II[i9],JJ[j9]) == a[i9]*a[j9]);
	      if( abs(a[III[i9]]*a[JJJ[j9]])> 0.01) 
		assert(A3(i9,j9) == a[III[i9]]*a[JJJ[j9]]);
	    }
	b=A*a;
	c=-9;
	cout << "xxxx\n"; 
	matrix sparseA=A;
	//cout << sparseA << endl;
	sparseA = 2*sparseA+sparseA;
	sparseA = 4*sparseA+sparseA*5; //  * 27
	matrix sparseB=sparseA+sparseA+sparseA-sparseA+2*sparseA; 
	//cout << sparseA << endl;
	//cout << sparseB << endl; // *81 
	cout << "sparseB = " << sparseB(0,0) << endl;
    cout << " trace = " << sparseB.trace << " == " <<  sparseA.trace*4 << endl; 
	cout << " -------- block matrix \n " << endl;
	matrix B = [ [sparseA, 0 , sparseA ], 
		     [ 0, sparseA , 0 ] ,
		     [0, 0, sparseB' ]];//']];
	matrix B2 = [ [sparseA], [sparseA]];
  
	assert( B2.n == sparseA.n*2);
	assert( B2.m == sparseA.m);
  
	matrix B1 = [ [sparseA, sparseA] ];
	assert( B1.m == sparseA.m*2); // FH. bug before version  2.11-4 (10/01/2007)
	assert( B1.n == sparseA.n);
  
  
	real[int] x([a,b,c]); //  construct the block vector x form a,b,c,
	//  where the size is  sum of size of a,b,c, 
	x=[a,b,c]; // set x to to the block vector (the vector x is  resize if it necessary
	cout << " abc =" << a[2] << " " << b[3] << " "<< c[4] << endl;
	cout << " xxx =" << x[2] << " " << x[3+N] << " "<< x[4+N*2] << endl;
	x = x*10;
	[a,b,c]=x; // set the block vector a,b,c  from concecutive part of  x;
	cout << " abc*10 == "  << a[2] << " " << b[3] << " "<< c[4] << endl;
  
  
	// remark  the size of sum of size must be equal to the size of x.  
	//cout << " B = " << B << endl; 
	cout << B(8,29) << " ===  " <<  sparseA(8,9) << endl;
	cout << B(28,27)
	<< " ===  " <<  sparseB(7,8) << endl;
	B(8,29)=100;  // change the value an existing coef 
	cout << " B(8,29) " <<  B(8,29) << endl;
	cout << " -------- block matrix \n " << endl;
      }

    //  build FE  matrice with differente meshes (here 3) 
    varf vM(u,v)=int1d(Th,qforder=1)(u*v);
    matrix MM=vM(Vh,VH);
    //cout << MM << endl;
    Vh unVh=0,wVh=0;
    VH unVH=0,wVH=0;
    unVh[]=1;
    unVH[]=1;
    wVh[] = MM' * unVH[] ; //'
      wVH[] = MM * unVh[] ; 

    //cout << "wWh : " << wVh[] << endl;
    //cout <<" wVH : " << wVH[] << endl;
    // array of matrix v2.4-1 
    cout << " array of matrix   \n" ;
    matrix[int]  aM(10);
    aM[0]= MM;
    aM[3]= MM;
    aM[9]= MM;
    // aM.resize(4);
    //  aM.resize(10);  bug on debian ? FH 

    //  add version 2.17 --- 
    {
      real[int] coef([1,2,3,5,6]);
      int[int]  lg(  [1,3,6,9,100]);
      int[int]  cl(  [1,4,9,0,0]);
  
      // a diagonal matrix
      matrix A=[coef];
      cout << " A = " << A << endl;
      // a raw matrix  
      matrix B=[lg,cl,coef];
      cout << " B = " << B << endl;
      [lg,cl,coef] = A; 
      cout<< " lg    : "  << lg << endl;
      cout << " cl   : " << cl << endl;
      cout << " coef = "<< coef << endl;
  
    }

    // version 3.1-1
	MM.CSR; 
    cout << " MM (format CSR or Morse)   "<< MM << endl;
    MM.resize(10,100);
    cout << " MM format COO " << MM << endl;

    {  //  test renumbering of sub mesh ..
      func Pk=P2;
      int[int] n2ok(1); 
      mesh ThC = trunc(Th,x < 0.5,new2old=n2ok);
      fespace VFh(Th,Pk);
      fespace VCh(ThC,Pk);
      verbosity= 1; 
      int[int] n2o=restrict(VCh,VFh,n2ok);
      cout << " n2o " << n2o << endl;
  
    }
  }
  
  { // verification v 4.3-2 F. H
	  matrix A = [[1,2],[3,4]],B;
	  matrix D2 = -(A-( (-1.5)*A- (2.2)*A));
	  real a00= -(1.-( (-1.5)*1.- (2.2)*1.));
	  //  -1 ---1.5 ---2.2
	  cout << D2 << endl; 
	  cout << a00 <<endl ;
	  assert( abs(D2(0,0)-a00 ) < 1e-10);  
	  B=A;
	  B+= A;// ???
	  B+= 2*A;
	  cout << B << endl;
	  assert( abs(B(0,0)-4 ) < 1e-10);  
	  cout << A << endl;
	  B -= 2*A - 3*A;// 
	  cout << B << endl;
	  assert( abs(B(0,0)-5) < 1e-10);  
  
  }
  {  // version 4.3-2-b F.H. (31 july 2017)
	  real[int] diag=[1,2,3,4,6,7,9,10];
	  int n = diag.n; 
	  
	  matrix A(n,n);
	  A.diag = diag;
	  cout << " A " << A << endl;
	  A.coef =0; // put all coef to zero 
	  cout << " A " << A << endl;
	  assert( A.l2 ==0);
	  A.diag = diag;
	  A.clear; 
	  cout << " A " << A << endl;
	  assert(A.nnz==0); 
  }
  { // add Oct 2019 version 4.4-1
  matrix A=eye(10);
  cout << A << endl; 
  A=eye(5);
  cout << A << endl; 
}
{  // version 4.13  sep. 2023 FH..
	// get structure of sparse matrix int [int][int] array ..
	// usefull to find some cnnectity
	// here:  for each vertex i, gives the list of  vertex in a same element. 
	mesh Th=square(3,3);
	fespace Vh(Th,P1);
	varf va(u,v)= int2d(Th)(u*v);
	matrix A = va(Vh,Vh);
	int [int][int] a=A;// array of array : Warning sort in  CSR  on A 
	int [int][int] at=A';// array of array:   Warning sort in  CSC  on A 

	for (int i=0; i< a.n; ++i)
	  cout << i << " " << a[i]  << endl;
        // here array at and array a are equal !
}
// Example of number manipulation

real x = 3.14, y;
int i, j;
complex c;
cout << "x = " << x << endl;

x = 1; y = 2;
x = y;

i = 0; j = 1;

cout << "--- Integer and real numbers ---" << endl;
cout << 1 + 3 << " " << 1/3 << "\n";
cout << 10 ^10 << "\n";
cout << 10 ^-10 << "\n";
cout << -10^-2 + 5 << " == 4.99\n";
cout << 10^-2 + 5 << " == 5.01\n";

cout << "--- Complex numbers ---" << endl;
cout << 10 - 10i << endl;

cout.scientific << "--- Scientific notation ---\n";
int prec = cout.precision(12);
cout << "-1^(1/3) = " << (-1+0i)^(1./3.) << " (precision=12)\n";
cout.precision(prec);
cout.fixed;
cout.showpos << "--- Fixed and showpos ---\n";
cout << "-1^(1/3) = " << (-1+0i)^(1./3.) << " (precision=" << prec << ")\n";
cout.noshowpos << "--- noshowpos ---\n";
cout << "8^(1/3)= " << (8)^(1./3.) << endl;
cout << "sqrt(-1) = " << sqrt(-1+0i) << endl;
complex a = 10 + 1i;
cout.default << "--- Default ---\n";
cout << a << endl;
cout << "real(a) = " << real(a) << ", conj(a) = " << conj(a)
	<< ", arg(a) = " << arg(a) << endl;

cout << "++i =" << ++i ;
cout << "i = " << i << endl;
cout << "i++ = "<< i++ << endl;
cout << "i = " << i << endl;
cout << "--- String concatenation ---" << endl;
string str, str1;
str = "abc+";
str1 = "+abcddddd+";
str = str + str1;
str = str + 2 ;
cout << "str = " << str << " == abc++abcddddd+2;\n";

{
	real x=0;
	for (int i = 0; i < 10; i++)
		x += i*i;
	cout << "x= " << x << endl;
	// example of if arithmetic expression
	real a = x == 0 ? x : -1;
	real b = x != 0 ? x : -1;
	cout << "a = " << a << ", b = " << b << endl;
	string ss = "\z\a\b\f\\--\\";
	cout << "\"" << ss << "\"" << endl;
}

// Add basic operation on R3 version 4.10.1 feb. 2022 
// to speed up compuatution 
R3 A(1.,2.,3.);
R3 B(3.,1.,0.);
R3 AB(A,B); // bipoint affine construction ..
R3 C = A^B; // cross product ..
R3 AB1 = A.*B ; //  product by componant by componant
R3 AB2 = A./B ; //  div by componant by componant
R3 Q= A+3*B+C-B;
cout << "det= " << det(A,B,C) << " == " << (A^B)'*C << endl; 
cout << Q.x << " " << Q.y << " "<< Q. z << endl; 
Q.x =1;
P=Q;// Current pojnt 
cout << P.x << " " << P.y << " "<< P. z << endl; 
cout <<"P=" <<  P << " det " << det(A,B,C) << endl;
cout << "R3" << R3(1,3,6) << " R3(A,) =" << R3(A,B) << endl; 
cout << C.l2 << " " << C.norm << " " << C.linfty  << " " << C <<  " dot product:  " << C'*C <<  endl;
real[int] E=A; // def array from R3*
real[int] F2=A+A; // def array from R3
R3 F3=E; // def R3 from array
F3=E; // set R3 from array 
F3+=E;
R3 O(0,0,0),E1(1,0,0),E2(0,1,0),E3(0,0,1); 
cout << " solidangle " << solidangle(O,E1,E2,E3) << " == " << pi/2 << endl;
cout << A'*R3(1,1,1) << endl; 
cout << R3(1,2,3).norm << " == " << sqrt(14.) << endl; 

mesh Th=square(4,4);
mesh Th4=square(2,2,[x*0.5,y*0.5]);
plot(Th,Th4,ps="ThTh4.eps",wait=1);
fespace Vh(Th,P1);
fespace Vh4(Th4,P1);
fespace Wh(Th,P0);
fespace Wh4(Th4,P0);

// remark in previous version (before v1.44)
// the name of interpolate function is interplotematrix

matrix IV= interpolate(Vh,Vh4); //  here the function is 
// exended by continuity

cout << " IV Vh<-Vh4 " << IV << endl;
Vh v;          Vh4 v4=x*y;
v=v4;           real[int]   vv= IV*v4[];
// here   v[]  == vv    =>  
real[int]  diff= vv - v[]; 
cout << " || v - vv || = " <<  diff.linfty << endl;
assert( diff.linfty<= 1e-6); // 

matrix IV0= interpolate(Vh,Vh4,inside=0);//  here the function is 
// exended by zero

cout << " IV Vh<-Vh4 (inside=1)  " << IV0 << endl;

matrix IVt0= interpolate(Vh,Vh4,inside=1,t=1);
cout << " IV Vh<-Vh4^t (inside=1)  " << IVt0 << endl;

matrix IV4t0= interpolate(Vh4,Vh);
cout << " IV Vh4<-Vh^t  " << IV4t0 << endl;

matrix IW4= interpolate(Wh4,Wh);
cout << " IV Wh4<-Wh  " << IW4  << endl;

matrix IW4V= interpolate(Wh4,Vh);
cout << " IV Wh4<-Vh  " << IW4  << endl;



fespace V4h(Th4,[P1,P1,P1,P1]);
fespace V3h(Th,[P1,P1,P1]);
int[int] u2vc=[1,3,-1];// -1 => put zero on the componante ;
matrix IV34= interpolate(V3h,V4h,inside=0,U2Vc=u2vc);//  here the function is 
V4h [a1,a2,a3,a4]=[1,2,3,4];
V3h [b1,b2,b3]=[10,20,30];
b1[]=IV34*a1[];

cout << "b1 = " << b1(.25,.25) << " == " << 2 << endl;
cout << "b2 = " << b2(.25,.25) << " == " << 4 <<endl;
cout << "b3 = " << b3(.25,.25) << " == " << 0 <<endl;
// Build interplation matrix a_ij at points (xx[j],yy[j]) j = 0, 1 :
//  $a_ij = d_op(w^i_c (xx[j],yy[j]))$ where $w_i$ is the basic function.  
real[int] xx=[.3,.4],yy=[.1,.4];
int c=0,dop=0; //  component and d operator 
matrix Ixx= interpolate(Vh,xx,yy,op=dop,composante=c);
cout << Ixx << endl;
Vh ww;
real[int] dd=[1,2]; 
ww[]= Ixx*dd;
plot(ww,wait=1);
mesh Th=square(10,10);
fespace Vh(Th,P1); 

macro grad(u) [dx(u),dy(u)]//
varf va(u,v) = int2d(Th) ( u*v+grad(u)'*grad(v)-10*dy(v)*(u))+ int2d(Th)(v*x)+on(1,2,3,4,u=0);
varf vat(u,v) = int2d(Th) ( u*v+grad(u)'*grad(v)-10*(v)*dy(u))+ int2d(Th)(v*x)+on(1,2,3,4,u=0);



matrix A=va(Vh,Vh,solver=sparsesolver);
matrix At=vat(Vh,Vh,solver=sparsesolver);
real[int] b = va(0,Vh);
set(A,solver=sparsesolver);

Vh u,ut;

u[]=A'^-1*b;
ut[]=At^-1*b;
plot(u,ut,wait=1);

ut[]-=u[];
real err = ut[].linfty ;
cout << " err = " << err << endl; 
assert(err < 1e-6); 

mesh Th=square(2,2);
plot(Th,wait=1,ps="square-0.eps");
Th= adaptmesh(Th,1./30.,IsMetric=1,nbvx=10000);// \index{mesh!uniforme}
plot(Th,wait=1,ps="square-1.eps");
Th= adaptmesh(Th,1./30.,IsMetric=1,nbvx=10000);//  more the one time du to
Th= adaptmesh(Th,1./30.,IsMetric=1,nbvx=10000);//  adaptation  bound \texttt{maxsubdiv=}
plot(Th,wait=1,ps="square-2.eps");


// variationnal inequality 
// --------------------------
//  Probleme:
//  $ - \Delta u = f , \quad u=gd \on \Gamma, \quad u < g $
//  algo of   Primal-Dual Active set strategy as a semi smoth Newton Method
//   HinterMuller , K. Ito, K. Kunisch 
//  to appeared in SIAM Option
// Thank to O. Pironneau 
// --------------------------
// F. Hecht april 2005
//  -----------------------
 mesh Th=square(20,20);
 real eps=1e-5;
 fespace Vh(Th,P1);     // P1 FE space
 int n = Vh.ndof; // number of Degree of freedom
 Vh uh,uhp;              // solution and previous one
 Vh Ik; //  to def the set where the containt is reached. 
 real[int] rhs(n); // to store the right and side of the equation 
 real c=10;  // the parameter of the algoritme
 func f=1;         //  right hand side function 
 func fd=0;         // Dirichlet   boundary condition function
 Vh g=0.05;
// array to store   
real[int] Aii(n),Aiin(n); // store the diagonal of the matrix




 real tgv = 1e30; // a hude value of exact penalisation of boundary condition
//  the variatonnal form of the problem:
 varf a(uh,vh) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=fd) ;                      //  boundary condition form



// two version of the problem  
matrix A=a(Vh,Vh,tgv=tgv,solver=CG);
matrix AA=a(Vh,Vh);

//  the mass Matrix construction: 
varf vM(uh,vh) = int2d(Th)(uh*vh);
matrix M=vM(Vh,Vh); // to do a fast computing of $L^2$ norm : sqrt( u'*(w=M*u)) 
Aii=A.diag; // get the diagonal of the matrix 

rhs = a(0,Vh,tgv=tgv);
Ik =0;
uhp=0;
Vh lambda=0;
for(int iter=0;iter<100;++iter)
{
  real[int] b(n) ; b=rhs;  //  get a copy of the Right hand side 
  real[int] Ak(n); //  the complementary of Ik ( !Ik = (Ik-1))
  // Today  the operator Ik- 1. is not implement so we do:
  Ak= 1.; Ak  -= Ik[];  // build Ak  = ! Ik 
  //  adding new locking  condition on b and on the diagonal if (Ik ==1 )
  b = Ik[] .* g[];      b *= tgv;     b  -=  Ak .* rhs;
  Aiin = Ik[] *  tgv;      Aiin  +=  Ak  .* Aii;  //set  Aii= tgv  $ i \in Ik $
  A.diag = Aiin; //  set the matrix diagonal 
  set(A,solver=CG); // important to change precondiconning  for solving
  uh[] = A^-1* b;   //  solve the problem with more locking condition
  lambda[] = AA * uh[]; //  compute the resudal ( fast with matrix)
  lambda[] += rhs; // remark rhs = $-\int f v $ 

  Ik = ( lambda + c*( g- uh)) < 0.;  //  set the new value 
  
   plot(Ik, wait=1,cmm=" lock set ",value=1 );
   plot(uh,wait=1,cmm="uh");
   // trick to compute  $L^2$ norm of the variation
      real[int] diff(n),Mdiff(n);  
      diff= uh[]-uhp[];    
      Mdiff = M*diff; 
      real err = sqrt(Mdiff'*diff);
  cout << "  || u_{k=1} - u_{k} ||_2 " << err << endl;
  if(err< eps) break; // stop test 
  uhp[]=uh[] ; // set the previous solution 
} 
savemesh(Th,"mm",[x,y,uh*10]);
  
  
  
// file thermal-fast.edp    same problem than thermal.edp

func fu0 =10+90*x/6;
func k = 1.8*(y<0.5)+0.2;
real ue = 25. , alpha=0.25, T=5, dt=0.1 ;

mesh Th=square(30,5,[6*x,y]);
fespace Vh(Th,P1);

Vh u0=fu0,u=u0;

varf vthermic (u,v)= int2d(Th)(u*v/dt + k*(dx(u) * dx(v) + dy(u) * dy(v)))  
  +  int1d(Th,1,3)(alpha*u*v)
  + on(2,4,u=1); 

varf vthermic0(u,v) =   int1d(Th,1,3)(alpha*ue*v);

varf vMass (u,v)= int2d(Th)( u*v/dt)  + on(2,4,u=1);

real tgv = 1e30;
matrix A= vthermic(Vh,Vh,tgv=tgv,solver=CG);
matrix M= vMass(Vh,Vh);


real[int]  b0  = vthermic0(0,Vh); // constant part of the RHS 
real[int]  bcn = vthermic(0,Vh); //  tgv on Dirichlet boundary  node  ( !=0 )
// we have for the node $i$ : $i\in \Gamma_{24}  \quad \Leftrightarrow \quad bcn[i] \ne 0 $ 
real[int]  bcl=tgv*u0[]; //  the Dirichlet boundary condition part 


ofstream ff("thermic.dat");
for(real t=0;t<T;t+=dt){
    real[int] b = b0 ; // for  the  RHS
    b += M*u[]; //  add the the time dependant part
    // to lock boundary 2,4 part:
    b = bcn ? bcl  : b ; // do $\forall i$:  b[i] =  bcn[i] ? bcl[i] : b[i]  ;      
    u[] = A^-1*b;    
    ff<< t << " " << u(3,0.5) <<endl;
    plot(u);
}
for(int i=0;i<20;i++) 
  cout<<dy(u)(6.0*i/20.0,0.9)<<endl;
plot(u,fill=true,wait=1,ps="thermic.eps");


verbosity=2;
mesh Thxy=triangulate("xyf");
plot(Thxy,wait=1,ps="Thxy.ps");
fespace Vhxy(Thxy,P1);
Vhxy fxy;

{ ifstream file("xyf");
   real xx,yy;
   for(int i=0;i<fxy.n;i++)
   file >> xx >>yy >> fxy[][i]; 
}

plot(fxy,wait=1,ps="xyf.ps");

// new way to bluid a mesh   version 2.23-2
Vhxy xx=x,yy=y;

mesh Th=triangulate(xx[],yy[]);
cout << " region = " <<  triangulate(xx[],yy[])[1].region  <<endl; 
cout << fxy[]'*fxy[] << endl;
plot(Th,wait=1); 
//  
//   calcul d'une zone saturation en eau (nappe phreatique)
//
verbosity=1;
real weak=1;
string com= "  avec du/dn ";
if(weak) com = " avec du/du = residu  ";
real L=10;        // longueur du domaine					   	
real Q=0.02;      // flux entrant
real K=0.5;	      //permeabilite	

real  erradap=0.001;
real  coef=1;



real h=2.1;	 // hauteur du bord gauche
real h1=0.35;    // hauteur du bord droite

//  maillage d'un tapeze
border a(t=0,L){x=t;y=0;};       // bas			   	
border b(t=0,h1){x=L;y=t;};      // droite
border f(t=L,0){x=t;y=t*(h1-h)/L+h;}; //  free surface
border d(t=h,0){x=0;y=t;};      // gauche

int n=10;
mesh Th=buildmesh (a(L*n)+b(h1*n)+f(sqrt(L^2+(h-h1)^2)*n)+d(h*n));

plot(Th,ps="dTh.eps");

fespace Vh(Th,P1);

int j=0,ii=0;

Vh p,v,pp,vv;

varf vPp(p,pp) = int2d(Th)( dx(p)*dx(pp)+dy(p)*dy(pp));
varf vonfree(p,pp) =on(f,p=1);
Vh onfree,wdpdn;
onfree[]=vonfree(0,Vh);
cout << "pb ?" << endl;
onfree[]/=onfree[].max; // sauce
cout << "pb non " << endl;
matrix A= vPp(Vh,Vh,solver=CG);


problem Pp(p,pp,solver=CG) = int2d(Th)( dx(p)*dx(pp)+dy(p)*dy(pp)) 
  + on(b,f,p=y) ;

//  --  imprecise (fort)
problem Pv(v,vv,solver=CG) = int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  on (a, v=0) + int1d(Th,f)(vv*((Q/K)*N.y- (dx(p)*N.x+dy(p)*N.y))); 
//   -- precise (faible)
problem Pw(v,vv,solver=CG) = int2d(Th)( dx(v)*dx(vv)+dy(v)*dy(vv)) 
  +  on (a, v=0) + int1d(Th,f)(vv*((Q/K)*N.y)) + wdpdn[]; 
  

real errv=1;
verbosity=1;
while(errv>1e-6)
{
  j++;       
  Pp;
  if (weak) {   wdpdn[] = A*p[]; wdpdn[] = wdpdn[].*onfree[];   wdpdn[] = -wdpdn[];
             Pw;}
  else Pv;
  errv=int1d(Th,f)(v*v);
  plot(Th,p,v ,cmm=com+"   iter = "+j+ "  errv =" +errv,wait=0);
  
//  if (j%10==0)
//    Th=adaptmesh(Th,p,err=erradap ) ;
  real coef=1;
  real mintcc = checkmovemesh(Th,[x,y])/5.; 
  real mint = checkmovemesh(Th,[x,y-v*coef]); 
  
  if (mint<mintcc ||  j%10==0) {  
    Th=adaptmesh(Th,p,err=erradap ) ;
    
     mintcc = checkmovemesh(Th,[x,y])/5.;     
     wdpdn=0; 	
     onfree=0;
  }
  
  while (1) 
  {  	    
    real mint = checkmovemesh(Th,[x,y-v*coef]); 
    
    if (mint>mintcc) break;
    
    cout << " min |T]  " << mint << endl;    
    coef /= 1.5;
  }
  
  Th=movemesh(Th,[x,y-coef*v]); // calcul de la deformation 
  A= vPp(Vh,Vh,solver=CG);	
  onfree[]=vonfree(0,Vh);onfree[]/=onfree[].max; // sauce
  cout << "\n\n"<<j <<"------------ errv = " << errv << "\n\n";

}
//plot(Th,wiat=1,ps="d_Thf.eps",cmm=com);
plot(p,wait=1,ps="d_u.eps",cmm=com);
// Beam under it own weight

// Parameters
real E = 21.5;
real sigma = 0.29;
real gravity = -0.05;

// Mesh
int bottombeam = 2;
border a(t=2, 0){x=0; y=t ;label=1;}	// left beam
border b(t=0, 10){x=t; y=0 ;label=bottombeam;}	// bottom of beam
border c(t=0, 2){x=10; y=t ;label=1;}	// rigth beam
border d(t=0, 10){x=10-t; y=2; label=3;}	// top beam
mesh th = buildmesh(b(20) + c(5) + d(20) + a(5));

// Fespace
fespace Vh(th, [P1, P1]);
Vh [uu, vv], [w, s];

// Macro
real sqrt2 = sqrt(2.);
macro epsilon(u1, u2) [dx(u1), dy(u2), (dy(u1) + dx(u2))/sqrt2] // EOM
macro div(u, v) (dx(u) + dy(v)) // EOM

// Problem (with solve)
real mu = E/(2*(1 + sigma));
real lambda = E*sigma/((1 + sigma)*(1 - 2*sigma));
cout << "Lambda = " << lambda << endl;
cout << "Mu = " << mu << endl;
cout << "Gravity = " << gravity << endl;
solve Elasticity ([uu, vv], [w, s], solver=sparsesolver)
	= int2d(th)(
		  lambda*div(w, s)*div(uu, vv)
		+ 2.*mu*(epsilon(w, s)' * epsilon(uu, vv))
	)
	- int2d(th)(gravity*s)
	+ on(1, uu=0, vv=0)
	;
cout << "Max displacement = " << uu[].linfty << endl;

// Plot
plot([uu, vv], wait=1);
plot([uu, vv], wait=1, bb=[[-0.5, 2.5], [2.5, -0.5]]);

// Move mesh
mesh th1 = movemesh(th, [x+uu, y+vv]);
plot(th1, wait=1);

mesh Th1=square(10,10);
mesh Th2=square(20,10,[x+1,y]);
verbosity=3;
int[int] r1=[2,18],  r2=[4,0];
savemesh(Th1,"meshTh1_av.mesh");
Th1=change(Th1,refe=r1);
savemesh(Th1,"meshTh1_ap.mesh");
Th2=change(Th2,refe=r2);
mesh Th=Th1+Th2;

cout << " nb ref = " << int1d(Th1,1,3,4)(1./lenEdge)+int1d(Th2,1,2,3)(1./lenEdge) 
     << " == " << int1d(Th,1,2,3,4)(1./lenEdge) <<" == " << ((10+20)+10)*2 << endl; 
plot(Th,wait=1);
fespace Vh(Th,P1);
macro Grad(u) [dx(u),dy(u)]//
Vh u,v;
solve P(u,v)=int2d(Th)(Grad(u)'*Grad(v))-int2d(Th)(v)+on(1,3,u=0);
plot(u,wait=1);
mesh[int] TT(2);
TT[0]=Th1;
TT[1]=Th2;
Th=gluemesh([Th1,Th2],eps=0); //  no glue 

// Th=gluemesh(Th1+Th2,eps=0); //  no glue 
// Th=gluemesh(TT,eps=0); //  no glue 
 
solve PP(u,v)=int2d(Th)(Grad(u)'*Grad(v))-int2d(Th)(v)+on(1,3,u=0);
// FFCS: for regression tests
real regtest;

{
// ---------------
real R=50.*sqrt(2.); //  theta = 
//un quart du paraboloide
border t1(t=0,R) {x=t;y=0;    label=1;}
border t2(t=0,R) {x=(R-t);y=t;label=2;}
border t3(t=R,0) {x=0;y=t;    label=3;}
int nn=3;
mesh Th= buildmesh(t1(5*nn)+t2(5*sqrt(2.)*nn)+t3(5*nn));  
plot(Th,wait=0);

 mesh Th4;

mesh th1=movemesh(Th,[x,-y]);
mesh th2=movemesh(Th,[-x,-y]);
mesh th3=movemesh(Th,[-x,y]);
plot(Th,th1,th2,th3,wait=1);
 Th4=Th+th1+th2+th3;

plot(Th4,wait=1);
Th=Th4;
regtest=Th.nv;
}
/*
   solving   Laplace operator with Neumann boundary condition
   with 1D lagrange multiplier
   
   The variational form is
   find (u,l) such that

   $\forall (v,m)   a(u,v) + b(u,m) + b(v,l) = L(v) $
   where $b(u,m) = int u*m dx$
   
*/
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
int n = Vh.ndof;
int n1 = n+1;

 Vh uh,vh;              // unknown and test function. 
 func f=1+x-y;                 //  right hand side function 
  
varf va(uh,vh) =                    //  definition of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
;
varf vL(uh,vh)=  int2d(Th)( f*vh )  ;
varf vb(uh,vh)= int2d(Th)(1.*vh);

matrix A=va(Vh,Vh);

real[int] b(n);
b = vL(0,Vh);

real[int]  B = vb(0,Vh); 	
// the block matrix

matrix AA = [ [ A ,  B ] ,
              [ B', 0 ] ] ;

real[int]  bb(n+1),xx(n+1),b1(1),l(1);
b1=0;
// build the block rhs 
bb = [ b, b1];
set(AA,solver=sparsesolver);
xx = AA^-1*bb; // solve the linear system

[uh[],l] = xx;  // set the value 
cout << " l = " << l(0) <<  " ,  b(u,1)  =" << B'*uh[]  << endl;  
plot(uh,wait=1);

//  signe of pressure is correct 
assert(version>1.18); 
real s0=clock();
mesh Th=square(10,10);
fespace Xh(Th,P2),Mh(Th,P1);
Xh u1,u2,v1,v2;
Mh p,q,ppp;


varf bx(u1,q) = int2d(Th)( (dx(u1)*q)); 

varf by(u1,q) = int2d(Th)( (dy(u1)*q));

varf a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) )
                    +  on(1,2,4,u1=0)  +  on(3,u1=1) ;

Xh bc1; bc1[] = a(0,Xh);
Xh b;
                   
matrix A= a(Xh,Xh,solver=CG); 
matrix Bx= bx(Xh,Mh);
matrix By= by(Xh,Mh);
Xh bcx=1,bcy=0;

func real[int] divup(real[int] & pp)
{ 
  int verb=verbosity;
   verbosity=0;
   b[]  = Bx'*pp; b[] += bc1[] .*bcx[];
   u1[] = A^-1*b[];
   b[]  = By'*pp; b[] += bc1[] .*bcy[];
   u2[] = A^-1*b[];
   ppp[] =   Bx*u1[];
   ppp[] +=  By*u2[];
   verbosity=verb;
   return ppp[] ;
};
p=0;q=0;u1=0;v1=0;

        
LinearCG(divup,p[],q[],eps=1.e-6,nbiter=50);

divup(p[]);

plot([u1,u2],p,wait=1,value=true,coef=0.1);

//  test all FEspace
verbosity=2;
real a=real(1+1i);
verbosity=2;
mesh Th=square(5,5);
verbosity = 2;
cout << " P0 " << endl;
fespace Ph(Th,P0);
cout << " P1 " << endl;
fespace Vh(Th,P1);
fespace Wh(Th,RT0);
Vh<real> v=x,diff;
Vh<complex> w=x+1i*y;
cout << "w[][10] "  << " " << w[][10] << endl;
w=y+1i*y;
cout << "w[][10] " << w[][10] << " " << (w[][10])' << endl;
Wh<complex> [wx,wy]=[x+1i*y,y];
[wx,wy]=[x+1i*y,y];

func ue= (x*x+2.*y*y+(x*y*y+3.*x*x*y)*1i);
func uexx = 2.+6.i*y;
func ueyy = 4.+2.i*x;

func f= (-uexx-(2i+1)*ueyy);
func g= ue;
Vh<complex> uh,vh;
 problem laplace(uh,vh,solver=LU,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th,optimize=1)( dx(uh)*dx(vh) + (2i+1)*dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,optimize=1)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form
//verbosity=102;
  laplace; // solve the problem plot(uh); // to see the result
  real err = int2d(Th)(norm(uh-ue));
  cout << " -- err = " << err << endl;
  assert(err<0.01);
//  cout << " -- uh = " << uh[] << endl;
  cout << " uh(0.5,0.5) = " << uh(0.5,0.5) << " ~  " << ue(0.5,0.5) << endl;
  Vh vr=real(uh(x,y));
  Vh vi=imag(uh(x,y));
  vr = real(uh);
  vi = imag(uh);
  Vh ver = real(ue);
  Vh vei = imag(ue);

 // for (int i=0;i<vi[].n;i++)
 // vi[][i] = imag(uh[][i]);

// now no complex plot 
  plot(vr,ver,ps="Lr.eps",cmm="real",value=true,wait=1);
  plot(vi,vei,ps="Li.eps",cmm="imag",value=true,wait=1);

// simple movemesh example
mesh Th=square(10,10);
fespace Vh(Th,P1); 
real t=0;
// ---
//  problem is how to build data without interpolation
//  so the data u is moving with the mesh hse you can see in the plot
// ---
Vh u=y;
for (int i=0;i<4;i++)
{ 
 t=i*0.1;
 Vh f= x*t;
 real minarea=checkmovemesh(Th,[x,y+f]);
 if (minarea >0 ) //  the movemesh will be ok
   Th=movemesh(Th,[x,y+f]);
 cout << " Min area  " << minarea << endl;
//  u=(Vh,u[]);  // the new syntaxe  FH
 Vh tmp;     // =u[],  sorry no init of FEspace function with array. 
 tmp[]=u[];  //save the value  
 u=0;        // to change the FEspace and mesh  associated to u
 u[]=tmp[];  // set le value of the array without no mesh update 
 plot(Th,u,wait=1);
};
//  remark, in this programme we have no solution with link to a previous mesh
// so all the previoux are delete in memory
//   -------- 
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh,u;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0.;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=GMRES,tgv=1e5) =                    //  definion of  the problem 
  - int2d(Th)( -dx(uh)*dx(vh) - dy(uh)*dy(vh) ) //  bilinear form
  - int1d(Th,1)( -uh*vh) 
  - int1d(Th,1)(  vh)
  - int2d(Th)( f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

 problem laplacep(uh,vh,solver=CG,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

  
  laplace; // solve the problem plot(uh); // to see the result
  u=uh;
  laplacep; // solve the problem plot(uh); // to see the result
  
  plot(uh,u,value=true);
  u[] -= uh[];
  cout << "Diff min = "<< u[].min << " max=" << u[].max << endl ;
//  -----  
// the convolution of fonction:  int(Sh) ( fh(x-y) * phih(y) dy ),
// for regularisation 
load "msh3"
load "Element_P3"
real eps =  0.02;// support of the  function phih ...
func f = x >0 ; //y*x*x+y*y*y+h*tanh(val*(sin(5.0*y)-2.0*x));

meshL S1= segment(1);
meshL S10= segment(100);
fespace V1H(S1,P3HL);// P3 hermite .. function C1.. ???
V1H [rho,drho]=[1-x,0];//  fonction axi sur [0,1] 
meshL Lh=segment(100);
fespace VLh(Lh,P1);
VLh xh=x,rhoh=rho;
// a trick to plot 1d function as arry .. 
plot([xh[],rhoh[]],wait=1,cmm=" the rho function ");

func r=dist(x,y);

border csupport(t=0,2*pi){ x=eps*cos(t);y=eps*sin(t);}
mesh Sh=buildmesh(csupport(20));
fespace Wh(Sh,P1);
Wh rr=min(r/eps,1.);// 
real beta2h=1; 
Wh phih= beta2h*rho(rr);// Ok version 5/10/2023. 
cout << " int int2d(Sh)(phih) "<<int2d(Sh)(phih)<< " == " << 1 << endl;
beta2h= 1./ int2d(Sh)(phih) ; // to a mass == 1 
phih[] *= beta2h; 
cout << " int int2d(Sh)(phih) "<<int2d(Sh)(phih)<< " == " << 1 << endl;
plot(Sh,phih,wait=1,value=1,cmm="phih");

cout << " int phih =  " << int2d(Sh)(phih) << " ----------- " << endl; 
mesh Th=square(50,50,[x-0.5,y-0.5]);//buildmesh(cercle(20));

fespace Ph(Th,P0);
fespace Vh(Th,P1);
Ph fh=f;
plot(fh,fill=1,wait=0); //

// the convolution fonction // int fh(x-y) * phih(y) dy 

func real  conv(real a,real b) {  return int2d(Sh)( fh(a-x,b-y)* phih); }


   fh =f;
   Vh  fhc = conv(x,y); // do the interpolation of the convolution fonction (expencive)
   plot(Th,fhc,wait=1);





// Schwarz without overlapping (Shur complement Neumann -> Dirichet)  
//  with matrix ---
//  ------------
verbosity=2;
real cpu=clock();

macro laplacien(u,v) (dx(u)*dx(v)+dy(u)*dy(u)) //

// --- beging  meshes  building --------------
int nbsd=4;
int labext= nbsd+1;
real[int] theta(nbsd+1),cost(nbsd),sint(nbsd);

for (int i=0;i<nbsd;i++)
 {
  real t=i*2*pi/nbsd;
  theta[i]= t;
  theta[i+1]= (i+1)*2*pi/nbsd;
  cost[i]=cos(t);
  sint[i]=sin(t);
 }


border g1(t=0,1){x=cost[0]*t;y=sint[0]*t;label=1;};
border g2(t=0,1){x=cost[1]*t;y=sint[1]*t;label=2;};
border g3(t=0,1){x=cost[2]*t;y=sint[2]*t;label=3;};
border g4(t=0,1){x=cost[3]*t;y=sint[3]*t;label=4;};

border e12(t=theta[0],theta[1]){x=cos(t);y=sin(t);label=labext;};
border e23(t=theta[1],theta[2]){x=cos(t);y=sin(t);label=labext;};
border e34(t=theta[2],theta[3]){x=cos(t);y=sin(t);label=labext;};
border e41(t=theta[3],theta[4]){x=cos(t);y=sin(t);label=labext;};

 int Ng = 10;
 int Ne = 10;

plot(g1(Ng)+g2(Ng)+g3(Ng)+g4(Ng) + e12(Ne) + e23(Ne)+ e34(Ne) + e41(Ne) ,wait=1);

mesh Thf = buildmesh( g1(Ng)+g2(Ng)+g3(Ng)+g4(Ng) + e12(Ne) + e23(Ne)+ e34(Ne) + e41(Ne) );
fespace Phf(Thf,P0);
fespace Vhf(Thf,P1);
Phf reg=region;
int rr1 = 0; 
int rr2 = 1;
int rr3 = 2; 
int rr4 = 3;

func rreg1 = reg==rr1;
func rreg2 = reg==rr2;
func rreg3 = reg==rr3;
func rreg4 = reg==rr4;

Vhf reg1=rreg1, reg2=rreg2, reg3=rreg3, reg4=rreg4;

int[int] ssd(Thf.nt);
for (int i=0;i<Thf.nt;i++)
 ssd[i]=reg[][i];

mesh The = emptymesh(Thf,ssd);
plot(Thf,wait=1);
plot(The,wait=1);

fespace Phe(The,P0); //

Phe rege=reg;
plot(rege,fill=1,wait=1);
fespace Whe(The,P1dc); // espace des multilicateur de Lagrange
fespace Mhe(The,P1); // espace des multilicateur de Lagrange
Whe trace;
Mhe lambda; 
Mhe intern; //  1 if the vertex in internal and 0 if on the real boundary 

intern=  (square(x)+square(y))  < 0.999; 

//   - end of  meshes building  . 
mesh[int] aTh(nbsd);
for (int i=0;i<nbsd;i++)
  aTh[i]=trunc(Thf,region==i);

int i=0;

fespace Xh1(aTh[0],P1);
Xh1 u1,v1,dnu1;

fespace Xh2(aTh[1],P1);
Xh2 u2,v2,dnu2;

fespace Xh3(aTh[2],P1);
Xh3 u3,v3,dnu3;

fespace Xh4(aTh[3],P1);
Xh4 u4,v4,dnu4;

matrix I1=interpolate(Xh1,Mhe); // build interpolation matrix  Mhe -> Xh1
matrix I2=interpolate(Xh2,Mhe); // build interpolation matrix  Mhe -> Xh2
matrix I3=interpolate(Xh3,Mhe); // build interpolation matrix  Mhe -> Xh2
matrix I4=interpolate(Xh4,Mhe); // build interpolation matrix  Mhe -> Xh3

int nm = Mhe.ndof;
real [int]  l1(nm),l2(nm),l3(nm),l4(nm);

func f = (x+1)*(y-2);
varf vgamma(u,v) = on(1,2,3,4,u=1);
Mhe  gamma;
gamma[] = vgamma(0,Mhe,tgv=1);
plot(gamma,wait=1,cmm="gamma",value=1);
varf vM(u,v) =  int1d(The)( u*v) ;
matrix M = vM(Mhe,Mhe,solver=sparsesolver) ;
 
// debut macro par ssd 
macro Pb(A,B,a,P,Th,u1,v1,Xh)
   cout << " -- PB -- " << endl;
  varf a(u1,v1) =   int2d(Th)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  - int2d(Th)( f*v1) ;
problem P(u1,v1,init=i,solver=Cholesky) = 
  int2d(Th)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  - int2d(Th)( f*v1) 
  + on(labext,u1= 0 ) 
  + on(1,2,3,4,u1=lambda)
  ;

matrix A = a(Xh,Xh,solver=GMRES) ;
real[int] B(Xh.ndof);
B=a(0,Xh);

// Fin macro ssd -------


Pb(A1,b1,va1,Pb1,aTh[0],u1,v1,Xh1);
Pb(A2,b2,va2,Pb2,aTh[1],u2,v2,Xh2);
Pb(A3,b3,va3,Pb3,aTh[2],u3,v3,Xh3);
Pb(A4,b4,va4,Pb4,aTh[3],u4,v4,Xh4);


func real[int] BoundaryProblem(real[int] &l)
{
  int vv = verbosity;
  verbosity=0; 
  lambda[]=l;
  Pb1;  dnu1[]= A1*u1[];dnu1[]+=b1;  l1= I1'*dnu1[];
  Pb2;  dnu2[]= A2*u2[];dnu2[]+=b2;  l2= I2'*dnu2[];
  Pb3;  dnu3[]= A3*u3[];dnu3[]+=b3;  l3= I3'*dnu3[];
  Pb4;  dnu4[]= A4*u4[];dnu4[]+=b4;  l4= I4'*dnu4[];
  l1 += l2;
  l1 += l3;
  l1 += l4;
  l1 = l1.* intern[]; 
  cout << " residu = " <<  l1.max << " " << l1.min << endl;
  lambda[]=M*l1;
  plot(lambda,wait=1,cmm="lamdba");
  lambda[]=lambda[].* intern[];
  i++;
  verbosity=vv; 
  return lambda[] ;
};

lambda=0;

Mhe p=0;

verbosity=100;
LinearCG(BoundaryProblem,p[],eps=1.e-6,nbiter=100);
BoundaryProblem(p[]);
plot(u1,u2,u3,u4,wait=1,cmm="u1,u2,u3,u4");
// Parameters
real nu = 1./100.;
real dt = 0.1;

// Mesh
mesh Th = square(8, 8);

// Fespace
fespace Xh(Th, P2);
Xh u1, v1;
Xh u2, v2;
Xh up1, up2;
Xh psi, phi;
fespace Mh(Th, P1);
Mh p, q;

// Problem Stokes (with solve)
real epsr = 1e-8;
solve Stokes ([u1, u2, p], [v1, v2, q])
	= int2d(Th)(
		( dx(u1)*dx(v1) + dy(u1)*dy(v1)
		+ dx(u2)*dx(v2) + dy(u2)*dy(v2) )
		- p*q*epsr
		+ p*dx(v1) + p*dy(v2)
		+ dx(u1)*q + dy(u2)*q
	)
	+ on(3, u1=1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0)
	;

// Plot
plot(coef=0.2, cmm="[u1, u2] and p", p, [u1, u2], ArrowSize=0.5, wait=1);

// Problem stream-lines (with solve)
solve streamlines (psi, phi)
	= int2d(Th)(
		  dx(psi)*dx(phi)
		+ dy(psi)*dy(phi)
	)
	+ int2d(Th)(
		- phi*(dy(u1) - dx(u2))
	)
	+ on(1, 2, 3, 4, psi=0);

// Plot
plot(psi, wait=1);

// Problem Navier-Stokes
int i = 0;
real alpha = 1/dt;
problem NS ([u1, u2, p], [v1, v2, q], init=i)
	= int2d(Th)(
		  alpha*(u1*v1 + u2*v2)
		+ nu * (
			  dx(u1)*dx(v1) + dy(u1)*dy(v1)
			+ dx(u2)*dx(v2) + dy(u2)*dy(v2)
		)
		- p * q * epsr
		+ p*dx(v1) + p*dy(v2)
		+ dx(u1)*q + dy(u2)*q
	)
	+ int2d(Th)(
		- alpha*convect([up1, up2], -dt, up1)*v1
		- alpha*convect([up1, up2], -dt, up2)*v2
	)
	+ on(3, u1=1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0)
	;

for (i = 0; i <= 20; i++) {
	// Update
	up1 = u1;
	up2 = u2;

	// Solve
	NS;

	// Plot
	if (!(i % 10))
		plot(coef=0.2, cmm="[u1, u2] and p", p, [u1, u2]);
}
plot(coef=0.2, cmm="[u1, u2] and p", p, [u1, u2]);

// Re-calculate stream-lines
streamlines;
plot(psi, wait=1);
// This is the rotating hill problem with one turn
// First 1/2 turn is a convection equation and second 1/2 a convection diffusion

// Parameters
int kt = 6;
int kloop = 5;
int nbadap = 5;

bool inq = 0;
real tol = 0.05;
real tol2 = 1e-4;
real dt = 0.17, t = 0;	// time step
int i;

// Mesh
border a(t=0, 2*pi){x=cos(t); y=sin(t);}	// the unit circle
mesh th = buildmesh(a(70));	// triangulates the disk

// Fespace
fespace Vh(th, P1);
Vh u1 = y, u2 = -x;	// rotation velocity
Vh m11 = 0, m22 = 0, m12 = 0;	// to store the metric field
Vh vT;	// to save the initial in big loop
Vh vv, vo, vp;	// working Finite element function
Vh v;

// Functions
func rhill = sqrt((x-0.3)^2 + (y-0.3)^2);
func hill = 1 - tanh(30*(rhill - 0.2));

// Initialization
v = hill;
vp = 0;
plot(v);

// Mesh adaptation loop
for (int i = 0; i < nbadap; i++) {
	th = adaptmesh(th, v, err=tol, inquire=inq);
	v = hill;
	real errl2 = sqrt(int2d(th)(square(vp-v)));
	vp = vp - v;
	cout << "adaptation iteration =" << i << ", l2 error = " << errl2
		<< ", diff min = " << vp[].min << ", max = " << vp[].max << endl
		<< " --------------- " << endl;
	vp = v;
	if (errl2 < tol2) break;
}

// Plot
plot(th, wait=1);

// Initialization
vT[] = v[];

// Solve loop
real error = 0;
for (i = 0; i < 20/kt; i++) {
	real T = t;
	vp = 0;
	for (int k = 0; k < kloop; k++) {
		t = T;	// restart
		v = vT;	// interpolation
		m11 = 0; m22 = 0; m12 = 0;	// reset metric
		adaptmesh(th, v, err=tol, metric=[m11[], m12[], m22[]], nomeshgeneration= true );	// warning change the order in version 1.28

		cout << "m11 = " << m11[].min << " " << m11[].max << endl;
		cout << "m22 = " << m22[].min << " " << m22[].max << endl;
		cout << "m12 = " << m12[].min << " " << m12[].max << endl;

		for (int j = 0; j < kt; j++) {
			t = t+dt;
			vo[] = v[];
			v = convect([u1, u2], -dt, vo);	// convect v by u1,u2, dt seconds, results in f
			plot(v, cmm="convection: t=" + t + ", min=" + v[].min + ", max=" + v[].max, wait=1, dim=3);
			adaptmesh(th, v, err=tol, metric=[m11[], m12[], m22[]], nomeshgeneration= true);
		}
		th = adaptmesh(th, v, err=tol, metric=[m11[], m12[], m22[]]);
		vo = 0;
		plot(th, wait=1, cmm="k=" + k + ", t= " + t + " ,i= " + i);
		real errl2 = sqrt(int2d(th)(square(vp - v)));
		cout << "iteration " << k << ", err l2 = " << errl2 << " --------------- " << endl;
		vp = v;
		error = errl2;
		if (errl2 < tol2) break;
	}
	vT = v;
};

// Plot
plot(th, v, wait=1);
//   example using region keywork
// construct a mesh with 4 regions (sub-domains)
border a(t=0,1){x=t;y=0;};
border b(t=0,0.5){x=1;y=t;};
border c(t=0,0.5){x=1-t;y=0.5;};
border d(t=0.5,1){x=0.5;y=t;};
border e(t=0.5,1){x=1-t;y=1;};
border f(t=0,1){x=0;y=1-t;};
//  internal boundary 
border i1(t=0,0.5){x=t;y=1-t;};
border i2(t=0,0.5){x=t;y=t;};
border i3(t=0,0.5){x=1-t;y=t;};
   
mesh th = buildmesh (a(6) + b(4) + c(4) +d(4) + e(4) + 
    f(6)+i1(6)+i2(6)+i3(6));
fespace Ph(th,P0);
fespace Vh(th,P1);
Ph reg=region;
plot(reg,fill=1,wait=1,value=1,ps="region.eps");
int nupper=reg(0.4,0.9);
int nlower=reg(0.9,0.1);
cout << " nlower " <<  nlower << ", nupper = " << nupper<< endl;
//  defined the characteristics fonctions of upper and lower region
Ph nu=1+5*(region==nlower) + 10*(region==nupper);
if ( nu[].sum < 1) { cout << " Bug in region.edp (bad version try new one)"<< endl; exit(1);}
plot(nu,fill=1,wait=1,value=1,ps="region_nu.eps");
Vh u,v;
solve lap(u,v) =   int2d(th)( nu*(dx(u)*dx(v) +dy(u)*dy(v)))  + int2d(th)(-1*v) + on(a,b,c,d,e,f,u=0);
plot(u,value=1,ps="region_u.eps");

// schwarz1 without overlapping
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, 1){ x= 1-t; y = t;label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
mesh TH = buildmesh ( e(6*n) + e1(25*n) );
plot(th,TH,wait=1,ps="schwarz-no-th.eps");
fespace vh(th,P1);
fespace VH(TH,P1);
vh u=0,v; VH U,V;
vh lambda=0;
int i=0;

problem PB(U,V,init=i,solver=Cholesky) = 
    int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + int2d(TH)( -V) 
  + int1d(TH,inside)(lambda*V) +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(th)( -v) 
  + int1d(th,inside)(-lambda*v) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 20; i++) 
{   
   PB; 
   pb;
   lambda = lambda - (u-U)/2;
//  if (i==0)

    // FFCS: add 3d view
  plot(U,u,wait=true,ps="schwarz-no-u"+i+".eps",dim=3,fill=1);
};

plot(U,u,ps="schwarz-no-u.eps");
// bug  save - restore P2 
verbosity=3;
int nn=2;
mesh Th=square(nn,nn);
savemesh(Th,"Th.msh");
func f=x+y+0.1234567890e-5;
fespace Vh(Th,P2);
Vh u=f;
{ofstream f("u2.txt");
  f.precision; 
 cout << " f.precision() = " << f.precision() << endl;
 f.precision(12);
 cout << " f.precision() = " << f.precision() << endl;

f <<u[];
}
real regtest;//FFCS regression test value
{
mesh Th=readmesh("Th.msh"); // il y a un changement de numerotation des traingle ou??
// mesh Th("Th.msh"); // oK ..
//savemesh(Th,"Th1.msh");
fespace VVh(Th,P2);
VVh u=f,v,e;
ifstream f("u2.txt");
f >> v[] ;
e[] = u[] -v[];
cout << e[].max << " " << e[].min << endl;
plot(e,wait=1,value=1);
assert(e[].max-e[].min < 1e-6);
regtest=e[].max-e[].min;
}

int nn =10;// 10 coubre 

real[int][int] xx(nn);
real[int][int] yy(nn);
real[int][int] zz(nn);
real[int][int] vv(nn);

mesh Th=square(1,1);
fespace Vh(Th,P1);
Vh u=1;

for(int i=0; i<nn; ++i)
{
	int m = 100+i;
	real dm = 1./(m-1);
	xx[i].resize(m);
	yy[i].resize(m);
	zz[i].resize(m);
	vv[i].resize(m);
	real dd = i*pi/nn, cc = 0.5*(4.*nn+i)/(5.*nn);
	real  px =dd; 
	
   for(int j=0; j<m; ++j)
   {
	   
	   xx[i][j] = px;
	   x =  px*4*pi+dd;
	   px += dm; 
	   yy[i][j] = cc*sin(x);
	   zz[i][j] = cos(x)/10+x/10.;
	   vv[i][j] = x;
   }


}

plot([xx,yy],dim=2,cmm="2");
plot([xx,yy,zz],dim=3,cmm="3");
plot([xx,yy,zz,vv],dim=3,cmm="4");
load "msh3"
meshL Th = segment(3);
real [int] vtgv = [ -20,-10,-2,-1,0, tgv]; 
real [int] vsym = [ 0,1]; 
varf va(u,v)= int1d(Th)(u*v*4*9.)+on(1,2,u=0);// mul by 12  to have integer coef ..
// label : 1 on first DoF O 
//         2 on last DoF  2 
// tgv :  -20  set to zero of row and colnum  of Dof with label 1 or 2 
// tgv :  -10  set to zero of row  of Dof with label 1 or 2 
// tgv :  -2   set to zero of row and colnum  of Dof with label 1 or 2 and set one on diagonal term
// tgv :  -1   set to zero of row  of Dof with label 1 or 2 and set one on diagonal term
// tgv >=0     set to tgv  value  on diagonal term of Dof with label 1 or 2 

fespace Vh(Th,P1);
int symj = 0; 
// for [j,symj:vsym]  buggus never get sym matrix .... FH..  
for [i,tgvi:vtgv]
{
	verbosity=9; 
	matrix A= va(Vh,Vh,tgv=tgvi,sym=symj,solver="GMRES");
	real[int,int] F(Vh.ndof,Vh.ndof); // to copy sparse matrix in full matrix ..
	F=0.;  
	for [i,j,aij:A]
	  F(i,j) = aij;
	cout << " sym= " << symj << " tgv =  " << tgvi << "  matrix= " << F << "\n\n\n";
}
 mesh Th=square(10,10);
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 problem laplace(uh,vh,solver=GMRES,tgv=1e5) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  - int1d(Th,1)( vh)
  - int2d(Th)( f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="LaplaceP1.eps",value=true);
mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a paratrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  de  partiel derivatrive of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  // to store the periodic condition 

// the intial mesh
savemesh(Th,"sphere",[f1,f2,f3]);

real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,inquire=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
load "msh3" load "medit" 
//savemesh(Th,"sphere-a",[f1,f2,f3]);
plot(Th,wait=1);
meshS Th3= movemesh23(Th,transfo=[f1,f2,f3]);
plot(Th3,wait=1); 
medit("sphere-a",Th3);// bug un color of u ... FH 

//exec("ffmedit sphere-a");
//ff-mpirun -np 4 Helmholtz_circle_Neumann_all_direct.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"
load "msh3"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Bemkernels
BemKernel SL("SL",k=k);
BemKernel DL("DL",k=k);
BemKernel TDL("TDL",k=k);
BemKernel HS("HS",k=k);
BemKernel CFIE=1i*k*DL+HS;
BemKernel CFIERHS=k*1i*SL+TDL;

// varf
varf vSL(u,v)=int1dx1d(Th)(Th)(BEM(SL,u,v)) ;  
varf vDL(u,v)=int1dx1d(Th)(Th)(BEM(DL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vTDL(u,v)=int1dx1d(Th)(Th)(BEM(TDL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vHS(u,v)=int1dx1d(Th)(Th)(BEM(HS,u,v)) ;  
varf vCFIE(u,v)=int1d(Th)(-1i*k*0.5*u*v)+int1dx1d(Th)(Th)(BEM(CFIE,u,v)) ;  
varf vCFIERHS(u,v)=int1dx1d(Th)(Th)(BEM(CFIERHS,u,v))-int1d(Th)(0.5*u*v) ;  


// hmat
HMatrix<complex> HSecondKindRHS     = vSL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HFirstKindRHS    = vTDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HSecondKind  = vDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HFirstKind = vHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HCFIE = vCFIE(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HCFIERHS = vCFIERHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);


if (mpirank == 0) cout << HFirstKind.infos << endl;
if (mpirank == 0) cout << HSecondKind.infos << endl;
if (mpirank == 0) cout << HFirstKindRHS.infos << endl;
if (mpirank == 0) cout << HSecondKindRHS.infos << endl;


// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind, gN;
gN=-(dxfinc*Tl.y-dyfinc*Tl.x);
bFirstKind[] = HFirstKindRHS*gN[];
bFirstKind[] *=-1; // because we cannot compute I/2-TDL, we computed TDL-I/2...
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = HSecondKindRHS*gN[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = HCFIERHS*gN[];
bCombined[]*=-1;
uCombined[] = HCFIE^-1*bCombined[];
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind1,vFirstKind2;
vFirstKind1[] = HSLPot*gN[];
vFirstKind2[] = HDLPot*uFirstKind[];
vFirstKind1[] += vFirstKind2[]+ vinc[];
UhOut vFirstKindabs = abs(vFirstKind1);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind1,vSecondKind2;
vSecondKind1[] = HSLPot*gN[];
vSecondKind2[] = HDLPot*uFirstKind[];
vSecondKind1[] += vSecondKind2[]+vinc[];
UhOut vSecondKindabs = abs(vSecondKind1);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*gN[];
vCombined2[] = HDLPot*uCombined[];
vCombined1[] += vCombined2[]+ vinc[];
UhOut vCombinedabs = abs(vCombined1);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
//ff-mpirun -np 4 Maxwell_cube_EFIE.edp -wg

// for the make check:
// NBPROC 4
// PARAM -frequency 2.e+8

load "bem"
load "msh3"

include "getARGV.idp"

real c0= 299792458;
real f = getARGV("-frequency",6e+8);
real k = 2*pi*f/c0;
real lambda = c0/f;

cout << "lambda=" << lambda << endl;
// incident wave
real thetaI =  2*pi*0./360.;
real[int] dir=[cos(thetaI),0,sin(thetaI)];

// plane wave polarisation y
func fincx = 0;
func fincy = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));
func fincz = 0;

int nloc = 4./lambda;
mesh3 Th3 = cube(nloc,nloc,nloc,[x-0.5,y-0.5,z-0.5]);

meshS ThS = extract(Th3);

plot(ThS);

macro def(u)[u,u#2,u#3]//

fespace Uh(ThS,RT0S);
Uh<complex> def(u), def(b);

varf vM([u1,u2,u3],[v1,v2,v3]) = int2dx2d(ThS)(ThS)(BEM(BemKernel("MA_SL",k=k),[u1,u2,u3],[v1,v2,v3]));  
HMatrix<complex> H = vM(Uh,Uh,eta=10,eps=1e-3);

if (mpirank == 0) cout << H.infos << endl;
display(H);

varf vrhs(def(u),def(v)) = int2d(ThS)(def(v)'*[-fincx,-fincy,-fincz]);

b[] = vrhs(0,Uh);

// resolution of the courant J
u[] = H^-1*b[];

// computation of the potential to reconstruct E
nloc *= 20;
nloc -= nloc%8;
meshS ThOut = square3(nloc,nloc,[4*(x-0.5),4*(y-0.5),0]);
ThOut = trunc(ThOut, max(abs(x),abs(y)) > 0.5 + 4./nloc);

fespace UhOut(ThOut,[P1,P1,P1]);
 
varf vP([u1,u2,u3],[v1,v2,v3])=int2d(ThS)(POT(BemPotential("MA_SL",k=k),[u1,u2,u3],[v1,v2,v3])) ;
HMatrix<complex> B = vP(Uh,UhOut,eta=10,eps=1e-3);

if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> [Ex,Ey,Ez];

Ex[] = B*u[];

fespace UhOutP1(ThOut,P1);
UhOutP1 Etotalr = sqrt(real(Ex+fincx)^2+ real(Ey+fincy)^2 + real(Ez+fincz)^2);

plot(Etotalr, dim=2, fill=1, value=1, nbiso=20);
//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling-MUMPS-composite.edp -wg

// for the make check:
// NBPROC 4
// PARAM -nlenses 1 -Rout 5

/* example of wave guiding with gradient-index lenses */

load "bem"
load "msh3"
load "MUMPS"

include "getARGV.idp"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int nlenses = getARGV("-nlenses",10); // number of lenses
int[int] nsl(nlenses);
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

// Fem mesh :
mesh Th = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l)+circle(nsl));

plot(Th, wait=1, dim=2, cmm="FEM mesh Th");

int[int] lab = [interface];
meshL ThL = extract(Th, label=lab); // BEM mesh
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL, wait=1, dim=2, cmm="BEM mesh ThL");

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);
reg = region;

func ind = reg == -1 ? 1 : 2./(1+((x-nsx[max(0.,reg-1)])^2+(y-nsy[max(0.,reg-1)])^2)); // gradient index in lenses

fespace Uh(Th,P1);
fespace UhL(ThL,P1);

macro Grad(u) [dx(u),dy(u)] // EOM

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (Frhs)
(  mass  -SL ) (ubem)   ( 0  ) */

Uh<complex> ufem,v1;
UhL<complex> ubem,v2;

// problem formulation ; the linear system is assembled in parallel and solved in a distributed way with MUMPS
problem pbLenses(<[ufem],[ubem]>,<[v1],[v2]>,solver=sparsesolver,master=-1) =
                                int2d(Th)(-ind*k^2*ufem*v1 + Grad(ufem)'*Grad(v1)) // F
                              + int1dx1d(ThL)(ThL)(BEM(BemKernel("TDL",k=k),ubem,v1)) + int1d(ThL)(0.5*ubem*v1) // TDL
                              + int1d(ThL)(ufem*v2)                        // mass
                              + int1dx1d(ThL)(ThL)(BEM(-1*BemKernel("SL",k=k),ubem,v2))  // -SL
                              - int2d(Th)(finc*v1) + on(waveguide,ufem=0); // RHS

pbLenses;

plot(ufem, fill=1, value=1, wait=1, dim=2, cmm="FEM solution");
plot(ubem, fill=1, value=1, wait=1, dim=2, cmm="BEM ansatz on ThL");

// output mesh for visualization
int np = 5;
real R = getARGV("-Rout",20.);
real rr = R;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R)+b2(np*rr)+b3(np*R)+b4(np*rr)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(UhL,UhOut);
if (mpirank == 0) cout << B.infos << endl;

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40, cmm="u");
//ff-mpirun -np 4 Helmholtz_circle_Dirichlet_all_indirect.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"
load "msh3"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Hmatrix for formulation of first kind
BemKernel ker1("SL",k=k);
varf vk1(u,v)=int1dx1d(Th)(Th)(BEM(ker1,u,v)) ;  
HMatrix<complex> HFirstKind = vk1(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << HFirstKind.infos << endl;
display(HFirstKind);

// Hmatrix for formulation of second kind
BemKernel ker2("DL",k=k);
varf vk2(u,v)=int1dx1d(Th)(Th)(BEM(ker2,u,v)) + int1d(Th)(0.5*u*v);  

HMatrix<complex> HSecondKind = vk2(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << HSecondKind.infos << endl;
display(HSecondKind);

// Hmatrix for combined formulation
BemKernel ker5=-1i*k*ker1+ker2;
varf vk3(u,v)=int1dx1d(Th)(Th)(BEM(ker5,u,v)) + int1d(Th)(0.5*u*v); 

HMatrix<complex> HCombined = vk3(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HCombined.infos << endl;
display(HCombined);


// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind;
varf vmassFirstKind(u,v) = int1d(Th)(-(finc)*v);
bFirstKind[] = vmassFirstKind(0,Uh);
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = bFirstKind[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = bFirstKind[];
uCombined[] = HCombined^-1*bCombined[];
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind;
vFirstKind[] = HSLPot*uFirstKind[];
vFirstKind[] += vinc[];
UhOut vFirstKindabs = abs(vFirstKind);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind;
vSecondKind[] = HDLPot*uSecondKind[];
vSecondKind[] += vinc[];
UhOut vSecondKindabs = abs(vSecondKind);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*uCombined[];
vCombined2[] = HDLPot*uCombined[];
UhOut vCombinedabs = abs(-1i*k*vCombined1+vCombined2+vinc);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
/*
time convention exp(-iwt).
solving EFIE for Maxwell with a incoming plane wave.

The polarization is such that:
\vec{k} = ( 0, 0, -k_z)^t (the wave vector), E_{inc}  =( E_x, 0, 0)^t \quad \mathtt{and}  \quad  H_{inc}=( 0, H_y, 0)^t

mpirun -np 2 ../../src/mpi/FreeFem++-mpi Maxwell_EFIE_sphere.edp -wg -frequency 6e8
*/

//load "msh3"
load "bem"
load "PETSc-complex"
include "getARGV.idp"


real c0= 299792458;
real f = getARGV("-frequency",6.e+8);
complex k = 2*pi*f/c0;
real mu0 = 4*pi*1.e-7;
real epsilon0 = 1./(c0*c0*mu0);
real Z0 = 119.9169832*pi;
real lambda = c0/f;

cout << "wave number   = " <<lambda << endl;
cout << "vacuum impedance = " <<Z0 << endl;
cout << "frequency = " << f << endl;

string testcase = "sphere";
meshS ThS;
meshS ThOut;

int nlambda = 4;                // number of wave lenght 

if( testcase == "sphere"){
    // definition of the surface mesh 
    include "MeshSurface.idp"
    real radius = 1;
    real hs = lambda/(1.0*nlambda); // mesh size on the sphere
    ThS = Sphere(radius,hs,7,1); 

    // definition of the mesh for the potentiel view
    real Rin = radius*1.05;
    real Rout = radius*1.5;

    int Nin = nlambda*40;
    int Nout = Nin*int(Rout/Rin+1);

    border circleS(t=0, 2*pi){x=Rin*cos(t); y=Rin*sin(t); z=0;}
    border circleOut(t=0, 2*pi){x=Rout*cos(t); y=Rout*sin(t); z=0;}
    mesh Thtmp = buildmesh( circleS(-Nin) + circleOut(Nout) );

    ThOut = movemesh23(Thtmp, transfo=[x,y,0]);
}
else if( testcase == "cube" ){
    int nloc = (1.0*nlambda)/lambda;
    mesh3 Th3 = cube(nloc,nloc,nloc,[x-0.5,y-0.5,z-0.5]);
    ThS = extract(Th3);

    real xout = 3.0; 
    int nlocOut = 5.0*(xout/lambda)*nlambda;
    real dxout = xout/nlocOut;
    ThOut = square3(nlocOut,nlocOut,[xout*(x-0.5),xout*(y-0.5),0]);
    ThOut = trunc(ThOut, max(abs(x),abs(y)) > 0.5 + dxout);
}
else{
    cout << "error in the choice of the test case" <<endl;
    exit(0);
}

// definition of the wave plane
// ========
//   E_inc = \vec{u}*exp(i*\vec{k}.\vec{x})
//
//   where \vec{k} =  k*\vec{dir}
//         \vec{dir} : direction of propagation
//         \vec{u} : polarization
// ========
real[int] dir(3), u(3);

if( testcase == "sphere"){
dir[0] =  0;
dir[1] =  0;
dir[2] = -1;

u[0] = 1;
u[1] = 0;
u[2] = 0;
}else if( testcase == "cube"){
dir[0] = 1;
dir[1] = 0;
dir[2] = 0;

u[0] = 0;
u[1] = 1;
u[2] = 0;
}

func uinc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));
func fincx = u[0]*uinc;
func fincy = u[1]*uinc;
func fincz = u[2]*uinc;
// ================================

// definition of fespace for EFIE 
fespace Uh3(ThS,RT0S);

Uh3<complex> [Fincx,Fincy,Fincz] = [uinc*u[0],uinc*u[1],uinc*u[2]]; // wave plane discretization
Uh3<complex> [mcx,mcy,mcz];  // FE function for magnetic current

BemKernel KerMA("MA_SL",k=k);
// construction of BEM H-matrix for EFIE operator
varf vEFIE([u1,u2,u3],[v1,v2,v3])=int2dx2d(ThS)(ThS)(BEM(KerMA,[u1,u2,u3],[v1,v2,v3]));    
HMatrix<complex> H = vEFIE(Uh3,Uh3,eta=10,eps=1e-2,minclustersize=10,maxblocksize=1000000,nbiter=4000);

if (mpirank == 0) cout << H.infos << endl;
display(H);



// computation of rhs of EFIE 
Uh3<complex> [rhsx,rhsy,rhsz]; // FE function for rhs
varf vrhs([u1,u2,u3],[v1,v2,v3]) = -int2d(ThS)( [v1,v2,v3]'*[Fincx,Fincy,Fincz] );
rhsx[] = vrhs(0,Uh3);

// solving magnetic current
mcx[] = H^-1*rhsx[];

fespace UhOutV(ThOut,[P1,P1,P1]);
// FE function of the scattered field E
UhOutV<complex> [Ex, Ey, Ez];

// Maxwell potentiel corresponding to EFIE for electromagnetic field
BemPotential PotMA("MA_SL", k=k);

varf vpotMA([u1,u2,u3],[v1,v2,v3])=int2d(ThS)(POT(PotMA,[u1,u2,u3],[v1,v2,v3]));
HMatrix<complex> HpotMA = vpotMA(Uh3,UhOutV,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HpotMA.infos << endl;
display(HpotMA);

// compute the scattered electromagnetic field
Ex[]  = HpotMA*mcx[];

fespace UhOut(ThOut,P1);
// save the real part of scattered electromagnetic field
UhOut rExScat = real(Ex);

// compute the real part of total electromagnetic field
UhOut vr = sqrt(real(Ex)^2 + real(Ey)^2 + real(Ez)^2 );

plot(vr, dim=2, fill=1, value=1, nbiso=20, cmm="|E-real|_L2");

// compute the real part of total electromagnetic field
UhOut rEx = real(Ex)+real(fincx);
UhOut rEy = real(Ey)+real(fincy);
UhOut rEz = real(Ez)+real(fincz);

plot(rEx, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ex) total",ps="MaxwellSphereRealEx.ps");
plot(rExScat, dim=2, fill=1, value=1, nbiso=20, cmm="real(ExScat)",ps="MaxwellSphereRealScatterEx.ps");
plot(rEy, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ey) total",ps="MaxwellSphererRealEy.ps");
plot(rEz, dim=2, fill=1, value=1, nbiso=20, cmm="real(Ez) total",ps="MaxwellSphererRealEz.ps");

//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling-MUMPS.edp -wg

// for the make check:
// NBPROC 4
// PARAM -nlenses 1 -Rout 5

/* example of wave guiding with gradient-index lenses */

load "bem"
load "msh3"
load "MUMPS"

include "getARGV.idp"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int nlenses = getARGV("-nlenses",10); // number of lenses
int[int] nsl(nlenses);
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

// Fem mesh :
mesh Th = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l)+circle(nsl));

plot(Th, wait=1, dim=2, cmm="FEM mesh Th");

int[int] lab = [interface];
meshL ThL = extract(Th, label=lab); // BEM mesh
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL, wait=1, dim=2, cmm="BEM mesh ThL");

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);
reg = region;

func ind = reg == -1 ? 1 : 2./(1+((x-nsx[max(0.,reg-1)])^2+(y-nsy[max(0.,reg-1)])^2)); // gradient index in lenses

fespace Uh(Th,P1);
fespace UhL(ThL,P1);

macro Grad(u) [dx(u),dy(u)] // EOM

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (Frhs)
(  mass  -SL ) (ubem)   ( 0  ) */

// assemble SL BEM block :
varf SL(u,v) = int1dx1d(ThL)(ThL)(BEM(BemKernel("SL",k=k),u,v));
HMatrix<complex> HSL = SL(UhL,UhL);
if (mpirank == 0) cout << HSL.infos << endl;
display(HSL, wait=1);

// assemble TDL BEM block :
varf TDL(u,v) = int1d(ThL)(0.5*u*v) + int1dx1d(ThL)(ThL)(BEM(BemKernel("TDL",k=k),u,v));
HMatrix<complex> HTDL = TDL(UhL,UhL);
if (mpirank == 0) cout << HTDL.infos << endl;

// assemble Helmholtz FEM block :
Th=change(Th,fregion = nuTriangle%mpisize); // for parallel assembly 
varf F(u,v) = int2d(Th,mpirank)((-ind*k^2*u*v+Grad(u)'*Grad(v))) + on(waveguide,u=0);
matrix<complex> mF = F(Uh,Uh);

matrix Rr = interpolate(UhL,Uh);
matrix<complex> Rc = Rr;

// assemble mass block, only on rank 0 :
varf mass(u,v) = int1d(Th,interface)(u*v);
matrix<complex> mmass(UhL.ndof, Uh.ndof);
if (mpirank == 0) {
  mmass = mass(Uh,Uh,solver=GMRES);
  mmass = Rc*mmass;
}

complex[int,int] MSL(UhL.ndof,UhL.ndof);
MSL = HSL; // each MPI process densifies its part of HMatrix HSL
MSL *= -1;
complex[int,int] MTDL(UhL.ndof,UhL.ndof);
MTDL = HTDL; // each MPI process densifies its part of HMatrix HTDL
matrix<complex> mTDL = MTDL;
mTDL = Rc'*mTDL;

matrix<complex> A = [[mF,mTDL],[mmass,MSL]];

// compute factorization of distributed matrix A in parallel with MUMPS
set(A,solver=sparsesolver,master=-1);

// assemble FEM rhs
varf FHrhs(u,v) = int2d(Th,mpirank)(finc*v) + on(waveguide,u=0);
complex[int] rhs(Uh.ndof+UhL.ndof);
rhs(0:Uh.ndof-1) = FHrhs(0,Uh);

complex[int] u(Uh.ndof+UhL.ndof);

u = A^-1*rhs;

Uh<complex> ufem;
ufem[] = u(0:Uh.ndof-1);

UhL<complex> ubem;
ubem[] = u(Uh.ndof:u.n-1);

plot(ufem, fill=1, value=1, wait=1, dim=2, cmm="FEM solution");
plot(ubem, fill=1, value=1, wait=1, dim=2, cmm="BEM ansatz on ThL");

// output mesh for visualization
int np = 5;
real R = getARGV("-Rout",20.);
real rr = R;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R)+b2(np*rr)+b3(np*R)+b4(np*rr)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(UhL,UhOut);
if (mpirank == 0) cout << B.infos << endl;

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40, cmm="u");
//ff-mpirun -np 4 Helmholtz_circle_Neumann_all_indirect.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"
load "msh3"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Hmatrix for formulation of first kind
BemKernel ker1("HS",k=k);
varf vk1(u,v)=int1dx1d(Th)(Th)(BEM(ker1,u,v)) ;  
HMatrix<complex> HFirstKind = vk1(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << HFirstKind.infos << endl;
display(HFirstKind);

// Hmatrix for formulation of second kind
BemKernel ker2("TDL",k=k);
varf vk2(u,v)=int1dx1d(Th)(Th)(BEM(ker2,u,v)) + int1d(Th)(0.5*u*v);  

HMatrix<complex> HSecondKind = vk2(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << HSecondKind.infos << endl;
display(HSecondKind);

// Hmatrix for combined formulation
BemKernel ker5=(-1i*k)*ker2+ker1;
varf vk3(u,v)=int1dx1d(Th)(Th)(BEM(ker5,u,v)) +int1d(Th)((-1i*k)* 0.5*u*v); 

HMatrix<complex> HCombined = vk3(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << HCombined.infos << endl;
display(HCombined);


// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind;
varf vmassFirstKind(u,v) = -int1d(Th)((dxfinc*Tl.y-dyfinc*Tl.x)*v);// change New Nt -> Tl (the tangent to Curve Nt^ortho == Tl )
bFirstKind[] = vmassFirstKind(0,Uh);
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = bFirstKind[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = bFirstKind[];
uCombined[] = HCombined^-1*bCombined[];
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind;
vFirstKind[] = HDLPot*uFirstKind[];
vFirstKind[] += vinc[];
UhOut vFirstKindabs = abs(vFirstKind);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind;
vSecondKind[] = HSLPot*uSecondKind[];
vSecondKind[] += vinc[];
UhOut vSecondKindabs = abs(vSecondKind);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*uCombined[];
vCombined2[] = HDLPot*uCombined[];
UhOut vCombinedabs = abs(-1i*k*vCombined1+vCombined2+vinc);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
//ff-mpirun -np 4 Helmholtz_circle_Dirichlet_all_direct.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 2

load "bem"
load "msh3"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

// Bemkernels
BemKernel SL("SL",k=k);
BemKernel DL("DL",k=k);
BemKernel TDL("TDL",k=k);
BemKernel HS("HS",k=k);
BemKernel CFIE=k*1i*SL+TDL;
BemKernel CFIERHS=1*k*1i*DL+HS;

// varf
varf vSL(u,v)=int1dx1d(Th)(Th)(BEM(SL,u,v)) ;  
varf vDL(u,v)=int1dx1d(Th)(Th)(BEM(DL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vTDL(u,v)=int1dx1d(Th)(Th)(BEM(TDL,u,v))-int1d(Th)(0.5*u*v) ;  
varf vHS(u,v)=int1dx1d(Th)(Th)(BEM(HS,u,v)) ;  
varf vCFIE(u,v)=int1dx1d(Th)(Th)(BEM(CFIE,u,v))+int1d(Th)(-0.5*u*v) ;  
varf vCFIERHS(u,v)=int1d(Th)(-1i*k*0.5*u*v)+int1dx1d(Th)(Th)(BEM(CFIERHS,u,v)) ;  

// hmat
HMatrix<complex> HFirstKind     = vSL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HSecondKind    = vTDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HFirstKindRHS  = vDL(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HSecondKindRHS = vHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HCFIE = vCFIE(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
HMatrix<complex> HCFIERHS = vCFIERHS(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);


if (mpirank == 0) cout << HFirstKind.infos << endl;
if (mpirank == 0) cout << HSecondKind.infos << endl;
if (mpirank == 0) cout << HFirstKindRHS.infos << endl;
if (mpirank == 0) cout << HSecondKindRHS.infos << endl;
// if (mpirank == 0) cout << HCFIE.infos << endl;
// if (mpirank == 0) cout << HCFIERHS.infos << endl;

// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind, gd;
gd=-finc;
bFirstKind[] = HFirstKindRHS*gd[];
bFirstKind[]*=-1; // because we cannot compute I/2-DL, we compute DL-I/2...
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Solve formulation of second kind 
Uh<complex> uSecondKind, bSecondKind;
bSecondKind[] = HSecondKindRHS*gd[];
uSecondKind[] = HSecondKind^-1*bSecondKind[];
plot(uSecondKind,dim=2,nbiso=20,value=1,cmm="Second kind");

// Solve combined formulation
Uh<complex> uCombined, bCombined;
bCombined[] = HCFIERHS*gd[];
uCombined[] = HCFIE^-1*bCombined[];
uCombined[] *=-1;
plot(uCombined,dim=2,nbiso=20,value=1,cmm="Combined");


// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for single layer potential
BemPotential SLPot("SL",k=k);
varf vpSL(u,v)=int1d(Th)(POT(SLPot,u,v)) ;  
HMatrix<complex> HSLPot = vpSL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HSLPot.infos << endl;
display(HSLPot);

// HMatrix for double layer potential
BemPotential DLPot("DL",k=k);
varf vpDL(u,v)=int1d(Th)(POT(DLPot,u,v)) ;  
HMatrix<complex> HDLPot = vpDL(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HDLPot.infos << endl;
display(HDLPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind1,vFirstKind2;
vFirstKind1[] = HSLPot*uFirstKind[];
vFirstKind2[] = HDLPot*gd[];
vFirstKind1[] += vFirstKind2[]+ vinc[];
UhOut vFirstKindabs = abs(vFirstKind1);

plot(vFirstKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="First kind");

// Solution for formulation of second kind
UhOut<complex> vSecondKind1,vSecondKind2;
vSecondKind1[] = HSLPot*uFirstKind[];
vSecondKind2[] = HDLPot*gd[];
vSecondKind1[] += vSecondKind2[]+vinc[];
UhOut vSecondKindabs = abs(vSecondKind1);

plot(vSecondKindabs, dim=1, fill=1, value=1, nbiso=20,cmm="Second kind");

// Solution for combined formulation
UhOut<complex> vCombined1,vCombined2;
vCombined1[] = HSLPot*uCombined[];
vCombined2[] = HDLPot*gd[];
vCombined1[] += vCombined2[]+ vinc[];
UhOut vCombinedabs = abs(vCombined1);

plot(vCombinedabs, dim=1, fill=1, value=1, nbiso=20,cmm="Combined");
//ff-mpirun -np 4 Helmholtz_Cobracavity.edp -wg

// for the make check:
// NBPROC 4
// PARAM

load "bem"
load "msh3"

include "getARGV.idp"

include "cobrameshcavity.idp"

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",3.e+9);
complex k = 2*pi*f/c0;
real lambda = c0/f;

real distx = 0.2*lambda;
real disty = distx;
real distz = distx;

int labextxm = 11, labextxM = 12, labextym = 13, labextyM = 14, labextzm = 15, labextzM = 16;
int regint = 4, regext = 5;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

// incident wave
real[int] dir=[1,0,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));

int nloc = 10.*sec3/lambda;

mesh3 Th3;
buildcobramesh(Th3);
Th3 = buildBdMesh(Th3);

meshS ThS = Th3.Gamma;
ThS = trunc(ThS, region==labmetal);

plot(ThS);

fespace Uh(ThS,P1);

cout << "ndof = " << Uh.ndof << endl;

//BemKernel ker("SL",k=k);
varf vk(u,v)=int2dx2d(ThS)(ThS)(BEM(BemKernel("SL",k=k),u,v)) ;  
HMatrix<complex> H = vk(Uh,Uh,eta=10,eps=1e-2,minclustersize=10,maxblocksize=1000000);
//HMatrix<complex> H = assemblecomplexHESL(Uh,Uh,k,eta=10,epsilon=1e-2,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << H.infos << endl;
display(H);

Uh<complex> u, b, uinc = -finc;

varf vmass(u,v) = int2d(ThS)(u*v);
matrix<complex> M = vmass(Uh,Uh,solver=CG);

b[] = M*uinc[];

u[] = H^-1*b[];

// output visu
distx = 2*lambda;
disty = distx;
distz = distx;

int np = 100;
meshS ThOut = square3(np,np,[(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3+2*distx)*x
                               -distx,
                               (height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))*y
                               +(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,
                               width/2]);

fespace UhOut(ThOut,P1);

//BemPotential Pot("SL",k=k);
varf vp(u,v)=int2d(ThS)(POT(BemPotential("SL",k=k),u,v)) ;  
HMatrix<complex> B = vp(Uh,UhOut,eta=10,eps=1e-2,minclustersize=10,maxblocksize=1000000);

//HMatrix<complex> B = assemblecomplexHESLPot(Uh,UhOut,k,eta=10,epsilon=1e-2,minclustersize=10,maxblocksize=1000000);


if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = real(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);
//ff-mpirun -np 4 Helmholtz_circle_Dirichlet_simple.edp -wg

// for the make check:
// NBPROC 4
// PARAM -k 1

/*
    This example solves the Dirichlet scattering problem with an indirect formulation of the first kind.
    You can find an overview of all standard direct and indirect BEM formulations for Dirichlet
    and Neumann problems in Helmholtz_circle_Dirichlet_all_direct.edp, Helmholtz_circle_Dirichlet_all_indirect.edp,
    Helmholtz_circle_Neumann_all_direct.edp and Helmholtz_circle_Neumann_all_indirect.edp
*/

load "bem"
load "msh3"
load "gsl"

include "getARGV.idp"

complex k = getARGV("-k",10.); // wavenumber

// incident wave
real angle = 0;
func finc = exp(-1i*k*(x*cos(angle)+y*sin(angle)));

//  Mesh
int n = 100;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

// Dof
fespace Uh(Th,P1);

real Robj = 1;
func complex exactsol(real xi, real yi){
    real r = sqrt(xi^2 + yi^2);
    real theta = atan2(yi,xi);
    complex value = 0;
    for (int n=0;n<100;n++){
        real JnAtr    = gslsfbesselJn(n,real(k)*r);
        real YnAtr    = gslsfbesselYn(n,real(k)*r);
        real JnAtRobj = gslsfbesselJn(n,real(k)*Robj);
        real YnAtRobj = gslsfbesselYn(n,real(k)*Robj);
        value+=2*(-1*JnAtRobj*(JnAtr+1i*YnAtr)/(JnAtRobj+1i*YnAtRobj))*exp(-1i*n*pi/2.)*cos(n*(theta-angle));
        if (n==0){
            value*=0.5;
        }
    }
    return value;
}

// Hmatrix for formulation of first kind
BemKernel ker1("SL",k=k);
varf vk1(u,v)=int1dx1d(Th)(Th)(BEM(ker1,u,v));
HMatrix<complex> HFirstKind = vk1(Uh,Uh,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);
if (mpirank == 0) cout << HFirstKind.infos << endl;
display(HFirstKind);

// Solve formulation of first kind
Uh<complex> uFirstKind, bFirstKind;
varf vmassFirstKind(u,v) = int1d(Th)(-(finc)*v);
bFirstKind[] = vmassFirstKind(0,Uh);
uFirstKind[] = HFirstKind^-1*bFirstKind[];
plot(uFirstKind,dim=2,nbiso=20,value=1,cmm="First kind");

// Mesh output
int R = 4;
int np = 5*R*real(k);

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

// Incident wave in volume
fespace UhOut(ThOut,P1);
UhOut<complex> vinc;
vinc = finc;

// HMatrix for potential
BemPotential Pot("SL",k=k);
varf vp(u,v)=int1d(Th)(POT(Pot,u,v));
HMatrix<complex> HPot = vp(Uh,UhOut,eta=10,eps=1e-3,minclustersize=10,maxblocksize=1000000);

if (mpirank == 0) cout << HPot.infos << endl;
display(HPot);

// Solution for formulation of first kind
UhOut<complex> vFirstKind, exacti = 0, exact;

// Compare to the exact solution:
for [i, bi : exacti[]]
if (i >= mpirank*ceil(1.*UhOut.ndof/mpisize) && i < (mpirank+1)*ceil(1.*UhOut.ndof/mpisize))
    bi = exactsol(ThOut(i).x,ThOut(i).y);
mpiReduce(exacti[],exact[],processor(0,mpiCommWorld),mpiSUM);

exact = exact + finc;

vFirstKind[] = HPot*uFirstKind[];
vFirstKind[] += vinc[];

UhOut<complex> diff = exact-vFirstKind;
if (mpirank == 0) cout << "relative L2 error = " << diff[].l2/exact[].l2 << endl;

plot(vFirstKind, dim=1, fill=1, value=1, nbiso=20,cmm="u");
plot(exact, dim=1, fill=1, value=1, nbiso=20,cmm="u exact");
plot(diff, dim=1, fill=1, value=1, nbiso=20,cmm="error");
load "msh3"

int n=2;
meshL Th1 = segment(n);
meshL Th2 = segment(n,[0,x,0],orientation=1);
meshL Th3 = segment(n,[x,0,1],orientation=1);
meshL Th4 = segment(n,[0,0,x],orientation=-1);

meshL Th = Th1+Th2+Th3+Th4;
cout << "test nv: " << Th.nv << " nt: " << Th.nt << " nbe: "<< Th.nbe << endl;
Th=rebuildBorder(Th, angle=pi/2.+0.0001);
cout << "rebuildBorder test nv: " << Th.nv << " nt: " << Th.nt << " nbe: "<< Th.nbe << endl;

plot(Th);

meshL[int] Thglue(4);
Thglue[0] = Th1;
Thglue[1] = Th2;
Thglue[2] = Th3;
Thglue[3] = Th4;
plot(Thglue[0],Thglue[1],Thglue[2],Thglue[3]);
meshL Thglued = gluemesh(Thglue);
plot(Thglued,cmm="2");
load "msh3" 

// c0 lap u + c1 u = f 
// CL u|x=0 = 0
// f = g
// time scheme backward euler 
// [ c0 masse + c1 rigidity ] u^n = fv + rho*epsilon/tau masse  V^n-1
// + [ rho*epsilon/dt^2*(1 + dt alpha) masse + beta*\lambda1/tau rigidity ] u^{n-1}

 
// parameters
real density = 1.1, young = 0.75e6, poisson = 0.5, thickness = 0.1;
real alpha = 0., beta = 0; //(coeff rayleigh)
real dt = 0.0001, iMax = 100.;
//real tgv = 1e30; // a hude value of exact penalisation of boundary condition

func h= sin(pi*x);

real lambda0 = young*thickness/(0.25*(1-poisson*poisson)); 
real lambda1 = young*thickness/(2.*(1.+poisson));   
real c0 = density*thickness/(dt*dt)+lambda0+alpha*density*thickness/dt;
real c1 = lambda1+beta*lambda1/dt;
real a = density*thickness*(1.+dt*alpha)/(dt*dt);
real b = density*thickness/dt;

macro Grad(u) [dx(u),dy(u),dz(u)]  // EOM

// string mesh 
meshL Th=Sline(100,[2.*x,y,z]);
savemesh(Th,"ThL.mesh");
// FE space
fespace Uh(Th,P1);
Uh u, v, V, uold ;
V=0;uold=0;

func g=1000.; //x^2;//; //10000.
// c0 * mass matrix + c1 stifness matrix
varf m(u,v) = int1d(Th) (u*v);
varf k(u,v) = int1d(Th) (Grad(u)'*Grad(v));
varf mmkk(u,v) = int1d(Th) (c0*u*v + c1*Grad(u)'*Grad(v)) + on(1,u=0);
varf cl(u,v) = on(1,u=0);

matrix mass=m(Uh,Uh);
matrix stifness=k(Uh,Uh);
matrix mk = mmkk(Uh,Uh); //,tgv=tgv,solver="SPARSESOLVER");

varf f(u,v) = int1d(Th)(g*v);
real[int] Force=f(0,Uh);
real[int] CL=cl(0,Uh);
matrix T = a*mass + (beta*lambda1/dt)*stifness;  

//initial condition
u[] = 0;
  
meshL Thmv;
real t=dt;

for (int i=0; i<=iMax; i++) {
	   V[]=(u[]-uold[]);
	   V[]/=dt; 
	   uold[]=u[];
	   //  for the time dependant part
	   real[int] rhs = mass*V[];  	   
	   rhs *= b;
	   rhs += CL;
	   rhs += T*uold[];
	   // apply the external force
	   if( ( t> 0.004 && t<0.008 ) || (t>0.02 && t<0.03)) 
	   		rhs+=Force;
	   u[] = mk^-1*rhs;
	   t+=dt;
	   // coeff for the visu
	   real coeff=100;
	   Thmv=movemesh(Th,[x,y,u*coeff]);
	   if (verbosity)
	   		cout << " time " << t << " u min "<< u[].min << " u max " << u[].max << endl;
       plot(Th, Thmv, wait=0, cmm=" d = "+t+" iter = "+i,prev=1);


    }

load "msh3"

meshL Th=Sline(4);

  // --------- new stuff -----------------
  int k=0,l=1,e=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int i=0;i<Th.nv;++i)
  cout << i << " : "  << Th(i).x << " "<< Th(i).y << " " << Th(i).z  << endl; 
 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) 
	 << " , label/ region  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<2;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0]    << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 


load "msh3"
load "medit"

int n=10;

int[int] labs = [1, 2, 2, 1, 1, 2]; // Label numbering
mesh3 Th = cube(n, n, n, label=labs);
// extract the surface (boundary) of the cube
int[int] llabs = [1]; 
meshS ThS = extract(Th,label=llabs);
ThS = buildBdMesh(ThS);
meshL ThL= ThS.Gamma;
assert(ThL.nv==88); 
assert(ThL.nt==90);
assert(ThL.nbe==7);

plot(ThL, wait=1);

savemesh(ThL, "testL.mesh");
meshL ThL2=Sline(10);
medit("ThL2",ThL2);
load "msh3" 
 
meshL ThL3=Sline(40,[x,1,x*0.1]);
real[int] bb(6);
boundingbox(ThL3,bb);
cout << bb << endl; 
fespace Vh(ThL3,P2);
Vh p2=x*x+2*x*z+3*z*(z-1);
cout << " dxx "<< dxx(p2)(0.5,0,0.5) << endl; 
cout << " dxz "<< dxz(p2)(0.5,0,0.5) << endl; 
cout << " dzz "<< dzz(p2)(0.5,0,0.5) << endl; 

func f = 1 ;
macro Grad3(uh) [dx(uh),dy(uh),dz(uh)]  // EOM

Vh uLPb,vLPb;

// with problem
problem Lap3dL(uLPb,vLPb)  = int1d(ThL3)(Grad3(uLPb)'*Grad3(vLPb))
 - int1d ( ThL3 ) ( f * vLPb )
  + on(1,uLPb=0);
Lap3dL;
// verif.
cout << " len ThL3 = "<< int1d(ThL3)(1.) << endl; 
// P=[0.5,1,0.05]; to do

real uP=uLPb(0.5,1,0.05);

Vh uex = cos(x) * cosh(y) + sin(x) * sinh(y);
Vh vn = (1 - x) * uex(0,1,0) + x * uex(1,1,0) +4;

cout << nuTriangle<< endl; 
cout << uP << " " << " ~ " << uLPb[][40]<< endl;
// cout << uLPb(0.5,1,0.05) << endl; // to do also ..
cout << ThL3.mesure << endl; 
Vh u1=dx(uLPb),u2=dy(uLPb),u3=dz(uLPb);

plot(ThL3,uLPb);
load "msh3"
//
// Problem definition
//
//1d pde on the boundary term       u_t=e*u_{xx}   0<x<1
//                                  u(0,x)=1-2*(t-1/2)*sign(t-1/2)
//                                  u(t,0)=0,u(t,1)=0

// Technical data to recreate OX and OY axis
//
border OX(t=0,1){x=t;y=0;} 
border OY(t=-1,1){x=0;y=t;}

int m=100; // grid points on x-interval [0,1]
real h=1./m;

meshL Th=segment(m);

plot(Th, cmm="NO ADAPTED MESH ",wait=0);//,ps="reactiondiffusionnoadapted2dmesh.eps");
fespace Uh(Th,P1);
 
// Initial data
func real u0(real t) 
{
return sin(4*pi*t);
}

 
Uh S, uold0,uold1,unew;

uold0=u0(x);// Step cero
uold1=uold0; // Step one

real dt=0.01;
real T=1; // tempo di uscita
real t=0;  // velocita iniziale
real c=1400; // Speed of propagation
real L=1000; // Speed of propagation


real ratio = 0.5*dt^2*c^2/L^2;

varf mat(u,v)= int1d(Th)(u*v+ratio*dx(u)*dx(v))+on(1,2,u=0); 

varf rhs(u,v)= int1d(Th)((2*uold1-uold0)*v
                          -ratio*dx(uold0)*dx(v)+0*v)+on(1,2,u=0);


matrix A=mat(Uh,Uh);
real[int] b=rhs(0,Uh);

real maximum=0.0;

// time loop
for (t=0;t<T; t+=dt) { 

S[]=A^-1*b;
meshL Thmv=movemesh(Th,[x,y+S*0.3]);
plot(Thmv,OX(1),OY(1),wait=0,prev=1,dim=2, cmm="Time "+t+" max "+S[].max);

//
//update

uold0[] = uold1[]; 
uold1[] = S[]; 
A=mat(Uh,Uh);
b=rhs(0,Uh);

}; // end of time loop
load "msh3" // bizarre
int nn= 4; 
int[int] ll=[10,11]; 
meshL Th= segment(nn,[x*nn,0,0],label=ll,region=1); // 
//  print information of Th
// bug label corrige ??
cout << " Element : "<<endl;
for(int k=0; k< Th.nt; ++k)
{
	cout << Th[k][0] << " "<< Th[k][1]  << ":  " 
	     << Th[k][0].x << " " << Th[k][0].label << " , " 
	     << Th[k][1].x << " " << Th[k][1].label <<  " " << Th[k].region << endl;
	
}
for(int i=0; i< Th.nv; ++i)
{
	cout << Th(i).x << " " << Th(i).y  << " " << Th(i).y  << " " << Th(i).label << endl; 
}
for(int i=0; i< Th.nbe; ++i)
{
	cout << " be " << i << " " << Th.be(i) << " " <<  Th.be(i).label  <<endl;
}

//  verif integration ..
func real track() { cout << " Track " << x << " N " << N << " Tl= " << Tl << endl; return 1.;}
fespace Vh(Th,P1);
varf va(u,v) = int1d(Th)(track()*dx(u)*dx(v)) + int0d(Th,10)(track()*u*v) - int0d(Th,10)(track()*v);
matrix A = va(Vh,Vh);
verbosity= 10; 
real[int] b= va(0,Vh);

cout << " A = " << A << endl;
cout << " b = " << b << endl;

assert(abs(b.sum+1)< 1e-7);
assert(abs(A(0,0)-2)<1e-7);
assert(abs(A(nn,nn)-1)<1e-7);
load "msh3"

meshL Th=segment(10,[x*pi*2]);
fespace Vh(Th,P1,periodic=[[1],[2]]);
meshL ThVh = Vh.Th; // check code ..
func u1e =(sin(x+1));
Vh u,v,uh=u1e;

meshL Thu = u.Th; // check code ..
u.n; // check code ..  
func f1= 1*u1e;
macro grad3(u) [dx(u),dy(u),dz(u)]//
solve PP2(u,v) = int1d(Th)(grad3(u)'*grad3(v)+1e-6*u*v) - int1d(Th)(f1*v) ;
Vh xx=x;
//plot([xx[],u[]],[xx[],uh[]],wait=1);
u[]-=uh[];
cout << " err 1 = " << u[].linfty << endl;

assert(u[].linfty< 0.05);
load "msh3"
int n = 100;
meshL Th = segment(n,[10.*(2.*x-1.),1.*y]);	
fespace Vh(Th,P1); 	
Vh psi, chi; // unknown and testfunction

int nev = 6; // number of eigensolutions
real e = 1.; // energy parameter (eigenvalue)
Vh[int] EigenPsi(nev); // array to store eigenvectors
real[int] EigenVal(nev); // array to store eigenvalues									

varf Schrodinger(psi,chi) = // variational form of the schrodinger equation
	int1d(Th)(dx(psi)*dx(chi) + x^2*psi*chi) 
	- int1d(Th)(e*psi*chi) + on(2,4,psi=0);
varf RHS(psi,chi) = int1d(Th)(psi*chi);
matrix A = Schrodinger(Vh,Vh);
matrix B = RHS(Vh,Vh);

// solve the eigenvalue problem:
int num = EigenValue(A,B,sym=true,sigma=e,value=EigenVal,
vector=EigenPsi,tol=1e-10,maxit=1000,ncv=0);

for(int i = 0; i < nev; i++){
	cout << "Eigenvalue["+i+"] = " << EigenVal[i] << endl;
	plot(EigenPsi[i],dim=3,fill=1,cmm="("+i+")");
	}
load "msh3" 

int upper = 1;
int others = 2;
int inner = 3;
int n = 10;

border D01(t=0, 1) {x=0; y=-1+t;z=3; }
border D02(t=0, 1){x=1.5-1.5*t; y=-1; z=3;label=upper;}
border D03(t=0, 1){x=1.5; y=-t; z=3;label=upper;}
border D04(t=0, 1){x=1+0.5*t; y=0; z=3;label=others;}
border D05(t=0, 1){x=0.5+0.5*t; y=0; z=3;label=others;}
border D06(t=0, 1){x=0.5*t; y=0; z=3;label=others;}
border D11(t=0, 1){x=0.5; y=-0.5*t; z=3;label=inner;}
border D12(t=0, 1){x=0.5+0.5*t; y=-0.5; z=3;label=inner;}
border D13(t=0, 1){x=1; y=-0.5+0.5*t; z=3;label=inner;}

plot(D01(-n) + D02(-n) + D03(-n) + D04(-n) + D05(-n)
   + D06(-n) + D11(n) + D12(n) + D13(n), wait=true);
 
meshL ThL=buildmeshL(D01(-n) + D02(-n) + D03(-n) + D04(-n) + D05(-n)
    + D06(-n) + D11(n) + D12(n) + D13(n));

savemesh(ThL,"toto.mesh");
	
//helice conique
border E1(t=0, 10.*pi){x=(1.)*t*cos(t); y=-(1.)*t*sin(t); z=t;}
meshL ThL2=buildmeshL(E1(1000));
plot(ThL2);

mesh Th=square(10,10);
int[int] ll=[4];
meshL ThL3 = extract(Th,[x+2,y*5],refedge=ll);
load "msh3"
verbosity=3;
border C(t=0, 2*pi){ x= cos(t); y=sin(t); region=1;}
meshL Lh=buildmeshL(C(20));
plot(Lh,dim=2, wait=1);
mesh Th = buildmesh(Lh);

plot(Th,dim=2, wait=1);
// NBPROC 4 
// PARAM   -cas 2    -n 20 -ndt 50
// usage :
//  ff-mpirun -np 8 NSNewtonCyl-100-mpi.edp -cas 2    -n 20 -ndt 50 
/* args can are:
   -ns                no output of script 
   -cas 1|2|3         case of benchmark  or Reynorl integer)
   -n nbseg           nb of seg on input edge ..  
   -ndt  ndt         nb time step par period 
   -nNewton nNx      number of of iteration in Newtow loop.    
   -gp      gnuplot ..
   -T final time 
 */
// Author: F. Hecht  .. 
// jan 2012 Stationnary imcompressible Navier Stokes Equation with Newton method.
//  a round a 2d Cylinder 
//  Benchmark  
// http://www.mathematik.tu-dortmund.de/lsiii/cms/papers/SchaeferTurek1996.pdf
//  
//  Thank to Macarena Gmez Mrmol <macarena@us.es>
// need version 3.20-2 ****  for pipe pluging 
// otherwise remove line with  pgnuplot 
// corresponding to gnuplot visualization
// --------------------------------------------------
include "getARGV.idp"
include "getARGV.idp"
load "MUMPS_mpi"
load "shell"
load "scotch"
load "pipe"

int cas = getARGV("-cas",2);; // 1, 2 or 3 ..
int n=getARGV("-n",15); //  mesh size ...
int ndt=getARGV("-ndt",25); 
int schema = 2; //  order 1  
bool gplt = usedARGV("-gp")>=0  && (mpirank==0) && (cas!=1) ; // 
real Tend = getARGV("-T",2);;  
bool save=0; 
real cpu0=mpiWtime() ; 
string data="./dd";//"2D-"+cas+"-"+n;
if(mpirank==0) mkdir(data);
string fgnup =data+"/fld2-"+cas+".gp";
string fdata = data+"/sol-cas-";
string fTh = data+"/Th-"+cas+".msh";

pstream  pgnuplot(  gplt  ? "gnuplot": "cat" );
 
//   parameter ... 
real D=0.1;
real H=0.41;
int ncurl=20; 

real[int] colorhsv=[  // color hsv model
  3./6., 1 , 0.5, // dark cyan
  3./6., 1 , 1, //  cyan
  4./6., 1 , 1, //  blue  
  5./6., 1 , 1, //  magenta
  1, 1. , 1, //  red
  1, 0.5 , 1 // light red 
   ];

real[int] vcurl( ncurl*2+1);
{ int n = vcurl.n;
   real d = 100;
   real c = 1.3 ;
    real ccc=0,cc = d/(1- c^(ncurl+1))/ (1-c) ; 
   vcurl[ncurl]=0; 
    for( int i =1 ; i <= ncurl;++i)
      {
        ccc += cc;
        cc *= c ; 
      //  cout << i << " " << ncurl-i << " " << ncurl+i << endl;
        vcurl[ncurl-i] = -ccc;
        vcurl[ncurl+i] = ccc;
      }
   cout << vcurl << endl; 
}
real cx0 = 0.2, cy0 = 0.2; // center of cyl. 
real xa = 0.15, ya=0.2, xe = 0.25,ye =0.2;// point for pressure..
//Definicin del dominio 
border fr1(t=0,2.2){x=t; y=0; label=1;}
border fr2(t=0,H){x=2.2; y=t; label=2;}
border fr3(t=2.2,0){x=t; y=H; label=1;}
border fr4(t=H,0){x=0; y=t; label=1;}
border fr5(t=2*pi,0){x=cx0+D*sin(t)/2; y=cy0+D*cos(t)/2; label=3;}

//plot(fr1(n)+fr2(n)+fr3(n)+fr4(n)+fr5(n));
mesh Th;

if(mpirank==0)
{
  Th=buildmesh(fr1(5*n)+fr2(n)+fr3(5*n)+fr4(n)+fr5(-n*3));
  int[int] nupart(Th.nt);
  nupart=0; 
  if(mpisize>1)
    scotch(nupart, Th, mpisize);
  Th=change(Th,fregion= nupart[nuTriangle]);
  savemesh(Th,fTh);
  plot(Th,wait=0);

}
broadcast(processor(0),Th); 
// partition of the mesh ...
// for computation of the Strouhal number
include "func-max.idp"
real hsize = D*pi/n; // size of the mesh ???? 

// bounding box for the plot 
func bb=[[0,H/4],[H*2,3*H/4]];

//  operator 
macro Grad(u1,u2) [ dx(u1),dy(u1), dx(u2),dy(u2)]// 
macro Eps(u1,u2) [ dx(u1),(dy(u1)+dx(u2))*0.5,(dy(u1)+dx(u2))*0.5,dy(u2)]// 
macro UgradV(u1,u2,v1,v2) [ [u1,u2]'*[dx(v1),dy(v1)] , [u1,u2]'*[dx(v2),dy(v2)] ]// 
macro div(u1,u2)  (dx(u1)+dy(u2))//
//  FE Space 
fespace Xh(Th,P2);fespace Mh(Th,P1);
fespace Wh(Th,[P2,P2,P1]);
fespace Rh(Th,P1dc);
Wh [u1,u2,p];
Wh [up1,up2,pp];
Wh [upp1,upp2,ppp];

Wh [vx1,vx2,vxp];
Wh [vy1,vy2,vyp];
varf von3x([u1,u2,p],[v1,v2,q]) = on(3 ,u1= 1); 
varf von3y([u1,u2,p],[v1,v2,q]) = on(3 ,u2= 1); 
vx1[]= von3x(0,Wh,tgv=1);
vy1[]= von3y(0,Wh,tgv=1);
real coefv =1, vtheta=0;  
real Um= 1.5;// max volicite case 2,3 (Rey 100) 
if( cas>3) 
  {
    
    Um = cas*1.5/100.;
    cas =2;
  }

func  Ub = Um*2./3.; 
real nu = 1e-3; 
real mu = 2*nu; //  Formulation in Eps : Eps 
func Rey = Ub*D/nu;
func ccdrag = 2./ square(Ub) /D ;
func ccfreq = D/Ub; 
real freq = 0.3/ccfreq; // frequence theorique
// initial guess..
u1[]=0; 

real T=0; // current time 

// velocity BC .. 
func coefV = (cas<3)? 1 : sin(pi*min(T/8.,1.));
func U1 = 4.*Um*y*(H-y)/(H*H) * coefv ;
func U2 = 0 ;

// stop test for Newton 
real eps=1e-8*Um;
//  choise of time step ..
int  mdt = rint(Tend*freq*ndt);
real dt = Tend/mdt;//  ntd  pas de temps pas periode 
real CFL = Um*dt/hsize; 
if(mpirank==0) cout << " dt =" << dt << " CFL = " << CFL <<  endl; 

verbosity=0;
// BDF2 schema  order 2 in time ... 
real[int] beta=[1.5, -2., +0.5];  
if(schema ==1) 
  beta=[1,-1,0]; // Euler implicit + ruse OP 
  
real[int] ab=1./dt*beta  ;

if(cas ==1) 
{ // static case
  Um = 0.3;
  Tend=0;
  ab=0; // no time .. 
 
}
// init..
int iter=0;
if(mpirank==0) {
        ofstream f(fgnup);// clean the file ..   
 }

varf GStokesl([du1,du2,dp],[v1,v2,q]) =
		   int2d(Th,mpirank) ( 
		                ab[0]*[du1,du2]'*[v1,v2]
		              + mu*(Eps(du1,du2)'*Eps(v1,v2) )
		              - div(du1,du2)*q - div(v1,v2)*dp 
		              - 1e-8*dp*q // stabilization term 
		             )
	    + on(1,3,du1=0,du2=0)
	    + on(2,du2=0) 
	    
;
varf GStokesl0([du1,du2,dp],[v1,v2,q]) =
		   int2d(Th,mpirank) ( 
		                ab[0]*[du1,du2]'*[v1,v2]
		              + mu*(Eps(du1,du2)'*Eps(v1,v2) )
		              - div(du1,du2)*q - div(v1,v2)*dp 
		              - 1e-8*dp*q // stabilization term 
		             )
	   ;
varf Vconvect([du1,du2,dp],[v1,v2,q]) =
  -int2d(Th,mpirank) ( 
    ab[1]* ( [v1,v2]'* [
      convect([u1,u2],-dt,up1),
      convect([u1,u2],-dt,up2)
    ] )
   +  ab[2]* ( [v1,v2]'* [
      convect([u1,u2],-dt*2,upp1),
      convect([u1,u2],-dt*2,upp2)
    ] )
     ); 

varf Vconvect1([du1,du2,dp],[v1,v2,q]) =
  -int2d(Th,mpirank) ( 
    ab[1]* ( [v1,v2]'* [
      convect([u1,u2],-dt,up1),
      convect([u1,u2],-dt,up2)
    ] )
); 
    
  
varf VBC([u1,u2,p],[v1,v2,q]) = on(1,u1=U1,u2=U2); 
real[int] bcl=VBC(0,Wh);
real[int] bl(Wh.ndof),b(Wh.ndof),bcv(Wh.ndof); 
matrix A,A0;
 
 A=GStokesl(Wh,Wh,solver=GMRES); //sparsesolver,master=-1);
//mpiAllReduce(Al,A,mpiCommWorld,mpiSUM);
A0=GStokesl0(Wh,Wh,solver=GMRES);
//mpiAllReduce(A0,A,mpiCommWorld,mpiSUM);

set(A,solver=sparsesolver,master=-1);
Wh [w1,w2,wp]; 
// loop in time if need ..
cout << "Stort\n";
real CPU0=mpiWtime();

while(1) 
{	
    real err=0;
    T += dt;
    iter++;
    real co = coefv;
    coefv  =  coefV;// coef in velocty ..
    if( co != coefv ) bcl=VBC(0,Wh);
    upp1[]=up1[];
    up1[]=u1[];
    if(schema>1)
     { u1[] *=2; u1[] -= upp1[]; } 
     if( ab[2])    
      bcv = Vconvect(0,Wh);
    else 
      bcv = Vconvect1(0,Wh);
    bl = bcv;
    bl += bcl;
       	
	{
	   //mpiAllReduce(bl,b,mpiCommWorld,mpiSUM);
        w1[]=A^-1*bl;
	    u1[] =  w1[];
	    if(mpirank==0)  
	      cout << T << "\t " << n << " rey  =" << Rey << " U1 max = " << u1[].max <<" " ;
	}
	//if( schema==1)
	 //{ u1[] *= 2; u1[] -= up1[]; }   
   if(cas==1) 
    {
        plot([u1,u2],p,  coef = 0.02/u1[].max, bb=bb,wait=1, cmm=" cas 1 "); 
    }
     b  = A0*w1[];
     b += bcv;
     real cdrag = -(b'*vx1[]) ; 
     real clift = b'*vy1[] ; 
		             
    real drag,lift,Cd,Cl,Ta;
    mpiAllReduce(clift,lift,mpiCommWorld,mpiSUM);  
    mpiAllReduce(cdrag,drag,mpiCommWorld,mpiSUM);  
    if ( iter > 2)
    {
    Cd = ccdrag*drag;
    Cl = ccdrag*lift; 
    }
    // end of compute the Drag and lift Coef 
    
    Ta = T/ccfreq; // The adimensional time ..
    real Deltap = p(xa,ya) - p(xe,ye) ; // the Deltap
    real strouhal = AddStrouhal(iter,Ta,Cl);
    AddMaxO2(Cd,iter,mxdrag,mxdragi);   
    AddMaxO2(Cl,iter,mxlift,mxlifti);   
    real Cdx = mxdrag.max, Clx = mxlift.max; 
   if(mpirank==0) {
        {
        ofstream f(fgnup,append);
        f << T << " " << drag << " " << lift << " " 
          << Ta << " " << Cd << " " << Cl    << " " << Deltap <<"   " << mpiWtime()-cpu0 << " " 
          << iter <<  "  " << strouhal << endl;
        }
     real Td = max((int(Ta)-20),0); //  period  = 3 en Ta 
     if(cas==3) Td=0; 
     if(gplt) {
        pgnuplot << "set title \"Rey = " +Rey + ", Strouhal= "+strouhal+",  T = "
                    + T + ", cas = " + cas << ", Cara CFL : "+CFL+"\";\n";
        pgnuplot << "plot ["+Td+":] \""+fgnup+"\" u 4:5 w l t \"Cd\", \""+fgnup
                    +"\"  u 4:6 w l t \"Cl\","+Cdx+",   "+ Clx << endl;
        flush(pgnuplot); 
     }
 
    }
    
    // plot curl of the flow preetty ...
    Rh curlu = -dy(u1)+ dx(u2);
    plot(curlu,viso=vcurl,  fill=1,hsv=colorhsv,
    // bb=bb,
      coef=0.01/Um,cmm = " T = " + T+" / "+Tend+" s + "); 
    
    upp1[] = up1[] -u1[];
    upp2[] = up2[] -u2[];
     real CPU = mpiWtime()-CPU0;
     CPU0=mpiWtime();
    real errt = upp1[].linfty + upp2[].linfty; 
    if(mpirank==0)  cout << " errt = " << errt<< " T = " << T <<  " Strouhal  " << strouhal  <<" Cdx= " << Cdx<< " Clx =  " << Clx << " " << CPU << "s" <<endl; 
    if(mpirank ==0 && save)
    {
        ofstream f(fdata+"-"+iter+".txt");
        f << T << endl;
        f << u1[] << endl;
        f << u2[] << endl;
        f << p[] << endl; 
    }
    if( errt < 1e-5) break; // stop if steady state 
    if(T>Tend*1.0000001) break; // stop after final time ..
}


//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4


verbosity=100;
cout << " rank = " << mpirank << " " << " size " << mpisize << endl;
if ( mpisize > 1) 
  if( mpirank==0) 
    {
      cout << " send to 1 " << endl;
      processor(1) << 123456;
    }
  else if (mpirank==1) 
    {
      int k;
      processor(0) >> k;
      cout << " recived " << k << endl;
    }
int l= mpirank+100;
cout << " l == " << l << " broadcast l from 0   mpirank = " << mpirank << endl;
broadcast(processor(0),l);
cout << " l == " << l << "  mpirank ="<< mpirank << endl;

matrix<complex> A;

if( mpirank==0)
   A=[[1+1i,1i],[0,2-1i]];
broadcast(processor(0),A);

if (mpirank==1)
  { A=A+A;
    processor(0) << A;
  }
 else if(mpirank==0)
   processor(1) >>  A;
cout << " mpirank = " << " A =  " <<  A << endl;

cout << " " <<  norm(A(1,1) - 2-1i) << endl;
if( mpisize>4)
{
int[int] procs=[1,0,3];
mpiGroup group(procs);
}
// NBPROC 10
// ff-mpirun -np 4 DDM-Schwarz-Lap-3d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/

load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer3d.idp"
include "DDM-funcs-v2.idp"
include "cube.idp" 
include "MPIplot.idp"

searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",20);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3);
string tsolver = getARGV("-ts","CG"); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=1; // size of overlap
bool RAS=1; 

if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

string sPk="P2-3gd";     
func Pk=P2;
int Pknbcomp=1; 

func bool  plotMPIall(mesh3 &Th,real[int] & u,string  cm)
{ if(vdebug) PLOTMPIALL(mesh3,Pk, Th, u,{ cmm=cm,nbiso=4,fill=1,dim=3,value=1}); return 1;}

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;

int[int] l111=[1,1,1,1]; 
settt 


int[int,int] LL=[[1,1],[1,1],[1,1]];
real[int,int] BB=[[0,1],[0,1],[0,1]];
int[int] NN=[nloc,nloc,nloc]; 
int[int] NNC=[nC,nC,nC]; 
settt 
mesh3 Thg=Cube(NN,BB,LL);
mesh3 ThC=Cube(NNC,BB,LL);

fespace VhC(ThC,P1); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh3,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh3,Pk,1,[0],
                 Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)

Whi ui,vi; 



/* the definition of the Problem .... */
func G=1.; /* ok  */
func F=1.; /* ok  */
macro grad(u) [dx(u),dy(u),dz(u)] //
// warning for Dir. BC. the last win 
varf vPb(U,V)= int3d(Thi)(grad(U)'*grad(V)) + int3d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int3d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon10(U,V)=on(10,U=1)+on(1,U=0);

varf vPBC(U,V)=on(1,U=G);


real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=tsolver); 

DMMDeffuncAndGlobals(Lap3,comm,jpart,Whi,Vhc,1,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0])

Lap3CheckUpdate();
  
Whi u=0,v;
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lap3DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lap3kiter <<  endl;
}

Lap3Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
//ff-mpirun -np 4 parmmg.edp -wg 

// for the make check:
// NBPROC 4
// PARAM

load "msh3"
load "medit"
load "mmg"
load "parmmg"

int nn = 40;

mesh3 Th3=cube(nn,nn,nn);

func sphere = sqrt((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)-0.3;
real hmin = 0.02;
real hmax = 0.1;

fespace Uh(Th3,P1);
Uh met = max(hmin,min(hmax,abs(sphere)));

// centralized input ; input mesh is from rank 0
Th3 = parmmg3d(Th3,metric=met[],comm=mpiCommWorld);
// output mesh is broadcast to all processes in comm

if (mpirank == 0)
  medit("Th3",Th3);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

// other
//load "medit"
load "MUMPS_mpi"
include "cube.idp"

real ttgv=1e10;
//string ssparams="nprow=1, npcol="+mpisize;

int[int]  Nxyz=[40,8,8];
real [int,int]  Bxyz=[[0.,5.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,1],[2,2],[2,2]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

fespace Vh(Th,[P2,P2,P2]);
//fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
real time=clock();  

real tMatrix = clock();
varf vLame([u1,u2,u3],[v1,v2,v3]) = 
int3d(Th)(
		 lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    + 2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //') for emacs
	      )
	      + on(1,u1=0,u2=0,u3=0);

matrix MLame=vLame(Vh,Vh,tgv=ttgv);
tMatrix = clock()-tMatrix;

real tFact = clock();
set(MLame,solver="MUMPSMPI",tgv=ttgv);
tFact = clock()-tFact;

real tsdc = clock();
varf vsdc([u1,u2,u3],[v1,v2,v3])=int3d(Th) (gravity*v3)+ on(1,u1=0,u2=0,u3=0);
real[int] sdc= vsdc(0,Vh); 
tsdc = clock()-tsdc;

real tsolve=clock();
u1[] = MLame^-1*sdc;
tsolve= clock()-tsolve;
cout << "===============================================" << endl;
cout << "====            CPU time                  =====" << endl;
cout << "===============================================" << endl;
cout << " ALL solving steps :::: "  << clock()-time << endl;
cout << " Matrix            :::: "  << tMatrix << endl;
cout << " Fact              :::: "  << tFact   << endl;
cout << " Second member     :::: "  << tsdc    << endl;
cout << " Solve             :::: "  << tsolve  << endl;
cout << "===============================================" << endl;

if(mpirank==0)
{
	real dmax= u1[].max;
	cout << mpirank << " max deplacement = " << dmax << endl;
	real coef= 0.01/max(dmax,1e-10);
	int[int] ref2=[1,0,2,0];
	
searchMethod=0;		
  mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2);
  savemesh(Thm,"beam-deformed-mumps.mesh");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -n 5

// other
load "msh3"
load "medit"
load "MUMPS_mpi"
include "getARGV.idp"

real ttgv=1e10;
//string ssparams="nprow=1, npcol="+mpisize;

int nn=getARGV("-n",15);
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);  Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],  labelmid=rmid, 
  reffaceup = rup,     reffacelow = rdown);
  
//medit("c10x10x10",Th);
fespace VVh(Th,[P2,P2,P2,P1]);
fespace UUh(Th,[P2,P2,P2]);
fespace Uh(Th,P2);
fespace Ph(Th,P1);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

func fup = (1-x)*(x)*y*(1-y)*16;

Uh u1,u2,u3;
Uh v1,v2,v3;
Ph p,q;

real timeI=clock();
real time1=clock();

//VVh [uu1,uu2,uu3,up];
varf vlaplace([u1,u2,u3],[v1,v2,v3]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) ) 
  + on(2,u1=fup,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ; //'

varf vdiv([u1,u2,u3],[q])=int3d(Th,qforder=3)(- div(u1,u2,u3)*q );
varf vdivT([q],[u1,u2,u3])=int3d(Th,qforder=3)(- div(u1,u2,u3)*q );
varf vmass(p,q) = int3d(Th,qforder=3)( 1e-10*p*q );

matrix M=vmass(Ph,Ph);
matrix L=vlaplace(UUh,UUh,tgv=ttgv);
matrix B=vdiv(UUh,Ph);
matrix BT=vdivT(Ph,UUh);

matrix A = [ [ L, BT ],     //'
	     [ B, M  ]];

time1=clock()-time1;

real timeF=clock();
set(A,solver=sparsesolver);
timeF=clock()-timeF;

real time2=clock();
real[int] b(VVh.ndof);
real[int] xx(VVh.ndof);
{ 
  real[int] b1 = vlaplace(0,UUh);
  
  for(int ii=0; ii<UUh.ndof; ii++)
    {
      b[ii]=b1[ii];
    }
  for(int ii=0; ii<Ph.ndof; ii++)
    {
      b[ii+UUh.ndof]=0;
    }
}
time2=clock()-time2;

real time3=clock();
xx = A^-1*b;
time3=clock()-time3;

for(int ii=0; ii<Uh.ndof; ii++)
    {
      u1[][ii]=xx[3*ii];
      u2[][ii]=xx[3*ii+1];
      u3[][ii]=xx[3*ii+2];
    }
  for(int ii=0; ii<Ph.ndof; ii++)
    {
      p[][ii]=xx[ii+UUh.ndof];
    }

timeI=clock()-timeI;

cout << "============= CPU TIME ============" << endl;
cout << " matrix                  " <<  time1 << endl;
cout << " Fact                    " <<  timeF << endl;
cout << " second member           " <<  time2 << endl;
cout << " solve                   " <<  time3 << endl;
cout << "                          ------------" << endl;
cout << " all                     " <<  timeI << endl;
cout << "============= CPU TIME ============" << endl;

//if(mpirank==0) medit("UV2 PV2",Th,[u1,u2,u3],p);

// NBPROC 3
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
load "MUMPS_mpi"
verbosity=7;
mesh Th=square(20,20,[pi*y,pi*x]);
Th=change(Th,fregion= (mpisize*nuTriangle)/Th.nt);
plot(Th,wait=1,fill=1);
fespace Vh(Th,P2);
Vh u1,u2;
int n=Vh.ndof; 

real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th,mpirank)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th,mpirank)(  u1*u2 ) ; // no  Boundary condition
int[int] info(40);
info=-1;
info(0)=1;
matrix A= a(Vh,Vh,solver=sparsesolver,master=-1,info=info); 

matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 
 

func real[int] FA(real[int] & u) { 
	// resolution distribuer mais pas le second membre 
	if(mpirank==0) {int cas=1; broadcast(processor(0),cas);}
	else u=0; //  second menbre non distribute
	real[int] Au=A^-1*u;return Au;
}


func real[int] FB(real[int] & u) { 
	
	if(mpirank==0) {
		int cas=2; broadcast(processor(0),cas);}
	broadcast(processor(0),u);
	real[int] Alu=B*u,Au(Alu.n);
	mpiReduce(Alu,Au,processor(0),mpiSUM);
	return Au;

}


func int Farpack(int i)
{
   
   real[int]  u(n);
   while(1)
	{
	int cas ;
	broadcast(processor(0),cas);
	cout << mpirank << " " << cas << endl; 
	if(cas==1) FA(u);
	else if(cas==2) FB(u);
	else break;
    }
	return 0; 
}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector

if(mpirank==0)
{
int k=EigenValue(n,FA,FB,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);

int cas=0; broadcast(processor(0),cas); 
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
real[int]  eev(36);
eev=1e100;
for(int i=1,k=0;i<7;++i)
for(int j=1;j<7;++j)
  eev[k++]=i*i+j*j;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  if(abs(ev[i]-eev[i]) > 1e-1) nerr++;
  cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=0);
}
assert(nerr==0);
}
else
 Farpack(0);
 

// NBPROC 4
load "MPICG"

// the grad of the bilinear part of J (the RHS in remove)
   int n=3;
  real[int]  b(n),u(n);
  b=1;
   u=0; // set  right hand side and initial gest

  func real[int] matId(real[int] &u) { return u;};
  func real[int] DJ0(real[int] &u)
    { 
      for (int i=0;i<u.n;i++)
	u[i]=10*mpirank+(i+1)*u[i];
      return u;  // return of global variable ok 
   };
  func real error(real[int] & u,real[int] & b)
   {
   real s=0;
     for (int i=0;i<u.n;i++)
	s += abs(10*mpirank+(i+1)*u[i] - b[i]);
   return s;    
   }

  b=1; u=0; // set  right hand side and initial gest
  MPILinearCG(DJ0,u,b,eps=1.e-6,nbiter=20,precon=matId);
  cout << "LinearCG (Linear)  err=" << error(u,b) << endl;
  assert(error(u,b) < 1e-5);


{
  int[int] procs=[0,1];
  mpiGroup gpr(procs);
  cout << " before  ...  " << mpirank << endl;
  mpiComm comm(gpr);
  if(comm)  // ..  comm 
    {
      int rank=mpiRank(comm);
      cout << " rank = " << rank << endl; 
      mesh[int]  aTh(2);
      int[int]  ll=[1,2-rank,1,1+rank];
      aTh[rank]=square(4,4,[rank+x,y], label=ll);	  
      broadcast(processor(0,comm),aTh[0]);
      broadcast(processor(1,comm),aTh[1]);
      mesh Th=aTh[rank];
      mesh Thi=aTh[1-rank]; 
      mesh Thh = Th+Thi;
      
      
      fespace Vh(Th,P1);	
      fespace Vhi(Thi,P1);
      
      matrix Ihi=interpolate(Vh,Vhi, inside=1);// Vh <-Vhi
      cout << rank << " Ihi = "<< Ihi << " ---- " << endl;
      
      // compresse row numbering to min. th comm.
      int [int] Ii(Vhi.ndof),II(Vh.ndof);
      real[int] dhi(Vh.ndof);
      int nn,NN;
      { 
	Vh uh=1.; Vhi ui=1;
	real[int] vi(0:ui[].n-1);
	ui[] =Ihi'*uh[];//';
	ui[] = ui[] ? 1 : 0;
	nn = rint(ui[].sum);
	vi = ui[] ? vi : 1e30;
	vi.sort;
	//	   cout << vi[nn] << " " << vi[nn-1] << endl;
	assert(vi[nn]>1e10 && vi[nn-1] < 1e10);
	vi.resize(nn);
	Ii.resize(nn);
	for(int i=0;i<nn;++i)
	  Ii[i]=vi[i];
	processor(1-rank,comm) << nn;
	processor(1-rank,comm) >> NN;
	assert( nn == NN) ;
	//   II.resize(NN);
	processor(1-rank,comm) <<Ii;
	processor(1-rank,comm) >>II;	     
	//cout << Ii << endl;
	real Ihioo=0;
	try {
	  Ihioo= Ihi(Vh.ndof-1,Ii[nn-1]);
	}
	   catch(...) {;};
	int[int] I(0:Vh.ndof-1);
	Ihi = Ihi(I,Ii);
	//assert(Ihi(Vh.ndof-1,nn-1) == Ihioo);
	// cout << rank << " Ihi = "<< Ihi << " ---- " << endl;
	dhi=1;
	vi=1;
	dhi += Ihi*vi;
	real[int] one(dhi);one=1.;
	dhi = one ./ dhi;
	cout << dhi << endl;
      }
      
      real[int] tosend(NN),torecv(nn);
      real tgv=1e3;
      macro  Grad(u) [dx(u),dy(u)] //
	varf va(u,v)=int2d(Th)(u*v+Grad(u)'*Grad(v)) - int2d(Th)( x*v ) -int1d(Th,1)( N.x*v)  ;	      ;//');
      matrix A=va(Vh,Vh,tgv=tgv);
      real[int] b=va(0,Vh,tgv=tgv);   
      int kiter=0;
      func real[int] projC(real[int] &u)
      {
	verbosity=0;
	processor(1-rank,comm) << (tosend = u(II));
	processor(1-rank,comm) >> torecv;
	//cout << "to send " << tosend << endl;
	u += Ihi*torecv;
	//  u = u .* dhi;
	Vh uu; uu[]=u;
	//     cout << kiter++ << " " << mpirank <<  " ---  " <<  uu(1,0.5) << endl; 	      
	return   u;	      
      }	  
      
      func real[int] projD(real[int] &u)
      {
	verbosity=0;
	processor(1-rank,comm) << (tosend = u(II));
	processor(1-rank,comm) >> torecv;
	u += Ihi*torecv;
	u = u .* dhi;
	Vh uu; uu[]=u;
	//   cout << kiter++ << " " << mpirank <<  " ---  " <<  uu(1,0.5) << endl; 	      
	return   u;	      
      }	
  
      func bool  Plot(real[int] & uu)
      {
	Vh u; u[]=uu;
	Vhi ui;
	if(rank==0)
	  {     
	    processor(1,comm) >> ui[];
	    plot(u,ui,wait=1);
	  }
	else
	  processor(0,comm) << u[];
	return true;
      }
      
      func real[int] DJJ(real[int] &v)
      { 
	verbosity=0;
	// Plot(v);
	v = projD(v);
	real[int] u=A*v;
	u += b; 
	u = projC(u);
	verbosity=1;
	return u;  // return 
      };		  
      
      func real[int] matId(real[int] &u) { 
	verbosity=0;
	u =projD(u);
	verbosity=1;
	return u;};
      
      
      
      
      Vh u=0;
      
      u=0;
      verbosity=1;
      MPIAffineCG(DJJ,u[],eps=1.e-4,nbiter=200,precon=matId,comm=comm);
      projD(u[]);
      Plot(u[]);
      if(rank==0)
	{
	  fespace Vhh(Thh,P1);
	  Vhh uuu,vvv;
	  // u = x , dn(x) = N.x 
	  solve PPPP(uuu,vvv) = int2d(Thh)(uuu*vvv+Grad(uuu)'*Grad(vvv)) - int2d(Thh)( x*vvv ) -int1d(Thh,1)( N.x*vvv)  ; //');
	  cout << " err = " << int2d(Th)( square(uuu-u)) << " " << int2d(Thh)( square(uuu-x)) << endl;
	 // savemesh(Thh,"/tmp/Thh.msh");
	}
    }
}

//  run with MPI:  ff-mpirun -np 2 script.edp
// NBPROC 2

if ( mpisize != 2 ) {
cout << " sorry number of processeur !=2 " << endl;
exit(1);}
verbosity=1;
real pi=4*atan(1);
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=40;
mesh th,TH;

if (mpirank == 0) 
 {
 th = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
 cout << " end th  " << endl;
// processor(1) << th ;
// processor(1) >> TH;
}
else
 {
 TH = buildmesh ( e(5*n) + e1(25*n) );
 cout << " end TH  " << endl;
// processor(0) << TH ;
// processor(0) >> th;
 }
broadcast(processor(0),th);
broadcast(processor(1),TH);



fespace vh(th,P1);
fespace VH(TH,P1);
vh u=0,v; VH U,V;
int i=0;

problem PB(U,V,init=i,solver=Cholesky) = 
    int2d(TH)( dx(U)*dx(V)+dy(U)*dy(V) )
  + int2d(TH)( -V) + on(inside,U = u)  +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(th)( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(th)( -v) + on(inside ,u = U) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 10; i++) 
{ 
  cout << mpirank << " looP " << i << endl;
  if (mpirank == 0)
  {   
   PB;
   processor(1) << U[];
   processor(1) >> u[];
  }
  else 
  {
   pb;
   processor(0) >> U[];
   processor(0) << u[];
  }
  //  if (mpirank==0)  
  // plot(U,u,wait=true,ps="Uu"+i+".eps");
};
mpiBarrier(mpiCommWorld);// missing FH. Jan/2016 
 if (mpirank==0)  
    plot(U,u,ps="Uu.eps");
    
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

cout << "\n\n empty file remove NSI3d-carac.edp\n\n" << endl;
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4


// other
load "msh3"
load "medit"
load "MUMPS_mpi"

real ttgv=-1;
//string ssparams="nprow=1, npcol="+mpisize;


int nn=5;
mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);  Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],  labelmid=rmid, 
  reffaceup = rup,     reffacelow = rdown);

real ccc = mpisize/real(Th.nt) ;
Th=change(Th,fregion= min(mpisize-1,int(nuTriangle* ccc+1e-10)));
if(mpirank==0)
for(int i=0;i<=mpisize;++i)
	 cout<< " Volume region  " <<  i << " " << int3d(Th,i)(1.) << endl;
//if(mpirank==0) medit("c10x10x10",Th);
fespace VVh(Th,[P2,P2,P2,P1]);
fespace UUh(Th,[P2,P2,P2]);
fespace Uh(Th,P2);
fespace Ph(Th,P1);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

func fup = (1-x)*(x)*y*(1-y)*16;

Uh u1,u2,u3;
Uh v1,v2,v3;
Ph p,q;

//VVh [uu1,uu2,uu3,up];
real timeI=clock();
real time1=clock();
varf vlaplace1(u1,v1) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) ) + on(2,u1=fup) + on(1,u1=0); //' for emacs 

varf vlaplacenull(u2,v2) = 
  int3d(Th,qforder=3)( Grad(u2)'*Grad(v2) ) + on(2,u2=0) + on(1,u2=0); //' for emacs 

varf vdx(u1,q) = int3d(Th,qforder=3)( -dx(u1)*q );
varf vdy(u2,q) = int3d(Th,qforder=3)( -dy(u2)*q ); 
varf vdz(u3,q) = int3d(Th,qforder=3)( -dz(u3)*q );

varf vmass(p,q) = int3d(Th,qforder=3)( 1e-10*p*q );

matrix M     = vmass(Ph,Ph,tgv=ttgv);
matrix L1    = vlaplace1(Uh,Uh,tgv=ttgv);
matrix Lnull = vlaplacenull(Uh,Uh);
matrix Bx = vdx(Uh,Ph);
matrix By = vdy(Uh,Ph);
matrix Bz = vdz(Uh,Ph);


matrix A = [ [ L1,     0,     0, Bx' ],     
	         [  0, Lnull,     0, By' ],
             [  0,     0, Lnull, Bz' ],
             [ Bx,    By,    Bz,  M  ] ];    //' for emacs


time1=clock()-time1;

real time2=clock();
real[int] b(VVh.ndof);
real[int] xx(VVh.ndof);
{ 
  real[int] b1 = vlaplace1(0,Uh,tgv=ttgv);
  real[int] b2 = vlaplacenull(0,Uh,tgv=ttgv);
  
  for(int ii=0; ii<Uh.ndof; ii++)
    {
      b[ii]=b1[ii];
      b[ii+Uh.ndof]=b2[ii];
      b[ii+2*Uh.ndof]=b2[ii];
    }
  for(int ii=UUh.ndof; ii<UUh.ndof+Ph.ndof; ii++)
    {
      b[ii]=0;
    }
}
time2=clock()-time2;

real timeF=clock();
set(A,solver=sparsesolver,tgv=ttgv);
timeF=clock()-timeF;

real time3=clock();
xx = A^-1*b;
time3=clock()-time3;

for(int ii=0; ii<Uh.ndof; ii++)
    {
      u1[][ii]=xx[ii];
      u2[][ii]=xx[ii+Uh.ndof];
      u3[][ii]=xx[ii+2*Uh.ndof];
    }
  for(int ii=0; ii<Ph.ndof; ii++)
    {
      p[][ii]=xx[ii+UUh.ndof];
    }

timeI=clock()-timeI;

cout << "============= CPU TIME ============" << endl;
cout << " matrix                  " <<  time1 << endl;
cout << " Fact                    " <<  timeF << endl;
cout << " second member           " <<  time2 << endl;
cout << " solve                   " <<  time3 << endl;
cout << "                          ------------" << endl;
cout << " all                     " <<  timeI << endl;
cout << "============= CPU TIME ============" << endl;

//if(mpirank==0) medit("UV2 PV2",Th,[u1,u2,u3],p);

//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

include "getARGV.idp"
load "metis"
load "parmetis"

mesh Th = square(getARGV("-global", 800), getARGV("-global", 800));
fespace Ph(Th, P0);
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    if(mpirank == 0)
        metisdual(part[], Th, getARGV("-lpart", 128));
    broadcast(processor(0, mpiCommWorld), part[]);
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "METIS: " << mpiWtime() - time << endl;
        plot(part, wait = 1, fill = 1, cmm = "METIS");
    }
}
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    parmetis(part[], Th, getARGV("-lpart", 128), communicator = mpiCommWorld, worker = getARGV("-worker", mpisize));
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "ParMETIS: " << mpiWtime() - time << endl;
        plot(part, wait = 1, fill = 1, cmm = "ParMETIS");
    }
}
// NBPROC 4
// ff-mpirun -np 4 DDM-Schwarz-Lap-3d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES2d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer3d.idp"
include "DDM-funcs-v2.idp"
include "cube.idp" 


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",5);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=1; // size of overlap
bool RAS=1; 

if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

string sPk="P2-Lame-3gd";     
func Pk=[P2,P2,P2];

func bool  plotMPIall(mesh3 &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh3,Pk, defPk3, Th, u, allu2, { cmm=cm,nbiso=20,fill=1,dim=3,value=1}); return 1;}


mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,1,1]; 
settt 


int[int,int] LL=[[1,1],[2,1],[1,1]];
real[int,int] BB=[[0,1],[0,5],[0,1]];
int[int] NN=[nloc,nloc*5,nloc]; 
int[int] NNC=[nC,nC*5,nC]; 


settt 
mesh3 Thg=Cube(NN,BB,LL);
mesh3 ThC=Cube(NNC,BB,LL);

fespace VhC(ThC,[P1,P1,P1]); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh3,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh3,Pk,3,[0,1,2],Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)





/* the definition of the Problem .... */


// the definition of the Problem ....
real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
  
varf vPb([u1,u2,u3],[v1,v2,v3])=
  int3d(Thi)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  + int3d(Thi) (gravity*v3)
  + on(2,10,u1=0,u2=0,u3=0)
  ;
  
varf vPbC([u1,u2,u3],[v1,v2,v3])=
  int3d(ThC)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  + int3d(ThC) (gravity*v3)
  + on(2,u1=0,u2=0,u3=0)
  ;

varf vPbon10([u1,u2,u3],[v1,v2,v3])=on(10,u1=1,u2=1,u3=1)+on(2,u1=0,u2=0,u3=0);
varf vPBC(U,V)=on(2,U=0);



real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Lame3,comm,jpart,Whi,Vhc,3,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0,1,2])

Lame3CheckUpdate();
  
Whi [u,u1,u2],[v,v1,v2];
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lame3DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lame3kiter <<  endl;
}

Lame3Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
cout << " On A Fin"<<endl; 
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

/*
   $ - \Delta p = f $   on $\Omega$, 
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{1}$ 
   $ p = gd  $ on $\Gamma_{2}$    
   with de Mixte finite element formulation 

   Find $p\in L^2(\Omega) $  and $u\in H(div) $ such than 
   $$  u - Grad p = 0    $$
   $$ - div u =  f $$
   $$  u. n = (g1d,g2d). n   \mbox{ on } \Gamma_{2}$$
   $$ p = gd  \mbox{ on }\Gamma_{1}$$
   the variationnel form is: 
                                                                                                                   
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{2} $:  

  $ \int_\Omega  u v + p div v -\int_{\Gamma_{1}} gd* v.n  = 0 $ 
 $\forall q\in L^2$:   $  +\int_\Omega q div u = -\int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_2$

*/

// brochet
load "medit"
load "MUMPS_mpi"
include "cube.idp"


real ttgv = 1e30;
string ssparams = "nprow=1, npcol="+mpisize;

    //int[int]  Nxyz=[18,18,18];
    int[int]  Nxyz=[10,10,10];
    real [int,int]  Bxyz=[[0,1],[0,1],[0,1]];
    int [int,int]  Lxyz=[[1,1],[1,1],[2,1]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);
fespace Vh(Th,P1);
fespace Rh(Th,RT03d);
fespace Nh(Th,Edge03d);//  Nedelec Finite element. 
fespace Ph(Th,P0);

func gd = 1.;

func g1n = 2.;
func g2n = 3.; 
func g3n = 4.; 

func f = 1.;

Rh [u1,u2,u3],[v1,v2,v3];
Nh [e1,e2,e3];
[u1,u2,u3]=[1+100*x,2+100*y,3+100*z];

// a + b ^ x = 
/*
  b1    x     a1 + b2*z - b3*y 
  b2 ^  y  =  a2 - b1*z + b3*x
  b3    z     a3 + b1*y - b2*x
*/
real b1=30,b2=10,b3=20;
func ex1=100+b2*z-b3*y;

func ex1x=0.;
func ex1y=-b3+0;
func ex1z=b2+0;

func ex2=200.- b1*z + b3*x ;
func ex2x= b3 +0;
func ex2y= 0. ;
func ex2z= -b1 +0;
func ex3=300.+b1*y - b2*x ;
func ex3x= -b2 +0;
func ex3y= b1 +0;
func ex3z= 0. ;
[e1,e2,e3]=[ex1,ex2,ex3]; 

int k=Th(.1,.2,.3).nuTriangle ;
cout << " u = " << u1(.1,.2,.3)  << " " << u2(.1,.2,.3) << " " << u3(.1,.2,.3) << endl;
cout << " dx u = " << dx(u1)(.1,.2,.3)  << " " << dy(u2)(.1,.2,.3) << " " << dz(u3)(.1,.2,.3) << endl;

cout << " e  = " << e1(.1,.2,.3)  << " " << e2(.1,.2,.3) << " " << e3(.1,.2,.3) << endl;
cout << " ex = " << ex1(.1,.2,.3)  << " " << ex2(.1,.2,.3) << " " << ex3(.1,.2,.3) << endl;


cout << " dx,dy,dz   e1x= " << ex1x(.1,.2,.3)  << " " << ex1y(.1,.2,.3) << " " << ex1z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2x= " << ex2x(.1,.2,.3)  << " " << ex2y(.1,.2,.3) << " " << ex2z(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3x= " << ex3x(.1,.2,.3)  << " " << ex3y(.1,.2,.3) << " " << ex3z(.1,.2,.3) << endl;

cout << " dx,dy,dz   e1 = " << dx(e1)(.1,.2,.3)  << " " << dy(e1)(.1,.2,.3) << " " << dz(e1)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e2 = " << dx(e2)(.1,.2,.3)  << " " << dy(e2)(.1,.2,.3) << " " << dz(e2)(.1,.2,.3) << endl;
cout << " dx,dy,dz   e3 = " << dx(e3)(.1,.2,.3)  << " " << dy(e3)(.1,.2,.3) << " " << dz(e3)(.1,.2,.3) << endl;


cout << " k = " << k << endl;
cout << Rh(k,0) << " " <<Rh(k,1) << " " <<Rh(k,2) << " " <<Rh(k,3) << endl;
cout << " df = " << u1[][Rh(k,0)] <<  " " << u1[][Rh(k,1)]  <<" " << u1[][Rh(k,2)]  << " " << u1[][Rh(k,2)] << endl;
// cout << u1[] << endl;

Vh P,Q;
Ph p,q; 
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //
macro Grad(u) [dx(u),dy(u),dz(u)]  //

// Laplace resolution
real timeLapl = clock();
{
/*
problem laplace(P,Q,solver=CG) = 
  int3d(Th) ( Grad(P)'*Grad(Q)) //') for emacs
  - int3d(Th)(f*Q) 
  + on(1,P=gd) 
  - int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q);
*/
// matrix resolution
varf vlap(P,Q) = int3d(Th) ( Grad(P)'*Grad(Q))+on(1,P=gd); //') for emacs

varf vsdc(P,Q) = int3d(Th)(f*Q) + int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q)+ on(1,P=gd);

matrix Mlap=vlap(Vh,Vh,solver=sparsesolver);
real[int] sdc=vsdc(0,Vh);
/*
varf vtot(P,Q) = int3d(Th) ( Grad(P)'*Grad(Q)) +int3d(Th)(f*Q) + int2d(Th,2) ( (g1n*N.x+g2n*N.y+g3n*N.z)*Q)+ on(1,P=gd); //') for emacs

matrix Mlap = vtot(Vh,Vh,solver=CG);
real[int] sdc = vtot(0,Vh);
*/
P[] = Mlap^-1*sdc;
}
timeLapl = clock()-timeLapl;

// some verification of Boundary condition
fespace RPh(Th,[RT03d,P0]);

varf von1([u1,u2,u3,p],[v1,v2,v3,q])  = 
   int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 - int3d(Th) ( f*q)
 + int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);

RPh [vv1,vv2,vv3,qq];
// some verification Boundary Condition
// and interpolation ...
real[int]  ron=von1(0,RPh);
vv3[]=von1(0,RPh);
cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << endl;
[vv1,vv2,vv3,qq]=[g1n,g2n,g3n,100];
[v1,v2,v3]=[g1n,g2n,g3n];

cout << " vv: = " << vv1(.1,.2,.001)  << " " << vv2(.1,.2,.001) << " " << vv3(.1,.2,.001) << " " << qq(.1,.2,.001) << endl;
cout << " v : = " << v1(.1,.2,.001)  << " " << v2(.1,.2,.001) << " " << v3(.1,.2,.001)  << endl;

// end of verification of Boundary Condition ... 


/*
problem laplaceMixte([u1,u2,u3,p],[v1,v2,v3,q],solver=sparsesolver,tgv=1e30,sparams="nprow=1, npcol="+mpisize, dimKrylov=400) = 
int3d(Th)( p*q*1e-15+ u1*v1 + u2*v2 + u3*v3 + p*div(v1,v2,v3) + div(u1,u2,u3)*q )
 + int3d(Th) ( f*q)
 - int2d(Th,1)( gd*(v1*N.x +v2*N.y + v3*N.z) )  //  int on gamma 
 + on(2,u1=g1n,u2=g2n,u3=g3n);
*/

RPh [uu1,uu2,uu3,pp];
//RPh [v1,v2,v3,q];

real tMatrix=clock();
varf vlaplaceMixte([uu1,uu2,uu3,pp],[v1,v2,v3,q]) = int3d(Th)( pp*q*1e-15+ uu1*v1 + uu2*v2 + uu3*v3 + pp*div(v1,v2,v3) + div(uu1,uu2,uu3)*q )+on(2,uu1=g1n,uu2=g2n,uu3=g3n);
matrix MlaplaceMixte = vlaplaceMixte(RPh,RPh,tgv=ttgv,solver=sparsesolver);
tMatrix=clock()-tMatrix;

real tFact=clock();
set(MlaplaceMixte,solver=sparsesolver,tgv=ttgv,sparams=ssparams);
tFact=clock()-tFact;

real tscd=clock();
varf vsdcLM([uu1,uu2,uu3,pp],[v1,v2,v3,q]) = -int3d(Th) ( f*q) + int2d(Th,1)( gd*(v1*N.x+v2*N.y + v3*N.z) )+on(2,uu1=g1n,uu2=g2n,uu3=g3n);
real[int] sdcLM = vsdcLM(0,RPh);
tscd=clock()-tscd;

real tsolve=clock();
uu1[] = MlaplaceMixte^-1*sdcLM;
tsolve=clock()-tsolve;

cout << "=============================" << endl;
cout << "CPU TIME Lapl: " << timeLapl << endl;
cout << "=============================" << endl;

cout << "=============================" << endl;
cout << "CPU TIME Lapl Mixte:         " << endl;
cout << " matrix         "<< tMatrix << endl;
cout << " factorization  "<< tFact   << endl;
cout << " second menber  "<< tscd    << endl;
cout << " solving        "<< tsolve  << endl;
cout << "=============================" << endl;

//if(mpirank==0){
real errL2=sqrt(int3d(Th)(square(P-pp))) ;
cout << " int 2 x,yz "<<int2d(Th,2)(x) << " " << int2d(Th,2)(y) << " " << int2d(Th,2)(z) << endl;
cout << " int 2 gn "<<int2d(Th,2)(g1n) << " " << int2d(Th,2)(g2n) << " " << int2d(Th,2)(g3n) << endl;
cout << " int 2 U  "<<int2d(Th,2)(uu1) << " " << int2d(Th,2)(uu2) << " " << int2d(Th,2)(uu3) << endl;
cout << " int 2 V  "<<int2d(Th,2)(v1) << " " << int2d(Th,2)(v2) << " " << int2d(Th,2)(v3) << endl;
cout << " int 2 DP "<<int2d(Th,2)(dx(P)) << " " << int2d(Th,2)(dy(P)) << " " << int2d(Th,2)(dz(P)) << endl;
  
cout << "  diff: u Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (uu1*N.x +uu2*N.y + uu3*N.z) ) ) ) <<endl;
cout << "  diff: P Gamma_2 " <<    sqrt(int2d(Th,2) ( square((g1n*N.x+g2n*N.y+g3n*N.z) - (dx(P)*N.x +dy(P)*N.y + dz(P)*N.z) ) ) ) <<endl;
cout << " diff err L2 :" << errL2 << endl;
cout << "    P     L2 :" <<sqrt(int3d(Th)(square(P))) << endl;
cout << "    p     L2 :" <<sqrt(int3d(Th)(square(pp))) << endl;
assert(errL2<0.05);
//}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4


verbosity=2;
cout << " rank = " << mpirank << " " << " size " << mpisize << endl;
cout << " rank = " << mpiRank(mpiCommWorld) << " " << " size " << mpiSize(mpiCommWorld) << endl;
if(mpisize>4)
  { 
    int[int] procs=[1,4];
    mpiGroup gpr(procs);
    cout << " before  ...  " << mpirank << endl;
    mpiComm comm(gpr);
    cout << " after ...  " << mpirank << "  in : " << bool(comm)   
	 << " rank " << mpiRank(comm) << " / " << mpiSize(comm) <<endl;
    mpiComm  n0comm(mpiCommWorld,mpirank%3,0);// MPI_Comm_split
    mpiComm  n1comm(mpiCommWorld,mpirank%3,1);// MPI_Comm_split
    mpiComm  n2comm(mpiCommWorld,mpirank%3,2);// MPI_Comm_split
    if( ! n1comm)  // not in n1comm 
      {
	// MPI_Intercomm_create constructor 
	mpiComm  nicomm(processor(n1comm,1),processor(n2comm,2),1000); 
	mpiComm  n12comm(nicomm,true);  // MPI_Intercomm_merge cosntructor 
      }
  }

if ( mpirank<2 && mpisize>=2)
  { 
    
    if( mpirank==0) 
      {
	cout << mpirank << " send to 1 " << endl;
	processor(1) << 123456; //  unblock send
      }
    else if (mpirank==1) 
      {
	int k;
	processor(0) >> k; // block recv 
	cout << " recived " << k << endl;
      }
    {
      // UnBlock communication 
      mpiRequest rq;
      if( mpirank==0) 
	{
	  Isend(processor(1,rq),16.);
	  mpiWait(rq);// Send
	}
      else if (mpirank==1) 
	{
	  real  k;
	  Irecv(processor(0,rq),k);
	  mpiWait(rq);// Recv 
	  assert(k==16.);// verif..
	}
    }


    {
    //  Block Communication
      if( mpirank==0) 
	  Send(processor(1),16.);
      else if (mpirank==1) 
	{
	  real  k;
	  Recv(processor(0),k);
	  assert(k==16.);// verif..
	}
    }

  }
int l= mpirank+100;
cout << " l == " << l << " broadcast l from 0   mpirank = " << mpirank << endl;
broadcast(processor(0),l);
cout << " l == " << l << "  mpirank ="<< mpirank << endl;

{
matrix<complex> A;
matrix<complex>[int]  B(10);
if( mpirank==0)
   A=[[1+1i,1i],[0,2-1i],[0,2-1i]];
broadcast(processor(0),A);


if (mpirank==1)
  { A=A+A;
    processor(0) << A;
  }
 else if (mpirank==0)
   processor(1) >>  B[3];

cout << " mpirank = " << mpirank << " A =  " << endl;
if (mpirank==0)
cout <<  " **** " <<  B[3] << endl;

cout << " " <<  norm(A(1,1) - 2-1i) << endl;
mpiRequest rr;
if (mpirank==1) Isend(processor(0,mpiCommWorld,rr),A);
else if (mpirank==0) Irecv(processor(1,mpiCommWorld,rr),B[3]);
mpiWait(rr);
if (mpirank==0)  cout << " B3= " << B[3] << endl;
if (mpirank==1)  cout << " A= " << A << endl;
}

// asyncronous  send/recv  messages....
mpiRequest rr;
real[int] vv(mpirank*mpisize:mpirank*mpisize+mpisize-1),ww(mpisize);
processor(0,rr) << vv;
if(mpirank==0)
  {
    mpiRequest[int] rq(mpisize);
    cout << " --- in ++ " <<mpisize << endl;
    for (int i=0;i<mpisize;++i)
       processor(i,rq[i]) >> ww;
    cout << " --- out ++ " <<mpisize << endl;

    int k=0;
    for (int i=0;i<mpisize;++i)
      {
	int k= mpiWaitAny(rq);
	cout << k << "  mpiWaitAny " << ww << endl; 
      }
  }
cout << " mpiWait " << mpiWait(rr) << " " << mpirank << endl;
//  a way to get data from any proc ... 
processor(0,rr) << vv;
if(mpirank==0)
  {
    for (int i=0;i<mpisize;++i)
      {
	processor(-1) >> ww;  
	cout << " case " << i << "   " <<  ww[0] << endl ;
      }
  }


mpiAlltoall(vv,ww);
cout << " all2all " << mpirank << " :  "  ;
for(int i=0;i<mpisize;i++) 
  cout << vv[i] << " ";
cout << " -> "  ;
for(int i=0;i<mpisize;i++) 
  cout << ww[i] << " ";
cout << endl; 


real s0=mpiWtime();
real[int,int] aa(10,mpisize),bb(10,mpisize);
real [int,int] ss(10,mpisize);
for(int i=0;i<10;i++)
  for(int j=0;j<mpisize;j++) 
    aa(i,j)=100*i+j;
mpiAlltoall(aa,bb);
mpiAlltoall(aa,bb,mpiCommWorld);
mpiAllgather(aa(:,mpirank),ss);
if(mpirank == 1) // just printing the result of one process ..
    cout << " AllGather " << ss << endl;
mpiGather (aa(:,mpirank),ss,processor(0,mpiCommWorld));
if(mpirank == 0)
    cout << " Gather " << ss << endl;

mpiScatter(aa,bb(:,mpirank),processor(0,mpiCommWorld));

cout << " all2all " << mpirank << " " << mpiWtime()-s0 << "s :  "  ;
cout << mpirank << " aa = " << aa << endl;
cout << mpirank << " bb = " << bb << endl;


mpiBarrier(mpiCommWorld);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "MUMPS_mpi"  // load the library dynamic correspond to MUMPS interface
verbosity = 0;
int[int] ICNTL(40); // declaration of ICNTL parameter for MUMPS

// get value of ICNTL from file
if(mpirank == 0)
{
	ifstream ff("ffmumps_fileparam.txt");
	string line;
	getline(ff,line);
	getline(ff,line);
	for(int iii=0; iii<40;iii++){
	ff >> ICNTL[iii];
	getline(ff,line);
	}
}

broadcast(processor(0),ICNTL);

// Given data of MUMPS solver in array lparams(SYM,PAR,ICNTL)
// There is no symmetric storage for a matrix associated with a sparse solver.
// Therefore, the matrix will be considered unsymmetric for parallel sparse solver even if symmetric.
// This fact will be change in new version of FreeFEM
{
    int SYM = 0;
    int PAR = 1;
    matrix A =
      [[ 40,  0,     45,  0, 0],
       [ 0,    12,     0,  0 , 0],
       [ 0,     0,  40,  0, 0],
       [ 12,     0,    0,  22, 0],
       [ 0,     0,    20,  0., 22]];

    // construction of integer parameter for MUMPS
    int[int] MumpsLParams(42);
    MumpsLParams[0] = SYM;
    MumpsLParams[1] = PAR;
    for(int ii=0; ii< 40; ii++) MumpsLParams[ii+2] = ICNTL[ii]; // ICNTL begin with index 0 here

    real[int] xx = [ 1,32,45,7,2], x(5), b(5), di(5);
    b=A*xx;
    if(mpirank ==0) cout << "xx=" << xx << endl;

    set(A,solver=sparsesolver,lparams=MumpsLParams); // We take the default value for CNTL MUMPS parameter

    if(mpirank ==0)  cout << "solving solution" << endl;
    x = A^-1*b;
    if(mpirank ==0) cout << "b=" << b << endl;
    if(mpirank ==0) cout << "x=" << endl; cout << x << endl;
    di = xx-x;
    if(mpirank==0){
    cout << "x-xx="<< endl; cout << "Linf "<< di.linfty << " L2 " << di.l2 << endl;
    }
}

// FFCS - reference value for regression tests
real regtest;

// Read parameter of MUMPS solver in file ffmumps_fileparam.txt

{
matrix A =
      [[ 40,  0,     45,  0, 0],
       [ 0,    12,     0,  0 , 0],
       [ 0,     0,  40,  0, 0],
       [ 12,     0,    0,  22, 0],
       [ 0,     0,    20,  0., 22]];


    real[int] xx = [ 1,32,45,7000,2], x(5), b(5), di(5); // xb(4),bbb(4);
    b=A*xx;
    cout << "b="  << b  << endl;
    cout << "xx=" << xx << endl;

    set(A,solver=sparsesolver);

    cout << "solving solution" << endl;
    x = A^-1*b;

    cout << "b=" << b << endl;
    cout << "x=" << endl; cout << x << endl;
    di = xx-x;
    if(mpirank==0){
    cout << "x-xx="<< endl; cout << "Linf "<< di.linfty << " L2 " << di.l2 << endl;
    regtest=di.l2;
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// time on 4 proc times: compile 0.013393s, execution 2.28842s,  mpirank:0
// time on 1 proc times: compile 0.012316s, execution 4.92302s,  mpirank:0
// NBPROC 4

load "MUMPS_mpi"

verbosity=0; 
real ttgv=1e30;

/*
  Incompressible Navier Stokes 
    with Taylor-Hood Finite element
    No linearity : Newton methode 
    continuation on Reynols Number
    Mesh adaptation 
*/
real  reymax = 9000; // ok < 125000 
mesh Th=square(8,8);
Th=change(Th,fregion=nuTriangle%mpisize); 
fespace Xh(Th,P2);
fespace Mh(Th,P1);
fespace XXMh(Th,[P2,P2,P1]);
XXMh [u1,u2,p];
XXMh [v1,v2,q]; 

macro div(u1,u2) (dx(u1)+dy(u2))//
macro grad(u1,u2) [dx(u1),dy(u2)]//
macro ugrad(u1,u2,v) (u1*dx(v)+u2*dy(v)) //
macro Ugrad(u1,u2,v1,v2) [ugrad(u1,u2,v1),ugrad(u1,u2,v2)]//

solve Stokes ([u1,u2,p],[v1,v2,q],solver=sparsesolver,tgv=ttgv,master=-1) =
    int2d(Th,mpirank)( ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*div(v1,v2)-q*div(u1,u2)
           )
  + on(3,u1=4*x*(1-x),u2=0) 
  + on(1,2,4,u1=0,u2=0);

 Xh uu1=u1,uu2=u2;  
if(mpirank==0)
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[uu1,uu2],wait=0);

Xh psi,phi;


solve streamlines(psi,phi,master=-1) = 
      int2d(Th,mpirank)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
   +  int2d(Th,mpirank)( -phi*(dy(u1)-dx(u2)))
   +  on(1,2,3,4,psi=0);
if(mpirank==0)
plot(psi,wait=0);
int i=0;
real  nu=1./100.;
real dt=0.1;
real alpha=1/dt;



/* NL 
 varf   vNS ([u1,u2,p],[v1,v2,q],solver=Crout,init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
            + Ugrad(u1,u2,u1,u2)'*[v1,v2]
           )   
  + on(3,u1=1,u2=0) 
  + on(1,2,4,u1=0,u2=0) 
*/

XXMh [up1,up2,pp];
varf   vDNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th,mpirank)(
            
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +  dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            + p*dx(v1)+ p*dy(v2)
            + dx(u1)*q+ dy(u2)*q
            + Ugrad(u1,u2,up1,up2)'*[v1,v2]
            + Ugrad(up1,up2,u1,u2)'*[v1,v2]
           )
  + on(1,2,3,4,u1=0,u2=0) 
;


varf   vNS ([u1,u2,p],[v1,v2,q]) =
    int2d(Th,mpirank)(
          
            + nu * ( dx(up1)*dx(v1) + dy(up1)*dy(v1)
            +  dx(up2)*dx(v2) + dy(up2)*dy(v2) )
            + pp*q*(0.000001) 
            + pp*dx(v1)+ pp*dy(v2)
            + dx(up1)*q+ dy(up2)*q
            + Ugrad(up1,up2,up1,up2)'*[v1,v2]//'
	      )
  + on(1,2,3,4,u1=0,u2=0) 
  ;

for(real re=100;re<=reymax;re *=2)
  { 
    
    real lerr=0.04;
    
    if(re>8000) lerr=0.01;
    if(re>10000) lerr=0.005; 
    for(int step=0;step<2;step++)
      {
		  
	   if( mpirank==0) {
		    Th=change(Th,fregion=1);
			Th=adaptmesh(Th,[u1,u2],p,err=lerr,nbvx=100000);
		    Th=change(Th,fregion=nuTriangle%mpisize);			
		   } 
	    broadcast(processor(0),Th);
      
	//plot(Th,wait=0);
	[u1,u2,p]=[u1,u2,p];
	[up1,up2,pp]=[up1,up2,pp];
	
	for (i=0;i<=20;i++)
	  {
	    nu =1./re;
	    up1[]=u1[];
	    real[int] b = vNS(0,XXMh);
	    matrix Ans=vDNS(XXMh,XXMh,tgv=ttgv);
	    set(Ans,solver=sparsesolver,master=-1);
	    real[int] w = Ans^-1*b;
	    u1[] -= w;
	    if( mpirank==0)  cout << step << " iter = "<< i << "  " << w.l2 <<  " rey = " << re << endl;
	    if(w.l2<1e-6) break; 
	    // uu1=u1;uu2=u2;
	    //plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[uu1,uu2]);  
	    
	  } ;
      }
    uu1=u1;uu2=u2;
    streamlines;
    if( mpirank==0) 
    plot(coef=0.2,cmm="rey="+re+" [u1,u2] et psi  ",psi,[uu1,uu2],wait=0,nbiso=20,ps="cavity-"+re+".ps");  
  }
  
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

include "getARGV.idp"
include "cube.idp"
load "metis"
load "parmetis"
load "medit"
int[int] Nxyz = [getARGV("-global", 50), getARGV("-global", 50), getARGV("-global", 50)];
real[int,int] Bxyz = [[0.0, 1.0], [0.0, 1.0], [0.0, 1.0]];
int[int,int] Lxyz = [[1, 2], [2, 2], [2, 2]];
mesh3 Th = Cube(Nxyz, Bxyz, Lxyz);
fespace Ph(Th, P0);
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    if(mpirank == 0)
        metisdual(part[], Th, getARGV("-lpart", mpisize));
    broadcast(processor(0, mpiCommWorld), part[]);
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "METIS: " << mpiWtime() - time << endl;
        medit("METIS", Th, part);
    }
}
{
    mpiBarrier(mpiCommWorld);
    real time = mpiWtime();
    Ph part;
    parmetis(part[], Th, getARGV("-lpart", mpisize), communicator = mpiCommWorld, worker = getARGV("-worker", mpisize));
    mpiBarrier(mpiCommWorld);
    if(mpirank == 0) {
        cout << "ParMETIS: " << mpiWtime() - time << endl;
        medit("ParMETIS", Th, part);
    }
}
// NBPROC 4
// ff-mpirun -np 4 DDM-Schwarz-Lap-3d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES2d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer2d.idp"
include "DDM-funcs-v2.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",10);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=1; // size of overlap
bool RAS=1; // select kind of  of $\pi_i$ 


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;


string sPk="P2-Lame-2gd";     
func Pk=[P2,P2];
 
func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh,Pk, defPk2, Th, u, allu1, { cmm=cm,nbiso=10,fill=1,dim=3,value=1}); return 1;}


mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[2,2,2,1]; 
settt 

mesh Thg=square(nloc*4,nloc,[x*4,y],label=l111);
mesh ThC=square(nC*4,nC,[x*4,y],label=l111);//   Coarse Mesh
fespace VhC(ThC,[P1,P1]); // of the coarse problem.. 

BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh,Pk,2,[0,1],Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)





/* the definition of the Problem .... */


// the definition of the Problem ....
real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2)  [dx(u1),dy(u2),(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2) ( dx(u1)+dy(u2) ) // EOM
  
varf vPb([u1,u2],[v1,v2])=
  int2d(Thi)(  
	    lambda*div(u1,u2)*div(v1,v2)	
	    +2.*mu*( epsilon(u1,u2)'*epsilon(v1,v2) ) //')
	      )
  + int2d(Thi) (gravity*v2)
  + on(1,10,u1=0,u2=0)
  ;
  
varf vPbC([u1,u2],[v1,v2])=
  int2d(ThC)(  
	    lambda*div(u1,u2)*div(v1,v2)	
	    +2.*mu*( epsilon(u1,u2)'*epsilon(v1,v2) ) //')
	      )
  + on(1,u1=0,u2=0)
  ;

varf vPbon10([u1,u2],[v1,v2])=on(10,u1=1,u2=1)+on(1,u1=0,u2=0);
varf vPBC(U,V)=on(1,U=0);



real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Lame2,comm,jpart,Whi,Vhc,2,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0,1])

Lame2CheckUpdate();
  
Whi [u,u1],[v,v1];
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lame2DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lame2kiter <<  endl;
}

Lame2Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
/*	Companion script of
	Golse, F., Hecht, F., Pironneau, O., Tournier, P. H., & Smets, D. (2022). Radiative Transfer For Variable 3D Atmospheres. arXiv preprint arXiv:2208.06410.

	This script also illustrates the use of the Htool Hierarchical Matrix library to compress a dense matrix stemming from a custom user-defined operator defined in a user C++ FreeFEM plugin.

	This can be done by defining and interfacing a Generator class deriving from the virtual class VirtualGenerator of Htool. This is done here in the C++ plugin "RadiativeTransfer_htool.cpp". The Generator object can then be created in the FreeFEM script through the user-defined constructor, for example here taking a mesh3, a meshS, one vector and a new user-defined type KappaGrid (also defined in the plugin) as parameters:

	Generator GenSE(Th3t,ThS,seeface,kappag);
	
	The Generator can then be passed to Htool through the Build() function, which returns the compressed H-Matrix built by Htool from the user-defined copy_submatrix (or get_coef) routine of the Generator computing the matrix coefficients:

	HMatrix HSE = Build(GenSE,VhS,Vht,eta=100,eps=1e-2,minclustersize=10,maxblocksize=1000000

	To launch:  ff-mpirun -np 8 chamonix.edp -ns -wg -Kmax 9

	In order to run the test cases from the paper, you can download the original mesh at https://freefem.org/misc/chamonix_100K_surf.meshb , change the file in the readmesh command, and run with argument '-fullmesh':
	wget https://freefem.org/misc/chamonix_100K_surf.meshb
	ff-mpirun -np 8 chamonix.edp -ns -wg -Kmax 9 -fullmesh -n 15
*/

load "msh3"
load "bem"
load "RadiativeTransfer_htool"
load "qf11to25"
load "medit"
load "iovtk"
load "mmg"
load "shell"

include "getARGV.idp"

verbosity=0;

/********************* SCRIPT PARAMETERS *********************/
int dc = 1, 							// samples every dc points in the nu integrals (speedup with dc>1, danger)
	Newton = 30,						// max Newton iter for the tempe eq
	n = getARGV("-n", 10),				// controls the number of vertices in the mesh
	Niter = 7,  						// outerloop for convergence
	Kmax = getARGV("-Kmax", 9), 		// 1 if kappa constant // in [2,10] otherwise
	gamma = getARGV("-gamma", 0), 		// incidence of sunlight (0 is vertical, 1 is morning and -1 evening)
	heat = 0, 							// if 1, temperature eq is solved 
	nosnow = getARGV("-nosnow", 0), 	// 0 or 1 if no snow
	cloud = getARGV("-cloud", 0), 		// 0 or 1 if cloud
	altkappa = getARGV("-altkappa", 0);	// if 1 (resp-1) Kappa is changed in a range for CO2 (resp CH4)

real sal = 10*nosnow+0.25, beta=0.3, 	// snow altitude limit and snow albedo
	Tsun=1.209, Q0=2.0e-5, sigma=sqr(sqr(pi))/15; // the Sunlight

/********************* OUTPUT FILES *********************/
string basedir("chamonix-output/");
if(mpirank==0) mkdir(basedir);
string tempestr("noon");
if (gamma == 1) tempestr = "morning";
if (gamma == -1) tempestr = "evening";
if (nosnow) tempestr = tempestr + "nosnow";
if (cloud) tempestr = tempestr + "cloud";
if (heat) tempestr = tempestr + "heat";
if (Kmax > 1) tempestr = tempestr + "K";  // res file non grey have a xx.K
if (Kmax > 1 && altkappa>0) tempestr = tempestr + "K";  // res file have a xx.KK
if (Kmax > 1 && altkappa<0) tempestr = tempestr + "KK"; // res file have a xx.KKK

int mem = storageused(); // memory used at this stage
/********************* BUILD THE MESH *********************/
mesh3 Th3;

if (mpirank == 0)
{
	// read the surface mesh of the Chamonix valley:
	meshS Thf = readmeshS("chamonix_surf.meshb");
	//meshS Thf = readmeshS("chamonix_100K_surf.meshb"); // uncomment to use the original fine mesh ; you can download it at https://freefem.org/misc/chamonix_100K_surf.meshb
	// build the volume mesh above the valley:
	real[int] bb(6);
	boundingbox(Thf, bb);
	int nn = 5*n;

	mesh Th2 = movemesh(Thf,transfo=[x,y]); // flatten the mesh, will be the input of buildlayers
	fespace Vhf(Thf, P1);
	fespace Vh2(Th2, P1);
	Vhf zzf = z;
	Vh2 z2;
	z2[] = zzf[]; // get the altitude as a P1 function on the flattened 2D mesh
	
	bool fullmesh = usedARGV("-fullmesh") != -1; // use the original fine adapted surface mesh ; beware, expensive case !
	if (!fullmesh) Th2 = square(nn, nn, [bb[0]+x*(bb[1]-bb[0]),bb[2]+y*(bb[3]-bb[2])]);
	z2 = z2;

	real zmin = z2[].min, zmax = 1;
	plot(z2);

	int[int] l23 = [1,1,2,2,3,3,4,4], lup = [0,6], lbot = [0,5];
	real hx = (bb[1]-bb[0])/nn;
	int nnz = fullmesh ? 5 : (zmax-zmin)/hx;

	func cc = (zmax-z2)/(zmax-zmin);
	Th3 = buildlayers(Th2, coef=cc, nnz, zbound=[z2,zmax],
		labelmid=l23, labelup=lup, labeldown=lbot);
	
	int[int] reqt=[5];
	
	if (fullmesh) Th3 = mmg3d(Th3,requiredTriangle=reqt,hmin=hx,hmax=hx,hgrad=1.5,mem=8192);
}
broadcast(processor(0),Th3);

real[int] bounds(6); // Domain bounds
boundingbox(Th3, bounds);
if (mpirank == 0) cout<< "x,y,z bounds: " << bounds << endl;

int[int] labRT = [5]; // emitting boundary
meshS ThS = extract(Th3, label=labRT, angle=pi); // extract as a surface mesh
if (mpirank == 0) cout << "Number of Vertices = " << Th3.nv << endl;
fespace Vh(Th3, P1);
fespace VhS(ThS, P1);

/********************* READ KAPPA[nu] *********************/
int Nnu = 483; // number of frequencies, will be augmented by 200
real[int] nu(200+Nnu), kappa(200+Nnu);
ifstream kappafile("geminitransmittance.txt");
int j =- 1;
while (j++ < Nnu-1) {
	real auxx, kappaux, nuj;
	kappafile >> nuj >> kappaux >> auxx >> auxx >> auxx;
	kappa[200+j] = 1 - min(1.,max(0.,kappaux)); // necessary
	nu[200+j] = nuj;
	if (altkappa<0 && nuj > 3/4. && nuj < 3/3.) kappa[200+j]=1;
	if (altkappa>0 && nuj > 3/18. && nuj < 3/14.) kappa[200+j]=1;
}
for (int j=0; j<200; j++) { nu[j] = 0.01+(nu[200]-0.01)*j/200.; kappa[j] = kappa[200]; }
Nnu += 200;
real kappa0=0;
for (int j=0; j<Nnu; j++) kappa0 += kappa[j]/Nnu;  // mean kappa is used in Newton steps
// kappa is kappa[nu]*rhof(x,y,z), but integrals are sampled by kappaApprox[K]*rhof(x,y,z)
real[int] kappaApprox(Kmax); // kappa(nu,x) = kappaApprox(K(nu))*rhof(x)  cf Lebesgue integral
for (int K=0; K<Kmax; K++) kappaApprox[K] = 1-real(K)/Kmax; // grey case: kappaApprox[0]=1

int[int] kappaInK(Kmax); // detect if kappa in (kappaApprox[K],kappaApprox[K-1])
kappaInK[0] = (Kmax==1); // used for the grey case
for (int K=1; K<Kmax; K++) {
	kappaInK[K]=0;
	for (int k=0; k<Nnu-dc-1; k+=dc) // every dc points
	if ( (kappa[k]>kappaApprox[K]) && (kappa[k]<=kappaApprox[K-1]) )
		kappaInK[K] = 1;
	if (mpirank == 0)
		cout << K << "K kappaApprox " << kappaApprox[K] << " " << kappaInK[K] << " " << kappaApprox[K-1] <<endl;
}

/********************* DEFINE the x-dependence of kappa, called rho *********************/

func rhof = (0.5-z*0.25) * (1 + (Kmax > 1)) * (1 + cloud * (1+0.5*(z>0.2)*(z<0.8)*(sqr(x-1.5)+sqr(y+1.5)<0.5)) );

Vh rhox = rhof; // rhox is the P1 function equal to rhof
real surf = int3d(Th3)(1.);
if (mpirank == 0) cout << "arithmetic mean of kappa(nu)*rhof = " << kappa0*int3d(Th3)(rhox)/surf << endl << endl;
 
/********************* DEFINE WIND *********************/
Vh u1, u2, u3, dT, dTh;
/*
{
ifstream velocity1("maillageCham/velocity1.txt");
ifstream velocity2("maillageCham/velocity2.txt");
ifstream velocity3("maillageCham/velocity3.txt");
velocity1 >> u1[];
velocity2 >> u2[];
velocity3 >> u3[]; 
if (mpirank==0) plot(u2, wait=1);
}
*/
u2 = 1*z; u1 = 0; u3 = 0;

/********************* Light is x cos(angle with normal)^-. Stored in seeface *********************/
VhS Q0S = Q0*(beta+(1-beta)*(z<sal)); // snow
varf vseeface(u,v) = int2d(ThS,qft=qf1pTlump)(Q0S*(Ns.z+gamma*(Ns.x-0.2*Ns.y))*v/sqrt(1+0.04*gamma*gamma));
real[int] seeface = vseeface(0,VhS);
varf vlump(u,v) = int2d(ThS,qft=qf1pTlump)(v);
real[int] blump = vlump(0,VhS);
seeface ./= blump;
for [i, bi : seeface] bi = -min(bi,0.);

/********************* Interpolation operator from Th3 to ThS *********************/
Vh onGamma;
{
       onGamma[] = -1;
       matrix R = interpolate(VhS,Vh);
       int[int] I(1),J(1);
       real[int] K(1);
       [I,J,K] = R;
       for (int i=0; i<I.n; i++)
               if (K[i] > 0.5) onGamma[][J[i]] = I[i];
}

/********************* Define truncated volume mesh Th3t (without the surface) *********************/
// Th3t will be used to remove surface-surface interactions from the boundary operator,
// as they will be treated separately.

fespace Ph0(Th3,P0);
varf vGamma(u,v) = int3d(Th3)(u*v);
matrix RGamma = vGamma(Vh, Ph0);
Ph0 tGamma;
Vh onG = (onGamma == -1 ? 0 : 1);
tGamma[] = RGamma*onG[];
mesh3 Th3t = trunc(Th3, tGamma == 0);
fespace Vht(Th3t,P1);

matrix Rt = interpolate(Vht,Vh); // restriction matrix from Th3 to Th3t

/********************* BUILD H-Matrices *********************/
verbosity = 1;
HMatrix[int] HVolume(Kmax); // The Volume integral matrices
Vh[int] SE(Kmax); // The surface integral vector operator

Vht SEt;
VhS ones = 1;

for (int K=min(Kmax-1,1); K<Kmax; K++)
if (kappaInK[K]) {
	KappaGrid kappag(bounds,0.01,kappaApprox[K-(K>0)]*rhof);

	// We use the truncated volume mesh Th3t (without the surface) for the boundary operator,
	// as we use an analytic formula for surface-surface interactions
	Generator GenSE(Th3t,ThS,seeface,kappag);
	HMatrix HSE = Build(GenSE,VhS,Vht,eta=100,eps=1e-2,minclustersize=10,maxblocksize=1000000);
	if (mpirank == 0) cout << HSE.infos << endl; 
	display(HSE);
	SEt[] = HSE*ones[]; // SE = \int_ ((x-x').n) exp(-\int_(x,x')kappa(nu,x'))/|x-x'|^3
	SE[K][] = Rt'*SEt[]; // extend the result from truncated Vht to Vh
	// use an analytic formula for surface-surface interactions:
	for [i,bi:SE[K][]] if (onGamma[][i] > -0.5) bi = 0.25*seeface[int(onGamma[][i]+0.5)];

	Generator GenVolume(Th3,kappag);
	HVolume[K] = Build(GenVolume,Vh,Vh,eta=100,eps=1e-2,minclustersize=10,maxblocksize=1000000);
	if (mpirank == 0) cout << HVolume[K].infos << endl; 
	display(HVolume[K]); // = \int_Omega kappa(nu,x') exp(-\int_(x,x')kappa(nu,x'))/|x-x'|^2
}

/********************* OUTER LOOP *********************/ 
Vh T = 0.01; // initial value of the temperature for iterations
Vh res, sT4=sqr(sqr(T)), J=sT4;

problem heatedp(dT, dTh) = int3d(Th3) (0.02*(dx(dT)*dx(dTh)+dy(dT)*dy(dTh)+dz(dT)*dz(dTh))
		+ (u1*dx(dT)+u2*dy(dT)+u3*dz(dT))*dTh + 15*dT*dTh)
	+ int3d(Th3) (0.02*(dx(T)*dx(dTh)+dy(T)*dy(dTh)+dz(T)*dz(dTh)));

if (Kmax == 1) { /********************* GREY CASE kappaApprox[0] = 1 *********************/
	for (int niter=0; niter<Niter; niter++) {
		sT4 = sigma*sqr(sqr(T));
		res[] = HVolume[0]*sT4[];
		J[] = SE[0][];
		J = J*sigma*sqr(sqr(Tsun));
		J[] += res[];
		T = sqrt(sqrt(abs(J/sigma)));
		if (heat) {
			heatedp;
			T = T + dT;
		}
		sT4 = sT4-J;
		if (mpirank == 0) {
			//plot(J, cmm="J at iter "+ niter, value=1, fill=1);
			plot(sT4, cmm="sT4 at iter "+ niter , value=1, fill=1);
			//plot(T, cmm="T at iter "+ niter, value=1, fill=1);
		}
	}
}
else { /********************* General Nonlinear loop *********************/
	// The method:
	// Let 4 pi J(nu,x) = int_om I dw = \int_(x') exp(-kappa(nu,x')|x'-x|)(angle(N,x'-x))^2Bnu(nu,Tsun)d 
	// 							+ \int_O(x') exp(-kappa(nu,x')|x'-x|)/|x'-x|^2 Bnu(nu,T(x'))dx'
	// get T(x) from : \int_0^ kappa(nu,x) Bnu(nu,T(x)) dnu = \int_0^ kappa(nu,x)J(nu,x)dnu =: J by Newton
	// nu-integrals as double sum: \int_0^ f(kappa(nu),nu)=\sum_K=1..Kmax \sum_k f(nu_k,kappa=K/Kmax)dnu_k
	// = \sum_K=1..Kmax H(kappa)*\sum_k F(K/Kmax,nu)dnu_k   when f=H(kappa)*F(kappa,nu)

	// Note: function Bnu is defined in the C++ plugin instead in order to speed up computations. The function corresponds to:
	// func real Bnu(real nu, real T) {return nu*nu*nu/(exp(nu/T)-1);}

	real[int] BnuTsun(Nnu);
	for (int k=0; k<Nnu-1 ;k++) BnuTsun[k] = Bnu(nu[k],Tsun); // aim is to speed up below
	Vh aux, bux, pres, paux = 0;

	real[int] compint(Vh.ndof);
	varf vint(u,v) = int3d(Th3)(v);
	compint = vint(0,Vh);

	// cut expensive loops into MPI slices for parallel computation
	int[int] sizes(mpisize);
	int[int] offsets(mpisize);
	offsets = 0;
	int chunksize = Vh.ndof%mpisize == 0 ? Vh.ndof/mpisize : Vh.ndof/mpisize + 1;

	for (int i = 0; i < mpisize; i++)
	if (i != mpisize - 1) {
		sizes[i] = chunksize;
		offsets[i] = i*chunksize;
	}
	else {
		sizes[i] = Vh.ndof - i*chunksize;
		offsets[i] = i*chunksize;
	}

	int ii = offsets[mpirank];
	real[int] chunkbuff(sizes[mpirank]), chunkbuff2(sizes[mpirank]);

	for (int niter=0; niter<Niter; niter++){ // Nonlinear loop
		bux=0; J=0;
		for (int K=1; K<Kmax; K++)
		if (kappaInK[K]) {
			real auxs = 0;
			chunkbuff2 = 0;       
			for (int k=0; k<Nnu-dc-1; k+=dc)  // every dc points, can be changed
			if ( (kappa[k]>kappaApprox[K]) && (kappa[k]<=kappaApprox[K-1]) ) {    
				real dnu = nu[k+dc] - nu[k];
				for [i,bi:chunkbuff] bi = rhox[](i+ii)*Bnu(nu[k],T[][i+ii]);
				chunkbuff2 += dnu*kappaApprox[K-1]*chunkbuff; // aux(x) = int_{kappa[k]=K} kappa Bnu(nu,T(x)) dnu
				auxs += BnuTsun[k]*dnu; // auxs = Q0*int_{kappa(nu)=K} Bnu(nu,Tsun) dnu
			}
			mpiAllgatherv(chunkbuff2, aux[], mpiCommWorld, sizes, offsets);
			res[] = HVolume[K]*aux[];
			for [i,bi:chunkbuff] bi = res[][i+ii] + SE[K][][i+ii]*rhox[][i+ii]*kappaApprox[K-1]*auxs;
			mpiAllgatherv(chunkbuff, res[], mpiCommWorld, sizes, offsets);
			bux[] += aux[]; // bux = \sum_K kappa_K \int_{kappa(nu)=K} Bnu(nu[k],T(x))dnu 
			J[] += res[]; // J(x) = int_{kappa(nu)=K} kappa exp(-kappa|x'-x|)/|x'-x|^2 Bnu(nu,T(x)) dnu
		}
		bux = bux - J;
		if (mpirank == 0) {
			//plot(J, cmm="J at n="+ niter ,value=1,fill=1);
			plot(bux, cmm="Bnu-J at n = "+ niter ,value=1, fill=1); // J = bux => converged
		}

		int newton = 0; // Newton iterations for T

		for [i,bi:chunkbuff] bi = sqrt(sqrt(abs(J[][i+ii]/sigma/rhox[][i+ii]/kappa0))); // guess to start Newton
		mpiAllgatherv(chunkbuff, T[], mpiCommWorld, sizes, offsets);

		pres = abs(bux/J-1);
		while (pres[]'*compint > 0.001*surf) {
			if (newton>0) { // compute bux with new T
				chunkbuff2 = 0; 
				for (int k=0; k<Nnu-dc-1; k+=dc) { 
					real dnu = nu[k+dc]-nu[k];
					for [i,bi:chunkbuff] bi = rhox[](i+ii)*kappa[k]*Bnu(nu[k],T[][i+ii]);
					chunkbuff2 += dnu*chunkbuff;
				}
				mpiAllgatherv(chunkbuff2, bux[], mpiCommWorld, sizes, offsets);
			}
			pres = bux/J-1;
			if (mpirank == 0) {
				if (Kmax == 1) {
					paux = rhox*kappaApprox[0]*sigma*T^4; 
					cout << niter << " <- niter, error ->" << int3d(Th3)(bux/paux-1)/surf << endl;
				} 
				else 
					cout << niter << " <- niter, newton ->" << newton << " error = " << pres[]'*compint <<endl;
			}
			pres = abs(bux/J-1);
			// bux=paux; T=sqrt(sqrt(J/(sigma*rhox*kappaApprox[0]))); // error check in the grey case
			// T = T - 0.5*(bux-J)/(4*sigma*rhox*kappa0*T*T*T);
			// Newton relaxation parameter 0.5
			for [i,bi:chunkbuff] bi = T[][i+ii] - 0.5*(bux[][i+ii]-J[][i+ii])/(4*sigma*rhox[][i+ii]*kappa0*T[][i+ii]*T[][i+ii]*T[][i+ii]);
			mpiAllgatherv(chunkbuff, T[], mpiCommWorld, sizes, offsets);
			if (newton++ > Newton) bux=J;
		}

		if (heat) {
			heatedp; T=T + dT;
		}

		plot(T, cmm="T at iter = "+ niter, value=1, fill=1);
	}
	// End of non linear loop

	/********************* Display J_nu(x,y,z) *********************/
	if (Kmax == 9) {
		string lightstr(basedir+tempestr+"light.txt");
		ofstream myfile2(lightstr);
		for (int k=0; k<Nnu-dc-1; k+=dc) { // every dc points, can be changed
			int K = -1; 
			for (int K1=1; K1<Kmax; K1++)
			if ( (kappa[k]>kappaApprox[K1]) && (kappa[k]<=kappaApprox[K1-1]) ) K = K1;
			if (K > 0) {
				for [i,bi:chunkbuff] bi = Bnu(nu[k],T[][i+ii]);
				mpiAllgatherv(chunkbuff, res[], mpiCommWorld, sizes, offsets);
				bux[] = HVolume[K]*res[];
				for [i,bi:chunkbuff] bi = bux[][i+ii] + BnuTsun[k]*SE[K][][i+ii];
				mpiAllgatherv(chunkbuff, J[], mpiCommWorld, sizes, offsets);
				if (mpirank == 0) myfile2 << 3/nu[k] << " " << 1e5*J(0.3,1.5,-1.5) << " " << kappa[k]
					<< " " << int(kappa[k]*10+0.5)/10. << " " << kappaApprox[K-1] << " " << K-1 << " " << k << endl;
			}
		}
	}
}
int tmem = storagetotal(); // max memory used at this stage


/********************* GRAPHICS *********************/
real hx=bounds[1]-bounds[0], hy=bounds[3]-bounds[2], hz=bounds[5]-bounds[4]; // domain size
mesh Tp = square(10*n, 5*n, [bounds[2]+hx*x, bounds[4]+hz*y]);
fespace Vp(Tp,P1);
Vp Temp = 4798*T(1.5,x,y)-273;
plot(Temp, value=1, fill=1);

if (mpirank == 0) {
	ofstream myfile(basedir+tempestr+"tempe.txt");
	real[int] XX(2000), YY(2000);
	int kk = 0;
	for (real Z=bounds[4]; Z<bounds[5];Z+=0.01) {
		real Tx = 4798*T(1.5,-1.5,Z)-273;
		XX[kk] = Z; YY[kk++] = Tx;
		cout << Z << "  " << Tx << endl;
		myfile << Z << "  " << Tx << endl;
	}
	XX.resize(kk); YY.resize(kk);
//	plot([XX,YY], cmm = "T in ["+YY.min+","+YY.max+"]");
}
VhS Ts = 4798*T-273, dTs=4798*dT;
//	plot(u1); plot(u2); plot(u3);
meshS ThS2 = movemesh(ThS,[x,y,2*z]); // to enhance graphics
fespace VhS2(ThS2,P1);
VhS2 Ts2;
Ts2[]= dTs[];
Ts2[] = Ts[];
plot(Ts2,fill=1,value=1);
//if (mpirank == 0) medit("Temperature",ThS2,Ts2);
//	T= 4798*T-273;
//	if (mpirank == 0) medit("Temperature",Th3,T);
int[int] fforder = [1];
if (mpirank == 0) savevtk(basedir+tempestr+".vtk",ThS2,Ts2,order=fforder);
if (mpirank == 0) cout << "file name: " << basedir+tempestr << endl;
if (mpirank == 0) cout << "Memory used (Go) = " << (((tmem-mem)/1000.)/1000.)/1000. << endl;
// NBPROC 2
// ff-mpirun -np 4 DDM-Schwarz-Stokes-2d.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter]  DDM-Schwarz-Stokes-2d.edp   [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer2d.idp"
include "DDM-funcs-v2.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",10);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",0); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
bool RAS=1; 
int sizeoverlaps=1; // size of overlap


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;


string sPk="P2-Stokes-2gd";     
func Pk=[P2,P2,P1];
//int  Pknbcomp=3; 

func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh,Pk, defPk3, Th, u, allu1, { cmm=cm,nbiso=10,fill=1,dim=3,value=1}); return 1;}
func bool  plotMPIallp(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALLU(mesh,Pk, defPk3, Th, u, allu2, { cmm=cm,nbiso=10,fill=1,dim=3,value=1}); return 1;}


mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int ipart= mpiRank(comm); // current partition number 

if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,2,1]; 
settt 

mesh Thg=square(nloc,nloc,[x,y],label=l111);
mesh ThC=square(nC,nC,[x,y],label=l111);//   Coarse Mesh

fespace VhC(ThC,[P2,P2,P1]); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(ipart,mesh,Pk,3,[0,1,-1],Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)





/* the definition of the Problem .... */


// the definition of the Problem ....
// the definition of the Problem ....
func u1bc= (1.-x)*(x)*4.;
// the definition of the Problem ....
macro grad(u) [dx(u),dy(u)] //  
macro div(u1,u2) (dx(u1)+dy(u2)) // 
real nu=1,alpha=0;
varf vPb([u1,u2,p],[v1,v2,q])=
  int2d(Thi)(  
       [u1,u2]'*[v1,v2]* alpha
	   + (   grad(u1)'*grad(v1)
	       + grad(u2)'*grad(v2)
	        ) *nu
	       - div(u1,u2)*q - div(v1,v2)*p +1e-9*p*q)
  + on(10,u1=0,u2=0)	      
  + on(2,u1=u1bc,u2=0)
  + on(1,u1=0,u2=0)
 ;
  
varf vPbC([u1,u2,p],[v1,v2,q])=
  int2d(ThC)(  
       [u1,u2]'*[v1,v2]* alpha
	   + (   grad(u1)'*grad(v1)
	       + grad(u2)'*grad(v2)
	        ) *nu
	       - div(u1,u2)*q - div(v1,v2)*p +1e-9*p*q)	      
  + on(1,2,u1=0,u2=0)
  ;
 
varf vPbon10([u1,u2,p],[v1,v2,q])=on(10,u1=1,u2=1)+on(1,2,u1=0,u2=0);
varf vPBC(U,V)=on(1,2,U=0);




real[int] onG10 = vPbon10(0,Whi); // on 1 on 10 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Stokes2,comm,jpart,Whi,Vhc,3,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0,1,-1])


  
Whi [u,u1,p],[v,v1,q];
 

u[]=vPb(0,Whi,tgv=1); 
real eps=1e-10;
Stokes2DDMSolver(Bi,u,v,gmres,eps,vdebug)


plotMPIall(Thi,v[],"u-final");
plotMPIallp(Thi,v[],"p-final");
{  //  update the pressure 
   /* find c_i such that 
    i,j  (O_i \cap O_j)  int(O_i \cap O_j) (p_i -  c_i - p_j + c_j) = 0
    int (O_i \cap O_j) (c_i - c_j) = int (O_i \cap O_j) p_i - p_j ;  
   */
   1;
}

real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Stokes2kiter <<  endl;
}

Stokes2Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
// NBPROC 10
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter]  DDM-Schwarz-Lap-2dd.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "MPIplot.idp"
include "DDM-Schwarz-macro.idp"
//include "AddLayer2d.idp"
include "DDM-funcs-v2.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
// 0 by default

assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",1);
int nloc = getARGV("-n",10);
string sff=getARGV("-p","");
int gmres=getARGV("-gmres",3); 
int nC = getARGV("-N" ,max(nloc/10,5)); 
int sizeoverlaps=getARGV("-overlap" ,1); ; // size of overlap
bool RAS=getARGV("-RAS",1);  // Global Variable ..



if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

string sPk="P2-2gd";     
func Pk=P2;

func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALL(mesh,Pk, Th, u,{ cmm=cm,nbiso=20,fill=1,dim=3,value=1}); return 1;}

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 


int iiipart= mpiRank(comm); // current partition number 


if(iiipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,2,2,2]; 
settt 

mesh Thg=square(nloc,nloc*5,[x,5*y],label=l111);
mesh ThC=square(nC,nC*5,[x,5*y],label=l111);//   Caarse Mesh
fespace VhC(ThC,P1); // of the coarse problem.. 


BuildPartitioning(sizeoverlaps,mesh,Thg,Thi,aThij,RAS,pii,jpart,comm,vdebug)

if(ksplit>1)
{
 for(int jp=0;jp<jpart.n;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);
 Thi =   trunc(Thi,1,split=ksplit);
}

BuildTransferMat(iiipart,mesh,Pk,1,[0],
                 Thi,Whi,Whij,Thij,aThij,Usend,Vrecv,jpart,vdebug)

Whi ui,vi; 



/* the definition of the Problem .... */
func G=1; /* ok  */
func F=2.; /* ok  */
macro grad(u) [dx(u),dy(u)] //
// warning for Dir. BC. the last win 
varf vPb(U,V)= int2d(Thi)(grad(U)'*grad(V)) + int2d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int2d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon10(U,V)=on(10,U=1)+on(1,U=0);

varf vPBC(U,V)=on(1,U=G);


real[int] onG10 = vPbon10(0,Whi); // on 1 
real[int] Bi=vPb(0,Whi);


matrix Ai = vPb(Whi,Whi,solver=sparsesolver); 

DMMDeffuncAndGlobals(Lap2,comm,jpart,Whi,Vhc,1,Ai,vPbC,onG10,Pii,Usend,Vrecv,[0])

Lap2CheckUpdate(); 
  
Whi u=0,v;
 

u[]=vPBC(0,Whi,tgv=1); 
real eps=1e-10;
Lap2DDMSolver(Bi,u,v,gmres,eps,vdebug)


real errg =1,umaxg;

{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(iiipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << Lap2kiter <<  endl;
}

Lap2Saveff(sff,eps,ksplit,nloc,sizeoverlaps); 
//  run with MPI:  ff-mpirun -np 2 script.edp
// NBPROC 2

/* to run : in a Shell.  cut and past:
cd /Users/hecht/work/freefem++/examples/mpi 
mpirun -np 2 FreeFem++-mpi schwarz-3.edp -glut ffglut
*/
load "msh3"
if ( mpisize != 2 ) {
cout << " sorry number of processeur !=2 " << endl;
exit(1);}
verbosity=4;
real pi=4*atan(1);
int inside = 2;
int outside = 1;
real zmin =0, zmax=1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;};
int n=1;
mesh th2,TH2;
mesh3 th,TH;
int[int] rup=[0,0], rdown=[0,0], rmid=[outside,outside,inside,inside];;
if (mpirank == 0)
 {
 th2 = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
 th =  buildlayers(th2,n,
	     zbound=[zmin,zmax],  labelmid=rmid,
	     reffaceup = rup,     reffacelow = rdown);

 cout << " end th  " << endl;
}
else
 {
 TH2 = buildmesh ( e(5*n) + e1(25*n) );
 TH =  buildlayers(TH2,n,
	     zbound=[zmin,zmax],  labelmid=rmid,
	     reffaceup = rup,     reffacelow = rdown);

 cout << " end TH  " << endl;
 }
broadcast(processor(0),th);
broadcast(processor(1),TH);


fespace vh(th,P1);
fespace VH(TH,P1);
fespace ph(th,P1);
fespace PH(TH,P1);
vh u=0,v; VH U,V;
ph chi=1;
PH CHI=1;
int i=0;

problem PB(U,V,init=i,solver=CG) =
  int3d(TH)( dx(U)*dx(V)+dy(U)*dy(V) +dz(U)*dz(V))
  + int3d(TH)( -V) + on(inside,U = u)  +    on(outside,U= 0 ) ;
problem pb(u,v,init=i,solver=CG) =
    int3d(th)( dx(u)*dx(v)+dy(u)*dy(v)+dz(u)*dz(v) )
  + int3d(th)( -v) + on(inside ,u = U) +    on(outside,u = 0 ) ;


for ( i=0 ;i< 10; i++)
{
  cout << mpirank << " looP " << i << endl;
  if (mpirank == 0)
   PB;
  else
    pb;
   broadcast(processor(0),U[]);
   broadcast(processor(1),u[]);
 
  if (mpirank==0)     plot(U,u,wait=1,fill=1);

  if(mpirank==0)
    {
      real ERR= int3d(TH)( square(U-u)*CHI*chi) ;
      cout << " ERR= " << ERR<< endl;
    }
  else
    {
      real err= int3d(th)( square(U-u)*CHI*chi) ;
      cout << " err= " << err<< endl;
    }

};
 if (mpirank==0)
    plot(U,u,ps="Uu.eps",fill=1);

// ff-mpirun -np 4 MPIGMRES2D.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES2d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "MPIplot.idp"
include "MPIGMRESmacro.idp"
//include "AddLayer2d.idp" 

searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
assert(version >=3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",3);
int nloc = getARGV("-n",11);
string sff=getARGV("-p,","");
int gmres=getARGV("-gmres",2); 
bool dplot=getARGV("-dp",0);
int nC = getARGV("-N" ,max(nloc/10,4)); 

if(mpirank==0 && verbosity)
{
  cout << "ARGV : ";
  for(int i=0;i<ARGV.n;++i)
    cout << ARGV[i] <<" ";
  cout << endl;
}


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

int withplot=0;
bool withmetis=1;
bool RAS=1; 
string sPk="P2-2gd";     
func Pk=P2;

func bool  plotMPIall(mesh &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALL(mesh,Pk, Th, u,{ cmm=cm,nbiso=20,fill=1,dim=3,value=1}); return 1;}

int sizeoverlaps=1; // size of overlap

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 
 
int npart=mpiSize(comm); // total number of partion
int ipart= mpiRank(comm); // current partition number 

int njpart=0; // nb of part with intersection (a jpart) with ipart without ipart
int[int] jpart(npart); //  list of jpart ..
if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,1,1]; 
settt 

mesh Thg=square(nloc,nloc,label=l111);
mesh ThC=square(nC,nC,label=l111);//   Caarse Mesh

mesh Thi,Thin;//  with overlap, without olverlap  
fespace Phg(Thg,P0);
fespace Vhg(Thg,P1);
fespace VhC(ThC,P1); // of the coarse problem.. 


Phg  part;

// build the partitioning ...  
{    
 int[int] nupart(Thg.nt);
 nupart=0; 
 if(npart>1 && ipart==0)
   metisdual(nupart,Thg,npart); 
   
 broadcast(processor(0,comm),nupart);
 for(int i=0;i<nupart.n;++i)
    part[][i]=nupart[i];
  
} // build ... 


if(withplot>1)
  plot(part,fill=1,cmm="dual",wait=1);

// overlapping partition

 Phg suppi= abs(part-ipart)<0.1; 
 Vhg unssd;                       // boolean function 1 in the subdomain 0 elswhere 
 Thin=trunc(Thg,suppi>0,label=10); // non-overlapping mesh, interfaces have label 10
 int nnn = sizeoverlaps*2;// to be sure 
 AddLayers(Thg,suppi[],nnn,unssd[]);    // see above ! suppi and unssd are modified  
 unssd[] *= nnn;  //  to put value nnn a 0  
 real nnn0 = nnn - sizeoverlaps +  0.001   ;
 Thi=trunc(Thg,unssd>nnn0 ,label=10); // overlapping mesh, interfaces have label 10
 
 settt 

 fespace Vhi(Thi,P1);
 int npij=npart;
 Vhi[int] pij(npij);// local partition of unit + pii 
 Vhi pii;  
 
 real nnn1=  + 0.001  ;
 { /*
   construction of the partition of the unit,
    let phi_i P1 FE function 1 on Thin and zero ouside of Thi and positive
    the partition is build with  
  $$  p_i = phi_i/ \sum phi_i 
    
    to build the partition of one domain i
    we nned to find all j such that supp(phi_j) \cap supp(phi_j) is not empty
    <=> int phi_j
 */
 //   build a local mesh of thii such that all compuation of the unit partition are
 //   exact in thii
 mesh Thii=trunc(Thg,unssd>nnn1 ,label=10); // overlapping mesh, interfaces have label 10


 {  
   // find all j  mes (supp(p_j) \cap supp(p_i)) >0  
   // compute all phi_j on Thii
   //  remark supp p_i include in Thi 
   //  
   fespace Phii(Thii,P0);
   fespace Vhii(Thii,P1);
   Vhi sumphi=0;
   jpart=0;
   njpart=0;
   int nlayer=RAS?1:sizeoverlaps;
   if(ipart==0) 
     cout <<" nlayer=" << nlayer << endl;
   pii= max(unssd-nnn+nlayer,0.)/nlayer;
   if(dplot) plot(pii,wait=1,cmm=" 0000");
   sumphi[] +=  pii[];
   if(dplot) plot(sumphi,wait=1,cmm=" summ 0000");
   Vhii phii=0;
   real epsmes=1e-10*Thii.area;
   for (int i=0;i<npart;++i)
     if(i != ipart ) 
       { 
	    Phii suppii=abs(i-part)<0.2; 
	    if(suppii[].max > 0.5) 
	    {
	     AddLayers(Thii,suppii[],nlayer,phii[]);
	     assert(phii[].min >=0);
	     real interij = int2d(Thi)(  phii); 
	     if(interij>epsmes) 
	       {  
		     pij[njpart]=abs(phii);	 
		     if(vdebug>2) cout << " ***** " << int2d(Thi)(real(pij[njpart])<0) << " " <<pij[njpart][].min << " " << phii[].min << endl;
		     assert(int2d(Thi)(real(pij[njpart])<0) ==0);
		     if(dplot)  plot(pij[njpart],wait=1,cmm=" j = "+ i + " " + njpart);
		     sumphi[] += pij[njpart][]; 
		     if(dplot)  plot(sumphi,wait=1,cmm=" sum j = "+ i + " " + njpart);
		     jpart[njpart++]=i;
	       }}}
   
   if(dplot) plot(sumphi,wait=1,dim=3,cmm="sum ",fill=1 );
   pii[]=pii[] ./ sumphi[];
   for (int j=0;j<njpart;++j)
     pij[j][] = pij[j][] ./ sumphi[];
   jpart.resize(njpart);	
   for (int j=0;j<njpart;++j)
     assert(pij[j][].max<=1);
   {
     cout << ipart << " number of jpart " << njpart << " : ";
     for (int j=0;j<njpart;++j)
       cout << jpart[j] << " ";
  	cout << endl;
   }
   sumphi[]=pii[];
   for (int j=0;j<njpart;++j)
     sumphi[]+= pij[j][];
   if(vdebug>2)  
     cout << " sum min " <<sumphi[].min << " " << sumphi[].max << endl;
   assert(sumphi[].min> 1.-1e-6 && sumphi[].max< 1.+1e-6);  
   //  verification 
 }}// (Thii is remove here) 
  // end of the construction of the local partition of the unity ...
  // on Thi ...  
  // -----------------------------------------------------------------
if(ipart==0) cout << " *** end build partition " << endl;

//  computation of  number of intersection ..
// ------------------------------------------

// here  pii and the pij is the locate partition of the unite on 
// Thi ( mesh with overlap )....
//Thi=splitmesh(Thi,2);
if(dplot ) 
  { plot(Thi,wait=1); 
    for(int j=0;j<njpart;++j)
      plot(pij[j],cmm=" j="+j ,wait=1); } 
      
//  Partition of the unity on Thi ..
// computation of message.
// all j> we have to recive 
// data on intersection of the support of pij[0] and pij[j]
settt 

 if(vdebug) plotMPIall(Thi,pii[],"pi_i");

mesh[int] aThij(njpart); 
matrix Pii;  
matrix[int] sMj(njpart); // M of send to j
matrix[int] rMj(njpart); // M to recv from j
fespace Whi(Thi,Pk);
mesh Thij=Thi;
fespace Whij(Thij,Pk);// 

// construction of the mesh intersect i,j part 
for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(Thi,pij[jp]>1e-6,label=10); // mesh of the supp of pij

for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);

Thi =   trunc(Thi,1,split=ksplit);

settt 

if(ipart==0) cout << " *** end build mesh  intersection  " << endl;
// construction of transfert  matrix
{
  Whi wpii=pii;
  Pii = wpii[];
  for(int jp=0;jp<njpart;++jp)
    {
      int j=jpart[jp];
      Thij = aThij[jp];
      matrix I = interpolate(Whij,Whi); // Whji <- Whi
      sMj[jp] = I*Pii;  // Whi -> s Whij  
      rMj[jp] = interpolate(Whij,Whi,t=1);   // Whji -> Whi
      if(vdebug>10) {
      {Whi uuu=1;Whij vvv=-1; vvv[]+=I*uuu[]; cout << jp << " %%% " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}
      {Whi uuu=1;Whij vvv=-1; vvv[]+=rMj[jp]'*uuu[]; cout << jp << " ### " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}}
    }}
if(ipart==0) cout << " *** end build transfert matrix " << endl;
// alloc array of send and recv data ..

InitU(njpart,Whij,Thij,aThij,Usend)  // initU(n,Vh,Th,aTh,U)
InitU(njpart,Whij,Thij,aThij,Vrecv) // ...
if(ipart==0) cout << " *** end init  data for send/revc  " << endl;

Whi ui,vi; 

func bool Update(real[int] &ui, real[int] &vi)
{
  for(int j=0;j<njpart;++j)
    Usend[j][]=sMj[j]*ui; 
   SendRecvUV(comm,jpart,Usend,Vrecv)
     vi = Pii*ui;
   for(int j=0;j<njpart;++j)
     vi += rMj[j]*Vrecv[j][]; 
   return true;
}


// the definition of the Problem ....
func G=x*0.1; // ok 
func F=1.; // ok 
macro grad(u) [dx(u),dy(u)] // 
varf vBC(U,V)=  on(1,U=G); 
varf vPb(U,V)= int2d(Thi)(grad(U)'*grad(V)) + int2d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int2d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon(U,V)=on(10,U=1)+on(1,U=1);
varf vPbon10only(U,V)=on(10,U=1)+on(1,U=0); 
// remark the order is important we want 0 part on 10 and 1


//----  

matrix Ai = vPb(Whi,Whi,solver=sparsesolver);
matrix AC,Rci,Pci;// 


if(mpiRank(comm)==0)
  AC = vPbC(VhC,VhC,solver=sparsesolver);

Pci=   interpolate(Whi,VhC);
Rci =  Pci'*Pii; 

real[int] onG10 = vPbon10only(0,Whi);
real[int] onG = vPbon(0,Whi);
real[int] Bi=vPb(0,Whi);





int kiter=-1;


func bool  CoarseSolve(real[int]& V,real[int]& U,mpiComm& comm)
{
   //  solving the coarse probleme 
   real[int] Uc(Rci.n),Bc(Uc.n); 
   Uc= Rci*U;
   mpiReduce(Uc,Bc,processor(0,comm),mpiSUM);
   if(mpiRank(comm)==0) 
      Uc = AC^-1*Bc;
    broadcast(processor(0,comm),Uc);
   V = Pci*Uc;
}//EOF ...
func real[int] DJ(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
   V =  Ai*U;
  V = onG10 ? 0.: V;  // remove internal boundary  
  return V; 
}

func real[int] PDJ(real[int]& U) // C1
{ 
  real[int] V(U.n); 
  
  real[int] b= onG10 ? 0. :  U; 
  V =  Ai^-1*b;	
  Update(V,U);
  return U; 
}

func real[int] PDJC(real[int]& U) // 
{ // Precon  C1= Precon //, C2  precon Coarse
// Idea : F. Nataf. 
  //  0 ~  (I C1A)(I-C2A) => I ~  - C1AC2A +C1A +C2A 
  //  New Prec P= C1+C2 - C1AC2   = C1(I- A C2) +C2
  // (  C1(I- A C2) +C2 ) Uo 
  //   V =  - C2*Uo
  // .... 
  real[int] V(U.n); 
  CoarseSolve(V,U,comm);
  V = -V; //  -C2*Uo 
  U  += Ai*V; // U =  (I-A C2) Uo 
  real[int] b= onG10 ? 0. :  U; 
  U =  Ai^-1*b;	//  ( C1( I -A C2) Uo 
  V = U -V; //  
  Update(V,U);
  return U; 
}


 func real[int] DJ0(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
  real[int] b= onG .* U;
  b  = onG ? b : Bi ;  
  V = Ai^-1*b;	
  Update(V,U);
  V -= U;
   return V; 
}


Whi u=0,v;
{ // verification.....
  Whi u=1,v;
  Update(u[],v[]);
  u[]-=v[];
  assert( u[].linfty<1e-6); }
  


settt
u[]=vBC(0,Whi,tgv=1); // set u with tge BC value ...

real epss=1e-6;
int rgmres=0;
if(gmres==1)
  {
   rgmres=MPIAffineGMRES(DJ0,u[],veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
   real[int] b= onG .* u[];
   b  = onG ? b : Bi ;
   v[] = Ai^-1*b;	
   Update(v[],u[]);
  }
else if(gmres==2)
  rgmres= MPILinearGMRES(DJ,precon=PDJ,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else if(gmres==3)
   rgmres= MPILinearGMRES(DJ,precon=PDJC,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else // algo Shwarz for demo ...
   for(int iter=0;iter <10; ++iter)
     {
       real[int] b= onG .* u[];
       b  = onG ? b : Bi ;
       v[] = Ai^-1*b;	
       
       Update(v[],u[]);
       if(vdebug) plotMPIall(Thi,u[],"u-"+iter);
        v[] -= u[];
       
       real err = v[].linfty;
       real umax = u[].max;
       real[int] aa=[err,umax], bb(2);
       mpiAllReduce(aa,bb,comm,mpiMAX);
       real errg = bb[0];
       real umaxg = bb[1];
       
       if(ipart==0)
	     cout << ipart << " err = " << errg << " u. max  " << umaxg << endl;
       if(errg< 1e-5) break;
     }
if(vdebug) plotMPIall(Thi,u[],"u-final");

settt

real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << kiter <<  endl;
}

if(sff != "")
  {
    ofstream ff(sff+".txt",append);
    cout << " ++++  " ;
    cout  << mpirank <<"/" <<  mpisize << " k=" <<  ksplit << " n= " << nloc << " " << sizeoverlaps << " it=  " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      cout << " " << ttt[i]-ttt[i-1] << " ";
    cout << epss << " " << Ai.nbcoef << " " << Ai.n << endl;
    
    /*
      1 mpirank
      2 mpisize 
      3 ksplit 
      4 nloc
      5 sizeoverlaps
      6 kiter
      7 mesh & part build  
      8 build the partion 
      9 build mesh, transfere , and the fine mesh .. 
      10 build the matrix,  the trans matrix, factorizatioon 
      11 GMRES 
    */
    ff   << mpirank << " " << mpisize << " " << sPk << " " ;
    ff <<  ksplit << " " << nloc << " " << sizeoverlaps << " " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      ff << " " << ttt[i]-ttt[i-1] << " ";
    ff << epss << " " << Ai.nbcoef << " " << Ai.n << " " << gmres << endl;
    
  }
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "mpi-cmaes"


int NN = 6;
mesh Th = square(NN,NN);
func f1=1.;
func f2=-1.;
func g1=0.;
func g2=0.1;
int iter=0;
int nadapt=1;
real starttol=1e-10,bctol=6.e-12;
fespace Vh(Th,P1);
Vh ou1,ou2;
real pena=1000;


for(int al=0;al<nadapt;++al)
{
	
varf BVF(v,w) = int2d(Th)(0.5*dx(v)*dx(w) + 0.5*dy(v)*dy(w));
varf LVF1(v,w) = int2d(Th)(f1*w);
varf LVF2(v,w) = int2d(Th)(f2*w);
matrix A =  BVF(Vh,Vh);
real[int] b1 = LVF1(0,Vh) , b2 = LVF2(0,Vh); 

varf Vbord(v,w) = on(1,2,3,4,v=1);
//real[int] bord = Vbord(0,Vh);
//real[int] in = bord ? 0 : 1;
Vh In,Bord;
Bord[] = Vbord(0,Vh,tgv=1);
In[] = Bord[] ? 0:1;
Vh gh1=Bord*g1,gh2=Bord*g2;



//Function which create a vector of the search space type from
//two finite element functions
func int FEFToSSP(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			ssp[kX] = fef1[i];
			ssp[kX+In[].sum] = fef2[i];
			++kX;
		}
	}
	return 1;
}
//Function spliting a vector from the search space and fills
//two finite element functions with it
func int SSPToFEF(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			fef1[i] = ssp[kX];
			fef2[i] = ssp[kX+In[].sum];
			++kX;
		}
		else
		{
			fef1[i] = gh1[][i];
			fef2[i] = gh2[][i];
		}
	}
	return 1;
}


func real IneqC(real[int] &X)
{
	real[int] constraints(In[].sum);
	for(int i=0;i<In[].sum;++i)
	{
		constraints[i] = X[i] - X[i+In[].sum];
		constraints[i] = constraints[i] <= 0 ? 0. : constraints[i];
	}
	return constraints.l2;
}


func real J(real[int] &X)
{
	Vh u1,u2;
	SSPToFEF(u1[],u2[],X);
	iter++;
	real[int] Au1 = A*u1[], Au2 = A*u2[];
	Au1 -= b1;
	Au2 -= b2;
	real val = u1[]'*Au1 + u2[]'*Au2;
	val +=  pena * IneqC(X);
	if(iter%100==0) plot(u1,u2,nbiso=30,fill=1,dim=3,cmm="adapt level " + al + " - iteration " + iter + " - J = " + val,value=1);
	return val ;
}



real[int] start(2*In[].sum);

if(al==0)
{
	start(0:In[].sum-1) = 0.;
	start(In[].sum:2*In[].sum-1) = 0.1;
}
else FEFToSSP(ou1[],ou2[],start);


real mini = cmaesMPI(J,start,stopMaxFunEval=10000*(al+1),stopTolX=1.e-4/(10*(al+1)),initialStdDev=(0.025/(pow(100.,al))));
Vh best1,best2;
SSPToFEF(best1[],best2[],start);

Th = adaptmesh(Th,best1,best2);
ou1 = best1;
ou2 = best2;

}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "msh3"
load "MUMPS_mpi"
////////////////////
//  parameters

real ttgv=1e30;
//string ssparams="nprow=1, npcol="+mpisize;
////////////////////
real nu=0.01,dt=0.3;
real alpha=1./dt,alpha2=sqrt(alpha);

int nn=7;

mesh Th2=square(nn,nn);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;

mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  // region=r1, 
  labelmid=rmid, 
  reffaceup = rup,
  reffacelow = rdown);

fespace VVh(Th,[P23d,P23d,P23d,P13d]);
fespace Vh(Th,P23d);
fespace Ph(Th,P13d);
macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM
  
cout << "initilisation" << endl;

real t1,t2,t3,t4;

t1=clock();
varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) //' for emacs
             - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
 + on(2,u1=1.,u2=0,u3=0)
 + on(1,u1=0,u2=0,u3=0)
 ;
matrix A=vStokes( VVh, VVh, tgv=ttgv );
t1=clock()-t1;

t4=clock();
set(A,solver=sparsesolver );
t4=clock()-t4;

t2=clock();
real[int] b= vStokes(0,VVh);
t2=clock()-t2;

VVh [u1,u2,u3,p];
VVh [X1,X2,X3,Xp];
VVh [x1,x2,x3,xp]=[x,y,z,0];

t3=clock();
u1[]= A^-1 * b;
t3=clock()-t3;

ux= u1(x,0.5,y);
uz= u3(x,0.5,y);
p2= p(x,0.5,y);
plot([ux,uz],p2,cmm=" cut y = 0.5",wait=1);
macro XX1() (x-u1*dt)//
macro XX2() (y-u2*dt)//
macro XX3() (z-u3*dt)//

  varf vNS([uu1,uu2,uu3,p],[v1,v2,v3,q]) = 
  int3d(Th)( alpha*(uu1*v1+uu2*v2+uu3*v3) + nu*(Grad(uu1)'*Grad(v1) +  Grad(uu2)'*Grad(v2) +  Grad(uu3)'*Grad(v3)) //' for emacs
  - div(uu1,uu2,uu3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,uu1=1,uu2=0,uu3=0)
  + on(1,uu1=0,uu2=0,uu3=0)
 
  +  int3d(Th,optimize=1,qforder=4)(   alpha*(  convect([u1,u2,u3],-dt,u1)*v1  +   convect([u1,u2,u3],-dt,u2)*v2  +   convect([u1,u2,u3],-dt,u3)*v3 )  ) ;
  //   +  int3d(Th,optimize=1)(   alpha*(  u1(X1,X2,X3)*v1  +  u2(X1,X2,X3)*v2  +  u3(X1,X2,X3)*v3 )  ) ;
//  +  int3d(Th,optimize=1)(   alpha*(  u1(XX1,XX2,XX3)*v1  +  u2(XX1,XX2,XX3)*v2  +  u3(XX1,XX2,XX3)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1(x,y,z)*v1  +  u2(x,y,z)*v2  +  u3(x,y,z)*v3 )  ) ;
//+  int3d(Th,optimize=1)(   alpha*(  u1*v1  +  u2*v2  +  u3*v3 )  ) ;

real time1,time2=0.,time3=0.,time4,time5;

time1=clock();
A = vNS( VVh, VVh, tgv=ttgv);
time1=clock()-time1;

time5=clock();
set(A,solver=sparsesolver,verb=1);
time5=clock()-time5;

time4=clock();
real t=0;
int nbtemps=5;
for(int i=0;i<nbtemps;++i)
  {
    real time2tmp,time3tmp;
    t += dt;
    cout << " iteration " << i << " t = " << t << endl;
    X1[]=x1[]+u1[]*(-dt);
    //    verbosity=1000;

    time2tmp=clock();
    b=vNS(0,VVh);
    time2=time2+(clock()-time2tmp);

    time3tmp=clock();
    u1[]= A^-1 * b;
    time3=time3+(clock()-time3tmp);

    ux= u1(x,0.5,y);
    uz= u3(x,0.5,y);
    p2= p(x,0.5,y);
    plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=0);
    if(i%5==6)
    {
      //exec("mkdir dd");
      string prefu="dd/pastix-nn-"+nn+"+u-"+(100+i);
      string prefp="dd/pastix-nn-"+nn+"p-"+(100+i);
      savemesh(Th,prefu+".mesh");
      savemesh(Th,prefp+".mesh");
     
      ofstream file(prefu+".bb"); 
      ofstream filep(prefp+".bb"); 
      Ph up1=u1,up2=u2,up3=u3,pp=p;
      file << "3 1 3 "<< up1[].n << " 2 \n";
      filep << "3 1 1 "<< pp[].n << " 2 \n";
      for (int j=0;j<up1[].n ; j++)  
	{
	  file << up1[][j] <<" " <<up2[][j] <<" "<< up3[][j] <<"\n";
	  filep << pp[][j] <<  endl; 
	}  
    }
  }
time4=clock()-time4;

//plot([ux,uz],p2,cmm=" cut y = 0.5, time ="+t,wait=1);
cout << "============ CPU TIME ==========================" << endl;
cout << "= Intialisation Stokes :::         =" << endl;
cout << "= matrix                           =" << t1<< endl;
cout << "= Factorization                    =" << t4 << endl; 
cout << "= second member                    =" << t2 << endl;
cout << "= solving                          =" << t3<< endl;
cout << "= all                              =" << t1+t2+t3+t4 << endl; 
cout << "============ CPU TIME ==========================" << endl;
cout << "= Navier Stokes :::                =" << endl;
cout << "= matrix                           =" << time1<< endl;
cout << "= Factorization                    =" << time5 << endl; 
cout << "= second member by step (dt)       =" << time2/nbtemps << endl;
cout << "= solving by step (dt)             =" << time3/nbtemps<< endl;
cout << "= all step solving                 =" << time4 << endl;
cout << "= solving Navier Stokes            =" << time1+time2+time3+time4+time5 << endl; 
cout << "============ CPU TIME ==========================" << endl;
// NBPROC 4
assert(version>=2.23);
if ( mpisize != 4 )
  {
    cout << " sorry number of processeur !=4 " << endl;
    exit(1);
  }

//  Mortar  (4 sub domain)
//  with matrix -et Precon Conjugade Gradient --
//    Neuman -> Dirichlet .
//  -------------------------------

func f=1+x+y;
real g=1;
int withprecon=1;
macro Grad(u) [ dx(u), dy(u) ] //
int nbsd=4;

macro Psd(U) U[0],U[1],U[2],U[3] //

int labext= nbsd+1;
real meshsize=0.03;
real meshsizem=meshsize*1.5;
bool noconforme=0;

mesh Tha,Thm,Thmm;
int [int] regsd(4);


if(mpirank==0)
  {

    mesh Thacopy; //hack to dcl Tha ouside of mortar-msh.idp
    {
      include "mortar-msh.idp"
	Thacopy=Tha;
      regsd=regi;
    }
    Tha=Thacopy;
    cout << "mortar : " << endl;
    Thm=Tha;
    Thm=adaptmesh(Thm,meshsizem,IsMetric=1,thetamax=60);
    Thm=emptymesh(Thm);       Thmm=Thm;
    Thmm=trunc(Thm,split=4,1); // for fine integration
    Thmm=emptymesh(Thmm);
    plot(Thm,wait=0,ps="mortar-Thm.eps");
  }

// send meshes
verbosity=1;
broadcast(processor(0),Tha);
broadcast(processor(0),Thm);
broadcast(processor(0),Thmm);
broadcast(processor(0),regsd);

// build sub domaine mesh :
mesh Thi=trunc(Tha,region==regsd[mpirank],split=1);// les sous domaines

if(noconforme)
 Thi=adaptmesh(Thi,meshsize*(1+0.1*mpirank),IsMetric=1,nbvx=100000,thetamax=60);// les sous domaines


fespace Lh(Thm,P1);
fespace RTh(Thm,[P0edge,P0edge]);
 RTh [Nmx,Nmy]; // ne marche pas car la normal
//                             n'est definie que une un bord
varf  vNN([ux,uy],[nx,ny]) = int1d(Thm,1)(( nx*N.x + ny*N.y)/lenEdge);
Nmx[]= vNN(0,RTh);

// les joint P0 sur le squelette
// -----   \int [q] l + \int[p] m
Lh  lh=0,rhsl=0;

fespace Vhi(Thi,P1);
fespace Ehi(Thi,P0);
matrix Asd,Csd,PAsd,PIsd,PJsd;
Vhi usd,vsd,rhssd, pusd,bcsd;
Ehi epssd;

real tgv=1e30;



varf cci([l],[u]) = int1d(Thmm,1,qforder=3)(l*u*epssd);
varf vepsi(u,v)= int1d(Thi,1,qforder=10)( (Nmx*N.x + Nmy*N.y)*v/lenEdge);

varf vLapMi([ui],[vi],tgv=tgv) =
			   int2d(Thi)(  Grad(ui)'*Grad(vi)  )
			   // + int1d(Thi,1,qfe=qf1pElump)(alpha*ui*vi)
			   +  int2d(Thi) (f*vi)   +  on(labext,ui=g);

varf vPLapMi([ui],[vi],tgv=tgv) =
			   int2d(Thi)(  Grad(ui)'*Grad(vi)  )
			   // + int1d(Thi,1,qfe=qf1pElump)(alphap*ui*vi)
			   + on(labext,1,ui=0);
;

varf  vrhsMi(ui,vi) =   on(labext,ui=g);


usd=0;
vsd=0;
epssd[]= vepsi(0,Ehi);
epssd = -real(epssd <-0.00001) + real(epssd >0.00001);

Csd  = cci(Lh,Vhi);
Asd  = vLapMi(Vhi,Vhi,solver="SPARSESOLVER");
PAsd = vPLapMi(Vhi,Vhi,solver="SPARSESOLVER");
matrix IVL=interpolate(Vhi,Lh,inside=1);
//   v = IVL*l
varf vonext(u,v)=on(labext,u=1);
varf von1(u,v)=on(1,u=1);
real[int]  onext=vonext(0,Vhi);
real[int]  on1=von1(0,Vhi);
on1= on1 ? 1 : 0;
on1 = onext ? 0 : on1; //  remove df of ext
matrix I1(on1);//   matrix    tgv $i\in Gamma_1 \ Gamma_e $ , 0 otherwise
PIsd=  I1*IVL;//  remove of line not on $Gamma_1 \ Gamma_e $
// so PIsd*l  =  tgv * Interpole l on $Gamma_1 \ Gamma_e $
I1.diag=on1;
matrix AA=I1*Asd;//  remove line not on lab 1
PJsd= IVL'*AA;
rhssd[]=vLapMi(0,Vhi);

varf  vML(u,v) = int2d(Thm)(u*v*1e-10)+int1d(Thm,1)(u*v);
matrix ML=vML(Lh,Lh);


lh[]=0;
int itera=0;

varf  vbc(u,v) =   int1d(Thm,labext)(v);
real[int] lbc(Lh.ndof),lbc0(Lh.ndof);
lbc=vbc(0,Lh);
lbc = lbc ? 0 : 1 ;

int what; //  to choose which  funct call 1  SkPb 2:PSkPb, 3:end
// the preconditionner
func real[int] PSkPb(real[int] &l)
{
  if(withprecon)
    {
      if(mpirank==0)
	{
	  what=2;
	  broadcast(processor(0),what); // get from SkBk routine
	}
      if(what!=2) return l;

      int verb=verbosity;   verbosity=0;   itera++;
      real[int] ll= ML^-1*l;
      broadcast(processor(0),ll);
      ll= lbc .* ll;
      ll *= tgv;
      pusd[] = PAsd^-1*(vsd[]= PIsd* ll);
      ll  = PJsd*pusd[];
      if(mpirank==0)
	{
	  for (int i=1;i<4;++i)
	    {
	      processor(i) >> l;
	      ll += l;
	    }
	  l = ML^-1*ll;
	  l= lbc .* l;
	}
      else
	processor(0) << ll;
      verbosity=verb;
    }
  return l ;
};

func real[int] SkPb(real[int] &l)
{
  int verb=verbosity;   verbosity=0;   itera++;
  if(mpirank==0 && what!=3) what=1;
  broadcast(processor(0),what);
  if(what==2) return PSkPb(l);
  else if (what !=1) return l;
  broadcast(processor(0),l);

  vsd[]  = rhssd[];
  vsd[] += Csd* l;
  usd[]  = Asd^-1*vsd[];
  l  = Csd'*usd[];
  l= lbc .* l;

  if(mpirank==0)
   {
    real[int] ll(l.n);
    for (int i=1;i<4;++i)
      {
        processor(i) >> ll;
        l += ll;
      }
    }
  else
    processor(0) << l;
  verbosity=verb;
  return l ;
};





if(mpirank==0)
  {
    verbosity=100;
    lh[]=0;
     LinearCG(SkPb,lh[],eps=1.e-5,nbiter=100,precon=PSkPb);
    what=3;
    SkPb(lh[]);
  }
 else
   while(what!=3)
     SkPb(lh[]);

plot(usd,bb=[[-1,-1],[1,1]],ps="mortar-"+mpirank+".eps");
cout << "Fin CG  " << mpirank <<  endl;

/*
Brochet:examples/mpi hecht$ (grep -vh showpage  mortar-?.eps;echo showpage) > mortar.eps
Brochet:examples/mpi hecht$ gv mortar.eps
*/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -n 5

/*
to change locatation of daynamic lib. set   freefem++.pref   file like :
more freefem++.pref
loadpath = "../../plugin/seq/"
loadpath += "./"
*/

load "msh3"
//load "medit"
load "MUMPS_mpi"
include "getARGV.idp"

verbosity=0;
real ttgv=1e10;



int nn=getARGV("-n",15);
int pplot=getARGV("-plot",0);


int[int] ll=[1,1,1,1,1,2];
mesh3 Th;
if(mpirank==0)
{
	Th=cube(nn,nn,nn,label=ll);
	Th=change(Th,fregion=nuTriangle%mpisize);
}
broadcast(processor(0),Th);
fespace VVh(Th,[P2,P2,P2,P1]);
fespace UUh(Th,[P2,P2,P2]);
fespace Uh(Th,P2);
fespace Ph(Th,P1);

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

func fup = (1-x)*(x)*y*(1-y)*16;


VVh [u1,u2,u3,p];
VVh [v1,v2,v3,q];

real timeI=mpiWtime();
real time1=mpiWtime();
varf vStokes([u1,u2,u3,p],[v1,v2,v3,q]) =
  int3d(Th,qforder=3,mpirank)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3)   //' for emacs
                  - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p )
  + on(2,u1=fup,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ;


matrix MStokes=vStokes(VVh,VVh,tgv=ttgv);
if(mpirank==0)
cout << "size of matrix " << MStokes.n << " x " << MStokes.m << " nn nzero coef  = " << MStokes.nbcoef << endl;
time1=mpiWtime()-time1;

real timeF=mpiWtime();
set(MStokes,solver=sparsesolver,master=-1);
timeF=mpiWtime()-timeF;

real time2=mpiWtime();
real[int] b=vStokes(0,VVh);
time2=mpiWtime()-time2;

real time3=mpiWtime();
u1[] = MStokes^-1*b;
time3=mpiWtime()-time3;

timeI=mpiWtime()-timeI;

if(mpirank==0)
{
cout << "============= CPU TIME ============" << endl;
cout << "size of matrix " << MStokes.n << " x " << MStokes.m << " nn nzero coef  = " << MStokes.nbcoef << endl;
cout << " matrix                  " <<  time1 << endl;
cout << " Fact                    " <<  timeF << endl;
cout << " second member           " <<  time2 << endl;
cout << " solve                   " <<  time3 << endl;
cout << "                          ------------" << endl;
cout << " all                     " <<  timeI << endl;
cout << "============= CPU TIME ============" << endl;
}
//if(mpirank==0 && pplot) medit("UV2 PV2",Th,[u1,u2,u3],p);
// UNCHECK-FILE   : BUGGUS  ....
// NBPROC 2
//  a new coding  methode de schwarz 
// with 2 proc. 
//  -------------------------------
// F.Hecht december 2003
// ----------------------------------
//  to test the broadcast instruction 
//  and array of mesh 
//  add add the stop test 
//  ---------------------------------

if ( mpisize != 2 ) {
cout << " sorry, number of processors !=2 " << endl;
exit(1);}
verbosity=3;
int interior = 2;
int exterior = 1;
border a(t=1,2){x=t;y=0;label=exterior;};
border b(t=0,1){x=2;y=t;label=exterior;};
border c(t=2,0){x=t ;y=1;label=exterior;};
border d(t=1,0){x = 1-t; y = t;label=interior;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=interior;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=exterior;}; 
int n=4;
mesh[int]  Th(mpisize);
if (mpirank == 0) 
 Th[0] = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
else
 Th[1] = buildmesh ( e(5*n) + e1(25*n) );

broadcast(processor(0),Th[0]);
broadcast(processor(1),Th[1]);

fespace Vh(Th[mpirank],P1);
fespace Vhother(Th[1-mpirank],P1);

Vh u=0,v;
Vhother U=0;
int i=0;

problem pb(u,v,init=i,solver=Cholesky) = 
    int2d(Th[mpirank])( dx(u)*dx(v)+dy(u)*dy(v) )
  + int2d(Th[mpirank])( -v) + on(interior,u = U)  +    on(exterior,u= 0 ) ;

for ( i=0 ;i< 20; i++) 
{ 
  cout << mpirank << " looP " << i << endl;
   pb; 
   //  send u  to the other proc, receive in U
  // processor(1-mpirank) << u[];    processor(1-mpirank) >> U[];
  mpiAlltoall(u[],U[]);
    real[int] err0(1),err1(1);
   err0[0] = int1d(Th[mpirank],interior)(square(U-u)) ;
   // send err0  to the other proc, receive in err1
   // dead lock use broadcast 
  // processor(1-mpirank)<<err0;   processor(1-mpirank)>>err1;
    mpiAlltoall(err0,err1);    
   real err= sqrt(err0[0]+err1[0]);
   cout <<" err = " << err << " err0 = " << err0[0] << ", err1 = " << err1[0] << endl;
   if(err<1e-3) break;
};
if (mpirank==0)  
    plot(u,U,ps="uU.eps");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "MUMPS_mpi" // add _mpi for windows do day
// load "symmetrizeCSR"
int[int] l = [1, 1, 2, 2];
mesh Th = square(150, 150, label = l);
int master = 0; //  no choose see MUMPS doc sect 4.3 
if(mpirank != master) // no need to store the matrix on ranks other than 0
    Th = square(1, 1, label = l);
fespace Vh(Th, P2);
real[int] rinfo(40);
 int[int] info(40); 

varf lap(u,v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v) - 100*u*v) + int2d(Th)(v) + on(1, u = 1);
real[int] b = lap(0, Vh);
matrix A,B;
//if( mpirank==master) // => trap pb of size  in  A^-1 * b;
{ // def only on master .. 
	A = lap(Vh, Vh); B = A;
	//symmetrizeCSR(B);
	set(B,sym=1);
	
	cout<< " A nnz "<< A.nnz << endl;
	cout<< " B nnz "<< B.nnz << endl;
} 
verbosity = 2;
// If you want, you can pass an array of integer (int[int] t)
// for specifying the ordering you want to use
// 1 : AMD
// 3 : AMF
// 4 : SCOTCH
// 5 : PORD
// 6 : METIS
// 7 : QAMD
// 10 : PT-SCOTCH
// 11 : ParMETIS
//
// You can also set on which MPI rank the matrix is defined
// as the current interface only supports centralized matrices
//
// Example :
// If one wants to use SCOTCH with a matrix stored on mpirank == 0
// int[int] t(2); t(0) = 4; t(1) = 1;
// set(A, solver = sparsesolver, lparams = t);
set(A, solver = sparsesolver,master=master);
set(B, solver = sparsesolver,master=master,rinfo=rinfo,info=info);
verbosity = 0;
Vh u;
u[] = A^-1 * b;
if(mpirank==master) cout << " A :  u " << u[].l1 << " " << u[].linfty << endl; 
if(mpirank==0-master)
plot(Th, u, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver unsymmetric", value = 1);
u[] = B^-1 * b;
if(mpirank==master) cout << " B :  u " << u[].l1 << " " << u[].linfty << endl; 
if(mpirank==master)
for(int i=0; i<40;++i)
   {
    cout << "mumps: info B" << i+1 << " = " << info[i] << " , / r " << rinfo[i] <<endl;
   }

if(mpirank==master)
plot(Th, u, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver symmetric", value = 1);

//  try distributed  version ...
 Th = square(150, 150, label = l);
u=0; // resize u..
b.resize(Vh.ndof);
Th=change(Th,fregion= nuTriangle%mpisize);
varf lapd(u,v) = int2d(Th,mpirank)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th,mpirank)(v) + on(1, u = 1);
A = lapd(Vh, Vh,solver=CG);
set(A, solver = sparsesolver,master=-1);// distruteb
b = lapd(0, Vh);
u[] = A^-1 * b;
cout << " D u " << u[].l1 << " " << u[].linfty << " " << mpirank << endl; 
cout << " On Fini" << endl; 
// NBPROC 4
// ff-mpirun -np 4 MPIGMRES2D.edp -glut ffglut  -n 11 -k 1  -d 1 -ns -gmres 1
/*
  a first true parallele example fisrt freefem++ 
  Ok up to 200 proc for a Poisson equation.. 
  See the Doc for full explaiantion

  F Hecht Dec. 2010. 
  -------------------
usage :
ff-mpirun [mpi parameter] MPIGMRES3d.edp  [-glut ffglut]  [-n N] [-k K]  [-d D] [-ns] [-gmres [0|1|2|3]
 argument: 
   -glut ffglut : to see graphicaly the process
   -n N:  set the mesh3 cube split NxNxN
   -d D:  set debug flag D must be one for mpiplot 
   -k K:  to refined by K all  elemnt
   -ns: reomove script dump
   -gmres 0   : use iterative schwarz algo.  
          1   :  Algo GMRES on residu of schwarz algo.
          2   :  DDM GMRES 
          3   :  DDM GMRES with coarse grid preconditionner (Good one)  
*/
load "MPICG"  load "medit"  load "metis"
include "getARGV.idp"
include "MPIplot.idp"
include "MPIGMRESmacro.idp"
//include "AddLayer3d.idp" 
include  "cube.idp"


searchMethod=0; // more safe seach algo (warning can be very expensive in case lot of ouside point) 
assert(version >3.11);
real[int] ttt(10);int ittt=0;
macro settt {ttt[ittt++]=mpiWtime();}//


verbosity=getARGV("-vv",0);
int vdebug=getARGV("-d",1);
int ksplit=getARGV("-k",2);
int nloc = getARGV("-n",10);
string sff=getARGV("-p,","");
int gmres=getARGV("-gmres",3); 
bool dplot=getARGV("-dp",0);
int nC = getARGV("-N" ,max(nloc/10,4)); 

if(mpirank==0 && verbosity)
{
  cout << "ARGV : ";
  for(int i=0;i<ARGV.n;++i)
    cout << ARGV[i] <<" ";
  cout << endl;
}


if(mpirank==0 && verbosity)
  cout << " vdebug: " << vdebug << " kspilt "<< ksplit << " nloc "<< nloc << " sff "<< sff <<"."<< endl;

int withplot=0;
bool withmetis=1;
bool RAS=1; 
string sPk="P2-3gd";     
func Pk=P2;

func bool  plotMPIall(mesh3 &Th,real[int] & u,string  cm)
{if(vdebug) PLOTMPIALL(mesh3,Pk, Th, u,{ cmm=cm,nbiso=3,fill=0,dim=3,value=1}); return 1;}

int sizeoverlaps=1; // size of overlap

mpiComm comm(mpiCommWorld,0,0);// trick : make a no split mpiWorld 
 
int npart=mpiSize(comm); // total number of partion
int ipart= mpiRank(comm); // current partition number 

int njpart=0; // nb of part with intersection (a jpart) with ipart without ipart
int[int] jpart(npart); //  list of jpart ..
if(ipart==0)  cout << " Final N=" << ksplit*nloc << " nloc =" << nloc << " split =" << ksplit <<  endl;
int[int] l111=[1,1,1,1]; 
settt 

int[int,int] LL=[[1,1],[1,1],[1,1]];
real[int,int] BB=[[0,1],[0,1],[0,1]];
int[int] NN=[nloc,nloc,nloc]; 
int[int] NNC=[nC,nC,nC]; 
settt 
mesh3 Thg=Cube(NN,BB,LL);
mesh3 ThC=Cube(NNC,BB,LL);

mesh3 Thi,Thin;//  with overlap, without olverlap  
fespace Phg(Thg,P0);
fespace Vhg(Thg,P1);
fespace VhC(ThC,P1); // of the coarse problem.. 


Phg  part;

// build the partitioning ...  
{    
 int[int] nupart(Thg.nt);
 nupart=0; 
 if(npart>1 && ipart==0)
   metisdual(nupart,Thg,npart); 
   
 broadcast(processor(0,comm),nupart);
 for(int i=0;i<nupart.n;++i)
    part[][i]=nupart[i];
  
} // build ... 


if(withplot>1)
  plot(part,fill=1,cmm="dual",wait=1);

// overlapping partition

 Phg suppi= abs(part-ipart)<0.1; 
 Vhg unssd;                       // boolean function 1 in the subdomain 0 elswhere 
 Thin=trunc(Thg,suppi>0,label=10); // non-overlapping mesh3, interfaces have label 10
 int nnn = sizeoverlaps*2;// to be sure 
 AddLayers(Thg,suppi[],nnn,unssd[]);    // see above ! suppi and unssd are modified  
 unssd[] *= nnn;  //  to put value nnn a 0  
 real nnn0 = nnn - sizeoverlaps +  0.001   ;
 Thi=trunc(Thg,unssd>nnn0 ,label=10); // overlapping mesh3, interfaces have label 10
 
 settt 

 fespace Vhi(Thi,P1);
 int npij=npart;
 Vhi[int] pij(npij);// local partition of unit + pii 
 Vhi pii;  
 
 real nnn1=  + 0.001  ;
 { /*
   construction of the partition of the unit,
    let phi_i P1 FE function 1 on Thin and zero ouside of Thi and positive
    the partition is build with  
  $$  p_i = phi_i/ \sum phi_i 
    
    to build the partition of one domain i
    we nned to find all j such that supp(phi_j) \cap supp(phi_j) is not empty
    <=> int phi_j
 */
 //   build a local mesh3 of thii such that all compuation of the unit partition are
 //   exact in thii
 mesh3 Thii=trunc(Thg,unssd>nnn1 ,label=10); // overlapping mesh3, interfaces have label 10


 {  
   // find all j  mes (supp(p_j) \cap supp(p_i)) >0  
   // compute all phi_j on Thii
   //  remark supp p_i include in Thi 
   //  
   fespace Phii(Thii,P0);
   fespace Vhii(Thii,P1);
   Vhi sumphi=0;
   jpart=0;
   njpart=0;
   int nlayer=RAS?1:sizeoverlaps;
   if(ipart==0) 
     cout <<" nlayer=" << nlayer << endl;
   pii= max(unssd-nnn+nlayer,0.)/nlayer;
   if(dplot) plot(pii,wait=1,cmm=" 0000");
   sumphi[] +=  pii[];
   if(dplot) plot(sumphi,wait=1,cmm=" summ 0000");
   Vhii phii=0;
   real epsmes=1e-10*Thii.measure;
   for (int i=0;i<npart;++i)
     if(i != ipart ) 
       { 
	    Phii suppii=abs(i-part)<0.2; 
	    if(suppii[].max > 0.5) 
	    {
	     AddLayers(Thii,suppii[],nlayer,phii[]);
	     assert(phii[].min >=0);
	     real interij = int3d(Thi)(  phii); 
	     if(interij>epsmes) 
	       {  
		     pij[njpart]=abs(phii);	 
		     if(vdebug>2) cout << " ***** " << int3d(Thi)(real(pij[njpart])<0) << " " <<pij[njpart][].min << " " << phii[].min << endl;
		     assert(int3d(Thi)(real(pij[njpart])<0) ==0);
		     if(dplot)  plot(pij[njpart],wait=1,cmm=" j = "+ i + " " + njpart);
		     sumphi[] += pij[njpart][]; 
		     if(dplot)  plot(sumphi,wait=1,cmm=" sum j = "+ i + " " + njpart);
		     jpart[njpart++]=i;
	       }}}
   
   if(dplot) plot(sumphi,wait=1,dim=3,cmm="sum ",fill=1 );
   pii[]=pii[] ./ sumphi[];
   for (int j=0;j<njpart;++j)
     pij[j][] = pij[j][] ./ sumphi[];
   jpart.resize(njpart);	
   for (int j=0;j<njpart;++j)
     assert(pij[j][].max<=1);
   {
     cout << ipart << " number of jpart " << njpart << " : ";
     for (int j=0;j<njpart;++j)
       cout << jpart[j] << " ";
  	cout << endl;
   }
   sumphi[]=pii[];
   for (int j=0;j<njpart;++j)
     sumphi[]+= pij[j][];
   if(vdebug)  
     cout << " sum min " <<sumphi[].min << " " << sumphi[].max << endl;
   assert(sumphi[].min> 1.-1e-6 && sumphi[].max< 1.+1e-6);  
   //  verification 
 }}// (Thii is remove here) 
  // end of the construction of the local partition of the unity ...
  // on Thi ...  
  // -----------------------------------------------------------------
if(ipart==0) cout << " *** end build partition " << endl;

//  computation of  number of intersection ..
// ------------------------------------------

// here  pii and the pij is the locate partition of the unite on 
// Thi ( mesh3 with overlap )....
//Thi=splitmesh(Thi,2);
if(dplot ) 
  { plot(Thi,wait=1); 
    for(int j=0;j<njpart;++j)
      plot(pij[j],cmm=" j="+j ,wait=1); } 
      
//  Partition of the unity on Thi ..
// computation of message.
// all j> we have to recive 
// data on intersection of the support of pij[0] and pij[j]
settt 

 plotMPIall(Thi,pii[],"pi_i");

mesh3[int] aThij(njpart); 
matrix Pii;  
matrix[int] sMj(njpart); // M of send to j
matrix[int] rMj(njpart); // M to recv from j
fespace Whi(Thi,Pk);
mesh3 Thij=Thi;
fespace Whij(Thij,Pk);// 

// construction of the mesh3 intersect i,j part 
for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(Thi,pij[jp]>1e-6,label=10); // mesh3 of the supp of pij

for(int jp=0;jp<njpart;++jp)
  aThij[jp]  = trunc(aThij[jp],1,split=ksplit);

Thi =   trunc(Thi,1,split=ksplit);

settt 

if(ipart==0) cout << " *** end build mesh3  intersection  " << endl;
// construction of transfert  matrix
{
  Whi wpii=pii;
  Pii = wpii[];
  for(int jp=0;jp<njpart;++jp)
    {
      int j=jpart[jp];
      Thij = aThij[jp];
      matrix I = interpolate(Whij,Whi); // Whji <- Whi
      sMj[jp] = I*Pii;  // Whi -> s Whij  
      rMj[jp] = interpolate(Whij,Whi,t=1);   // Whji -> Whi
      if(vdebug>10) {
      {Whi uuu=1;Whij vvv=-1; vvv[]+=I*uuu[]; cout << jp << " %%% " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}
      {Whi uuu=1;Whij vvv=-1; vvv[]+=rMj[jp]'*uuu[]; cout << jp << " ### " << vvv[].linfty << endl; assert(vvv[].linfty < 1e-6);}}
    }}
if(ipart==0) cout << " *** end build transfert matrix " << endl;
// alloc array of send and recv data ..

InitU(njpart,Whij,Thij,aThij,Usend)  // initU(n,Vh,Th,aTh,U)
InitU(njpart,Whij,Thij,aThij,Vrecv) // ...
if(ipart==0) cout << " *** end init  data for send/revc  " << endl;

Whi ui,vi; 

func bool Update(real[int] &ui, real[int] &vi)
{
  for(int j=0;j<njpart;++j)
    Usend[j][]=sMj[j]*ui; 
   SendRecvUV(comm,jpart,Usend,Vrecv)
     vi = Pii*ui;
   for(int j=0;j<njpart;++j)
     vi += rMj[j]*Vrecv[j][]; 
   return true;
}


// the definition of the Problem ....
func G=1.; // ok 
func F=1.; // ok 
macro grad(u) [dx(u),dy(u),dz(u)] // 
varf vBC(U,V)=  on(1,U=G); 
varf vPb(U,V)= int3d(Thi)(grad(U)'*grad(V)) + int3d(Thi)(F*V) + on(10,U=0)+on(1,U=G) ; //');// for emacs
varf vPbC(U,V)= int3d(ThC)(grad(U)'*grad(V))  +on(1,U=0) ; //');// for emacs
varf vPbon(U,V)=on(10,U=1)+on(1,U=1);
varf vPbon10only(U,V)=on(10,U=1)+on(1,U=0); 

//----  

matrix Ai = vPb(Whi,Whi,solver=sparsesolver);
matrix AC,Rci,Pci;// 


if(mpiRank(comm)==0)
  AC = vPbC(VhC,VhC,solver=sparsesolver);

Pci=   interpolate(Whi,VhC);
Rci =  Pci'*Pii; 

real[int] onG10 = vPbon10only(0,Whi);
real[int] onG = vPbon(0,Whi);
real[int] Bi=vPb(0,Whi);





int kiter=-1;


func bool  CoarseSolve(real[int]& V,real[int]& U,mpiComm& comm)
{
   //  solving the coarse probleme 
   real[int] Uc(Rci.n),Bc(Uc.n); 
   Uc= Rci*U;
   mpiReduce(Uc,Bc,processor(0,comm),mpiSUM);
   if(mpiRank(comm)==0) 
      Uc = AC^-1*Bc;
    broadcast(processor(0,comm),Uc);
   V = Pci*Uc;
}//EOF ...
func real[int] DJ(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
   V =  Ai*U;
  V = onG10 ? 0.: V;  // remove internal boundary  
  return V; 
}

func real[int] PDJ(real[int]& U) // C1
{ 
  real[int] V(U.n); 
  
  real[int] b= onG10 ? 0. :  U; 
  V =  Ai^-1*b;	
  Update(V,U);
  return U; 
}

func real[int] PDJC(real[int]& U) // 
{ // Precon  C1= Precon //, C2  precon Coarse
// Idea : F. Nataf. 
  //  0 ~  (I C1A)(I-C2A) => I ~  - C1AC2A +C1A +C2A 
  //  New Prec P= C1+C2 - C1AC2   = C1(I- A C2) +C2
  // (  C1(I- A C2) +C2 ) Uo 
  //   V =  - C2*Uo
  // .... 
  real[int] V(U.n); 
  CoarseSolve(V,U,comm);
  V = -V; //  -C2*Uo 
  U  += Ai*V; // U =  (I-A C2) Uo 
  real[int] b= onG10 ? 0. :  U; 
  U =  Ai^-1*b;	//  ( C1( I -A C2) Uo 
  V = U -V; //  
  Update(V,U);
  return U; 
}


 func real[int] DJ0(real[int]& U)
{ 
  ++kiter;
  real[int] V(U.n); 
  real[int] b= onG .* U;
  b  = onG ? b : Bi ;  
  V = Ai^-1*b;	
  Update(V,U);
  V -= U;
   return V; 
}


Whi u=0,v;
{ // verification.....
  Whi u=1,v;
  Update(u[],v[]);
  u[]-=v[];
  assert( u[].linfty<1e-6); }
  


settt
u[]=vBC(0,Whi,tgv=1); // set u with tge BC value ...

real epss=1e-6;
int rgmres=0;
if(gmres==1)
  {
   rgmres=MPIAffineGMRES(DJ0,u[],veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
   real[int] b= onG .* u[];
   b  = onG ? b : Bi ;
   v[] = Ai^-1*b;	
   Update(v[],u[]);
  }
else if(gmres==2)
  rgmres= MPILinearGMRES(DJ,precon=PDJ,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else if(gmres==3)
   rgmres= MPILinearGMRES(DJ,precon=PDJC,u[],Bi,veps=epss,nbiter=300,comm=comm,dimKrylov=100,verbosity=ipart ? 0: 50);
else // algo Shwarz for demo ...
   for(int iter=0;iter <10; ++iter)
     {
       real[int] b= onG .* u[];
       b  = onG ? b : Bi ;
       v[] = Ai^-1*b;	
       
       Update(v[],u[]);
       if(vdebug) plotMPIall(Thi,u[],"u-"+iter);
        v[] -= u[];
       
       real err = v[].linfty;
       real umax = u[].max;
       real[int] aa=[err,umax], bb(2);
       mpiAllReduce(aa,bb,comm,mpiMAX);
       real errg = bb[0];
       real umaxg = bb[1];
       
       if(ipart==0)
	     cout << ipart << " err = " << errg << " u. max  " << umaxg << endl;
       if(errg< 1e-5) break;
     }
if(vdebug) plotMPIall(Thi,u[],"u-final");

settt

real errg =1,umaxg;
{ 
  real umax = u[].max,umaxg;
  real[int] aa=[umax], bb(1);
  mpiAllReduce(aa,bb,comm,mpiMAX);
  errg=bb[0];
  if(ipart==0)
    cout << " umax global  = " << bb[0] << " Wtime = " << (ttt[ittt-1]-ttt[ittt-2])  << " s " <<  " " << kiter <<  endl;
}

if(sff != "")
  {
    ofstream ff(sff+".txt",append);
    cout << " ++++  " ;
    cout  << mpirank <<"/" <<  mpisize << " k=" <<  ksplit << " n= " << nloc << " " << sizeoverlaps << " it=  " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      cout << " " << ttt[i]-ttt[i-1] << " ";
    cout << epss << " " << Ai.nbcoef << " " << Ai.n << endl;
    
    /*
      1 mpirank
      2 mpisize 
      3 ksplit 
      4 nloc
      5 sizeoverlaps
      6 kiter
      7 mesh3 & part build  
      8 build the partion 
      9 build mesh3, transfere , and the fine mesh3 .. 
      10 build the matrix,  the trans matrix, factorizatioon 
      11 GMRES 
    */
    ff   << mpirank << " " << mpisize << " " << sPk << " " ;
    ff <<  ksplit << " " << nloc << " " << sizeoverlaps << " " << kiter  ;  
    for (int i=1; i<ittt;++i)	
      ff << " " << ttt[i]-ttt[i-1] << " ";
    ff << epss << " " << Ai.nbcoef << " " << Ai.n << " " << gmres << endl;
    
  }
//  a new coding  methode de schwarz 
//  -------------------------------
// F.Hecht december 2003
// ----------------------------------
//  to test the broadcast instruction 
//  add add the stop test 
//  ---------------------------------
// NBPROC 2

if ( mpisize != 2 ) {
cout << " sorry number of processeur !=2 " << endl;
exit(1);}
verbosity=3;
real pi=4*atan(1);
int inside = 2;
int outside = 1;
border a(t=1,2){x=t;y=0;label=outside;};
border b(t=0,1){x=2;y=t;label=outside;};
border c(t=2,0){x=t ;y=1;label=outside;};
border d(t=1,0){x = 1-t; y = t;label=inside;};
border e(t=0, pi/2){ x= cos(t); y = sin(t);label=inside;};
border e1(t=pi/2, 2*pi){ x= cos(t); y = sin(t);label=outside;}; 
int n=4;
mesh Th0,Th1;

if (mpirank == 0) 
 Th0 = buildmesh( a(5*n) + b(5*n) + c(10*n) + d(5*n));
else
 Th1 = buildmesh ( e(5*n) + e1(25*n) );

broadcast(processor(0),Th0);
broadcast(processor(1),Th1);

fespace Vh1(Th1,P1);
fespace Vh0(Th0,P1);
Vh0 u0,v0;	
Vh1 u1=0,v1;

int i=0;

problem pb0(u0,v0,init=i,solver=Cholesky) = 
    int2d(Th0)( dx(u0)*dx(v0)+dy(u0)*dy(v0) )
  + int2d(Th0)( -v0) + on(inside,u0 = u1)  +    on(outside,u0= 0 ) ;

problem pb1(u1,v1,init=i,solver=Cholesky) = 
    int2d(Th1)( dx(u1)*dx(v1)+dy(u1)*dy(v1) )
  + int2d(Th1)( -v1) + on(inside ,u1 = u0) +    on(outside,u1 = 0 ) ;


for ( i=0 ;i< 20; i++) 
{ 
  cout << mpirank << " looP " << i << endl;
  if (mpirank == 0)
    pb0; 
   else
    pb1;
   broadcast(processor(0),u0[]);
   broadcast(processor(1),u1[]);
   real err0,err1;
   if (mpirank == 0)
     err0 = int1d(Th0,inside)(square(u0-u1)) ;
   else 
     err1= int1d(Th1,inside)(square(u0-u1)) ;
   broadcast(processor(0),err0);
   broadcast(processor(1),err1);  
   real err= sqrt(err0+err1);
   cout <<" err = " << err << " err0 = " << err0 << ", err1 = " << err1 << endl;
   if(err<1e-3) break;
};
 if (mpirank==0)  
    plot(u0,u1,ps="u0-u1.eps");
//ff-mpirun  -np  4 heat-torus-3d-surf.edp -wg -ffddm_schwarz_method ras -ffddm_geneo_nu 10 -global 5

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -ffddm_schwarz_method ras -ffddm_geneo_nu 10 -global 5

macro dimension 3S// EOM            // 2D or 3D

include "ffddm.idp"

load "msh3"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

real R = 3, r=1; 
int nx = r*2*pi*getARGV("-global", 5);
int ny = R*2*pi*getARGV("-global", 5);

meshS ThGlobal = square3(nx,ny,[(R+r*cos(2*pi*x))*cos(2*pi*y),(R+r*cos(2*pi*x))*sin(2*pi*y),r*sin(2*pi*x)]);

func f = 100*exp(-20*((x-0)^2+(y-(R+r))^2+z^2));

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int2d(meshName)(u*v + dt * grad(u)' * grad(v)) +int2d(meshName)(un*v + f*v);
// EOM

int nt = 50;
real dt = 0.5;

ffddmbuildDmesh(Lap, ThGlobal, mpiCommWorld)
ffddmbuildDfespace(Lap, Lap, real, def, init, P1)

LapVhi u, un;

ffddmsetupOperator(Lap, Lap, Varf)
ffddmsetupPrecond(Lap, Varf)
ffddmgeneosetup(Lap, Varf)

real[int] rhs(LapVhi.ndof);

un = 0;

for (int i = 0; i < nt; i++) {
  ffddmbuildrhs(Lap, Varf, rhs)
  u[] = LapfGMRES(un[], rhs, 1.e-6, 200, "right");
  ffddmplot(Lap,u, "u");
  un[] = u[];
}

Lapwritesummary
//ff-mpirun  -np 4 diffusion-3d-minimal-direct.edp -wg -raspart -global 20

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// Abstract "Lap: Direct solver (MUMPS) :" << endl;//direct parallel solver 

// for the make check:
// NBPROC 4
// PARAM -raspart -global 20

load "msh3"

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient

int[int] LL = [2,2, 1,2, 2,2];
mesh3 ThGlobal = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10),
    [x, y, z], label = LL);      // global mesh

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int3d(meshName)(grad(u)' * grad(v)) + int3d(meshName)(v) + on(1, u = 1.0); // EOM
       
// Domain decomposition
ffddmbuildDmesh( Lap , ThGlobal , mpiCommWorld )
ffddmbuildDfespace( Lap , Lap , real , def , init , P1 )
ffddmsetupOperator(Lap ,Lap , Varf)

// Distributed Direct solve
real[int] rhs(LapVhi.ndof);//rhs(1) works as well 
ffddmbuildrhs(Lap , Varf , rhs )
LapVhi def(udirectsolver);

//Direct solve
udirectsolver[] = Lapdirectsolve(rhs);
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,udirectsolver, "Lap Global solution with direct solver");


//ff-mpirun  -np 4 Richards-2d.edp -wg -ns -ffddm_disable_plots

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -ffddm_disable_plots -nt 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

int nt = getARGV("-nt", 100);

searchMethod = 1; // safe search algo, use brute force in case of missing point

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P1;

real Ks=0.01,
     hg=30,
     thetas=0.3,
     eta = 6.55,
     m = 0.173,
     n = 2/(1-m);
     
     
real z0=215;
real q0=15/3600.;
real dt=60;

// $A(h) - \partial h / \partial t - div(K(h)(\nabla(h-y)) = f $ dans $ \Omega$
//  -K(h)(\nabla(h-y)). n = q0 $ sur $ \Gamma_1$
//  h = h_0$ sur $\Gamma_0$
//  + condition initial $d_d$
//   A(h) = h <0 ? C(h) : 0; 
//  


// remarque z == y 
real xmax = 300, ymax=300, x0=60, y0= 215;

border ba(t=0,ymax)   { x=0; y=ymax-t ;label=2;};  // left   
   
border bb1(t=x0,0)    { x=t; y=ymax ;label=1;};   // top     1 
border bb2(t=xmax,x0) { x=t; y=ymax ;label=2;};  // top   2   
 
border bc1(t=y0,0) { x=xmax; y=ymax-t ;label=2;};  // right     
border bc2(t=ymax,y0) { x=xmax; y=ymax-t ;label=3;};  // right  
   
border bd(t=0,xmax)   { x=t; y=0; label=4;};   // bottom

int Gamma0=3;
int Gamma1=1;

int nn=20;
int nn1=nn*x0/xmax,nn2=nn-nn1;
int ny1=nn*y0/ymax,ny2=nn-ny1;
plot(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn),wait=1);
mesh Th=buildmesh(ba(nn)+bb1(nn1)+bb2(nn2)+bc1(ny1)+bc2(ny2)+bd(nn));
plot(Th,wait=1);

mesh Thc = Th;

fespace Vh(Th,P1);
Vh h,v,hhh;

macro theta(h) (thetas*(1+((abs(h)/hg))^n)^(-m))//
macro dtheta(h) (m*n*thetas*(1+((abs(h)/hg))^n)^(-m-1)*(((abs(h)/hg))^(n-1))/hg)
//
macro A(h)  ( (h<=0)* dtheta(h) ) 
//
macro K(h) (Ks*((h<=0)*((theta(h)/thetas)^eta)+ (h>0)))
//

Vh hd= -y0+(ymax-y); // bof bof ????
Vh hn=hd,hh;
Vh Ahdt,Kh;

int nbiso=20;
real[int] viso(3+(75+110/2)/5);

{int k=0;
for(int i=-75;i<0;i+=5)
 viso(k++)=i;
 viso(k++)=-0.5;
 viso(k++)=0.;
 viso(k++)=0.5;
for(int i=5;i<=110;i+=5*2)
 viso(k++)=i;
}
/* 
problem Richard(h,v) =
  int2d(Th)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(Th)( Ahdt* hn*v - Kh* dy(v) )
- int1d(Th,Gamma1)(q0*v)
+ on(3,h=(ymax-y)-y0)
;
*/

real pena=1e10;

macro VarfPb(varfName, meshName, VhName)

  VhName mh, mhn;
  RfromVhi(hi[],VhName,mh[])
  RfromVhi(hin[],VhName,mhn[])
  VhName Ahdt = A(mh)/dt;
  VhName Kh = K(mh);

  varf varfName(h,v) =
  int2d(meshName)( Ahdt * h * v+ Kh* (dx(h)*dx(v)+dy(h)*dy(v)) )
- int2d(meshName)( Ahdt* mhn*v - Kh* dy(v) )
- int1d(meshName,Gamma1)(q0*v)
 +int1d(meshName,3)(pena*h*v)-int1d(Th,3)(pena*((ymax-y)-y0)* v)

; // EOM

plot(hn,wait=1,cmm=" hd ");

macro Rdefmplot(u)u//EOM

//macro Rwithhpddmkrylov()1//EOM

ffddmbuildDmeshAug(R,Th,mpiCommWorld)

ffddmbuildDfespace(R,R,real,def,init,Pk)

ffddmsetupinit(R,R)// 

ffddmset(R,verbosity,1)// 

RVhi hi=hd, hin=hd;

real[int] rhs;

// Richard;
// plot(hd,wait=1,cmm="hd ----");
real temps=0;
for(int ii=0;ii<nt;ii++)
{
  string scmm="h + temps "+int(temps)/3600+"h "+ ((temps)%3600/60.) + "mn ";
  for(int k=0;k<3;k++) 
  {

	ffddmsetup(R,R,VarfPb,null)
	
	ffddmbuildrhs(R,VarfPb,rhs)
	
	rhs = -rhs;
  
  //cout << " "<< Kh[].min << " " << Kh[].max << endl;
 // plot(Ahdt,fill=1,value=1,wait=1,cmm="Ahdt");
 // plot(Kh,fill=1,value=1,wait=1,cmm="Kh");
 // plot(Kh,wait=1,cmm="Kh");

	hi[] = RfGMRES(hi[], rhs, -1.e-6, 200, "right");

  // forces a refresh of the FE function h, so that it is defined on the currrent mesh Th
  // in particular, the underlying array h[] has the correct size
  h = 0.;
  
	RfromVhi(hi[],Vh,h[]);

  // plot(h,wait=0,cmm=scmm,viso=viso);
//  hhh = h <0;
  }
  if(ii%10==1) {
  Th=adaptmesh(Th,h,ratio=1.1,err=2e-2);
  broadcast(processor(0),Th);
  
  // the mesh has changed ; we create a new decomposition and obtain new local meshes
  ffddmbuildDmeshAug(R,Th,mpiCommWorld)
  ffddmbuildDfespace(R,R,real,def,init,Pk)
  // interpolate the solution at the previous time step on the new local mesh 
  hi = h;
  
//  plot(Th,h,cmm="h ",value=1,wait=1);
  }
 // plot(hhh,wait=1,cmm="h < 0");

  plot(h,wait=0,cmm=scmm,viso=viso,value=1);
//  plot(h,cmm="h ",value=1);
  hin = hi;
  temps += dt;
}

Rwritesummary
//ff-mpirun -np 8 natural_convection_3D_obstacle.edp -raspart -ffddm_schwarz_method oras -wg -ffddm_medit -global 9 -CSsplit 3

//large scale case : ff-mpirun  -np 224 natural_convection_3D_obstacle.edp -raspart -ffddm_schwarz_method oras -ns -nw -global 36 -noGlob -CSsplit 6 -ffddm_master_p 2 -ffddm_master_exclude 1

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -Ra 1e4 -global 4 -CSsplit 2

macro dimension()3// EOM            // 2D or 3D

include "ffddm.idp"

load "msh3"

searchMethod = 1;

macro def(i)[i, i#B, i#C, i#D, i#E]// EOM     // vector field definition
macro init(i)[i, i, i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u),dz(u)]// EOM   // two-dimensional gradient
macro Grad(u1,u2,u3)[dx(u1),dy(u1),dz(u1),dx(u2),dy(u2),dz(u2),dx(u3),dy(u3),dz(u3)]//
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
macro UgradU(uw,u)[[uw,uw#B,uw#C]'*grad(u),[uw,uw#B,uw#C]'*grad(u#B),[uw,uw#B,uw#C]'*grad(u#C)]//
func Pk = [P2, P2, P2, P1, P1];             // finite element space

real Ra=getARGV("-Ra", 1.e4);
real Pr=0.71;
real Rey=sqrt(Ra/Pr);
real IRe=1./Rey, IRa=Ra/(Rey*Rey*Pr), IPr=1./(Rey*Pr);

real Thot=0.5, Tcold=-0.5, Tin=0.8;

real eps = 1e-7; // penalisation dans Navier-Stokes

int newtonMax = 20; 
real tolNewton = 1.e-3;

real coef;

int np = getARGV("-global", 6);

int mysplit = getARGV("-CSsplit", 3);

// maillage grossier pour le precond 2 niveaux
mesh3 Thc = cube(np/mysplit,np/mysplit,np/mysplit, [x, y, z]);
Thc = trunc(Thc,(((x>0.66|x<0.33) |(y>0.66|y<0.33)| (z>0.66|z<0.33))),label=20);

// maillage fin defini en splittant le maillage grossier : on split les aretes du maillage grossier en 3 (parametre mysplit) -> les 2 maillages sont emboites
mesh3 ThGlobal = trunc(Thc,1,split=mysplit);

//macro NCdefplot(u)u#E//

// on construit la decomposition avec recouvrement (le "aug" signifie qu'on fait egalement le necessaire pour pouvoir recuperer la solution syncronisee sur les ThAugmented, ce qui va nous servir pour avoir la matrice restreinte au sous-domaine (qui depend de la solution precedente) correcte).
// "NC" est un prefixe, un nom qu'on choisit en input, qui va correspondre a une simulation (on peut combiner et resoudre de maniere differente plusieurs problemes dans le meme script)
// Toutes les structures de donnees creees par la suite auront un nom prefixe par "NC"
ffddmbuildDmeshAug(NC,ThGlobal,mpiCommWorld)
ffddmbuildDfespace(NC,NC,real,def,init,Pk)

// tgv = -1 -> pseudo elimination pour les conditions de Dirichlet (on met 1 sur la diagonale et 0 ailleurs sur la ligne).
vtgv = -1;
vtgvelim = -1;
vsym = 0;

// la definition de la macro ci-dessous signifie qu'on veut utiliser le GMRES d'hpddm, mais avec notre preconditionneur (par defaut si on ne la definit pas on utilise un GMRES parallele "maison" en freefem, defini dans ffddm_functions.idp)
macro NCwithhpddmkrylov()1//

// on initialise les structures pour le 1er niveau du precond (tout sauf ce qui depend de l'edp -- on apellera plus tard ffddmsetup(NC,Varf,VarfOpt) a chaque iteration pour assembler les matrices locales a partir des formulations variationnelles, qui changent a chaque iteration)
ffddmsetupinit(NC,NC)

// NCpCS est le nombre de coeurs qui s'occupent du probleme grossier, donne par -ffddm_master_p (1 par defaut). Si NCpCS > 1, alors on "distribue" les elements du maillage grossier en utilisant les regions, pour distribuer plus tard l'assemblage du probleme grossier sur les NCpCS coeurs.
if (NCpCS > 1) {
	int[int] nupart(Thc.nt);
	nupart=0;
	if (mpirank == 0)
		scotch(nupart, Thc, NCpCS);
	if (mpirank < NCpCS) {
		broadcast(processor(0,NCcommCS),nupart);
		Thc=change(Thc,fregion=nupart[nuTriangle]);
	}
}

// on initialise les structures pour le 2e niveau (grossier) du precond (tout sauf ce qui depend de l'edp -- on apellera plus tard ffddmcoarsemeshsetup(NC,Thc,VarfCS,null) a chaque iteration pour assembler la matrice du probleme grossier)
ffddmcoarsemeshsetupinit(NC,Thc)

// [uG,uGB,uGC,pG,TG] est destinee a etre l'interpolation de la solution sur le maillage grossier et interviendra dans l'assemblage du probleme grossier (mais en fait on ne va pas l'utiliser car ca marche beaucoup mieux sans !)
NCVhCoarse [uG,uGB,uGC,pG,TG];
uG[] = 0;

ffddmset(NC,verbosity,10)

// solutions locales
NCVhi [ui,uiB,uiC,pi,Ti], [upi,upiB,upiC,ppi,Tpi];

real[int] rhs;

// la formulation variationnelle pour le probleme initial (pour le produit matrice-vecteur A). On va l'assembler sur les maillage locaux "augmentes" (anciennement les ThAugmented).
macro Varf(varfName, meshName, VhName)
	/* on syncronise la solution precedente (ui[] en local) sur les maillages locaux augmentes. le fespace courant qu'on utilise est "VhName" (qui correspondra au fespace sur maillages augmentes). Le resultat est uG (solution qui est donc syncronisee sur les maillages augmentes apres le call). */
	VhName [uG,uGB,uGC,pG,TG];
	NCfromVhi(ui[],VhName,uG[])
	
    varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(uG,uw)'*[v,vB,vC]
         + UgradU(uw,uG)'*[v,vB,vC]
         + ( Grad(uw,uwB,uwC)'*Grad(v,vB,vC))*IRe
         - coef*IRa*Tw*vB
         -[uG,uGB,uGC]'*grad(W)*Tw
         -[uw,uwB,uwC]'*grad(W)*TG
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

// la formulation variationnelle pour le probleme grossier. On enleve les termes qui dependent de la solution precedente, et ca marche quand meme tres bien.
macro VarfCS(varfName, meshName, VhName)
    varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         /*+ UgradU(uG,uw)'*[v,vB,vC]
         + UgradU(uw,uG)'*[v,vB,vC]*/
         + ( Grad(uw,uwB,uwC)'*Grad(v,vB,vC))*IRe
         - coef*IRa*Tw*vB
         /*-[uG,uGB,uGC]'*grad(W)*Tw
         -[uw,uwB,uwC]'*grad(W)*TG*/
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

// la formulation variationnelle pour le 1er niveau du preconditionneur (optimized schwarz). On integre sur les maillages locaux (NCThi), donc on peut utiliser directement la solution locale precedente ui. La condition optimisee sur les interfaces (bord 10) est un choix a faire, celle-ci semble bien marcher.
macro VarfOpt(varfName, meshName, VhName)
    varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(ui,uw)'*[v,vB,vC]
         + UgradU(uw,ui)'*[v,vB,vC]
         + ( Grad(uw,uwB,uwC)'*Grad(v,vB,vC))*IRe
         - coef*IRa*Tw*vB
         -[ui,uiB,uiC]'*grad(W)*Tw
         -[uw,uwB,uwC]'*grad(W)*Ti
         + grad(Tw)'*grad(W)*IPr)
    + int2d(meshName,10)(20./hTriangle*IRe*[uw,uwB,uwC]'*[v,vB,vC]+20*1./hTriangle*[pw, Tw]'*[q, W])
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

macro Varfrhs(varfName, meshName, VhName)
	varf varfName([uw, uwB, uwC, pw, Tw], [v, vB, vC, q, W]) =
     int3d(meshName)(
         UgradU(ui,ui)'*[v,vB,vC]       
         - [ui,uiB,uiC]'*grad(W)*Ti       
     )
    + on(1,2,3,4,5,6,20, uw=0,uwB=0,uwC=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot)
    +on(20,Tw=Tin);
// EOM

int nstep= max((int(log10(Ra)-4)^2), 2)*max(log10(Ra)-7.,1.);

[ui,uiB,uiC,pi,Ti]=[0,0,0,0,Thot+x*(Tcold-Thot)];

int iter=0;

for(int step=1; step <= nstep; ++step)
{
   iter++;

    real err=1e100;
    real errp = err;
    coef = (step/real(nstep))^3; // continuation sur le coef en temperature ...
    if (mpirank == 0)
      cout<< "---------------  continuation coef*Ra=" << coef*Ra << endl;

   // Iteration de Newton ---------------------------
   for(int niter=0 ; niter < newtonMax ; niter++){
   	
   	 //le call NCfromVhi permet d'interpoler la solution locale fine sur le maillage grossier, mais on a finalement enleve les termes qui dependent de la solution precedente dans le probleme grossier
	 //NCfromVhi(ui[],NCVhCoarse,uG[])

	 // on assemble les matrices locales (Varf pour le produit matrice-vecteur A, VarfOpt pour le 1er niveau du preconditionneur)
	 ffddmsetup(NC,NC,Varf,VarfOpt)
	 
	 // on assemble le probleme grossier. On repasse pour l'occasion en mode penalisation exacte avec des 1e+30 sur la diagonale pour les conditions de Dirichlet, ca marche en general mieux et c'est plus simple lorsque la matrice est distribuee (sur les NCpCS coeurs du probleme grossier).
	 // remarque : si -ffddm_master_exclude 1, les calls ffddmsetup et ffddmcoarsemeshsetup sont faits en parallele : les coeurs qui ne s'occupent que du 1er niveau assemblent les matrices locales dans ffddmsetup, et les coeurs qui ne s'occupent que du probleme grossier l'assemblent dans ffddmcoarsemeshsetup
	 vtgv = 1.e+30/NCpCS; 
	 ffddmcoarsemeshsetup(NC,Thc,VarfCS,null)	 
	 vtgv = -1;
	 
	 // assemblage du second membre
     ffddmbuildrhs(NC,Varfrhs,rhs)

	 // resolution
     ui[] = NCfGMRES(ui[], rhs, 1.e-8, 200, "right");
     
     upi[] -= ui[];
     real reduce = upi[].linfty;
     upi[]  = ui[];
     mpiAllReduce(reduce, err, mpiCommWorld, mpiMAX);

     if(mpirank == 0)
	   cout << "niter = " << niter << " err =  " << err << endl;

     if(err > errp*100) break;
     if(err < tolNewton) break;
   }
   
   ffddmplot(NC,Ti, "Global solution");

}

NCwritesummary

// on peut aussi automatiquement mettre la solution locale ui sur n'importe quel maillage (global) avec NCfromVhi, qui interpole et fait les communications
fespace Vhg(ThGlobal,Pk);
Vhg [u1s,u2s,u3s,ps,Ts];
NCfromVhi(ui[],Vhg,u1s[])

int[int] fforder=[1,1,1,1];
load "iovtk"
if (mpirank == 0)
	savevtk("sol.vtk",ThGlobal,u1s,u2s,u3s,Ts,dataname="VelocityX VelocityY VelocityZ Temperature",order=fforder);

//ff-mpirun  -np  4 diffusion-3d-simple.edp -wg -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "msh3"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

int[int] LL = [2,2, 1,2, 2,2];
mesh3 ThGlobal = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10),
    [x, y, z], label = LL);      // global mesh


macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int3d(meshName)(grad(u)' * grad(v)) + int3d(meshName)(v) + on(1, u = 1.0); // EOM
       
// Domain decomposition
ffddmbuildDmesh( Lap , ThGlobal , mpiCommWorld )
savemesh(LapThi,"localTh"+mpirank+".mesh");
ffddmbuildDfespace( Lap , Lap , real , def , init , P1 )
ffddmsetupOperator( Lap , Lap , Varf)

//distributed matrix vector product
LapVhi uux=1.;
real[int] Au = LapA(uux[]);

// Distributed Direct and domain decomposition solves
real[int] rhs(LapVhi.ndof);//rhs(1) works as well 
ffddmbuildrhs(Lap,Varf,rhs)
LapVhi def(u) , def(udirectsolver);

//Direct solve
if (mpirank == 0) cout << endl << "Lap: Direct solver (MUMPS) :" << endl;//direct parallel solver 
udirectsolver[] = Lapdirectsolve(rhs);
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,udirectsolver, "Lap Global solution with direct solver");

// Two-level Schwarz solve
if (mpirank == 0) cout << endl << "Lap: RAS + GENEO :" << endl; //second level method with a GenEO coarse space
ffddmsetupPrecond(Lap,Varf)
ffddmgeneosetup(Lap,Varf)

real[int] x0(LapVhi.ndof);
x0 = 0;
u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,u, "Lap Global solution with fGMRES");

// Visualization and computation of relative error w.r.t. direct solver 
LapVhi error;
error[] = u[]-udirectsolver[];
real solnorm2 = Lapscalprod(u[],u[]) ,  errnorm2 = Lapscalprod(error[],error[])  ;
if(mpirank == 0) cout << endl << "Relative error w.r.t. to direct solver : " <<  sqrt(errnorm2/solnorm2) << "\n" << endl;
ffddmplot(Lap,error, "Difference between direct and ddm solve");

real solnorm2global = Lapscalprod(u[],u[]);

cout << solnorm2 << " ==  " <<  solnorm2global << "??"  << endl;









load "msh3"
load "geophysics"

include "getARGV.idp"

real gtol = getARGV("-tol",1e-4);

func Pk = P2;

real freq = getARGV("-frequency",10.); // frequency
real nppwl = getARGV("-nppwl",5.); // number of points per wavelength

macro dimension 2// EOM            // 2D or 3D
include "ffddm.idp"

real c0 = 2;

//Marmousi marm("marmousi.bin");
func c = c0;//marm(x,y);

func k = 2*pi*freq/c;

real k0 = 2*pi*freq/c0;

real lambda = c0/freq;

int Robin = 2;
int[int] lab = [Robin,Robin,Robin,Robin];

real length = 9.2;
real depth = 3;

mesh Th = square(nppwl*length/lambda,nppwl*depth/lambda,[x*length,-y*depth],label=lab);

fespace Uh(Th,P1);
Uh met = c/freq/nppwl;
Th = adaptmesh(Th,met,IsMetric=1,nbvx=1000000);

func source = exp(-((x-6)^2+y^2)*50*k0);

ffddmoverlap = 0;
macro mminoverlap()1//
ffddmbuildDmesh(,Th,mpiCommWorld)

macro def(i)i// EOM
macro init(i)i// EOM
ffddmbuildDfespace( , ,complex,def,init,Pk)

macro Grad(u) [dx(u),dy(u)] // EOM

varf vAi(u,v) = int2d(Thi)(-k^2*u*v+Grad(u)'*Grad(v))
				      - int1d(Thi,Robin)(1i*k*u*v);

varf vrhs(u,v) = int2d(Thi)(source*v);

matrix<complex> Ai = vAi(Vhi,Vhi);

int[int] labG=[ffddminterfacelabel];
meshL Gammai = extract(Thi,label=labG);

fespace GammaVhi(Gammai,Pk);

matrix<complex> Ric;
{
  matrix Ri = interpolate(GammaVhi,Vhi);
  Ric = Ri;
}

matrix<complex> Ti;
/*
{
varf vTi(u,v) = int1d(Gammai)(k*u*v);
Ti = vTi(GammaVhi,GammaVhi);
}
*/
{
load "bem"
varf vH(u,v) = int1dx1d(Gammai)(Gammai)(BEM(BemKernel("HS",k=1i*k0),u,v));  
HMatrix<complex> H = vH(GammaVhi,GammaVhi,commworld=mpiCommSelf,compressor="SVD");
display(H);
complex[int,int] mdense(GammaVhi.ndof, GammaVhi.ndof);
mdense = H;
Ti = mdense;
if (mpirank == 0) cout << H.infos << endl;
}

matrix<complex> GTi = Ric'*Ti;
GTi = GTi*Ric;

matrix<complex> Li = Ai - 1i*GTi;
set(Li,solver=sparsesolver,commworld=mpiCommSelf,factorize=3);

matrix<complex> mat;

complex[int] GammaDk = Ric*Dk[mpirank];
{
  complex[int] Diinv = 1./GammaDk;
  matrix<complex> mDiinv = Diinv;
  mat = mDiinv*Ti;
}

int[int][int] petscintersection(1 + numberIntersection);
{
  petscintersection[0].resize(arrayIntersection.n);
  petscintersection[0] = arrayIntersection;
  complex[int] CC;
  int[int] II;
  for (int j=0; j<numberIntersection;j++) {
    matrix<complex> RR = restrictionIntersection[j]*Ric';
    [II, petscintersection[1 + j], CC] = RR;
    if (CC[CC.n-1] == 0) petscintersection[1 + j].resize(CC.n-1);
  }
}

real[int] petscD = GammaDk.re;

load "PETSc-complex"
Mat<complex> Tpetsc(mat, petscintersection, petscD, communicator = mpiCommWorld);

set(Tpetsc,sparams="-ksp_converged_reason -pc_type lu -ksp_rtol "+gtol);

complex[int] ti(GammaVhi.ndof), qi(GammaVhi.ndof), di(GammaVhi.ndof), gi(GammaVhi.ndof), Tg(GammaVhi.ndof);
complex[int] ui(Vhi.ndof), vti(Vhi.ndof);

func complex[int] OP(complex[int] &pi)
{
  ti = Ti*pi;
  vti = Ric'*ti;
  ui = Li^-1*vti;

  qi = Ric*ui;
  qi *= -2i;

  di = pi - qi;

  gi = Ti*di;

  exchange(Tpetsc,gi,scaled=false);

  Tg = 0;
  Tg = Tpetsc^-1*gi;

  complex[int] res = qi + 2*Tg;

  return res;
}

complex[int] rhsi = vrhs(0,Vhi);
update(rhsi,true);

GammaVhi<complex> soli, bi;
{
  complex[int] vi = Li^-1*rhsi;

  bi[] = Ric*vi;
  bi[] *= 2i;

  complex[int] tmp = Ric * vi;
  complex[int] gi = Ti*tmp;
  gi *= 2i;
  
  exchange(Tpetsc,gi,scaled=false);

  complex[int] ri(gi.n);
  ri = Tpetsc^-1*gi;
  bi[] -= 2*ri;
}

Mat<complex> OPshell(GammaVhi.ndof);
Mat<complex> OPpetsc(OPshell,OP);
set(OPpetsc,sparams = "-ksp_monitor -pc_type none -ksp_rtol "+gtol);

soli[] = OPpetsc^-1*bi[];

complex[int] si = Ti*soli[];
complex[int] wi = Ric'*si;
wi += rhsi;

Vhi<complex> vi;

vi[] = Li^-1*wi;

ffddmplot(,real(vi), "Global solution");



//ff-mpirun -np 4 Helmholtz-2d-interfaceBCs-comp.edp -ns -wg

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -frequency 2.0

macro dimension 2// EOM            // 2D or 3D

load "msh3"
load "bem"
include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;

int Dirichlet = 1;
int Robin = 2;

int[int] labs=[Robin, Robin, Robin, Robin];
//int[int] labs=[Dirichlet, Dirichlet, Dirichlet, Dirichlet];

real freq = getARGV("-frequency",4.0);
func k = 2.*pi*freq;
real lambda = (1./freq);
if (mpirank == 0) cout << "lambda = " << lambda << endl;

real nppwl = getARGV("-nppwl",10.0);
real h = lambda/nppwl;

real length = 1.;
real lengthpml = getARGV("-lengthpml",1.0)*lambda;

real nloc = nppwl*length/lambda;
int npl = nloc*(length+2*lengthpml)/length;
mesh Th = square(npl,npl,[x*(length+2*lengthpml)-lengthpml, y*(length+2*lengthpml)-lengthpml], label = labs);

func f = 100*exp(-((x-length/2)^2+(y-length/2)^2)*k*10);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*u*v+Grad(u)'*Grad(v))
				- int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOptRobin(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*u*v+Grad(u)'*Grad(v))
				- int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

macro HFEdefmplot(u)real(u)//

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmsetupOperator(H,HFE,Varf)

ffddmprecond = "oras";

complex[int] rhs(1);
ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;
HFEVhi<complex> def(u);

{
NewMacro HRobinmyA()
func complex[int] HRobinA(complex[int] &l) {return HA(l);}
EndMacro

ffddmsetupinit(HRobin,HFE)

ffddmsetupPrecond(HRobin,VarfOptRobin)

if (mpirank == 0) cout << "Robin:" << endl;

u[] = HRobinfGMRES(x0, rhs, 1.e-6, 200, "right");

HRobinwritesummary
}

{
NewMacro HBEMmyA()
func complex[int] HBEMA(complex[int] &l) {return HA(l);}
EndMacro

meshL ThiL = extract(HmeshThi);
ThiL = OrientNormal(ThiL,unbounded=1);
ThiL = trunc(ThiL,region==10);

fespace VhiL(ThiL,Pk);
fespace Chi = HFEVhi*VhiL;

varf vc(<[ufem],[ubem]>,<[v1],[v2]>) = int2d(HmeshThi)(-k^2*ufem*v1+Grad(ufem)'*Grad(v1)) // F
                              - int1d(HmeshThi,Robin)(1i*k*ufem*v1)
                              + on(Dirichlet,ufem=0)
                              + int1dx1d(ThiL)(ThiL)(BEM(BemKernel("TDL",k=k),ubem,v1)) + int1d(ThiL)(0.5*ubem*v1) // TDL
                              + int1d(ThiL)(ufem*v2)                        // mass
                              + int1dx1d(ThiL)(ThiL)(BEM(-1*BemKernel("SL",k=k),ubem,v2));  // -SL

matrix<complex> HC = vc(Chi,Chi,commworld=mpiCommSelf,factorize=3);

complex[int] rhsi(HFEVhi.ndof+VhiL.ndof);
rhsi = 0;

HFEVhi<complex> ufem;
VhiL<complex> ubem;

NewMacro HBEMmyPREC()
func complex[int] HBEMPREC(complex[int] &l) {
  rhsi(0:HFEVhi.ndof-1) = l;
  complex[int] res = HC^-1*rhsi;
  [ufem[],ubem[]] = res;

  HFEupdate(ufem[],true);

  return ufem[];
}
EndMacro

ffddmsetupinit(HBEM,HFE)

if (mpirank == 0) cout << "BEM:" << endl;

u[] = HBEMfGMRES(x0, rhs, 1.e-6, 200, "right");

HBEMwritesummary
}

ffddmplot(HFE,real(u), "Global solution");


//ff-mpirun -np 8 elasticity-3d-simple.edp -wg -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 20 -global 10

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 20 -global 5

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "msh3"

macro def(i)[i, i#B, i#C]// EOM                         // vector field definition
macro init(i)[i, i, i]// EOM                        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1,P1,P1];                               // finite element space

int[int] LL = [2,3, 2,1, 2,2];
mesh3 ThGlobal = cube(6 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [6 * x, y, z], label = LL);

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11;
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
int dirichlet = 1;

macro Varf(varfName, meshName, PhName)
    varf varfName(def(u), def(v)) = int3d(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(meshName)(f * vC) + on(dirichlet, u = 0.0, uB = 0.0, uC = 0.0); // EOM

vtgv = -2;
vtgvelim = -2;
vsym = 1;

ffddmbuild(E,ThGlobal,real,def,init,Pk,mpiCommWorld)

//macro Ewithhpddm()1//

macro Edefmplot(u)u//

ffddmsetup(E,E,Varf,null)

real[int] rhs(1);

ffddmbuildrhs(E,Varf,rhs)

real[int] x0(rhs.n);
x0 = 0;

EVhi def(u), def(err);

//set(EhpddmOP,sparams="-hpddm_reuse_preconditioner 1");

if (mpirank == 0) cout << "RAS :" << endl; 

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO :" << endl; 

ffddmgeneosetup(E,Varf)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

err[] = EA(u[]);
err[] -= rhs;

ffddmplot(E,u, "Global solution");
ffddmplot(E,err, "Global residual");

EVhglob def(uglob);

EfromVhi(u[],EVhglob,uglob[])

real alpha = 20000.0;
EThglob = movemesh3(EThglob, transfo = [x + alpha * uglob, y + alpha * uglobB, z + alpha * uglobC]);
u[] = mpirank;

ffddmplot(E,u, "Deformed mesh");
//ff-mpirun -np 4 Helmholtz-2d-sweeping.edp -ns -wg -raspart -ffddm_overlap 4 -nppwl 4 -frequency 10

macro dimension 2// EOM
include "ffddm.idp"

ffddmprecond = "oras";

macro def(i)i// EOM // scalar field definition
macro init(i)i// EOM // scalar field initialization

real freq = getARGV("-frequency",10.); // frequency
int nppwl = getARGV("-nppwl",4); // number of points per wavelength
int npml = getARGV("-npml",4); // number of points for global PML

load "msh3"
load "geophysics"

int Dirichlet = 1;
int Robin = 2;
int Neumann = 7;
int PML = 8;

///*** Waveguide : ***///

real c0 = 1;
real k0 = 2*pi*freq/c0;
real lambda = c0/freq;
func Pk = P2;
int[int] lab = [Dirichlet,Robin,Dirichlet,Robin];
real length = mpisize;
real depth = 1;
func c = 1;
func source = 0;
func sourceGamma = (x < 1e-10)*exp(-120*(y+0.5)^2)*sin(-pi*y);


///*** Cavity : ***///
/*
real c0 = 1;
real k0 = 2*pi*freq/c0;
real lambda = c0/freq;
func Pk = P2;
int[int] lab = [Dirichlet,Robin,Dirichlet,Dirichlet];
real length = mpisize;
real depth = 1;
func c = 1;
func source = 0;
real theta = pi/8;
func sourceGamma = (x > length-1e-10)*exp(-1i*k0*(x*cos(theta)+y*sin(theta)));
*/
///*** Marmousi : ***///
/*
real c0 = 2;
real k0 = 2*pi*freq/c0;
real lambda = c0/freq;
func Pk = P2;
int[int] lab = [PML,PML,Neumann,PML];
real length = 9.2;
real depth = 3;
Marmousi marm("marmousi.bin");
func c = marm(x,y);
real xs = 6;
real ys = 0;
func source = exp(-((x-xs)^2+(y-ys)^2)*50*k0);
func sourceGamma = 0;
*/

if (mpirank == 0) cout << "lambda = " << lambda << ", h = " << lambda/nppwl << endl;

func k = 2*pi*freq/c;

int[int] npmlg(4);

npmlg[0] = npml*(lab[3] == PML); npmlg[1] = npml*(lab[1] == PML);
npmlg[2] = npml*(lab[0] == PML); npmlg[3] = npml*(lab[2] == PML);

real[int] lengthpml(4); // length of global PML
for (int i=0; i<4; i++) lengthpml[i] = npmlg[i]*lambda/nppwl;

int npmli = ffddmoverlap == 2 ? 1 : 2; // number of points in subdomain PML
real lpml = npmli*lambda/nppwl; // length of subdomain PML

real nloc = nppwl/ffddmsplit*length/lambda;

int nx = rint(nloc*(length+lengthpml[0]+lengthpml[1])/length);
int ny = rint(nloc*(depth+lengthpml[2]+lengthpml[3])/length);

mesh Th = square(nx,ny,[-lengthpml[0]+x*(length+lengthpml[0]+lengthpml[1]),-depth-lengthpml[2]+y*(depth+lengthpml[2]+lengthpml[3])],label=lab);

real epst = 1e-10;
func sigmax = (npmlg[0]>0)*(x>=length)/max(epst,(length+lengthpml[1]-x)*real(k))  +  (npmlg[1]>0)*(x<=0)/max(epst,(x + lengthpml[0])*real(k));
func sigmay = (npmlg[3]>0)*(y>=0)/max(epst,(lengthpml[3]-y)*real(k))  +  (npmlg[2]>0)*(y<=-depth)/max(epst,(y+depth + lengthpml[2])*real(k));

macro Grad(u) [dx(u),dy(u)] // EOM
macro Gradpml(u) [(1.+1i*sigmay)/(1.+1i*sigmax)*dx(u),
                  (1.+1i*sigmax)/(1.+1i*sigmay)*dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*(1-1i*sigmax)*(1-1i*sigmay)*u*v+Gradpml(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*(1-1i*sigmax)*(1-1i*sigmay)*u*v)
				+ on(Dirichlet,PML,u=0); // EOM

// for the preconditioner
macro VarfOptRobin(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-k^2*(1-1i*sigmax)*(1-1i*sigmay)*u*v+Gradpml(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*(1-1i*sigmax)*(1-1i*sigmay)*u*v)
				+ on(Dirichlet,PML,u=0); // EOM

// for the preconditioner with PMLs
macro VarfOpt(varfName, meshName, PhName)
    /* change definition of sigmax to take subdomain PMLs into account
       d is the distance to the subdomain interface */
    func sigmax = (npmlg[0]>0)*(x>=length)/max(epst,(length+lengthpml[1]-x)*real(k))  +  (npmlg[1]>0)*(x<=0)/max(epst,(x + lengthpml[0])*real(k))
                + (d<=lpml)/max(epst,d*real(k));
    varf varfName(u,v) =
  int2d(meshName)(-k^2*(1-1i*sigmax)*(1-1i*sigmay)*u*v+Gradpml(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*(1-1i*sigmax)*(1-1i*sigmay)*u*v)
				+ on(Dirichlet,PML,10,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                int2d(meshName)(source*v)
                +int1d(meshName,Robin)(sourceGamma*v)
                + on(Dirichlet,PML,u=0); // EOM

vsym = 2; // symmetric, not hermitian
vtgv = -2;
vtgvelim = -2;

/****** ORAS METIS ******/
{
ffddmpartitioner = 1;
ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

HFEVhi<complex> uoras, x0, rhs;
x0[] = 0;

ffddmsetup(ORASMETIS,HFE,Varf,VarfOptRobin)

ffddmbuildrhs(ORASMETIS,Varfrhs,rhs[])

uoras[] = ORASMETISfGMRES(x0[], rhs[], 1.e-6, 2000, "right");

ORASMETISwritesummary

ffddmplot(HFE,real(uoras), "ORASMETIS solution");
}

/****** BAND DECOMPOSITION ******/
macro Hmeshsimple(PhGlobal, part, comm)
int cx = 0, ii = 0;
int zx = mpisize - (nx%mpisize);
int px = nx/mpisize;
int[int] partcube(nx*ny);
for (int i=0; i<nx; i++) {
  for (int j=0; j<ny; j++)
    partcube[j+i*ny] = cx;
  ii++; if (cx < zx) { if (ii == px) {ii = 0; cx++;} } else { if (ii == px+1) {ii=0; cx++;} }
}
part = partcube[int((x+lengthpml[0])/(length+lengthpml[0]+lengthpml[1])*nx)*ny+int(-(y-lengthpml[3])/(depth+lengthpml[2]+lengthpml[3])*ny)];
// EOM

ffddmpartitioner = 0;
ffddmbuildDmeshpartcubes(Hmesh,Th,mpiCommWorld)

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

HFEVhi<complex> uoras, u, x0, rhs;
x0[] = 0;

int[int] labi = [ffddminterfacelabel];
meshL ThGamma = extract(HmeshThi,label=labi); // extract subdomain interface as meshL

real[int] bounds(6);
boundingbox(ThGamma,bounds);

func d = min(abs(x-bounds[0]), abs(x-bounds[1])); // distance to subdomain interface to define subdomain PMLs

NewMacro Generate(pr)
/****** ORAS BAND ******/
IFMACRO(!PMLI)
ffddmsetup(pr#ORAS,HFE,Varf,VarfOptRobin)
ENDIFMACRO
IFMACRO(PMLI)
ffddmsetup(pr#ORAS,HFE,Varf,VarfOpt)
ENDIFMACRO

ffddmbuildrhs(pr#ORAS,Varfrhs,rhs[])

uoras[] = pr#ORASfGMRES(x0[], rhs[], 1.e-6, 2000, "right");

pr#ORASwritesummary

ffddmplot(HFE,real(uoras), Stringification(pr)+"ORAS solution");

/****** BJS ******/
IFMACRO(!PMLI)
varf vGamma(u, v) = on(ffddminterfacelabel, u=1);
complex[int] onGamma = vGamma(0,HFEVhi,tgv=1); // tag interface dofs
ENDIFMACRO

IFMACRO(PMLI)
complex[int] onGamma(HFEVhi.ndof);
{
  onGamma = 0;
  HFEVhi dg = (d <= lpml*(1+1e-10));
  onGamma.re = dg[]; // tag interface PML dofs
}
ENDIFMACRO

complex[int] notonGamma(onGamma.n);
notonGamma = 1;
notonGamma -= onGamma; // tag interior dofs

complex[int] l1(HFEVhi.ndof), trsf(HFEVhi.ndof), rhsi(HFEVhi.ndof);
complex[int] wi(HFEVhi.ndof), vil(HFEVhi.ndof), vir(HFEVhi.ndof), hil(HFEVhi.ndof), hir(HFEVhi.ndof), vhil(HFEVhi.ndof), vhir(HFEVhi.ndof), wi2(HFEVhi.ndof);

macro pr#BJSmyPREC1
func complex[int] pr#BJSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l; /* restrict to interior */

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1; /* local solve */

  for (int i=0; i<Hmeshnpart; i++) {
    /* left to right sweep */
    /* transfer from left neighbor i-1 to i */
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi + vil;
    HFEupdate(trsf,false);

    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      /* apply interface operator */
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      rhsi = onGamma.*rhsi; /* restrict to interface */
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*rhsi;
    }

    /* perform right to left sweep simultaneously */
    int j = Hmeshnpart-i-1;
    /* transfer from right neighbor j+1 to j */
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi + vir;
    HFEupdate(trsf,false);

    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      /* apply interface operator */
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      rhsi = onGamma.*rhsi; /* restrict to interface */
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*rhsi;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#GSSmyPREC1
func complex[int] pr#GSSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  vil = 0;
  vir = 0;

 /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#SGSSmyPREC1
func complex[int] pr#SGSSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  vil = 0;
  vir = 0;

 /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir += onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#JSmyPREC1
func complex[int] pr#JSPREC1(complex[int] &l)
{
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  vil = 0;
  vir = 0;

 /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  wi += vil + vir;

  HFEupdate(wi,true);

  return wi;
}
//

macro pr#BSGSSmyPREC1
func complex[int] pr#BSGSSPREC1(complex[int] &ll)
{
  complex[int] l = ll;

  /* STEP 1 */
  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi + vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart) {
      trsf = wi + vir;
      trsf += vil;
    }
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  /* STEP 2 */
  vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil -= onGamma.*rhsi;
    }
  }

  vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir -= onGamma.*rhsi;
    }
  }

 /* STEP 3 */
  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir += onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  l = wi;
  l+= vil + vir;

  HFEupdate(l,true);
  return l;
}
//

macro pr#BGSSmyPREC1
func complex[int] pr#BGSSPREC1(complex[int] &ll)
{
  complex[int] l = ll;

  l1 = notonGamma.*l;

  wi = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*l1;

  /* G(f) */
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = wi;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
    }
  }

  vil = 0;
  vir = 0;
  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil += onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vil + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir += onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  l = wi;
  l+= vil + vir;

  HFEupdate(l,true);

  return l;

  /* STEP 2 */
  vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vil;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil -= onGamma.*rhsi;
    }
  }

  vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir -= onGamma.*rhsi;
    }
  }

 /* STEP 3 */

  vhir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
  vhil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
  wi2 = vhil + vhir;

  for (int i=0; i<Hmeshnpart; i++) {
    int j = Hmeshnpart-i-1;
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == j+1 && j+1 < Hmeshnpart)
      trsf = vhir + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == j && j < Hmeshnpart-1) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hir = onGamma.*rhsi;
      vir = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hir;
    }
  }

  for (int i=0; i<Hmeshnpart; i++) {
    trsf = 0;
    if (mpiRank(Hmeshcommddm) == i-1 && i-1 >= 0)
      trsf = vhil + vil;
    if (mpiRank(Hmeshcommddm) == i+1 && i+1 < Hmeshnpart)
      trsf = vhir + vir;
    HFEupdate(trsf,false);
    if (mpiRank(Hmeshcommddm) == i && i > 0) {
      rhsi = pr#ORASaR[mpiRank(Hmeshcommddm)]*trsf;
      hil = onGamma.*rhsi;
      vil = pr#ORASaR[mpiRank(Hmeshcommddm)]^-1*hil;
    }
  }

  l = wi;
  l+= vil + vir;

  HFEupdate(l,true);
  return l;
}
//

/* BJS */
macro pr#BJSmyA
func complex[int] pr#BJSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//

ffddmsetupinit(pr#BJS,HFE)

u[] = pr#BJSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#BJSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"BJS solution");

/* BGSS */
macro pr#BGSSmyA
func complex[int] pr#BGSSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//
ffddmsetupinit(pr#BGSS,HFE)

u[] = pr#BGSSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#BGSSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"BGSS solution");

/* BSGSS */
macro pr#BSGSSmyA
func complex[int] pr#BSGSSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//
ffddmsetupinit(pr#BSGSS,HFE)

u[] = pr#BSGSSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#BSGSSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"BSGSS solution");

/* SGSS */
macro pr#SGSSmyA
func complex[int] pr#SGSSA(complex[int] &l) {complex[int] res = pr#ORASA(l); return res;}
//
ffddmsetupinit(pr#SGSS,HFE)

u[] = pr#SGSSfGMRES(x0[], rhs[], 1.e-6, 400, "right");

pr#SGSSwritesummary

ffddmplot(HFE,real(u), Stringification(pr)+"SGSS solution");

EndMacro

/* with PML interface conditions */
{
macro PMLI()1//
Generate(PML)
}

/* with Robin interface conditions */
{
Generate(ROBIN)
}
/* solves the 3D Helmholtz equation with finite-differences using the compact
  wavelength-adaptive 27-point stencil from Aghamiry, H. S., Gholami, A.,
  Combe, L., & Operto, S. (2022). Accurate 3D frequency-domain seismic wave
  modeling with the wavelength-adaptive 27-point finite-difference stencil:
  A tool for full-waveform inversion. Geophysics, 87(3), R305-R324.

  Details about the GO_3D_OBS crustal geomodel can be found at https://www.geoazur.fr/WIND/bin/view/Main/Data/GO3DOBS
  The velocity grid can be downloaded at https://www.geoazur.fr/WIND/pub/nfs/FWI-DATA/GO_3D_OBS/TARGET_PAPERS/v.bin
  File 'Helmholtz_geophysics_rhs_pos.txt' contains the coordinates of the 130 right-hand sides representing a seabed node acquisition

  For a simple test run at low frequency, run:

  ff-mpirun -np 8 Helmholtz_geophysics.edp -ns -nw -frequency 0.3 -nppwl 4 -npml 4 -raspart -ffddm_overlap 3 -npmlprec 2 -tol 1e-4 -murhs 20 -maxrhs 20 -ffddm_verbosity 3

  For a large-scale 3.75 Hz frequency simulation, run:

  ff-mpirun -np 660 Helmholtz_geophysics.edp -ns -nw -frequency 3.75 -nppwl 4 -npml 8 -raspart -noGlob -ffddm_overlap 3 -npmlprec 2 -tol 1e-4 -maxit 150 -ffddm_gmres_restart 150 -murhs 20 -maxrhs 130 -ffddm_verbosity 3
*/

macro FDsimulation()1//
//macro FEsimulation()1// uncomment to perform FE simulation

load "Helmholtz_FD" // plugin implementing the 27-point FD stencil
load "geophysics" // for loading velocity grids of the geomodels

load "parmmg" // for parallel mesh adaption
load "Element_P3" // plugin for P3 finite elements
load "qf11to25" // high order quadrature rules

include "cube.idp"
include "getARGV.idp"

macro dimension 3//EOM
include "ffddm.idp"

real lengthx = 102; //the metric unit is the kilometer
real lengthy = 20;
real depth = 28.3;

int[int] npmlg(6);

real freq = getARGV("-frequency",1.); // frequency
real nppwl = getARGV("-nppwl",4.); // number of points per wavelength
npmlg = getARGV("-npml",8); // number of points in the global PMLs

int npmli = getARGV("-npmlprec",2); // number of points in local PMLs for the preconditioner

int maxit = getARGV("-maxit",400); // maximum number of GMRES iterations for finite differences
real gmrestol = getARGV("-tol",1e-4); // GMRES relative stopping criterion

int maxrhs = getARGV("-maxrhs",130); // total number of RHSs to treat
int murhs = getARGV("-murhs",20); // RHSs are treated by blocks of nrhs

int split = getARGV("-split",2); // splitting ratio for the coarse mesh for finite elements
int maxitFE = getARGV("-maxitFE",30); // maximum number of outer GMRES iterations for finite elements

func PkFE = P2; // P2 or P3 finite elements
macro mqfV()qfVp7//EOM // order 7 quadrature rule for finite elements

// point source coordinates for the single RHS case
real xs = 12.3;
real ys = 10.5;
real zs = -0.9;

// file containing the positions of the 130 RHSs mimicking a sparse seabed node acquisition
ifstream f("Helmholtz_geophysics_rhs_pos.txt");

complex omega = 2.*pi*freq;
real c0 = 1.5; // reference (minimum) velocity
real lambda = (1./freq)*c0;
real h = lambda/nppwl;

if (mpirank == 0) cout << "lambda = " << lambda << ", h = " << h << endl;

// dimensions must be multiples of h
lengthx = h*floor(lengthx/h);
lengthy = h*floor(lengthy/h);
depth = h*floor(depth/h);

real[int]bounds = [0,lengthx,0,lengthy,-depth,0];
Crustal crust("v.bin",bounds); // load the GO_3D_OBS crustal geomodel
func c = crust(x,y,z)/1000;
func mu = c^2;

real[int] lengthpml(6); // length of the global PMLs
for (int i=0; i<6; i++) lengthpml[i] = npmlg[i]*lambda/nppwl;

macro def(u)u//EOM
macro init(u)u//EOM

/***********************************************************************/
/*************************  FINITE DIFFERENCES  ************************/
/***********************************************************************/
IFMACRO(FDsimulation)

real nloc = nppwl/ffddmsplit*lengthx/lambda;

int nplx = rint(nloc*(lengthx+lengthpml[0]+lengthpml[1])/lengthx);
int nply = rint(nloc*(lengthy+lengthpml[2]+lengthpml[3])/lengthx);
int npd = rint(nloc*(depth+lengthpml[4]+lengthpml[5])/lengthx);

int[int] N = [nplx,nply,npd];
real[int,int] Bounds = [[-lengthpml[0],lengthx+lengthpml[1]], [-lengthpml[2],lengthy+lengthpml[3]], [-depth-lengthpml[4],lengthpml[5]]];
int[int,int] Labels = [[11,12],[13,14],[15,16]];

/* partition the domain into overlapping cubic subdomains */
ffddmbuildDmeshpartcubesauto(FDmesh,N,Bounds,Labels,mpiCommWorld)

if (mpirank == 0) cout << "grid size " << nplx+1 << " x " << nply+1 << " x " << npd+1 << endl;

/* define the distributed nodal discretization space */
ffddmbuildDfespace(FDspace,FDmesh,complex,def,init,P1)

//////////// *********** BUILD LOCAL MATRICES *********** ////////////

macro FDmyOperator(matName, meshName, VhName)
/* build local matrices A_i for the matrix-vector product */
int[int] labs = labels(meshName);

int[int] pmls(6);
pmls = -1; /* Dirichlet BC */

for (int i=0; i<labs.n; i++)
if (labs[i] >= 11 && labs[i] <= 16)
  pmls[labs[i]-11] = npmlg[labs[i]-11]; /* global PML boundaries */
matName = HelmholtzFD(meshName,omega,mu,npml=pmls);
//EOM

macro FDmyPrecond(matName, meshName, VhName)
/* build local matrices B_i for the preconditioner */
int[int] labs = labels(meshName);

int[int] pmls(6);
pmls = npmli; /* local PMLs */

for (int i=0; i<labs.n; i++)
if (labs[i] >= 11 && labs[i] <= 16)
  pmls[labs[i]-11] = npmlg[labs[i]-11]; /* global PML boundaries */
matName = HelmholtzFD(meshName,omega,mu,npml=pmls);
//EOM

macro FDwithhpddm()1//EOM

ffddmprecond = "oras";
/* define operator (build A_i) */
ffddmsetupOperator(FD,FDspace,null)
/* define preconditioner (build B_i) */
ffddmsetupPrecond(FD,null)

// set BLR parameters for local solver MUMPS
set(FDhpddmOP,sparams="-hpddm_FD_mumps_icntl_35 2 -hpddm_FD_mumps_cntl_7 1e-3 -hpddm_FD_mumps_icntl_37 0 -hpddm_FD_mumps_icntl_36 1");

// use GMRES with Classical Gram-Schmidt orthogonalization
set(FDhpddmOP,sparams="-hpddm_FD_reuse_preconditioner 1 -hpddm_FD_orthogonalization cgs -hpddm_FD_krylov_method gmres");

//////////// ***********  BUILD RIGHT-HAND SIDES  *********** ////////////
//////////// *********** SOLVE THE LINEAR SYSTEMS *********** ////////////

FDspaceVhi<complex> u, rhs;

int irhs = 0;

if (FDmeshisincomm)
while (irhs < maxrhs) {
  int mu = min(murhs, maxrhs-irhs); // number of treated RHSs for this block

  complex[int] brhs(FDspaceVhi.ndof*mu); // local RHSs

  /* assemble the mu RHSs */
  for (int i = 0; i < mu; i++) {
    if (murhs > 1) { // read RHS position in the file
      f >> zs; zs /= -1000; zs = h*rint(zs/h); // closest FD grid point to source position
      f >> xs; xs /= 1000; xs = h*rint(xs/h);
      f >> ys; ys /= 1000; ys = h*rint(ys/h);
    }
    irhs++;

    /* tag the source node */
    rhs = 0;
    for (int i=0; i<FDmeshThi.nv; i++)
    if ((FDmeshThi(i).x-xs)^2+(FDmeshThi(i).y-ys)^2+(FDmeshThi(i).z-zs)^2 < 1e-3*h)
      rhs[][i] = -1./h^2;

    brhs(i*FDspaceVhi.ndof:(i+1)*FDspaceVhi.ndof-1) = rhs[];
  }

  complex[int] bu(FDspaceVhi.ndof*mu); // local solutions
  bu = 0; // 0 initial guess

  /* solve the linear systems */
  bu = FDfGMRES(bu, brhs, gmrestol, maxit, "right");

  u[] = bu(0:FDspaceVhi.ndof-1); // save the first solution for export
  u = u*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2); // scale with distance to source for visualization
}

FDwritesummary

/* export a solution to parallel vtu format */
if (FDmeshisincomm) {
  load "PETSc-complex"
  func pml = (x>=lengthx)+(x<=0)+(y>=lengthy)+(y<=0)+(z>=0)+(z<=-depth);
  //FDmeshThi = trunc(FDmeshThi,pml==0); // remove PML region
  FDspaceVhi ur = (!pml)*real(u), ui = (!pml)*imag(u);
  int[int] fforder = [1,1];
  savevtk("GO_3D_OBS_FD.vtu", FDmeshThi, ur, ui, dataname = "u ui", order=fforder, communicator=FDmeshcommddm);
  if (mpirank == 0) cout << "Solution saved: " << "GO_3D_OBS_FD_"+mpiSize(FDmeshcommddm)+".pvd" << endl;
}
ENDIFMACRO

/***********************************************************************/
/**************************  FINITE ELEMENTS  **************************/
/***********************************************************************/
IFMACRO(FEsimulation)
{
ffddmoverlap = 1;

real nloc = nppwl/ffddmsplit*lengthx/lambda/split;

int nplx = rint(nloc*(lengthx+lengthpml[0]+lengthpml[1])/lengthx);
int nply = rint(nloc*(lengthy+lengthpml[2]+lengthpml[3])/lengthx);
int npd = rint(nloc*(depth+lengthpml[4]+lengthpml[5])/lengthx);

int[int] N=[nplx,nply,npd];
real [int,int] B=[[-lengthpml[0],lengthx+lengthpml[1]],[-lengthpml[2],lengthy+lengthpml[3]],[-depth-lengthpml[4],lengthpml[5]]];
int [int,int] L=[[11,12],[13,14],[15,16]];

mesh3 Th = Cube(N,B,L);

/* mesh adaptation */
for (int i=0; i<3; i++) {
  fespace Uh(Th,P1);
  Uh met = (1./freq)*real(c)/nppwl*split;
  Th = parmmg3d(Th,metric=met[],hgrad=3,verbose=1,mem=16000);
}

ffddmbuildDmeshNested(FEmesh,Th,split,mpiCommWorld)

/* clear memory */
Th = cube(1,1,1);

func k = omega/c;

real epst = 1e-10;
func sigmax = ((x>=lengthx)/max(epst,(lengthx+lengthpml[1]-x))  +  (x<=0)/max(epst,(x + lengthpml[0])))/real(k);
func sigmay = ((y>=lengthy)/max(epst,(lengthy+lengthpml[3]-y))  +  (y<=0)/max(epst,(y + lengthpml[2])))/real(k);
func sigmaz = ((z>=0)/max(epst,(lengthpml[5]-z))  +  (z<=-depth)/max(epst,(z+depth + lengthpml[4])))/real(k);

macro Grad(u) [dx(u),dy(u),dz(u)] //EOM
macro Gradpml(u) [(1.-1i*sigmay)*(1.-1i*sigmaz)/(1.-1i*sigmax)*dx(u),
                  (1.-1i*sigmax)*(1.-1i*sigmaz)/(1.-1i*sigmay)*dy(u),
                  (1.-1i*sigmax)*(1.-1i*sigmay)/(1.-1i*sigmaz)*dz(u)] //EOM

macro Varf(varfName, meshName, PhName)
  varf varfName(u,v) = int3d(meshName,qfV=mqfV)(-(k^2*(1+1i*sigmax)*(1+1i*sigmay)*(1+1i*sigmaz))*u*v+Gradpml(u)'*Grad(v))
                     + on(11,12,13,14,15,16,u=0);
//EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
  varf varfName(u,v) = int3d(meshName,qfV=mqfV)(-(k^2*(1+1i*sigmax)*(1+1i*sigmay)*(1+1i*sigmaz))*u*v+Gradpml(u)'*Grad(v))
                     - int2d(meshName,10)(1i*k*(1+1i*sigmax)*(1+1i*sigmay)*(1+1i*sigmaz)*u*v)
                     + on(11,12,13,14,15,16,u=0);
//EOM

macro Varfrhs(varfName, meshName, PhName)
  func source = exp(-0.5/(h/8)^2*((x-xs)^2+(y-ys)^2+(z-zs)^2)) / pow(2*pi*(h/8)^2,3./2.);
  varf varfName(u,v) = int3d(meshName,qfV=mqfV)(source*v)
                     + on(11,12,13,14,15,16,u=0);
//EOM

ffddmbuildDfespace(FEs,FEmesh,complex,def,init,PkFE)
ffddmbuildDfespace(FEsCoarse,FEmeshCoarse,complex,def,init,PkFE)

vsym = 2; // matrices are symmetric, not hermitian
vtgv = vtgvelim = -2;

ffddmprecond = "oras";

macro FEwithhpddm()1//
macro FECoarsewithhpddm()1//

ffddmsetupOperator(FECoarse,FEsCoarse,Varf)

ffddmsetupOperator(FE,FEs,Varf)

ffddmset(FE,verbosity,3)
ffddmset(FECoarse,verbosity,1)

ffddmsetupPrecond(FECoarse,VarfOpt)

ffddmsetupPrecond(FE,VarfOpt)

ffddmcoarsemeshsetup(FE,Th,Varf,null)

// set BLR parameters for local solver MUMPS
set(FECoarsehpddmOP,sparams="-hpddm_FECoarse_mumps_icntl_35 2 -hpddm_FECoarse_mumps_cntl_7 1e-3 -hpddm_FECoarse_mumps_icntl_37 0 -hpddm_FECoarse_mumps_icntl_36 1");
set(FEhpddmOP,sparams="-hpddm_FE_mumps_icntl_35 2 -hpddm_FE_mumps_cntl_7 1e-3 -hpddm_FE_mumps_icntl_37 0 -hpddm_FE_mumps_icntl_36 1");

// use GMRES with Classical Gram-Schmidt orthogonalization
set(FECoarsehpddmOP,sparams="-hpddm_FECoarse_reuse_preconditioner 1 -hpddm_FECoarse_orthogonalization cgs -hpddm_FECoarse_krylov_method gmres");
set(FEhpddmOP,sparams="-hpddm_FE_reuse_preconditioner 1 -hpddm_FE_orthogonalization cgs -hpddm_FE_krylov_method gmres");

int irhs = 0;

FEsVhi<complex> u, rhs;

ifstream f("Helmholtz_geophysics_rhs_pos.txt");
while (irhs < maxrhs) {
  int mu = min(murhs, maxrhs-irhs); // number of treated RHSs for this block

  complex[int] brhs(FEsVhi.ndof*mu); // local RHSs

  /* assemble the mu RHSs */
  for (int i = 0; i < mu; i++) {
    if (murhs > 1) { // read RHS position in the file
      f >> zs; zs /= -1000; zs = h*rint(zs/h); // closest FD grid point to source position
      f >> xs; xs /= 1000; xs = h*rint(xs/h);
      f >> ys; ys /= 1000; ys = h*rint(ys/h);
    }
    irhs++;

    ffddmbuildrhs(FE,Varfrhs,rhs[])
    brhs(i*FEsVhi.ndof:(i+1)*FEsVhi.ndof-1) = rhs[];
  }

  complex[int] bu(FEsVhi.ndof*mu); // local solutions
  bu = 0; // 0 initial guess

  /* solve the linear systems */
  bu = FEfGMRES(bu, brhs, gmrestol, maxitFE, "right");

  u[] = bu(0:FEsVhi.ndof-1); // save the first solution for export
  u = u*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2); // scale with distance to source for visualization
}

FECoarsewritesummary
FEwritesummary

/* export a solution to parallel vtu format */
load "PETSc-complex"
func pml = (x>=lengthx)+(x<=0)+(y>=lengthy)+(y<=0)+(z>=0)+(z<=-depth);
//FEmeshThi = trunc(FEmeshThi,pml==0); // remove PML region
FEmeshThi = trunc(FEmeshThi,1,split=2);
FEsVhi ur = (!pml)*real(u), ui = (!pml)*imag(u);
int[int] fforder = [1,1];
savevtk("GO_3D_OBS_FE.vtu", FEmeshThi, ur, ui, dataname = "u ui", order=fforder);
if (mpirank == 0) cout << "Solution saved: " << "GO_3D_OBS_FE_"+mpisize+".pvd" << endl;
}
ENDIFMACRO
//ff-mpirun -np 8 diffusion-2d-thirdlevelgeneo.edp -wg -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 50 -ffddm_partitioner 0 -nsuper 4 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

// for the make check:
// NBPROC 4
// PARAM -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 40 -ffddm_partitioner 0 -nsuper 2 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM     // vector field definition
macro init(i)i// EOM        // vector field initialization
macro grad(u) [dx(u),dy(u)] // EOM
func Pk = P1;             // finite element space

int global = getARGV("-global", 8);

mesh ThGlobal = square(global,global);

macro Varf(varfName, meshName, PhName)

varf varfName(def(u), def(v)) = int2d(meshName)(grad(u)' * grad(v))
+ int2d(meshName)(v)
+ on(1, u = 0.0);
// EOM

vsym = 1;
vtgv = 1e+30;
vtgvelim = vtgv;

int nsuper = getARGV("-nsuper",2);

ffddmbuildSuper(Lap,ThGlobal,nsuper,real,def,init,Pk)

real[int] rhs(1);
real[int] x0(LapVhi.ndof);
x0 = 0;
LapVhi def(u), def(err);
macro Lapdefmplot(u)u//

LapbinexactgeneoCS = 0;

ffddmsetupsuperinit(Lap,Lap)

ffddmsetup(Lap,Lap,Varf,null)

ffddmbuildrhs(Lap,Varf,rhs)

if (mpirank == 0) cout << "RAS :" << endl; 

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary
  
if (mpirank == 0) cout << endl << "RAS + GENEO EXACT :" << endl;   
  
ffddmgeneosetup(Lap,Varf)

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(RAS) :" << endl;

LapbinexactgeneoCS = 1;

ffddmgeneosetup(Lap,Varf)

ffddmset(Lapsuper,verbosity,1)

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(GENEO) :" << endl; 

ffddmnu = getARGV("-ffddm_geneo_super_nu",5);

ffddmgeneosetupsuper(Lap)

u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");

Lapwritesummary

err[] = LapA(u[]);
err[] -= rhs;

ffddmplot(Lap,u, "Global solution");
ffddmplot(Lap,err, "Global residual");

// SAVE TO FILES
/*
{
LapVhi def(isshared);

isshared[] = 0;
for (int i=0;i<LaparrayIntersection.n;i++){
      real[int] tvec(LaprestrictionIntersection[i].n);
      tvec = 1;
      real[int] tres = LaprestrictionIntersection[i]'*tvec;
      isshared[] += tres;
}

{ofstream f("isshared_"+mpirank+".dat");
 f << isshared[];
}

matrix R = interpolate(LapVhi,LapVhglob);

int[int] I(1), J(1);
real[int] K(1);
[I,J,K] = R;

if (K[K.n-1] == 0) {
  I.resize(K.n-1);
  J.resize(K.n-1);
  K.resize(K.n-1);
}

ofstream parU("ParU_"+mpirank+".dat");
parU << LapDk[mpirank];

ofstream ff("renum_"+mpirank+".dat");
ff << J;

ofstream f("neumann_"+mpirank+".mat");
f << LapmatN;

ffddmnpart = 1;
ffddmbuildDmesh(Lap0,ThGlobal,Lapcommself)

if (mpirank == 0) {

  ffddmbuildDfespace(Lap0,Lap0,real,def,init,P1)
  ffddmsetupOperator(Lap0,Lap0,Varf)
  
  real[int] rhs(1);

  ffddmbuildrhs(Lap0,Varf,rhs)

  ofstream rhsj("rhs.dat");
  rhsj << rhs;
  cout << rhs.l2 << endl;

  ofstream fj("AGlobal.mat");
  fj << Lap0aRd[0];
}

}
*/
//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling.edp -ffddm_partitioner 0 -ffddm_gmres_restart 1000 -wg

// for the make check:
// NBPROC 4
// PARAM -ffddm_partitioner 0 -ffddm_gmres_restart 1000

/* example of wave guiding with gradient-index lenses */

include "ffddm.idp"
load "bem"
load "msh3"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int[int] nsl(10); // number of lenses
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

mesh Thwaveguide = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l));

mesh Thlenses = buildmesh(circle(nsl));
// we do not want any region with label 0 for the lenses, as 0 is the waveguide region in Thwaveguide :
Thlenses = change(Thlenses,fregion=region+1);

mesh Th = Thwaveguide + Thlenses; // FEM mesh

meshL ThL = extract(Th);
ThL = trunc(ThL,region==interface);
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL);

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);

func ind = region == -1 ? 1 : 2./(1+((x-nsx[region-1])^2+(y-nsy[region-1])^2)); // gradient index in lenses

// DD mesh partitioning
fespace FPh(Th,P0);
FPh fpart;
if (mpirank == 0) {
  int[int] lpart(FPh.ndof);
  if (mpisize > 1)
    scotch(lpart,Th,mpisize);
  else
    lpart = 0;
  for(int i=0;i<lpart.n;++i)
    fpart[][i]=lpart[i];
}
broadcast(processor(0), fpart[]);

macro Fsimple(PhGlobal, part, comm) part[] = fpart[]; // EOM

macro Bsimple(PhGlobal, part, comm) part = fpart; // EOM

macro Fdim 2//
ffddmbuildDmesh(F, Th, mpiCommWorld)

macro Bdim 3L//
ffddmbuildDmesh(B, ThL, mpiCommWorld)

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
ffddmbuildDfespace(F, F, complex, def, init, P1)

ffddmbuildDfespace(B, B, complex, def, init, P1)

macro VarfSL(varfName, meshName, PhName)
  varf varfName(u,v) = int1dx1d(meshName)(meshName)(BEM(BemKernel("SL",k=k),u,v));
//

macro VarfTDL(varfName, meshName, PhName)
varf varfName(u,v) = int1dx1d(meshName)(meshName)(BEM(BemKernel("TDL",k=k),u,v)) + int1d(meshName)(0.5*u*v);  

// assemble BEM blocks :
ffddmprecond = "ras";
ffddmsetupOperatorBem(B, B, VarfSL)

ffddmsetupPrecond(B, VarfSL)

ffddmsetupOperatorBem(TDL, B, VarfTDL)

if (mpirank == 0)
  cout << BAglobal.infos << endl;
display(BAglobal);

BVhi<complex> ubi, bbi;

bbi[] = 0;

macro Grad(u) [dx(u),dy(u)] // EOM

macro VarfF(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-ind*k^2*u*v+Grad(u)'*Grad(v))
  + on(waveguide,u=0); // EOM

// for the preconditioner
macro VarfFOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-ind*k^2*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,10)(1i*k*u*v)
        + on(waveguide,u=0); // EOM

macro VarfFrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                int2d(meshName)(finc*v)
                + on(waveguide,u=0); // EOM

macro VarfFmass(varfName, meshName, PhName)
    varf varfName(u,v) =
  int1d(meshName,interface)(u*v); // EOM

// assemble FEM blocks :
ffddmprecond = "oras";
ffddmsetup(F, F, VarfF, VarfFOpt)

ffddmsetupOperator(Fmass, F, VarfFmass)

FVhi<complex> ufi, bfi;

ffddmbuildrhs(F, VarfFrhs, bfi[])

int Cn = FVhi.ndof + BVhi.ndof;

// rhs for the coupled problem :
complex[int] bC = [bfi[], bbi[]];

// restriction matrix from local fem space to local bem space :
matrix<complex> RFtoB;
{
  matrix tmp = interpolate(BVhi,FVhi);
  RFtoB = tmp;
}

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (bfi)
(  mass  -SL ) (ubem)   ( 0 ) */

// define custom operators for the coupled problem :
macro Cmyscalprod
func complex Cscalprod(complex[int] va, complex[int] vb)
{
  complex resf = Fscalprod(va(0:FVhi.ndof-1),vb(0:FVhi.ndof-1));
  complex resb = Bscalprod(va(FVhi.ndof:Cn-1),vb(FVhi.ndof:Cn-1));
  return resf+resb;
}
//

ffddminitDfespacef(C, B, complex, def, init, P1, def, init, P1)

macro CmyA
func complex[int] CA(complex[int] &u) 
{
  complex[int] res(u.n);
  res(0:FVhi.ndof-1) = FA(u(0:FVhi.ndof-1));
  res(FVhi.ndof:Cn-1) = (-1)*BA(u(FVhi.ndof:Cn-1));
  
  complex[int] uFm = FmassA(u(0:FVhi.ndof-1));
  complex[int] tmp = RFtoB*uFm;
  Bupdate(tmp,true);
  res(FVhi.ndof:Cn-1) += tmp;
  
  complex[int] utdl = TDLA(u(FVhi.ndof:Cn-1));
  complex[int] tmp2 = RFtoB'*utdl;
  Fupdate(tmp2,true);
  res(0:FVhi.ndof-1) += tmp2;

  return res;
}
//

// block diagonal preconditioner :
macro CmyPREC1
func complex[int] CPREC1(complex[int] &u) 
{
  complex[int] res(u.n);
  res(0:FVhi.ndof-1) = FPREC1(u(0:FVhi.ndof-1));
  res(FVhi.ndof:Cn-1) = (-1)*BPREC1(u(FVhi.ndof:Cn-1));
  return res;
}
//

macro Cwithhpddmkrylov()1//

ffddmsetupinit(C,C);

complex[int] uC(Cn);

uC = CfGMRES(uC, bC, 1.e-4, 2000, "right");

Fwritesummary

Bwritesummary

Cwritesummary

ufi[] = uC(0:FVhi.ndof-1); // FEM local solution

ubi[] = uC(FVhi.ndof:Cn-1); // BEM local solution

FVhglob<complex> ufem;
FfromVhi(ufi[],FVhglob,ufem[]) // FEM global solution

ffddmplot(F,real(ufi),"FEM solution");

BVhglob<complex> ubem;

BfromVhi(ubi[], BVhglob, ubem[]) // BEM global solution

// output mesh for visualization
int np = 200/2;
real R = 20;
real rr = 20;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R/rr)+b2(np)+b3(np*R/rr)+b4(np)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));
broadcast(processor(0),ThOut);

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(BVhglob,UhOut);
if (mpirank == 0) cout << B.infos << endl;
//display(B);

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40);
//ff-mpirun -np 4 Helmholtz-2d-simple.edp -wg -raspart -ffddm_schwarz_method oras -waven 30

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -waven 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P1;

real k = getARGV("-waven",20.);
func f = 100*exp(-((x-.5)^2+(y-.5)^2)*k*10);

real lambda = 2*pi/k;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

//int[int] chlab=[1, Robin, 2, Robin, 3, Robin, 4, Robin];
int[int] chlab=[1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];

int mysplit = 3;

real npplo = 15./mysplit;

mesh Thc = square(npplo*1./lambda,npplo*1./lambda);    // global mesh

Thc=change(Thc,refe=chlab);

mesh Th = trunc(Thc,1,split=mysplit);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)

macro HFEdefmplot(u)real(u)//

ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

//macro Hwithhpddmkrylov()1//

ffddmsetup(H,HFE,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HFEVhi<complex> def(u), def(err);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL (coarse mesh):" << endl;

ffddmcoarsemeshsetup(H,Thc,VarfEprec,VarfEprec)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL (DtN):" << endl;

ffddmdtnsetup(H,Varf,k)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

err[] = HA(u[]);
err[] -= rhs;

ffddmplot(HFE,real(u), "Global solution");
ffddmplot(HFE,abs(err), "Global residual");
// NBPROC 8
// PARAM -raspart -ffddm_schwarz_method oras -frequency 1 -ffddm_overlap 1 -ffddm_inexactCS_tol 0.1

//ff-c++ -auto marmousi2.cpp
//ff-mpirun -np 8 Navier-2d-marmousi2.edp -wg -ns -raspart -ffddm_schwarz_method oras -frequency 1 -ffddm_overlap 1 -ffddm_inexactCS_tol 0.1

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

load "marmousi2"

macro def(i)[i,i#B]// EOM                         // scalar field definition
macro init(i)[i,i]// EOM                        // scalar field initialization
func Pk = [P1,P1];

Marmousi2 marm2vp("/var/tmp/data/marmousi2/model/vp.rsf@");
Marmousi2 marm2vs("/var/tmp/data/marmousi2/model/vs.rsf@");
Marmousi2 marm2density("/var/tmp/data/marmousi2/model/density.rsf@");

real freq = getARGV("-frequency",1.); // Hz
real k = 2.*pi*freq;
real k0 = 2.*pi*freq;
real lambda0 = 0.32319/freq;
real omega = 2*pi*freq;

real Q = 0;

func Cp = marm2vp(x,y);  // km/s
func Cs = marm2vs(x,y);  // km/s
func rho = marm2density(x,y);
func lambda = -2*Cs^2*rho+Cp^2*rho;
func mu = Cs^2*rho;
func Kp = omega/Cp;
func Ks = Kp*Cp/Cs;                                         // wavenumber of P & S-waves

func source = exp(-200*((x-10)^2+(y+0.5)^2));  // source at the top surface

int labextxm = 4;
int labextxM = 2;
int labextym = 1;
int labextyM = 3;
int[int] labsext = [labextxm,labextxM,labextym,labextyM];

int mysplit = 3;

real npplo = 20./mysplit;

int nloc = npplo*17./lambda0;

int nn = ffddmnpart/2;
int mm = ffddmnpart/nn;

int nlocx = nloc/nn*nn;
int nlocy = int(nloc*3./17)/mm*mm;

mesh Thc = square(nlocx,nlocy,[x*17,y*3-3.5]);

mesh Th = trunc(Thc,1,split=mysplit);

real sqrt2 = sqrt(2.);
macro Grad(u) [dx(u),dy(u)]              // EOM
macro epsilon(u,v) [dx(u),dy(v),(dy(u)+dx(v))/sqrt2] // EOM
macro div(u,v) ( dx(u)+dy(v) )                              // EOM
// Sigma macro
macro sxx() rho*omega*(Cp*N.x^2+Cs*N.y^2) //EOM
macro sxy() rho*omega*(Cp-Cs)*N.x*N.y     //EOM
macro syy() rho*omega*(Cp*N.y^2+Cs*N.x^2) //EOM

macro Navier(u,v,uu,vv) rho*(omega^2)*(u*uu+v*vv) -        
            lambda*(div(u,v)*div(uu,vv))-2.*mu*( epsilon(u,v)'*epsilon(uu,vv) ) // EOM

macro NavierEprec(u,v,uu,vv) rho*(omega^2+1.i*omega)*(u*uu+v*vv) -        
            lambda*(div(u,v)*div(uu,vv))-2.*mu*( epsilon(u,v)'*epsilon(uu,vv) ) // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) = int2d(meshName)(Navier(u,v,uu,vv)) 
              + int1d(meshName,labsext)(1i *(sxx*u*uu + sxy*(v*uu+u*vv) +syy*v*vv));
// EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) = int2d(meshName)(NavierEprec(u,v,uu,vv)) 
              + int1d(meshName,labsext)(1i *(sxx*u*uu + sxy*(v*uu+u*vv) +syy*v*vv));
// EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) = int2d(meshName)(NavierEprec(u,v,uu,vv)) 
              + int1d(meshName,labsext,10)(1i *(sxx*u*uu + sxy*(v*uu+u*vv) +syy*v*vv));
// EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([u,v],[uu,vv]) =
                         -intN(meshName)(source*vv);
// EOM

/*
macro Nsimple(PhGlobal, part, comm)
{

 fespace PhGlobal(Thc,P0);
 real allongx = 17;
 real allongy = 3;
 if (mpirank==0 && (nn*mm != ffddmnpart))
   cout << "PB SIMPLE PARTITIONING : nn*mm != npart" << endl;
 assert (nn*mm == ffddmnpart);

 PhGlobal xx=x,yy=y;
 part= int(xx/allongx*nn)*mm + int((-0.5-yy)/allongy*mm);
}
// EOM
*/

ffddmbuildNested(N,Thc,mysplit,complex,def,init,Pk,mpiCommWorld)

//macro NCoarsewithhpddmkrylov()1//
//macro Nwithhpddmkrylov()1//

ffddmsetup(NCoarse,NCoarse,VarfEprec,VarfOpt)

ffddmset(NCoarse,verbosity,1)

ffddmsetup(N,N,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(N,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

NVhi<complex> def(u), def(err);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = NfGMRES(x0, rhs, 1.e-6, 2000, "right");

Nwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(N,Thc,VarfEprec,VarfEprec)

u[] = NfGMRES(x0, rhs, 1.e-6, 300, "right");

Nwritesummary

if (mpirank == 0) cout << "Coarse problem :" << endl;

NCoarsewritesummary

err[] = NA(u[]);
err[] -= rhs;

ffddmplot(N,sqrt(real(u)^2+real(uB)^2), "Global solution");
ffddmplot(N,abs(err), "Global residual");

fespace Vhg(Th,Pk);
Vhg<complex> def(ug);
NfromVhi(u[],Vhg,ug[])

if (mpirank == 0)
medit("ug",Th,sqrt(real(ug)^2+real(ugB)^2));
//ff-mpirun -np 8 elasticity-3d-thirdlevelgeneo.edp -wg -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 10 -ffddm_partitioner 0 -nsuper 4 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -ffddm_schwarz_method ras -ffddm_geneo_nu 20 -global 5 -ffddm_partitioner 0 -nsuper 2 -ffddm_geneo_super_nu 8 -ffddm_inexactCS_tol 1.e-2

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "msh3"

macro def(i)[i, i#B, i#C]// EOM                         // vector field definition
macro init(i)[i, i, i]// EOM                        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1,P1,P1];                               // finite element space

int[int] LL = [2,3, 2,1, 2,2];
mesh3 ThGlobal = cube(6 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [6 * x, y, z], label = LL);

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11;
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
int dirichlet = 1;

macro Varf(varfName, meshName, PhName)
    varf varfName(def(u), def(v)) = int3d(meshName)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(meshName)(f * vC) + on(dirichlet, u = 0.0, uB = 0.0, uC = 0.0); // EOM

vtgv = -2;
vtgvelim = -2;
vsym = 1;

int nsuper = getARGV("-nsuper",2);

ffddmbuildSuper(E,ThGlobal,nsuper,real,def,init,Pk)

real[int] rhs(1);
real[int] x0(EVhi.ndof);
x0 = 0;
EVhi def(u), def(err);

//macro Ewithhpddmkrylov()1//

//macro Esuperwithhpddmkrylov()1//

macro Edefmplot(u)u//

EbinexactgeneoCS = 0;

ffddmsetupsuperinit(E,E)

ffddmsetup(E,E,Varf,null)

ffddmbuildrhs(E,Varf,rhs)

if (mpirank == 0) cout << "RAS :" << endl; 

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO EXACT :" << endl; 

ffddmgeneosetup(E,Varf)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(RAS) :" << endl; 

EbinexactgeneoCS = 1;

ffddmgeneosetup(E,Varf)

ffddmset(Esuper,verbosity,1)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

if (mpirank == 0) cout << endl << "RAS + GENEO INEXACT(GENEO) :" << endl;

ffddmnu = getARGV("-ffddm_geneo_super_nu",5);

ffddmgeneosetupsuper(E)

u[] = EfGMRES(x0, rhs, 1.e-6, 200, "right");

Ewritesummary

err[] = EA(u[]);
err[] -= rhs;

ffddmplot(E,u, "Global solution");
ffddmplot(E,err, "Global residual");

EVhglob def(uglob);

EfromVhi(u[],EVhglob,uglob[])

real alpha = 20000.0;
EThglob = movemesh3(EThglob, transfo = [x + alpha * uglob, y + alpha * uglobB, z + alpha * uglobC]);
u[] = mpirank;

ffddmplot(E,u, "Deformed mesh");
//ff-mpirun -np 8 Maxwell-3d-simple.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -global 10

load "Element_Mixte3d"

macro dimension 3// EOM

include "ffddm.idp"

load "msh3"

macro def(i)[i, i#y, i#z]// EOM             // vector field definition
macro init(i)[i, i, i]// EOM                // vector field initialization
macro defPart(u)u// EOM                     // partition of unity definition
macro initPart(u)u// EOM                    // partition of unity initialization
macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
macro Curlabs(ux, uy, uz)[abs(dy(uz)-dz(uy)), abs(dz(ux)-dx(uz)), abs(dx(uy)-dy(ux))]// EOM
func Pk = Edge03d;
func PkPart = Edge03ds0;

int Dirichlet = 1, Robin = 2;

int ng = getARGV("-global", 30);

int[int] labs = [Robin, Robin, Robin, Robin, Robin, Robin];
//int[int] labs = [Dirichlet, Dirichlet, Dirichlet, Dirichlet, Dirichlet, Dirichlet];

mesh3 Th = cube(ng, ng, ng, [x,y,z], label = labs);
func k = 6 * pi;

func f = exp(-((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)*60);

int mysplit = 3;

mesh3 Thc = cube(ng/mysplit, ng/mysplit, ng/mysplit, [x,y,z], label = labs);

real epsilonprob = 0;//0 k k^2;                  // epsilon of the problem
real be = getARGV("-betaEprec",1.); // beta for epsilonEprec  
real epsilonEprec = 0;//k^be; 

//macro Mdefplot(u)sqrt(real(u)^2+real(u#y)^2+real(u#z)^2)//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuildDmesh(M,Th,mpiCommWorld)
ffddmbuildDfespaceEdge(M,M,complex,def,init,Pk,defPart,initPart,PkPart)

macro Varf(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonprob)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(Dirichlet,Ex=0,Ey=0,Ez=0);    // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(Dirichlet,Ex=0,Ey=0,Ez=0);    // EOM
                
// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)

    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + int2d(meshName,10)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(Dirichlet,Ex=0,Ey=0,Ez=0);    // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
        -int3d(meshName)([vx,vy,vz]'*[0,0,f])
       + on(Dirichlet,Ex=0,Ey=0,Ez=0);  // EOM

ffddmsetup(M,M,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(M,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

MVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(M,Thc,VarfEprec,VarfEprec)

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

ffddmplot(M,sqrt(real(u)^2+real(uy)^2+real(uz)^2), "Global solution");
//ff-mpirun -np 8 Maxwell_Cobracavity.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit -frequency 2e+9

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -frequency 0.8e+9

load "medit"
load "Element_Mixte3d"

macro dimension 3// EOM

include "ffddm.idp"

load "msh3"

include "cobrameshcavity.idp"

/* COBRA cavity paper JCP: EM wave scattering problem from the COBRA cavity
We place a first order absorbing boundary condition a few lambdas away from the cavity boundary. 
The volume of the computational domain is much bigger than the interior cavity region itself.  */

// The long dimension is along x (not the same axes)

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",5.e+9);//17.5e+9;
real k = 2*pi*f/c0;
real lambda = c0/f;

// the computational domain is a box around the cavity. Distance between artificial boundaries and the cavity in each direction:
real distx = 0.2*lambda;
real disty = distx;
real distz = distx;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

int labextxm = 11;
int labextxM = 12;
int labextym = 13;
int labextyM = 14;
int labextzm = 15;
int labextzM = 16;

int[int] labsext = [labextxm,labextxM,labextym,labextyM,labextzm,labextzM];

int regint = 4;
int regext = 5;

real epsilonprob = 0;//0 k k^2;                  // epsilon of the problem
real be = getARGV("-betaEprec",1.); // beta for epsilonEprec  
real epsilonEprec = k^be; 

int mysplit = 2;

int nloc = 20./mysplit*sec3/lambda;

mesh3 Thc;

buildcobramesh(Thc);

macro def(u)[u,u#y,u#z]//
macro init(u)[u,u,u]//
macro defpart(u)u//
macro initpart(u)u//

func Pk = Edge03d;
func PkP0 = Edge03ds0;

//  Macros: Curl and cross product by the normal
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro CrossN(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM

// Incident plane wave

// Convention exp(+i w t)
// exp(-ikx)
// -> propagation along +x

real theta = 2.*pi*180./360.; // 180 or 150

// eta is - the direction of propagation
real[int] eta(3), etaort(3);
eta = [cos(theta),0,sin(theta)];  // oblique
//eta = [-1,0,0];  // normal
//etaort = [0,1,0]; // not used
    
// plane wave
// y polarization
func fx = 0;
func fy = exp(1.i*k*(eta(0)*x+eta(1)*y+eta(2)*z));
func fz = 0;

// calculated for the impedance condition with n=(-1,0,0) (= 2*1i*k f in the normal case)
func Gxm1 = 0;
func Gxm2 = (-1i*k*cos(theta) + 1i*k)*fy;
func Gxm3 = 0;

// calculated for the impedance condition with n=(1,0,0) (= 0 in the normal case)
func GxM1 = 0;
func GxM2 = (1i*k*cos(theta) + 1i*k)*fy;
func GxM3 = 0;

// n=(0,-1,0)
func Gym1 = 1i*k*cos(theta)*fy;
func Gym2 = 0;
func Gym3 = 1i*k*sin(theta)*fy;

// n=(0,1,0)
func GyM1 = -1i*k*cos(theta)*fy;
func GyM2 = 0;
func GyM3 = -1i*k*sin(theta)*fy;

// n=(0,0,-1)
func Gzm1 = 0;
func Gzm2 = (-1i*k*sin(theta) + 1i*k)*fy;
func Gzm3 = 0;

// n=(0,0,1)
func GzM1 = 0;
func GzM2 = (1i*k*sin(theta) + 1i*k)*fy;
func GzM3 = 0;

macro Varf(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonprob)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,labsext)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(labmetal,labo,Ex=0,Ey=0,Ez=0);    // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,labsext)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(labmetal,labo,Ex=0,Ey=0,Ez=0);    // EOM
                
// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)

    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
  int3d(meshName)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
                + int3d(meshName)(-(k^2-1i*epsilonEprec)*[vx,vy,vz]'*[Ex,Ey,Ez])
                + int2d(meshName,labsext)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + int2d(meshName,10)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
                + on(labmetal,labo,Ex=0,Ey=0,Ez=0);    // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName([Ex,Ey,Ez],[vx,vy,vz]) =
        int2d(meshName,labextxm)([vx,vy,vz]'*[Gxm1,Gxm2,Gxm3])
       +int2d(meshName,labextxM)([vx,vy,vz]'*[GxM1,GxM2,GxM3])
       +int2d(meshName,labextym)([vx,vy,vz]'*[Gym1,Gym2,Gym3])
       +int2d(meshName,labextyM)([vx,vy,vz]'*[GyM1,GyM2,GyM3])
       +int2d(meshName,labextzm)([vx,vy,vz]'*[Gzm1,Gzm2,Gzm3])
       +int2d(meshName,labextzM)([vx,vy,vz]'*[GzM1,GzM2,GzM3])
       + on(labmetal,labo,Ex=0,Ey=0,Ez=0);  // EOM

//macro Mdefplot(u)sqrt(real(u)^2+real(u#y)^2+real(u#z)^2)//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = -2;

ffddmbuildDmeshNested(M,Thc,mysplit,mpiCommWorld)
ffddmbuildDfespaceEdge(M,M,complex,def,init,Pk,defpart,initpart,PkP0)
ffddmbuildDfespaceEdge(MCoarse,MCoarse,complex,def,init,Pk,defpart,initpart,PkP0)

//macro Mwithhpddmkrylov()1//
macro MCoarsewithhpddm()1//

ffddmsetupOperator(MCoarse,MCoarse,VarfEprec)
ffddmsetupPrecond(MCoarse,VarfOpt)

ffddmset(MCoarse,verbosity,1)

ffddmsetupOperator(M,M,Varf)
ffddmsetupPrecond(M,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(M,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

MVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

Mwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL + INEXACT COARSE SOLVE :" << endl;

ffddmcoarsemeshsetup(M,Thc,VarfEprec,VarfEprec)

u[] = MfGMRES(x0, rhs, 1.e-6, 200, "right");

if (mpirank == 0) cout << "fine problem :" << endl;
Mwritesummary
if (mpirank == 0)cout << endl << "coarse problem :" << endl;
MCoarsewritesummary

ffddmplot(M,sqrt(real(u)^2+real(uy)^2+real(uz)^2), "Global solution");
//ff-c++ geophysics.cpp
//ff-mpirun -np 8 Helmholtz-3d-overthrust.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras 

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "geophysics"

include "cube.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;  

Overthrust Ovt("/Users/pn/3DOverthrustdata.bin");

func vel = Ovt(x,y,z);  // km/s

real freq = getARGV("-frequency",1.); // Hz
real refvel = 2.1791;
func k = 2.*pi*freq/vel;
real k0 = 2.*pi*freq/refvel;
real lambda = (1./freq)*refvel;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

real nppwl = 5./ffddmsplit;

real length = 20;
real depth = 4.65;

int nloc = nppwl*length/lambda;

int[int] N=[nloc,nloc,nloc*depth/length];
real[int,int] B=[[0,length],[0,length],[-depth,0]];
int[int] L=[Robin,Robin,Robin,Robin,Robin,Dirichlet];
mesh3 Th = cube(nloc,nloc,nloc*depth/length, [x*length, y*length, z*depth-depth], label = L);      // global mesh

real xs = length/8.;
real ys = length/8.;
real zs = -depth/8.;

// 2000
func source = 1000*exp(-200*((x-xs)^2+(y-ys)^2+(z-zs)^2));  // source at the top surface

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                int3d(meshName)(source*v)
                + on(Dirichlet,u=0); // EOM

macro Hdefplot(u)real(u)//

macro Hwithhpddm()1//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuild(H,Th,complex,def,init,Pk,mpiCommWorld)

ffddmsetup(H,H,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

ffddmplot(H,real(u), "Global solution");

//ff-mpirun -np 4 Helmholtz_Cobracavity_BEM.edp -wg

// for the make check:
// NBPROC 4
// PARAM -frequency 1e+9

load "bem"
load "msh3"

include "getARGV.idp"

include "cobrameshcavity.idp"

macro dimension 3S//

include "ffddm.idp"

real sec1 = 0.01;
real angle = 2*pi*35/360;
real radius = 0.186;
real sec2 = 0.08;
real sec3 = 0.1;
real height = 0.084;
real width = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0= 299792458;
real f = getARGV("-frequency",3.e+9);
complex k = 2*pi*f/c0;
real lambda = c0/f;

real distx = 0.2*lambda;
real disty = distx;
real distz = distx;

int labextxm = 11, labextxM = 12, labextym = 13, labextyM = 14, labextzm = 15, labextzM = 16;
int regint = 4, regext = 5;

int labtomerge = 7;

int labmetal = 1;
int labi = 2; // label in : entrance (n=(-1,0,0))
int labo = labmetal; // label out
// Cavity: labo is also a metallic border

// incident wave
real[int] dir=[1,0,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]+z*dir[2]));

int nloc = 10.*sec3/lambda;

mesh3 Th3;
buildcobramesh(Th3);
Th3 = buildBdMesh(Th3);

meshS ThS = Th3.Gamma;
ThS = trunc(ThS, region==labmetal);

plot(ThS);

ffddmbuildDmesh(H, ThS, mpiCommWorld)

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
ffddmbuildDfespace(H, H, complex, def, init, P1)

macro Varf(varfName, meshName, PhName)
  BemKernel ker("SL",k=k);
  varf varfName(u,v) = int2dx2d(meshName)(meshName)(BEM(ker,u,v));
//

macro Varfrhs(varfName, meshName, PhName)
varf varfName(u,v) =
  -int2d(meshName)(finc*v);
//

ffddmsetupOperatorBem(H, H, Varf)

if (mpirank == 0)
  cout << HAglobal.infos << endl;
display(HAglobal);

ffddmsetupPrecond(H, Varf)

HVhi<complex> ui, bi;

ffddmbuildrhs(H, Varfrhs, bi[])

ui[] = HfGMRES(ui[], bi[], 1.e-6, 200, "right");

Hwritesummary

fespace Uh(ThS,P1);
Uh<complex> u;

HfromVhi(ui[], Uh, u[])

// output visu
distx = 2*lambda;
disty = distx;
distz = distx;

int np = 100;
meshS ThOut = square3(np,np,[(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3+2*distx)*x
                               -distx,
                               (height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))*y
                               +(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,
                               width/2]);

fespace UhOut(ThOut,P1);

BemPotential Pot("SL",k=k);
varf vp(u,v)=int2d(ThS)(POT(Pot,u,v));
HMatrix<complex> B = vp(Uh,UhOut);
if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = real(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);
//ff-mpirun -np 8 natural_convection.edp -raspart -ffddm_schwarz_method oras -wg

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -Ra 1e6 -global 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

searchMethod = 1;

macro def(i)[i, i#B, i#C, i#D]// EOM     // vector field definition
macro init(i)[i, i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro Grad(u1,u2)[dx(u1),dy(u1),dx(u2),dy(u2)]//
macro div(u)(dx(u) + dy(u#B))// EOM
macro UgradU(uw,u)[[uw,uw#B]'*grad(u),[uw,uw#B]'*grad(u#B)]//
func Pk = [P2, P2, P1, P1];             // finite element space 

real Ra=getARGV("-Ra", 1.e7);
real Pr=0.71;
real Rey=sqrt(Ra/Pr);
real IRe=1./Rey, IRa=Ra/(Rey*Rey*Pr), IPr=1./(Rey*Pr) ;

real Thot=0.5, Tcold=-0.5;

real eps = 1e-7; // penalization in Navier-Stokes

int newtonMax = 10; 

real coef;

int np = getARGV("-global", 40);

int mysplit = 4;

mesh Thc = square(np/mysplit, np/mysplit, [x, y]);
mesh ThGlobal = trunc(Thc,1,split=mysplit);

//macro NCFEdefplot(u)u#D//

ffddmbuildDmeshAug(NCmesh,ThGlobal,mpiCommWorld)
ffddmbuildDfespaceAug(NCFE,NCmesh,real,def,init,Pk)

//ffddmbuildAug(NC,ThGlobal,real,def,init,Pk,mpiCommWorld)

vtgv = -1;
vtgvelim = -1;
vsym = 0;

macro NCwithhpddmkrylov()1//

ffddmsetupinit(NC,NCFE)

if (NCmeshpCS > 1) {
	int[int] nupart(Thc.nt);
	nupart=0;
	if (mpirank == 0)
		scotch(nupart, Thc, NCmeshpCS);
	if (mpirank < NCmeshpCS) {
		broadcast(processor(0,NCmeshcommCS),nupart);
		Thc=change(Thc,fregion=nupart[nuTriangle]);
	}
}

ffddmcoarsemeshsetupinit(NC,Thc)

NCVhCoarse [uG,uGB,pG,TG];

ffddmset(NC,verbosity,1)

NCFEVhi [ui,uiB,pi,Ti], [upi,upiB,ppi,Tpi];

real[int] rhs;

macro Varf(varfName, meshName, VhName)
	VhName [uG,uGB,pG,TG];
	NCfromVhi(ui[],VhName,uG[])
	
    varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(uG,uw)'*[v,vB]
         + UgradU(uw,uG)'*[v,vB]
         + ( Grad(uw,uwB)'*Grad(v,vB))*IRe
         - coef*IRa*Tw*vB
         -[uG,uGB]'*grad(W)*Tw
         -[uw,uwB]'*grad(W)*TG
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4, uw=0,uwB=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM

macro VarfCS(varfName, meshName, VhName)
    varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName,mpirank)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(uG,uw)'*[v,vB]
         + UgradU(uw,uG)'*[v,vB]
         + ( Grad(uw,uwB)'*Grad(v,vB))*IRe
         - coef*IRa*Tw*vB
         -[uG,uGB]'*grad(W)*Tw
         -[uw,uwB]'*grad(W)*TG
         + grad(Tw)'*grad(W)*IPr)
    + on(1,2,3,4, uw=0,uwB=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM

macro VarfOpt(varfName, meshName, VhName)
    varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName)(- div(uw)*q -div(v)*pw - eps*pw*q
         + UgradU(ui,uw)'*[v,vB]
         + UgradU(uw,ui)'*[v,vB]
         + ( Grad(uw,uwB)'*Grad(v,vB))*IRe
         - coef*IRa*Tw*vB
         -[ui,uiB]'*grad(W)*Tw
         -[uw,uwB]'*grad(W)*Ti
         + grad(Tw)'*grad(W)*IPr)
    + int1d(meshName,10)(20./hTriangle*IRe*[uw,uwB]'*[v,vB]+20*1./hTriangle*[pw, Tw]'*[q, W])
    + on(1,2,3,4, uw=0,uwB=0)
    + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM
   
macro Varfrhs(varfName, meshName, VhName)
	varf varfName([uw, uwB, pw, Tw], [v, vB, q, W]) =
     int2d(meshName)(
         UgradU(ui,ui)'*[v,vB]       
         - [ui,uiB]'*grad(W)*Ti       
     )
     + on(1,2,3,4, uw=0,uwB=0)
     + on(2,Tw=Tcold) + on(4,Tw=Thot);
// EOM

int nstep= max((int(log10(Ra)-4)^2), 3)*max(log10(Ra)-7.,1.);
real tol = 1e-6;

[ui,uiB,pi,Ti]=[0,0,0,Thot+x*(Tcold-Thot)];
nstep *=2;

int iter=0;

for(int step=1; step <= nstep; ++step)
{
   iter++;

    real err=1e100;
    real errp = err;
    coef = (step/real(nstep))^3; // continuation sur le coef en temperature ...
    if (mpirank == 0)
      cout<< "---------------  continuation coef*Ra=" << coef*Ra << endl;
    real tolk= coef<1 ? 1e-2 : tol;

   // Iteration de Newton ---------------------------
   for(int niter=0 ; niter < newtonMax ; niter++){
   	
	 NCfromVhi(ui[],NCVhCoarse,uG[])

	 ffddmsetup(NC,NCFE,Varf,VarfOpt)
	 
	 vtgv = 1.e+30/NCmeshpCS;	 
	 ffddmcoarsemeshsetup(NC,Thc,VarfCS,null) 
	 vtgv = -1;
	 
     ffddmbuildrhs(NC,Varfrhs,rhs)

     ui[] = NCfGMRES(ui[], rhs, 1.e-6, 200, "left");
     
     upi[] -= ui[];
     real reduce = upi[].linfty;
     upi[]  = ui[];
     mpiAllReduce(reduce, err, mpiCommWorld, mpiMAX);

     if(mpirank == 0)
	   cout << "niter = " << niter << " err =  " << err << endl;

     if(err > errp*100) break;
     if(err < tolk) break;
   }
   
   ffddmplot(NCFE,Ti, "Global solution");

}

NCwritesummary
//ff-mpirun  -np  4 diffusion-3d-minimal-ddm.edp -wg -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// Abstract :  "Lap: RAS + GENEO :" << endl; //second level method with a GenEO coarse space

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method ras -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_nu 10 -global 20

macro dimension 3// EOM            // 2D or 3D

load "msh3"

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

int[int] LL = [2,2, 1,2, 2,2];
mesh3 ThGlobal = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10),
    [x, y, z], label = LL);      // global mesh

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) = int3d(meshName)(grad(u)' * grad(v)) + int3d(meshName)(v) + on(1, u = 1.0); // EOM
       
// Domain decomposition
ffddmbuildDmesh( Lap , ThGlobal , mpiCommWorld )
ffddmbuildDfespace( Lap , Lap , real , def , init , P1 )
ffddmsetupOperator(Lap ,Lap , Varf)

// Domain decomposition solve
real[int] rhs(LapVhi.ndof);//rhs(1) works as well 
ffddmbuildrhs(Lap , Varf , rhs )
LapVhi def(u) ;

// Two-level Schwarz solve
ffddmsetupPrecond(Lap,Varf)
ffddmgeneosetup(Lap,Varf)

real[int] x0(LapVhi.ndof);
x0 = 0;
u[] = LapfGMRES(x0, rhs, 1.e-6, 200, "right");
Lapwritesummary//process 0 prints convergence history
ffddmplot(Lap,u, "Lap Global solution with fGMRES");
 //ff-mpirun -np 4 Helmholtz-3d-simple.edp -wg -raspart -ffddm_schwarz_method oras  -ffddm_medit

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -waven 6

macro dimension 3// EOM            // 2D or 3D

include "ffddm.idp"

load "msh3"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;  

real k = getARGV("-waven",10.);
func f = exp(-((x-.5)^2+(y-.5)^2+(z-.5)^2)*k*10);

real lambda = 2*pi/k;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

int mysplit = 3;

real npplo = 10./mysplit;

//int[int] LL = [Dirichlet,Dirichlet, Dirichlet,Dirichlet, Dirichlet,Dirichlet];
int[int] LL = [Robin,Robin, Robin,Robin, Robin,Robin];

mesh3 Thc = cube(npplo*1./lambda,npplo*1./lambda,npplo*1./lambda, [x, y, z], label = LL);

mesh3 Th = trunc(Thc,1,split=mysplit);

macro Grad(u) [dx(u),dy(u),dz(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int3d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int2d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int3d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

macro Hdefmplot(u)real(u)//

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuild(H,Th,complex,def,init,Pk,mpiCommWorld)

ffddmsetup(H,H,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HVhi<complex> def(u);

if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout <<  endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(H,Thc,VarfEprec,VarfEprec)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

ffddmplot(H,real(u), "Global solution");
//ff-mpirun -np 4 Helmholtz_circle_BEM.edp -wg

// for the make check:
// NBPROC 4
// PARAM

load "bem"
load "msh3"

include "getARGV.idp"

include "cobrameshcavity.idp"

macro dimension 3L//

include "ffddm.idp"
load "bem"
load "msh3"

complex k = 10;

// incident wave
real[int] dir=[1,0];
func finc = exp(1i*k*(x*dir[0]+y*dir[1]));
func dxfinc = 1i*k*dir[0]*finc;
func dyfinc = 1i*k*dir[1]*finc;

//  Mesh
int n = 1000;
border circle(t=0, 2*pi){x=cos(t); y=sin(t); z=0;}
meshL Th = buildmeshL(circle(n));

Th = OrientNormal(Th,unbounded=1);

ffddmbuildDmesh(H, Th, mpiCommWorld)

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
ffddmbuildDfespace(H, H, complex, def, init, P1)

macro Varf(varfName, meshName, PhName)
  varf varfName(u,v) = int1dx1d(meshName)(meshName)(BEM(BemKernel("SL",k=k),u,v));
//

macro Varfrhs(varfName, meshName, PhName)
varf varfName(u,v) =
  -int1d(meshName)(finc*v);
//

ffddmsetupOperatorBem(H, H, Varf)

if (mpirank == 0)
  cout << HAglobal.infos << endl;
display(HAglobal);

ffddmsetupPrecond(H, Varf)

HVhi<complex> ui, bi;

ffddmbuildrhs(H, Varfrhs, bi[])

ui[] = HfGMRES(ui[], bi[], 1.e-6, 200, "right");

Hwritesummary

fespace Uh(Th,P1);
Uh<complex> u;

HfromVhi(ui[], Uh, u[])

// Mesh output
int np = 200;
int R = 4;

border b1(t=-R, R){x=t; y=-R;}
border b2(t=-R, R){x=R; y=t;}
border b3(t=-R, R){x=-t; y=R;}
border b4(t=-R, R){x=-R; y=-t;}
border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

mesh ThOut = buildmesh(b1(np)+b2(np)+b3(np)+b4(np)+circleout(-np*pi/R));

fespace UhOut(ThOut,P1);

//BemPotential Pot("SL",k=k);
varf vp(u,v)=int1d(Th)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(Uh,UhOut);
if (mpirank == 0) cout << B.infos << endl;
display(B);

UhOut<complex> v, vinc;

vinc = finc;

v[] = B*u[];

v[] += vinc[];

UhOut vr = abs(v);

plot(vr, dim=2, fill=1, value=1, nbiso=20);

//ff-mpirun -np 4 Helmholtz-2d-HPDDM-BGMRES.edp -wg -raspart -ffddm_schwarz_method oras -waven 30

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras -waven 20

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;

real xf = 0.5;
real yf = 0.5;

real k = getARGV("-waven",40.);
func f = 100*exp(-((x-xf)^2+(y-yf)^2)*k*10);

real lambda = 2*pi/k;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

//int[int] chlab=[1, Robin, 2, Robin, 3, Robin, 4, Robin];
int[int] chlab=[1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];

real npplo = 15;

mesh Th = square(npplo*1./lambda,npplo*1./lambda);    // global mesh

Th=change(Th,refe=chlab);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

ffddmbuildDmesh(Hmesh,Th,mpiCommWorld)
ffddmbuildDfespace(HFE,Hmesh,complex,def,init,Pk)

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

macro Hwithhpddm()1//

ffddmsetup(H,HFE,Varf,VarfOpt)

int nbrhs = 10;

complex[int] brhs(nbrhs*HFEVhi.ndof);
complex[int] bu(nbrhs*HFEVhi.ndof);

complex[int] rhs(0);
for (int i=0; i<nbrhs; i++) {
      xf = 0.4+i*0.4/nbrhs;
      ffddmbuildrhs(H,Varfrhs,rhs)
      brhs(i*HFEVhi.ndof:(i+1)*HFEVhi.ndof-1) = rhs;
}

complex[int] x0(brhs.n);
x0 = 0;

if (mpirank == 0) cout << "Pseudo-Block GMRES :" << endl;

bu = HfGMRES(x0, brhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "Block GMRES :" << endl;

set(HhpddmOP,sparams="-hpddm_H_krylov_method bgmres");

bu = HfGMRES(x0, brhs, 1.e-6, 200, "right");

Hwritesummary

HFEVhi<complex> def(u);
u[] = bu(0:HFEVhi.ndof-1); 

ffddmplot(HFE,real(u), "u[0]");
//ff-c++ -auto geophysics.cpp
//ff-mpirun -np 4 Helmholtz-2d-marmousi.edp -wg -raspart -ffddm_schwarz_method oras -ffddm_medit

// If you have openmpi you may need to add the option --oversubscribe to allow more processes than the number of cores available on your computer

// for the make check:
// NBPROC 4
// PARAM -raspart -ffddm_schwarz_method oras 

macro dimension 2// EOM            // 2D or 3D

include "ffddm.idp"

load "geophysics"

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
func Pk = P2;  

Marmousi marm("marmousi.bin");

func vel = marm(x,y);  // km/s

real freq = 5; // Hz
func k = 2.*pi*freq/vel;

func f = exp(-2000*((x-6)^2+y^2));  // source at the top surface

real lambda = 1.5/freq;

real epsilonprob = 0;
real be = getARGV("-betaEprec",1.);
real epsilonEprec = 0;//k^be;

int Dirichlet = 1;
int Robin = 2;

int[int] chlab=[1, Robin, 2, Robin, 3, Dirichlet, 4, Robin];

int mysplit = 3;

real npplo = 10./mysplit;

int nloc = npplo*9.2/lambda;

mesh Thc = square(nloc,nloc*3./9.2,[x*9.2,y*3-3]);

Thc=change(Thc,refe=chlab);

mesh Th = trunc(Thc,1,split=mysplit);

macro Grad(u) [dx(u),dy(u)] // EOM

macro Varf(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonprob)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner (if (!bAbsorp) epsilonEprec = epsilonprob;)
macro VarfEprec(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

// for the preconditioner
macro VarfOpt(varfName, meshName, PhName)
    varf varfName(u,v) =
  int2d(meshName)(-(k^2-1i*epsilonEprec)*u*v+Grad(u)'*Grad(v))
				+ int1d(meshName,Robin,10)(1i*k*u*v)
				+ on(Dirichlet,u=0); // EOM

macro Varfrhs(varfName, meshName, PhName)
    varf varfName(u,v) =
                -int2d(meshName)(f*v)
                + on(Dirichlet,u=0); // EOM

vsym = 2; // symmetric, not hermitian
vtgv = 1.e+30;
vtgvelim = 1.e+30;

ffddmbuild(H,Th,complex,def,init,Pk,mpiCommWorld)

//macro Hwithhpddmkrylov()1//

ffddmsetup(H,H,Varf,VarfOpt)

complex[int] rhs(1);

ffddmbuildrhs(H,Varfrhs,rhs)

complex[int] x0(rhs.n);
x0 = 0;

HVhi<complex> def(u);



if (mpirank == 0) cout << "ORAS :" << endl;

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

if (mpirank == 0) cout << endl << "ORAS TWO-LEVEL :" << endl;

ffddmcoarsemeshsetup(H,Thc,VarfEprec,VarfEprec)

u[] = HfGMRES(x0, rhs, 1.e-6, 200, "right");

Hwritesummary

ffddmplot(H,real(u), "Global solution");

/*
complex[int] err(u[].n);
err = HA(u[]);
err -= rhs;

ffddmplot(H,u[], "Global solution");
ffddmplot(H,err, "Global residual");
*/

savemesh(HThi,"visu/marm_" + mpirank + "_" + mpisize + ".mesh");
{
	ofstream f("visu/marm_" + mpirank + "_" + mpisize + ".dat");
	f << u[];
}

int[int] fforder=[1];
load "iovtk"
savevtk("visu/test_" + mpirank + "_" + mpisize + ".vtk", HThi, real(u), dataname = "sol", order = fforder);
exec("/Applications/paraview.app/Contents/bin/pvpython vtk2vtu.py visu/test_" + mpirank + "_" + mpisize);

if(mpirank == 0) {
    ofstream pvd("visu/test.pvd");
    pvd << "<?xml version=\"1.0\"?>\n";
    pvd << "<VTKFile type=\"Collection\" version=\"0.1\"\n";
    pvd << "         byte_order=\"LittleEndian\"\n";
    pvd << "         compressor=\"vtkZLibDataCompressor\">\n";
    pvd << "  <Collection>\n";
    for(int i = 0; i < mpisize; ++i) {
        pvd << "    <DataSet timestep=\"0\" group=\"\" part=\"" << i << "\"\n";
        pvd << "             file=\""; pvd << "test_" << i << "_" << mpisize << ".vtu\"/>\n";
    }   
    pvd << "  </Collection>\n";
    pvd << "</VTKFile>\n";
}
// EOM


//ff-mpirun -np 4 elasticity_saddlepoint.edp -wg -ns -ffddm_schwarz_coarse_correction BNN -ffddm_geneo_threshold_A 0.1 -ffddm_geneo_threshold_S 0.3 -ffddm_geneo_nu 40 -Dmdim=2 -global 10 -nlayers 10

/* 3D heterogenous elasticity problem with nearly incompressible
   material solved with the GenEO saddle point solver from
   Nataf, F., & Tournier, P. H. (2021). A GenEO Domain Decomposition
   method for Saddle Point problems.
   arXiv preprint available at https://arxiv.org/abs/1911.01858 */

// the command line parameter '-Dmdim' sets the value of the macro 'mdim' in the script;
// '-Dmdim=2' or '-Dmdim=3' switches between the 2D and 3D test case

include "getARGV.idp"
int global = getARGV("-global", 10); // discretization parameter
int nlayers = getARGV("-nlayers", global); // number of alternating material layers in the y direction

// material coefficients:
real nu1 = 0.4999;
real nu2 = 0.35;
real E1 = 1e+7;
real E2 = 200e+9;

// heterogeneous material distribution:
func fE = int(y*nlayers)%2 == 0 ?  E1 :  E2;
func fnu = int(y*nlayers)%2 == 0 ? nu1 : nu2;

real gtol = 1e-5;

/********* 2D *********/
IFMACRO(mdim,2)
macro dimension 2// EOM
include "ffddm.idp"

macro grad(u) [dx(u),dy(u)] // EOM
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM

mesh ThGlobal = square(5*global, global, [5*x,y]);

func Pku = [P2,P2];
func Pkp = [P0];

macro VarfA(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));
varf varfName([u, uB], [v, vB]) = int2d(meshName)(2.0 * mu * (epsilon(u)' * epsilon(v)))
                                 +on(4, u = 0, uB = 0)
                                 -int2d(meshName)(100*vB);
 // EOM

macro VarfB(varfName, meshName, PhName)
varf varfName([u, uB], [q]) = int2d(meshName)(div(u) * q);
// EOM

macro VarfC(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));

varf varfName([p], [q]) = int2d(meshName)(1./lambda * p * q);
// EOM

macro defA(i)[i, i#B] // EOM
macro initA(i)[i, i] // EOM

macro defB(i)[i] // EOM
macro initB(i)[i] // EOM
ENDIFMACRO

/********* 3D *********/
IFMACRO(mdim,3)
macro dimension 3// EOM
include "ffddm.idp"
load "msh3"

real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM

int[int] LL = [2,3, 2,1, 2,2];
mesh3 ThGlobal = cube(5*global, global, global, [5*x,y,z], label = LL);

func Pku = [P2,P2,P2];
func Pkp = [P1];

macro VarfA(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));
varf varfName([u, uB, uC], [v, vB, vC]) = int3d(meshName)(2.0 * mu * (epsilon(u)' * epsilon(v)))
                                 +on(1, u = 0, uB = 0, uC = 0)
                                 -int3d(meshName)(100*vB);
// EOM

macro VarfB(varfName, meshName, PhName)
varf varfName([u, uB, uC], [q]) = int3d(meshName)(div(u) * q);
// EOM

macro VarfC(varfName, meshName, PhName)
fespace Ph0(meshName,P0);
Ph0  E = fE, nu = fnu;
func mu = E/(2*(1+nu));
func lambda = E*nu/((1+nu)*(1-2*nu));

varf varfName([p], [q]) = int3d(meshName)(1./lambda * p * q);
// EOM

macro defA(i)[i, i#B, i#C] // EOM
macro initA(i)[i, i, i] // EOM

macro defB(i)[i] // EOM
macro initB(i)[i] // EOM
ENDIFMACRO

/* build mesh decomposition with minimal overlap size 1*2 (prefix M) and also the Augmented decomposition
   with overlap size 2*2 (prefix MAug) */
ffddmbuildDmeshAug(M,ThGlobal,mpiCommWorld)

func Pk = [Pku,Pkp];

/* build Dfespace for A on distributed mesh M (prefix AFE) ; this also builds Dfespace tilde with larger overlap
   on distributed mesh MAug (prefix AFEAug) needed for the rectangular operator B on tilde decomposition.
   This also builds 'AFEAuginterp' matrices (restriction matrices from AFEAugVhi to AFEVhi local FE spaces). */
ffddmbuildDfespace(AFE,M,real,defA,initA,Pku)

ffddmbuildDfespace(CFEAug,MAug,real,defB,initB,Pkp) // Dfespace for C

vsym=1;
vtgvelim=1e+30;
vtgv=1e+30;

ffddmsetupOperator(A,AFE,VarfA); /* Operator A */
ffddmsetupPrecond(A,null); /* one level preconditioner for A */

ffddmtau = getARGV("-ffddm_geneo_threshold_A", 0.3);
ffddmgeneosetup(A,VarfA); /* second level for A */

Acorr == "ADEF1";

ffddmsetupOperatorRect(Btilde,AFEAug,CFEAug,VarfB) /* Operator B on tilde decomposition */

ffddmsetupOperator(Ctilde,CFEAug,VarfC) /* Operator C on tilde decomposition */

matrix Ctildei;
{
  VarfC(vC, MAugThi, null)
  Ctildei = vC(CFEAugVhi,CFEAugVhi,sym=1); /* Ctilde_i from Remark 3.2 */
}

/* define and build all necessary operators for the application of N_S^-1 */
ffddmtau = getARGV("-ffddm_geneo_threshold_S", 0.1);
ffddmSPsetup(SP,A,Btilde,Ctilde,Ctildei)

AFEVhi defA(Fx);
ffddmbuildrhs(A,VarfA,Fx[]) /* Build F_u */

CFEAugVhi [Fp] = [0]; /* Build F_p */

AFEVhi defA(Gx);

Averbosity = 1;
/* Solve A G_u = F_u with M_A^-1 as a preconditioner, step 1 of Algorithm 2 */
Gx[] = AfGMRES(Gx[], Fx[], gtol, 100, "right");

/* Compute G_p = F_p - B G_u, step 2 of Algorithm 2 */
CFEAugVhi [Gp];
Gp[] = Fp[] - SPBmatvec(Gx[]);

/* Step 3 of Algorithm 2: solve (C + B A^-1 B^T) P = -G_p with N_S^-1 as a preconditioner */
Gp[] *= -1;

CFEAugVhi [P];
P[] = 0;
P[] = SPfGMRES(P[], Gp[], gtol, 100, "right");

Awritesummary
SPwritesummary

ffddmplot(CFEAug,P,"P");

// Step 4 of Algorithm 2: compute G_u = F_u - B^T P
Gx[] = Fx[] - SPBTmatvec(P[]);

// Step 5 of Algorithm 2: solve A U = G_u with M_A^-1 as a preconditioner
AFEVhi defA(Ux);
Ux[] = 0;
Ux[] = AfGMRES(Ux[], Gx[], gtol, 100, "right");

ffddmplot(CFEAug,UxB,"Uy");

IFMACRO(BLOCK)
/* Block solve with preconditioner P of eq. (28) */
real[int] rhs(AFEVhi.ndof+CFEAugVhi.ndof);
rhs(0:AFEVhi.ndof-1) = Fx[];
rhs(AFEVhi.ndof:rhs.n-1) = Fp[];

real[int] x0(rhs.n), u(rhs.n);

u = SPBlockfGMRES(x0, rhs, gtol, 100, "right");

SPBlockwritesummary

real[int] Us = Ux[];

Ux[] = u(0:AFEVhi.ndof-1);

ffddmplot(CFEAug,UxB,"UxB block");

Ux[] -= Us;

ffddmplot(CFEAug,UxB,"difference");
ENDIFMACRO
load "SuperLu"
load "MUMPS_seq"
verbosity=3;
//  a example to test the level of optimisation
// --------------------------------------------
int nn=30;
 mesh Th=square(nn,nn);
verbosity=3;
 fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 int err=0;
 func bool verif()
 {
	real umax  =0.361995;
	if( abs( umax - uh[].max) >0.001) err++;
 }
 int init=0;
 problem laplace0(uh,vh,init=init) =                  //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  + int1d(Th,1)( uh*vh) 
  + int1d(Th,1)( - vh)
  + int2d(Th)( -f*vh )                          //  linear form
  + on(2,3,4,uh=g) ;                      //  boundary condition form
//init=1; 
DefaultSolver="UMFPACK";
DefaultSolverSym="CHOLMOD";
real cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap UMFPACK " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
verif();

uh=0;
DefaultSolver="SUPERLU";
DefaultSolverSym="SUPERLU";
cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap SuperLU " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
verif();
DefaultSolver="MUMPS";
DefaultSolverSym="MUMPS";
cpu=clock() ;
laplace0; // solve the problem plot(uh); // to see the result
cout << "-- lap MUMPS " << nn << "x" << nn << "  : " <<  -cpu+clock() << " s,  max =" << uh[].max << endl;
verif();
assert(err==0); 
include "cube.idp"
load "medit"
int[int, int] LL = [[2,2], [1,1], [1,1]];
real[int, int] BB = [[0,1], [0,1], [0,1]];
int[int] CC = [4, 4, 4];
load "splitmesh4"
mesh3 Th3=Cube(CC, BB, LL);
mesh3 Th4=splitmesh4(Th3);
assert(Th4.nt == Th3.nt * 4);
cout << Th4.nt << " == 4 x " << Th3.nt << endl;
assert(Th4.nbe == Th3.nbe);
cout << Th4.nbe << " == " << Th3.nbe << endl;
plot(Th3, cmm="Th3", wait=1);
plot(Th4, cmm="Th4", wait=1);
fespace Vh(Th4, P1);
Vh xyz = x + y + z;
medit("splitmesh4",Th4,xyz);
load "MetricPk"
load "Element_P3";
load "Element_P4";

int nIter=4;
mesh Th=square(20,20,[x,y]);
//fespace Vh(Th,P1); int kDeg=1;  //degr des FE utiliss
//fespace Vh(Th,P2); int kDeg=2;  //degr des FE utiliss
fespace Vh(Th,P3); int kDeg=3;  //degr des FE utiliss
int rdeg=1;	 //on approche le gradient ou des drives d'ordre suprieur

real ratio = 2.;//number of triangles is multiplied by ratio at each step
real rmax = 1; 	//max triangle size desired.

Vh u,v;
fespace Metric(Th,[P1,P1,P1]);
Metric [m11,m12,m22];
////pour de l'adaptation isotrope
//problem EpsDelta(u,v) =
//		int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))+
//		on(1,u=1)+on(2,3,4, u=0);
//avec une forte anisotropie, et des singularits aux coins.
real eps=0.01;
problem EpsDelta(u,v) =
		int2d(Th)(eps*dx(u)*dx(v)+eps*dy(u)*dy(v)+(dx(u)+dy(u))*v)+
		on(1,u=atan(10*x*(1-x)))+on(2,3,4, u=0);

//real massRef = 1000*Th.nt;
real massRef = Th.nt/2;
EpsDelta;
plot(u, wait=1);
for(int i=0; i<nIter; i++){
	plot(Th, wait=1); //on affiche avant de tout changer
	plot(u, wait=1);
	[m11,m12,m22]=[0,0,0];	//absolument crucial...
	m11[]=MetricPk(Th,u,kDeg=kDeg,rDeg=rdeg, mass=massRef);
	Th = adaptmesh(Th,m11,m12,m22,IsMetric=true);
	cout << "expected number of triangles : " << massRef/20 << "; obtained " << Th.nt << "\n";
	EpsDelta;
	massRef=ratio*massRef;
}

plot(Th, wait=1, ps="o/triangulationEpsDelta.ps");
      load "splitedges"
      mesh Th=square(50,50);
      real xx=1.1,yy=1.1;	
      for(int i=0;i<4;++i)
	{     
	  xx *= 0.5;
	  yy *= 0.5;
	  Th=SplitEdgeMesh(Th,x<yy && y < yy );
	  plot(Th,wait=1);
	}
// file tetgencube.edp
// this is  a BUGGUS  file work in progress F. Hecht .... Oct 2011
load "msh3"
load "tetgen"
load "medit"

real x0,x1,y0,y1;
x0=1.; x1=2.; y0=0.; y1=2*pi;
mesh Thsq1 = square(5,35,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

int[int] ref31h = [0,12];
int[int] ref31b = [0,11];

meshS Th31h = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1max],region=ref31h,orientation=1);
meshS Th31b = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1min],region=ref31b,orientation=-1);   

//medit("haut",Th31h);
//medit("bas",Th31b);

/////////////////////////////////
x0=1.; x1=2.; y0=0.; y1=1.5;
mesh Thsq2 = square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

int[int] ref32h = [0,13];
int[int] ref32b = [0,14];

meshS Th32h = movemesh23(Thsq2,transfo=[XX2,YY2max,ZZ2],region=ref32h,orientation=-1);  
meshS Th32b = movemesh23(Thsq2,transfo=[XX2,YY2min,ZZ2],region=ref32b,orientation=1);

/////////////////////////////////
x0=0.; x1=2*pi; y0=0.; y1=1.5;
mesh Thsq3 = square(35,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
func XX3min = 1.;
func XX3max = 2.;

func YY3 = x;
func ZZ3 = y;

int[int] ref33h = [0,15];
int[int] ref33b = [0,16];
cout << "tyty\n";
verbosity = 4; 
meshS Th33h = movemesh23(Thsq3,transfo=[XX3max,YY3,ZZ3],region=ref33h,orientation=1);  
cout << "tyty\n";
meshS Th33b = movemesh23(Thsq3,transfo=[XX3min,YY3,ZZ3],region=ref33b,orientation=-1); 

////////////////////////////////
meshS Th33 = Th31h+Th31b+Th32h+Th32b+Th33h+Th33b; // "gluing" surface meshs to obtain the surface of cube
cout << "premier check" << endl;
checkbemesh(Th33,manifolds=[ [[11,1],[12,1],[13,1],[14,1],[15,1],[16,1]] ]);


func mv2x = x;
func mv2y = y;
func mv2z = -1.5+z;
cout << "movemesh ::new mesh" <<endl;
meshS Th33mv = movemesh(Th33, [mv2x,mv2y,mv2z]);
int[int] r1=[12,11,11,21,13,23,14,24,15,25,16,26];
cout << "change ::new mesh" <<endl;
//medit("Th33mv",Th33mv);
if(0) {
Th33mv=change(Th33mv,label=r1);  // bug change if non tet in mesh .... HERE ...
cout << "add ::new mesh" <<endl;
meshS Thall = Th33+Th33mv;  // The vertex of faces of labels 11 of Th33 and Th33mv must be same. The faces of label 11 of Thall correspond to the faces of the first in the sum : Th33.

medit("Thall",Thall);
// check manifold of the two gluing mesh
cout << "check gluing 1" << endl; 
checkbemesh(Thall,manifolds=[ [[11,1],[12,1],[13,1],[14,1],[15,1],[16,1]] ]);
cout << "check gluing 2" << endl; 
checkbemesh(Thall,manifolds=[ [[11,-1],[21,1],[23,1],[24,1],[25,1],[26,1]] ]);   
cout << "check exterior" << endl;
checkbemesh(Thall,manifolds=[ [[12,1],[13,1],[14,1],[15,1],[16,1],[21,1],[23,1],[24,1],[25,1],[26,1]] ]); // check the exterior manifold 
}
load "Morley"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-6;
int it1=Th(x1,y1).nuTriangle; 

func ff =  2*x*x + 3*y*y + 4.5*y*x + 5*x + 6*y + 7;
func ffx = 4*x + 4.5*y + 5;
func ffy = 6*y + 4.5*x + 6;
func ffxx = 4.;
func ffyy = 6.;
func ffxy =4.5;

fespace Vh(Th,P2Morley);
fespace Eh(Th,P0edge);

Eh  edges;

Vh [a1,a2,a3],[b1,b2,b3],[c1,c2,c3];
 
[a1,a2,a3] = [ ff,ffx,ffy];

 cout << a1(0.6,0.2) << " == " << ff(0.6,0.2) << endl;
 cout << a2(0.6,0.2) << " == " << ffx(0.6,0.2) << endl;
  cout << a3(0.6,0.2) << " == " << ffy(0.6,0.2) << endl;
  cout << dxx(a1)(0.6,0.2) << " xx== " << ffxx(0.6,0.2) << endl;
  cout << dyy(a1)(0.6,0.2) << " yy== " << ffyy(0.6,0.2) << endl;
  cout << dxy(a1)(0.6,0.2) << " xy== " << ffxy(0.6,0.2) << endl;
  cout << dyx(a1)(0.6,0.2) << " yx== " << ffxy(0.6,0.2) << endl;
 cout << a1(0.2,0.6) << " == " << ff(0.2,0.6) << endl;
 cout << a2(0.2,0.6) << " == " << ffx(0.2,0.6) << endl;
  cout << a3(0.2,0.6) << " == " << ffy(0.2,0.6) << endl;
 cout << " 00 = " << int2d(Th)(square(a1-ff)) << endl;
 cout << " 00 = " << int2d(Th)(square(a2-ffx)) << endl;
 cout << " 00 = " << int2d(Th)(square(a3-ffy)) << endl;
plot(a1,wait=1);

Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  [b1,b2,b3]=[a1,a2,a3];

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];
  cout << " int_1 " <<  int1d(Th,1) (dn(a1)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dn(a1)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dn(a1)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dn(a1)) << endl;

  cout << " int_1 " <<  int1d(Th,1) (dnn(a)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dnn(a)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dnn(a)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dnn(a)) << endl;

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << " == " << a2(x1,y1) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h) << " == " << a3(x1,y1) << endl; 

  cout << " dx(a2)(x1,y1) = " << dx(a2)(x1,y1) << " == " << DD(a2,h,0)  << " == " << dxx(a1) << endl; 
  cout << " dy(a2)(x1,y1) = " << dy(a2)(x1,y1) << " == " << DD(a2,0,h)  << " == " << dxy(a1) << endl; 
  cout << " dx(a3)(x1,y1) = " << dx(a3)(x1,y1) << " == " << DD(a3,h,0)  << " == " << dxy(a1) << endl; 
  cout << " dy(a3)(x1,y1) = " << dy(a3)(x1,y1) << " == " << DD(a3,0,h)  << " == " << dyy(a1) << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a2)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a3)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dx(a2)(x1,y1)-DD(a2,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-4);


} 

load "Element_P4"
load "msh3"
{
macro DD(f,hx,hy,hz) ( (f(x1+hx,y1+hy,z1+hz)-f(x1-hx,y1-hy,z1-hz))/(2*(hx+hy+hz))) //
macro DD2(f,hx,hy,hz) ( (-2*f(x1,y1,z1)+f(x1+hx,y1+hy,z1+hz)+f(x1-hx,y1-hy,z1-hz))/(square(hx+hy+hz))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
//mesh3 Th("/Users/Hecht/Desktop/bug-ff/Th2.mesh"); //
mesh3 Th=cube(2,2,2); //,[10*(x+y/3),10*(y-x/3),z]);
//Th=trunc(Th, nuTriangle==0);
real x1=0.7,y1=0.9,z1=0.1, h=1e-4;
int it1=Th(x1,y1,z1).nuTriangle; 
fespace Vh(Th,P4);
fespace Eh(Th,P0face3d);
cout << " ndof = "<< Vh.ndof << " /K "<< Vh.ndofK<< endl; 
Eh  edges;

Vh a1,b1,c1;
func bool pvi(real[int] & v)
{
	for(int i=0; i< v.n; ++i)
	if( abs(v[i])>1e-10) cout << i << " ";
	return true;
} 
varf vFlux([a],[e]) = intallfaces(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intallfaces(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/area);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
int err=0;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Tet " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
//  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
//  cout << " Mean   edges = " << edges[] << endl; 
  real je= intallfaces(Th)(square(jump(a1)));
  if( je > 1e-10) err++;
  //plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

 // plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min ;	
  if( c1[].linfty> 1e-10)
  {
	  err++;
    cout <<i << " " ;
    pvi(a1[]);
    cout << " --> " ;
    pvi(b1[]);
    cout <<"   err = "<< err  <<endl;
  }
  cout<< endl;
 // assert(c1[].max < 1e-5 && c1[].min > -1e-9);
  /*
  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1,z1) << " == " << DD(a1,h,0,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1,z1) << " == " << DD(a1,0,h,0)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1,z1) << " == " << DD2(a1,h,0,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1,z1) << " == " << DD2(a1,0,h,0)  << endl; 

  assert( abs(dx(a1)(x1,y1,z1)-DD(a1,h,0,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1,z1)-DD2(a1,h,0,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1,z1)-DD(a1,0,h,0) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1,z1)-DD2(a1,0,h,0) ) < 1e-4);
*/


} 
assert(err==0); 
}

/*
{
	meshL Th=segment(1);
	fespace Vh(Th,P4L);
	fespace Wh(Th,P4dcL);
	func f = 1; //3*x^3+2*x^2+x + 1;
	Vh u = f;
	Wh fd = f;
	Vh v=0;
	v[][0] = 1.; 
	real err = sqrt(int1d(Th)( sqr(f-u)));
	cout << "err L " << err << endl;
	for(int i=0; i<= 9;++i)
	{
		x = i/9.;
		cout << x << " "<< u << " " << f << " " << fd << " " << v << endl; 
	}
	
	
 assert(err < 1e-6);	
	
}
*/
{
	mesh Th2=square(10,10,flags=3);
	//Th2 = trunc(Th2,x<0.5);
	meshS Th=movemesh23(Th2,transfo=[x,y,0]);
	plot(Th,wait=1);
	fespace Vh(Th,P4S);
	fespace Vh2(Th2,P4);
	int[int] P(Vh2.ndof);
	for(int k=0;k<Th.nt;++k)
	for (int i=0;i<15;++i)
	P[Vh(k,i)]=Vh2(k,i);
	//Vh2 f;f[]=0;f[][1]=3;
	func f =3*x^3+2*x^2+x + 1+x*y+y^3+x^4;
	Vh u = f;
	Vh2 u2 =f;
	Vh v=0;
	v[]=u2[](P); 
	v[] -= u[];
	for(int i=0; i< Vh.ndofK;++i)
	cout << Vh(0,i) << " ";
	cout << endl; 
       // cout << " u = " << u[] << endl;
       // cout << " 0 == v = " << v[] << endl;
	cout << endl;
        v[]=u2[](P); 
	//cout << P << endl;
	real err = sqrt(int1d(Th)( sqr(f-u)));
	real err1 = sqrt(int1d(Th)( sqr(f-v)));
	real err2= sqrt(int1d(Th)( sqr(f-u2)));
	cout << "err S " << err << endl;
	cout << "err 1 " << err1 << endl;
	cout << "err 2 " << err2 << endl;
	u2[](P) -=u[];
	cout << u2[].linfty << endl;
	err+= u2[].linfty;
 assert(err < 1e-6);	
	
}

/*

{ // P4HL
       real L = 1;
	meshL Th=segment(1,[x*L,0,0]);
	fespace Vh(Th,P4HL);
	fespace Wh(Th,P4L);
	fespace Whdc(Th,P4dcL);
	func f = 3*(x^3) +2*(x^2)+x + 1;
	func fxx = 18*x+4. ;//+ 4.;
	Wh fh = f;
	cout << " 0 = "<< f(0,0) << " " << dx(fh)(0,0) << " "<< dxx(fh)(0,0) <<" "<< fxx(0,0) << endl; 
	cout << " L = "<< f(L,0) << " " << dx(fh)(L,0) << " " << dxx(fh)(L,0) <<" "<< fxx(L,0) << endl; 
	
	Vh [u,ux] = [f,dx(fh)];
	cout << " u[]"<< u[] << endl; 
	Vh [v,vx]; v[]=0;
	// function de base OK ...
	// interpolation ok ...
	real err = 0; 
	for(int i=0; i<4;++i)
	{ 
	v[]=0;
	v[][Vh(0,i)] = 1.; 
	Wh vv=v,dvv=dx(vv);
	cout << i << " " << Vh(0,i) << " " << dxx(vv)(0,0,0) << " " <<  dxx(vv)(L,0,0) << " " << dxx(dvv)(L/2,0,0)  <<endl;
	cout << "    v 0: "<< v(0,0,0) << " " << vx(0,0,0) << endl; 
	cout << "    v 1: "<< v(L,0,0) << " " << vx(L,0,0) << endl; 
	cout << "    dx(v) 0: "<< dx(v)(0,0,0) << " " << dx(vx)(0,0,0) << endl; 
	cout << "    dx(v) 1: "<< dx(v)(L,0,0) << " " << dx(vx)(L,0,0) << endl; 
	cout << "    dxx(v) 0: "<< dxx(v)(0,0,0) << " " << dxx(vx)(0,0,0) << endl; 
	cout << "    dxx(v) 1: "<< dxx(v)(L,0,0) << " " << dxx(vx)(L,0,0) << endl; 

	Vh [w,wx]=[v,vx]; 
	v[] -= w[]; 
	err += v[].linfty ;
	cout << " w[]"<< w[] <<" err " << err <<  endl; 
        }
        err+= sqrt(int1d(Th)( sqr(f-u)));
	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(dx(fh)-dx(u))));
	 cout << "err L " << err << endl;	
         err+= sqrt(int1d(Th)( sqr(dx(fh)-ux)));
 	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(fxx-dxx(u))));
	//Whdc d=dxx(fh)-dxx(u);
	//cout << d[] << endl;
        cout << "err L " << err << endl;	
	
	
      {  // BiLap 1d ..
	      real cc = 16.;
	      func ue = cc*(1-x)*(1-x)*x*x;
	      func fe = cc*24.0;
	      int nn=50;
	      Th = segment(nn);
	      meshL Thg=segment(nn*40);
	      fespace Ph(Thg,P1);
	      Vh  [u,ux] ,  [v,vx] ;
	      solve BiLap([u,ux],[v,vx]) = int1d(Th)(dx(ux)*dx(vx))- int1d(Th)(fe*v)+on(1,2,u=0,ux=0);
	      Ph U=u, X=x,Ux=ux, F=ue;
	      //cout << U[] << endl;
	      plot([X[],U[]],[X[],F[]],wait=1);
	      err += sqrt(int1d(Th)(sqr(ue-u)));;
	      cout << " err = " << err << endl; 
      }	
 assert(err < 1e-6);	
	
}
*/
load "addNewType"

myType ff("toto"); 
cout << ff(1,2).x << endl; 

cout << ff(1,2).N.x  << endl; 
load "Element_HCT"
load "splitmesh3"
load "Element_P3dc"

macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,flags=3);//,[10*(x+y/3),10*(y-x/3)]);
// Th=trunc(Th,x<0.5); 
mesh Th3=splitmesh3(trunc(Th,1,split=10));
for(int i=0; i<3;++i)
cout <<i << " "  <<" "<<  Th[0][i].x << " " << Th[0][i].y  << endl;
real x1=0.7,y1=0.9, h=1e-6;
int it1=Th(x1,y1).nuTriangle; 

func ff =  2*x*x + 3*y*y + 4.5*y*x + 5*x + 6*y + 7;
func ffx = 4*x + 4.5*y + 5;
func ffy = 6*y + 4.5*x + 6;
func ffxx = 4.;
func ffyy = 6.;
func ffxy =4.5;

fespace Vh(Th,HCT);
fespace Wh(Th3,P3dc);
fespace Eh(Th,P0edge);

Eh  edges;

Vh [a1,a2,a3],[b1,b2,b3],[c1,c2,c3];

 
[a1,a2,a3] = [ ff,ffx,ffy];
cout << a1(0,0) << endl; 
if(1)
for(int k=0; k<12; ++k)
{
    a1[]=0;
    a1[][Vh(0,k)]=1;
    Wh aa=a1,dxaa=dx(aa),dyaa=dy(aa);
    real err=int2d(Th)( square(aa-a1));
    real errx=int2d(Th)( square(dx(aa)-a2));
    real erry=int2d(Th)( square(dy(aa)-a3));
    real errxx=int2d(Th)( square(dx(dxaa)-dxx(a1)));
    cout << int2d(Th)( square(dxaa));
    cout << int2d(Th)( square(dxx(a1)));
  assert(errxx<1e-9);
 
    real erryy=int2d(Th)( square(dy(dyaa)-dyy(a1)));
    real errxy=int2d(Th)( square(dy(dxaa)-dxy(a1)));
    cout << " err= " <<k << ":" << err << " /" << errx << " "<< erry << " / " << errxx << " "<< errxy << " " 
    << erryy << endl;
    assert(int2d(Th)( square(dy(a2)-dyx(a1))) < 1e-9);
    assert(int2d(Th)( square(dy(a3)-dyy(a1))) < 1e-9);
    assert(int2d(Th)( square(dx(a2)-dxx(a1))) < 1e-9);
    assert(int2d(Th)( square(dx(a3)-dxy(a1))) < 1e-9);
    assert(errx<1e-9);
    assert(erry<1e-9);
   assert(errxx<1e-9);
   assert(errxy<1e-9);
   assert(erryy<1e-9);
   [b1,b2,b3]=[a1,a2,a3];
   cout << " a2, a3 :" << a2(0.5,0.5) << " " << a3(0.5,0.5) <<endl; 
   cout << k <<  " b1 = " << b1[] << endl;
   b1[]-=a1[];
   assert(b1[].linfty < 1e-6);
}
 cout << a1(0.6,0.2) << " == " << ff(0.6,0.2) << endl;
 cout << a2(0.6,0.2) << " == " << ffx(0.6,0.2) << endl;
  cout << a3(0.6,0.2) << " == " << ffy(0.6,0.2) << endl;
  cout << dxx(a1)(0.6,0.2) << " xx== " << ffxx(0.6,0.2) << endl;
  cout << dyy(a1)(0.6,0.2) << " yy== " << ffyy(0.6,0.2) << endl;
  cout << dxy(a1)(0.6,0.2) << " xy== " << ffxy(0.6,0.2) << endl;
  cout << dyx(a1)(0.6,0.2) << " yx== " << ffxy(0.6,0.2) << endl;
 cout << a1(0.2,0.6) << " == " << ff(0.2,0.6) << endl;
 cout << a2(0.2,0.6) << " == " << ffx(0.2,0.6) << endl;
  cout << a3(0.2,0.6) << " == " << ffy(0.2,0.6) << endl;
 cout << " 00 = " << int2d(Th)(square(a1-ff)) << endl;
 cout << " 00 = " << int2d(Th)(square(a2-ffx)) << endl;
 cout << " 00 = " << int2d(Th)(square(a3-ffy)) << endl;
plot(a1,wait=1);

//Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  for (int k=0; k< 3; ++k)
    cout <<" v at " << Th[it1][k] <<  " == " << a1(Th[it1][k].x, Th[it1][k].y) << " " << Th[it1][k].x<< " " <<  Th[it1][k].y <<endl;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  [b1,b2,b3]=[a1,a2,a3];

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];
  cout << " int_1 " <<  int1d(Th,1) (dn(a1)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dn(a1)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dn(a1)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dn(a1)) << endl;

  cout << " int_1 " <<  int1d(Th,1) (dnn(a)) << endl;
  cout << " int_3 " <<  int1d(Th,3) (dnn(a)) << endl;
  cout << " int_2 " <<  int1d(Th,2) (dnn(a)) << endl;
  cout << " int_4 " <<  int1d(Th,4) (dnn(a)) << endl;

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << " == " << a2(x1,y1) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h) << " == " << a3(x1,y1) << endl; 

  cout << " dx(a2)(x1,y1) = " << dx(a2)(x1,y1) << " == " << DD(a2,h,0)  << " == " << dxx(a1)(x1,y1) << endl; 
  cout << " dy(a2)(x1,y1) = " << dy(a2)(x1,y1) << " == " << DD(a2,0,h)  << " == " << dxy(a1)(x1,y1) << endl; 
  cout << " dx(a3)(x1,y1) = " << dx(a3)(x1,y1) << " == " << DD(a3,h,0)  << " == " << dxy(a1)(x1,y1) << endl; 
  cout << " dy(a3)(x1,y1) = " << dy(a3)(x1,y1) << " == " << DD(a3,0,h)  << " == " << dyy(a1)(x1,y1) << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a2)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs((a3)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dx(a2)(x1,y1)-DD(a2,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-4);


} 

/*  README NEWUOA:
     This is the Fortran version of NEWUOA. Its purpose is to seek
the least value of a function F of several variables, when derivatives
are not available, where F is specified by the user through a subroutine
called CALFUN. The algorithm is intended to change the variables to values
that are close to a local minimum of F. The user, however, should assume
responsibility for finding out if the calculations are satisfactory, by
considering carefully the values of F that occur. The method is described
in the report "The NEWUOA software for unconstrained optimization without
derivatives", which is available on the web at www.damtp.cam.ac.uk, where
you have to click on Numerical Analysis and then on Reports, the number
of the report being NA2004/08. Let N be the number of variables. The main
new feature of the method is that quadratic models are updated using only
about NPT=2N+1 interpolation conditions, the remaining freedom being taken
up by minimizing the Frobenius norm of the change to the second derivative
matrix of the model.

     The new software was developed from UOBYQA, which also forms quadratic
models from interpolation conditions. That method requires NPT=(N+1)(N+2)/2
conditions, however, because they have to define all the parameters of the
model. The least Frobenius norm updating procedure with NPT=2N+1 is usually
much more efficient when N is large, because the work of each iteration is
much less than before, and in some experiments the number of calculations
of the objective function seems to be only of magnitude N.

     The attachments in sequence are a suitable Makefile, followed by a main
program and a CALFUN routine for the Chebyquad problems, in order to provide
an example for testing. Then NEWUOA and its five auxiliary routines, namely
NEWUOB, BIGDEN, BIGLAG, TRSAPP and UPDATE, are given. Finally, the computed
output that the author obtained for the Chebyquad problems is listed.

     The way of calling NEWUOA should be clear from the Chebyquad example
and from the comments of that subroutine. It is hoped that the software will
be helpful to much future research and to many applications. There are no
restrictions on or charges for its use. If you wish to refer to it, please
cite the DAMTP report that is mentioned above, which has been submitted for
publication in the proceedings of the 40th Workshop on Large Scale Nonlinear
Optimization (Erice, Italy, 2004).

December 16th, 2004                    M.J.D. Powell (mjdp@cam.ac.uk)
*/

load "ffnewuoa"
/*
      SUBROUTINE CALFUN (N,X,F,IWF)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION X(*),Y(10,10),IWF(*)
      DO 10 J=1,N
      Y(1,J)=1.0D0
   10 Y(2,J)=2.0D0*X(J)-1.0D0
      DO 20 I=2,N
      DO 20 J=1,N
   20 Y(I+1,J)=2.0D0*Y(2,J)*Y(I,J)-Y(I-1,J)
      F=0.0D0
      NP=N+1
      IW=1
      DO 40 I=1,NP
      SUM=0.0D0
      DO 30 J=1,N
   30 SUM=SUM+Y(I,J)
      SUM=SUM/DFLOAT(N)
      IF (IW .GT. 0) SUM=SUM+1.0D0/DFLOAT(I*I-2*I)
      IW=-IW
   40 F=F+SUM*SUM
      RETURN
      END 

*/
int N=2;
real[int,int] Y(N+1,N);
real[int] X(N);
func real J(real[int] & X)
{
  Y(0,:)=1.;
  Y(1,:)=2.*X;
  for(int i=2;i<=N;++i)
    for(int j=0;j<N;++j)
      Y(i,j) = Y(1,j) * Y(i-1,j)- Y(i-2,j);

  real f=0;
  int np=N+1,iw=1;
  for(int i=0;i<=N;i++)
    {
      real s=Y(i,:).sum/N;
      int i1=i+1;
      if(iw>0) s+= 1./(i1*i1-2.*i1);
      iw=-iw;
      f += s*s;
    }
  return 2.14+f;
}
real delta=1;
mesh Th=square(30,30,[(x-0.5)*delta,(y-0.5)*delta]);
fespace Vh(Th,P1);
Vh u;
for(int i=0;i<Th.nv;++i)
  {X[0]=Th(i).x;X[1]=Th(i).y;
    u[][i]=J(X);
  }
plot(u,wait=1);

for(int i=0;i<N;++i)
  X[i]=(i+1)/(N+1.);
real mincost=newuoa(J,X,rhobeg=2*X[0],rhoend=1e-6,npt=2*N+1);
cout << " min " << mincost << "  at :" << X << endl;
load "BernardiRaugel"
// remark: the sign of p is correct
real s0=clock();
mesh Th=square(2,2);
fespace Vh2(Th,P2BR);
fespace Vh(Th,P0);

fespace Wh(Th,[P2BR,P0]);
real reylnods=400;
//cout << " Enter the reynolds number :"; cin >> reylnods;
Wh [u1,u2,p],[v1,v2,q],[up1,up2,pp];
assert(reylnods>1 && reylnods < 100000);
[up1,up2,pp]=[0.,0.,0.];

func g=(x)*(1-x)*4;

real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;
varf NS ([u1,u2,p],[v1,v2,q],init=i) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2)
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            - p*q*(0.000001)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  - int2d(Th) ( -alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 )
  + on(3,u1=g,u2=0)
  + on(1,2,4,u1=0,u2=0) ;
  matrix A= NS(Wh,Wh,solver="SPARSESOLVER");
  real[int] b=  NS(0,Wh);
  u1[] = A^-1*b;
plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="o/StokesP2P1.eps",value=1,wait=1);
{
  real[int] xx(21),yy(21),pp(21);
  for (int i=0;i<21;i++)
   {
     yy[i]=i/20.;
     xx[i]=u1(0.5,i/20.);
     pp[i]=p(i/20.,0.999);
    }
      cout << " " << yy << endl;
     plot([xx,yy],wait=1,cmm="u1 x=0.5 cup");
     plot([yy,pp],wait=1,cmm="pressure y=0.999 cup");
}

dt = 0.1;
int nbiter = 3;
real coefdt  = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.3,coeftol = 0.25^(1./nbiter);
nu=1./reylnods;

for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ " << endl;
  alpha=1/dt;
  A= NS(Wh,Wh,solver="SPARSESOLVER");
  for (i=0;i<=10;i++)
   {
     up1[]=u1[]; // copie vectoriel
     real[int] b= NS(0,Wh);
	 u1[] = A^-1*b;
     //NS;
     if ( !(i % 10))
     plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="o/plotNS_"+iter+"_"+i+".eps");
     cout << "CPU " << clock()-s0 << "s " << endl;
   }

  if (iter>= nbiter) break;

  Th=adaptmesh(Th,[u1,u2],iso=0,
              abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="o/ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
  [u1,u2,p]=[u1,u2,p];// reinterpolation
  [up1,up2,pp]=[u1,u2,p];// reinterpolation


//  plot(coef=0.2,cmm=" [u1,u2] et p --------- ",p,[u1,u2],wait=1);
   }
cout << "CPU " << clock()-s0 << "s " << endl;
// meditddm.edp
load "medit"
load "msh3"
load "shell"
/********************************************
 Initial Problem:
Resolution of the following EDP:
$- \Delta u = f$ on   $\Omega =\{ (x,y) |  1 \leq sqrt(x^2+y^2) \geq 2}$
$- \Delta u = f1$ on  $\Omega_{1} =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
$u = 1$ on $\Gamma$  +  Null Neumman condition on $\Gamma_{1}$ and on $\Gamma_{2}$	
We find the solution $u$ in solving two EDP defined on domain $\Omega$ and $\Omega_{1}$
This solution is vizualize with ffmedit 
*********************************************/
verbosity=3;
{
border Gamma(t=0,2*pi){x=cos(t); y=sin(t); label=1;};
border Gamma1(t=0,2*pi){x=2*cos(t); y=2*sin(t); label=2;};
border Gamma2(t=0,2*pi){x=0.5*cos(t); y=0.5*sin(t); label=3;};

// construction of mesh of domain $\Omega$
mesh Th=buildmesh(Gamma1(40)+Gamma(-40)); 

fespace Vh(Th,P2);
func f=sqrt(x*x+y*y);
Vh us,v;
macro Grad2(us) [dx(us),dy(us)]  // EOM

problem Lap2dOmega(us,v,init=false)=int2d(Th)(Grad2(v)' *Grad2(us)) - int2d(Th)(f*v)+on(Gamma,us=1) ;
//  Resolution of EDP defined on the domain $\Omega$
// $- \Delta u = f$ on $\Omega$ 
//      $u = 1$  on $\Gamma
//   + Null Neumann condition on $\Gamma_{1}$
Lap2dOmega;

// construction of mesh of domain $\Omega1 =\{ (x,y) |  0.5 \leq sqrt(x^2+y^2) \geq 1.}$
mesh Th1=buildmesh(Gamma(40)+Gamma2(-40));

fespace Vh1(Th1,P2);
func f1=10*sqrt(x*x+y*y);
Vh1 u1,v1;
macro Grad21(u1) [dx(u1),dy(u1)]  // EOM

problem Lap2dOmega1(u1,v1,init=false)=int2d(Th1)(Grad21(v1)' *Grad21(u1)) - int2d(Th1)(f1*v1)+on(Gamma,u1=1) ;
//   Resolution of EDP defined on the domain $\Omega_{1}$
// $- \Delta u = f1$ on $\Omega_{1}$ 
//      $u = 1$ on $\Gamma$
//   + Null Neumann condition on $\Gamma_{2}$
Lap2dOmega1; 

// vizualisation of solution of the initial problem
medit("solution",Th,us,Th1,u1,order=1,meditff="ffmedit",save="testsavemedit.solb");	
// 
}
{
	mesh3 Th=cube(10,10,10);
	fespace Vh(Th,P1);

	Vh u= x+2*y+3*z;
	savemesh(Th,"meditcube.meshb");
	savesol("meditcube.solb",Th,u,order=1);
}
{
mesh3 Th=readmesh3("meditcube.meshb");
fespace Vh(Th,P1);
Vh u;
verbosity=99;
u[]=readsol("meditcube.solb");
cout << u[].max << " " << u[].min << endl;
assert(abs(u[].max-6) <1e-6);
plot(u);
unlink("meditcube.meshb");
unlink("meditcube.solb");

}
load "CircumCenter"

mesh Th = square(3,3);

fespace Ph(Th,P0);

Ph px,py;

CircumCenter(Th,px[],py[]);

cout << px[] << endl;
cout << py[] << endl;
/*
 *     min   x1*x4*(x1 + x2 + x3)  +  x3
            (= x1^2.x4 + x1.x2.x4 + x1.x3.x4 + x3)
 *     s.t.  x1*x2*x3*x4                   >=  25
 *           x1**2 + x2**2 + x3**2 + x4**2  =  40
 *           1 <=  x1,x2,x3,x4  <= 5
 *
 *     Starting point:
 *        x = (1, 5, 5, 1)
 *
 *     Optimal solution:
 *        x = (1.00000000, 4.74299963, 3.82114998, 1.37940829)
 */
 
 load "ff-Ipopt"
 real[int] xlb=[1.,1.,1.,1.],xub=[5.,5.,5.,5.],glb=[25.,40.],gub=[1.e19,40.];
 
 func real J(real[int] &X)
 {
 	return X[0]*X[3]*(X[0] + X[1] + X[2]) + X[2];
 }
 
 func real[int] dJ(real[int] &X)
 {
 	real[int] grad(X.n);
 	grad[0] = 2.*X[0]*X[3] + X[1]*X[3] + X[2]*X[3];
 	grad[1] = X[0]*X[3];
 	grad[2] = X[0]*X[3] + 1.;
 	grad[3] = X[0]*X[0] + X[0]*X[1] + X[0]*X[2];
 	return grad;
 }
 
matrix H; 

	int[int] hi=[0,1,1,2,2,2,3,3,3,3],hj=[0,0,1,0,1,2,0,1,2,3];
	real[int] hc(hi.n);
	hc=0.;

func matrix HJ(real[int] &X,real jfactor,real[int] &lambda)
{
	H = [hi,hj,hc];
	H(0,0) = jfactor * 2*X[3];
	H(1,0) = jfactor * X[3];
	H(2,0) = jfactor * X[3];
	H(3,0) = jfactor * (2*X[0] + X[1] + X[2]);
	H(3,1) = jfactor * X[0];
	H(3,2) = jfactor * X[0];
	H(1,0) += lambda[0] * (X[2]*X[3]);
	H(2,0) += lambda[0] * (X[1]*X[3]);
	H(2,1) += lambda[0] * (X[0]*X[3]);
	H(3,0) += lambda[0] * (X[1]*X[2]);
	H(3,1) += lambda[0] * (X[0]*X[2]);
	H(3,2) += lambda[0] * (X[0]*X[1]);
	H(0,0) += lambda[1] * 2.;
	H(1,1) += lambda[1] * 2.;
	H(2,2) += lambda[1] * 2.;
	H(3,3) += lambda[1] * 2.;
	//cout << H << endl;
	return H;
}
 
 func real[int] G(real[int] &X)
 {
 	real[int] g(2);
 	g[0] = X[0]*X[1]*X[2]*X[3];
 	g[1] = square(X.l2);
 	return g;
 }
 
 matrix GG;
 int[int] II=[0, 0, 0, 0, 1, 1, 1, 1], JJ=[0, 1, 2, 3, 0, 1, 2, 3];
 real[int] CC=[0.,0.,0.,0.,0.,0.,0.,0.];
 
 GG = [II,JJ,CC];
 
 func matrix jacG(real[int] &X)
 {
    GG(0,0) = X[1]*X[2]*X[3];
    GG(0,1) = X[0]*X[2]*X[3];
    GG(0,2) = X[0]*X[1]*X[3];
    GG(0,3) = X[0]*X[1]*X[2];
    GG(1,0) = 2.*X[0];
    GG(1,1) = 2.*X[1];
    GG(1,2) = 2.*X[2];
    GG(1,3) = 2.*X[3];
 	return GG;
 }
 
 real[int] start=[1, 5, 5, 1];
 real[int] optimsol=[1.00000000, 4.74299963, 3.82114998, 1.37940829];
IPOPT(J,dJ,HJ,G,jacG,start,ub=xub, lb=xlb,clb=glb,cub=gub);
optimsol -= start;
cout << "Dist : " << optimsol.l2 << endl;
 
// Theorem 3.3 in https://arxiv.org/pdf/2105.14981.pdf 
load "Element_P4dc"
load "Element_P4"
load "Element_P3nc"
func real cc(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];

// the ref triangle 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);


//Th = movemesh(Th,[x+0.1*y,y-0.2*x]);
//Th = movemesh(Th,[x*2,y*2]);

mesh Thg = trunc(Th,1,split=2,label=-1);
plot(Th, wait=1);
cout << " Th: " << Th[0][0] << Th[0][1]  << Th[0][2]  << endl; 
int it0=0; 

fespace Lh(Th,P1);
Lh[int] l(3);
l[0][][0]=1;
l[1][][1]=1;
l[2][][2]=1;


fespace Wh(Th,P4dc);
fespace Vh(Th,P3nc);
Wh[int] mn(10);
int k=0;
real cc6 = 3*4*5;
//func bk = (l[0] - l[1]) * (l[1] - l[2]) * (l[2] - l[0]);
func l0 =l[0];
func l1 =l[1];
func l2 =l[2];

mn[k++]=      l0 * l0 * l0;
mn[k++]=  l1 * l1 * l1;
mn[k++]=  l2 * l2 * l2;                                            //3
mn[k++]=        l0 * l0 * l1;
mn[k++]=   l0 * l0 * l2;
mn[k++]=   l1 * l1 * l0;
mn[k++]=   l1 * l1 * l2;
mn[k++]=   l2 * l2 * l0;
mn[k++]=   l2 * l2 * l1;
  //6
mn[k++]=        l0 * l1 * l2;                                                                       //2
//mn[k++]=        bk * l0;
//mn[k++]=   bk * l1 ;                                                                    // P4 element

assert(k==10);
/*
      l0 * l0 * l0, l1 * l1 * l1, l2 * l2 * l2,                                            //3
      l0 * l0 * l1, l0 * l0 * l2, l1 * l1 * l0, l1 * l1 * l2, l2 * l2 * l0, l2 * l2 * l1,  //6
      l0 * l1 * l2,                                                                        //2

*/
Vh u,v;
real[int,int] CC(10,10),C1(10,10);
for (int j=0;j<10;++j)
{
	Wh u=mn[j];
	int i=0;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge));
		CC(j,i++)=  cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge));
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	CC(j,i++)= cc(int2d(Th,qforder=9)( u/area)) ;// bof bof !!!
}
C1=CC		;
CC *=cc6;
cout << " CC =" << CC << endl;
  load "lapack"
inv(C1); 
real[int,int]   Ct =  C1';

cout << " C1 =" << C1 << "\n C1' " << Ct << endl;
cout << " {";
for( int i=0; i<10; ++i)
{ cout << "{";
for( int j=0; j<10; ++j)
{  cout << C1(j,i)  ;
   if( j != 9) cout << ",";}
   cout << "}";
   if( i != 9) cout << ",\n";
}
cout << "}\n\n";


for (int j=0;j<Vh.ndofK;++j)
{
	int i = Vh(0,j);
	cout << j << " -> " <<  i << " : " ;
    u=0;
	u[][i]=1;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		if ( i2 < i1) swap(i1,i2); 
		cout << " " << cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	cout << " " << cc(int2d(Th,qforder=9)( u/area))  <<  " ::::   " ; 
	//plot(u,wait=1);
	v=u;
	for (int j=0;j<Vh.ndofK;++j)
	cout << cc(v[][Vh(0,j)]) << " " ;
	cout << endl;

}


 Th=square(5,5);
 u=x*x*y;
 v = u;
 cout << " err = " << sqrt(int2d(Th)(square((u)-(u))));
 solve PL2(u,v)=int2d(Th,qforder=7)(u*v)-int2d(Th,qforder=9)(x*x*y*v);
 // verification  !!!!!
 plot(u,wait=1);
 real err=0,err1=0,err2=0; 
for (int i=0;i<Vh.ndof;++i)
{
    u=0;

	u[][i]=1;
	Wh u3=u;
	v=u;
	v[]-=u[];
	real e  = v[].linfty;
	real e1 = sqrt(int2d(Th)(square(dx(u)-dx(u3))));
	real e2 = sqrt(int2d(Th)(square(dy(u)-dy(u3))));
	Wh dxu=dx(u), dxu3=dx(u3);
	Wh dyu=dy(u), dyu3=dy(u3);
	//plot(dxu,cmm=" dxu ", wait=1);
	//plot(dxu3,cmm=" dxu3 ", wait=1);
	dxu [] -= dxu3[];
	dyu [] -= dyu3[];
	real ee =  dxu []. linfty +  dyu []. linfty + e1 + e2;
	if( ee > 1e-6)
	  cout << i << " " << e << " " << e1 << " " << e2 << " :: " << dxu []. linfty << " " << dyu []. linfty << endl;
	err+= ee;
}
cout << " err=" << err  << endl; ; 
assert( err < 1e-6);
load "Element_P4" load "msh3" load "medit"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P4);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
    medit("mm",Th3); 
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "ff-Ipopt";
int nn=10;
mesh Th=square(nn,nn);
fespace Vh(Th,[P1,P1] );
fespace Wh(Th,[P1] );
int iter=0;

func f1 =  10;//right hand sides
func f2 = -15;
func g1 = -0.1;//Boundary conditions functions
func g2 =  0.1;

Vh [uz,uz2]=[1,1],[lz,lz2]=[1,1];
Wh lm=1.;
Vh [u1,u2]=[0,0];//starting point


while(++iter)
{
macro Grad(u) [dx(u),dy(u)]//gradient macro
varf vP([u1,u2],[v1,v2]) = int2d(Th)(Grad(u1)'*Grad(v1)+ Grad(u2)'*Grad(v2)) 
- int2d(Th)(f1*v1+f2*v2);

matrix A = vP(Vh,Vh);//Fitness function matrix...
real[int] b = vP(0,Vh);//and linear form

int[int] II1=[0],II2=[1];//Constraints matrix
matrix C1 =  interpolate (Wh,Vh, U2Vc=II1);
matrix C2 =  interpolate (Wh,Vh, U2Vc=II2);
matrix CC = -1*C1 + C2; // u2 - u1 >0
Wh cl=0;//constraints lower bounds (no upper bounds)

//Boundary conditions
varf vGamma([u1,u2],[v1,v2]) = on(1,2,3,4,u1=1,u2=1);
real[int] onGamma=vGamma(0,Vh);
Vh [ub1,ub2]=[g1,g2];
Vh [lb1,lb2]=[g1,g2];
ub1[] = onGamma ? ub1[] : 1e19  ; //Unbounded in interior
lb1[] = onGamma ? lb1[] : -1e19  ;


Vh [uzi,uzi2]=[uz,uz2],[lzi,lzi2]=[lz,lz2];
Wh lmi=lm;
Vh [ui1,ui2]=[u1,u2];

IPOPT([b,A],CC,ui1[],lb=lb1[],clb=cl[],ub=ub1[],warmstart=iter>1,uz=uzi[],lz=lzi[],lm=lmi[]);

//cout << "ADAPTMESH ITERATION " << iter << endl << "UZ = " << uzi[] << endl << "LZ = " << lzi[] << endl << "LM = " << lmi[] << endl;

plot(ui1,ui2,wait=1,nbiso=60,dim=3);
if(iter > 1) break;
Th= adaptmesh(Th,[ui1,ui2],err=0.004,nbvx=100000);
[uz,uz2]=[uzi,uzi2];
[lz,lz2]=[lzi,lzi2];
[u1,u2]=[ui1,ui2];
lm=lmi;
}
load "gmsh"
load "iovtk"
load "medit"
//verbosity = 1;

// example gmsh

mesh3 Th = gmshload3("cube.msh");
//medit("gmsh3d",Th,wait=1);

// example iovtk

border Gamma(t=0,2*pi){x=cos(t);y=sin(t);label=3;}
border Gamma1(t=0,2*pi){x=2*cos(t);y=2*sin(t);label=5;}
mesh Th2 = buildmesh( Gamma(10)+Gamma1(20) ); 

fespace Vh(Th2,P1);     // P1 FE space
func gg=x;
Vh uh,vh,u;   
Vh ggg=gg;
solve laplacep(uh,vh,solver=CG,tgv=1e5) =      //  definion of  the problem 
    int2d(Th2)( dx(uh)*dx(vh) + dy(uh)*dy(vh) )   //  bilinear form
       + on(3,uh=1)+ on(5,uh=2) ;                        //  boundary condition form

cout << "vtk information" << endl;
int[int] fforder=[0,0,1,0,1];
savevtk("disque.vtk",Th2,uh,ggg,uh,[uh,ggg],[uh,ggg],dataname="kkdjd jyqql bidule45 vector nnn nn44233T",order=fforder,bin=1);


mesh3 Th3;
try {
Th3=readmesh3("spherewithahole.mesh"); // This .mesh file is obtaing with tetgenholeregion.edp
}
catch (...) {
  // FFCS - path to example scripts are changed, so this needs to be in the local directory to be common to FF and FFCS
  //  trick to extract Th3finhole from "tetgenholeregion_rugby.edp"
  //  warning Th3 mesh3 exist in "tetgenholeregion_rugby.edp"
  mesh3 Thedp;// mesh3 variable  out the block 
  {
  include "tetgenholeregion_rugby.edp"
  Thedp=Th3finhole;// save de correcte mesh 
  }
  Th3=Thedp;// set coorect variable ...
}
fespace Vh3(Th3,P1);     // P1 FE space
func gg2=x+y;
int[int] fforder2=[1,1,1,1];
if(verbosity) verbosity=2;
savevtk("bidule.vtu",Th3,gg2,[gg2,gg2,gg2],gg2,[gg2,gg2,gg2],order=fforder2,dataname="kkdjd jyqql bidule45",bin=1); // The fourth solution Have no name. This name is vector4 (4 ==> fourth solution and vector ==> vector solution).
savevtk("bidule.vtk",Th3,gg2,[gg2,gg2,gg2],gg2,[gg2,gg2,gg2],order=fforder2,dataname="kkdjd jyqql bidule45",bin=1);
if(0) { // restore mesh and data, does not work on Windows
real[int][int] data;	

mesh3 Th=vtkload3("bidule.vtk",fields=data);//  work only with order =1 and vgk file
cout << " " << data.n << " == 4 "<< endl;
}

savegmsh(Th3,"Th3");
load "splitmesh6"
mesh Th=square(5,5);
mesh Th6=splitmesh6(Th);
plot(Th6,wait=1);

fespace Vh(Th,P1);
fespace Nh(Th,P0);

fespace Vh6(Th6,P1);
fespace Nh6(Th6,P0);
fespace RT6(Th6,RT0); // Raviart Thomas ordre 0

//  
varf vM6(u,v) = int2d(Th6,qforder=1)(u*v*3/area);
matrix  M610= vM6(Nh6,Vh6);
matrix  I61 = interpolate(Vh,Vh6);
matrix  S61 =  I61*M610;

Nh6 eta6=1;
Vh  eta;
eta[]= S61*eta6[];
plot(eta,wait=1);

RT6  [u6,v6];
RT6  [uu6,vv6];

Nh6 x6=x,y6=y;

//solve  PP([u6,v6],[uu6,vv6]) = intalledges(Th6)(  u6*uu6*N.x + v6*vv6*N.y)
//- intalledges(Th6)(  mean(x6)*uu6*N.x + mean(y6)*vv6*N.y);

  [u6,v6] = [mean(x6),mean(y6)]; // OK version 2.19 
 [uu6,vv6] = [x6,y6];
 plot( [u6,v6],  [uu6,vv6], wait=1);
 
 
load "Element_P4dc"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P4dc);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;

if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    if(0)
      { 
      load "medit" load "msh3"
      meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
      medit("mm",Th3); 

      //savemesh(th,"mm",[x,y,vi*0.5]);   //save *.points and *.faces file for medit
      //exec("ffmedit mm");
      //exec(" rm mm.faces mm.points");
      }	
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "Element_Mixte"
/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$

*/
mesh Th=square(10,10);
fespace Vh(Th,RT1);
fespace Ph(Th,P1dc);

func gd = 1.;
func g1n = 1.;
func g2n = 1.;
func f = 1.;

Vh [u1,u2],[v1,v2];
Ph p,q;

problem laplaceMixte([u1,u2,p],[v1,v2,q],solver="SPARSESOLVER",eps=1.0e-10,tgv=1e30,dimKrylov=150) =
   int2d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
 + int2d(Th) ( f*q)
 - int1d(Th,1,2,3)( gd*(v1*N.x +v2*N.y))   //  int on gamma
 + on(4,u1=g1n,u2=g2n);

 laplaceMixte;
 plot([u1,u2],coef=0.1,wait=1,ps="o/lapRTuv.eps",value=true);
 plot(p,fill=1,wait=1,ps="o/laRTp.eps",value=true);  
load "Element_P4dc"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro DD2(f,hx,hy) ( (-2*f(x1,y1)+f(x1+hx,y1+hy)+f(x1-hx,y1-hy))/(square(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-4;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P4dc);
fespace Eh(Th,P0edge);

Eh  edges;

Vh a1,b1,c1;
 
varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1) << " == " << DD2(a1,h,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1) << " == " << DD2(a1,0,h)  << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1)-DD2(a1,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1)-DD2(a1,0,h) ) < 1e-4);



} 

load "distance"
mesh Th=square(10,10);
Th=adaptmesh(Th,0.03,IsMetric=1);
fespace Vh(Th,P1);
varf vong(u,v)= on(1,u=1);
real[int] ong=vong(0,Vh);
Vh u =1,v, e=y;
u[] = ong ? 0 : u[]; 
//plot(u,wait=1);
//verbosity = 10000; 
//savemesh(Th,"Th.msh"); 
distance(Th,u,v[]);
//for (int i=0;i<v[].n; ++i)
// cout << i << " " << v[][i] << " "<< e[][i] <<  endl;  
e = v-y;
cout << "err = "<< e[].linfty << endl; 
plot(e, wait=1);
assert( e[].linfty < 1e-5);// not really exact F. Hecht but small 
load "Element_P3"
load "UMFPACK64"

//defaulttoUMFPACK64();
verbosity=10;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh,solver="UMFPACK64") =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

verbosity=5;
  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "Element_P3"
load "msh3"
{
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro DD2(f,hx,hy) ( (-2*f(x1,y1)+f(x1+hx,y1+hy)+f(x1-hx,y1-hy))/(square(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-4;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P3);
fespace Eh(Th,P0edge);

Eh  edges;

Vh a1,b1,c1;
 
varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].max < 1e-5 && c1[].min > -1e-9);

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1) << " == " << DD2(a1,h,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1) << " == " << DD2(a1,0,h)  << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1)-DD2(a1,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1)-DD2(a1,0,h) ) < 1e-4);



} 
}
{
	meshL Th=segment(1);
	fespace Vh(Th,P3L);
	fespace Wh(Th,P3dcL);
	func f = 1; //3*x^3+2*x^2+x + 1;
	Vh u = f;
	Wh fd = f;
	Vh v=0;
	v[][0] = 1.; 
	real err = sqrt(int1d(Th)( sqr(f-u)));
	cout << "err L " << err << endl;
	for(int i=0; i<= 9;++i)
	{
		x = i/9.;
		cout << x << " "<< u << " " << f << " " << fd << " " << v << endl; 
	}
	
	
 assert(err < 1e-6);	
	
}
{
	meshS Th=square3(10,10);
	fespace Vh(Th,P3S);
	func f = 3*x^3+2*x^2+x + 1+x*y+y^3;
	Vh u = f;
	Vh v=0;
	v[][0] = 1.; 
	real err = sqrt(int1d(Th)( sqr(f-u)));
	cout << "err L " << err << endl;
	
	
 assert(err < 1e-6);	
	
}
{ // P3HL
       real L = 1;
	meshL Th=segment(1,[x*L,0,0]);
	fespace Vh(Th,P3HL);
	fespace Wh(Th,P3L);
	fespace Whdc(Th,P3dcL);
	func f = 3*(x^3) +2*(x^2)+x + 1;
	func fxx = 18*x+4. ;//+ 4.;
	Wh fh = f;
	cout << " 0 = "<< f(0,0) << " " << dx(fh)(0,0) << " "<< dxx(fh)(0,0) <<" "<< fxx(0,0) << endl; 
	cout << " L = "<< f(L,0) << " " << dx(fh)(L,0) << " " << dxx(fh)(L,0) <<" "<< fxx(L,0) << endl; 
	
	Vh [u,ux] = [f,dx(fh)];
	cout << " u[]"<< u[] << endl; 
	Vh [v,vx]; v[]=0;
	// function de base OK ...
	// interpolation ok ...
	real err = 0; 
	for(int i=0; i<4;++i)
	{ 
	v[]=0;
	v[][Vh(0,i)] = 1.; 
	Wh vv=v,dvv=dx(vv);
	cout << i << " " << Vh(0,i) << " " << dxx(vv)(0,0,0) << " " <<  dxx(vv)(L,0,0) << " " << dxx(dvv)(L/2,0,0)  <<endl;
	cout << "    v 0: "<< v(0,0,0) << " " << vx(0,0,0) << endl; 
	cout << "    v 1: "<< v(L,0,0) << " " << vx(L,0,0) << endl; 
	cout << "    dx(v) 0: "<< dx(v)(0,0,0) << " " << dx(vx)(0,0,0) << endl; 
	cout << "    dx(v) 1: "<< dx(v)(L,0,0) << " " << dx(vx)(L,0,0) << endl; 
	cout << "    dxx(v) 0: "<< dxx(v)(0,0,0) << " " << dxx(vx)(0,0,0) << endl; 
	cout << "    dxx(v) 1: "<< dxx(v)(L,0,0) << " " << dxx(vx)(L,0,0) << endl; 

	Vh [w,wx]=[v,vx]; 
	v[] -= w[]; 
	err += v[].linfty ;
	cout << " w[]"<< w[] <<" err " << err <<  endl; 
        }
        err+= sqrt(int1d(Th)( sqr(f-u)));
	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(dx(fh)-dx(u))));
	 cout << "err L " << err << endl;	
         err+= sqrt(int1d(Th)( sqr(dx(fh)-ux)));
 	 cout << "err L " << err << endl;	
        err+= sqrt(int1d(Th)( sqr(fxx-dxx(u))));
	//Whdc d=dxx(fh)-dxx(u);
	//cout << d[] << endl;
        cout << "err L " << err << endl;	
	
	
      {  // BiLap 1d ..
	      real cc = 16.;
	      func ue = cc*(1-x)*(1-x)*x*x;
	      func fe = cc*24.0;
	      int nn=50;
	      Th = segment(nn);
	      meshL Thg=segment(nn*40);
	      fespace Ph(Thg,P1);
	      Vh  [u,ux] ,  [v,vx] ;
	      solve BiLap([u,ux],[v,vx]) = int1d(Th)(dx(ux)*dx(vx))- int1d(Th)(fe*v)+on(1,2,u=0,ux=0);
	      Ph U=u, X=x,Ux=ux, F=ue;
	      //cout << U[] << endl;
	      plot([X[],U[]],[X[],F[]],wait=1);
	      err += sqrt(int1d(Th)(sqr(ue-u)));;
	      cout << " err = " << err << endl; 
      }	
 assert(err < 1e-6);	
	
}

load "scotch"
load "metis"
border C(t=0, 2*pi){ x=cos(t); y=sin(t); }
mesh Th = buildmesh(C(1000)); // first mesh: a simple circle
int lpart = 10; // how many clusters must be created ?
fespace Ph(Th, P0); // using P0 FE to store the partition
int[int] nupart(Th.nt); // the actual partition
Ph part = nuTriangle; // number of each triangles in the mesh
int[int] weight(Th.nt); // array of integers to store weights
for(int i = 0; i < Th.nt;++i)
    weight[i] = Th[i][1].x > 0. && Th[i][1].y > 0. ? 10 : 1; // if we want to partition has much as possible the region x > 0 && y > 0
plot(Th, part, value = 1, fill = 1, wait = 1, cmm = "original");
scotch(nupart, Th, lpart, weight = weight); // with weight
Ph balance;
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH with weights");
scotch(nupart, Th, lpart); // without weight
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH");
metisdual(nupart, Th, lpart);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "Metis");
Th = square(400, 400); // second mesh: a simple square
balance = 0;
part = nuTriangle;
weight.resize(Th.nt);
nupart.resize(Th.nt);
for(int i = 0; i < Th.nt;++i)
    weight[i] = Th[i][1].x > 0.5 && Th[i][1].y > 0.5 ? 100 : 1; // if we want to partition has much as possible the region x > 0.5 && y > 0.5
plot(Th, part, value = 1, fill = 1, wait = 1, cmm = "original");
scotch(nupart, Th, lpart, weight = weight);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH with weights");
scotch(nupart, Th, lpart);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "SCOTCH");
metisdual(nupart, Th, lpart);
for(int i = 0; i < Th.nt; ++i)
    balance[][i] = nupart[i];
plot(Th, balance, value = 1, fill = 1, wait = 1, cmm = "Metis");
load "Element_P2pnc_3d"
load "msh3"
load "tetgen"
load "medit"
int err=0;
int cas1=0;  //0 need Th1.mesh ... 
macro DoFi(d,u,vf,p) ((d==12) ? int3d(Th)((u)/volume) : int2d(Th,d/3,qforder=6)((u)*l[vf(d/3,p[d]%3)]/area)) //
macro DoFih(d,u) ((d==12) ? int3d(Th)((u)/volume) : int2d(Th,d/3,qforder=6)((u)*l[vf(d/3,d%3)]/area)) //
macro ErrH1(Th,u,v) sqrt(int3d(Th)( square(dx(u)-dx(v))+square(dy(u)-dy(v))+square(dz(u)-dz(v)) )) //
macro ErrL2(Th,u,v) sqrt(int3d(Th)( square((u)-(v)) )) //
func real clean(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
func real clean(real[int] &aa) {
	for [i,ai:aa] ai=clean(ai);
	return 0; }
func real clean(real[int,int] &aa) {
		for [i,j,ai:aa] ai=clean(ai);
		return 0; }
func bool PrintCC(string str,real[int,int] &A)
		{
			int n= A.n,m=A.m;
			cout <<"\n\n   double "<<  str << "["<< n <<"][" << m <<"] = {\n";
			for( int i=0; i< n;++i)
			{ cout << "\t {";
			  for( int j=0; j< m;++j)
			  {
			  cout << clean(A(i,j)) ;
			  if( j != m-1) cout <<", ";
		          }
			  if( i != n-1) cout << "},\n ";
			  else  cout << "}};\n\n ";
			  if(i%3==2) cout << endl;
		        }
			return 1; 
		}	
// construction des coef fonction des bases
// matrice 13x13 ... 
// les monomes faire ...
int[int,int] vf= [[3,2,1],[0,2,3],[ 3,1,0],[ 0,1,2]];  // FreeFem face Tet numbering ...
//int[int,int] vf= [[1,2,3],[0,2,3],[ 0,1,3],[ 0,1,2]];
int[int] p(13),p1(13) ;// p() = i ,  dof dans ^K et i: dof dans K 
int[int] q(12),Kq(12); 
// p[i] : p[i]/3 == nF numero de la face p[i]%3 numero du sommet de face dans K et telle p[i] %3 croissante pour un nF. 
// cf. construction de p,p1 
int[int] id(13); 
for(int i=0;i<13;++i) id[i] = i;
func int  print(string cmm,int[int] & p)
{
	cout << cmm;
	for [i,pi:p] {if(i%3==0) cout << " "; cout << " "<< pi ;}
	cout<< endl;
	return p.n;
}

func int buildp(mesh3 & Th,int k, int[int] & p,int[int,int]&  vf)
{
	int [int] I=[Th[k][0],Th[k][1],Th[k][2],Th[k][3]];// le 4 sommet du tet k.
	int [int] II=[0,1,2,3];
	// cout << I << " " << II << endl; 
	int err =0;
	for(int f=0; f<4;++f)
	{ 
		int k = 3*f;
	  //  build the correct order
	  // sort i_j j=0,1,2  I[i_j] croissnate
	  int[int] F=vf(f,:); 
	  int i0=0,i1=1,i2=2;
	  if( I[vf(f,i0)] >I[vf(f,i2)] )  swap(i0,i2);
	  if( I[vf(f,i1)] >I[vf(f,i2)] )  swap(i1,i2);
	  if( I[vf(f,i0)] >I[vf(f,i1)] )  swap(i0,i1);
	  p[k+0]=k+i0;
	  p[k+1]=k+i1;
	  p[k+2]=k+i2;
	//  cout <<i0 << i1 << i2 << " " <<  I[F[i0]] << I[F[i1]] << I[F[i2]] << endl;
	  assert(I[F[i0]] < I[F[i1]]);
	  assert(I[F[i1]] < I[F[i2]]);
       }
        for(int i=0;i<12;++i)
	 q[i] = vf(i/3,p[i]%3); // numero de sommet local des faces 
	for(int i=0;i<12;++i)
	  Kq[i]= I[q[i]]; // numero global de sommet local des faces
	  p[12]=12; 
	  for(int i=0;i<13;++i) p1[p[i]] = i;
  print(" p = ",p);
  print(" q = ",q );
  print("Kq = ",Kq );
  
   return err;	
}
func int verifp(mesh3 & Th,int k, int[int] & p,int[int,int]&  vf)
{
	cout << p << " " << vf << endl;
	int err =0;
	for(int f=0; f<4;++f)
	{
	   err += ((vf(f,0)+vf(f,1)+vf(f,2))!= (0+1+2+3-f));		
	for( int i=0; i<2; ++i)
	{  int i1 = p[3*f+i]%3;// in [0,1,2]
	   int i2 = p[3*f+i+1]%3;	   
	   int n1 = Th[k][vf(f,i1)];
	   int n2 = Th[k][vf(f,i2)];
	   cout << err << " f "  << f << " " << i << " : " << i1 << " " << i2 << "::  " << n1 << " " << n2 << " " << (vf(f,0)+vf(f,1)+vf(f,2)) << " err = " ;	   
	   err += (n2 <= n1);	
	   cout << err << endl; 
	}}
	if(err) cout << err << "\n p = "<< p << "\n vf= " << vf << endl;
   assert(err==0);
   return err;	
}
load "Element_P3dc"
load "Element_P4dc"
load "Element_P2pnc"

real[int] xx=[0,1,0,0], yy=[0,0,1,0], zz=[0,0,0,1]; 
mesh3 Th=tetgconvexhull(xx,yy,zz,region=1,label=3);
savemesh(Th,"/tmp/Th.mesh");

assert(Th.nbe==4);
int [int] plab=[0,2,3,1];
for(int f=0; f<Th.nbe;++f)
{
  int k = 1+2+3-Th.be(f)[0]-Th.be(f)[1]-Th.be(f)[2];
//  cout << f << " " << k << " ::: ";
  plab[Th[0][f]]=k;
  for(int l=0; l<3;++l)	
      cout << " " <<  Th.be(f)[l] << " ";   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
      cout << endl;
	
}
Th=change(Th,flabel=plab[nuFace]);
savemesh(Th,"/tmp/Th2.mesh");
buildp(Th,0,p,vf);
verifp(Th,0,p,vf);


if(cas1) {
	cout << " cas1 "<< "Th1.mesh"<<endl;
mesh3 Th1("Th1.mesh");Th=Th1;
buildp(Th,0,p,vf);
verifp(Th,0,p,vf);

}
fespace Lh(Th,P1);
Lh[int] l(4); // 4 fonctions de Base du P1 .. sur l'element 0
{
	int 	i0 = Lh(0,0); 
	int 	i1 = Lh(0,1); 
	int 	i2 = Lh(0,2); 
	int 	i3 = Lh(0,3); 
l[0][][i0]=1;
l[1][][i1]=1;
l[2][][i2]=1;
l[3][][i3]=1;
}
// verif face
for(int f=0; f<Th.nbe;++f)
{
 err += (abs(int2d(Th,f)(l[f]))>0 );
 cout << f << " err " << err << endl;
}
 assert(err==0);

fespace Wh(Th,P3dc3d); 

Wh[int] mo(13),fb(13);
// le 13 monome to build Base FE function. 
{
  int k=0;
  for(int i=0;i<4;i++)
    mo[k++]=l[i];
   for(int i=0;i<4;i++)
    for(int j=0;j<i;j++)
     mo[k++] = l[i]*l[j];
     cout << k << endl;
    mo[k++] = l[1]*l[2]^2;
    mo[k++] = l[0]*l[2]^2;
    mo[k++] = l[0]*l[1]^2;
    assert(k==13); 
}
// dof computation ...
real[int,int] CC(13,13),C1(13,13),Cc(13,13);


for(int i=0; i<13;++i)
for(int d=0; d<13;++d)
   CC(i,d) = clean(DoFih(d,mo[i]));
   Cc =CC * (130 *6*3);
if(verbosity>9)  cout << " CC = " << Cc << endl;

load "lapack"
verbosity=9;
C1=CC^-1; 
verbosity=1;
clean(C1); 
//cout << C1 << endl; 
// Build Base Func  !!! 
cout << " Test F b formel  p(^i)=i :: " << endl;
 err=0; 
for(int i=0; i<13;++i)
{
	real dij; 
	fb[i][]=0;
	for(int j=0; j<13;++j)
	  fb[i][] += C1(p[i],j)*mo[j][];
	cout << i << " : " ;
	for(int j=0; j<13;++j)
	{
	  cout <<(dij=clean(DoFi(j,fb[i],vf,p))) << " , ";
	  err +=  abs(dij- (i==j)) > 1e-10;
        }
	cout << endl; 	
} 
assert(err==0);

cout << " cas: "<< cas1 <<endl; 
print("p=",p);
PrintCC("C1",C1);  // for C++


// fonction de base 
// CC(i,j) = dof(j)(mo(i)); // 
//  les fonction de base
//fb_k = sum_i c1(k,i)* mo(i)  
// dof(j)fB_k = delta_jk  = sum_i c1(k,i) dof(j) mo(i)  = sum_i c1(k,i) CC(i,j) 
// => Id = c1*CC => c1 = CC^-1 
fespace Vh(Th,P2pnc3d);
cout << " Vh" << Vh.ndof <<  " : "  ;
for( int i=0; i< 13; ++i)
cout << Vh(0,i) << " ";
cout << endl;
Vh f=l[0],g;
cout << " f : " << f[] << endl; 
real f000 = f(0,0,0);
real f100 = f(1,0,0);
real f010 = f(0,1,0);
real f001 = f(0,0,1);
cout << " f (0,0,0) = "<< f000  <<" " << f100 << " "<< f010 << " "<< f001 << " "<< dx(f)(0.25,0.25,0.25) << endl; 

cout << " dof f  : ";
for(int i=0; i<13;++i)
	cout << DoFi(i,f,vf,p) << " ";
cout << "\n\n Verif Interpolant : dof fb  : \n";
	for(int ii=0; ii<13;++ii)
	{
		int i=Vh(0,ii);
		f = fb[i]; 
		cout << i << " :::: " ;
		real dij;
		for(int d=0; d<13;++d)
		{
	         cout << (dij=clean(f[][d]))  <<  ",";
		 err += abs( dij - (d==i) ) > 1e-10; 
	        }
	 Wh ff =f;
	 real dd = ErrH1(Th,f,ff);
	 cout << " dd "<< dd << " "  << ErrL2(Th,dx(f),dx(ff)) << " " << ErrL2(Th,dy(f),dy(ff)) << " " << ErrL2(Th,dz(f),dz(ff)) <<  endl; ;

	 err += (dd> 1e-10); 
	 cout <<endl ;
	}
	
cout <<endl <<  endl;
verbosity=101;
fespace VVh(Th,[P2pnc3d,P2pnc3d]);
verbosity=1;
VVh [u,v]=[1,2];

//assert(err==0) ;
int errinter=err; 
if(errinter==0)
cout << " Interpolant Ok !"<< endl; 

err=0; 
cout << " Test fb C++  with dofi:"<< endl; 
for(int ii=0; ii<13;++ii)
{ // Attention les fonction de base sont avec la permution !!!  non 
	int i = Vh(0,ii);
	cout << i << " i : " ;
	f[]=0.;
	f[][i]=1.;
	real dij;
	for(int d=0; d<13;++d)
	{
	  cout << (dij= clean(DoFi(d,f,vf,p))) <<  ",";
	  err += abs( dij - (d==i) ) > 1e-10; 
        }
       cout << endl; 
}
cout << endl; cout << endl;
if(err==0)
cout << " Fonction de Base OK !!! nb err = " << err << endl;
else 
cout << " PB Fonction de Base!!! nb err = " << err << endl;

if(errinter==0)
cout << " Interpolant Ok !"<< endl; 
else 
cout << " PB Interpolant nb err = " << errinter << endl;

assert(err==0); 

cout << " verification  compatibility  interpolant and  basic function! "<< endl; 
 err =0; 

for(int i=0; i<13;++i)
{
	cout << i << " g i : ";
	f[]=0.;
	f[][i]=1.;
	g = f;	
	for[ j,gi:g[]] cout << clean(gi) << " ";
	g[]-=f[];
	err += g[].linfty > 1e-10; // if no zeo => bug ...
	cout << endl; 

}
cout << " nb err = " << err << endl;
// 
assert(err==0 && errinter==0);  
{
Th= cube(3,2,1,[x*2,y*3+x,z*5]); //trunc(trunc(cube(1,1,1),x<0.5),nuTet<2);
//Th= trunc(Th,nuTet<1);
Vh u=0,v,w;

for(int k=0;k<Th.nt;++k)
{
	for(int i=0;i<4;++i)
	cout << k << ": " << Th[k][i] <<  " ";
	cout << endl;
	for(int i=0;i<13;++i)
	cout << Vh(k,i) << " ";
	cout << endl;
}

for(int i=0; i<Vh.ndof;++i)
{
	u[]=0;u[][i]=1;
	v=u;
	clean(v[]); 
	w[]=u[];
	w[]-=v[];
	real lerr= w[].linfty;
	if(lerr>1e-10 &&0) {
 		cout << " kkk err = "<< endl;
		for(int d=0; d<Vh.ndof;++d)
		if( abs(w[][d]) > 0.1 ) cout <<  d << " " << w[][d] << " , ";
		cout << endl << endl; 
		verbosity=9;
		v=u;
		verbosity=1;
		clean(v[]); 
		cout << i << " " << v[] << endl; 
		
		plot(u,cmm="u i "+i+" "+lerr,wait=1) ;
		plot(v,cmm="v i "+i+" "+lerr,wait=1) ;
	cout << i << " " << lerr << " " << err << endl;	
	assert(lerr>1e-10);;
	err++;
	
	
}
    
	
}
assert(err==0);
}



// PARAM -cd -ns
load "pipe"

// example for with pipe
string persist=" -persist";
persist="";
string sgnuplot ="gnuplot"+persist;
string sls ="ls -l";
if (onWIN32)
{ // windows command ...
	sls="dir";
	sgnuplot= "\"C:\\Program Files (x86)\\gnuplot\\bin\\pgnuplot.exe\""+persist;
}

if(1) {// input case ..
	pstream  ls(sls,"r");

	while (!ls.eof)
	{
		string file;
		getline(ls,file);
		cout <<  file << endl;
	}
}
cout << "pipe on " << sgnuplot << endl;
pstream  f(sgnuplot,"w");
try {
	f << "set terminal png" << endl;
	f << "set output \"pipe.png\"" << endl;
	for(int i=0;i<100; i++)
	{
		cout << "plot sin(x+" + (i*.01) + ") w l;" << endl;
		f  << "plot sin(x+" + (i*.01) + ") w l;" << endl;
	}
	f << "pause 2"<<endl;
}
catch (...)
	{cout << " catch  error ??? "<< endl;}
load "msh3"
load "tetgen"

// Parameters
int C1 = 99, C2 = 98; // Boundary labels, could be anything

// Mesh
border C01(t=0, pi){x=t; y=0; label=1;}
border C02(t=0, 2*pi){x=pi; y=t; label=1;}
border C03(t=0, pi){x=pi-t; y=2*pi; label=1;}
border C04(t=0, 2*pi){x=0; y=2*pi-t; label=1;}

border C11(t=0, 0.7){x=0.5+t; y=2.5; label=C1;}
border C12(t=0, 2){x=1.2; y=2.5+t; label=C1;}
border C13(t=0, 0.7){x=1.2-t; y=4.5; label=C1;}
border C14(t=0, 2){x=0.5; y=4.5-t; label=C1;}

border C21(t=0, 0.7){x=2.3+t; y=2.5; label=C2;}
border C22(t=0, 2){x=3; y=2.5+t; label=C2;}
border C23(t=0, 0.7){x=3-t; y=4.5; label=C2;}
border C24(t=0, 2){x=2.3; y=4.5-t; label=C2;}

mesh Th = buildmesh(
	  C01(10) + C02(10) + C03(10) + C04(10)
	+ C11(5) + C12(5) + C13(5) + C14(5)
	+ C21(-5) + C22(-5) + C23(-5) + C24(-5)
	);

mesh Ths = buildmesh(
	  C01(10) + C02(10) + C03(10) + C04(10)
	+ C11(5) + C12(5) + C13(5) + C14(5)
	);

plot(Th, cmm="Th");
plot(Ths, cmm="Ths");

// Construction of a box with one hole and two regions
func zmin = 0.;
func zmax = 1.;
int MaxLayer = 10;

int[int] r1 = [0, 41];
int[int] r2 = [98, 98, 99, 99, 1, 56];
int[int] r3 = [4, 12];	// The triangles of upper surface generated by the triangle in the 2D region of mesh Th of label 4 as label 12
int[int] r4 = [4, 45];	// The triangles of lower surface generated by the triangle in the 2D region of mesh Th of label 4 as label 45

mesh3 Th3 = buildlayers(Th, MaxLayer, zbound=[zmin, zmax], region=r1,
	labelmid=r2, labelup=r3, labeldown=r4);
savemesh(Th3, "box2region1hole.mesh");
plot(Th3, cmm="Th3");

// Construction of a sphere with tetgen 
func XX1 = cos(y)*sin(x);
func YY1 = sin(y)*sin(x);
func ZZ1 = cos(x);

real [int] domain = [0., 0., 0., 0, 0.001];
string test = "paACQ";
cout << "test=" << test << endl;
mesh3 Th3sph = tetgtransfo(Ths, transfo=[XX1, YY1, ZZ1], switch=test,
	nbofregions=1, regionlist=domain);
savemesh(Th3sph,"sphere2region.mesh");
plot(Th3sph, cmm="Th3sph");

load "splitmesh3"
mesh Th=square(5,5);
mesh Th3=splitmesh3(Th);
plot(Th3,wait=1);
load "Element_Mixte"
/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$

*/
mesh Th=square(10,10);
fespace Vh(Th,RT2);
fespace Ph(Th,P2dc);

func gd = 1.;
func g1n = 1.;
func g2n = 1.;
func f = 1.;

Vh [u1,u2],[v1,v2];
Ph p,q;

problem laplaceMixte([u1,u2,p],[v1,v2,q],solver="SPARSESOLVER") =
   int2d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + p*(dx(v1)+dy(v2)) + (dx(u1)+dy(u2))*q )
 + int2d(Th) ( f*q)
 - int1d(Th,1,2,3)( gd*(v1*N.x +v2*N.y))   //  int on gamma
 + on(4,u1=g1n,u2=g2n);

 laplaceMixte;
 plot([u1,u2],coef=0.1,wait=1,ps="o/lapRTuv.eps",value=true);
 plot(p,fill=1,wait=1,ps="o/laRTp.eps",value=true);  
if (HaveUMFPACK) //  to heavy computation if not 
{
load "BernardiRaugel"

real s0=clock();

// Parameters
real reylnods = 400.;
func g = (x)*(1-x)*4;
real nu = 1;
real dt = 0.1;
real penalty = 1.e-6;
int nbiter = 3;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter);
real cut = 0.01;
real tol = 0.3;
real coeftol = 0.25^(1./nbiter);

// Mesh
mesh Th = square(2, 2);

// Fespace
fespace Vh2(Th, P2BR);
fespace Vh(Th, P0);
fespace Wh(Th, [P2BR, P0]);
Wh [u1, u2, p], [v1, v2, q], [up1, up2, pp];

// Macro
macro div(u1, u2) (dx(u1) + dy(u2)) //

// Problem
real alpha = 0;
int i = 0;

varf NS ([u1, u2, p], [v1, v2, q], init=i)
	= int2d(Th)(
		  alpha*(u1*v1 + u2*v2)
		+ nu*(
			  dx(u1)*dx(v1)
			+ dy(u1)*dy(v1)
			+ dx(u2)*dx(v2)
			+ dy(u2)*dy(v2)
		)
		- penalty * p*q
		- p*div(v1, v2)
		- div(u1, u2)*q
	)
	- int2d(Th)(
		- alpha*convect([up1, up2], -dt, up1)*v1
		- alpha*convect([up1, up2], -dt, up2)*v2
	)
	+ on(3, u1=g, u2=0)
	+ on(1, 2, 4, u1=0, u2=0)
	;

// Initialization
[up1, up2, pp] = [0., 0., 0.];

// Solve (Stokes)
matrix A = NS(Wh, Wh, solver="SPARSESOLVER");
real[int] b = NS(0, Wh);
u1[] = A^-1 * b;

// Plot
plot([u1,u2], p, coef=0.2, cmm="[u1, u2] and p", value=true, wait=true);

// Convergence loop
int iter = 0;
nu = 1./reylnods;
for (iter = 1; iter <= nbiter; iter++){
	cout << "dt = " << dt << endl;
	alpha = 1./dt;
	
	A = NS(Wh, Wh, solver="SPARSESOLVER");
	
	// Time loop
	for (i = 0; i <= 10; i++){
		// Update
		up1[] = u1[];
		real[int] b = NS(0, Wh);
		
		// Solve
		u1[] = A^-1 * b;
		
		// Plot
		if (!(i % 10))
			plot([u1,u2], p, coef=0.2, cmm="[u1,u2] and p");
		
		// Display
		cout << "CPU " << clock()-s0 << "s " << endl;
	} 
	
	if (iter >= nbiter) break;
	
	// Mesh adaptation
	Th = adaptmesh(Th, [u1, u2], iso=0, abserror=0, cutoff=cut, err=tol, inquire=0, ratio=1.5, hmin=1./1000);
	plot(Th);
	
	// Update
	dt = dt*coefdt;
	tol = tol *coeftol;
	cut = cut *coefcut;
	
	// Re-interpolation
	[u1, u2, p] = [u1, u2, p];
	[up1, up2, pp] = [u1, u2, p];
}

// Display
cout << "CPU " << clock()-s0 << "s " << endl;
}



load "funcTemplate"
 
mesh Th=square(3,3);
fespace Vh(Th,P1);

Vh N;
for(int i=0; i<N.n; i++) {
 N[][i] = i+0.1;
}

Vh P = 2.0;
Vh uh1;
real a;

// OUTPUT:
//    uh1[]
// INPUT:
//    N[]
//    P[]
// Description:
//  make the product N[] .* P[]
//
CppModTemplate3(uh1[], N[], P[]);
cout << endl;
cout << "uh1: " << uh1[].min  << " " << uh1[].max << endl;


CppModTemplate4(uh1[], N[], P[], P[]);
cout << endl;
cout << "uh1: " << uh1[].min  << " " << uh1[].max << endl;

CppModTemplate5(uh1[], N[], P[], P[], P[]);
cout << endl;
cout << "5 args: uh1: " << uh1[].min  << " " << uh1[].max << endl;

CppModTemplate6(uh1[], N[], P[], P[], P[], P[]);
cout << endl;
cout << "6 args: uh1: " << uh1[].min  << " " << uh1[].max << endl;                                                                                                                                           
                                                                                                                                           
CppModTemplate7(uh1[], N[], P[], P[], P[], P[], P[]);
cout << endl;
cout << "7 args: uh1: " << uh1[].min  << " " << uh1[].max << endl; 


CppModTemplate8(uh1[], N[], P[], P[], P[], P[], P[], P[]);
cout << endl;
cout << "8 args: uh1: " << uh1[].min  << " " << uh1[].max << endl; 
cout << " funcs1 " << funcs1(2) << endl;
cout << " funcs2 " << funcs2(2,3) << endl;
cout << " funcs3 " << funcs3(1,2,3) << endl;



Vh[int] U(10); // Array of finite element function 
for(int i=0; i<10; ++i)
  U[i]= i; 
//  plot(U,wait=1);	
cout << "test = "<< test(U) << endl; 
// Stokes Quasi static avec tension superficiel
if (HaveUMFPACK) //  need UMPACK  computation 
{
verbosity=0; 
// voir https://fr.wikipedia.org/wiki/Pression_de_Laplace
load "isoline"
load "Curvature"

real X0 = 0.1, Y0 =1*X0,Y1=0, CC0=Y0; 
real meshsize=X0/10;
real CFL = 0.1; 
real dt = 0.005;
int niter = 100;
real Kc =10; 
real rhog = 0; 
real nu=1;
real Vin =1; 
int nlissage=2;
real X02=X0*X0; 
func u2in=(-1+x*x/X02)*Vin;
real fluxin;
border ctop(t=X0,0){x=t; y=Y0;label=1;};
border cleft(t=Y0,Y1){x=0; y=t;label=3;};
border cright(t=0,Y0){x=X0; y=t;label=0;}
int nsl=100; 
real[int,int] SL(3,nsl) ;
for(int i=0; i< nsl; ++i)
  { 
    real ll = i/(nsl-1.); 
    SL(0,i) = 0*(1-ll)+X0*ll;
    real l0=ll;
    real RR=1.2*1.2, YY=sqrt(RR-1);
    SL(1,i) = -CC0*(sqrt(RR-l0*l0)-YY);
    SL(2,i) = ll; 
  }
real lgc = setcurveabcisse(SL); 
 {  nsl = lgc/meshsize; 
   real[int,int] SL1=equiparameter(SL,nsl); 
   SL.resize(SL1.n,SL1.m);
   SL = SL1;  
 }
border bSL(t=0,1) 
{
    P= Curve(SL,t); 
    label=2; 
} 
Y1= SL(1,0);  
int nn = 20;
func cfix = ctop(X0/meshsize)+cleft(Y0/meshsize)+cright(Y0/meshsize); 
plot( cfix+ bSL(lgc/meshsize) , wait=1); 
func Bmesh = buildmesh( cfix+ bSL(lgc/meshsize) );
mesh Th= Bmesh;

plot(Th, wait=1);
// Formule (2.9) of  http://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch02.d/AFEM.Ch02.pdf 
//  macro Eps(u,v) [ dx(u),dy(v), (dx(v)+dy(u))*0.5, (dx(v)+dy(u))*0.5 ] // 
// here r==x, z==y
macro Eps(u1,u2)  [dx(u1),dy(u2),u1/x, (dx(u2)+dy(u1))*0.5,(dx(u1)+dy(u2))*.5 ] // EOM

macro Grad(u,v) [ dx(u),dy(v), dx(v), dy(u) ] // 
macro div(u1,u2) (dx(u1)+dy(u2) ) // 
macro rdiv(ur,uy) (x*dx(ur) + ur + x*dy(uy)) //

func mN = [ N.x,N.y]*[ N.x,N.y]'; 
func mT = [ N.y,-N.x]*[ N.y,-N.x]'; 
real bN = 1e6, bT = 1e6, bT1 =1e6; // Coef de 
real bT0 = 1; // frottement a la paroi

fespace Mh(Th,P1);
fespace Wh(Th,P2);
Mh rfcourbure;

rfcourbure[]=0;
int[int] llc=[2];
//plot(frcourbure,wait=1,fill=1); 
//real fcourbure =1;
fespace Vh(Th,[P2,P2,P1]); 
Vh [u1,u2,p],[v1,v2,q];
Wh U;
real temps =0; 
for(int iter=0; iter<niter;++iter)
{
    rfcourbure=0;
    rfcourbure[]=raxicurvature(Th,2);
    u1[]=0;
solve PMeca2( [u1,u2,p],[v1,v2,q] ) =
int2d(Th) ( x*2*nu*Eps(u1,u2)'*Eps(v1,v2) - rdiv(v1,v2)*p -rdiv(u1,u2)*q)
 + on(1,u1=0,u2=u2in)
 + on(0,u1=0,u2=0)
 + on(3,u1=0)
 + int1d(Th,2) ( Kc*rfcourbure*[N.x,N.y]'*[v1,v2]) 
 - int2d(Th)( -x*rhog*v2)
;
//plot(rfcourbure,WindowIndex=1);
fluxin = int1d(Th,1)(-u2);

real[int,int] UU(2,nsl);
real Umax=0;
for(int i=0; i<nsl-1;++i)
  {
    x= SL(0,i);
    y= SL(1,i); 
    real Tx=1,Ty=0;
    if(i>0)
    {
    Tx=SL(0,i+1)-SL(0,i-1);
    Ty=SL(1,i+1)-SL(1,i-1);
    }
    
    real ll = sqrt(Tx*Tx+Ty*Ty); 
    real Nx = -Ty/ll;
    real Ny =  Tx/ll;
    real cN= Nx*u1+Ny*u2;
    UU(0,i)=cN*Nx;
    UU(1,i)=cN*Ny;
    Umax=max(Umax,abs(cN)); 
  }
  //  lissage de UU
  real bb= 0.9, aa = (1-bb)/2.; 
  for(int j=0; j<nlissage;++j)
  for(int i=1; i<nsl-2;++i)
    { 
        UU(0,i) = aa*UU(0,i-1)+bb*UU(0,i)+aa*UU(0,i+1);
        UU(1,i) = aa*UU(1,i-1)+bb*UU(1,i)+aa*UU(1,i+1);
    }

  dt = meshsize*CFL/Umax;
  real Vadd = fluxin*dt;
  real volUU=0;
  
  cout << "nsl =" << nsl << " "<<UU.n << " " << UU.m << " " << SL.m << endl; 
  UU(0,nsl-1)=0;
  UU(1,nsl-1)=0;
  for(int i=0; i<nsl-1;++i)
   { 
     SL(0,i) += dt*UU(0,i);
     SL(1,i) += dt*UU(1,i);
   }
temps += dt;

 cout << iter << temps << " " << " dt = " << dt << " " << Umax << endl; 
lgc = setcurveabcisse(SL); 
if( iter% 10 ==9) 
{
   nsl = lgc/meshsize; 
   cout << "nsl =" << nsl << endl; 
   real[int,int] SL1=equiparameter(SL,nsl); 
   SL.resize(SL1.n,SL1.m);
   SL = SL1;  
   if(verbosity>2) 
   for(int i=1; i<nsl-1;++i)
     cout << i << " " << SL(0,i) << " " << SL(1,i) << " " <<  SL(2,i)  <<endl; 
}
plot([u1,u2],p,bSL(lgc/meshsize),coef=dt,cmm=" temps " + temps+ " / " + dt + " / " +Umax );
 Y1= SL(1,0);
Th= Bmesh;
}
cout << " End loop \n"; 
}
load "SuperLu"

verbosity=0;

{

cout << "laplace solving with SuperLu" << endl;

mesh Th=square(10,10);
fespace Vh(Th,P1);     // P1 FE space
 Vh uh,vh;              // unkown and test function. 
 func f=1;                 //  right hand side function 
 func g=0;                 //  boundary condition function
 
 verbosity= 3;
problem laplace(uh,vh,solver="SUPERLU",tgv=1e5,sym=0) =                    //  definion of  the problem 
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th)( f*vh )                        	     //  linear form
  + on(1,2,3,4,uh=g) ;                      //  bou  ndary condition form

  laplace; // solve the problem plot(uh); // to see the result
 
  plot(uh,value=true); 
   verbosity= 1;
   assert(abs(uh[].max - 0.0730987)< 0.01);
}

// FFCS: need to declare it globally to print out its value for regression tests
complex[int] lastx(4);

for(int i=0;i<3;++i)
{
  if(i==0)  cout << "resolution SuperLU" <<endl; 
  if(i==1)  cout << "resolution GMRES" <<endl;
  if(i==2)  cout << "resolution UMFPACK" <<endl; 
  {
    matrix A = 
      [[ 0,  1,  0, 10],
       [ 0,  0,  2,  0],
       [ 0,  0,  0,  3],
       [ 4,  0,  0,  0]];
    real[int] xx = [ 4,1,2,3], x(4), b(4); // xb(4),bbb(4);
    b=A*xx;
    cout << "b="  << b  << endl;
    cout << "xx=" << xx << endl;
    set(A,solver="SUPERLU",sparams="DiagPivotThresh=0.05,ColPerm=MMD_AT_PLUS_A,Equil=NO"); 
    x = A^-1*b;	
    cout << "x=" << endl; cout << x << endl;	
  }
  
  {
    matrix<complex> A = 
      [[  0, 1i,  0, 10],
       [  0,  0, 2i,  0],
       [  0,  0,  0, 3i],
       [ 4i,  0,  0,  0]];
    complex[int] xx = [ 4i,1i,2i,3i], x(4), b(4);
    b = A*xx;
    cout << "b="  << b << endl;
    cout << "xx=" << xx << endl;
    set(A,solver=sparsesolver);
    x = A^-1*b;
    cout << "x=" << endl; cout << x << endl;
    lastx=x;
  }
  if(i==0) DefaultSolver="GMRES";
  if(i==1) DefaultSolver="UMFPACK";
}
cout << " fin.. \n";




load "Element_Mixte"

mesh Th=square(2,2);

fespace Vh(Th,RT0dc);

Vh [u1,u2];
Vh [v1,v2];
int nerr=0; 
for (int i=0;i<Vh.ndof;++i)
{
	u1[]=0;
	u1[][i]=i;
	[v1,v2]=[u1,u2];
	plot([u1,u2],wait=1,cmm=" dof "+i);
	real[int] d=u1[]-v1[]; 
	real err= d.linfty ;
	if (err > 1e-10)
	{
		nerr++;
		cout << " bug dof"<< i << " "<< v1[] << endl; 
	}
	
}
assert(nerr==0); 
/* solves the 3D Helmholtz equation with finite-differences using the
   27-point stencil from Operto, S., Virieux, J., Amestoy, P., LExcellent,
   J. Y., Giraud, L., & Ali, H. B. H. (2007). 3D finite-difference
   frequency-domain modeling of visco-acoustic wave propagation using a 
   massively parallel direct solver: A feasibility study.
   Geophysics, 72(5), SM195-SM211. */

// for the make check:
// PARAM -nppwl 4 -npml 4

load "Helmholtz_FD"

include "cube.idp"
include "getARGV.idp"

load "medit"
load "MUMPS_seq"

real freq = getARGV("-frequency",1.); // frequency
int nppwl = getARGV("-nppwl",8); // number of points per wavelength
int npml = getARGV("-npml",8); // number of points in pml

real omega = 2.*pi*freq;
real c = 1;
real mu = c^2;
real k = omega/c;

real lambda = (1./freq)*c;
real h = lambda/nppwl;

cout << "lambda = " << lambda << ", h = " << h << endl;

real lengthpml = npml*lambda/nppwl;

/* dimensions of the domain */
real lengthx = 6;
real lengthy = 2;
real depth = 10;

/* point source coordinates */
real xs = lengthx/2.;
real ys = lengthy/2.;
real zs = -depth/2.;

real nloc = nppwl*lengthx/lambda;

int nplx = nloc*(lengthx+2*lengthpml)/lengthx;
int nply = nloc*(lengthy+2*lengthpml)/lengthx;
int npd = nloc*(depth+2*lengthpml)/lengthx;
nplx = nplx+nplx%2;
nply = nply+nply%2;
npd = npd+npd%2;

int[int] N=[nplx,nply,npd];
real [int,int] B=[[-lengthpml,lengthx+lengthpml],[-lengthpml,lengthy+lengthpml],[-depth-lengthpml,lengthpml]];
int [int,int] L=[[11,12],[13,14],[15,16]];

mesh3 Th=Cube(N,B,L);

/* tag the source node: */
real disti, dist = 1e+30;
real idist = -1;
for (int i=0; i<Th.nv; i++) {
  disti =(Th(i).x-xs)^2+(Th(i).y-ys)^2+(Th(i).z-zs)^2;
  if (disti < dist){
    dist = disti; 
    idist = i;
  }
}

func supp = sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2) > lambda;
func pml = (x>=lengthx)+(x<=0)+(y>=lengthy)+(y<=0)+(z>=0)+(z<=-depth);

func exact = exp(1i*k*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2))/(1e-20+4*pi*sqrt((x-xs)^2+(y-ys)^2+(z-zs)^2));

fespace Uh(Th,P1);

Uh<complex> rhs = 0;
rhs[][idist] = -1./(h^3);

int[int] npmls(6);
npmls = npml;
matrix<complex> A = HelmholtzFD(Th,omega,mu,npml=npmls);
set(A,solver=sparsesolver);

Uh<complex> u, uexact = exact*supp;

u[] = A^-1*rhs[];

Th = trunc(Th,pml==0);

u = u*supp;

real err = sqrt(abs(int3d(Th,qfV=qfV1lump)(supp*(u-exact)^2))) / sqrt(abs(int3d(Th,qfV=qfV1lump)(supp*exact^2)));

cout << "relative L2 error = " << err << endl;

medit("u.re uexact.re",Th,real(u),real(uexact));
load "Element_P3"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P3);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    if(0)
      {
      load "medit" load "msh3"
      meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
      medit("mm",Th3); 
      //savemesh(th,"mm",[x,y,vi*0.5]);   //save *.points and *.faces file for medit
      //if(!NoGraphicWindow) exec("ffmedit mm");
      //exec(" rm mm.faces mm.points");
      }	
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "Element_P3"
load "NewSolver"
verbosity=3;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "Element_P2bulle3"
load "msh3"
load "medit"
mesh3 Th=cube(2, 3, 4);
//mesh3 Th = readmesh3("./T1.mesh");
mesh3 Thf = trunc(Th,1,split=2);
func bool fv(real[int] & v, ofstream of)
{
	of<< " ( ";
	for(int i=0; i< v.n; ++i)
	if(abs(v[i])>1e-10) of << i << " " << v[i] << ", " ;
	of << " ) \n";
	return 1; 
}
func f = x+2*y+3*z;                                            //sin(x) + sin(2*y)+sin(3*z);
fespace Vh(Th,P2b3d);
fespace Vh2(Thf,P1);

Vh u =0,v,w;
//verbosity=10;
int err=0;
for(int i=0; i< u[].n; ++i)
{
	//cout << "\n\t******  i = " << i << endl;
	u=0; u[][i]=1; 
	Vh2 u2 = u; 
	v =u;
	w[]=u[]-v[];
	//plot(u2,cmm=" i =" + i ,wait=1,nbiso = 10);
	if( w[].linfty> 1e-5)
	{
		err++;
	  cout << i << " "<< v[][i] <<" ==" << v[].imax  ; fv(v[],cout); 
     }
	
}
assert(err==0);
u=f; 
real err1 = int3d(Thf)(sqr(f-u)) ;
cout << " err1=" << err1 << endl; 
//cout << u[] << endl;

Vh2 u2 = u; 
plot(u2);
// cout << " u2 bounad = " << u2[].min << " " << u2[].max << endl; 
real err2 = int3d(Th)(sqr(f-u2)) ;
cout << " err2=" << err2 << endl; 
//cout << u2[] << endl;

 

load "msh3"
load "mat_psi"
border a(t=0, 2*pi)     {    x = cos(t);    y = sin(t);  };
mesh th2 = buildmesh(a(70));
mesh3 th=  buildlayers(th2,5,zbound=[0,1]);
fespace Vh(th,P1);

Vh vh,vo,u1 = y, u2 = -x, v = exp(-10*((x-0.3)^2 +(y-0.3)^2)), u3=0, rhs =0;
Vh wh=0,Bwh;
real dt = 0.001,t=0, tmax=3.14;
int kk=0;
varf aa(v,vh) = int3d(th)(v*vh/dt) ;
matrix  AA= aa(Vh,Vh,solver="SPARSESOLVER");

problem  A(v,vh) = int3d(th)(v*vh/dt)   - int3d(th)(vo*vh/dt) + rhs[];

real[int] viso=[-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,10,100,1000];
verbosity = 4;
if(1)
 cout << "\n\n\n  MatUpWind0 3d not yet implemented FH. (To DO) \n\n\n" << endl; 
else
for ( t=0; t< tmax ; t+=dt)
{
  vo=v;
  matrix B;
  MatUpWind0(B,th,vo,[u1,u2,u3]);
//  cout << B << endl;
  rhs[] = AA* vo[];
  rhs[] += B* vo[] ;
  v[] = AA^-1*rhs[];
 // wh[][50]=1;
  //Bwh[] = B*wh[];
 // plot(wh,Bwh,wait=1);
  plot(v,fill=1,cmm="convection: t="+t + ", min=" + v[].min + ", max=" +  v[].max,viso=viso,wait=0);
};
plot(v,wait=1,value=1,fill=1);
load "distance"
mesh Th=buildmesh("g.gmesh",nbvx=10000);
fespace Vh(Th,P1);
real[int] bb(4); 
boundingbox(Th,bb);
// b[0] xmin, xmax, ymin ymax 
real xc1 = bb[0]*0.6 + bb[1]*0.4;
real xc2 = bb[0]*0.2 + bb[1]*0.8;
real yc = bb[2]*0.3 + bb[3]*0.7;
real r2 = ((bb[3]-bb[2])*.1)^2;
cout << xc1 << " "<< xc2 << " " << yc << "r2 = " << r2 << endl; 
cout << bb << endl;
func f0 = ((x-xc1)^2 + (y-yc)^2- r2)*((x-xc2)^2 + (y-yc)^2 - r2);
Vh u = f0, v;

plot(u, dim=3, value=1,wait=1); 

verbosity=1; 


distance(Th,f0,v[]);

real[int] v0 = [-10,-1,-0.01,0,0.01,1,10];
plot(u,wait=1,viso=v0);
plot(v,wait=1,cmm="distance");
load "lapack"
// test of lapack load file ... 
// .......................
// load "fflapack" obsolete (F. Hecht version 3.8)
// use  load "lapack"  
int nerr=0; // nomber of err .. 
//  to set a full matrix .. 
macro SETM(A,i,j,fij) 
{ 
    for(int i=0;i<A.n;++i) 
      for(int j=0;j<A.m;++j) 
        A(i,j)= (fij) ;
}//EOM 

// The of Eigen Problem ..
NewMacro TEST(Type,Typevp,vtype,ComputeEV)
{     
cout << "\n\n *****************   VP \n\n\n"; 
int n=5;
Type[int,int] A(n,n),A1(n,n),B(n,n),Id(n,n);
SETM(A,i,j,(i==j) ? n+1 : 1); 
SETM(Id,i,j,real(i==j)); 
A(0,n-1)=vtype;

cout << A << endl;
A1=A^-1;
cout << A1 << endl;

Typevp[int] vp(n);
Typevp[int,int] VP(n,n),KK(n,n);

int nn= ComputeEV(A,vp,VP);
 cout << " vp = " << vp << endl;
 cout << " VP = " << VP << endl;
 
 // verification ... 
 KK =0.;
 for(int i=0;i<n;++i)
   for(int j=0;j<n;++j)
     for(int k=0;k<n;++k)
       //KK(i,j) += (A(i,k) - vp[j]* real(i==k) ) *VP(k,j);
       KK(i,j) += (A(i,k) - ((i==k)?vp[j]:0.0) ) *VP(k,j);
 cout <<" ||KK|| " <<  KK.linfty << endl; 
 nerr += KK.linfty > 1e-9; 
B=0;
B = A*A1; // version 3.13
B -= Id; 
cout <<" ||A*A1-Id|| " <<  B.linfty << endl; 
nerr += B.linfty > 1e-9; 
inv(A1);
A1 -= A; 
cout <<  "|| inv(A1) - A ||" << A1.linfty << endl;
nerr += A1.linfty > 1e-9; 
}
EndMacro 

cout << "Testing real complex dgeev..." << endl;
TEST(real,complex,-100.,dgeev)
cout << nerr << endl;
cout << "Testing complex complex zgeev..." << endl;
TEST(complex,complex,100i,zgeev)
cout << nerr << endl;
cout << "Testing real real dsyev..." << endl;
TEST(real,real,1,dsyev)
cout << nerr << endl;
assert(nerr==0); 


// FFCS - value for regression checks
real regtest=0;

{

int n=5;
real [int,int] A(n,n),  B(n,n),  C(n,n);
SETM(C,i,j,1./(1+i+j)) ; 
SETM(B,i,j,i==j?2.:1./n) ;
 
A = B*C;
cout << A << " " << endl;
A = B + C;
real[int]  b(n),c(n);
real[int,int] AA=A;
AA=A;
real [int,int] At=A';

b = A*c;

At =A';
{

real [int,int] A=[[0,-1,2],[4,11,2],[0,-1,2],[4,11,2]];
real [int,int] B=[[3,-1],[1,2],[6,1]];
real [int,int] E=[[11,0],[35,20],[11,0],[35,20]];
real [int,int]  At=A';
real [int,int] C(A.n,B.m);
C=A*B;
cout << " C = " <<  C << endl;
cout << " E = " <<  E << endl;

C -= E;
assert( C.linfty < 1e-10);
C = A*B;
C -=E; 
assert( C.linfty < 1e-10);
}
{

complex [int,int] A=[[0,-1,2],[4,11,2],[0,-1,2],[4,11,2]];
complex [int,int] B=[[3,-1],[1,2],[6,1]];
complex [int,int] E=[[11,0],[35,20],[11,0],[35,20]];

complex [int,int] C(A.n,B.m);
complex [int,int]  At=A';
cout << "At = " << At << endl;
C=A*B;
cout << " C = " <<  C << endl;
cout << " E = " <<  E << endl;

C -= E;
assert( C.linfty < 1e-10);
C = A*B;
C -=E; 
assert( C.linfty < 1e-10);

// FFCS - value for regression checks
regtest=C.linfty;
}
}
// Example of dynamic function load
// --------------------------------
// $Id$
//   Discret Fast Fourier Transform 
// -------------------------------
 load "dfft"
 
int nx=32,ny=16,N=nx*ny;
// warning the fourier space is not exactly the unite square due to periodic condition
mesh Th=square(nx-1,ny-1,[(nx-1)*x/nx,(ny-1)*y/ny]);
// warring  the numbering is of the vertices (x,y) is 
// given by $  i = x/nx + nx* y/ny $

fespace Vh(Th,P1); 

func f1 = cos(2*x*2*pi)*cos(3*y*2*pi);
Vh<complex> u=f1,v;
Vh w=f1;


Vh  ur,ui;
//  in dfft the matrix n,m is in row-major order ann array n,m is 
// store j + m* i ( the transpose of the square numbering ) 
 v[]=dfft(u[],ny,-1);
 u[]=dfft(v[],ny,+1);
 cout << " ||u||_\infty " << u[].linfty << endl;
 u[] *= 1./N; // remark: operator /= bug  before version 2.0-3 (FH)
 cout << " ||u||_\infty " << u[].linfty <<  endl;
  ur=real(u); 
  plot(w,wait=1,value=1,cmm="w");
  plot(ur,wait=1,value=1,cmm="u");
 v = w-u;
cout << " diff = "<< v[].max << " " <<  v[].min << endl;
assert( norm(v[].max) < 1e-10 &&  norm(v[].min) < 1e-10) ;
 // -------  a more hard example ----\hfilll
 // Lapacien en FFT \hfilll
 // $ -\Delta u = f $ with biperiodic condition \hfilll
func f = cos(3*2*pi*x)*cos(2*2*pi*y); // 
func ue =  +(1./(square(2*pi)*13.))*cos(3*2*pi*x)*cos(2*2*pi*y);  // the exact solution 
Vh<complex> ff = f;
Vh<complex> fhat;
fhat[] = dfft(ff[],ny,-1);

Vh<complex> wij,wijm;
// warning in fact we take mode between -nx/2, nx/2 and -ny/2,ny/2
//  thank to the operator ?: \label{?:} 
wij = square(2.*pi)*(square(( x<0.5?x*nx:(x-1)*nx)) + square((y<0.5?y*ny:(y-1)*ny)));
wij[][0] = 1e-5; // to remove div / 0
fhat[] = fhat[]./ wij[];  // 
u[]=dfft(fhat[],ny,1);
u[] /= complex(N);
ur = real(u); // the solution
w = real(ue); // the exact solution 
plot(w,ur,value=1 ,cmm=" ue   ", wait=1); 
w[] -= ur[]; // array sub
real err= abs(w[].max)+abs(w[].min) ;
cout << " err = " << err << endl;
assert( err  < 1e-6);

// version 3.22 ... 

fftwplan p1=plandfft(u[],v[],ny,-1);
fftwplan p2=plandfft(u[],v[],ny,1);
//mapkk(wijm[],ny,cccx*(x*x)+cccy*(y*y));
mapkk(wijm[],P,ny,sqr(2*pi*x)+sqr(2*pi*y)); 
wijm[][0] = 1e-5;
plot(wij,wait=1);
plot(wijm,wait=1);
wij[]-=wijm[];
cout << " err = " << wij[].linfty << endl;
assert( wij[].linfty < 1e-8);
load "Element_P1ncdc"
load "Element_P1dc1"
load "msh3"
int errT=0; 

macro Test(Th,FE,nFE)
{
int err=0; 	
fespace Wh(Th,FE);
Wh u=x,v,w;
int[int] I(Wh.ndof), K(Wh.ndof);
for(int k=0; k<Th.nt;++k)
for(int i=0; i< Wh.ndofK;++i)
{  int j = Wh(k,i);
	I[j]= i;
	K[j]=k;
}
for(int i=0; i< Wh.ndof;++i)
{
	if(0) cout << " i "<< i << endl;
	u=0;
	u[][i]=1;
	v=u;
	v[]-=u[];
	err += v[].linfty>1e-7;
	if(v[].linfty>1e-7) {v=u;cout << " err" << i<< " " << "Wh(k,i) " << K[i] << " " << I[i] << v[] << endl;}
}
cout << " ** " << nFE << " Nb err = "<< err<< " " << Wh.ndof << " errT =" << errT << endl; 
errT += err;
}
// 

mesh Th=square(1,1);

{
	fespace Vh(Th,P1bnc);
	

Vh u=x;

for(int i=0; i< Vh.ndof;++i)
{
	u=0;
	u[][i]=1;
plot(u,wait=1,cmm="2d dof="+i,fill=1,dim=3);

}
varf vm(u,v)= int2d(Th,qforder=3)(u*v);
matrix M=vm(Vh,Vh);
//cout << M << endl; 
}

//	Test(Th,P1dcnc,"P1dcnc")
Test(Th,P1dc,"P1dc")
Test(Th,P1dc1,"P1dc1")
Test(Th,P1bnc,"P1bnc")
Test(Th,P1bdcnc,"P1bdcnc")

mesh3 Th3=cube(1,1,1);

Test(Th3,P1dc3d,"P1dc3d")
Test(Th3,P1dc3d1,"P1dc3d1")


meshS ThS=square3(1,1);
fespace VhS(ThS,P1dcS);
VhS uS=x;

for(int i=0; i< VhS.ndof;++i) {
	uS=0;
	uS[][i]=1;
plot(uS,wait=1,cmm="3d surf dof="+i,fill=1);
}
Test(ThS,P1dcS,"P1dcS")
Test(ThS,P1dcS1,"P1dc1S")


meshL ThL=Sline(10);
Test(ThL,P1dcL,"P1dcL")
Test(ThL,P1dcL1,"P1dc1L")



assert(errT==0);

load "Element_P4dc"
load "Element_P4"
load "Element_P3pnc"
func real cc(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];

// the ref triangle 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);


//Th = movemesh(Th,[x+0.1*y,y-0.2*x]);
//Th = movemesh(Th,[x*2,y*2]);

mesh Thg = trunc(Th,1,split=2,label=-1);
plot(Th, wait=1);

int it0=0; 

fespace Lh(Th,P1);
Lh[int] l(3);
l[0][][0]=1;
l[1][][1]=1;
l[2][][2]=1;


fespace Wh(Th,P4dc);
fespace Vh(Th,P3pnc);
Wh[int] mn(12);
int k=0;
real cc7 = 3*4*5*6*7;
func bk = (l[0] - l[1]) * (l[1] - l[2]) * (l[2] - l[0]);
func l0 =l[0];
func l1 =l[1];
func l2 =l[2];

mn[k++]=      l0 * l0 * l0;
mn[k++]=  l1 * l1 * l1;
mn[k++]=  l2 * l2 * l2;                                            //3
mn[k++]=        l0 * l0 * l1;
mn[k++]=   l0 * l0 * l2;
mn[k++]=   l1 * l1 * l0;
mn[k++]=   l1 * l1 * l2;
mn[k++]=   l2 * l2 * l0;
mn[k++]=   l2 * l2 * l1;
  //6
mn[k++]=        l0 * l1 * l2;                                                                       //2
mn[k++]=        bk * l0;
mn[k++]=   bk * l1 ;                                                                    // P4 element


/*
      l0 * l0 * l0, l1 * l1 * l1, l2 * l2 * l2,                                            //3
      l0 * l0 * l1, l0 * l0 * l2, l1 * l1 * l0, l1 * l1 * l2, l2 * l2 * l0, l2 * l2 * l1,  //6
      l0 * l1 * l2,                                                                        //2
      bk * l0, bk * l1                                                                     // P4 element

*/
/*
for(int i=0; i<3;++i)
{
	int i1 = (i+1)%3, i2=(i+3)%3;
	mn[k++]= l[i];
	mn[k++]= l[i1]*l[i2];
	mn[k++]= l[i]*l[i]*l[i];
	
}
mn[k++]= l[0]*l[1]*l[2];
mn[k++]= l[0]*bk;
mn[k++]= l[1]*bk;
*/
Vh u,v;
real[int,int] CC(12,12),C1(12,12);
for (int j=0;j<Vh.ndofK;++j)
{
	Wh u=mn[j];
	int i=0;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge));
		CC(j,i++)=  cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge));
		CC(j,i++)= cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	CC(j,i++)= cc(int2d(Th,qforder=9)( l[0]*u/area)) ;
	CC(j,i++)= cc(int2d(Th,qforder=9)( l[1]*u/area)) ;
	CC(j,i++)= cc(int2d(Th,qforder=9)( l[2]*u/area)) ;
}
C1=CC		;
CC *=cc7;
cout << " CC =" << CC << endl;
real[int,int] DD =[
  [  -1.2,    -1.2,      1.2,      1.2,         6.,        -15.6,       6.,        1.2,       -15.6,      -9.6,     4.8,      4.8     ], //dof 1
  [   6.,     1.2,      -15.6,     -1.2,        -1.2,       1.2,        1.2,       6.,        -15.6,      4.8,      -9.6,     4.8     ], //dof 2
  [   1.2,    6.,       -15.6,      6.,         1.2,       -15.6,      -1.2,      -1.2,       1.2,        4.8 ,     4.8,      -9.6    ], //dof 3
  [  -8.4,    -73.2,    298.8,      73.2,       10.8,      -306.,      -46.8,      20.4,      97.2,      189.6,    -192.,      2.4    ],  //dof 4
  [  10.8,    75.6,     -205.2,     -63.6,      -46.8,     349.2,      10.8,      -10.8,      -54.,      21.6,      86.4,     -108.   ], //dof 5
  [  10.8,    73.2,     -306.,      -73.2,      -8.4,      298.8,      20.4,      -46.8,      97.2,      -192.,     189.6,    2.4     ], //dof 6
  [ -46.8,    -63.6,    349.2,      75.6,       10.8,      -205.2,     -10.8,     10.8,      -54.,       86.4 ,     21.6,    -108.    ], //dof 7
  [ -10.8,    -73.2,    198.,       37.2,       20.4,      -154.8,     -8.4,      10.8,      46.8,       -24. ,     -81.6,    105.6   ], //dof 8
  [  20.4,    37.2,     -154.8,    -73.2,       -10.8,     198.,       10.8,      -8.4,      46.8,       -81.6 ,    -24.,     105.6   ], //dof 9
  [  12.,     12.,      -180.,      12.,        12.,       -180.,      12.,       12.,       -180.,      60. ,      60.,      60.     ], //dof 10
  [   0.,     -84.,     252.,       84.,        84.,       -504.,     -84.,       0.,        252.,       84.,      -168.,     84.     ], //dof 11
  [ -84.,     -84.,     504.,       84.,        0.,        -252.,     -0.,        84.,      -252.,       168.,     -84.,     -84.     ] //dof 12
   ];
  load "lapack"
inv(C1); 
real[int,int]   Ct =  C1';
cout << " C1 " << C1 << " DD = " << DD << endl; 
   DD -= Ct;
   cout << DD << endl; 
   cout << DD.linfty << endl; 


cout << " C1 =" << C1 << endl;

for (int j=0;j<Vh.ndofK;++j)
{
	int i = Vh(0,j);
	cout << j << " -> " <<  i << " : " ;
    u=0;
	u[][i]=1;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		if ( i2 < i1) swap(i1,i2); 
		cout << " " << cc(int1d(Th,k,qforder=9)(u*l[i1]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]/lenEdge)) << " " << cc(int1d(Th,k,qforder=9)(u*l[i2]*l[i1]/lenEdge)) ; 
	}
	cout << " " << cc(int2d(Th,qforder=9)( l[0]*u/area)) << " " << cc(int2d(Th,qforder=9)( l[1]*u/area)) <<" " << cc(int2d(Th,qforder=9)( l[2]*u/area)) << endl; 
	//plot(u,wait=1);
	v=u;
	for (int j=0;j<Vh.ndofK;++j)
	cout << cc(v[][Vh(0,j)]) << " " ;
	cout << endl;

}


 Th=square(5,5);
 u=x*x*y;
 v = u;
 cout << " err = " << sqrt(int2d(Th)(square((u)-(u))));
 solve PL2(u,v)=int2d(Th,qforder=7)(u*v)-int2d(Th,qforder=9)(x*x*y*v);
 // verification  !!!!!
 plot(u,wait=1);
 real err=0,err1=0,err2=0; 
for (int i=0;i<Vh.ndof;++i)
{
    u=0;

	u[][i]=1;
	Wh u3=u;
	v=u;
	v[]-=u[];
	real e  = v[].linfty;
	real e1 = sqrt(int2d(Th)(square(dx(u)-dx(u3))));
	real e2 = sqrt(int2d(Th)(square(dy(u)-dy(u3))));
	Wh dxu=dx(u), dxu3=dx(u3);
	Wh dyu=dy(u), dyu3=dy(u3);
	//plot(dxu,cmm=" dxu ", wait=1);
	//plot(dxu3,cmm=" dxu3 ", wait=1);
	dxu [] -= dxu3[];
	dyu [] -= dyu3[];
	real ee =  dxu []. linfty +  dyu []. linfty + e1 + e2;
	if( ee > 1e-6)
	  cout << i << " " << e << " " << e1 << " " << e2 << " :: " << dxu []. linfty << " " << dyu []. linfty << endl;
	err+= ee;
}
cout << " err=" << err  << endl; ; 
assert( err < 1e-6);
load "mat_psi"
border a(t=0, 2*pi)     {    x = cos(t);    y = sin(t);  };
mesh th = buildmesh(a(70));
fespace Vh(th,P1);

Vh vh,vo,u1 = y, u2 = -x, v = exp(-10*((x-0.3)^2 +(y-0.3)^2)), rhs =0;
Vh wh=0,Bwh;
real dt = 0.001,t=0, tmax=pi/4;
int kk=0;
varf aa(v,vh) = int2d(th)(v*vh/dt) ;
matrix  AA= aa(Vh,Vh,solver=CG);

problem  A(v,vh) = int2d(th)(v*vh/dt)   - int2d(th)(vo*vh/dt) + rhs[];

real[int] viso=[-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,10,100,1000];
verbosity = 4;
for ( t=0; t< tmax ; t+=dt)
{
  vo[]=v[];
  matrix B;
  MatUpWind0(B,th,vo,[u1,u2]);
//  cout << B << endl;
  rhs[] = B* vo[] ;
  rhs[] = -rhs[] ;
  rhs[] += AA* vo[];
  v[] = AA^-1*rhs[];
 // wh[][50]=1;
  //Bwh[] = B*wh[];
 // plot(wh,Bwh,wait=1);
  plot(v,fill=1,dim=3,cmm="convection: t="+t + ", min=" + v[].min + ", max=" +  v[].max,viso=viso,wait=0);
};
plot(v,dim=3,wait=1,value=1,fill=1);
// -*- FreeFEM -*-
// Time-stamp: "2022-10-04 18:08:35 fujiwara"
//
// Example from FreeFEM document
//
//----------------------------------------------------------------------
// Domain
//----------------------------------------------------------------------
border ba(t=0,1.0) { x=t;   y=0;   label=1; };
border bb(t=0,0.5) { x=1;   y=t;   label=2; };
border bc(t=0,0.5) { x=1-t; y=0.5; label=3; };
border bd(t=0.5,1) { x=0.5; y=t;   label=3; };
border be(t=0.5,1) { x=1-t; y=1;   label=2; };
border bf(t=0.0,1) { x=0;   y=1-t; label=1; };

mesh Th = buildmesh( ba(6)+bb(4)+bc(4)+bd(4)+be(4)+bf(6) );

//----------------------------------------------------------------------
// P1 approximation
//----------------------------------------------------------------------
fespace Vh1(Th,P1);
Vh1 u,v;
func f = -1;
solve Poisson(u,v)
  = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v))
    - int2d(Th)(f*v) + on(1,u=0) + on(2,u=0) + on(3,u=0);

plot(u,ps="LshapeP1.ps"); // default output

load "plotPDF"  // without semicolon

bool ret = plotPDF( "LshapeP1", Th, u );

assert( ret == true );  // Error check.

plotPDF( "LshapeP1contour", Th, u, gray=true, value=false, meshpage=false, index=false, belabel=false, fill=false ); // only contour (without legend : value=false), monochrome

//------------------------------
// output with options
//------------------------------
plotPDF( "LshapeWithMesh", Th, u, withmesh=0.75 );
plotPDF( "LshapeP1op1", Th, u, index=true, nbiso=36, nbfill=128 );

real[int] contour = [ -0.03,-0.025,-0.020,-0.015,-0.010 ];
real[int] range = [ -0.03, -0.01 ];
plotPDF( "LshapeP1op2", Th, u, index=true, viso=contour, frange=range );

//----------------------------------------------------------------------
// P0 approximation
//----------------------------------------------------------------------
fespace Vh0(Th,P0);
Vh0 u0 = u;
plotPDF( "LshapeP0", Th, u0, fetype="P0" );

//----------------------------------------------------------------------
// P1nc approximation
//----------------------------------------------------------------------
fespace Vh1nc(Th,P1nc);
Vh1nc u1nc,v1nc;
solve PoissonP1nc(u1nc,v1nc)
  = int2d(Th)(dx(u1nc)*dx(v1nc)+dy(u1nc)*dy(v1nc))
    - int2d(Th)(f*v1nc) + on(1,u1nc=0) + on(2,u1nc=0) + on(3,u1nc=0);

plotPDF( "LshapeP1nc", Th, u1nc );

//----------------------------------------------------------------------
// P2 approximation
//----------------------------------------------------------------------
fespace Vh2(Th,P2);
Vh2 u2,v2;
solve PoissonP2(u2,v2)
  = int2d(Th)(dx(u2)*dx(v2)+dy(u2)*dy(v2))
    - int2d(Th)(f*v2) + on(1,u2=0) + on(2,u2=0) + on(3,u2=0);

plotPDF( "LshapeP2", Th, u2, fetype="P2" );

plotPDF( "LshapeP2asP1", Th, u2 ); // u2 is interpreted as P1-approx.

//----------------------------------------------------------------------
// color palette example
//----------------------------------------------------------------------
// Proposed by Paul Tol
// Each triplet is [R,G,B]
// The 1st and the final are colors for minimum and maximum values.
// Between them, RGB is linearly interpolated

real[int,int] BuRd = [
  [ 33,102,172],
  [ 67,147,195],
  [146,197,222],
  [209,229,240],
  [247,247,247],
  [253,219,199],
  [244,165,130],
  [214,96, 77],
  [178,24, 43]
];
plotPDF( "LshapeP2-BuRd", Th, u2, fetype="P2", meshpage=false, palette=BuRd );

//----------------------------------------------------------------------
// vector fields
//----------------------------------------------------------------------
border c(t=0,2*pi) { x=cos(t); y=sin(t); }
//border a(t=0,2*pi) { x=0.3+0.3*cos(t); y=0.3*sin(t); }

int m = 30;
Th = buildmesh( c(m) );
//Th = buildmesh( c(m)+a(m) );

fespace P1h(Th,P1);
P1h uc=x*x+y*y, vc=x*x-y*y;

//verbosity=99;

// plot([uc,vc],Th,ps="vector.eps",wait=1); // default in FreeFem++
plotPDF("vector.pdf",Th,[uc,vc], withmesh=0.2, meshpage=false );
plotPDF("vector-unitarrow.pdf",Th,[uc,vc], unitarrow=true, isoline=false, withmesh=0.2, meshpage=false );

//----------------------------------------------------------------------
// complex-valued functions
//----------------------------------------------------------------------

border recta(t=-pi,pi) { x=t;  y=-1; label=1; };
border rectb(t=-1,1) { x=pi;  y=t;  label=2; };
border rectc(t=-pi,pi) { x=-t; y=1;  label=3; };
border rectd(t=-1,1) { x=-pi; y=-t; label=4; };

int r=20;
mesh Thr = buildmesh( recta(3*r) + rectb(r) + rectc(3*r) + rectd(r) );
fespace Vhr(Thr,P1);

Vhr<complex> sinz = sin( x + y*1i );

plotPDF( "complex.pdf", Thr, sinz, cmm="sin(z)", meshpage=false, zabs=true, zreal=true, zimag=true, zarg=true,fill=false );

//----------------------------------------------------------------------
// End of file
//----------------------------------------------------------------------
load "Element_P3"
load "NewSolver"

//defaulttoUMFPACK();
verbosity=3;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

verbosity=5;
  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "Element_P3"
load "MUMPS_seq"

//defaulttoMUMPSseq();
verbosity=4;
 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh  uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function
 real[int] rinfo(40);
 int[int] info(40);
 varf laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) - 100*uh*vh   ) //  bilinear form
  + int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form
matrix A=laplace(Vh,Vh,solver=sparsesolverSym);
set(A,solver=sparsesolver,rinfo=rinfo,info=info);
real[int] b=laplace(0,Vh);
cout << " nnz = "<< A.nnz << endl;  
//verbosity=1;
  uh[]=A^-1*b; // solve the problem plot(uh); // to see the result
  cout << "uh[] " << uh[].linfty << endl;
  plot(uh,ps="o/LaplaceP3.eps",value=true);
  if(verbosity>1)
 for(int i=0; i<40;++i)
   {
    cout << " solve: info " << i+1 << " = " << info[i] << " , / r " << rinfo[i] <<endl;
   }
load "distance"
load "msh3"
load "medit"
mesh3 Th=cube(10,10,10);
fespace Vh(Th,P1);
Vh u = z;//-0.501; 
func fxy=max(abs(x-y),abs(-1.+x+y));
func fxz=max(abs(x-z),abs(-1.+x+z));
func fyz=max(abs(y-z),abs(-1.+y+z));
func fxyz = max(max(fxy,fxz),fyz);
func ff=max(max(abs(x-0.5),abs(y-0.5)),abs(z-0.5));
u = 0.25-ff;
real[int] v0 = [0.001];
plot(u, dim=3, value=1,viso=v0,wait=1); 
Vh v=0,zz=z;
verbosity=3; 
//cout << v[] << endl; 

distance(Th,u,v[],distmax=1);


plot(u,wait=1,viso=v0);
plot(v,wait=1,cmm="distance",nbiso=10);
cout << " vmin/ vmax  " << v[].min << " "<< v[].max << endl;
verbosity=0;
/*
for( int k=0; k< Th.nt; ++k)
for( int j=0; j< 4; ++j)
{
	int i= Vh(k,j);
if(abs(v[][i]-zz[][i]) > 0.001)
cout << " i "<< i << " k = "<< k << " " << j << endl;
}
//medit("Th-v",Th,v);
*/
load "Element_P3dc"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro DD2(f,hx,hy) ( (-2*f(x1,y1)+f(x1+hx,y1+hy)+f(x1-hx,y1-hy))/(square(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro dnn(f) ( N.x*f#2+N.y*f#3) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-4;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P3dc);
fespace Eh(Th,P0edge);

Eh  edges;

Vh a1,b1,c1;
 
varf vFlux([a],[e]) = intalledges(Th)( dn(a1)*e*(jump(real(nuTriangle))<= 0));
varf vMean([a],[e]) = intalledges(Th)( (a1)*e*(jump(real(nuTriangle))<= 0)/lenEdge);


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " -> " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  edges[]=vFlux(0,Eh);
  cout << "Flux  edges = " << edges[] << endl; 
  edges[]=vMean(0,Eh);
  cout << " Mean   edges = " << edges[] << endl; 

  plot(a1, wait=1,cmm="w_"+i); 
  b1=a1;

  plot(a1,b1,cmm="w"+i, wait=1); 

  c1[] = a1[] - b1[];

  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;

  assert(c1[].linfty < 1e-5 );

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  cout << " dy(a1)(x1,y1) = " << dy(a1)(x1,y1) << " == " << DD(a1,0,h)  << endl; 
  cout << " dxx(a1)(x1,y1) = " << dxx(a1)(x1,y1) << " == " << DD2(a1,h,0) << endl; 
  cout << " dyy(a1)(x1,y1) = " << dyy(a1)(x1,y1) << " == " << DD2(a1,0,h)  << endl; 

  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
  assert( abs(dxx(a1)(x1,y1)-DD2(a1,h,0) ) < 1e-4);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
  assert( abs(dyy(a1)(x1,y1)-DD2(a1,0,h) ) < 1e-4);



} 

// FFCS: for regression tests
load "ClosePoints"
real regtest;
{
    // example of mesh with a given set of internal point (P)
    // P(i,0) x,
    // P(i,1) y,
    // P(i,2) = mesh density close to x,y not mandatory ..
    verbosity=1;

 real[int,int] P(100,3);
 real[int,int] Q(100,2);
 for(int i=0; i<P.n; ++i)
  {
      P(i,0) = 0.5+0.1*cos(i*0.02*pi);
      P(i,1) = 0.5+0.1*sin(i*0.02*pi);
      Q(i,0)=P(i,0)+i*0.001;
      Q(i,1)=P(i,1);

      P(i,2) = 0.05*0.05*2*pi;// mesh size auron point..
  }
// multy border syntax version 3.30 avril 2014 ...
  real[int] xx=[0,1,1,0],
            yy=[0,0,1,1];
  // radius, centre of the 4 circles ..
  real[int] RC=[ 0.1, 0.05, 0.05, 0.1],
            XC= [0.2,0.8,0.2,0.8],
            YC= [0.2,0.8,0.8,0.2];
  int[int]  NC=[-10,-11,-12,13]; //list number of $\pm$ segments
  // of the 4 circles borders

  border bb(t=0,1;i)
  {
  // i is the the index variable of the multi border loop
    int ii = (i+1)%4; real t1 = 1-t;
    x =  xx[i]*t1 + xx[ii]*t;
    y =  yy[i]*t1 + yy[ii]*t;
    label = 0; ;
  }

  border cc(t=0,2*pi;i)
 {
    x = RC[i]*cos(t)+XC[i];
    y = RC[i]*sin(t)+YC[i];
    label = i+1;
  }
  int[int] nn=[4,4,5,7];// 4 border , with 4,4,5,7 segment respectively .
  plot(bb(nn),cc(NC),wait=1);
  mesh th= buildmesh(bb(nn)+cc(NC), points=P,nbvx=100000) ;
  plot(th,wait=1,ps="o/multy-border+internal.eps"); 
  regtest = th.area;
  real eps= 0.01;
  //dumptable(cout);

  int[int] I= ClosePoints(eps,th,Q);
  //  j=I[i] is a array given number point Q_i in th_j
  cout << " Q_i -> th_j " << I << endl;
  int[int] J= ClosePoints1(eps,th,Q);
  //  j=J[i] is a array given number point th_i in Q_j
  cout << " th_i -> Q_j " << J << endl;
  // same try of
   int[int] II= ClosePoints(eps,Q');// remove point to close is a set {i/ Q[I[i]] }is without commun point at eps
   int[int] JJ= ClosePoints1(eps,Q');// remove point to close and is J[i] == J[j] => the point are to close at eps
   cout << " II=" << II << endl;
   cout << " JJ=" << JJ << endl;
   int[int] KK(II.n);
   KK=JJ(II); // Identity KK(i)==i
   II=0:II.n-1;
   KK-=KK;
   assert(KK.min==0 &&KK.max==0 );
}
{
    verbosity = 100;
     real[int,int] P(10,2);
     real[int,int] Q(11,2);
     for (int i=0; i<P.n; ++i)
       {
        P(i,0)= i;
        P(i,1)= i-1;
        Q(i,0)= P(i,0)+i*0.001;
        Q(i,1)= P(i,1)+i*0.001;
       }
       for (int i=P.n; i<Q.n; ++i)
       {
        Q(i,0)= randreal1();
        Q(i,1)= randreal1();
       }
       Q(P.n,:)=P(0,:);
       Q(P.n-2,:)=P(0,:);
     for (int i=0; i<P.n; ++i)
        cout <<" P " << i << " = " <<P(i,0) << " " << P(i,1) << endl;
        cout << endl;
    for (int i=0; i<Q.n; ++i)
        cout <<" Q " << i << " = " <<Q(i,0) << " " << Q(i,1) << endl;
     int[int][int] ij(10);
     Voisinage(P,Q,0.01,ij);
     cout << " ij: "<< endl;
     for(int i=0; i<Q.n; ++i)
       {
        cout << i << " " << ij[i].n <<" : " ;
        for(int j=0; j<ij[i].n; ++j)
         cout << ij[i][j] << " ";
        cout << endl;
       }

}
// -*- FreeFem++ -*-
// Sample of SaveHB
// Author: fujiwara@acs.i.kyoto-u.ac.jp
mesh Th = square(3,3);
macro Grad(u) [dx(u),dy(u)] // EOM

fespace Vh(Th,P1);
varf vP(u,v) = int2d(Th)(Grad(u)'*Grad(v)) + int2d(Th)(v) + on(1,u=1);

matrix A = vP(Vh,Vh);
real[int] rhs = vP(0,Vh);

load "SaveHB" 
int ret = SaveHB("sample.hb", A, rhs, "sample of SaveHB");
A.CSR; 
cout << A << endl; 
cout << " A = " << A << endl;
cout << " rhs  = " << rhs << endl;

assert(ret == 0); 

// End of file
load "ilut"
mesh Th=square(10,10);
fespace Qh(Th,P1);
fespace Vh(Th,P2);
real nu=1;
varf mp(p,q)=int2d(Th)(p*q/nu);

matrix Mp=mp(Qh,Qh);
real[int] diagMp(Qh.ndof); diagMp=Mp.diag; diagMp=1/nu*diagMp;

// We are putting this here to workaround a bug in freefem++
real[int] ilutOUT(Vh.ndof+Qh.ndof);

// Uses ILUT for the velocity part and the mass matrix for the pressure part
func real[int] ilutMp(real[int] & xx) {
	real[int] uuin(Vh.ndof);
	real[int] ppin(Qh.ndof);

	real[int] uuout(Vh.ndof);
	real[int] ppout(Qh.ndof);

	[uuin,ppin]=xx;

	for(int k=0;k<Qh.ndof;++k)  {
		ppout[k]=ppin[k]/diagMp[k];
	}
	//ppout=Mp^-1*ppin;
	uuout=applyIlutPrecond(uuin);

	ilutOUT=[uuout,ppin];
	return ilutOUT;
}
//dumptable(cout);
// Uses ILUT for the velocity and I for the pressure
func real[int] ilut(real[int] & xx) {
	ilutOUT=applyIlutPrecond(xx);
	return ilutOUT;
}

// Dummy do-nothing preconditioner
func real[int] dummy(real[int] & xx) {
	ilutOUT=xx;
	return ilutOUT;
}
// a trick to build C1 finite element with P3 lagrangre finite element
// like HSIEH-CLOUCH-TOCHER finite element 
// the idee is insure the the jump (dn(u)) on all edges 
// by penalisatison ... 
// not to bad ... 
// F. Hecht juin 2014 ..

load "Element_P3" // for P3
load "splitmesh3" // to splite each triangle in 3 traingle

int n=100,nn=n+10;
real[int] xx(nn),yy(nn);

mesh Th=square(20,20);  // mesh definition of $\Omega$
//Th=splitmesh3(Th);
fespace Vh(Th,P3);      // finite element space

macro bilaplacien(u,v) ( dxx(u)*dxx(v)+dyy(u)*dyy(v)+2.*dxy(u)*dxy(v)) // fin macro 
real f=1;
Vh [u],[v];
real pena = 1e6;
macro dn(u) (dx(u)*N.x+dy(u)*N.y)//
solve bilap([u],[v]) =
    int2d(Th)(  bilaplacien(u,v) ) 
  + intalledges(Th) ( jump(dn(u))*jump(dn(v))*pena) 
   - int2d(Th)(f*v)
   
   + on(1,2,3,4,u=0) 
; 
   
plot(u,cmm="u", wait=1,fill=1);
real umax = u[].max; 
int err =  (abs(umax-0.0012782) > 1e-4); 
cout << " uu max " << umax << " ~  0.0012782  , err = " << err 
     << " " << abs(umax-0.0012782) <<endl; 


for (int i=0;i<=n;i++)
 {
   xx[i]=real(i)/n;
   yy[i]=u(0.5,real(i)/n); // value of uh at point (0.5, i/10.) 
 }
 plot([xx(0:n),yy(0:n)],wait=1);
 assert(err==0); 
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.
cout << "--------- file : load.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "load.edp";
	real TESTload=uh[].max;
		cout<<"load reference value = "<<REFload
				<<" test value ="<<TESTload<<endl;
			assert(TESTload<REFload*(1+0.0001));
				assert(TESTload>REFload*(1-0.0001));
};

cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};

cout << "--------- file : testFEMorley.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFEMorley.edp";
	
};

cout << "--------- file : funcTemplate.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "funcTemplate.edp";
	
};

cout << "--------- file : LapDG3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LapDG3.edp";
	
};

cout << "--------- file : LapDG4.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LapDG4.edp";
	
};

cout << "--------- file : LaplaceP3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP3.edp";
	
};

cout << "--------- file : LaplaceP4.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "LaplaceP4.edp";
	
};

cout << "--------- file : bilapMorley.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "bilapMorley.edp";
	
};

cout << "--------- file : plot-fb-P3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P3.edp";
	
};

cout << "--------- file : plot-fb-P3dc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P3dc.edp";
	
};

cout << "--------- file : plot-fb-P4.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P4.edp";
	
};

cout << "--------- file : plot-fb-P4dc.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "plot-fb-P4dc.edp";
	
};

cout << "--------- file : splitmesh3.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "splitmesh3.edp";
	
};

cout << "--------- file : splitmesh6.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "splitmesh6.edp";
	
};

cout << "--------- file : testFE-PkEdge.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE-PkEdge.edp";
	
};

cout << "--------- file : testFE.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFE.edp";
	
};

cout << "--------- file : testFEMorley.edp -----------------" << endl;
verbosity=verbosityy;
{
		
	
	include "testFEMorley.edp";
	
};



load "Element_P3dc"
load "Element_P3"


//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
macro dn(u) (N.x*dx(u)+N.y*dy(u) ) //  def the normal derivative 

mesh Th = square(3,3); // unite square 
fespace Vh(Th,P3dc);     // Discontinous P2 finite element
fespace Xh(Th,P3);
//  if param = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=1000; // a paramater to add penalisation 
varf Ans(u,v)= 
   int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)  ) // Ok P4 
 + intalledges(Th,qforder=7)(//  loop on all  edge of all triangle 
         // the edge are see nTonEdge times so we / nTonEdge
         // remark: nTonEdge =1 on border edge and =2 on internal 
         // we are in a triange th normal is the exterior normal
         // def: jump = external - internal value,     on border extern - internal value
         //      average = (external + internal value)/2, on border just internal value
             ( jump(v)*average(dn(u)) -  jump(u)*average(dn(v)) 
          + pena*jump(u)*jump(v) ) / nTonEdge 
)
;
func f=1;
func g=0;
Vh u,v;
Xh uu,vv;
problem A(u,v,solver="SPARSESOLVER") = Ans 
- int2d(Th)(f*v) 
- int1d(Th)(g*dn(v)  + pena*g*v) 
;
problem A1(uu,vv,solver=CG) 
= 
 int2d(Th)(dx(uu)*dx(vv)+dy(uu)*dy(vv)) - int2d(Th)(f*vv) + on(1,2,3,4,uu=g);
 
 A; // solve  DG
 A1; // solve continuous

plot(u,uu,cmm="P3 Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
//  example of using the Schur Complement. 
// solve a Poisson problme on on symmetric domain with un hole
// with constant Dichilet Boundary condition par  hole. 
// but we only  just using half domain left Domain to buil matrix.

// for ShurComplement  full matrix 
load "lapack"
// for ShurComplement  sparse matrix 
load "Schur-Complement"

include "ExtractDofsonBorder.idp"
// for  to find dof with  Dirichet Boundary on l lablel 
macro FindDofOnBorder(l,Vh,I)
{
	varf von(u,v) = on(l,u=-1);
    int[int] J=0:Vh.ndof-1;
	real[int] vl = von(0,Vh); 
	sort(vl,J);
	vl = vl ? 1. :0.;
	int n = vl.sum+0.5; 

	I.resize(n);
	I=J(0:n-1);
	if(verbosity) cout << " FindDofOnBorder:n = "<< n << endl; 
}//

if (HaveUMFPACK) //  need UMPACK  computation 
{
macro grad(u) [dx(u),dy(u)] //

real hsize= 0.1; 
real htt = max(hsize/2,0.1);
mesh Th=square(2/hsize,1/hsize,[x*2,y]);

Th=trunc(Th,(abs(x-1)>4*htt)||(abs(y-0.5)>htt),label=10);

mesh Th2=movemesh(Th,[2-(x-2),y]);
plot(Th,Th2,wait=1);
fespace Vh(Th,P1);
fespace Vh2(Th2,P1);
int n = Vh.ndof;
varf va(u,v) = int2d(Th)(grad(u)'*grad(v))+on(1,3,4,u=0);

 matrix A= va(Vh,Vh,sym=0,tgv=-2);
if(verbosity>9) cout << A << endl; 
int[int] I; 
ExtractDofsonBorder(2,Vh,I,1);

real[int,int] B(1,1);

//  model 2 
int[int] I10;//list of  DoD  on label 10. (the hole) 
FindDofOnBorder(10,Vh,I10);
if(verbosity>9) cout << " I10 "<< I10 << endl; 
int[int] If(n);
int In=I.n; 
If=-1;
for [i,Ii:I]
  If[Ii]=i; 
for [i,I10i:I10]
    If[I10i]=In; 
if( verbosity>9) cout << If << endl; 	
real[int,int] S(1,1);

int nfs=SchurComplement(S,A,If,B);

cout << nfs << " "<< In+1  << endl;
if( verbosity>9)  cout << " S = "<<" " << S << endl;  
/*
In S  the dof are from 0 to  In-1 : right side 
  number is    In =  Boundary condition on hole
  PB build by symetry  so   solve  S(Il,Il)+S(Ir,Ir) 
*/
// compute the renumbing of left au right part Il,Ir
// here the the DoF on hole will be differente on left   and  right  part. 
int iclr=nfs; // DOF of B.C on  left part 
int icll=nfs-1;// DOF of B.C on  right part 
int iclS = nfs-1;
int[int] Il=0:nfs;
int[int] Ir=0:nfs;

Ir[iclr]=iclS;
Ir[icll]=-1;

Il[iclr]=-1;
Il[icll]=iclS;
 
int nd = nfs+1;//   Number of Dof on full problem
// need v4.3.2-177-g84744c98
// missing in previoux version : FH: 31th july 2018 
/*  version with sparse matrice
matrix St(nd,nd);
cout << " S ="<< S << endl;
St+=S(Ir,Ir);//  right matrix
St+=S(Il,Il);//  left  matrix
*/
// version with full matrix (need version after  4.4)
real[int,int] St(nd,nd);
St=0.;
Add(St,S,Ir);
Add(St,S,Il);
cout << " St=" <<  St << endl; 
cout << "ic  = "<< icll <<" " << iclr << endl; 
int[int] It=[icll,iclr];
real[int,int] SS(1,1), B0(1,1);
int nfs0=SchurComplement(SS,St,It,B0);

cout << "B0=" << B0 << endl; 
// plot the solution on the 2  meshes. 
for(int j=0; j<B0.m; ++j)
{	
	Vh ul=0;
	Vh2 ur = 0; 
	//  vertical Dof  left aund right part
	for(int i=0; i<nfs-1; ++i)
  	 ur[] +=  B(:,i)*B0(i,j);
	for(int i=0; i<nfs-1; ++i)
 	 ul[] +=  B(:,i)*B0(i,j);
	//  for DoF on Holes (left and right).   
	{
	  ur[] +=  B(:,nfs-1)*B0(nfs-1,j);
	  ul[] +=  B(:,nfs-1)*B0(nfs,j);
	 }   
	plot(ul,ur, wait=1);
}
}
load "MetricPk"

int kDeg=4;
int nIter=5;
mesh Th=square(20,20,[2*x-1,2*y-1]);
real c=5;
func f = x^2*y + y^3 + tanh(c*(-2*x + sin(5*y)));
real ratio = 1.3;
//real massRef=40*Th.nt; //40 : constante pour passer de la masse au nb de triangles (?).
real massRef=Th.nt/2; //The number of triangles is approx twice the mass

fespace Metric(Th,[P1,P1,P1]);
Metric [m11,m12,m22];
for(int i=0; i<nIter; i++){
	plot(Th,wait=true);
	[m11,m12,m22]=[0,0,0];
	m11[]=MetricPk(Th,f,kDeg=kDeg,rDeg=1,mass=massRef,MetricType=1,TriangulationType=1);
	Th = adaptmesh(Th,m11,m12,m22,IsMetric=true);
	massRef=massRef*ratio;
}
plot(Th,wait=true,ps="o/lastMesh.ps");
//load "Element_P3dc"
mesh Th=square(10,10);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P1);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=min(vi[].n,20);i<min(vi[].n,50);++i)
 {
   vi[][i]=1;
   Wh w=vi;
    plot(w,wait=1,cmm=" v"+i,dim=3);	
    //    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "Curvature"
load "isoline"
cout << " tersca " << Tresca(1,2,3,0,0,0) << endl;; 
real R= 1;
real meshsize= 0.1;
border DC(t=pi/2,-pi/2) { x=R*cos(t); y=R*sin(t); label=1;}
border axe(t=R,-R) {x=0; y=t; label=2;}

mesh Th=buildmesh(DC(-R*pi/meshsize)+axe(2*R/meshsize));

fespace Vh(Th,P1); 
Vh ca,c,cc,ccc;;
c[]=curvature(Th,1);
real cmean= int1d(Th,1,qforder=1)(c)/int1d(Th,1,qforder=1)(1.);
cout<< " cmean = " << cmean << " == " << 1/R << endl;
plot(c, wait=1,cmm=" curvature" ); 
verbosity=1000;
ca[]=raxicurvature(Th,1);
verbosity=1;
plot(ca, wait=1,cmm="axi curvature" );
real s=int1d(Th,1,qforder=1)(x*2*pi); 
cout << " s = " << s << " " << 4*pi*R*R << endl; 
real cmeana= int1d(Th,1,qforder=1)(2*pi*ca)/s;
solve AAA(cc,ccc)= int2d(Th)(cc*ccc*1e-10)+ int1d(Th,1)(x*cc*ccc)- int1d(Th,1)(ca*ccc);
//cc = ca/max(x,0.01);
plot(cc,wait=1); 
cout<< " cmeana = " << cmeana << " == " << 2/R << endl;
assert(abs(cmean-1/R)< 0.05/R); 

int[int] ll=[1,2];
real[int,int] b12(1,3); 
real l12=extractborder(Th,ll,b12);
cout << " size b12 = " << b12.n << " x " << b12.m << endl;
border BB(t=0,1){ P=Curve(b12,t);label=3;}
plot(BB(100),wait=1);
load "qf11to25"
load "Element_QF"
{
mesh Th=square(5,5,flags=2);
//Th=trunc(Th, x <0.5);
plot(Th,wait=1);
mesh Thf=square(10,10);
fespace QFh(Th,FEQF5);
fespace Ph(Thf,P0);
func ff = (x+1)^2*(y-2)^3;
QFh ffh=ff;
Ph ffp=ffh;
plot(ffp,wait=1,fill=1); 
QFh xh=x;
QFh yh=y;
if(verbosity>9)
{
cout << " xh = " << xh[] << endl;
cout << " yh = " << yh[] << endl;
}
cout << int2d(Th)(x) << " ==  " << int2d(Th)(xh) << endl; 
cout << int2d(Th)(y) << " == " << int2d(Th)(yh) << endl; 
cout << int2d(Th)(ff) << " == " << int2d(Th)(ffh) << endl; 
//dumptable(cout);
FiniteElement2d EFQF(qf23pT);
fespace Zh(Th,EFQF);
Zh zz=x+y;
plot(zz,fill=1,wait=1,cmm="zz");
}
{
 load "msh3"
mesh3 Th=cube(2,2,2);
//Th=trunc(Th, x <0.5);
plot(Th,wait=1);
mesh3 Thf=cube(10,10,10);
fespace QFh(Th,FEQF53d);
fespace Ph(Thf,P0);
func ff = (x+1)^2*(y-2)^3*(z+2)^1.5;
QFh ffh=ff;
Ph ffp=ffh;
plot(ffp,wait=1,fill=1); 
QFh xh=x;
QFh yh=y;
QFh zh=z;
if(verbosity>9)
{
cout << " xh = " << xh[] << endl;
cout << " yh = " << yh[] << endl;
cout << " yh = " << yh[] << endl;
}
cout << int3d(Th)(x) << " ==  " << int3d(Th)(xh) << endl; 
cout << int3d(Th)(y) << " == " << int3d(Th)(yh) << endl; 
cout << int3d(Th)(z) << " == " << int3d(Th)(zh) << endl; 
cout << int3d(Th)(ff) << " == " << int3d(Th)(ffh) << endl; 
FiniteElement3d EFQF3(qfVp14);
fespace Zh(Th,EFQF3);
fespace Zh2(Th,[EFQF3,EFQF3]);

}
;

load "msh3"
load "Element_P3"
load "qf11to25"
 real umax = 0.0562131; // P2 
verbosity=2;
int[int] l1=[1,1,1,1,1,1];
mesh3 Th=cube(10,10,10, label=l1);
fespace Vh(Th,P3);

Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM


problem Lap3d(u,v,solver=CG)  =
  int3d(Th,qfV=qfVp6)(Grad3(v)' *Grad3(u)) //') for emacs  
  - int3d(Th,qfV=qfVp6)(1.*v) 
  + on(1,u=0);
 
  
 
Lap3d;

cout << " u max= " << u[].max << " // " << umax << endl; 
plot(u,wait=1); 
real err= abs(u[].max-umax);
assert( err < 1e-2);

// file adaptsphere.edp
load "msh3"
load "tetgen"
load "medit"

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a sphere 
func f1 =cos(x)*cos(y);
func f2 =cos(x)*sin(y);
func f3 = sin(x);
//  partiel derivative of the parametrization DF
func f1x=sin(x)*cos(y);   
func f1y=-cos(x)*sin(y);
func f2x=-sin(x)*sin(y);
func f2y=cos(x)*cos(y);
func f3x=cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of spheres
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

meshS Th3=movemesh23(Th,transfo=[f1min,f2min,f3min],orientation=-1);

real[int] domain = [0.,0.,0.,145,0.01];
mesh3 Th3sph=tetg(Th3,switch="paAAQYY",nbofregions=1,regionlist=domain);

int[int] newlabel = [145,18];
real[int] domainrefine = [0.,0.,0.,145,0.0001];

mesh3 Th3sphrefine=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel,nbofregions=1,regionlist=domainrefine,sizeofvolume=0.0001);

int[int] newlabel2 = [145,53];
func fsize = 0.01/(( 1 + 5*sqrt( (x-0.5)^2+(y-0.5)^2+(z-0.5)^2) )^3);
mesh3 Th3sphrefine2=tetgreconstruction(Th3sph,switch="raAQ",region=newlabel2,sizeofvolume=fsize);

medit("sphere",Th3sph);
medit("sphererefinedomain",Th3sphrefine);
medit("sphererefinelocal",Th3sphrefine2);

load "Element_P3dc"
mesh Th=square(1,1);
plot(Th,wait=1);
mesh th=square(150,150);
fespace Vh(Th,P3dc);
fespace Wh(th,P1);
func p9=x*x*x+2*y*y*y+3*x*x*y+4*x*y*y+5*x*x+6*x*y+7*y*y+8*x+9*y+10;
func p9x=3 * x * x + 6 * x * y + 4 * y * y + 10 * x + 6 * y + 8;
func p9y=6 * y * y + 3 * x * x + 8 * x * y + 6 * x + 14 * y + 9;
func p9yy= 12 * y + 8 * x + 14;
func p9xx=6 * x + 6 * y + 10;
func p9xy=6 * x + 8 * y + 6;



Vh vi=p9;

cout << " 0.2,0.1 : " << vi(0.2,0.1)<<  " " << p9(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dx(vi)(0.2,0.1)<<  " " << p9x(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dy(vi)(0.2,0.1)<<  " " << p9y(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxx(vi)(0.2,0.1)<<  " " << p9xx(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dyy(vi)(0.2,0.1)<<  " " << p9yy(0.2,0.1) << endl;
cout << " 0.2,0.1 : " << dxy(vi)(0.2,0.1)<<  " " << p9xy(0.2,0.1) << endl;
vi=0;
if(!NoUseOfWait)
  for (int i=0;i<min(vi[].n,5);++i)
 {
    vi[][i]=1;
    vi;
    plot(vi,wait=0,cmm=" v"+i);
    if(!NoGraphicWindow && 0 )
      {
      load "medit" load "msh3"
      meshS Th3= movemesh23(th,transfo=[x,y,vi*0.5]);
      medit("mm",Th3); 
 
//      savemesh(th,"mm",[x,y,vi*0.5]);   //save *.points and *.faces file for medit
//      exec("ffmedit mm");
//      exec(" rm mm.faces mm.points");
      }	
    vi=vi;	
    cout << i << " vi = "<< vi[]<<endl;
    vi[]=0;
    
 }
load "msh3"
mesh Th=square(3,3);

mesh3 Th3=buildlayers(Th,3);
savemesh(Th3,"lll.mesh");
load "msh3"
load "iovtk"
mesh3 Th = cube(1,1,1,region=11);
fespace Vh(Th,P1);
Vh g=x+y*y+z*z*z;
int[int] fforder2=[1,1];
savevtk("bidule.vtk",Th,g,[g,g,g],/*order=fforder2,*/dataname=" b c",bin=1);


{ // restore mesh and data ???
real[int][int] data;	

mesh3 Th=vtkload3("bidule.vtk",fields=data);//  work only with order =1 and vgk file
cout << " " << data.n << " == 2 "<< endl;
}
// Mesh
load "msh3"
load "Element_P3"
load "Element_P2pnc_3d"
int[int] lc=[1,1,1,1,1,2];
mesh3 Th=cube(5,5,5,label=lc);
func Pu = P2pnc3d;
func Pm = P1dc; 
fespace VVh(Th,[Pu,Pu,Pu,Pm]);
fespace Vh(Th,P23d);

VVh [u1,u2,u3,p];
VVh [v1,v2,v3,q];

macro Grad(u) [dx(u),dy(u),dz(u)]// EOM
macro div(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

solve vStokes([u1,u2,u3,p],[v1,v2,v3,q]) = 
  int3d(Th,qforder=3)( Grad(u1)'*Grad(v1) +  Grad(u2)'*Grad(v2) +  Grad(u3)'*Grad(v3) //)';
		       - div(u1,u2,u3)*q - div(v1,v2,v3)*p + 1e-10*q*p ) 
  + on(2,u1=1,u2=0,u3=0) + on(1,u1=0,u2=0,u3=0) ;
plot(p,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
plot([u1,u2,u3] ,wait=1, nbiso=5); // a 3d plot of iso  pressure. 
//    Discontinous Galerlin Method
//   based on paper from 
// Riviere, Beatrice; Wheeler, Mary F.; Girault, Vivette
// title: 
// A priori error estimates for finite element 
// methods based on discontinuous approximation spaces
//  for elliptic problems.
//  SIAM J. Numer. Anal. 39 (2001), no. 3, 902--931 (electronic).
//  ---------------------------------
//  Formulation given by Vivette Girault
//  ------ 
// Author: F. Hecht , december 2003
// -------------------------------
//   nonsymetric bilinear form
//   ------------------------
//  solve $ -\Delta u = f$ on $\Omega$ and $u= g$ on $\Gamma$
macro dn(u) (N.x*dx(u)+N.y*dy(u) ) //  def the normal derivative 

mesh Th = square(10,10); // unite square 
fespace Vh(Th,P2dc);     // Discontinous P2 finite element
fespace Xh(Th,P2);
//  if param = 0 => Vh must be P2 otherwise we need some penalisation  
real pena=0; // a paramater to add penalisation 
varf Ans(u,v)= 
   int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)  )
 + intalledges(Th)(//  loop on all  edge of all triangle 
         // the edge are see nTonEdge times so we / nTonEdge
         // remark: nTonEdge =1 on border edge and =2 on internal 
         // we are in a triange th normal is the exterior normal
         // def: jump = external - internal value,     on border extern - internal value
         //      average = (external + internal value)/2, on border just internal value
            ( jump(v)*average(dn(u)) -  jump(u)*average(dn(v)) 
          + pena*jump(u)*jump(v) ) / nTonEdge 
)
;
func f=1;
func g=0;
Vh u,v;
Xh uu,vv;
problem A(u,v,solver="SPARSESOLVER") = Ans 
- int2d(Th)(f*v) 
- int1d(Th)(g*dn(v)  + pena*g*v) 
;
problem A1(uu,vv,solver=CG) 
= 
 int2d(Th)(dx(uu)*dx(vv)+dy(uu)*dy(vv)) - int2d(Th)(f*vv) + on(1,2,3,4,uu=g);
 
 A; // solve  DG
 A1; // solve continuous

plot(u,uu,cmm="Discontinue Galerkin",wait=1,value=1);
plot(u,cmm="Discontinue Galerkin",wait=1,value=1,fill=1);
load "MatrixMarket" 
// small interf	ce to read en small matrix in matrixmarket format 
//and add a binary  version (no ckeck of the endianness to day )
mesh Th=square(1,1);
fespace Vh(Th,P1); 
varf va(u,v)= int2d(Th)(u*v)+on(1,u=0);
string dir="/tmp/";
if (onWIN32) dir="";
{
matrix<complex> A = va(Vh,Vh);
savemtx(dir+"a.mtx",A);
savemtx(dir+"a.mtxb",A,1);

matrix<complex> AA , AB ;

{
readmtx(dir+"a.mtx",AA);
AA.COO;
cout << "A " << A << endl; 
cout << "AA " << AA << endl; 
AA = AA - A;
AA.COO;
cout <<" diff AA -A "<<  AA << endl;
cout << " diff AA"<< AA.linfty << endl;
assert(AA.linfty < 1e-10);
}
readmtx(dir+"a.mtxb",AB,1);

AB = AB - A;
cout << " AB"<< AB.linfty << endl;
assert(AB.linfty < 1e-10);

}

{
matrix<real> A = va(Vh,Vh);
savemtx(dir+"a.mtx",A); //  formatted  form A
savemtx(dir+"a.mtxb",A,1);//  binary  form 

matrix<real> AA , AB ;

{
readmtx(dir+"a.mtx",AA);
AA.COO;
cout << "A " << A << endl; 
cout << "AA " << AA << endl; 
AA = AA - A;
AA.COO;
cout <<" diff AA -A "<<  AA << endl;
cout << " diff AA"<< AA.linfty << endl;
assert(AA.linfty < 1e-10);
}

readmtx(dir+"a.mtxb",AB);

AB = AB - A;
cout << " AB"<< AB.linfty << endl;
assert(AB.linfty < 1e-10);

}
load "mat_edgeP1"
load "msh3"
load "Element_PkEdge"
load "Element_Mixte3d"
int err=0;
{ mesh Th=square(3,3);
	fespace Eh(Th,P0edge);
matrix A;
MatrixEdgeP1(A,Th);
cout << "2d " << A.nnz << " " << 2*Eh.ndof << endl;
err+=  A.nnz != 2*Eh.ndof;
if(verbosity>4)
cout << A << endl;
}
{ mesh3 Th=cube(10,10,10);
 fespace Eh(Th,Edge03d );
matrix A;
verbosity=5;
MatrixEdgeP1(A,Th);
if(verbosity>5)
cout << A << endl;
cout << " 3d:: " << A.nnz << " " << 2*Eh.ndof << endl;
cout << " 3d:: " << A.n << " " << Eh.ndof << endl;
err+=  A.nnz != 2*Eh.ndof;
err += A.n != Eh.ndof;

}
assert(err==0);
load "ff-cmaes"

int NP=10;			//Control the mesh quality
func ud=100; 		//Desired temperature in the target zone
real L=2,l=1.5,R=0.075;//L:oven length, l:oven height, R: resistors radius
real eps=1e-2,hugeval=1.e30;		//a small value governing collisions and a huge one for something else
int nbres=6;		//number of resistors (should not be changed) 
int NPres=NP*(2*pi*R);
real[int] pr(nbres+2), K(nbres+2); 
int regi=nbres, rege=nbres+1, lext=1;
K=1;	K[regi]=10;

macro Grad(u) [dx(u),dy(u)]//EOM
macro Resistor(i,cx,cy,lab)
border Res#i(t=0.,2*pi) {x=cx+R*cos(t); y=cy+R*sin(t); label=lab;}//EOM
real pena = 100;
func target = 100.;

real[int] Xmin(3*nbres),Xmax(3*nbres);
for(int i=0;i<nbres;++i)
{
	Xmin[3*i] = -hugeval;
	Xmax[3*i] = hugeval;
	Xmin[3*i+1] = (i%3)*(L/3) +  R+eps/2;
	Xmax[3*i+1] = (i%3 + 1)*(L/3) - (R+eps/2);
	Xmin[3*i+2] = R+eps + (i>2 ? 2*l/3 : 0);
	Xmax[3*i+2] = (i>2 ? l : l/3) - (R+eps);
}
cout << "Xmin: " << Xmin << endl << "Xmax: " << Xmax << endl;

int iter=0;
func real J(real[int] &X)
{
	verbosity=0;
	real[int] XX=X,diff=X;
	for(int i=0;i<X.n;++i)
	{
		XX[i] = X[i]>Xmin[i] ? X[i] : Xmin[i];
		XX[i] = XX[i]<Xmax[i] ? XX[i] : Xmax[i];
	}
	diff -= XX;
	real corr = diff.l2;
	//cout << X << endl << XX << endl << "==>" << corr << endl;
	
	border b1(t=0,1){x=L*t; y=0; label=0;}
	border b2(t=0,1){x=L;   y=l*t; label=0;}
	border b3(t=0,1){x=L*(1-t); y=l; label=0;}
	border b4(t=0,1){x=0;   y=l*(1-t); label=0;}
	Resistor(1,XX[1] ,XX[2] ,1);
	Resistor(2,XX[4] ,XX[5] ,1);
	Resistor(3,XX[7] ,XX[8] ,1);
	Resistor(4,XX[10],XX[11],1);
	Resistor(5,XX[13],XX[14],1);
	Resistor(6,XX[16],XX[17],1);
	border bi1(t=0,2){x=(0.5+t)*L/3; y=l/3; label=1;}
	border bi2(t=0,1){x=5*L/6; y=(1+t)*l/3; label=1;}
	border bi3(t=0,2){x=(2.5-t)*L/3; y=2*l/3; label=1;}
	border bi4(t=0,1){x=L/6; y=(2-t)*l/3; label=1;}
	mesh Th = buildmesh(
		 bi1(2*NP*L/3)+bi2(NP*l/3)+bi3(2*NP*L/3)+bi4(NP*l/3)
		+ Res1(NPres)+Res2(NPres)+Res3(NPres)+Res4(NPres)+Res5(NPres)+Res6(NPres)
		+ b1(NP*L)+b2(NP*l)+b3(NP*L)+b4(NP*l));
	//plot(Th,wait=1);
	
	fespace Vh(Th,P1);
	Vh u,v,reg=region;
	real[int] K(reg[].max+1),pr(reg[].max+1);
	K=1;
	K[Th(L/2,l/2).region] = 10;
	pr=0;
	for(int i=0;i<nbres;++i) pr(Th(XX[3*i+1],XX[3*i+2]).region) = XX[3*i];
	//plot(reg,value=1,fill=1,wait=1);
	
	solve Chaleur(u,v) = int2d(Th)( (dx(u)*dx(v) + dy(u)*dy(v)) * K[region]) + int1d(Th,0)(u*v) - int2d(Th)(pr[region]*v) ;
	if(iter %200 == 199)
	plot(u,fill=1,nbiso=50,wait=0,dim=2);
	real meanu = int2d(Th,Th(L/2,l/2).region)(u)/int2d(Th,Th(L/2,l/2).region)(1.);
	real res = int2d(Th,Th(L/2,l/2).region)(square(u-target));
	cout << "J: iter " << iter++ << "  -  mean=" << meanu << "  -  corr=" << corr << "  -  res=" << res << " ==> " << res+pena*corr << endl;
	cout << "pos : ";
	for(int j=0;j<X.n;++j) cout << " " << X[j];
	cout << endl;
	return res + pena*corr;
}

real[int] grad(3*nbres);
bool plotgrad=1;
func real[int] dJ(real[int] &X)
{
	verbosity=0;
	real[int] XX=X,diff=X;
	for(int i=0;i<X.n;++i)
	{
		XX[i] = X[i]>Xmin[i] ? X[i] : Xmin[i];
		XX[i] = XX[i]<Xmax[i] ? XX[i] : Xmax[i];
	}
	diff -= XX;
	real corr = diff.l2;
	//cout << X << endl << XX << endl << "==>" << corr << endl;
	
	border b1(t=0,1){x=L*t; y=0; label=7;}
	border b2(t=0,1){x=L;   y=l*t; label=7;}
	border b3(t=0,1){x=L*(1-t); y=l; label=7;}
	border b4(t=0,1){x=0;   y=l*(1-t); label=7;}
	Resistor(1,XX[1] ,XX[2] ,0);
	Resistor(2,XX[4] ,XX[5] ,1);
	Resistor(3,XX[7] ,XX[8] ,2);
	Resistor(4,XX[10],XX[11],3);
	Resistor(5,XX[13],XX[14],4);
	Resistor(6,XX[16],XX[17],5);
	border bi1(t=0,2){x=(0.5+t)*L/3; y=l/3; label=6;}
	border bi2(t=0,1){x=5*L/6; y=(1+t)*l/3; label=6;}
	border bi3(t=0,2){x=(2.5-t)*L/3; y=2*l/3; label=6;}
	border bi4(t=0,1){x=L/6; y=(2-t)*l/3; label=6;}
	mesh Th = buildmesh(
		 bi1(2*NP*L/3)+bi2(NP*l/3)+bi3(2*NP*L/3)+bi4(NP*l/3)
		+ Res1(NPres)+Res2(NPres)+Res3(NPres)+Res4(NPres)+Res5(NPres)+Res6(NPres)
		+ b1(NP*L)+b2(NP*l)+b3(NP*L)+b4(NP*l));
	//plot(Th,wait=1);
	
	fespace Vh(Th,P1);
	Vh reg=region;
	real[int] K(reg[].max+1),pr(reg[].max+1);
	K=1;
	K[Th(L/2,l/2).region] = 10;
	pr=0;
	for(int i=0;i<nbres;++i) pr(Th(XX[3*i+1],XX[3*i+2]).region) = XX[3*i];
	//plot(reg,value=1,fill=1,wait=1);
	Vh u,v;
	solve Chaleur(u,v) = int2d(Th)( (dx(u)*dx(v) + dy(u)*dy(v)) * K[region]) + int1d(Th,7)(u*v) - int2d(Th)(pr[region]*v) ;
	int regt = Th(L/2,l/2).region;
	for(int i=0;i<nbres;++i)
	{
		Vh up,ux,uy;
		int thereg = Th(XX[3*i+1],XX[3*i+2]).region;
		//cout << "pr:" << pr[thereg] << endl;
		solve dpchaleur(up,v) = int2d(Th)( (dx(up)*dx(v) + dy(up)*dy(v)) * K[region]) + int1d(Th,7)(up*v) - int2d(Th,thereg)(v);
		grad[3*i] = int2d(Th,regt)(2*up*(u-target)) + 2*pena*diff[3*i];
		solve dxchaleur(ux,v) = int2d(Th)( (dx(ux)*dx(v) + dy(ux)*dy(v)) * K[region]) + int1d(Th,7)(ux*v) - int1d(Th,i)(pr[thereg]*v*N.x);
		grad[3*i+1] = int2d(Th,regt)(2*ux*(u-target)) + 2*pena*diff[3*i+1];
		solve dychaleur(uy,v) = int2d(Th)( (dx(uy)*dx(v) + dy(uy)*dy(v)) * K[region]) + int1d(Th,7)(uy*v) - int1d(Th,i)(pr[thereg]*v*N.y);
		grad[3*i+2] = int2d(Th,regt)(2*uy*(u-target)) + 2*pena*diff[3*i+2];
		if(plotgrad)
		{
			plot(up,nbiso=50,wait=0,cmm="Derivative w.r.t. pr["+i+"]");
			plot(ux,nbiso=50,wait=0,cmm="Derivative w.r.t. x["+i+"]");
			plot(uy,nbiso=50,wait=0,cmm="Derivative w.r.t. y["+i+"]");
		}
	}
	cout << "dJ : " << grad << endl;
	return grad;
}


real pst=5000;
real isdxy=3*L/24.;
real[int] isd  =[1000,isdxy,isdxy,1000,isdxy,isdxy,1000,isdxy,isdxy,1000,isdxy,5*l/6,1000,isdxy,isdxy,1000,isdxy,isdxy];
real[int] start=[pst,L/6,l/6,pst,L/2,l/6,pst,5*L/6,l/6,pst,L/6,5*l/6,pst,L/2,5*l/6,pst,5*L/6,5*l/6];

//dJ(start);
cout << cmaes(J,start,initialStdDevs=isd,stopTolFun=1e-1,stopMaxIter=200,stopMaxFunEval=1000);
//BFGS(J,dJ,start,nbiterline=10,nbiter=3000,eps=1.e-8);
iter = 1000;

// FFCS - regression test reference value
real regtest=J(start);
load "tetgen" 
int nn=100; 
real[int] xx(nn),yy(nn),zz(nn);

for(int i=0; i<nn; ++i)
{
  xx[i] = randreal1();
  yy[i] = randreal1();
  zz[i] = randreal1();
}
mesh3 Th=tetgconvexhull(xx,yy,zz,region=1,label=3);
plot(Th);
load "metis"
load "msh3"
mesh Th=square(30,30);
meshS ThS=square3(30,30);
fespace Ph(Th,P0);
fespace Vh(Th,P0edge);
int[int] nupart(Th.nt);
Ph  part;
Vh  p1;
metisdual(p1,10); // new interface .. 
plot(p1,wait=1,fill=1);
metisnodal(p1,10); // new interface .. 
plot(p1,wait=1,fill=1);
metisnodal(nupart,Th,30);

for(int i=0;i<nupart.n;++i)
  part[][i]=nupart[i];
plot(part,fill=1,cmm="nodal",wait=1);

metisdual(nupart,Th,30);
for(int i=0;i<nupart.n;++i)
  part[][i]=nupart[i];
plot(part,fill=1,cmm="dual",wait=1);
bool fast=true;
load "mat_dervieux";  // external module in C++ must be loaded
border a(t=0, 2*pi){ x = cos(t); y = sin(t);  }
mesh th = buildmesh(a(100));
fespace Vh(th,P1);

Vh vh,vold,u1 = y, u2 = -x;
Vh v = exp(-10*((x-0.3)^2 +(y-0.3)^2)), vWall=0, rhs =0;

real dt = 0.025;
// qf1pTlump means mass lumping is used
problem  FVM(v,vh) = int2d(th,qft=qf1pTlump)(v*vh/dt)
                  - int2d(th,qft=qf1pTlump)(vold*vh/dt)
      + int1d(th,a)(((u1*N.x+u2*N.y)<0)*(u1*N.x+u2*N.y)*vWall*vh)
+ rhs[] ;


matrix A;
MatUpWind1(A,th,vold,[u1,u2]);
if(fast)
  {
    varf  vFVM(v,vh) = int2d(th,qft=qf1pTlump)(v*vh/dt)
      - int1d(th,a)(((u1*N.x+u2*N.y)<0)*(u1*N.x+u2*N.y)*vWall*vh)      ;
    real[int] rhs0=vFVM(0,Vh);
    matrix M=vFVM(Vh,Vh,solver=CG);
    A=-A+M;

    for ( real t=0; t< pi ; t+=dt)
      {
	vold=v;
        rhs[]=rhs0;
	rhs[] += A * vold[] ;
	v[]= M^-1*rhs[];
	plot(v,wait=0);
      }
  }
else
for ( real t=0; t< pi ; t+=dt){
  vold=v;
  rhs[] = A * vold[] ;
  FVM;
  plot(v,wait=0);
};
load "distance"
mesh Th;
Th=square(100,100);
if(1)
{
	mesh Th2;
	mesh3 Th3;
	int ltube=1,lup=3,lout=4,lin =2;
	int l3d = 5;
	real D3d=1; 
	{
	int Nbtube= 4; 
    
	real Dx=1,Dy=1,La=3*Dx,Lh=5*Dy;

	int Ndx=19,Ndy=19, Nh=(Lh-Dy)*Ndy/Dy,Na=(La-Dx)*Ndx/Dx ;     

	mesh Th0;
	{
	    int[int] ll0=[1,0,0,1];
	    int[int] llv=[0,1,2,1];
	    int[int] llvv=[0,1,4,1];
	    int[int] llh=[1,3,1,0];
	 Th0 = square(Ndx,Ndy,[x*Dx,y*Dy],label=ll0); 
	mesh Thv = square(Ndx,Nh,[x*Dx,Dy+y*(Lh-Dy)],label=llv); 
	mesh Thvv = square(Ndx,Ndy,[x*Dx,Lh+y*(Dy)],label=llvv); 
	mesh Thh = square(Na,Ndy,[Dx+x*(La-Dx),y*Dy],label=llh); 

	Th=Th0+Thv+Thh;
	Th0=Th;
	Th=Th+Thvv;
	plot(Th,wait=1);
	}

	for(int i=1; i< Nbtube; ++i)
	   Th=Th + movemesh(Th0,[x+La*i,y]);
	   int[int] llabel=[1,ltube,2,lup,3,lout,4,lin] ;
	 Th=change(Th,label=llabel,rmInternalEdges=1);  
	}
	plot(Th,wait=1);
}
fespace Vh(Th,P1);
Vh u = y-0.500; 
u = 0.400-max(abs(x-y),abs(-1.+x+y));
plot(u, dim=3, value=1); 
Vh v=u;
//verbosity=100; 
//cout << v[] << endl; 

distance(Th,u,v[],distmax=100);

real[int] v0 = [-10,-1,-0.01,0,0.01,1,10];
plot(u,wait=1,viso=v0);
plot(v,wait=1,cmm="distance",nbiso=100);
/*

Boggus exemples => No time to correct

See J-M Mirebeau FH 2017 ..

a first correction

--- a/examples/plugin/GeometryQA.cpp    Fri Dec 01 16:53:54 2017 +0100
+++ b/examples/plugin/GeometryQA.cpp    Wed Dec 06 10:05:54 2017 +0100
@@ -376,6 +376,7 @@
     Edge **minEdge= new Edge *[nv_iso]();
     Edge **maxEdge= new Edge *[nv_iso]();
     R2   *eigenVec= new R2[nv_iso];
+    cout << " nv = " << nv() << endl;
     for(int i=0; i<nv_iso; i++) eigenVec[i]=vertices[i].getm().eigensys();

     for(int i=0; i<ne_iso; i++){
@@ -400,10 +401,11 @@
     for(int i=0; i<ne_iso; i++){
         Edge *e=&edges[i];
         if(!e->isRepresentative()) continue;
-
+        cout << " nv = " << nv() << " " << ne_oriented() << endl;
+
         const int indexu = vertices.index(e->getu()), indexv = vertices.index(e->getv());
-        bool extru= (e==minEdge[indexu]) || (e==maxEdge[indexu]);
-        bool extrv= (e==minEdge[indexv]) || (e==maxEdge[indexv]);
+        bool extru= indexu<nv_iso && ( (e==minEdge[indexu]) || (e==maxEdge[indexu]));
+        bool extrv= indexv<nv_iso && ( (e==minEdge[indexv]) || (e==maxEdge[indexv]));

         if(!extru && !extrv) continue;
         Edge *const f=e->hRefine2(h, edges, vertices, metric, NULL); //non recursive split.

but after ...

		CheckPtr:  erreur delete []
		CheckPtr:  erreur delete []
Triangulation::hRefineQA : Intermediate anisotropic triangulation contains 540 triangles.
Triangulation::hRefineQA : Final triangulation contains 547 triangles after refinement of the boundary.
Exporting edges
  current line = 14
Assertion fail : (area>0)
	line :281, in file ./../femlib/fem.hpp
Assertion fail : (area>0)
	line :281, in file ./../femlib/fem.hpp
 err code 5 ,  mpirank 0
Process 26872 exited with status = 5 (0x00000005)
*/
load "FreeFemQA"


mesh Th=square(1,1,[x,y]);

func scal = 1/(x+0.2)^2;

//func scal = 5;

func mxx=100*scal;
func mxy=0;
func myy=scal;

Th=adaptmesh(Th,4*scal,0,4*scal,IsMetric=true);
Th=MeshGenQA(Th,mxx,mxy,myy,exportToMathematica=true,exportMetricToMathematica=true,finalRefine=false);
plot(Th,wait=true,ps="o/IsoFFMesh.ps");

//Th=readmesh("triQA.msh");
plot(Th,ps="o/QAMesh.ps");


//mesh Th=readmesh("/Users/jean-mariemirebeau/Library/Developer/Xcode/DerivedData/DelaunayFlip-deaxqdiomhuvirblsdlxiubujmam/Build/Products/Debug/Th.msh");
//plot(Th);

//Le sens Geometry->FF a l'air de marcher.
//Maintenant, il faut le sens inverse.

//mesh Th=square(1,1,[x,y]);
//savemesh(Th,"ThFF.msh");


;
load "bfstream"

real[int] b(10), bb(1);
for (int i = 0; i < b.n; ++i)
	b[i] = i+pi;
cout << " " << b << endl;
int kk=100;
{
	ofstream f("bfstreamExample.dt",binary);
	f.write(134);
	f.write(1.346888);
	f.write(b);
	f.write(kk);
	writeint(f,10);
}
b = 0;

{
	real r;
	int i,kk,i4;
	ifstream f("bfstreamExample.dt",binary);
	f.read(i);
	f.read(r);
	f.read(bb);
	f.read(kk);
	readint(f,i4);
	
	cout << i << " " << r << " "<< i4 <<  endl;
	cout << bb << endl;
	//cout << b << endl;
}
// (M. Bonazzoli, Nov 2015)

load "msh3"
load "medit"
load "Element_Mixte3d" //for Edge13d
//load "P012_3d_Modif" //for Edge13d (my file)

// The boundary value problem:
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

// Mesh data
int nloc = 4;        // number of segments on the smallest dimension
real a = 0.00254, b = 0.00127, c = 0.01;    // dimensions of the waveguide
//real a = 0.00254, b = 0.00127, c = 0.005;   

// Build the mesh
include "cube.idp"
int mx, my, mz;      // to decide the number of seg in the 3 directions 
mx = a/min(a,b);
my = b/min(a,b);
mz = c/min(a,b);
int[int] NN = [mx*nloc, my*nloc, mz*nloc];  // the number of seg in the 3 directions 
int guide = 1, in = 2, out = 3;             // labels for the waveguide
real [int,int] BB = [[0,a],[0,b],[0,c]];    // bounding box
int [int,int] L = [[guide,guide],[guide,guide],[in,out]];  // labels of the 6 parallelipiped faces
mesh3 Th = Cube(NN,BB,L);                   // build the mesh
//medit("mesh", Th);                        // plot the mesh

// Sol data
real f = 94*10^9;                  // frequence (I think omega=2*pi*f)
real er = 1;                       // dielectric constant
real c0 = 299792458;               // speed of light in vacuum
real k = 2*pi*f*sqrt(er)/c0;       // it's the wavenumber if mu_r=1
int m = 1, n = 0;
real beta = sqrt(k^2-(m*pi/a)^2-(n*pi/b)^2); // it comes from the dispersive relation
// (we assume E(x,y,z) = Etilde(x,y)*exp(-i*beta*z))
real Z = sqrt(er)*120*pi; // ?                        

real ukb = 1/(k^2-beta^2);
func expbz = exp(-1i*beta*z);
func ExTE = (1i*k*Z)*ukb*(n*pi)/b*cos(m*pi*x/a)*sin(n*pi*y/b)*expbz;  // (ricorda: k*Z = mu*omega)
func EyTE = -(1i*k*Z)*ukb*(m*pi)/a*sin(m*pi*x/a)*cos(n*pi*y/b)*expbz;
// For the impedance condition at the waveguide entrance:
func Gix = +2*1i*beta*ExTE;                       
func Giy = +2*1i*beta*EyTE;    
func Giz = 0;
// the sign here is + and in the variational formulation it is - int2d(Th,in)(Ginc*v) (all is written on the lhs)

// Finite element space
fespace Nh(Th, Edge23d);
// Edge13d: edge finite elements of degree 2
// (I called the space I introduced like this because the Nedelec elements of degree 1 are called Edge03d)
Nh<complex> [Ex,Ey,Ez], [vx,vy,vz];   // define the vector field and the test function
// (edge elements are vector elements and they give a subspace of Hcurl)

// Macros
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro Nvec(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM //uxN 
macro Curlabs(ux,uy,uz) [abs(dy(uz)-dz(uy)),abs(dz(ux)-dx(uz)),abs(dx(uy)-dy(ux))] //EOM

// Variational formulation of the problem to solve
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

problem waveguide([Ex,Ey,Ez], [vx,vy,vz], solver=sparsesolver) =
                  int3d(Th)(Curl(Ex,Ey,Ez)'*Curl(vx,vy,vz))
                - int3d(Th)(k^2*[Ex,Ey,Ez]'*[vx,vy,vz])
                + int2d(Th,in,out)(1i*beta*Nvec(Ex,Ey,Ez)'*Nvec(vx,vy,vz))
                - int2d(Th,in)([vx,vy,vz]'*[Gix,Giy,Giz])   
                + on(guide,Ex=0,Ey=0,Ez=0);      
waveguide;  // solve the problem

Nh<complex> [Eex,Eey,Eez] = [ExTE,EyTE,0]; // the exact solution
Nh<complex> [Errx,Erry,Errz]; // the error wrt the exact solution
[Errx,Erry,Errz] = [Eex,Eey,Eez]-[Ex,Ey,Ez];

// Norm of the exact solution
real Hcurlerrsqex, Hcurlerrex, L2errsqex, L2errex;
L2errsqex = int3d(Th)(abs(Eex)^2+abs(Eey)^2+abs(Eez)^2);
Hcurlerrsqex = int3d(Th)(Curlabs(Eex,Eey,Eez)'*Curlabs(Eex,Eey,Eez))+L2errsqex;
Hcurlerrex = sqrt(Hcurlerrsqex);
L2errex = sqrt(L2errsqex);
cout << "Hcurl norm of the exact solution = " << Hcurlerrex << endl;
cout << "L2 of the exact solution = " << L2errex << endl << endl;

// Norm of the error
real Hcurlerrsq, Hcurlerr, L2errsq, L2err;
L2errsq = int3d(Th)(abs(Errx)^2+abs(Erry)^2+abs(Errz)^2);
Hcurlerrsq = int3d(Th)(Curlabs(Errx,Erry,Errz)'*Curlabs(Errx,Erry,Errz))+L2errsq;
Hcurlerr = sqrt(Hcurlerrsq);
L2err = sqrt(L2errsq);
cout << "Hcurl norm of the error = " << Hcurlerr << endl;
cout << "L2 norm of the error = " << L2err << endl << endl;

// Relative errors
cout << "relative Hcurl norm of the error = " << Hcurlerr/Hcurlerrex << endl;
cout << "relative L2 norm of the error = " << L2err/L2errex << endl << endl;

// Plot the real part of the solution
medit("real",Th,[real(Ex),real(Ey),real(Ez)]); // in the medit window press h=help, m=data!!

load  "meshtools" 
load "msh3"
mesh Th= square(10,10)+ square(10,10,[x+1,y+1]);
mesh3 Th3= cube(2,2,2)+ cube(3,3,3,[x+2,y+3,z+1]);
int[int] cc;
int nbc; 
nbc =ConnectedComponents(Th,cc); //  data on element of the open  set  
cout << " nb cmp cnx = " << nbc << " size of data " << cc.n <<endl; 
nbc =ConnectedComponents(Th,cc,closure=1); //  data on element of the closure set   
cout << " nb cmp cnx = " << nbc << " size of data " << cc.n <<endl; 
nbc =ConnectedComponents(Th,cc,vertices=1); //  data on vertices  
cout << " nb cmp cnx = " << nbc << " size of data " << cc.n << endl; 


fespace Vh(Th,P1);
fespace Ph(Th,P0);
Vh c;
Ph p;
nbc =ConnectedComponents(Th,c[],vertices=1);
 cout << " vertex/ nb cmp cnx = " << nbc << endl; 
 nbc =ConnectedComponents(Th,p[]);
  
plot(c,wait=1,fill=1,cmm="per vertex");
plot(p,wait=1,fill=1,cmm="per adj");


fespace Vh3(Th3,P0);
Vh3 d;
 nbc =ConnectedComponents(Th3,d[]);
 cout << " nb cmp cnx = " << nbc << endl; 
load "Element_HCT"
load "qf11to25" // for tripleQF function

// Parameter
real f = 1;

// Mesh
mesh Th = square(40, 40); //mesh definition of Omega

// Fespaces
fespace Wh(Th, P2);
fespace Vh(Th, HCT);	// HCT finite element space
Vh [u, ux, uy], [v, vx, vy];

// Macro
macro bilaplacien(u, v) (dxx(u)*dxx(v) + dyy(u)*dyy(v) + 2.*dxy(u)*dxy(v))	// end of macro

// Problem
// WARNING: the quadrature formula must be defined on 3 sub triangles
// the function tripleQF build this king of formula from classical quadrature
QF2 qfHCT5 = tripleQF(qf5pT);
solve bilap ([u, ux, uy], [v, vx, vy])
	= int2d(Th, qft=qfHCT5)(bilaplacien(u, v))
	- int2d(Th)(f*v)
	+ on(1, 2, 3, 4, u=0, ux=0, uy=0)
	;

// Plot
plot(u, cmm="u", wait=1, fill=1);
plot(ux, wait=1, cmm="u_x");
plot(uy, wait=1, cmm="u_y");

// Max & Error
Wh uu = u;
real umax = uu[].max;
int err = (abs(umax-0.0012782) > 1e-4);
cout << " uu max = " << umax << " ~ 0.0012782, err = " << err << endl;

// Plot
int n = 100, nn = n+10;
real[int] xx(nn), yy(nn);
for (int i = 0; i <= n; i++) {
	xx[i] = real(i)/n;
	yy[i] = u(0.5, real(i)/n);	// value of uh at point (0.5, i/10.)
}
plot([xx(0:n), yy(0:n)], wait=1);

// End
assert(err == 0);

load "PARDISO" 
load "shell"
//if(ompgetnumthreads() < 2 & getenv("OMP_NUM_THREAD") =="" ) 
//  ompsetnumthreads(10);// set number of thread for PARDISO ..  
//cout << " OMP NUM THREAD = " << ompgetnumthreads()  << " " << ompgetmaxthreads() << endl;; 
int[int] l = [1, 1, 2, 2];
mesh Th = square(100, 100, label = l);
fespace Vh(Th, P1);
Vh u, v;
verbosity = 0;
varf lap(u,v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th)(v) + on(1, u = 1);
varf lapc(u,v) = int2d(Th)((1+1i)*dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th)((1+2i)*v) + on(1, u = 1+3i);
real[int] b = lap(0, Vh);
verbosity = 4;
matrix A = lap(Vh, Vh,solver = "PARDISO",sym=0);
matrix<complex>  C= lapc(Vh, Vh,solver = "PARDISO",sym=0);
matrix B = A;// Warning no solver set in this case => set solver ..
matrix Bspd = A;// Warning no solver set in this case => set solver ..
set(B, solver = "PARDISO",sym=1);// Warning this sym the matrix 
set(Bspd, solver = "PARDISO",sym=1,positive=1);// Warning this sym the matrix 




verbosity = 5;
Vh x;
x[] = A^-1 * b;
cout << " x min /max "<< x[].min << " "<< x[].max << endl;
plot(Th, x, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver unsymmetric", value = 1);

x[] = B^-1 * b;
plot(Th, x, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver symmetric", value = 1);
x[] = Bspd^-1 * b;
plot(Th, x, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver  spd", value = 1);
Vh<complex>  c;
complex[int] bc=lapc(0,Vh); 
c[]= C^-1*bc;
plot(Th, c, wait = 1, dim = 3, fill = 1, cmm = "sparsesolver  complex spd", value = 1);

load "Element_P2pnc"
load "Element_P3dc"

 mesh Th=square(10,10);
 fespace Vh(Th,P2pnc);     // P2+ nc  in P FE space
 cout << " Vh.ndof = "<< Vh.ndof << endl;
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 varf vLap(uh,vh) =                    //  Definion of  the problem
    int2d(Th)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
   - int2d(Th)( f*vh )                          //  linear form
   + on(1,2,3,4,uh=g) ;                      //  boundary condition form
  ;
  matrix A = vLap(Vh,Vh,solver="SPARSESOLVER");
  real[int] b= vLap(0,Vh);
  //cout << A << endl;
  uh[]=A^-1*b ;// solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP2pnc.eps",value=true);
load "Element_P4"
load "lapack"
load "qf11to25"

include "CC.idp"

int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];
// the fonctions bubble 
int[int] k6=[4,5,  9, 11, 15,16 ]; 
//  the edges function 
int[int] Be=[1,3,2, 8,10,6, 12,17,13];

func NN=[N.x,N.y];

// the ref triangle 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);
//  the 2 base vector [Cx,Cy] for interior DoF
real[int] Dx= [Th(2).x-Th(0).x, Th(0).x-Th(1).x];// 1: 20 et 2: 01 
real[int] Dy= [Th(2).y-Th(0).y, Th(0).y-Th(1).y];
real dJ1 =1/Th.area/2;
real[int] Cx=  Dy*-dJ1;
real[int] Cy=  Dx*dJ1;


fespace Rh(Th,RT0);
fespace P1h(Th,P1); 
fespace Ch(Th,[P4,P4]);// To store momoe function
Rh[int] [phi1,phi2](3);
P1h[int] l(3);

macro pp(i,j)  (l[i]*l[j])// P2 monome
	real err =0;

// Build phi and l basic functions 
real[int] sgf=[1,-1,1];
for(int i=0;i<3;++i)
{
l[i][]=0;     l[i][][i]=1;
phi1[i][]=0;  phi1[i][][i]=sgf[i];
}
Ch[int]  [b1,b2](6*3); //  build all momone functions
int [int,int] bii(18,3);

{   
	int k=0;   
	for(int i=0; i<3;++i)
	  for(int e=0; e<2;++e)//  
	    for(int j=0; j<3;++j)//  
	    {	
		int i1 = j, i2=j; //  sommet
		if(e) {i1 = ne1[j]; i2 =ne2[j];} // vertex of edge j
		bii(k,0) =i;
		bii(k,1) =i1;
		bii(k,2) =i2;
		[b1[k],b2[k]]= [phi1[i],phi2[i]]*pp(i1,i2);
		k++;
		}
}


real[int,int] Cb(15,6); //  coef of monone too be with mass mod 0
Ch[int] [Fb1,Fb2](15);  // the mono funct for verif.
{
	real[int,int] A(18,6);
	for(int i=0;i<18; ++i)
	  for(int j=0;j<3; ++j)
	   for(int k=0;k<2; ++k)
	     A(i,2*j+k) = int2d(Th)( [b1[i],b2[i]]'*[Cx[k],Cy[k]]*l[j]);

	real[int,int]  C(6,6),C1(6,6) ; 

	for( int j=0; j<6; ++j)// ligne 
	 for( int l=0; l<6; ++l)
	  C(j,l)= A(k6(l),j);
	C1=C^-1;


	for( int i=0; i<9; ++i)
	{
		int ki = Be[i];
		real[int] a6(6),b6(6);//
		for( int j=0; j<6; ++j)// ligne
		   b6(j)= -A(ki,j) ;
		a6 = C1*b6;
		Cb(i,:)=a6;
	}
	for( int i=0; i<6; ++i)
	 Cb(9+i,:)=C1(:,i);

	// les fonction bases

	for(int i=0; i< 15; ++i)
	{
		Ch [F1,F2];
		F1[]=0.; 
		if( i<9) 
			F1[] = b1[Be[i]][]; 
		for(int k=0; k< 6; ++k) // 
		  F1[] +=  Cb(i,k)*b1[k6[k]][];
		Fb1[i][]=F1[]; 
	}
}
//  Verif DOF 
// Les flux 
real[int][int] sigma(15);// To store all Dof linear form 
real[int,int] C1(3,3);// the DOf on edge 
{
	real[int,int] CC=[[ 24 , 6 , 4],[6,4,6],[4 , 6  ,24]];//   
	CC /= 120.;
	C1 = CC^-1; 
	int dof =0;
	// Edge dof 
	for (int i=0; i<3; ++i)
	{  	
		int i1 = ne1[i], i2 =ne2[i];
		for(int k=0;k<3;++k)
		{
			int kk = i*3+k;
			func FF=[Fb1[kk],Fb2[kk]];
			
			func fl = C1(0,k)*pp(i1,i1) 
			        + C1(1,k)*pp(i1,i2) 
					+ C1(2,k)*pp(i2,i2);
	
		    varf vdof([uu,vv],[u1,u2]) = int1d(Th,i,qforder=10)( fl*([u1,u2]'*[N.x,N.y]));
			sigma[dof].resize(Ch.ndof);
			sigma[dof++] = vdof(0,Ch);
	    }		
	}
	// Internal Dof 
	for (int j=0; j<6; ++j)
	   {
		   int i=j/2;
		   int k=j%2; 
		   varf vdof([uu,vv],[u1,u2]) = int2d(Th)( l[i]*[u1,u2]'*[Cx[k],Cy[k]]);
		   sigma[dof].resize(Ch.ndof);
		   sigma[dof++] =vdof(0,Ch);
	   }
	   assert(dof==15);
	   //  Check the if DoF and B.F are OK

	   for(int i=0; i<15; ++i)
	   {
	     for(int j=0; j<15; ++j)
		 {
			 real dij = Fb1[i][]'*sigma[j];
			 err = err+ abs( dij-(i==j));
			 cout << c00(dij) << " " ; 
		 }
		 cout << " err=" << err << endl;
       }
	   
}
// data Genaration for  FF++
CCt("cf",Cb); 
CCt("Bii",bii); 
CC("fe",Be);
CC("k6",k6);

CC("c1",C1);
cout << endl;
assert(err< 1e-10); 
include "cube.idp"
load "medit"
int[int, int] LL = [[2,2], [1,1], [1,1]];
real[int, int] BB = [[0,1], [0,1], [0,1]];
int[int] CC = [4, 4, 4];
load "splitmesh12"
mesh3 Th3=Cube(CC, BB, LL);
mesh3 Th12=splitmesh12(Th3);
assert(Th12.nt == Th3.nt * 12);
cout << Th12.nt << " == 12 x " << Th3.nt << endl;
assert(Th12.nbe == Th3.nbe * 3);
cout << Th12.nbe << " == 3 x " << Th3.nbe << endl;
plot(Th3, cmm="Th3", wait=1);
plot(Th12, cmm="Th12", wait=1);
fespace Vh(Th12, P1);
Vh xyz = x + y + z;
medit("splitmesh12",Th12,xyz);
load "medit"
load "iohdf5"
include "cube.idp"
load "iovtk"
verbosity=2;
int[int]  Nxyz=[20,5,5];
real [int,int]  Bxyz=[[0.,5.],[0.,1.],[0.,1.]];
int [int,int]  Lxyz=[[1,2],[2,2],[2,2]];
mesh3 Th=Cube(Nxyz,Bxyz,Lxyz);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;

fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM

solve Lame([u1,u2,u3],[v1,v2,v3])=
  int3d(Th)(  
	    lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) //')
	      )
  - int3d(Th) (gravity*v3)
  + on(1,u1=0,u2=0,u3=0)
  ;
real dmax= u1[].max;
cout << " max deplacement = " << dmax << endl;
real coef= 0.1/dmax;
int[int] ref2=[1,0,2,0];
mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2);
Thm=change(Thm,label=ref2);
plot(Th,Thm, wait=1,cmm="coef  amplification = "+coef );

savemesh(Thm,"beam-3d-def.mesh.h5");
savehdf5sol("beam-3d-def.sol.h5",Thm,u1,"ux",[u1,u2,u3],"U",(epsilon(u1,u2,u3)),"eps");
load "isoline"
load "msh3"
real[int,int] xy(3,1);
int[int] be(1);
{
mesh Th=square(10,10);//,[x*.5,y*0.5]);
fespace Vh(Th,P1);
Vh u= sqrt(square(x-0.5)+square(y-0.5));
real iso= 0.2 ;
real[int] viso=[iso];
plot(u,viso=viso,Th);

int nbc= isoline(Th,u,xy,close=1,iso=iso,beginend=be,smoothing=0.0);
/*

  	iso =  value of the iso to compute
	close =  close the iso line this the border (def. 0). 
       smoothing =  nb of smoothing process =  smoothing * len curve ^ratio  
                (def. 0.) 
	   ratio =  (def. 1.) 
	eps =  relative eps (see code ??)  (def 1e-10 )
	beginend =  array to get begin end of sub line 
	file =  filename 

	remark:
        sense  of the  isoline :  the upper part is a the left part  isoline 
        so here : the minimiun is a 0.5,05 => the curve 1 turn in the clockwise sense 
*/
cout << " nb of the line  componant   = " << nbc << endl; 
cout << " n = " << xy.m << endl; // nombre of points 
cout << "be = " << be << endl; //  begin end of the componant

// show the lines 
for( int c=0;c<nbc; ++c) 
{
    int i0 = be[2*c], i1 = be[2*c+1]-1; // begin and end  the  connexe line comp. c       
    if(verbosity>4)          
    for(int i=i0; i<= i1; ++i)
       cout << " x = " <<  xy(0,i) << " y =  " << xy(1,i) << " s =  " << xy(2,i) << endl; 
    plot([xy(0,i0:i1),xy(1,i0:i1)],wait=1,viso=viso,cmm = " curve "+c);
}

border Curve2(t=0,1;i) 
{ int c =i; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 
int[int] NN(nbc);
for(int c=0;c<nbc;++c)
{
        int i0 = be[2*c], i1 = be[2*c+1]-1;   
	
	NN(c)=i1-i0;
}
plot(Curve2(NN),wait=1,cmm="2d nbc="+nbc);

}


cout << " len of the curve 1 = " << xy(2,xy.m-1) << endl;; 


border Curve0(t=0,1) 
{ int c =0; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 

border Curve1(t=0,1) 
{ int c =1; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 

plot(Curve1(100)); 
mesh Th= buildmesh(Curve1(-100));
plot(Th,wait=1);

//  test sur meshS 
{
meshS Th=square3(10,10,[0,x,y]);//,[x*.5,y*0.5]);
fespace Vh(Th,P1);
Vh u= sqrt(square(y-0.5)+square(z-0.5));
real iso= 0.2 ;
real[int] viso=[iso];
plot(u,viso=viso,Th);

int nbc= isoline(Th,u,xy,close=1,iso=iso,beginend=be,smoothing=0.0);

border Curve2(t=0,1;i) 
{ int c =i; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 
// pour afficher toute les iso !!!!
int[int] NN(nbc);
for(int c=0;c<nbc;++c)
   NN(c)=be[2*c+1]-1-be[2*c];

plot(Curve2(NN),wait=1,cmm="nbc="+nbc);

cout << " nb of the line  componant   = " << nbc << endl; 
cout << " n = " << xy.m << endl; // nombre of points 
cout << " m = " << xy.n << endl; // nombre of data 
cout << "be = " << be << endl; //  begin end of the componant

// show the lines 
for( int c=0;c<nbc; ++c) 
{
    int i0 = be[2*c], i1 = be[2*c+1]-1; // begin and end  the  connexe line comp. c  
    if(verbosity>4)      
    for(int i=i0; i<= i1; ++i)
       cout << " x = " <<  xy(0,i) << " y =  " << xy(1,i) << " " << xy(2,i) << " s =  " << xy(3,i) << endl; 
    plot([xy(0,i0:i1),xy(1,i0:i1),xy(2,i0:i1)],wait=1,viso=viso,cmm = " curveS "+c);
}
border Curve1(t=0,1) 
{ int c =1; 
  int i0 = be[2*c], i1 = be[2*c+1]-1;   
  P=Curve(xy,i0,i1,t); 
  label=1; 
} 
meshL ThL= buildmeshL(Curve1(-100));
plot(ThL,wait=1,cmm="ThL");

include "buildmeshS.idp"
meshS ThS= buildmeshS(ThL,1,1);
plot(ThS,cmm="ThS",wait=1);


}
// -*- FreeFem++ -*-
// Sample of SaveHB
// Author: fujiwara@acs.i.kyoto-u.ac.jp
mesh Th = square(3,3);
macro Grad(u) [dx(u),dy(u)] // EOM

fespace Vh(Th,P1);
varf vP(u,v) = int2d(Th)(Grad(u)'*Grad(v)) + int2d(Th)(v) + on(1,u=1);

matrix<complex> A = vP(Vh,Vh);
complex[int] rhs = vP(0,Vh);

load "SaveHB" 
int ret = SaveHB("sample_z.hb", A, rhs, "sample of SaveHB");

cout << " A = " << A << endl;
cout << " rhs  = " << rhs << endl;

assert(ret == 0); 

// End of file
//  Fluid-structure interaction for a weighting beam sitting on a
// square cavity filled with a fluid.
load "iohdf5"
int bottombeam = 2;
border a(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
border b(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
border c(t=0,2)  { x=10; y=t ;label=1;};       //  rigth beam
border d(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
real E = 21.5;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
mesh th = buildmesh( b(20)+c(5)+d(20)+a(5));
fespace Vh(th,[P1,P1]);
Vh [uu,vv], [w,s];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 
// definition of 2 macro :
real sqrt2=sqrt(2.);
macro epsilon(u1,u2)  [dx(u1),dy(u2),(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u,v) ( dx(u)+dy(v) ) // EOM

solve bb([uu,vv],[w,s],solver=CG)=
	int2d(th)(  
		  lambda*div(w,s)*div(uu,vv)	
                  +2.*mu*( epsilon(w,s)'*epsilon(uu,vv) ) 
                 )
  - int2d(th) (gravity*s)
  + on(1,uu=0,vv=0)
  ;

//verbosity=100;
plot([uu,vv],wait=1);
plot([uu,vv],wait=1,bb=[[-0.5,2.5],[2.5,-0.5]]);
mesh th1 = movemesh(th, [x+uu, y+vv]);
plot(th1,wait=1);
cout << " max deplacement = " << uu[].linfty << endl;
savemesh(th1,"beam-2d-def.mesh.h5");
savehdf5sol("beam-2d-def.sol.h5",th1,uu,"uu",[uu,vv],"U",(epsilon(uu,vv)),"eps");
load "ff-Ipopt"
int bfgs=0,constraint =1; // aglo .. 
real x0=1.5,y0=0.5; 
mesh Th=square(10,10,[x+1,y]);
fespace Vh(Th,P2);
func g = cos(pi*x)*cos(pi*y);; //acosh(sqrt(x*x+y*y));//cos(pi*x)*cos(pi*y);
Vh ue= g;
macro grad(u) [dx(u),dy(u)]//EOM
func real J(real[int]& X)
{
    Vh u; u[]=X;
    return int2d(Th)(sqrt(1+grad(u)'*grad(u))) ;
}

func real[int]  DJ(real[int]& X)
{
    Vh u; u[]=X;
   
    varf vg(uu,v) = int2d(Th)((grad(u)'*grad(v)) / sqrt(1+grad(u)'*grad(u))) ;
   real[int] G= vg(0,Vh); 
    return G;}
matrix H;//global vairable for Hessien matrix Overwise  => seg fault in Ipopt     
func matrix  HJ(real[int]& X)
{
    Vh u; u[]=X;   
    varf vH(v,w) = int2d(Th)( (grad(w)'*grad(v)) / sqrt(1+grad(u)'*grad(u)) 
     - (grad(w)'*grad(u))*(grad(v)'*grad(u)) *(1+grad(u)'*grad(u))^-1.5 ) ;
    H = vH(Vh,Vh); 
    return H;}  
       
    
varf OnGamma(u,v) = on(1,2,3,4,u=1); 
Vh OnG;
OnG[]=OnGamma(0,Vh,tgv=1); // 1 on Gamma 
Vh lb = OnG!=0 ? g : -1e19 ; // 
Vh ub = OnG!=0 ? g :  1e19 ; //  
Vh u = OnG!=0  ? g : 0 ; //  initial guest ..
Vh clb = 3-square(10*(square(x-x0)+square(y-y0))); //  constraint .. 
if(constraint) lb = max(lb,clb); 
int ret;
if(bfgs) 
  ret = IPOPT(J,DJ,u[],lb=lb[],ub=ub[],bfgs=1); 
else 
  ret = IPOPT(J,DJ,HJ,u[],lb=lb[],ub=ub[]); 

cout << " min = "  << J(u[]) << "  ~ " << J(ue[]) << " ret = " << ret << endl; 
plot(u, wait=1);
load "ff-NLopt"

//A brief script to demonstrate how to use the freefemm interfaced nlopt routines
//The problem consist in solving a simple variational inequality using one of the
//optimization algorithm of nlopt. We restart the algorithlm a few times agter
//performing some mesh adaptation to get a more precise output.
int kas = 3; //    choose of the algo ...

int NN = 6;
mesh Th = square(NN,NN);
func f1=1.;
func f2=-1.;
func g1=0.;
func g2=0.1;
int iter=0;
int nadapt=2;
real starttol=1e-6,bctol=6.e-12;
fespace Vh(Th,P1);
Vh oldu1,oldu2;


for(int al=0;al<nadapt;++al)
{
	
varf BVF(v,w) = int2d(Th)(0.5*dx(v)*dx(w) + 0.5*dy(v)*dy(w));
varf LVF1(v,w) = int2d(Th)(f1*w);
varf LVF2(v,w) = int2d(Th)(f2*w);
matrix A =  BVF(Vh,Vh);
real[int] b1 = LVF1(0,Vh) , b2 = LVF2(0,Vh); 

varf Vbord(v,w) = on(1,2,3,4,v=1);
Vh In,Bord;
Bord[] = Vbord(0,Vh,tgv=1);
In[] = Bord[] ? 0:1;
Vh gh1=Bord*g1,gh2=Bord*g2;

func real J(real[int] &X)
{
	Vh u1,u2;
	u1[] = X(0:Vh.ndof-1);
	u2[] = X(Vh.ndof:2*Vh.ndof-1);
	iter++;
	real[int] Au1 = A*u1[], Au2 = A*u2[];
	Au1 -= b1;
	Au2 -= b2;
	real val = u1[]'*Au1 + u2[]'*Au2;
	if(iter %10==9) 
	plot(u1,u2,nbiso=30,fill=1,dim=3,cmm="adapt level " + al + " - iteration " + iter + " - J = " + val,value=1);
	return val;
}

varf dBFV(v,w) = int2d(Th)(dx(v)*dx(w)+dy(v)*dy(w));
matrix dA = dBFV(Vh,Vh);
func real[int] dJ(real[int] &X)
{
	Vh u1,u2;
	u1[] = X(0:Vh.ndof-1);
	u2[] = X(Vh.ndof:2*Vh.ndof-1);
	
	real[int] grad1 = dA*u1[], grad2 = dA*u2[];
	grad1 -= b1;
	grad2 -= b2;
	real[int] Grad(X.n);
	Grad(0:Vh.ndof-1) = grad1;
	Grad(Vh.ndof:2*Vh.ndof-1) = grad2; 
	return Grad;
}


func real[int] IneqC(real[int] &X)
{
	real[int] constraints(Vh.ndof);
	for(int i=0;i<Vh.ndof;++i) constraints[i] = X[i] - X[i+Vh.ndof];
	return constraints;
}
func real[int,int] dIneqC(real[int] &X)
{
	real[int,int] dconst(Vh.ndof,2*Vh.ndof);//so sparse... shame!
	dconst=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		dconst(i,i) = 1.;
		dconst(i,i+Vh.ndof) = -1.;
	}
	return dconst;
}

real[int] BordIndex(Th.nbe); //Indexes of border d.f.
{
	int k=0;
	for(int i=0;i<Bord.n;++i) if(Bord[][i]) {BordIndex[k]=i; ++k;}
}
func real[int] BC(real[int] &X)
{
	real[int] bc(2*Th.nbe);
	for(int i=0;i<Th.nbe;++i)
	{
		int I = BordIndex[i];
		bc[i] = X[I] - gh1[][I];
		bc[i+Th.nbe] = X[I+Th.nv] - gh2[][I];
	}
	return bc;
}
func real[int,int] dBC(real[int] &X)
{
	real[int,int] dbc(2*Th.nbe,2*Th.nv);//yet sparser...:(
	dbc=0.;
	for(int i=0;i<Th.nbe;++i)
	{
		int I=BordIndex[i];
		dbc(i,I) = 1.;
		dbc(i+Th.nbe,I+Th.nv) = 1.;
	}
	return dbc;
}


real[int] start(2*Vh.ndof),up(2*Vh.ndof),lo(2*Vh.ndof);

if(al==0)
{
	start(0:Vh.ndof-1) = 0.;
	start(Vh.ndof:2*Vh.ndof-1) = 0.01;//comment this two lines and uncomment what follows to use ub and lb
	/*Vh g1i=g1,g2i=g2;
	start(0:Vh.ndof-1) = g1i[];
	start(Vh.ndof:2*Vh.ndof-1) = g2i[]; */
}
else 
{
	start(0:Vh.ndof-1) = oldu1[];
	start(Vh.ndof:2*Vh.ndof-1) = oldu2[]; 
}
up=1000000;
lo=-1000000;
for(int i=0;i<Vh.ndof;++i)
{
	if(Bord[][i])
	{
		up[i] = gh1[][i] + bctol;
		lo[i] = gh1[][i] - bctol;
		up[i+Vh.ndof] = gh2[][i] + bctol;
		lo[i+Vh.ndof] = gh2[][i] - bctol;
	}
}

//Uncomment this to use ub and lb
if(kas<3){
  real[int] diff1 = start - lo , diff2 = up - start;
  for(int i=0;i<diff1.n;++i) 
   {
	if(diff1[i]<0) start[i]=lo[i];
	if(diff2[i]<0) start[i]=up[i]; 
   }
}

real mini=1e100;
if(kas==1)
   mini = nloptAUGLAG(J,start,grad=dJ,lb=lo,ub=up,IConst=IneqC,gradIConst=dIneqC,subOpt="LBFGS",stopMaxFEval=10000,stopAbsFTol=starttol);
else if(kas==2) 
 mini = nloptMMA(J,start,grad=dJ,lb=lo,ub=up,stopMaxFEval=10000,stopAbsFTol=starttol);
else if(kas==3) 
 mini = nloptAUGLAG(J,start,grad=dJ,IConst=IneqC,gradIConst=dIneqC,EConst=BC,gradEConst=dBC,subOpt="LBFGS",stopMaxFEval=200,stopRelXTol=1e-2);
else if(kas==4) 
 mini = nloptSLSQP(J,start,grad=dJ,IConst=IneqC,gradIConst=dIneqC,EConst=BC,gradEConst=dBC,stopMaxFEval=10000,stopAbsFTol=starttol);
Vh best1,best2;
best1[] = start(0:Vh.ndof-1);
best2[] = start(Vh.ndof:2*Vh.ndof-1);

Th = adaptmesh(Th,best1,best2,err=0.05);

oldu1=best1;
oldu2=best2;
}
load "Element_PkEdge"
// a macro the compute numerical derivative
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
mesh Th=square(1,1,flags=0,[10*(x+y/3),10*(y-x/3)]);
Th=square(1,1,flags=0   );
plot(Th,wait=1);
//savemesh(Th,"Th.msh");
real x1=0.4,y1=0.4;//10*(x+y/3),y1=10*(y-x/3), 
real h=1e-5 ;
int it1=Th(x1,y1).nuTriangle; 

// FFCS: store reference value
real regtest;

 macro Check(PkEdge)
{ 
  cout << " Test Finite Element " <<endl << endl;
  fespace Vh(Th,PkEdge);

  Vh a1,b1,c1;
  c1=x+y;
  real[int] viso(100);
  real v0= -100;
  real dv = 200./(viso.n+1);
  for(int i=0;i<viso.n;++i)
     viso[i]=v0+i*dv;
  plot(c1,fill=1,wait=1,viso=viso);
  for (int i=0;i<Vh.ndofK;++i)
    cout << i << " " << Vh(0,i) << endl;
  for (int i=0;i<Vh.ndofK;++i)
    {
      a1[]=0;	
      int j=Vh(it1,i);
      a1[][j]=1;
      plot(a1, wait=1); 
      b1=a1;/* do the interpolation */
      
      
      c1[] = a1[] - b1[];
      cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
      cout << " a = " << a1[] <<endl;
      cout << " b = " << b1[] <<endl;
      assert(c1[].max < 1e-9 && c1[].min > -1e-9); /* check if the interpolation is correct */
      
      /*  check the derivative and numerical derivative */
      /* no derivative in this element.  */
      
      
	cout << " dx(a1)(x1,y1) =  " << dx(a1)(x1,y1) << "  == " 
	   << DD(a1,h,0) << " DD " << " /  " 
	   << (a1(0.001,0.001) -  a1(0.999,0.999))/2 <<endl; 
	assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-4);
	assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-4);
	/*sassert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-5);*/
     
      
    } 
  regtest=a1'*a1;
}  //EOM

Check(P1edge)
Check(P2edge)
Check(P3edge)
Check(P4edge)
Check(P5edge)
// (M. Bonazzoli, Nov 2015)

load "msh3"
load "medit"
load "Element_Mixte3d" //for Edge13d
//load "P012_3d_Modif" //for Edge13d (my file)

// The boundary value problem:
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

// Mesh data
int nloc = 4;        // number of segments on the smallest dimension
real a = 0.00254, b = 0.00127, c = 0.01;    // dimensions of the waveguide
//real a = 0.00254, b = 0.00127, c = 0.005;   

// Build the mesh
include "cube.idp"
int mx, my, mz;      // to decide the number of seg in the 3 directions 
mx = a/min(a,b);
my = b/min(a,b);
mz = c/min(a,b);
int[int] NN = [mx*nloc, my*nloc, mz*nloc];  // the number of seg in the 3 directions 
int guide = 1, in = 2, out = 3;             // labels for the waveguide
real [int,int] BB = [[0,a],[0,b],[0,c]];    // bounding box
int [int,int] L = [[guide,guide],[guide,guide],[in,out]];  // labels of the 6 parallelipiped faces
mesh3 Th = Cube(NN,BB,L);                   // build the mesh
//medit("mesh", Th);                        // plot the mesh

// Sol data
real f = 94*10^9;                  // frequence (I think omega=2*pi*f)
real er = 1;                       // dielectric constant
real c0 = 299792458;               // speed of light in vacuum
real k = 2*pi*f*sqrt(er)/c0;       // it's the wavenumber if mu_r=1
int m = 1, n = 0;
real beta = sqrt(k^2-(m*pi/a)^2-(n*pi/b)^2); // it comes from the dispersive relation
// (we assume E(x,y,z) = Etilde(x,y)*exp(-i*beta*z))
real Z = sqrt(er)*120*pi; // ?                        

real ukb = 1/(k^2-beta^2);
func expbz = exp(-1i*beta*z);
func ExTE = (1i*k*Z)*ukb*(n*pi)/b*cos(m*pi*x/a)*sin(n*pi*y/b)*expbz;  // (ricorda: k*Z = mu*omega)
func EyTE = -(1i*k*Z)*ukb*(m*pi)/a*sin(m*pi*x/a)*cos(n*pi*y/b)*expbz;
// For the impedance condition at the waveguide entrance:
func Gix = +2*1i*beta*ExTE;                       
func Giy = +2*1i*beta*EyTE;    
func Giz = 0;
// the sign here is + and in the variational formulation it is - int2d(Th,in)(Ginc*v) (all is written on the lhs)

// Finite element space
fespace Nh(Th, Edge13d);
// Edge13d: edge finite elements of degree 2
// (I called the space I introduced like this because the Nedelec elements of degree 1 are called Edge03d)
Nh<complex> [Ex,Ey,Ez], [vx,vy,vz];   // define the vector field and the test function
// (edge elements are vector elements and they give a subspace of Hcurl)

// Macros
macro Curl(ux,uy,uz) [dy(uz)-dz(uy),dz(ux)-dx(uz),dx(uy)-dy(ux)] // EOM
macro Nvec(ux,uy,uz) [uy*N.z-uz*N.y,uz*N.x-ux*N.z,ux*N.y-uy*N.x] // EOM //uxN 
macro Curlabs(ux,uy,uz) [abs(dy(uz)-dz(uy)),abs(dz(ux)-dx(uz)),abs(dx(uy)-dy(ux))] //EOM

// Variational formulation of the problem to solve
// (sigma = 0, here k is the wavenumber) 
//  -k^2*E + curl(curl E) = 0	in Omega
//  E x n = 0	on x = 0, x = a, y = 0, y = b
//  Curl(E) x n + i*beta n x (E x n) = Ginc   on z = 0
//  Curl(E) x n + i*beta n x (E x n) = 0      on z = c

problem waveguide([Ex,Ey,Ez], [vx,vy,vz], solver=sparsesolver) =
                  int3d(Th)(Curl(Ex,Ey,Ez)'*Curl(vx,vy,vz))
                - int3d(Th)(k^2*[Ex,Ey,Ez]'*[vx,vy,vz])
                + int2d(Th,in,out)(1i*beta*Nvec(Ex,Ey,Ez)'*Nvec(vx,vy,vz))
                - int2d(Th,in)([vx,vy,vz]'*[Gix,Giy,Giz])   
                + on(guide,Ex=0,Ey=0,Ez=0);      
waveguide;  // solve the problem

Nh<complex> [Eex,Eey,Eez] = [ExTE,EyTE,0]; // the exact solution
Nh<complex> [Errx,Erry,Errz]; // the error wrt the exact solution
[Errx,Erry,Errz] = [Eex,Eey,Eez]-[Ex,Ey,Ez];

// Norm of the exact solution
real Hcurlerrsqex, Hcurlerrex, L2errsqex, L2errex;
L2errsqex = int3d(Th)(abs(Eex)^2+abs(Eey)^2+abs(Eez)^2);
Hcurlerrsqex = int3d(Th)(Curlabs(Eex,Eey,Eez)'*Curlabs(Eex,Eey,Eez))+L2errsqex;
Hcurlerrex = sqrt(Hcurlerrsqex);
L2errex = sqrt(L2errsqex);
cout << "Hcurl norm of the exact solution = " << Hcurlerrex << endl;
cout << "L2 of the exact solution = " << L2errex << endl << endl;

// Norm of the error
real Hcurlerrsq, Hcurlerr, L2errsq, L2err;
L2errsq = int3d(Th)(abs(Errx)^2+abs(Erry)^2+abs(Errz)^2);
Hcurlerrsq = int3d(Th)(Curlabs(Errx,Erry,Errz)'*Curlabs(Errx,Erry,Errz))+L2errsq;
Hcurlerr = sqrt(Hcurlerrsq);
L2err = sqrt(L2errsq);
cout << "Hcurl norm of the error = " << Hcurlerr << endl;
cout << "L2 norm of the error = " << L2err << endl << endl;

// Relative errors
cout << "relative Hcurl norm of the error = " << Hcurlerr/Hcurlerrex << endl;
cout << "relative L2 norm of the error = " << L2err/L2errex << endl << endl;

// Plot the real part of the solution
medit("real",Th,[real(Ex),real(Ey),real(Ez)]); // in the medit window press h=help, m=data!!

load "aniso"

// [m11, m12, m22]
real[int] M2 = [1, 0, 100];
// [m11, m21, m22, m31, m32, m33
real[int] M3 = [1, 0, 10, 0, 0, 100];

boundaniso(3, M2, 3);
cout << "M2 = " << M2 << endl;

boundaniso(6, M3, 2);
cout << "M3 = "<< M3 << endl;
//  Solver - Delta u = f , u < g et u = 0 on Gamma 
load "ff-Ipopt";
int nn=20;
mesh Th=square(nn,nn);
fespace Vh(Th,P2);

func f = 1.; //rhs function
real r=0.03,s=0.1; //some parameters for g
func g = r - r/2*exp(-0.5*(square(x-0.5)+square(y-0.5))/square(s));


macro Grad(u) [dx(u),dy(u)]//
varf vP(u,v) = int2d(Th)(Grad(u)'*Grad(v)) - int2d(Th)(f*v);

matrix A = vP(Vh,Vh,solver=CG);
real[int] b = vP(0,Vh);

// Warning the boundary condition are given with lb and ub on border
// equal value ... 
Vh u=0;
Vh lb=-1.e19;
varf vGamma(u,v) = on(1,2,3,4,u=1);
real[int] onGamma=vGamma(0,Vh);
Vh ub=g;
ub[] = onGamma ? 0. : ub[];
lb[] = onGamma ? 0. : lb[];

IPOPT([A,b],u[],lb=lb[],ub=ub[]);
Vh ubb =g;
plot(u,ubb,wait=1);

load "MetricKuate"
mesh Th=square(5,5,[(x-0.5)*2,(y-0.5)*2]);
real x0,y0;//  pour definir l'err  forme n lineare en x0,y0
real coef =1;
fespace Vh(Th,P1);
fespace Wh(Th,P2);
fespace Ph(Th,P0);
real c=10;

func f = tanh(c * (sin( (5 * y)) -  (2 * x))) +  (y * x * x) +   pow( y,  3);;

func fxxx = 0.16e2 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) - 0.32e2 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1);
func fxxy = -0.40e2 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) * cos( (5 * y)) + 0.80e2 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1) * cos( (5 * y)) + 0.2e1;
func fxyy = 0.100e3 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.2e1) - 0.200e3 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.2e1) - 0.100e3 * tanh(c * (sin( (5 * y)) -  (2 * x))) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * c * c * sin( (5 * y));

func fyyy = -0.250e3 * pow(0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1), 0.2e1) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.3e1) + 0.500e3 * pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * pow(c, 0.3e1) * pow(cos( (5 * y)), 0.3e1) + 0.750e3 * tanh(c * (sin( (5 * y)) -  (2 * x))) * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * c * c * cos( (5 * y)) * sin( (5 * y)) - 0.125e3 * (0.1e1 - pow(tanh(c * (sin( (5 * y)) -  (2 * x))), 0.2e1)) * c * cos( (5 * y)) + 0.6e1;

/*
real p=20;
real p3=p-3, p321=p*(p-1)*(p-2);
func f= x^p + y^p;
func fxxx = p321*x;
func fyyy = p321*y;
func fxxy=0.;
func fxyy=0.;
*/
func err=(fxxx*x0*x0*x0+3*fxxy*x0*x0*y0+3*fxyy*x0*y0*y0+fyyy*y0*y0*y0 )*coef;

for(int i=1;i<4;i++)
  {
    Vh m11,m12,m22;
    coef = 1;
    Wh f2=f;
    MetricKuate(Th,200,0.0001,3,err,[m11[],m12[],m22[]],[x0,y0]);
   // plot(m11,m22,wait=1,cmm="mmmm");
    real cc=10;
    Th=adaptmesh(Th,cc*m11,cc*m12,cc*m22,IsMetric=1,inquire=1,hmin=0.00001,nbvx=1000000);
    cout << m11[].max << " " << m12[].max << " " << m22[].max << endl;
    plot(Th,wait=1,ps="o/Th.eps");
    plot(f2,wait=1);
    Ph eh = (abs(f2-f));
    Ph leh= log10(eh);
    real[int] viso=[-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1];
    plot(leh,fill=1,wait=1,viso=viso,value=1,ps="o/leh.eps");
    cout << i << " .... " << eh[].min << " "<< eh[].max << " "<< eh[].sum/eh[].n << " "
         << int2d(Th)(eh)/Th.area << " " << Th.nt << " " << Th.nv << endl;
  }
   Th=square(5,5,[(x-0.5)*2,(y-0.5)*2]);

// FFCS - regression tests
real regtest;

 real cerr= 0.005*(0.000961606/0.000582183)^0.66;
  for(int i=1;i<4;i++)
  {
    Vh m11,m12,m22;
    coef = 1;
    Wh f2=f;

    real cc=10;
    Th=adaptmesh(Th,f,err=cerr,inquire=1,hmin=0.00001,nbvx=1000000);
    cout << m11[].max << " " << m12[].max << " " << m22[].max << endl;
    plot(Th,wait=1,ps="o/Th2.eps");
    plot(f2,wait=1);
    Ph eh = (abs(f2-f));
    Ph leh= log10(eh);
    real[int] viso=[-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1];
    plot(leh,fill=1,wait=1,viso=viso,value=1,ps="o/leh2.eps");
    cout << i << " .... " << eh[].min << " "<< eh[].max << " "<< eh[].sum/eh[].n << " "
         << int2d(Th)(eh)/Th.area << " " << Th.nt << " " << Th.nv << endl;
    regtest=eh[]'*eh[];//'
  }
// this exemple is buggus in some case ...
// strange ...  FH.  , S Auliac  (will be correct in test ???)
// remove the test  (no loop)  
int nadapt=0;//  3 is teh previous value..
load "msh3";
load "medit";
load "ff-Ipopt";

real alpha=0.9;
int np=30;
mesh Th = square(2*np,np,[2*pi*x,pi*y]);

// FFCS regression reference value
real regtest;

fespace Vh(Th,P1,periodic=[[2,y],[4,y]/*,[1,x],[3,x]*/]);

/*
 * Initial shape definition
 * outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations
 */

Vh startshape=5;//+0.5*(cos(10*x)*sin(10*y)*sin(y));

//uz,lz,lm : dual variables storage for the warmstart
Vh uz=1.,lz=1.;
real[int] lm=[1];



for(int kkk=0;kkk<nadapt;++kkk) //Mesh adaptation loop
{

int iter=0;
func sin2 = square(sin(y));

/*
 * A function which transform Th in 3d mesh (r=rho)
 * a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )
 * then displays the resulting mesh with medit.
 * (often crashs if some values of rho are negative or if freefem is compiled with debug)
 */
func int Plot3D(real[int] &rho,string cmm,bool ffplot)
{
	Vh rhoo;
	rhoo[]=rho;
	//mesh sTh = square(np,np/2,[2*pi*x,pi*y]);
	//fespace sVh(sTh,P1);
	//Vh rhoplot=rhoo;
	try
	{
		meshS Sphere = movemesh23(Th,transfo=[rhoo(x,y)*cos(x)*sin(y),rhoo(x,y)*sin(x)*sin(y),rhoo(x,y)*cos(y)]);
		if(ffplot) plot(Sphere);
		else medit(cmm ,Sphere,wait=0);
	}
	catch(...)
	{
		cout << "cant plot" << endl;
	}
	return 1;
}


/*
 * Surface computation
 * Maybe is it possible to use movemesh23 to have the surface function less complicated
 * However, it would not simplify the gradient and the hessian
 */
func real Area(real[int] &X)
{
	Vh rho;
	rho[] = X;
	Vh rho2 = square(rho);
	Vh rho4 = square(rho2);
	real res = int2d(Th)(sqrt( rho4*sin2 + rho2*square(dx(rho)) + rho2*sin2*square(dy(rho)) ) );
	++iter;
	if(1) plot(rho,value=1,fill=1,cmm="rho(theta,phi) on [0,2pi]x[0,pi] - S="+res,dim=3);
	else Plot3D(rho[],"shape_evolution",1);
	return res;
}
func real[int] GradArea(real[int] &X)
{
	Vh rho,rho2;
	rho[] = X;
	rho2[] = square(X);
	Vh sqrtPsi,alpha;
	{
		Vh  dxrho2 = dx(rho)*dx(rho), dyrho2 = dy(rho)*dy(rho);
		sqrtPsi = sqrt( rho2*rho2*sin2 + rho2*dxrho2 + rho2*dyrho2*sin2 );
		alpha = 2.*rho2*rho*sin2 + rho*dxrho2 + rho*dyrho2*sin2;
	}
	varf dArea(u,v) = int2d(Th)(1./sqrtPsi * (alpha*v + rho2*dx(rho)*dx(v) + rho2*dy(rho)*sin2*dy(v)) );
	real[int] grad = dArea(0,Vh);
	return grad;
}
matrix hessianA;
func matrix HessianArea(real[int] &X)
{
	Vh rho,rho2;
	rho[] = X;
	rho2 = square(rho);
	Vh sqrtPsi,sqrtPsi3,C00,C01,C02,C11,C12,C22,A;
	{
		Vh C0,C1,C2;
		Vh  dxrho2 = dx(rho)*dx(rho), dyrho2 = dy(rho)*dy(rho);
		sqrtPsi = sqrt( rho2*rho2*sin2 + rho2*dxrho2 + rho2*dyrho2*sin2 );
		sqrtPsi3 = ( rho2*rho2*sin2 + rho2*dxrho2 + rho2*dyrho2*sin2 )*sqrtPsi;
		C0 = 2*rho2*rho*sin2 + rho*dxrho2 + rho*dyrho2*sin2;
		C1 = rho2*dx(rho);
		C2 = rho2*sin2*dy(rho);
		C00 = square(C0);
		C01 = C0*C1;
		C02 = C0*C2;
		C11 = square(C1);
		C12 = C1*C2;
		C22 = square(C2);
		A = 6.*rho2*sin2 + dxrho2 + dyrho2*sin2;
	}
	varf d2Area(w,v) =
		int2d(Th)(1./sqrtPsi * (A*w*v + 2*rho*dx(rho)*dx(w)*v + 2*rho*dx(rho)*w*dx(v) + 2*rho*dy(rho)*sin2*dy(w)*v + 2*rho*dy(rho)*sin2*w*dy(v)
								+ rho2*dx(w)*dx(v) + rho2*sin2*dy(w)*dy(v)) 
		+        1./sqrtPsi3 * (C00*w*v + C01*dx(w)*v + C01*w*dx(v) + C02*dy(w)*v + C02*w*dy(v) + C11*dx(w)*dx(v)
								   + C12*dx(w)*dy(v) + C12*dy(w)*dx(v) + C22*dy(w)*dy(v)) );
	hessianA = d2Area(Vh,Vh);
	return hessianA;
}


/*
 * Volume computation
 */
func real Volume(real[int] &X)
{
	Vh rho;
	rho[]=X;
	Vh rho3=rho*rho*rho;
	real res = 1./3.*int2d(Th)(rho3*sin(y));
	return res;
}
func real[int] GradVolume(real[int] &X)
{
	Vh rho;
	rho[]=X;
	varf dVolume(u,v) = int2d(Th)(rho*rho*sin(y)*v);
	real[int] grad = dVolume(0,Vh);
	return grad;
}
matrix hessianV;
func matrix HessianVolume(real[int] &X)
{
	Vh rho;
	rho[]=X;
	varf d2Volume(w,v) = int2d(Th)(2*rho*sin(y)*v*w);
	hessianV = d2Volume(Vh,Vh);
	return hessianV;
}



/*
 * If we want to use the volume as a constraint function
 * we must wrap it in some freefem functions returning the appropriate type 
 * The lagrangian hessian also have to be wrapped since the Volume is not linear with 
 * respect to rho, it will constribbute to the hessian.
 */
func real[int] ipVolume(real[int] &X) {real[int] vol = [Volume(X)]; return vol;}
matrix mdV;
func matrix ipGradVolume(real[int] &X) {real[int,int] dvol(1,Vh.ndof); dvol(0,:)=GradVolume(X); mdV=dvol; return mdV;}
matrix HLagrangian;
func matrix ipHessianLag(real[int] &X,real objfact,real[int] &lambda)
{
	HLagrangian = objfact*HessianArea(X) + lambda[0]*HessianVolume(X);
	return HLagrangian;
}
/*building struct for GradVolume */
int[int] gvi(Vh.ndof),gvj=0:Vh.ndof-1;
gvi=0;


/*
 * The starting value
 */
Vh rc=startshape ;


/*
 * Bounds definition
 */
Vh ub=1.e19;
//Vh lb=1.,ub=3.;


/*
 * make it funnier by puptting some objects inside the shape , where rho has to be greater than a given value
 */
Vh lb=0;
int shapeswitch=1;
real sigma=2*pi/40.,treshold=0.1;
func real Gaussian(real X,real Y,real theta,real phi)
{
	real deltax2 = square((X-theta)*sin(Y)) , deltay2 = square(Y-phi);
	return exp(-0.5 * (deltax2 + deltay2) / (sigma*sigma));
}
real e=0.1,r0=0.25,rr=2-r0;
real E=1./(e*e),RR=1./(rr*rr);
func disc1 = sqrt(1./(RR+(E-RR)*cos(y)*cos(y)))*(1+0.1*cos(7*x));
func disc2 = sqrt(1./(RR+(E-RR)*cos(x)*cos(x)*sin2))  ;
if(1) //doesn't work well...
{
	lb=r0;
	/*{
		func f = rr*Gaussian(x,y,0,0);
		func g = rr*Gaussian(x,y,0,pi);
		lb = max(max(lb,f),g);
	}*/
	for(int q=0;q<5;++q)
	{
		func f = rr*Gaussian(x,y,2*q*pi/5.,pi/3.);
		func g = rr*Gaussian(x,y,2*q*pi/5.+pi/5.,2.*pi/3.);
		lb = max(max(lb,f),g);
	}
	lb = max(lb,rr*Gaussian(x,y,2*pi,pi/3));
}
lb =  max(lb,max(disc1, disc2));
real Vobj = Volume(lb[]);
real Vnvc = 4./3.*pi*pow(lb[].linfty,3);

if(1) Plot3D(lb[],"object_inside",0);
real[int] clb=0.,cub=[(1-alpha)*Vobj + alpha*Vnvc];


/*
 * Call to IPOPT
 */
int res=IPOPT(Area,GradArea,ipHessianLag,ipVolume,ipGradVolume,rc[],ub=ub[],lb=lb[],clb=clb,cub=cub,checkindex=1,maxiter=kkk<nadapt-1 ? 40:150,warmstart=kkk,lm=lm,uz=uz[],lz=lz[],tol=0.00001,structjacc=[gvi,gvj]);
cout << " IPOPT: res =" << res << endl ;
/*
 * Display the final mesh
 */
Plot3D(rc[],"Shape_at_"+kkk,0);
Plot3D(GradArea(rc[]),"ShapeGradient",0);
if(kkk<nadapt-1)
{
	Th = adaptmesh(Th,rc*cos(x)*sin(y),rc*sin(x)*sin(y),rc*cos(y)/*,hmax=pi/np*/,nbvx=50000,periodic=[[2,y],[4,y]/*,[1,x],[3,x]*/]);
	plot(Th,wait=1);
	startshape = rc;
	uz=uz;//dual variables interpolation
	lz=lz;
}

// FFCS regression reference value
regtest=rc[]'*rc[];
}

load "exactpartition"
load "msh3"
mesh Th=square(10,10);
mesh3 Th3=buildlayers(Th,10); 
fespace Vh(Th,P1);
fespace Vh3(Th3,P1);
int n=10;
Vh[int] p(n); 
Vh3[int] p3(n); 
real[int][int] pp(n);

for(int i=0; i<n; ++i)
p[i]= lrint(x*y*n/3)== lrint(i*1./3.);
for(int i=0; i<n; ++i)
  p3[i]= lrint(x*y*(1-z)*n/3)== lrint(i*1./3.);
for(int i=0;i<n;++i)
{
    pp[i].resize(Vh.ndof);
    pp[i]=p[i][]; 
}
plot(p, wait=1);
int[int] pj=[3,4,1,8,9,100,8,7,10,11,12]; 
exactpartition(p,pj); 
exactpartition(p3,pj); 
exactpartition(pp,pj); 
Vh s=1;
for(int i=0; i<n;++i)
 s[] -= p[i][];
 
 assert(s[].linfty ==0); 
load "ff-cmaes"


int NN = 5;
mesh Th = square(NN,NN);
func f1=1.;
func f2=-1.;
func g1=0.;
func g2=0.1;
int iter=0;
int nadapt=1;
real starttol=1e-10,bctol=6.e-12;
fespace Vh(Th,P1);
Vh ou1,ou2;
real pena=1000;


for(int al=0;al<nadapt;++al)
{
	
varf BVF(v,w) = int2d(Th)(0.5*dx(v)*dx(w) + 0.5*dy(v)*dy(w));
varf LVF1(v,w) = int2d(Th)(f1*w);
varf LVF2(v,w) = int2d(Th)(f2*w);
matrix A =  BVF(Vh,Vh);
real[int] b1 = LVF1(0,Vh) , b2 = LVF2(0,Vh); 

varf Vbord(v,w) = on(1,2,3,4,v=1);
//real[int] bord = Vbord(0,Vh);
//real[int] in = bord ? 0 : 1;
Vh In,Bord;
Bord[] = Vbord(0,Vh,tgv=1);
In[] = Bord[] ? 0:1;
Vh gh1=Bord*g1,gh2=Bord*g2;



//Function which create a vector of the search space type from
//two finite element functions
func int FEFToSSP(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			ssp[kX] = fef1[i];
			ssp[kX+In[].sum] = fef2[i];
			++kX;
		}
	}
	return 1;
}
//Function spliting a vector from the search space and fills
//two finite element functions with it
func int SSPToFEF(real[int] &fef1,real[int] &fef2,real[int] &ssp)
{
	int kX=0;
	for(int i=0;i<Vh.ndof;++i)
	{
		if(In[][i])
		{
			fef1[i] = ssp[kX];
			fef2[i] = ssp[kX+In[].sum];
			++kX;
		}
		else
		{
			fef1[i] = gh1[][i];
			fef2[i] = gh2[][i];
		}
	}
	return 1;
}


func real IneqC(real[int] &X)
{
	real[int] constraints(In[].sum);
	for(int i=0;i<In[].sum;++i)
	{
		constraints[i] = X[i] - X[i+In[].sum];
		constraints[i] = constraints[i] <= 0 ? 0. : constraints[i];
	}
	return constraints.l2;
}


func real J(real[int] &X)
{
	Vh u1,u2;
	SSPToFEF(u1[],u2[],X);
	iter++;
	real[int] Au1 = A*u1[], Au2 = A*u2[];
	Au1 -= b1;
	Au2 -= b2;
	real val = u1[]'*Au1 + u2[]'*Au2;
	val +=  pena * IneqC(X);
	if(iter%200==199) 
	plot(u1,u2,nbiso=30,fill=1,dim=3,cmm="adapt level " + al + " - iteration " + iter + " - J = " + val,value=1);
	return val ;
}



real[int] start(2*In[].sum);

if(al==0)
{
	start(0:In[].sum-1) = 0.;
	start(In[].sum:2*In[].sum-1) = 0.1;
}
else FEFToSSP(ou1[],ou2[],start);


real mini = cmaes(J,start,stopMaxFunEval=10000*(al+1),stopTolX=1.e-3/(10*(al+1)),initialStdDev=(0.025/(pow(100.,al))));
Vh best1,best2;
SSPToFEF(best1[],best2[],start);

Th = adaptmesh(Th,best1,best2);
ou1 = best1;
ou2 = best2;

}
load "./lgbmo"
int n=2;
real[int] X(n),DX(n);
real[int] X0(n);
for(int i=0;i<n;++i) X0[i]=0.5;

func real J(real[int] & x)
{
  real s=n;
  x -= X0;
  for (int i=0;i<x.n;i++)
    s +=(x[i]*x[i]-cos(18.*x[i]));
  //cout << " J " << s << "       .... " << x[0] << " " << x[1] << endl;
  return s;
}

func real[int] DJ(real[int] &x)
{
  x -= X0; 
  for (int i=0;i<x.n;i++)
    x[i]=2*x[i]+18*sin(18*x[i]);
  //cout << " dJ "  << "       .... " << x[0] << " " << x[1] << endl;
  return x;  // return of global variable ok 
};

for(int i=0;i<n;++i)
  X[i]=abs(sin((i+1)/(n*2.)));
verbosity=9;

//  buggus.. 
 
real  mm=0;// bmo(J,DJ,X,min=-10,max=10);
cout << " min = " << mm << endl;

cout << " x = " << X << endl;
cout << " X0 = " << X0 << endl;

// Example of dynamic function load
// --------------------------------
// $Id$

 load "myfunction2"
  string toto="xxxx";
 Why(toto);
 Why("qqsdqs.wwc.dqqs");
 cout << f(3.) << endl; 
// ShurComplement  full matrix 
load "lapack"
// ShurComplement  sparse matrix 
load "Schur-Complement"
include "ExtractDofsonBorder.idp"


// popur CL Dirichet
macro FindDofOnBorder(l,Vh,I)
{
	varf von(u,v) = on(l,u=-1);
    int[int] J=0:Vh.ndof-1;
	real[int] vl = von(0,Vh); 
	sort(vl,J);
	vl = vl ? 1. :0.;
	int n = vl.sum+0.5; 

	I.resize(n);
	I=J(0:n-1);
	cout << " n = "<< n << endl; 
}//

macro grad(u) [dx(u),dy(u)] //
real hsize= 0.1; 

real htt = max(hsize/2,0.1);
mesh Th=square(2/hsize,1/hsize,[x*2,y]);

Th=trunc(Th,(abs(x-1)>4*htt)||(abs(y-0.5)>htt),label=10);

mesh Th2=movemesh(Th,[2-(x-2),y]);
plot(Th,Th2,wait=1);
fespace Vh(Th,P1);
fespace Vh2(Th2,P1);
int n = Vh.ndof;
varf va(u,v) = int2d(Th)(grad(u)'*grad(v))+on(1,3,4,u=0);

 matrix A= va(Vh,Vh,sym=0,tgv=-2);
if(verbosity>9) cout << A << endl; 
int[int] I; 
ExtractDofsonBorder(2,Vh,I,1);

real[int,int] B(1,1);

//  model 2 
int[int] I10;
FindDofOnBorder(10,Vh,I10);
if(verbosity>9) cout << " I10 "<< I10 << endl; 
int[int] If(n);
int In=I.n; 
If=-1;
for [i,Ii:I]
  If[Ii]=i; 
for [i,I10i:I10]
    If[I10i]=In; 
if( verbosity>9) cout << If << endl; 	
real[int,int] S(1,1);
int nfs=SchurComplement(S,A,If,B);

cout << nfs << " "<< In+1  << endl;
if( verbosity>9)  cout << " S = "<<" " << S << endl;  
/*
dans S  les dof sont : 0 a In-1 : cote doite vertical 
       In =  cl troue
    PB symetrique => resoudre S+S 
*/
int iclr=nfs;
int icll=nfs-1;
int iclS = nfs-1;
int[int] Il=0:nfs;
int[int] Ir=0:nfs;

Ir[iclr]=iclS;
Ir[icll]=-1;

Il[iclr]=-1;
Il[icll]=iclS;
 
int nd = nfs+1;
//matrix St(nd,nd);// manque une matrix vide 
cout << " S ="<< S << endl;
real[int,int] St(nd,nd);
func real[int,int]  to(int[int] &I,real[int,int] &S)
{
	int n = I.n;
	real[int,int]  A(n,n);
	A=0;
	for(int i=0; i<n; ++i)
		for(int j=0; j<n; ++j)
		if(I[i]>=0 && I[j]>=0 )
	  	  A(i,j) += S(I[i],I[j]);
		  return A;
}
St =0;
{// a ameliorer ... il maque des fonction ff++ 
	//St+=S(Ir,Ir);
	St=to(Ir,S);
	real[int,int] Stt=to(Il,S);
	St+= Stt;
	/*  bug ... in Matrixfull2mapIJ in  v 4.3-1
	{
    matrix Stt = S(Ir,Ir);
    real[int,int] Sb(nd,nd);
    copy(Sb,Stt);
	cout << Ir << endl; 
	cout << "Sbr " << Sb << endl;
     St += Sb; 
    }
	{
    matrix Stt = S(Il,Il);
    real[int,int] Sb(nd,nd);
    copy(Sb,Stt);
	cout << Il << endl; 
	cout << "Sbl " << Sb << endl;
    St += Sb; 
    }
*/
}
cout << " St=" <<  St << endl; 
cout << "ic  = "<< icll <<" " << iclr << endl; 
int[int] It=[icll,iclr];
real[int,int] SS(1,1), B0(1,1);
matrix Stm = St;
int nfs0=SchurComplement(SS,Stm,It,B0);

cout << "B0=" << B0 << endl; 
for(int j=0; j<B0.m; ++j)
{	
	Vh ul=0;
	Vh2 ur = 0; 
	for(int i=0; i<nfs-1; ++i)
  	 ur[] +=  B(:,i)*B0(i,j);
	for(int i=0; i<nfs-1; ++i)
 	 ul[] +=  B(:,i)*B0(i,j);
	{
	  ur[] +=  B(:,nfs-1)*B0(nfs-1,j);
	  ul[] +=  B(:,nfs-1)*B0(nfs,j);
	 }   
	plot(ul,ur, wait=1);
}

load "ppm2rnm"

// Parameters
bool wait = false;
string figName = "fig.pgm";

// Read PPM (method 1)
real[int, int] img1(figName); //Read image and set to an array
int nx = img1.n, ny = img1.m;
mesh Th1 = square(nx-1, ny-1, [(nx-1)*(x)/nx, (ny-1)*(1-y)/ny]);
//Warning:
// the numbering of the vertices (x,y) is
// given by i = x/nx + nx* y/ny
fespace Vh1(Th1, P1);
Vh1 fimg1;
fimg1[] = img1;
plot(fimg1, cmm="method 1", wait=wait);

// Read PPM (method 2)
real[int, int] img2(figName); //Read image and set to an array
int nx2 = img2.n, ny2 = img2.m;
mesh Th2 = square(nx2-1, ny2-1, [(nx2-1)*(x)/nx2, (ny2-1)*(1-y)/ny2]);
fespace Vh2(Th2, P1);
Vh2 fimg2;
fimg2[] = img2;
plot(fimg2, cmm="method 2", wait=wait);

// Save PPM
bool res = savePPM("figout.ppm", img2);
assert(res);

// Difference PPM
real[int, int] imgDiff = diffPPM(img1, img2);
int nxDiff = imgDiff.n, nyDiff = imgDiff.m;
mesh ThDiff = square(nxDiff-1, nyDiff-1, [(nxDiff-1)*(x)/nxDiff, (nyDiff-1)*(1-y)/nyDiff]);
fespace VhDiff(ThDiff, P1);
VhDiff fimgDiff;
fimgDiff[] = imgDiff;
plot(fimgDiff, cmm="difference", wait=wait);
mesh Th=square(100,100,[x*2-1,y*2-1]);
load "isoline"
fespace Vh(Th,P1);
fespace Ph(Th,P0); 
func rr= sqrt(x^2+y^2);
int k =5;
Vh u= sin(k*pi*x)*sin(k*pi*y);//rr*(1-rr);
plot(u, wait=1);
Ph r; 

verbosity=3;
int[int] lm=findalllocalmin(Th,u[],r[],convex=1,eps=0);
plot(r,u,fill=1,wait=1);
// lm.n == number of min
// r  bassin number 
// lm[int(r[k])] is the minimal vertex of the bassin associated 
//cout << r[]<<endl; 

cout << lm << endl; 
include "gsl.idp"
// FFCS - avoid using P2 and P3 which already define something very precise
real [int] p2=[ 2,-3,1];
real [int] p3=[ 8,-10,1,1];
real [int] X(3);
complex[int] Z(4);
real [int] Q4=[ -1,0,0,0,1];
gslpolysolvequadratic(p2,X);
cout << X[0] << " " << X[1] << endl; 
gslpolysolvecubic(p3,X);
cout << X[0] << " " << X[1] << " " << X[2] << endl; 
gslpolycomplexsolve(Q4,Z); 
cout << Z[0] << " " << Z[1] << " " << Z[2] << " " << Z[3] <<endl;

cout << "\n\n gsl random :\n\n";
 cout << " list of generator " << ngslrng << endl;
 for(int i=0; i <ngslrng ; ++i)
   cout << i << " name  " <<  gslname(gslrngtype(i)) << endl; 
gslrng r=gslrngtype(1);// chose a generator 
// cout << r << endl;  no print .. 
for (int i = 0; i < 10; i++) 
   cout << gslrnguniform(r) << endl;;  
 
 real x0=0.2;
 int n=10;
 real[int,int] dspline(2,n+6);
 for(int i=0; i<= n+5; ++i)
  {
    real xx = square(real(i)/n)+x0; 
    real yy = sin(xx*pi*2); 
    dspline(0,i)= xx;
    dspline(1,i)= yy;    
  }
  /*
 the 7  type of spline of gsl are 
  0: gslinterpcspline (default .
  1: gslinterpakima
  2: gslinterpsteffen
  3: gslinterplinear
  4:  gslinterppolynomial
  5: gslinterpcsplineperiodic
  6:  gslinterpakimaperiodic 
  */
  gslspline spline(gslinterplinear,dspline);
  int mm=100;
 real[int] xx(mm+1),yy(mm+1),zz(mm+1),dyy(mm+1),ddyy(mm+1),dzz(mm+1),ddzz(mm+1);
 real err=0; 
 for (int i=0; i<=mm; ++i)
 { xx[i]= real(i)/mm+x0;
   yy[i]= spline(xx[i]);
   dyy[i]= spline.d(xx[i]);
   ddyy[i]= spline.dd(xx[i]);
   zz[i]= sin(pi*xx[i]*2);
   dzz[i]= 2*pi*cos(pi*xx[i]*2);
   ddzz[i]= -2*pi*2*pi*sin(pi*xx[i]*2);
   err = max( err , abs(yy[i]-zz[i]));
   cout << xx[i] << " " << yy[i] << "  ~ " << zz[i] << ",  " << dyy[i] << " ~ " << dzz [i] <<  " , " << ddyy[i] << " " << ddzz[i] <<  endl; 
 }
 //  test out of  bound v 3.50
 // OUT => VALUE AT BOUND ... FH OCT 2015 
 cout << dspline(1,0) << " ==  " << spline(-1) << " " << spline(100) << " == "<< dspline(1,dspline.m-1) << endl; 
 cout << " err = " << err << endl; 
 plot([xx,yy],[xx,zz],cmm= "err = " + err);
 assert(err < 0.3);
bool withmetis=0;
bool RAS=0;
int sizeoverlaps=2; // size off overlap 
int nn=2,mm=2;

func bool AddLayers(mesh & Th,real[int] &ssd,int n,real[int] &unssd)
{
  //  build a continuous function  uussd (P1) :
  //  ssd in the caracteristics function on the input sub domain.
  //  such that : 
  //   unssd = 1 when   ssd =1;
  //   add n layer of element (size of the overlap)
  //   and unssd = 0 ouside of this layer ...
  // ---------------------------------
  fespace Vh(Th,P1);
  fespace Ph(Th,P0);
  Ph s;
  assert(ssd.n==Ph.ndof);
  assert(unssd.n==Vh.ndof);
  unssd=0;
  s[]= ssd;
  //  plot(s,wait=1,fill=1);
  Vh u;
  varf vM(u,v)=int2d(Th,qforder=1)(u*v/area);
  matrix M=vM(Ph,Vh);
  
  for(int i=0;i<n;++i)
    {
      u[]= M*s[];
      // plot(u,wait=1);
      u = u>.1; 
      // plot(u,wait=1);
      unssd+= u[];
      s[]= M'*u[];//';
      s = s >0.1;
    }
  unssd /= (n);
  u[]=unssd;
  ssd=s[];      
  return true;
}

int withplot=3;
mesh Th=square(50,50);
int[int] chlab=[1,1  ,2,1  ,3,1  ,4,1  ];
Th=change(Th,refe=chlab);
int npart= nn*mm;
fespace Ph(Th,P0);
fespace Vh(Th,P1);

Ph  part;
Vh  sun=0,unssd=0;
Ph xx=x,yy=y,nupp;
part = int(xx*nn)*mm + int(yy*mm);
//plot(part,wait=1);
if(withmetis)
  {
    load "metis";
    int[int] nupart(Th.nt);
    metisdual(nupart,Th,npart); 
    for(int i=0;i<nupart.n;++i)
      part[][i]=nupart[i];
  }
if(withplot>1)
plot(part,fill=1,cmm="dual",wait=1);
mesh[int] aTh(npart);
mesh Thi=Th;
fespace Vhi(Thi,P1);
Vhi[int] au(npart),pun(npart);
matrix[int] Rih(npart);
matrix[int] Dih(npart);
matrix[int] aA(npart);
Vhi[int] auntgv(npart);
Vhi[int] rhsi(npart);

for(int i=0;i<npart;++i)
  {
    Ph suppi= abs(part-i)<0.1;
    AddLayers(Th,suppi[],sizeoverlaps,unssd[]);
    Thi=aTh[i]=trunc(Th,suppi>0,label=10,split=1);
    Rih[i]=interpolate(Vhi,Vh,inside=1); //  Vh -> Vhi
    if(RAS)
      {
        suppi= abs(part-i)<0.1;
        varf vSuppi(u,v)=int2d(Th,qforder=1)(suppi*v/area);
        unssd[]= vSuppi(0,Vh);
        unssd = unssd>0.;
        if(withplot>19)
          plot(unssd,wait=1);
      }
    pun[i][]=Rih[i]*unssd[];
    sun[] += Rih[i]'*pun[i][];//';
    if(withplot>9)
      plot(part,aTh[i],fill=1,wait=1);
  }
plot(sun,wait=1,dim=3,fill=1);
for(int i=0;i<npart;++i)
  {
    Thi=aTh[i];
    pun[i]= pun[i]/sun;
    if(withplot>8)
      plot(pun[i],wait=1);    
  }

//  verif partition of unite 

macro Grad(u) [dx(u),dy(u)]//EOM 
  sun=0;

for(int i=0;i<npart;++i)
  {
    cout << " build part :" << i << "/" << npart << endl;
    Thi=aTh[i];
    varf va(u,v) = 
      int2d(Thi)(Grad(u)'*Grad(v))//')
      +on(1,u=1) + int2d(Thi)(v)
      +on(10,u=0) ; 
    
    
    aA[i]=va(Vhi,Vhi);
    set(aA[i],solver="SPARSESOLVER");
    rhsi[i][]= va(0,Vhi);
    Dih[i]=pun[i][];
    real[int]  un(Vhi.ndof);
    un=1.;
    real[int] ui=Dih[i]*un; 
    sun[] += Rih[i]'*ui;;//';
    varf vaun(u,v) = on(10,u=1);
    auntgv[i][]=vaun(0,Vhi); // store arry of tgv on Gamma intern.
  }
if(withplot>5)
  plot(sun,fill=1,wait=1);
cout << sun[].max << " " << sun[].min<< endl;
// verification of the partition of the unite.
assert( 1.-1e-9 <= sun[].min  && 1.+1e-9 >= sun[].max);  

// FFCS: reference value for regression tests
Vh ref;

int nitermax=1000;
{
  Vh un=0;
  for(int iter=0;iter<nitermax;++iter)
    {
      real err=0;
      Vh un1=0;
      for(int i=0;i<npart;++i)
        {
          Thi=aTh[i];
          real[int] ui=Rih[i]*un[];//';
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          real[int] bi = ui .* auntgv[i][];
          bi = auntgv[i][] ? bi :  rhsi[i][];  
          ui=au[i][];
          ui= aA[i] ^-1 * bi;
          //{   Vhi uuu; uuu[]=ui;      plot(uuu,wait=1);}
          bi = ui-au[i][];
          err += bi'*bi;//';
          au[i][]= ui;
          bi = Dih[i]*ui;
          un1[] += Rih[i]'*bi;//';
        }
      err= sqrt(err);
      cout << iter << " Err = " << err << endl;
      if(err<1e-2) break;
      //    plot(un1,wait=1);
      un[]=un1[];
      if(withplot>2)
        plot(au,dim=3,wait=0,cmm=" iter  "+iter,fill=1 );
    }
  plot(un,wait=1,dim=3,fill=1);
  ref=un;
}
/*
 * Incompressible Navier Stokes
 * with Taylor-Hood Finite element
 * Non linearity : Newton method
 * continuation on Reynols Number
 * Mesh adaptation
*/
if (HaveUMFPACK)
{//  just do with UMPACK fgmres do not converge !!!
load "Element_P3pnc"

// Parameters
real reyini= 500; 
real reymax = 1000;	// ok < 125000

func BCu1 = 4*x*(1-x);
real epsr=1e-6;

// Mesh


mesh Th = square(8, 8);
func PkX = P3pnc;
func PkM = P2dc;

// Fespace
fespace Xh(Th, PkX);
Xh uu1, uu2;
Xh psi, phi;

fespace Mh(Th, PkM);
fespace XXMh(Th, [PkX, PkX, PkM]);
XXMh [u1, u2, p];
XXMh [v1, v2, q];
XXMh [up1, up2, pp];

// Macro
macro div(u1, u2) (dx(u1) + dy(u2)) //
macro grad(u1, u2) [dx(u1), dy(u2)] //
macro ugrad(u1, u2, v) (u1*dx(v) + u2*dy(v)) //
macro Ugrad(u1, u2, v1, v2) [ugrad(u1, u2, v1), ugrad(u1, u2, v2)] //

// Problem Stokes (with solve)
solve Stokes ([u1, u2, p], [v1, v2, q], solver=sparsesolver)
	= int2d(Th,qforder=9)(
		( dx(u1)*dx(v1) + dy(u1)*dy(v1)
		+ dx(u2)*dx(v2) + dy(u2)*dy(v2) )
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);

// Plot
uu1 = u1;
uu2 = u2;
plot(coef=0.2, cmm="[u1, u2] and p" ,p, [uu1, uu2], wait=1);

// Problem stream-lines (with solve)
solve streamlines (psi, phi)
	= int2d(Th,qforder=9)(
		  dx(psi)*dx(phi)
		+ dy(psi)*dy(phi)
	)
	+ int2d(Th,qforder=9)(
		- phi*(dy(u1) - dx(u2))
	)
	+ on(1, 2, 3, 4, psi=0);

// Plot
plot(psi, wait=1);
real nu = 1.;

// Variatonal form definition Navier-Stokes
int i = 0;

varf vDNS ([u1, u2, p], [v1, v2, q])
	= int2d(Th,qforder=9)(
		+ nu * (
			  dx(u1)*dx(v1) + dy(u1)*dy(v1)
			+ dx(u2)*dx(v2) + dy(u2)*dy(v2)
		)
		- p * q * epsr
		- p*div(v1, v2) - q*div(u1, u2)
		+ Ugrad(u1, u2, up1, up2)'*[v1, v2]
		+ Ugrad(up1, up2, u1, u2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;

varf vNS ([u1, u2, p], [v1, v2, q])	// DF(u)u - F(u)
	= int2d(Th,qforder=9)(
		  Ugrad(up1, up2, up1, up2)'*[v1, v2]
	)
	+ on(3, u1=BCu1, u2=0)
	+ on(1, 2, 4, u1=0, u2=0);
	;
	real err =0; 
for (real re = reyini ; re <= reymax; re *= 2) {
	real lerr = 1; 
	nu = 1./re;

	if (re > 8000) lerr = 0.2;
	if (re > 10000) lerr = 0.05;
	for (int step = 0; step < 2; step++) {
		// Mesh adaptation & interpolation
		Th = adaptmesh(Th, [dx(u1), dx(u2),dy(u1), dy(u2)], p, err=lerr, nbvx=100000, abserror=0, cutoff=0.01);
		[u1, u2, p] = [u1, u2, p];
		[up1, up2, pp] = [up1, up2, pp];

		// Newton
		for (i = 0; i <= 20; i++) {
			// Update
			up1[] = u1[];

			// Solve
			real[int] b = vNS(0, XXMh);	// build right hand side
			matrix Ans = vDNS(XXMh, XXMh);	// build matrix
			set(Ans, solver=sparsesolver);	// set solver
			u1[] = Ans^-1*b;	// solve linear system

			// Error
			b = u1[]-up1[];
			err = b.l2;
			cout << "iter = "<< i << ", err = " << err << ", rey = " << re << endl;

			// Convergence criteria
			if (err < 1e-4) break;
			if(err > 1e10) break;
		}
		if(err > 1e10) break;
	  
	}
	if(err > 1e10) break;
        
	// Stream-lines
	uu1 = u1;
	uu2 = u2;
	streamlines;
	plot(coef=0.2, cmm="rey="+re+" [u1, u2] and p", psi, [uu1, uu2], wait=0, nbiso=20);
}
}
load "Element_P4"
load "Element_P3"
load "qf11to25"
load "msh3"

mesh Th=square(10,10);
mesh3 Th3=cube(10,10,10);
verbosity=4;

for (int i=1;i<=26;i++)
{
  cout <<" int1d order= "<< i ;
  int1d(Th,qforder=i)(1.);
}

for (int i=1;i<=26;i++)
{
 cout <<" int2d order= "<< i ;
  int2d(Th,qforder=i)(1.);
}

for (int i=1;i<=14;i++)
{
 cout <<" int3d order= "<< i ;
  int3d(Th3,qforder=i)(1.);
}

verbosity=1;

 fespace Vh(Th,P4);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf11pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf25pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP4.eps",value=true);

  real[int,int] qq1=[ [0.5,0],
                      [0.5,1]];
  real[int,int] qq2=[[1./3,0,0],[1./3.,1,0],[1./3.,0,1]];
  real[int,int] qq3=[[1./4,0,0,0],[1./4.,1,0,0],[1./4.,0,1,0],[1./4.,0,0,1]];

  QF1 qf1(1,qq1);
  QF2 qf2(1,qq2);
  QF3 qf3(1,qq3);
  real I1 = int1d(Th,qfe=qf1)(x^2) ;
  real I1l = int1d(Th,qfe=qf1pElump)(x^2) ;

  real I2 = int2d(Th,qft=qf2)(x^2) ;
  real I2l = int2d(Th,qft=qf1pTlump)(x^2) ;

  cout << I1 << " == " << I1l << endl;
  cout << I2 << " == " << I2l << endl;
  assert( abs(I1-I1l) < 1e-10);
  assert( abs(I2-I2l) < 1e-10);

load "Element_P3dc"
load "Element_P2pnc"
func real cc(real aa) {real a=aa; if(abs(a)<1e-10) a=0; return a;} 
int[int] ne1=[1,2,0];
int[int] ne2=[2,0,1];

real[int] xx=[0,1,0,0],yy=[0,0,1,0],zz=[0,0,0,1];
 
int[int] ll=[2,0,0,1];
mesh Th=square(1,1,flags=2,label=ll);

Th = trunc(Th,x<0.5,label=0);


//Th = movemesh(Th,[x+0.1*y,y-0.2*x]);
//Th = movemesh(Th,[x*2,y*2]);

mesh Thg = trunc(Th,1,split=2,label=-1);
plot(Th, wait=1);

int it0=0; 

fespace Lh(Th,P1);
Lh[int] l(3);
l[0][][0]=1;
l[1][][1]=1;
l[2][][2]=1;


fespace Wh(Th,P3dc);
fespace Vh(Th,P2pnc);
Vh u,v;
for (int j=0;j<Vh.ndofK;++j)
{
	int i = Vh(0,j);
	cout << j << " -> " <<  i << " : " ;
    u=0;
	u[][i]=1;
	for(int k=0; k<3;k++)
	{
		int i1= (k+1)%3, i2=(k+2)%3;
		cout << cc(int1d(Th,k)(u*l[i1]/lenEdge)) << " " << cc(int1d(Th,k)(u*l[i2]/lenEdge)) << " "; 
	}
	cout << cc(int2d(Th)( u/area)) << endl; 
	//plot(u,wait=1);
	v=u;
	for (int j=0;j<Vh.ndofK;++j)
	cout << cc(v[][Vh(0,j)]) << " " ;
	cout << endl;

}
 Th=square(10,10);
 u=x*x*y*y;
 
 solve PL2(u,v)=int2d(Th,qforder=7)(u*v)-int2d(Th,qforder=7)(x*x*y*y*v);

 plot(u,wait=1);
 real err=0,err1=0,err2=0; 
for (int i=0;i<Vh.ndof;++i)
{
    u=0;

	u[][i]=1;
	Wh u3=u;
	v=u;
	v[]-=u[];
	err += v[].linfty;
	err1 += sqrt(int2d(Th)(square(dx(u)-dx(u3))));
	err2 += sqrt(int2d(Th)(square(dy(u)-dy(u3))));
}
cout << " err=" << err << " " << err1 << " " << err2 << endl; 
assert( err+err1+err2 < 1e-10);
// file tetgencube.edp
load "msh3"
load "tetgen"
load "medit"

real x0,x1,y0,y1;
x0=1.; x1=2.; y0=0.; y1=2*pi;
mesh Thsq1 = square(5,35,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ1min = 0;
func ZZ1max = 1.5;
func XX1 = x;
func YY1 = y;

int[int] ref31h = [0,12];
int[int] ref31b = [0,11];

meshS Th31h = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1max],region=ref31h,orientation=1);
meshS Th31b = movemesh23(Thsq1,transfo=[XX1,YY1,ZZ1min],region=ref31b,orientation=-1);   

//medit("haut",Th31h);
//medit("bas",Th31b);

/////////////////////////////////
x0=1.; x1=2.; y0=0.; y1=1.5;
mesh Thsq2 = square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

func ZZ2 = y;
func XX2 = x;
func YY2min = 0.;
func YY2max = 2*pi;

int[int] ref32h = [0,13];
int[int] ref32b = [0,14];

meshS Th32h = movemesh23(Thsq2,transfo=[XX2,YY2max,ZZ2],region=ref32h,orientation=-1);  
meshS Th32b = movemesh23(Thsq2,transfo=[XX2,YY2min,ZZ2],region=ref32b,orientation=1);

/////////////////////////////////
x0=0.; x1=2*pi; y0=0.; y1=1.5;
mesh Thsq3 = square(35,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);
func XX3min = 1.;
func XX3max = 2.;

func YY3 = x;
func ZZ3 = y;

int[int] ref33h = [0,15];
int[int] ref33b = [0,16];

meshS Th33h = movemesh23(Thsq3,transfo=[XX3max,YY3,ZZ3],region=ref33h,orientation=1);  
meshS Th33b = movemesh23(Thsq3,transfo=[XX3min,YY3,ZZ3],region=ref33b,orientation=-1); 

////////////////////////////////
meshS Th33 = Th31h+Th31b+Th32h+Th32b+Th33h+Th33b; // "gluing" surface meshs to obtain the surface of cube
//medit("glumesh",Th33);
savemesh(Th33,"Th33.mesh");

// build a mesh of a axis parallel box with TetGen
//real[int] domaine = [1.5,pi,0.75,145,0.001];
//mesh3 Thfinal = tetg(Th33,switch="pqaAAYYQ",nbofregions=1,regionlist=domaine);    // Tetrahelize the interior of the cube with tetgen
//medit("tetg",Thfinal);
//savemesh(Thfinal,"Thfinal.mesh");


// build a mesh of a half cylindrical shell of interior radius 1. and exterior radius 2 and heigh 1.5
func mv2x = x*cos(y);
func mv2y = x*sin(y);
func mv2z = z;
//mesh3 Thmv2 = movemesh3(Thfinal, transfo=[mv2x,mv2y,mv2z]);
//savemesh(Thmv2,"halfcylindricalshell.mesh");
verbosity=2;
meshS Thmv2surf = movemesh(Th33, [mv2x,mv2y,mv2z], removeduplicate=0);
cout << "\b\b Thmv2surf.measure=" << Thmv2surf.measure << endl;
cout << " Thmv2surf.bordermeasure=" << Thmv2surf.bordermeasure << endl;

medit("maiAllagesurf",Thmv2surf,wait=1);
//savemesh(Thmv2surf,"maillagesurfacecylindre.mesh");
//medit("maillageplein",Thmv2);



load "BernardiRaugel"
// a macro the compute numerical derivative
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
mesh Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);

real x1=0.7,y1=0.9, h=1e-7;
int it1=Th(x1,y1).nuTriangle; 

fespace Vh(Th,P2BR);

Vh [a1,a2],[b1,b2],[c1,c2];


for (int i=0;i<Vh.ndofK;++i)
	cout << i << " " << Vh(0,i) << endl;
for (int i=0;i<Vh.ndofK;++i)
{
  a1[]=0;	
  int j=Vh(it1,i);
  a1[][j]=1;
  plot([a1,a2], wait=1); 
  [b1,b2]=[a1,a2];// do the interpolation


  c1[] = a1[] - b1[];
  cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;	
  cout << " a = " << a1[] <<endl;
  cout << " b = " << b1[] <<endl;
  assert(c1[].max < 1e-9 && c1[].min > -1e-9); // check if the interpolation is correct

 //  check the derivative and numerical derivative
 

  cout << " dx(a1)(x1,y1) = " << dx(a1)(x1,y1) << " == " << DD(a1,h,0) << endl; 
  assert( abs(dx(a1)(x1,y1)-DD(a1,h,0) ) < 1e-5);
  assert( abs(dx(a2)(x1,y1)-DD(a2,h,0) ) < 1e-5);
  assert( abs(dy(a1)(x1,y1)-DD(a1,0,h) ) < 1e-5);
  assert( abs(dy(a2)(x1,y1)-DD(a2,0,h) ) < 1e-5);


} 

load "shell"
cout << "pwd = " << getcwd()<< endl;// add version 4.9.1
Directory  c=".";
string ttoto="/tmp/toto";
while(1)
{
	string n=readdir(c);
	if( n != "") 
	  cout << n << " " << isdir(n) << endl; 
	else break; 
}

cout << " login " << getenv("LOGIN") << endl;
setenv("FF_TOTO","toto");
cout << " FF_TOTO  " << getenv("FF_TOTO") << endl;
string pwd=getenv("PWD");
verbosity=3;
cout << " FILE: " <<FILE << endl;
cpfile(FILE,"/tmp");
cout << "basename " << basename(pwd) << endl; 
cout << "dirname " << dirname(pwd) << endl; 
cout << isdir(ttoto) << endl; 
if (isdir(ttoto)<0 )
{
	cout << "mkdir"  << " " << ttoto << endl; 
if  (mkdir(ttoto)==0)
{
	cout << " ls : " ;
	Directory dtoto = "/tmp/toto";
	while(1)
	{
		string n=readdir(dtoto);
		if( n == "") break;
		cout <<  n << " "; 
	}
	cout << endl; 
	cout << " rmdir /tmp/toto" << endl; 
   rmdir("/tmp/toto");//  dir /tmp/toto must be  empty 
}
}
load "ff-Ipopt";

int NN=10;

mesh Th = square(NN,NN);
fespace Vh(Th,P1);
{  // verif no thresholding in operation 1*A; 
	macro grad(u) [dx(u),dy(u)]//
	varf a(u,v) = int2d(Th)(grad(u)'*grad(v));
	matrix A = a(Vh,Vh);
	matrix A1 = 1.*A;
	assert(A.nnz == A1.nnz ); 
}  // end verification 


func f=1;
func g=0;

varf Poiss(u,v) = int2d(Th)(0.5*dx(u)*dx(v) + 0.5*dy(u)*dy(v)) - int2d(Th)(v*f);
varf dPoiss(u,v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) ;
matrix A = Poiss(Vh,Vh);
matrix dA = dPoiss(Vh,Vh);
real[int] b = Poiss(0,Vh);

varf Bord(u,v) = int1d(Th,1,2,3,4)(0.5*u*v) - int1d(Th,1,2,3,4)(v*g);
varf dBord(u,v) = int1d(Th,1,2,3,4)(u*v);
real intg2 = int1d(Th,1,2,3,4)(0.5*g*g);


matrix M = dBord(Vh,Vh);
real[int] bc= Bord(0,Vh);



//cout << M << endl;
//matrix M = Bord(Vh,Vh);

int iter=0;

func real J(real[int] &X)
{
	Vh u;
	u[]=X;
	real[int] Au = A*X;
	Au += b;
	real res = X '* Au;
	plot(u,dim=3,fill=1,cmm="res = "+res+" - iter="+(iter++));
	return res;
}

int nj=0;
func real[int] dJ(real[int] &X)
{
	real[int] Au = dA*X;
	//Au *= 2.;
	Au += b;
	return Au;
}

int nh=0;

matrix MH;
func matrix HJ(real[int] &X,real objfact,real[int] &lm) 
{
	int[int] ia(0),ja(0),ic(0),jc(0);
	real[int] ca(0),cc(0);
	[ia,ja,ca] = dA;
	[ic,jc,cc] = M;
	ca *= (objfact ? objfact : 0.0001);
	cc *= (lm[0] ? lm[0] : 0.0001);
	matrix odA = [ia,ja,ca];
	matrix lmM = [ic,jc,cc];
	MH = odA + lmM;
	return MH;
}
//func matrix HJ(real[int] &X) {return dA;}
//out << dA << end;
int nc=0;
func real[int] C(real[int] &X)
{
	real[int] res=M*X;
	res *= 0.5;
	res += bc;
	real result = X '* res;
	result += intg2;
	real[int] rrr = [result];
	return rrr;
}

int ndc=0;
matrix MdC;
for(int i=0;i<Vh.ndof;++i)
{
	Vh xx=0.;
	xx[][i] = 1.;
	real[int] Mxx = M*xx[];
	real[int,int] MMxx(1,Mxx.n);
	MMxx(0,:) = Mxx;
	matrix MMMxx = MMxx;
	matrix temp = MMMxx;
	if(i==0) MdC = MMMxx;
	else MMMxx = MdC + temp;
	MdC = MMMxx;
}
cout << MdC << endl;
int[int] imdc(0),jmdc(0);
real[int] cmdc(0);
[imdc,jmdc,cmdc] = MdC;
func matrix dC(real[int] &X)
{
	real[int] res = M*X;
	res += bc;
	real[int,int] mdc(1,X.n);
	mdc(0,:) = res;
	for(int i=0;i<res.n;++i) if(res[i]) MdC(0,i) = res[i];
	
	return MdC;
}
//cout << borders << endl;
real[int] Clb(1),Cub(1);
Clb=0.;
Cub=0.;
Vh start=0.;//x*(x-1)*y*(1-y);

real[int] xub(Vh.ndof),xlb(Vh.ndof);
xub=1.e19;
xlb=-1.e19;
//xub = xub .* inside;
//xlb = xlb .* inside;
//cout << "J=" << J(start[]) << endl << " dJ=" << dJ(start[]) << endl << " HJ=" << HJ(start[]) << endl << " C=" << C(start[]) << endl << " dC=" << dC(start[]) << endl;
//cout << "dC = " << dC(start[]) << endl;

//IPOPT(J,dJ,HJ,start[],ConstFunc=C,ConstGrad=dC,clb=Clb,cub=Cub);
/*
real[int] lll=[0.];
cout << HJ(start[],1.,lll) << endl;
lll[0] = 1.;
cout << HJ(start[],0.,lll) << endl;*/


IPOPT(J,dJ,HJ,C,dC,start[],ub=xub, lb=xlb,cub=Cub,clb=Clb);

Vh uff,v;
solve LaplaceFF(uff,v) = int2d(Th)(dx(uff)*dx(v) + dy(uff)*dy(v)) - int2d(Th)(v*f) + on(1,2,3,4,uff=0);
real nl2 = sqrt(int2d(Th)(square(uff-start))), ninf = sqrt(int2d(Th)(square(dx(uff)-dx(start)) + square(dy(uff)-dy(start))));
cout << "||ipopt - ff||_2 = " << nl2 << "   ||grad||_2 = "  << ninf << endl;
// UNCHECK-FILE
/*

 Example of coupling c program and freemfem++ script
 with mmap and semaphore

 the c code is    :   ffmaster.c
 the ff++ code is : ffslave.edp
 and here FreeFEM is a slave process
  the compile step is

 cc -c libff-mmap-semaphore.c
 cc ffmaster.c -o ffmaster  libff-mmap-semaphore.o -g
 #build the freefem++ plugin
  ff-c++ -auto ff-mmap-semaphore.cpp
 # launch
 ./ffmaster


 F. Hecht Feb. 2018   Frederic.Hecht@upmc.fr
 */

load "ff-mmap-semaphore"
Psemaphore smff("ff-slave1",0);
Psemaphore smc("ff-master1",0);
Pmmap sharedata("shared-data",1024);
if(verbosity<4) verbosity =0;
mesh Th=square(10,10);
fespace Vh(Th,P1);
Vh u,v;
int[int] Lab=[1,2,3,4];

macro grad(u) [dx(u),dy(u)] //

int status=1;
//Read(sharedata,8,status);
cout << " ff status = "<< status << endl;
real cff,rff;
problem Pb(u,v) = int2d(Th)(grad(u)'*grad(v))-int2d(Th)(cff*v)+ on(Lab,u=0);
if(verbosity>9) cout << " ff: before ff post\n";
Post(smff); // un lock master fin init


while( 1)
{
	if(verbosity>9) cout << " ff: before ff wait \n";
	Wait(smc); // wait from cint ecriture ok
	Read(sharedata,0,cff);
	Read(sharedata,8,status);


	cout << " After wait ..  ff "<< cff << " " << status << endl;
	if(status<=0) break;
	Pb;
	rff = int2d(Th)(u*u);
	cout << " ** ff "<< cff << " " << rff << endl;

	Write(sharedata,16,rff);
	Post(smff); // unlock cc
}

Post(smff); // wait from cint
cout << " Fin FreeFEM "<< endl;
// file tetgenholeregion_rugby.edp
load "msh3"
load "tetgen"
load "medit"
verbosity=2;

// Test 1

// data of rugby ball
real Ra=2.; 
real Rb=2.;
real Rc=1.;

mesh Th=square(10,20,[x*pi-pi/2,2*y*pi]);  //  $]\frac{-pi}{2},\frac{-pi}{2}[\times]0,2\pi[ $
//  a parametrization of a ellipsoid
func f1 = Ra*cos(x)*cos(y);
func f2 = Rb*cos(x)*sin(y);
func f3 = Rc*sin(x);
//  partiel derivative of the parametrization DF
func f1x=Ra*sin(x)*cos(y);   
func f1y=-Ra*cos(x)*sin(y);
func f2x=-Rb*sin(x)*sin(y);
func f2y=Rb*cos(x)*cos(y);
func f3x=Rc*cos(x);
func f3y=0;
// $  M = DF^t DF $
func m11=f1x^2+f2x^2+f3x^2;
func m21=f1x*f1y+f2x*f2y+f3x*f3y;
func m22=f1y^2+f2y^2+f3y^2;

func perio=[[4,y],[2,y],[1,x],[3,x]];  
real hh=0.1;
real vv= 1/square(hh);
verbosity=2;
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
Th=adaptmesh(Th,m11*vv,m21*vv,m22*vv,IsMetric=1,periodic=perio);
plot(Th,wait=1);

verbosity=2;

// construction of the surface of prolate ellipsoide
real Rmin  = 1.;
func f1min = Rmin*f1;
func f2min = Rmin*f2;
func f3min = Rmin*f3;

cout << "=====================" << endl;
cout << "=====================" << endl;
meshS Th3sph=movemesh23(Th,transfo=[f1min,f2min,f3min],orientation=1);
cout << "=====================" << endl;
cout << "=====================" << endl;
real Rmax  = 2.;
func f1max = Rmax*f1;
func f2max = Rmax*f2;
func f3max = Rmax*f3;
cout << "=====================" << endl;
cout << "=====================" << endl;
meshS Th3sph2=movemesh23(Th,transfo=[f1max,f2max,f3max],orientation=-1);
cout << "=====================" << endl;
cout << "=====================" << endl;
cout << "addition" << endl;
meshS Th3=Th3sph+Th3sph2;
savemesh(Th3sph,"ellipsoide.mesh");

real[int] domain2 = [1.5*Ra,0.,0.,145,0.001,0.,0.,0.,18,0.001];
cout << "==============================" << endl;
cout << " tetgen call without hole " << endl;
cout << "==============================" << endl;
mesh3 Th3fin=tetg(Th3,switch="paAAYYCCV",nbofregions=2,regionlist=domain2);
cout << "=============================" << endl;
cout << "finish: tetgen call without hole" << endl;
cout <<


 "=============================" << endl;
savemesh(Th3fin,"spherewithtworegion.mesh"); 
medit("maillagetwo",Th3fin);

real[int] hole = [0.,0.,0.];
real[int] domain = [1.5*Ra,0.,0.,53,0.001];
cout << "=============================" << endl;
cout << "  tetgen call with hole   " << endl;
cout << "=============================" << endl;
mesh3 Th3finhole=tetg(Th3,switch="paAAYCCV",nbofholes=1,holelist=hole,nbofregions=1,regionlist=domain);
cout << "=============================" << endl;
cout << "finish: tetgen call with hole   " << endl;
cout << "=============================" << endl;
savemesh(Th3finhole,"spherewithahole.mesh"); 



// Example of dynamic function load
// --------------------------------
// $Id$
//   Discret Fast Fourier Transform 
// -------------------------------
 load "dfft"
 load "msh3"
 {
int nx=32,ny=32,nz=32,N=nx*ny*nz;
// warning the fourier space is not exactly the unite square due to periodic condition
mesh3 Th=cube(nx-1,ny-1,nz-1,[(nx-1)*x/nx, (ny-1)*y/ny, (nz-1)*z/nz ]);
// warring  the numbering is of the vertices (x,y) is 
// given by $  i = round(x*nx) + nx* round(y*ny) +  nx*ny* round(z*nz);
int nerr=0; 
for(int v=0; v<Th.nv;++v)
{
	P=Th(v).P;
	int i =  round(x*nx) + nx* round(y*ny) +  nx*ny* round(z*nz);
	if( i != v) cout << nerr++ << " err "<< i<< " != "<< v << " "<< P << endl;
	
}
cout << " nerr " << nerr<<endl;
assert(nerr==0);
fespace Vh(Th,P1); 
Vh<complex> u;
 // Lapacien en FFT \hfilll
 // $ -\Delta u = f $ with full periodic condition \hfilll
func f = cos(3*2*pi*x)*cos(2*2*pi*y)*sin(2*pi*z); // 
func ue =  +(1./(square(2*pi)*14.))*cos(3*2*pi*x)*cos(2*2*pi*y)*sin(2*pi*z);  // the exact solution 
Vh<complex> ff = f;
Vh<complex> fhat;
fhat[] = dfft(ff[],ny,nz,-1);

Vh<complex> wij;
// warning in fact we take mode between -nx/2, nx/2 and -ny/2,ny/2
//  thank to the operator ?: \label{?:} 
wij = square(2.*pi)*(  square((x<0.5?x*nx:(x-1)*nx)) 
                     + square((y<0.5?y*ny:(y-1)*ny))
		     + square((z<0.5?z*nz:(z-1)*nz)) );
		    
real c2 = sqr(2*pi);	
//  New wait to set fourier function more simpile 	   
mapkkk(wij[],P,ny,nz,c2*P.norm2);		     
wij[][0] = 1e-5; // to remove constante ..

plot(wij,wait=1);
fhat[] = fhat[]./ wij[];  // 
u[]=dfft(fhat[],ny,nz,1);
u[] /= complex(N);
Vh ur,w;
ur = real(u); // the solution
w = real(ue); // the exact solution 
plot(ur,value=1 ,cmm=" ue   ", wait=1); 
w[] -= ur[]; // array sub
real err= abs(w[].max)+abs(w[].min) ;
cout << " err = " << err << endl;
assert( err  < 1e-6);
}
// test in all dimention ...
 {
int n1=32,n2=32;
mesh Th= square(n1-1,n2-1);
fespace Vh(Th,P1);
Vh<complex> u;
//verbosity=29; 
R3 K; 
mapkk(u[],K,n2,K.norm2);
//cout << u[] << endl; 
plot(u,wait=1);

}
{ load "msh3"
int n1=32,n2=32,n3=32;
mesh3 Th= cube(n1-1,n2-1,n3-1);
fespace Vh(Th,P1);
Vh<complex> u;
//verbosity=29; 
R3 K; 
mapkkk(u[],K,n2,n3,K.norm2);
//cout << u[] << endl; 
plot(u,wait=1);

}
{ 
int n1=32;
meshL Th= segment(n1-1);
fespace Vh(Th,P1);
Vh<complex> u;
//verbosity=29; 
R3 K; 
mapk(u[],K,K.norm2);
//cout << u[] << endl; 
plot(u,wait=1);

}

load "MetricPk"

mesh Th=square(3,3,[x,y]);
fespace Metric(Th,[P1,P1,P1]);
Metric [m11,m12,m22];

//fespace Deriv(Th,[P1,P1,P1]);
//Deriv [D1,D2,D3]; 
//m11[]=MetricPk(Th,(x^2+100*y^2)/2,kDeg=1,rDeg=1,Derivatives=D1[]);


fespace Deriv(Th,[P1,P1,P1,P1]);
Deriv [D1,D2,D3,D4]; 
//m11[]=MetricPk(Th,(x^3+2*3*x^2*y+3*3*x*y^2+4*y^3)/6,kDeg=2,rDeg=1,Derivatives=D1[]);
m11[]=MetricPk(Th,(x^3/100+y^3)/6,kDeg=2,rDeg=1,Derivatives=D1[]);

//fespace Deriv(Th,[P1,P1,P1,P1,P1]);
//Deriv [D1,D2,D3,D4,D5]; 
//m11[]=MetricPk(Th,(x^4+2*4*x^3*y+3*6*x^2*y^2+4*4*x*y^3+5*y^4)/24,kDeg=3,rDeg=1,Derivatives=D1[]);
//m11[]=MetricPk(Th,(x^3+2*3*x^2*y+3*3*x*y^2+4*y^3)/6,kDeg=3,rDeg=1,Derivatives=D1[]);

//fespace Deriv(Th,[P1,P1,P1,P1,P1,P1]);
//Deriv [D1,D2,D3,D4,D5,D6]; 
//m11[]=MetricPk(Th,(x^5+2*5*x^4*y+3*10*x^3*y^2+4*10*x^2*y^3+5*5*x*y^4+6*y^5)/120,kDeg=4,rDeg=1,Derivatives=D1[]);
//m11[]=MetricPk(Th,(x^4+2*4*x^3*y+3*6*x^2*y^2+4*4*x*y^3+5*y^4)/24,kDeg=4,rDeg=1,Derivatives=D1[]);


//plot(m11,m12,m22,dim=3,wait=1);
cout << m11[] << endl;
cout << D1[] << endl;

/*
    Test of Incomplete factorization 
    Choleski and LU

    
*/
load "IncompleteCholesky"

int nn=50;
mesh Th=square(nn,nn);
fespace Vh(Th,P1); 
macro grad(u) [dx(u),dy(u)]//
real kconv =0;
complex cc= 1+2i; 
func f = sin(2*pi*x)*sin(2*pi*y);
varf va(u,v) = int2d(Th) (grad(u)'*grad(v) + u*v + kconv*u*dx(v) ) + int2d(Th)( f*v) +on(1,2,3,4,u=0);
varf vac(u,v) = int2d(Th) (cc*grad(u)'*grad(v) + u*v + kconv*u*dx(v) ) + int2d(Th)( f*v) +on(1,2,3,4,u=0);
real teps =1e-8;
if(1)
{
	verbosity=3;
	matrix L ;// to store in incomplet factorizatin. 
	func real[int] PreconIcho(real[int] & b) {// the precondtionner
		icholSolve(L,b);
		return b;}
	
	matrix AI = va(Vh,Vh,solver=CG,precon=PreconIcho);
	matrix A = va(Vh,Vh,solver=CG,sym=1);
	ichol(A,L);//  take the stucture OF a FOR l; 
	real[int] b = va(0,Vh);
	Vh u,ui;
	verbosity = 4;
	real t0=clock();
	u[]= A^-1*b;
	real t1=clock();
	
	ui[]= AI^-1*b;
	real t2=clock();
	cout << " ** GC/  ichol "<< t2-t1 << " GC/diag  " << t1-t0 << " s "<< " ratio = "<<  (t1-t0 )/(t2-t1+teps) << endl;
	plot(u,wait=1);

}
{ // test ILU 
    kconv =50;
	int n = Vh.ndof;
	verbosity=3;
	matrix L,U;// to store in incomplet factorizatin. 
	
	func real[int] PreconILU(real[int] & b) {
		 iluSolve(L,U,b); 
		 return b;}
		 
	matrix AI =	 va(Vh,Vh,solver=GMRES,precon=PreconILU);
	matrix A = va(Vh,Vh,solver=GMRES);
	
	real[int] b = va(0,Vh);
	iLU(AI,L,U);// do the incomplet LU  with sturct of A.
	
    if(nn<10)	
	  cout << "\n\n **L=" << L <<"\n\n  **U " <<  U << endl; 
	Vh u,ui;
	verbosity = 3;
	real t0=clock();
	u[]= A^-1*b;
	real t1=clock();
	ui[]= AI^-1*b;
	real t2=clock();
	cout << " ** GMRES/  iLU "<< t2-t1 << " GMRES/diag  " << t1-t0 << " s "<< " ratio = "<<  (t1-t0 )/(t2-t1+teps) << endl;
	//plot(u,wait=1);
}

{ // test ILU complex ...
	cout << " Complex \n\n" <<endl;
    kconv =50;
    
	int n = Vh.ndof;
	verbosity=3;
	matrix<complex> L,U;// to store in incomplet factorizatin. 
	
	func complex[int] PreconILU(complex[int] & b) {
		 iluSolve(L,U,b); 
		 return b;}
		 
	matrix<complex> AI = vac(Vh,Vh,solver=GMRES,precon=PreconILU);
	matrix<complex> A = vac(Vh,Vh,solver=GMRES);
	
	complex[int] b = vac(0,Vh);
	L=removeHalf(AI,1);  // build the structure of L
		if(nn<10)
    	  cout << " L " <<  L << endl; 
	U=removeHalf(AI,-1); // build the structure of Ut ( transpose of )
	    if(nn<10)	
		  cout << " U " <<  U << endl; 
		
	iLU(AI,L,U);// do the incomplet LU  
	
    if(nn<10)	
	  cout << "\n\n **L=" << L <<"\n\n  **U " <<  U << endl; 
	Vh<complex> u,ui;
	verbosity = 3;
	real t0=clock();
	u[]= A^-1*b;
	real t1=clock();
	ui[]= AI^-1*b;
	real t2=clock();
	cout << " ** GMRES/  iLU "<< t2-t1 << " GMRES/diag  " << t1-t0 << " s "<< " ratio = "<<  (t1-t0 )/(t2-t1+teps) << endl;
	//plot(u,wait=1);
}
load "BernardiRaugel"

// Parameters
real x1 = 0.7;
real y1 = 0.9;
real h = 1e-7;

// Mesh
mesh Th = square(1, 1, [10*(x+y/3), 10*(y-x/3)]);

// Macro
//a macro to compute numerical derivative
macro DD(f, hx, hy) ((f(x1+hx, y1+hy) - f(x1-hx, y1-hy))/(2*(hx+hy))) //

// Fespace
fespace Vh(Th, P2BR);
Vh [a1, a2], [b1, b2], [c1, c2];

for (int i = 0; i < Vh.ndofK; ++i)
	cout << i << " " << Vh(0,i) << endl;

// Test P2BR
int it1 = Th(x1, y1).nuTriangle;
for (int i = 0; i < Vh.ndofK; ++i){
	a1[] = 0;
	int j = Vh(it1, i);
	a1[][j] = 1;
	plot([a1, a2], wait=true);
	[b1, b2] = [a1, a2]; //do the interpolation
	
	c1[] = a1[] - b1[];
	cout << " ---------" << i << " " << c1[].max << " " << c1[].min << endl;
	cout << " a = " << a1[] << endl;
	cout << " b = " << b1[] << endl;
	assert(c1[].max < 1e-9 && c1[].min > -1e-9); //check if the interpolation is correct
	
	//check the derivative and numerical derivative
	cout << " dx(a1)(x1, y1) = " << dx(a1)(x1, y1) << " == " << DD(a1, h, 0) << endl;
	assert( abs(dx(a1)(x1, y1) - DD(a1, h, 0) ) < 1e-5);
	assert( abs(dx(a2)(x1, y1) - DD(a2, h, 0) ) < 1e-5);
	assert( abs(dy(a1)(x1, y1) - DD(a1, 0, h) ) < 1e-5);
	assert( abs(dy(a2)(x1, y1) - DD(a2, 0, h) ) < 1e-5);
} 

load "Morley"

// Parameter
real f = 1;

// Mesh
mesh Th = square(40, 40); //mesh definition of Omega

// Fespaces
fespace Wh(Th, P2);
fespace Vh(Th, P2Morley);	// HCT finite element space
Vh [u, ux, uy], [v, vx, vy];

// Macro
macro bilaplacien(u, v) (dxx(u)*dxx(v) + dyy(u)*dyy(v) + 2.*dxy(u)*dxy(v))	// end of macro

// Problem
solve bilap ([u, ux, uy], [v, vx, vy])
	= int2d(Th)(bilaplacien(u, v))
	- int2d(Th)(f*v)
	+ on(1, 2, 3, 4, u=0, ux=0, uy=0)
	;

// Plot
plot(u, cmm="u", wait=1, fill=1);
plot(ux, wait=1, cmm="u_x");
plot(uy, wait=1, cmm="u_y");

// Max & Error
Wh uu = u;
real umax = uu[].max;
int err = (abs(umax-0.0012782) > 1e-4);
cout << " uu max = " << umax << " ~ 0.0012782, err = " << err << endl;

// Plot
int n = 100, nn = n+10;
real[int] xx(nn), yy(nn);
for (int i = 0; i <= n; i++) {
	xx[i] = real(i)/n;
	yy[i] = u(0.5, real(i)/n);	// value of uh at point (0.5, i/10.)
}
plot([xx(0:n), yy(0:n)], wait=1);

// End
assert(err == 0);

load "Element_P3"

 mesh Th=square(10,10);
 fespace Vh(Th,P3);     // P1 FE space
 Vh uh,vh;              // unkown and test function.
 func f=1;                 //  right hand side function
 func g=0;                 //  boundary condition function

 problem laplace(uh,vh) =                    //  Definion of  the problem
    int2d(Th,qft=qf7pT)( dx(uh)*dx(vh) + dy(uh)*dy(vh) ) //  bilinear form
  - int2d(Th,qft=qf7pT)( f*vh )                          //  linear form
  + on(1,2,3,4,uh=g) ;                      //  boundary condition form

  laplace; // solve the problem plot(uh); // to see the result
  plot(uh,ps="o/LaplaceP3.eps",value=true);
load "msh3"

real x0=-1.,x1=-0.5;
real y0=-0.5,y1=0.5;

mesh Th1=square(5,8,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

x0=-0.5;
x1=-0.1;
y0=-1;
y1=1;
mesh Th2=square(10,16,[x0+(x1-x0)*x,y0+(y1-y0)*y]);


int[int] r1=[2,0],  r2=[4,0];
Th1=change(Th1,label=r1);
Th2=change(Th2,label=r2);

plot( Th1, Th2, wait=1 );

verbosity=2;

cout << "================" << endl;
cout << "   gluing mesh  " << endl;
mesh Th2D=Th1+Th2;
cout << "Vertex, Triangle, Border " << Th2D.nv << " "<< Th2D.nt << " " <<  endl; 
//plot( Th2D, wait=1 );
savemesh( Th2D, "glu2D.mesh");


func zmin=0.;
func zmax=1.;
int MaxLayer=10;

mesh3 Th31=buildlayers(Th1,MaxLayer,zbound=[zmin,zmax]); 
savemesh( Th31, "bl31.mesh");

mesh3 Th32=buildlayers(Th2,MaxLayer,zbound=[zmin,zmax]); 
savemesh( Th32, "bl32.mesh");

mesh3 Tht=Th31+Th32;
savemesh( Tht, "glu3D.mesh");

cout << "Vertex, Tet, Triangle " << Tht.nv << " "<< Tht.nt << " " << Tht.nbe << endl; 
cout << "area  border = " << int2d(Tht)(1.) << endl; 
verbosity =3;
Tht = change(Tht,rmInternalFaces=1);
cout << "area  border = " << int2d(Tht)(1.) <<endl;
verbosity =1;
func mv1x = 1+x;
func mv1y = y;
func mv1z = z;
mesh3 Thmvs1 = movemesh3(Tht, transfo=[mv1x,mv1y,mv1z]);
savemesh(Thmvs1,"movemeshglumesh.mesh");
// test of DxWriter  from Sala Lorenzo.
load "DxWriter"
mesh Th=square(5,5);
DxWriter ff("pippo");
Dxaddmesh(ff, Th);
Dxaddtimeseries(ff, "Vx",Th);
fespace Vh(Th, P1);
real t=1.0;
Vh vx=x*y*t;
Dxaddsol2ts(ff,"Vx",t, vx);
t=2.0;
vx=x*y*t;
Dxaddsol2ts(ff,"Vx",t, vx);
cout<<"Hello";
load "ffrandom"
srandomdev();  
//  warning under window this
// change the seed by  randinit(random()) ) so all
// freefem++ random function are change..

cout << random() << endl;
cout << random() << endl;
cout << random() << endl;
srandom(10);
cout << random() << endl;
cout << random() << endl;
cout << random() << endl;


//  august 2015 add 
load "msh3"
//  DEF LABEL unit CUBE before transformation 
//  6 face plan label are:
//  y = 0 ) label 1, 
//  x = 1 ) label 2, 
//  y = 1 ) label 3, 
//  x = 0 ) label 4, 
//  z = 0 ) label 5,
//  z = 1 ) label 6.
// the region numbering is 0 by default.
{
	real[int,int] mm= [ [0.5,0.0,0.5], [1.0,0.5,0.5], 
	                    [0.5,1.0,0.5], [0.0,0.5,0.5], 
						[0.5,0.5,0.0], [0.5,0.5,1.0] ];
	int[int] l6=[1,2,3,4,5,6];
	mesh3 Th=cube(2,2,2); //[x*4,y*1+0.1*sin(4*pi*x)]);
	for (int i=1; i< 7; ++i)
	{
		real s = int2d(Th,i)(1.); 
		real mx = int2d(Th,i)(x); 
		real my = int2d(Th,i)(y); 
		real mz = int2d(Th,i)(z); 	
		cout<< i << " " << s <<  " "<< mx << " " << my << " " << mz << endl;
		int j=i-1;
		real err= abs(mx-mm(j,0)) + abs(my-mm(j,1)) + abs(mz-mm(j,2)) ;
		assert(err< 0.1);
	}
}
int[int] l6=[37,42,45,40,25,57];
int r11=11;
mesh3 Th=cube(4,5,6,[x*2-1,y*2-1,z*2-1],label=l6,flags =3,region=r11); 
cout << " volume " << Th.measure << ", border area "<< Th.bordermeasure <<endl; // \index{mesh3!measure} \index{mesh3!bordermeasure}

// Check label dans  region numbering 
int err =0; 
for(int i=0; i<100; ++i)
{
    real s =int2d(Th,i)(1.);
    real sx=int2d(Th,i)(x);
    real sy=int2d(Th,i)(y);
    real sz=int2d(Th,i)(z);
    
    if( s )
    {
     int ix = (sx/s+1.5), iy=(sy/s+1.5), iz=(sz/s+1.5), ii=(ix + 4*(iy+1) + 16*(iz+1) ) ;    
      //  value of ix,iy,iz =>  face min 0 ,  face max 2  , no face 1
      cout <<" label="<< i << " s " << s << " " << ix << iy << iz << " : " << ii << endl; 
      if( i != ii ) err++;
    }
}   
real volr11 = int3d(Th,r11)(1.) ;
cout << " vol region " << 11 << ": " << volr11 << endl; 
if( (volr11 - Th.measure )>1e-8) err++;
plot(Th,fill=0); 
cout << " nb err= " << err <<endl;
assert(err==0); 
// Example of dynamic function load
// --------------------------------
// $Id$

 load "myfunction"
// dumptable(cout);
 mesh Th=square(5,5);
 fespace Vh(Th,P1);
 Vh uh= myfunction(); // warning  do not forget () 
 cout << uh[].min << " " << uh[].max << endl;
 cout << " test io ( " << endl;
 testio();
 cout << " )  end test io .. " << endl;
/*
  Exemple of Mixte furmulation for Lame equation (Linear Elasticity)
   
  The Stress and Strian are  H(div div),  
  for a Sym Stress S we have 
      ( div(div S) in H^-1 
  and S.nn are continuous

  The Displacement u are H(Curl) (    u.tau is continuous )
  where n,tau are normal / tangent 

  This formulation is call TD-NSS
*/
if (HaveUMFPACK) //  need UMPACK  computation 
{
load "Element_Mixte"
load "Element_P3"
int nn=10;
mesh Th= square(nn*4,nn,[x*4,y]);

// caoutchoouc 
//real mu     = 0.012; 
//real lambda = 0.4; 
// rho rho=1e-16;
// ALu
real  mu = 3.8;
real lambda= 6.2;
real rho = 5e-4;
//   s11, s12, s22 
real twomu=mu*2;
real mu1= 1./(twomu);
real lambda1 = 1./(2*(2*lambda+twomu)) - 1./(twomu*2);
macro BItr(a,b)  /* S-> a S + b tr(S) Id */  
[ [ a + b , 0 , 0 ,b       ], 
  [     0 , a , 0 ,0         ], 
  [     0 , 0 , a ,0         ], 
  [   b   , 0 , 0 , a+ b  ]    ] //

func A = BItr(twomu,lambda) ;
func A1 = BItr(mu1,lambda1) ;

real gravity = -9.81*rho;



macro Strain(u)  [dx(u#1),(dy(u#1)+dx(u#2))/2,(dy(u#1)+dx(u#2))/2,dy(u#2)] //EOM
macro Strain2(s)  [s#11, s#12, s#12, s#22] //EOM
macro S(s) [s#11,s#12,s#22]//
  macro U(u) [u#1,u#2] //
  macro dn(u) (U(u)'*[N.x,N.y]) //')
  macro dnn(s) ( [N.x,N.y]' * [[ s#11,s#12] , [s#12, s#22] ] *[N.x,N.y]) //')

fespace Wh(Th,[P2,P2]);
fespace Sh(Th,TDNNS1);
fespace Vh(Th,BDM1Ortho);
Sh S(s),S(t);
Vh U(u),U(v);;
Wh U(w),U(ww);

  solve Lame2([s11,s12,s22,u1,u2],[t11,t12,t22,v1,v2])=
  int2d(Th)( 
	       Strain2(s)'*(A1*Strain2(t)) //' 
	    - Strain(u)'*Strain2(t)  //'
	    - Strain(v)'*Strain2(s) //'
     //      + 1e-6*(u1*v2+u2*v2)
	     )
  +  intalledges(Th)( dnn(t)*dn(u) + dnn(s)*dn(v) ) 
  //  - int1d(Th,4) ( 0*dnn(t) ) // here  0 <=> U_d .n * dnn(t) 
  +  int2d(Th) ( gravity*v2) //-int2d(Th,1,2,3) ( dNtau(t). v.tau) 
  +on(1,2,3,s11=0,s12=0,s22=0)
  +on(4,u1=0,u2=0); 



  solve Lame1([w1,w2],[ww1,ww2])=
  int2d(Th)( 
	      Strain(w)'*(A*Strain(ww)) //' 
	     )
 -int2d(Th)(gravity*ww2)
  +on(4,w1=0,w2=0); 
plot([w1,w2], wait=1);
plot([u1,u2], wait=1);

real errl2 = sqrt(int2d(Th)( square(w1-u1) + square(w2-w2)));
cout << " errL2 = " << errl2 << endl;
}




load "Element_P4"
load "Element_Mixte"
load "Element_PkEdge"
macro DD(f,hx,hy) ( (f(x1+hx,y1+hy)-f(x1-hx,y1-hy))/(2*(hx+hy))) //
macro dn(f) ( N.x*dx(f)+N.y*dy(f)) //
macro ccn(f) ( N.x*f#1+N.y*f#2) //
macro cctau(f) ( -N.y*f#1+N.x*f#2) //
macro dnn(f) ( N.x*N.x*f#11+2.*N.y*N.x*f#12+ N.y*N.y*f#22) //
mesh Th=square(1,1,flags=1);//,[10*(x+y/3),10*(y-x/3)]);
Th=trunc(Th,(x+y)<1.1);plot(Th,wait=1);
Th=movemesh(Th,[0.1*(x+y/3),0.1*(y-x/3)]);
Th=movemesh(Th,[0.1*(x),0.1*(y)]);
real x1=0.7,y1=0.9, h=1e-6;
int it1=Th(x1,y1).nuTriangle; 

fespace Zh(Th,P1dc); 
Zh  f11= 1, f12=0, f22=0;

fespace Vh(Th,TDNNS1);
cout << Vh.ndof << endl;
cout << Vh.ndofK << endl;
fespace Eh(Th,P0edge);
fespace Ehdc(Th,P0edgedc);

fespace P3h(Th,[P0,P0,P0]);


Eh  edges;
 macro SS(a) [a#11,a#12,a#22] //

P3h SS(pp);

Vh SS(a),SS(b),SS(c);

varf vFlux([ax11,ax12,ax22],[e]) = intalledges(Th,qforder=1)( dnn(a)*e*lenEdge);
edges=x; 
cout << " x = " << edges[]<< endl; 
edges=y; 
cout << " y = " << edges[]<< endl; 

real gx=1./3., gy(1./3); 


for(int j=0; j<Vh.ndofK;++j)
{int i= Vh(0,j);
 cout << "****" << j << " "  << i << endl; 
 a11[]=0;
 a11[][i]=1;
/*
 x=0; y = 0.5;  N.x = -1; N.y = 0; 
  cout << " ------ dnn (0.,0.5) " << dnn(a) <<  "   " ;
 x=0.5; y = 0.5;  N.x = 1; N.y = 1; 
 cout << " dnn (.5,.5) " << dnn(a) << "     " ;
 x=0.5; y = 0.;  N.x = 0; N.y = -1; 
  cout << " dnn (0.5,0) " << dnn(a) << endl;
  cout << " (0,0.5)  = " << a11(0,0.5) << " " << a12(0,0.5) << " " << a22(0,0.5) << endl;
  cout << " (0.5,0)  = " << a11(0.5,0) << " " << a12(0.5,0) << " " << a22(0.5,0) << endl;
  cout << " (0.5,0.5)  = " << a11(0.5,0.5) << " " << a12(0.5,0.5) << " " << a22(0.5,0.5) << endl;
*/
 // cout << " ...... " << int2d(Th)(a11) << " " << int2d(Th)(a12) << " " <<int2d(Th)(a22) << endl;

// plot(a11,wait=1,cmm="a00 "+i);
// plot(a22,wait=1,cmm="a22 "+i);
// plot(a12,wait=1,cmm="a12 "+i);
edges[]=vFlux(0,Eh);
// cout << a11(gx,gy) << " " << a12(gx,gy) << " " << a22(gx,gy) << " at G "<< " " <<OA
  cout << " ...... " << int2d(Th)(a11) << " " << int2d(Th)(a12) << " " <<int2d(Th)(a22)  << "   --- " ; 
  for(int j=0;j<3;++j)
   cout << edges[](Eh(0,j)) << " " ;
 cout << "   *** Edges flux n.n " << j  << endl;  

}
 
SS(a) =SS(f);
cout << a11[].n << " a = "<< a11[] <<endl; 

 cout << a11(0.6,0.2) << " == " << f11(0.6,0.2) << endl;
 cout << a12(0.6,0.2) << " == " << f12(0.6,0.2) << endl;
 cout << a22(0.6,0.2) << " == " << f22(0.6,0.2) << endl;
 cout << " 00 = " << int2d(Th)(square(a11-f11)) << endl;
 cout << " 00 = " << int2d(Th)(square(a22-f22)) << endl;
 cout << " 00 = " << int2d(Th)(square(a12-f12)) << endl;
//plot(a11,wait=1);

//Th=square(1,1,[10*(x+y/3),10*(y-x/3)]);
//it1=Th(x1,y1).nuTriangle;


for (int i=0;i<Vh.ndofK;++i)
	cout <<  i << " l  -> G " << Vh(0,i) << endl;
 macro diff(err,dd,c,a,s) { real ddd = int2d(Th) (square( dd(a)-dd(c))) ;
  cout << " ddd " << s << " : " <<ddd <<endl;
 if (ddd>1e-10)  err++ ;} //
int err=0;
for (int i=0;i<Vh.ndofK;++i)
{
  cout << " ***  node " << i << " of Traingle " << it1 << endl;
  a11[]=0;	
  int j=Vh(it1,i);
  a11[][j]=1;
  SS(b)=SS(a);
  cout << " b = " << b11[] << endl; 
  b11[]-=a11[];
  edges[]=vFlux(0,Eh);
  cout << "Mean  edges = " << edges[] << "  diff = " << b11[].linfty <<endl; 
  if (b11[].linfty > 1e-10) err++; 
  Zh c11=a11,c12=a12,c22=a22;
 
    
 // plot(a12,wait=1,cmm="a12 "+i );
 // plot(c12,wait=1,cmm="c12 "+i );
  diff(err, ,c11,a11," ");
  diff(err, ,c12,a12," ");
  diff(err, ,c22,a22," ");
  diff(err, dx,c11,a11,"dx");
  diff(err, dx,c12,a12,"dx");
  diff(err, dx,c22,a22,"dx");

  diff(err, dy,c11,a11,"dy");
  diff(err, dy,c12,a12,"dy");
  diff(err, dy,c22,a22,"dy");


  
} 
assert(err==0);
for(int i=0;i<P3h.ndof;++i)
 {
 	cout << " i =" << i << endl;
 	pp11[]=0;
 	pp11[][i]=1;
 	SS(a)=SS(pp);
 	diff(err, ,pp22,a22," ");
 	diff(err, ,pp11,a11," ");
 	diff(err, ,pp12,a12," ");

 }

// FFCS - reference value
real ref;

{
assert(err==0);

NewMacro V(u) [u#1,u#2] EndMacro
NewMacro CheckRT(RT,RTname,xx,yy,pxy,dxxx,V,doassert)
cout << " Check  ***********" << RTname <<  "\n"; 

{
fespace Wh1 (Th,RT);
fespace Ph1 (Th,P1);
fespace Ph2 (Th,P2dc);
fespace Kh (Th,P2);
fespace P4h (Th,P4);
fespace Eh0 (Th,P1nc);
Wh1 V(u), V(w);

int err1=0;
for( int j=0;j<Wh1.ndofK;++j)
{
  int i=Wh1(0,j); 
  u1[] =0;
  u1[][i]=1;
  Ph2 U1=u1,U2=u2;
  U1=u1;
  U2=u2;
  cout << j << " " << i << " int K = " << int2d(Th,qforder=3)(u1) << " --- " << int2d(Th,qforder=3)(u2) << "   ---  " << int1d(Th,qforder=2)( u1*N.x + u2*N.y) << " .. " << err1 <<  endl;
  V(w)=V(u);
  varf veeee(uu,E) = intalledges(Th)( (nTonEdge==2) *E*( jump(dxxx(u))));
  real ddcc=intalledges(Th)( (nTonEdge==2) *square( jump(dxxx(u))));
  if(ddcc > 1e-10) {err1++;  cout << j<< " " << i << " err disc " << ddcc << endl;
  Eh0 eee; eee[]=veeee(0,Eh0);
  plot(eee,cmm=" jump ",fill=1,wait=1); 
   mesh Tg=trunc(Th,1,split=5);
  fespace WWh(Tg,P2dc);
  WWh  gu1=u1,gu2=u2;
   plot([gu1,gu2],wait=1,cmm=" dof "+j+" K=0 ");}
  w1[][i]-=1;
  if(w1[].linfty > 1e-10) { w1[][i]+=1;cout << j << " " << i << " diff = "   << w1[] << " " << err1 << endl;}
  cout << j << " ||w - (\delta_ij)_j=  || " << w1[].linfty << endl;
  assert( w1[].linfty < 1e-10);
  NewMacro diff2(op) int2d(Th)(square(op(u1)-op(U1))+square(op(u2)-op(U2))) EndMacro 
  assert( diff2(  )) ;
  assert( diff2(dx)) ;
  assert( diff2(dy)) ;


}
assert(abs(err1)<1e-10);

Th=square(5,5,[10*(x+y/3),10*(y-x/3)]);
V(u)=[0,0];
V(w)=[0,0];

  P4h p1=pxy;
  P4h uu1 =  1-x+xx*p1;
  P4h uu2 =  2-2*y+yy*p1;


 [u1,u2] = [uu1 ,uu2];
 real eerr1=int2d(Th)( square(uu1-u1) )/ Th.area ,err2=int2d(Th)( square(uu2-u2) )/Th.area;
 real errx1= int2d(Th)( square(dx(uu1)-dx(u1)) )/ Th.area ,errx2=int2d(Th)( square(dx(uu2)-dx(u2)) )/Th.area;
 real erry1= int2d(Th)( square(dy(uu1)-dy(u1)) )/ Th.area ,erry2=int2d(Th)( square(dy(uu2)-dy(u2)) )/Th.area;
 
 cout << "err "+RTname+" "<< eerr1 << " "  << err2  << endl;
 cout << "  dx " <<  errx1 <<" " << errx2 << endl; 
 cout << "  dy " <<  erry1 <<" " << erry2 << endl; 
 plot([u1,u2],wait=1,cmm=RTname);
 real err=eerr1+err2+errx1+errx2+erry1+erry2; 
 if( doassert) assert( err< 1e-6);
for( int i=0;i<Wh1.ndof;++i)
{

  u1[] =0;
  u1[][i]=1;
  V(w)=V(u);
  w1[][i]-=1;
  assert( w1[].linfty < 1e-10);

  // FFCS reference value
  ref=w1[].linfty;
}

cout << " End  Check  ***********" << RTname <<  " Ok .... \n"; 
}
EndMacro
func pxy0=2;
func pxy1=2+x-y*3;
func pxy2 = 2+x+y*2+x*x+2*x*y+-x*x;
CheckRT(RT1,"RT1",x,y,pxy1,ccn,V,1)
CheckRT(RT1Ortho,"RT1Ortho",-y,x,pxy1,cctau,V,1)

CheckRT(RT2,"RT2",x,y,pxy2,ccn,V,1)
CheckRT(RT2Ortho,"RT2Ortho",-y,x,pxy2,cctau,V,1)
CheckRT(BDM1,"BDM1",x,y,pxy0,ccn,V,1)
CheckRT(BDM1Ortho,"BDM1Ortho",-y,x,pxy0,cctau,V,1)
CheckRT(BDM2,"BDM2",x,y,pxy1,ccn,V,1)
//  buggus FH  version 4.13 ??? in test !!!!  
CheckRT(BDM2Ortho,"BDM2Ortho",-y,x,pxy1,cctau,V,1)
	
}
load "ppm2rnm" load "isoline"
string leman="lg.pgm";
real AreaLac =  580.03; // $Km^2$
real hsize= 5;
real[int,int] Curves(3,1);
int[int] be(1);
int nc;// nb of curve
{
  real[int,int] ff1(leman); // read  image and set to an rect. array
  int nx = ff1.n, ny=ff1.m; // grey value between 0 to 1 (dark)
  // build a Cartesian mesh such that the origne is qt the right place.
  mesh Th=square(nx-1,ny-1,[(nx-1)*(x),(ny-1)*(1-y)]);
   // warning  the numbering is of the vertices (x,y) is
   // given by $  i = x/nx + nx* y/ny $
  fespace Vh(Th,P1);
  Vh f1; f1[]=ff1; //  transforme array in finite element function.
  plot(f1,wait=1);
  nc=isoline(Th,f1,iso=0.25,close=1,Curves,beginend=be,smoothing=.1,ratio=0.5);
  verbosity=1;
}
// the longuest isoline
int ic0=be(0), ic1=be(1)-1;
plot([Curves(0,ic0:ic1),Curves(1,ic0:ic1)], wait=1);
int NC= Curves(2,ic1)/hsize;
real xl = Curves(0,ic0:ic1).max-5;
real yl = Curves(1,ic0:ic1).min+5;
border G(t=0,1) {  P=Curve(Curves,ic0,ic1,t);  label= 1 + (x>xl)*2 + (y<yl);}

plot(G(-NC),wait=1);
mesh Th=buildmesh(G(-NC));
plot(Th,wait=1);
real scale = sqrt(AreaLac/Th.area);
Th=movemesh(Th,[x*scale,y*scale]); // resize the  mesh to have the correct scale
cout << " Th.area = " << Th.area << " Km^2 " << " == " << AreaLac <<  "   Km^2 " << endl ;
plot(Th,wait=1,ps="o/leman.eps");
load "Element_Mixte3d"
load "msh3"
//load "Element_P1dc1"
/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n).n$ on $\Gamma_4$

*/
int nn=7;
mesh3 Th=cube(nn,nn,nn);
fespace Wh(Th,P1);
fespace Vh(Th,RT13d);
fespace Ph(Th,P1dc);

func gd = 0.;
func g1n = 1.;
func g2n = 1.;
func g3n = 1.;
func f = 1.;

Vh [u1,u2,u3],[v1,v2,v3];
Ph p,q;
Wh pp,qq;
problem laplaceMixte([u1,u2,u3,p],[v1,v2,v3,q],solver="SPARSESOLVER",eps=1.0e-10,tgv=1e30,dimKrylov=150) =
   int3d(Th)( p*q*0e-10+ u1*v1 + u2*v2 + u3*v3
	   + p*(dx(v1)+dy(v2)+dz(v3)) + (dx(u1)+dy(u2)+dz(u3))*q )
 + int3d(Th) ( f*q)
 - int2d(Th,1,2,3,4,5,6)( gd*(v1*N.x +v2*N.y+ v3*N.z))   //  int on gamma
// + on(4,u1=g1n,u2=g2n,u3=g3n)
 ;
 macro grad(u) [dx(u),dy(u),dz(u)]//
 solve LapP1(pp,qq) = int3d(Th)(grad(pp)'*grad(qq)) - int3d(Th)(f*qq) +on(1,2,3,4,5,6,pp=gd);
 laplaceMixte;
 real err =  int3d(Th)(abs(pp-p));
 cout << "err =" <<  err << " max  "<< pp[].max << " " << p[].max << endl;
 plot(p,wait=1,ps="o/laRTp.eps",value=true);  
 //  BUG after 22 march 2021FH the err increase from 0.005 or 0.01 
 // no raison (possibly due too little chaneg in position of dof ...)
 // err go from 0.002 or 0.006 ????
 assert(err < 0.01);
load "Element_P1bl"
load "splitmesh3"
load "msh3"

// 2d OK ???
{
mesh Th=square(1,1);
fespace Vh(Th,P1bl);
cout << Vh.ndofK << " "<< Vh.ndof << endl;
func f=x+2*y+x*(1-x)*y*(1-y)*30;
Vh u=f;
mesh Th2=splitmesh3(Th);
fespace Vh2(Th2,P1dc);
Vh2 u2=u;
Vh2 u2e=f;

plot(u2,u2e,wait=1);
u2[] =- u2e[];
cout << " diff = " << u2[].linfty << endl; 

for(int i=0; i<  Vh.ndof ; ++i)
{
	u[]=0;
	u[][i] = 1;
	u2=u;
	real err1 = int2d(Th2)((dx(u2)-dx(u))^2); 
	real err2 = int2d(Th2)((dy(u2)-dy(u))^2); 
	cout << err1 << " " << err2 << endl; 
	plot(u2,wait=1,cmm="i="+i+" err="+err1+err2 );
	assert(err1+err2< 1e-5); 
}
}

// 3d 

{
mesh3 Th=cube(1,1,1);
fespace Vh(Th,P1bl3d);
fespace Wh(Th,P1b3d);

func f=x+2*y+3*z+x*(1-x)*y*(1-y)*z*(1-z)*100;
Vh u=f;
Wh u2=u;
Vh u2e=f;

plot(u,u2e,wait=1);
u2[] =- u2e[];
cout << " diff = " << u2[].linfty << endl; 
}
load "msh3"

int n=10;

/*      Th11
  -----------------	
/Th2 /	|	  /| 
-----------------/ | 
|		|Th5|	| Th6  
|Th1	|  /	|  /
|       |/      | /
-----------------/
        Th22
*/

meshS Th1 = square3(n,n,[2*x,y,1],orientation=-1);
meshS Th2 = square3(n,n,[2*x,y,0],orientation=1);
meshS Th11 = square3(n,n,[2*x,1,y],orientation=1);
meshS Th22 = square3(n,n,[2*x,0,y],orientation=-1);
meshS Th5 = square3(n,n,[1,y,x]);
meshS Th6 = square3(n,n,[2,y,x],orientation=1);

meshS Th = Th1+Th2+Th11+Th22+Th5+Th6;
plot(Th,wait=1);
assert(Th.nbnomanifold==40);

meshS[int] Thglue(6);
Thglue[0] = Th1;
Thglue[1] = Th2;
Thglue[2] = Th11;
Thglue[3] = Th22;
Thglue[4] = Th5;
Thglue[5] = Th6;


meshS Thglued = gluemesh(Thglue);
assert(Thglued.nbnomanifold==40);

plot(Thglued,cmm="2");


load "msh3"
load "medit"
load "mmg"

int nn = 15;

mesh3 Th3=cube(nn,2*nn,nn,[x,2*y,z]);

func head = sqrt((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)-0.3;
func ear1 = sqrt((x-0.3)^2+(y-0.5)^2+0.5*(z-0.8)^2)-0.1;
func ear2 = sqrt((x-0.7)^2+(y-0.5)^2+0.5*(z-0.8)^2)-0.1;
func nose = sqrt((x-0.5)^2+0.006*(y-0.9)^2+(z-0.5)^2)-0.03;

fespace Uh(Th3,P1);
Uh Pinocchio = min(min(min(head,ear1),ear2),nose);

Th3 = mmg3d(Th3,metric=Pinocchio[],iso=1,ls=0,hausd=0.008,hgrad=2.3,verbose=10,mem=1000);// 1 G de ram ..
Th3 = buildBdMesh(Th3);
//medit("Th3",Th3);

meshS ThS = Th3.Gamma;
ThS = trunc(ThS,region==10);
ThS = mmgs(ThS,hausd=0.004,hgrad=2.3);
medit("Pinocchio",ThS);
load "msh3"
//load "medit"

//load "gmsh"
//load "iovtk"

int n= 10;
int nvb = (n+1)^3 - (n-1)^3;// Nb boundary vertices
int ntb = n*n*12; // Nb of Boundary triangle 
mesh3 Th=cube(n,n,n);
Th = buildBdMesh(Th); // build the surface mesh


int[int] ref2=[1,0,2,0];
mesh3 Thm=change(Th,label=ref2);


meshS Th1 = Th.Gamma;

assert(Th1.nv==602); 
assert(Th1.nt==1200);
assert(Th1.nbe==120);

plot(Th1);
savemesh(Th1, "Th1.mesh");

meshS Th2 = readmeshS("Th1.mesh");

assert(Th1.nv==Th2.nv); 
assert(Th1.nt==Th2.nt);
assert(Th1.nbe==Th2.nbe);
load "msh3" 
//Validation of Laplace Equation on Torus (Thanks to I. Danaila and G. Sadaka)



real R = 3, r=1; 
real h = 0.2; // 
int nx = R*2*pi/h;
int ny = r*2*pi/h;
func Tx= (R+r*cos(y))*cos(x);
func Ty= (R+r*cos(y))*sin(x);
func Tz= r*sin(y);
macro grad(U) [dx(U)/(R+r*cos(y)),dy(U)/r]//
macro grad3(u) [dx(u),dy(u),dz(u)]  // EOM

// inverse tranformation (Tx,Ty,Tz)
func T1x= atan2(y,x);
func T1y= atan2(z,dist(x,y)-R);
func Jtore = (R+r*cos(y));
// verif transfo inverse : 
cout << " T1x "<< T1x(Tx(0.5,1),Ty(0.5,1),Tz(0.5,1)) << " T1y " << T1y(Tx(0.5,1),Ty(0.5,1),Tz(0.5,1)) << endl;
mesh Th=square(nx,ny,[2*pi*x,2*pi*y]) ;

meshS ThS=movemesh23(Th,transfo=[Tx,Ty,Tz],removeduplicate=1) ;

fespace Vh(Th,P1,periodic=[[1,x],[3,x],[2,y],[4,y]]);
fespace VhS(ThS,P1);
// 
VhS fs = x+y+z;
Vh fh=fs(Tx,Ty,Tz); //  fs on Th 
VhS u,v;
Vh uh;

solve Lap(u,v) = int2d(ThS)( u*v+grad3(u)'*grad3(v)) -int2d(ThS)(fs*v);
plot(u,wait=1,nbiso=20,fill=1);
uh=u(Tx,Ty,Tz);
plot(uh,wait=1);

Vh U,V;

solve Laph(U,V) = int2d(Th)( (U*V+grad(U)'*grad(V))*r*(R+r*cos(y))) -int2d(Th)(fh*V*r*(R+r*cos(y)));

plot(U,uh,wait=1,cmm=" 2 ");
U[] -= uh[];
cout << U[].linfty << endl; 
assert(U[].linfty < 1e-2 );

load "gmsh"

load "msh3"
int nn=20;
mesh Th2=square(nn,nn,region=0);
fespace Vh2(Th2,P2);
Vh2 ux,uz,p2;
int[int] rup=[0,2],  rdown=[0,1], rmid=[1,1,2,1,3,1,4,1];
real zmin=0,zmax=1;
mesh3 Th=buildlayers(Th2,nn,
  zbound=[zmin,zmax],
  labelmid=rmid,
  reffaceup = rup,
  reffacelow = rdown);

Th = buildBdMesh(Th); // build the surface mesh
meshS ThS= Th.Gamma;

fespace Vh(ThS,P2);
Vh u,v;

func ue =   2*x*x + 3*y*y + 4*z*z + 5*x*y+6*x*z+1;
func uex=   4*x+  5*y+6*z;
func uey=   6*y + 5*x;
func uez=   8*z +6*x;
func f= -18. ;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM
// 
problem Lap3dS(u,v,solver=CG)  =
  int2d(ThS)(Grad3(v)' *Grad3(u)) //') for emacs
  + int1d(ThS,2)(u*v)
  - int2d(ThS)(f*v)
  - int1d(ThS,2) ( ue*v + (uex*N.x +uey*N.y +uez*N.z)*v )
  + on(1,u=ue);
Lap3dS;

plot(u,wait=1);


savegmsh(ThS,"ThS");

 

load "msh3"
int nn=100;

mesh Th2=square(nn,nn);
real theta = pi/2;
meshS Th = movemesh23(Th2, transfo=[x, cos(theta)*y-sin(theta)*z, sin(theta)*y+cos(theta)*z]);

func uex=x; func uey=6.*x; func uez=0.;
func uSex=x; func uSey=6.*(cos(theta)*y-sin(theta)*z)-9*x; func uSez=0.;
func f= -18. ;

fespace Vh(Th,P1);
Vh u,v;

macro Grad3(u) [dx(u),dy(u),dz(u)]  // EOM
macro Grad2(u) [dx(u),dy(u)]  // EOM

problem Lap3dS(u,v)  =
  int2d(Th)(Grad3(v)' *Grad3(u))
  + int1d(Th,2)(u*v)  
  - int2d(Th)(f*v) 
  - int1d(Th,2) ((uSex*N.x +uSey*N.y +uSex*N.z)*v )
  + on(1,u=0);
Lap3dS;

plot(u,wait=1);

fespace Vh2(Th2,P1);
Vh2 u2,v2;

problem Lap2d(u2,v2)  =
  int2d(Th2)(Grad2(v2)' *Grad2(u2))
  + int1d(Th2,2)(u2*v2)  
  - int2d(Th2)(f*v2) 
  - int1d(Th2,2) ((uex*N.x +uey*N.y)*v2 )
  + on(1,u2=0);
Lap2d;

cout << " u min::   " << u[]. min << "  max: " << u[].max << endl;
cout << " u2 min::   " << u2[]. min << "  max: " << u2[].max << endl;

real[int] err = u[] - u2[];

assert( abs(err.l2) < 1e-6);
plot(u2,wait=1);






load "msh3"

int bottombeam = 2;
border a(t=2, 0){x=0; y=t ;label=1;}	// left beam
border b(t=0, 10){x=t; y=0 ;label=bottombeam;}	// bottom of beam
border c(t=0, 2){x=10; y=t ;label=1;}	// rigth beam
border d(t=0, 10){x=10-t; y=2; label=3;}	// top beam
mesh th1 = buildmesh(b(20) + c(5) + d(20) + a(5));
meshS Th=movemesh23(th1,transfo=[x,y,z]);

real E = 21.5e4;
real sigma = 0.29;
real mu = E/(2.*(1.+sigma));
real lambda = E*sigma/((1.+sigma)*(1.-2.*sigma));
real gravity = -0.05;

cout << "Lambda = " << lambda << endl;
cout << "Mu = " << mu << endl;
cout << "Gravity = " << gravity << endl;

fespace Vh(Th,[P1,P1,P1]);
Vh [u1,u2,u3], [v1,v2,v3];

real sqrt2=sqrt(2.);
macro epsilon(u1,u2,u3)  [dx(u1),dy(u2),dz(u3),(dz(u2)+dy(u3))/sqrt2,(dz(u1)+dx(u3))/sqrt2,(dy(u1)+dx(u2))/sqrt2] // EOM
macro div(u1,u2,u3) ( dx(u1)+dy(u2)+dz(u3) ) // EOM
  
solve Lame([u1,u2,u3],[v1,v2,v3])=
  int2d(Th)( lambda*div(u1,u2,u3)*div(v1,v2,v3)	
	    +2.*mu*( epsilon(u1,u2,u3)'*epsilon(v1,v2,v3) ) )
  - int2d(Th) (gravity*v3)
  + on(1,u1=0,u2=0,u3=0);

real dmax=  u1[].linfty, coef= 1./dmax;

assert(dmax<7.6e-06);
cout << " max deplacement = " << dmax << " " <<coef<<endl;

plot(Th,[u1,u2,u3], wait=1);

// Move mesh
meshS thm = movemesh(Th, [x+coef*u1, y+coef*u2, z+coef*u3]);
plot(Th,thm, wait=1);

include "buildmeshS.idp"
border bc(t=0,2*pi) {  x = 1+cos(t); z= 2+sin(t); y = 3+0.5*sin(5*t);label=1;region=3;}
border bci(t=0,2*pi) {  x = 1+0.5*cos(-t); z= 2+0.5*sin(-t); y = 3+0.1*cos(2*t);label=2;region=4;}
verbosity=1; 
meshL TL= buildmeshL(bc(100)+bci(50));
cout << " TL: regions "<< regions(TL) << endl;
cout << " TL: labels "<< labels(TL) << endl;
meshS Ts=buildmeshSminsurf(TL,1); // minimal  surface 
meshS Tsl=buildmeshSLap(TL,1); // Lapace   surface  
plot(Ts,Tsl,TL,wait=1); 

cout << " TL: regions "<< regions(Ts) << endl;
cout << " TL: labels "<< labels(Ts) << endl;




load "msh3"

// Parameters
int nn = 30; // Mesh quality

// Mesh
int[int] labs = [1, 2, 2, 1, 1, 2]; // Label numbering
mesh3 Th = cube(nn, nn, nn, label=labs);
// extract the surface (boundary) of the cube
int[int] llabs = [1, 2]; //  Th = buildSurface(Th); 
meshS ThS = extract(Th,label=llabs);


// Remove the ]0.5,1[^3 domain of the surface cube
ThS = trunc(ThS, (x < 0.5) | (y < 0.5) | (z < 0.5), label=1);
plot(ThS);
// Fespace
fespace Vh(ThS, P1);
Vh u, v;

// Macro
macro Grad(u) [dx(u), dy(u), dz(u)] //

// Define the weak form and solve
solve Poisson(u, v, solver=CG)
    = int2d(ThS)(
          Grad(u)' * Grad(v)
    )
    -int2d(ThS)(
          1 * v
    )
    + on(1, u=0)
    ;

// Plot
plot(u, nbiso=15);
load "msh3" 
load "medit"
load "ioply"

// Parameters
int nn = 10; // Mesh quality
//example of operator for meshS 

// read the imput mesh, vertice/tetra/triangle/edge 
mesh3 Th3 = cube(nn,nn,nn);
Th3 = buildBdMesh(Th3); // build the surface mesh 
meshS ThS = Th3.Gamma;
//split the extrating surface
//plot(Th3);
meshS ThSsplit = trunc(ThS, 1, split=3);
mesh3 Th3split = trunc(Th3, 1, split=2);
savemesh(Th3split, "Th3split.mesh");

meshS Th3splitG = Th3split.Gamma;

medit("buildFromMesh3Splited",Th3splitG);
medit("buildFromMesh3Initial",ThSsplit);

mesh3 Th3mv = movemesh(Th3,[x+1,y/2,z+y]);
Th3mv=buildBdMesh(Th3mv);
meshS Th3mvG = Th3mv.Gamma;
meshS ThSmv = movemesh(ThS,[x+1,y/2,z+y]);

medit("Th3mvG",Th3mvG);
medit("ThSmv",ThSmv); 

meshS ThS2=plyloadS("plane.ply");
plot(ThS2);
//  version 4.11-1.. 13 sep 2022
meshS Ths = square3(10,10,[x,y,square(2*x-1)+square(2*y-1)]); 
plot(Ths,wait=1);
real[int] gzz;
mesh Th2 = movemesh(Ths,transfo=[x,y,z],getZ=gzz);//  get flat 2d mesh ...
fespace Vh2(Th2,P1);
Vh2 gz; gz[]=gzz;
plot(gz,wait=1);

load "msh3" 

// c0 lap u + c1 u = f 
// CL u|x=0 = 0
// f = g
// time scheme backward euler 
// [ c0 masse + c1 rigidity ] u^n = fv + rho*epsilon/tau masse  V^n-1
// + [ rho*epsilon/dt^2*(1 + dt alpha) masse + beta*\lambda1/tau rigidity ] u^{n-1}

 
// parameters
real density = 0.9, young = 0.9e5, poisson = 0.4, thickness = 0.1;
real alpha = 0., beta = 0; //(coeff rayleigh)
real dt = 0.0001, iMax = 500.;
//real tgv = 1e30; // a hude value of exact penalisation of boundary condition

func h= sin(pi*x);

real lambda0 = young*thickness/(0.25*(1-poisson*poisson)); 
real lambda1 = young*thickness/(2.*(1.+poisson));   
real c0 = density*thickness/(dt*dt)+lambda0+alpha*density*thickness/dt;
real c1 = lambda1+beta*lambda1/dt;
real a = density*thickness*(1.+dt*alpha)/(dt*dt);
real b = density*thickness/dt;

macro Grad(u) [dx(u),dy(u),dz(u)]  // EOM

// string mesh 
meshS Th=square3(20,50,[x,3.*y,z]);
savemesh(Th,"ThL.mesh");
// FE space
fespace Uh(Th,P1);
Uh u, v, V, uold ;
V=0;uold=0;

func g=10000.; //x^2;//; //10000.
// c0 * mass matrix + c1 stifness matrix
varf m(u,v) = int2d(Th) (u*v);
varf k(u,v) = int2d(Th) (Grad(u)'*Grad(v));
varf mmkk(u,v) = int2d(Th) (c0*u*v + c1*Grad(u)'*Grad(v)) + on(2,u=0);
varf cl(u,v) = on(2,u=0);

matrix mass=m(Uh,Uh);
matrix stifness=k(Uh,Uh);
matrix mk = mmkk(Uh,Uh); //,tgv=tgv,solver="SPARSESOLVER");

varf f(u,v) = int2d(Th)(g*v);
real[int] Force=f(0,Uh);
real[int] CL=cl(0,Uh);
matrix T = a*mass + (beta*lambda1/dt)*stifness;  

//initial condition
u[] = 0;
  
meshS Thmv;
real t=dt;

for (int i=0; i<=iMax; i++) {
	   V[]=(u[]-uold[]);
	   V[]/=dt; 
	   uold[]=u[];
	   //  for the time dependant part
	   real[int] rhs = mass*V[];  	   
	   rhs *= b;
	   rhs += CL;
	   rhs += T*uold[];
	   // apply the external force
	   if(i==1 || i==100)
	   		rhs+=Force;
	   u[] = mk^-1*rhs;
	   t+=dt;
	   // coeff for the visu
	   real coeff=100;
	   Thmv=movemesh(Th,[x,y,u*coeff]);
	   if (verbosity)
	   		cout << " time " << t << " u min "<< u[].min << " u max " << u[].max << endl;
       plot(Th, Thmv, wait=0, cmm=" d = "+t+" iter = "+i,prev=1);


    }

load "msh3"

meshS Th=square3(20,20,[x*2*pi,y*2*pi]);
fespace Vh(Th,P1,periodic=[[1,x],[3,x],[2,y],[4,y]]);

func u2e =(sin(x+1)*sin(y+2));
Vh u2,v2,u2h=u2e;
func f2= 2.*u2e;
macro grad3(u) [dx(u),dy(u),dz(u)]//
solve PP2(u2,v2) = int2d(Th)(grad3(u2)'*grad3(v2)+1e-6*u2*v2) - int2d(Th)(f2*v2) ;
plot(u2,u2h,wait=1);
u2[]-=u2h[];

cout << " err 2 = " << u2[].linfty << endl;

assert(u2[].linfty< 0.05);
// test to validate the addition of surfacic finite elements in FreeFEM

load "msh3"
load "medit"

/////variational form

/////////////////////////////////
// laplacian 2D
mesh Th = square(10,10);

fespace Vh(Th,P1);
Vh uVar,vVar;
Vh uPb, vPb;
func f = -12.;
func g = P.x*P.x+2.*P.y*P.y;

macro Grad2(uVar) [dx(uVar),dy(uVar)]  // EOM

//with variational form
varf a(uVar,vVar) = int2d(Th)(Grad2(uVar)'*Grad2(vVar))
 + int2d ( Th ) ( f * vVar )
  + on(1,uVar=g);

matrix AVar =a(Vh,Vh);
real[int] bVar = a(0,Vh);
real[int] solVar = AVar^-1*bVar;

// with problem

problem Lap2d(uPb,vPb , solver = CG )  = int2d(Th)(Grad2(uPb)'*Grad2(vPb))
 - int2d ( Th ) ( f * vPb )
  + on(1,uPb=g);
Lap2d;

/////////////////////////////////////
// laplacian Beltrami
// build surface 3D  with Th 2D mesh and move with pi/2 rotation ThSurf
real theta = pi/2;
meshS ThS = movemesh23(Th, transfo=[x, cos(theta)*y-sin(theta)*z, sin(theta)*y+cos(theta)*z]);

fespace VhS(ThS,P1);
VhS uSVar,vSVar;
VhS uSPb,vSPb;

/*(const R3 & P){
    R theta = 3.14; //pi/2.;
    R x=P.x;
    R y=cos(theta)*P.y-sin(theta)*P.z;
    R z=sin(theta)*P.y+cos(theta)*P.z;
    return x*x+2*y*y;} // boundary condition
*/

macro Grad3(uSVar) [dx(uSVar),dy(uSVar),dz(uSVar)]  // EOM

//with variational form
varf aS(uSVar,vSVar) = int2d(ThS)(Grad3(uSVar)'*Grad3(vSVar))
 + int2d ( ThS ) ( f * vSVar )
  + on(1,uSVar=g);
matrix ASVar =aS(VhS,VhS);
real[int] bSVar = aS(0,VhS);
real[int] solSVar = ASVar^-1*bSVar;

// with problem
problem Lap3dS(uSPb,vSPb , solver = CG )  = int2d(ThS)(Grad3(uSPb)'*Grad3(vSPb))
 - int2d ( ThS ) ( f * vSPb )
  + on(1,uSPb=g);
Lap3dS;

savemesh (Th, "Th2D.mesh");
savemesh (ThS, "ThS.mesh");

// check solution for variational forms
real[int] errVar = solVar - solSVar;
cout << "---> norm error l2 for variationnal form " << errVar.l2 << endl;
assert(errVar.l2 < 1e-10);

// check solution with problem
real[int] errPb = uPb[] - uSPb[];
cout << "---> norm error l2 with problem " << errPb.l2;
assert(errPb.l2 < 1e-10);

medit("uSPb",ThS, uSPb);

// test P2b and interpolate 2d->3d surface

fespace Vh2(Th,P2b);
Vh2 u2Var,v2Var;

matrix A2Var =a(Vh2,Vh2);
Vh2 b2Var; b2Var[] = a(0,Vh2);
Vh2 sol2Var; sol2Var[] = A2Var^-1*b2Var[];


ThS=square3(10,10);
fespace Vh2S(ThS,P2b);
Vh2S u2SVar,v2SVar;
matrix A2SVar =aS(Vh2S,Vh2S);
Vh2S b2SVar; b2SVar[] = aS(0,Vh2S);
Vh2S sol2SVar; sol2SVar[] = A2SVar^-1*b2SVar[];

matrix inter=interpolate(Vh2S,Vh2);
Vh2S err2b; err2b[] = inter*sol2Var[];err2b[]-= sol2SVar[];

cout << "---> norm error l2 for variationnal form with P2b" << err2b[].l2 << endl;
assert(err2b[].l2 < 1e-10);

load "msh3"
int errT=0; 

macro Test(Th,FE,nFE)
{
int err=0; 	
fespace Wh(Th,FE);
Wh u=x,v,w;

for(int i=0; i< Wh.ndof;++i)
{
	u=0;
	u[][i]=1;
	v=u;
	v[]-=u[];
	err += v[].linfty>1e-7;
}
cout << " ** " << nFE << " Nb err = "<< err<< endl; 
errT += err;
} 
//


meshS ThS=square3(1,1);

Test(ThS,P0,"P0")
Test(ThS,P1,"P1")
Test(ThS,P2,"P2")

//Test(ThS,RT0S,"RT0S");
fespace VhS(ThS,RT0S);
VhS [u1,u2,u3]=[x,y,z], [v1,v2,v3];

for(int i=0; i< VhS.ndof;++i) {
	u1[]=0;
	u1[][i]=1;
plot([u1,u2,u3],wait=1,cmm="3d surf dof="+i,fill=1);

	v1[]=u1[];
	v1[]-=u1[];
	errT += v1[].linfty>1e-7;
}


assert(errT==0);
// basic example io vtk for meshS/meshL
load "iovtk"
load "msh3"

mesh Th = square(10,10);
savevtk("Th.vtk",Th,bin=1); 
mesh Th2=vtkload("Th.vtk");
meshS ThS = square3(10,10);

savevtk("ThS.vtk",ThS,bin=0); 
savevtk("ThS.vtu",ThS,bin=1);
meshS ThS2=vtkloadS("ThS.vtk");
plot(Th2);
ThS=buildBdMesh(ThS);
meshL ThL= ThS.Gamma;

savevtk("ThL.vtk",ThL,bin=1); 
savevtk("ThL.vtu",ThL,bin=1); 
meshL ThL2=vtkloadL("ThL.vtk");
/*
Cauchy problem
| Delta u = 0 in Omega
| u = f on Gamma_1 
| du/dn = g on Gamma_1
| u = f on Gamma_2

with  Gamma_0=]0;1]x{1}
Gamma_1=]0;1]x{0}
Gamma_2=d Omega \ (Gamma_0 U Gamma_1)

-->
alternatively solve two problems with well-defined limits, (PC)2n and (PC)2n+1

(PC)2n   | Delta u(2n) = 0 in Omega
		 | u(2n) = v(n) on Gamma_0 
		 | du/dn(2n) = g on Gamma_1
		 | u(2n) = f on Gamma_2
(PC)2n+1 | Delta u(2n+1) = 0 in Omega
		 | du/dn(2n+1) = w(n) on Gamma_0 
		 | u(2n+1) = f on Gamma_1
		 | u(2n+1) = f on Gamma_2
where 
 v(n) = a(n) (u)2n1 + (1  a(n)) v(n1)
 w(n) = (b)n (du/dn)2n + (1  b(n)) w(n1)
    with a(n) and b(n) can be chosen constant or dynamic

*/

load "msh3"
macro lap (u,v) (dx(u)*dx(v) + dy(u)*dy(v) + dz(u)*dz(v))//
macro gradn (u) (dx(u)*N.x + dy(u)*N.y + dz(u)*N.z)//


int[int] r=[4,2];
meshS Th = square3(10,10);
Th=change(Th,refedge=r);

fespace Vh(Th,P1);

Vh u, v, w, wn, uprec, uprec2, vprec, vprec2;
Vh uex = cos(x) * cosh(y) + sin(x) * sinh(y);
Vh vn = (1 - x) * uex(0,1,0) + x * uex(1,1,0);
func f = 0.;
real err, eps = 1.e-6;
real erru = 0., errgradv = 0.;
int ii = 0;
real theta = 1.;
real delta = 1.;


problem pair (u,w) = 
	int2d(Th) (lap(u,w))
	- int2d(Th) (f*w)
	- int1d (Th, 1) (gradn(uex)*w)
	+ on (2, u = uex)
	+ on (3, u = vn);

problem impair (v,w) = 
	int2d(Th) (lap(v,w))
	- int2d(Th) (f*w)
	- int1d (Th, 3) (wn*w)
	+ on (1, v = uex)
	+ on (2, v = uex);

err = eps + 1.;

// iterations 1 et 2

pair;

ii++;
wn = dy(u);

impair;

err = sqrt (int1d (Th, 3) ((v-u)^2));

vn = theta*v + (1-theta)*vn;

uprec = u;
uprec2 = u;
vprec = v;
vprec2 = v;

// iterations 3 et 4

pair;

ii++;
wn = delta*dy(u) + (1-delta)*wn;

impair;

err = sqrt (int1d (Th, 3) ((v-u)^2));
theta = ( int1d (Th, 3) ((u-uprec)*(u-uprec-v+vprec)) ) / ( int1d (Th, 3) ((u-uprec-v+vprec)^2) );
vn = theta*v + (1-theta)*vn;

uprec = u;
vprec = v;

// next iterations 

while (err > eps) {
	
	pair;

	erru = sqrt (int1d (Th, 3) ((u-uex)^2));
	errgradv = sqrt (int1d (Th, 3) ((gradn(u)-gradn(uex))^2));
	ii++;

	delta = ( int1d (Th, 3) ((dy(vprec)-dy(vprec2))*(dy(vprec)-dy(vprec2)-dy(uprec)+dy(uprec2))) ) 
	/ ( int1d (Th, 3) ((dy(vprec)-dy(vprec2)-dy(uprec)+dy(uprec2))^2) );

	wn = delta*dy(u) + (1-delta)*wn;
	impair;	

	err = sqrt (int1d (Th, 3) ((v-u)^2));
	theta = ( int1d (Th, 3) ((u-uprec)*(u-uprec-v+vprec)) ) / ( int1d (Th, 3) ((u-uprec-v+vprec)^2) );
	vn = theta*v + (1-theta)*vn;

	uprec2 = uprec;
	uprec = u;
	vprec2 = vprec;
	vprec = v;

}

assert(err < 1e-6);
// criture  l'cran de l'erreur et du nombre d'itrations

cout << "\n";
cout << "\n";
cout << ii << " iterations pour un ecart de " << err << ".\n";
cout << "Erreur sur u de " << erru << ".\n";
cout << "Erreur sur grad u de " << errgradv << ".\n";

plot (v, cmm = "impair (verification)", value = true);
plot (uex, cmm = "solution exacte", value = true);


















load "msh3"

meshS Th=square3(2,2);

  // --------- new stuff -----------------
  int k=0,l=1,e=1;
  Th.nbe ; // return the number of boundary element \hfilll
  Th.be(k);   // return the boundary element k $\in \{0,...,Th.nbe-1\}$ \hfilll
  Th.be(k)[l];   // return the vertices l $\in \{0,1\}$ of  boundary element k \hfilll
  Th.be(k).Element ;   // return the triangle contening the  boundary element k \hfilll
  Th.be(k).whoinElement ;   // return the egde number of triangle contening the  boundary element k \hfilll
  Th.be(k).N ;   // return the Normal to be(k)   version 4.10.1
  Th[k].adj(e) ; // return adjacent triangle to k by edge e, and change the value of e to \hfilll
  
  // the corresponding edge in the adjacent triangle
  Th[k] == Th[k].adj(e) ;// non adjacent triangle return the same 
  Th[k] != Th[k].adj(e) ;// true adjacent triangle 
  
  cout << " print mesh connectivity " << endl;
  int nbelement = Th.nt; 
  for (int i=0;i<Th.nv;++i)
  cout << i << " : "  << Th(i).x << " "<< Th(i).y << " " << Th(i).z  << endl; 
 
  for (int k=0;k<nbelement;++k)
    cout << k << " :  " << int(Th[k][0]) << " " << int(Th[k][1]) << " " <<  int(Th[k][2])
	 << " , label/ region  " << Th[k].label << endl; 
  //  
  
  for (int k=0;k<nbelement;++k)
    for (int e=0,ee;e<3;++e) 
      //  remark FH hack:  set ee to e, and ee is change by method adj, 
      //  in () to make difference with  named parameters. 
      {
	    cout << k <<  " " << e << " <=>  " << int(Th[k].adj((ee=e))) << " " << ee  
	     << "  adj: " << ( Th[k].adj((ee=e)) != Th[k]) << endl;  
      }
      // note :     if k == int(Th[k].adj(ee=e)) not adjacent element 


  int nbboundaryelement = Th.nbe; 
  Th.be;
    for (int k=0;k<nbboundaryelement;++k)
      cout << k << " : " <<  Th.be(k)[0] << " " << Th.be(k)[1]   << " , label " << Th.be(k).label 
	   <<  " tet  " << int(Th.be(k).Element) << " " << Th.be(k).whoinElement <<  " N " << Th.be(k).N << endl; 
	
	real[int] bb(4);
	boundingbox(Th,bb); // bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax 
	   cout << " boundingbox  xmin: " << bb[0] << " xmax: " << bb[1] 
	                     << " ymin: " << bb[2] << " ymax: " << bb[3] << endl; 

    R3 O(0.5,0.5,0.5);
    real ss =0;
    for (int k=0;k<Th.nt;++k)
       ss += solidangle(O,Th[k]);
     cout << " solid angle = " << ss << " == 4*pi/6 == " << 4*pi/6 << endl;
    assert( abs(ss-4*pi/6) < 1e-9);
    func real f(R3 A)
    {
	    cout << "P "<< P << " " << nuTriangle << " A = "<< A << endl;
	    return solidangle(A,Th[nuTriangle])/area;
    }
    cout << int2d(Th,qforder=1)(f(O) )<< endl; 
load "Element_Mixte3d"
load "msh3"
load "Element_P1dc1"
// never tested ......

/*
   Solving the following Poisson problem
   Find $p$, such that;
   $ - \Delta p = f $   on $\Omega$,
   $ dp / dn = (g1d,g2d,g3d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$
  with de Mixte finite element formulation
   Find $p\in L^2(\Omega)   and $u\in H(div) $ such than
    u - Grad p = 0
    - div u =  f
   $  u. n = (g1d,g2d,g3d). n  $ on $\Gamma_{123}$
   $ p = gd  $ on $\Gamma_{1}$

   the variationnel form is:
 $\forall v\in H(div)$;  $v.n = 0$ on $\Gamma_{4}\} $:    $ \int_\Omega  u v + p div v -\int_{\Gamma_{123}} gd* v.n  = 0 $

 $\forall q\in L^2$:   $  -\int_\Omega q div u = \int_Omega f q  $
and $ u.n = (g1n,g2n,g3n).n$ on $\Gamma_4$

*/

macro divS(u1,u2,u3) (dx(u1)+dy(u2)+dz(u3)) //EOM

real theta = pi/2;
meshS ThS = square3(10,10, [x, cos(theta)*y-sin(theta)*z, sin(theta)*y+cos(theta)*z]);
plot(ThS,wait=1);

fespace VhS(ThS,[RT1S,P1dcS]);// bug !!!!!   with RT0 (dim of ThS,[RT0,P0] is wrong 3 not 4 ... 
verbosity=1;

func gd = 1.;
func g1n = 1.;
func g2n = 1.;
func g3n = 0.;
func f = 1.;

VhS [uS1,uS2,uS3,pS], [bS1,bS2,bS3,cS];

varf a([u1,u2,u3,p],[v1,v2,v3,q]) =
   int2d(ThS)( p*q*0e-10+ u1*v1 + u2*v2 + u3*v3 + p*divS(v1,v2,v3) + divS(u1,u2,u3)*q )
 - int2d(ThS) ( f*q)
 + int1d(ThS,1,2,3)( gd*(v1*N.x + v2*N.y + v3*N.z))
 + on(4,u1=g1n,u2=g2n,u3=g3n);


matrix AS=a(VhS,VhS);

set(AS,solver=sparsesolver,eps=1.0e-10,tgv=1e30,dimKrylov=150);
bS1[] = a(0,VhS);
uS1[] = AS^-1*bS1[];

plot([uS1,uS2,uS3], coef=0.1,cmm="u", value=true, wait=1);
plot(pS,fill=1,wait=1,value=true);   


verbosity=0;
real x0=0.0, x1=1.5;
real y0=0.0, y1=2.0;
real xx0=0.5, xx1=1.;
real yy0=0.5, yy1=1.;
int acc,ref, i;
real sH;
ref=10;

border a( t= x0,x1){ x= t ; y= y0; label=1; };
border b( t= y0,y1){ x= x0; y= t ; label=2; };
border c( t= x0,x1){ x= t ; y= y1; label=3; };
border d( t= y0,y1){ x= x1; y= t ; label=4; };
border aa( t= xx0,xx1){ x= t ; y= yy0; label=1; };
border bb( t= yy0,yy1){ x= xx0; y= t ; label=2; };
border cc( t= xx0,xx1){ x= t ; y= yy1; label=3; };
border dd( t= yy0,yy1){ x= xx1; y= t ; label=4; };

//cout << "enter accuracy = ";
//cin >> acc;
acc=0;
// Creation des maillages grossier et fin

//mesh TH=square(ref,ref,[x0+(x1-x0)*x,y0+(y1-y0)*y]);

mesh TH = buildmesh( a(10) + b(-10) + c(-10) + d(+10)
                    +aa(-10) + bb(+10) + cc(+10) + dd(-10) );
plot(TH,wait=1);
end;

{ //    hole 
real pi=4.0*atan(1);
border a(t=0,2*pi){ x=cos(t); y=sin(t);label=1;};
border b(t=0,2*pi){ x=0.3+0.3*cos(t); y=0.3*sin(t);label=2;};
mesh Thwithouthole= buildmesh(a(50)+b(+30));
mesh Thwithhole   = buildmesh(a(50)+b(-30));
plot(Thwithouthole,wait=1,ps="Thwithouthole.eps");
plot(Thwithhole,wait=1,ps="Thwithhole.eps");
}
//  bug --
mesh Th=square(1,1);
fespace Vh(Th,P1);
Vh u;
func real  ff( Vh & u) { return u;} 
func real xx(real x){ return x;}
func real yy(func real(real xx)) { return xx(1);}
 
func f=1;
f=2; 
mesh Th=square(10,10);
fespace Vh(Th,P1);
// bug due  to optimisation process .. HARD ....  FH 
Vh u = y ? 1./y : x;
// remark: the sign of p is correct 
// BUG ..... 
bool classique=0;

real s0=clock();
mesh Th=square(10,10);
fespace Vh2(Th,P2);
fespace Vh(Th,P1);
fespace Wh(Th,[P2,P2,P1]);
Vh2 u2,v2,up1,up2;
Vh2 u1,v1; 
Vh  u1x=0,u1y,u2x,u2y, vv;

real reylnods=1000;
//cout << " Enter the reynolds number :"; cin >> reylnods;
assert(reylnods>1 && reylnods < 100000); 
up1=0;
up2=0; 
func g=(x)*(1-x)*4; 
Vh p=0,q;
real alpha=0;
real  nu=1;
int i=0,iter=0;
real dt=0;

real sig = 2*classique-1;

varf vNS([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2)
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001)
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + int2d(Th) ( sig*(-alpha*convect([up1,up2],-dt,up1)*v1 -alpha*convect([up1,up2],-dt,up2)*v2 ) )
  + on(3,u1=g,u2=0)
  + on(1,2,4,u1=0,u2=0) ;


solve NS ([u1,u2,p],[v1,v2,q],solver="SPARSESOLVER",init=i,save="toto") =   vNS; 

     cout << "-- n " << p[].n << " stokes " << endl;
     cout << "-- u1 : " << u1[].min << " " << u1[].max << endl;
     cout << "-- u2 : " << u2[].min << " " << u2[].max << endl;
     cout << "-- p  : " << p[].min << " " << p[].max << endl;
//plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="StokesP2P1.eps",value=1,wait=1);
dt = 0.1;
int nbiter = 2;
real coefdt = 0.25^(1./nbiter);
real coefcut = 0.25^(1./nbiter) , cut=0.01;
real tol=0.5,coeftol = 0.25^(1./nbiter);
nu=1./reylnods;   
Wh [uu1,uu2,pp];
Wh [vv1,vv2,qq];
Wh [f1,f2,fp];
for (iter=1;iter<=nbiter;iter++)
{
  cout << " dt = " << dt << " ------------------------ sig ="<< sig  << endl;
  alpha=1/dt;
  for (i=0;i<=1;i++)
    {
      up1=u1;
      up2=u2;     
      matrix A=vNS(Wh,Wh,solver="SPARSESOLVER");
      //     set(A,solver="SPARSESOLVER"); // set a solver 	
      verbosity=3;
      if(classique) {
	//NS;
	solve NS1 ([uu1,uu2,pp],[vv1,vv2,qq],solver="SPARSESOLVER",init=i,save="toto") =   vNS; 	
      }
      else {
		  [f1,f2,fp]=[0,0,0];
	f1[] = vNS(0,Wh);
	{
	  ofstream tt("tt.matrix");
	  tt << A << endl;
	}
	{
	  ofstream tt("tt.b");
	  tt << f1[]  << endl;
	}
	uu1[]  = A^-1*f1[];
      }
      verbosity=1;
      u1=uu1;
      u2=uu2;
      p = pp;
      
      cout << "-- n " << p[].n << endl;
      cout << "-- u1 : " << u1[].min << " " << u1[].max << endl;
      cout << "-- u2 : " << u2[].min << " " << u2[].max << endl;
      cout << "-- p  : " << p[].min << " " << p[].max << endl;
      
      if ( !(i % 10)) 
	plot(coef=0.2,cmm=" [u1,u2] et p  ",p,[u1,u2],ps="plotNS_"+iter+"_"+i+".eps");  
      cout << "CPU " << clock()-s0 << "s " << endl;     
    } 
  
  if (iter>= nbiter) break;
 
  Th=adaptmesh(Th,[dx(u1),dy(u1),dx(u1),dy(u2)],
              abserror=0,cutoff=cut,err=tol, inquire=0,ratio=1.5,hmin=1./1000);
  plot(Th,ps="ThNS.eps");
  dt = dt*coefdt;
  tol = tol *coeftol;
  cut = cut *coefcut;
}
cout << "CPU " << clock()-s0 << "s " << endl;     
//  bug string macro parameter   version < 1.41
// bug in string parameter version before <2.5
// -----------------
 macro tyty(uu) uu//  
cout << tyty("toto") << endl;

// other bug   un func parameter  no correct 

  func string   write(string  fn,real[int] & u)
    {
      cout <<"write :   " <<  fn << " u = "<<  u << endl;  //  delete 2 times before version 2.5 
      return fn; 
    }

  func string   write1(string  fn,real[int] & u)
    {
      cout << "write 1 " << fn << " u = " << u << endl;   
      string toto=fn; ;
      return toto+"dfsdf"; 
    }

 real[int] u(3);
 u=1;

string tt=tyty("toto1"+1+" -- 77");

string t1="0123456789";// write(tt,u);

string t2=  write1(t1,u)+write1(tt,u);

cout << " t2 = " << t2 << endl;
mesh Th = square(10,10); 
fespace Wh(Th,[P2,P2]);	// R2->R2
Wh [F1,F2]; //def de l'inconnu et des fonct tests

F1 = 1;
// il y a un bug ici car dans un element fini vectoriel
// il est impossible defini juste une composante
//  il faut faire:

cout << F1(0.5, 0.6) << endl;
cout << F2(0.5, 0.6) << endl;
cout << F1(0.5, 0.6);
[F1,F2]=[1,2]; 
cout << " -- F1 " <<  F1(0.5, 0.6) << endl;
cout << " -- F2 " << F2(0.5, 0.6) << endl;
// +=====================================================================+
// | Un bug en arithmetique complexe.                                    |
// +---------------------------------------------------------------------+
// | 01/09/02 : Les tableaux de complexes ne sont pas dispos             |
// | 11/09/03, V1.34                                                     |
// |   variable du contexte sont ecrasees c'est le cas de j              |
// |                                                                     |
// +=====================================================================+


   complex z1, z2, j    ;
   real    ReZ, ImZ ;

   j = 0 + 1i ;
   cout << "j = " << j <<" attendu : i" << endl ;

   cout << "trace 1 de j = " << j  << endl ;
   ReZ = 4.5 ; ImZ = 6.7 ; 
   cout << "ReZ = " << ReZ << " attendu : 4.5 " << endl ;
   cout << "ImZ = " << ImZ << " attendu : 6.7 " << endl ;
   cout << "trace 2 de j = " << j  << endl ;
   cout << "Voila, j est ecrase par 0 + (ReZ) i !" << endl ;
   
   cout << endl ;
   cout << "Le meme Pb pour les reels ? " << endl ;

   
   real r1, r2, jR   ;

   jR = 2 ;
   cout << "jR = " << jR <<" attendu : 2" << endl ;

   cout << "trace 1 de jR = " << jR  << endl ;
   ReZ = 4.5 ; ImZ = 6.7 ; 
   cout << "ReZ = " << ReZ << " attendu : 4.5 " << endl ;
   cout << "ImZ = " << ImZ << " attendu : 6.7 " << endl ;
   cout << "trace 2 de jR = " << jR  << endl ;
   cout << "NON jR n'est pas ecrase" << endl ;
   cout << endl ;
 // routine
// bug before  version 1.27 pb passage d'argument
func int myfunction(real  a1)
{
   int i=a1*a1/1;
   return i;
}; 
func real myfunction(real a,real b)
{
   real z =myfunction(a)+b;
   return z;
};
// appele 
cout << myfunction(1.0,3.) << " " << myfunction(1,3)  << endl;
// bug correct in version 1.19
cout << ( 10. < 2 ) << endl;
cout << ( 10. < 2. ) << endl;
mesh Th=square(5,5);
fespace Xh(Th,P2);
Xh v;
v=label;
plot(v,value=1,wait=1);
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface in complex ..
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh<complex> u1,u2;
int n=Vh.ndof; 

complex sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    + int1d(Th)(u1*u2) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix<complex> A= a(Vh,Vh,solver=sparsesolver); 
matrix<complex> B= b(Vh,Vh,solver=sparsesolver); 

func complex[int] FA1(complex[int] & u) { complex[int] Au=A^-1*u;return Au;}
func complex[int] FB(complex[int] & u) { complex[int] Au=B*u;return Au;}
func complex[int] FA(complex[int] & u) { complex[int] Au=A*u;return Au;}
func complex[int] FB1(complex[int] & u) { complex[int] Au=B^-1*u;return Au;}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

complex[int] ev(nev); // to store nev eigein value
Vh<complex>[int] eV(nev);   // to store nev eigen vector


int k=complexEigenValue(n,A1=FA1,B=FB,A=FA,B1=FB1,sigma=sigma,tol=1e-10,maxit=1000,ncv=200,nev=nev,value=ev,vector=eV);
	//,mode=3,which="LM");
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0; 
for (int i=0;i<k;i++)
{
  u1=eV[i];
  complex gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1)) + int1d(Th)(u1*u1);
  complex mm= int2d(Th)(u1*u1) ;
  complex err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) +  int1d(Th)(u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  cout << " ---- " <<  i<< " " << ev[i]  << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=0,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=0);
}

//  laplace with matrix  
verbosity=1;
mesh Th=square(20,20,[2*pi*x,2*pi*y]);
fespace Vh(Th,P2);
Vh u1,u2;
int n=u1.n;
real[int] Bu1(n),Bu2(n);
real[int] Au1(n),Au2(n);

real sigma = 0;                     
real nu=0.1;

varf  op(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0)
;
varf  a(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 )
                    +  on(1,2,3,4,u1=0)
;
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ;//+  on(1,2,3,4,u1=0);


matrix OP= op(Vh,Vh,solver="SPARSESOLVER",factorize=0); 
matrix A= a(Vh,Vh,solver=GMRES); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 
int nev=11;

real[int] ev(nev); // to store 10 eigein value real part
real[int] evi(nev); // to store 10 eigein value imag part
Vh[int] eV(nev);   // to store 10 eigen vector  
/*
 For real nonsymmetric problems, complex eigenvectors are
 given as two consecutive vectors, so if Eigenvalue $k$ and $k+1$ 
 are complex conjugate eigenvalues, 
the vector eV[K] will contain the real part and 
the vector eV[K] the imaginary part of the corresponding 
complex conjugate eigenvectors. 
*/


int k=EigenValue(OP,B,sym=false,sigma=sigma,value=ev,vector=eV,
	         tol=1e-10,maxit=0,ncv=0,ivalue=evi);
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
for (int kk=0;kk<k;kk++)
{ 
  int i=kk;
  u1=eV[i];
  u2=0;
  real er=ev[i],ei=evi[i];
  complex v= er+ei*1i;
  if(ei) { // complex case
    int j=++kk;
    if (j>=k) break; 
    u2 = eV[j];
  }
  cout << " ||u1|| " << u1[].linfty << " || u2|| = " << u2[].linfty << endl;
  Bu1=B*u1[];
  Bu2=B*u2[];
  Au1=A*u1[];
  Au2=A*u2[];
    //  The Rayleigh quotient lambda = x'Ax/x'Bx 
    //  given the eigen value 
  real xBx = u1[]'*Bu1 + u2[]'*Bu2;
  complex xAx = u1[]'*Au1 + u2[]'*Au2 + 1i*(u1[]'*Au2 - u2[]'*Au1);
  complex eigenvalue = xAx/xBx;
  cout << " ---- " <<  i<< " " <<  v <<" eigenvalue= " << eigenvalue << endl;

  // FFCS: add 3D view
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + er + " , " + ei  ,wait=1,value=1,dim=3,fill=1);
}

// FFCS: order of eigenvalues may change, and biggest eigenvalue
// (95.xxx) may not be picked up at all.

real regtest=0;
for(int i=1;i<nev;i++)if(ev[i]<95 && regtest<ev[i])regtest=ev[i];
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh u1,u2;


real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=sparsesolver); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,which="LM"); // which="LM" default 
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
real[int]  eev(36);
eev=1e100;
for(int i=1,k=0;i<6;++i)
for(int j=1;j<6;++j)
  eev[k++]=i*i+j*j;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  if(abs(ev[i]-eev[i]) > 1e-1) nerr++;
  cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,
  //*ps="eigen"+i+".eps",
  dim=3,fill=1,CutPlane=0,ShowAxes=0);
}
assert(nerr==0);
//  Computation of the eigen value and eigen vector of the 
// 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
// Linear elastisitic problem in axisym. model. 
// thank to 
// http://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch02.d/AFEM.Ch02.pdf
//  for the model.
//  the benchmark  case is
// thank form comsol and ansys 
// the comsol sol testcaes:  Eigenfrequency Analysis of a Free Cylinder
// The model is taken from NAFEMS Free Vibration Benchmarks
// 1. F. Abassian, D.J. Dawswell, and N.C. Knowles, Free Vibration Benchmarks, 
// Volume 3, NAFEMS, Glasgow, 1987
//  the comsol data: 
// http://www.comsol.com/model/download/40173/free_cylinder.pdf 
// F. Hecht may 2014 ??
// warning: Axi / 0x   
//  r == y,  
real[int] freqref=[0,243.53,377.41,394.11,397.72,405.28];   
verbosity=0;
real ccc= 1; // coef scale of matrix 
real E =  2.e11*ccc ;// 72e9;
real nu = 0.3;
real rho = 8000*ccc;//2700;//
real freq0 = 100; 
real mu = E/(2.*(1.+nu));
real lambda = E*nu/((1.+nu)*(1.-2.*nu));
real R1 = 1.8, R2 = R1+ 0.4, L = 10;
int nn = 40, nz = 40;
border cc1(t=0,2*pi){ x = R1*cos(t); y=R1*sin(t); }
border cc2(t=0,2*pi){ x = R2*cos(t); y=R2*sin(t); }
int NN = 10; 
mesh Th=square(L*NN,(R2-R1)*NN,[x*L, (1-y)*R1+y*R2]); 
plot(Th, wait=1); 


real shift = 1; // make a shift because 0 mode ... 
real C11=  2*mu  + lambda  ; 
real C12 =  lambda ;
real C44=  2*mu;
func Amat = [  [C11, C12, C12, 0.  ],
               [C12, C11, C12,  0. ],
               [C12, C12, C11,  0. ],
               [0. , 0. , 0.,   C44]
             ];

fespace Vh(Th,[P2,P2]);
Vh [u1,u2], [v1,v2];
func dr=dy; 
func r=y; 

macro Strainaxi(ux,ur)  [dx(ux),dr(ur),ur/r, dr(ux)+dx(ur) ] // EOM
  
varf vLame([u1,u2],[v1,v2])=
  int2d(Th)(  (Strainaxi(v1,v2)'*(Amat*Strainaxi(u1,u2))  
  - ([u1,u2]'*[v1,v2]*rho*shift) )*y )
  ;
varf vMass([u1,u2],[v1,v2])=
  int2d(Th)( ( [v1,v2]'*[u1,u2]*rho )*y );
 
matrix A= vLame(Vh,Vh,solver=sparsesolver); 
matrix B= vMass(Vh,Vh,solver=CG,eps=1e-20); 

int nev=6;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] [eu1,eu2](nev);   // to store nev eigen vector


int k=EigenValue(A,B,sigma=shift,sym=true,value=ev,vector=eu1,tol=1e-20);

k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
for (int i=0;i<k;i++)
{
    real e = ev[i] ;
    real freq = sqrt(abs(e))/(pi*2) ;
    if( abs(freq-freqref[i]) > 0.3) nerr++;
  cout << i << " ev " <<  e << " freq = " << freq  << "Hz, err=" << abs(freq-freqref[i]) <<endl;   
  real coef= 0.5/eu1[i][].linfty;
  mesh Thm=movemesh(Th,[x+eu1[i]*coef,y+eu2[i]*coef]);
  //plot(Th,Thm, wait=1,cmm=i+"/"+k+"coef  amplification = "+coef );
 // medit("Thm-"+ev[i],Thm,wait=1);
 plot(Thm,Th,wait=1,cmm=i+"/"+k+"coef  amplification = "+coef +" freq " + freq + "Hz"  , fill=1);
}
assert(nerr==0);
// test to validate the addition of surfacic finite elements in FreeFEM

load "msh3"
load "medit"


/////variational form

/////////////////////////////////
// laplacian 2D
real R = 3, r=1; 
real h = 0.1; // 
int nx = R*2*pi/h;
int ny = r*2*pi/h;
func torex= (R+r*cos(y*pi*2))*cos(x*pi*2);
func torey= (R+r*cos(y*pi*2))*sin(x*pi*2);
func torez= r*sin(y*pi*2);


meshS Th=square3(nx,ny,[torex,torey,torez],removeduplicate=true) ;

fespace Vh(Th,P1);

/*(const R3 & P){
    R theta = 3.14; //pi/2.;
    R x=P.x;
    R y=cos(theta)*P.y-sin(theta)*P.z;
    R z=sin(theta)*P.y+cos(theta)*P.z;
    return x*x+2*y*y;} // boundary condition
*/

macro Grad3(uSVar) [dx(uSVar),dy(uSVar),dz(uSVar)]  // EOM

//with variational form
real sigma = -1; 
varf aS(u,v) = int2d(Th)(Grad3(u)'*Grad3(v)- sigma* u*v);
varf mS(u,v) = int2d(Th)( u*v);
Vh Nx,Ny,Nz;
Vh Mx,My,Mz;
solve Pn([Nx,Ny,Nz],[Mx,My,Mz]) = int2d(Th)( [Nx,Ny,Nz]'*[Mx,My,Mz])- int2d(Th)([Ns.x,Ns.y,Ns.z]'*[Mx,My,Mz]); 

matrix A =aS(Vh,Vh);
matrix B =mS(Vh,Vh,solver=CG);
int nev=100;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,which="LM"); // which="LM" default 

for (int i=0;i<k;i++) 
	plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,dim=3,fill=0,CutPlane=0,ShowAxes=0, nbiso=40);
NoUseOfWait=true;int verbosityy=verbosity;
 cout << "--------- file : BeamEigenValue.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "BeamEigenValue.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : BeamEigenValueperio.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "BeamEigenValueperio.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : LapEigenValue.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "LapEigenValue.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : Stokes-eigen.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "Stokes-eigen.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
 cout << "--------- file : neuman.edp --------------------------------------------------------" << endl;
verbosity=verbosityy;
{ include "neuman.edp";};
 cout << "------------------------------------------------------------------------------ " << endl;
//Script for FreeFem++cs  http://www.ann.jussieu.fr/~lehyaric/ffcs/index.htm
//to compute WG eigen vector (magnetic field) and value (wave vector)
// of axially symmetrical dielectric resonators
// See Chaper 9 the example Whispering gallery modes of teh DOC. 


//Developed by I. S. Grudinin at JPL/Caltech
//Copyright 2012 California Institute of Technology. Government sponsorship acknowledged.
//If this script was helpful in a project that resulted in a publication, please cite our paper:
//``Finite element modeling of coupled optical microdisk resonators for displacement sensing,''
//I. S. Grudinin and Nan Yu (2012)
//    J. Opt. Soc. Am. B

//based on "Traceable 2-D finite-element simulation of the whispering-gallery modes of axisymmetric electromagnetic resonators"
//by M. Oxborrow
//IEEE TRANSACTIONS ON MICROWAVE THEORY AND TECHNIQUES  Volume: 55   Issue: 6   Pages: 1209-1218

real radius=36; //approximate radius of the cavity
real yb=-10,yt=-yb; //window yb=bottom and yt=top coordinates
real xl=radius-5,xr=radius+3; //window xl=left and xr=right coordinates
real angle=asin((yt)/radius); //angle of the sphere segment to model in radians
int Nm=60;  	//number of mesh vertices per border 
real ne=1.46; //n_e-extraordinary refractive index (root of permittivity parallel to z-axis, epara)
real no=1.46; //n_o-ordinary refractive index (root of permittivity orthogonal to z-axis, eorto)
real nm=1;     //refractive index of surrounding medium (air)

int nev=4; // number of eigen values to find

int M=213;	//azimuthal mode order ~ 2Pi*n*R/lambda
real alpha=1; 	//penalty term

//describing the mesh:
border W1l(t=0,1) { x=xl+(radius*cos(angle)-xl)*(1-t); y=yt; label=1;}  // window upper border left
border W1r(t=0,1) { x=xr-(xr-radius*cos(angle))*(t); y=yt; label=1;}  	// window upper border right
border W2(t=0,1) { x=xr; y=yb+(yt-yb)*t; label=1;}  			// window right border
border W3l(t=0,1) { x=xl+(radius*cos(angle)-xl)*(t); y=yb; label=1;}  	// window lower border left
border W3r(t=0,1) { x=xr-(xr-radius*cos(angle))*(1-t); y=yb; label=1;}  // window lower border right
border W4(t=0,1) { x=xl; y=yt-(yt-yb)*t; label=1;} 			// window left border
border S(t=0,1) { x=radius*cos((t-0.5)*2*angle); y=radius*sin((t-0.5)*2*angle); label=2;}  //sphere segment
mesh Th = buildmesh(W1r(Nm/4)+W1l(Nm/4)+W4(Nm)+W3l(Nm/4)+W3r(Nm/4)+W2(Nm)+S(Nm));
plot (Th, WindowIndex = 0);


//setting subdomain parameters, i.e. refractive indices of resonator and surrounding air box
fespace Ph(Th, P0);  
Ph reg=region; // function that returns region number of a point XY
int ncav=reg(xl+1, 0);  // cavity
int nair=reg(xr-1, 0);		//air
Ph eorto=no^2*(region==ncav)+nm^2*(region==nair);  //subdomains for epsilon values inside and outside the resonators
Ph epara=ne^2*(region==ncav)+nm^2*(region==nair);  //subdomains for epsilon values inside and outside the resonators

//supplementary variables to store eigenvectors, defined on mesh Th with P2 elements - Largange quadratic.
fespace Supp(Th, P2);
Supp eHsqr;

//3d vector FE space 
fespace Vh(Th,[P2,P2,P2]);
Vh [Hr, Hphi, Hz], [vHr, vHphi, vHz]; //magnetic field components on Vh space and test functions vH

real sigma =(M/(ne*radius))^2+2; // value of the shift (k^2), where the modes will be found

//boundary condition macros
macro EWall(Hr,Hphi, Hz) (dy(Hr)-dx(Hz)+Hr*N.x+Hz*N.y-epara*(Hz*M-dy(Hphi)*x)*N.y+eorto*(Hphi-Hr*M+dx(Hphi)*x)*N.x) // eom
macro MWall(Hr,Hphi, Hz) (Hphi+Hz*N.x-Hr*N.y+epara*(Hz*M-dy(Hphi)*x)*N.x+eorto*(Hphi-Hr*M+dx(Hphi)*x)*N.y ) // eom
//b matrix (see freefem++ manual, section 9 - eigenvalue problems)
varf b([Hr, Hphi, Hz], [vHr, vHphi, vHz]) = int2d(Th)( x*(Hr*vHr+Hphi*vHphi+Hz*vHz) );
// OP = A - sigma B ; // the shifted matrix
varf op([Hr, Hphi, Hz], [vHr, vHphi, vHz])=
int2d(Th)(
(
	(eorto*(vHphi*Hphi-M*(vHphi*Hr+Hphi*vHr)+M^2*vHr*Hr)+epara*M^2*vHz*Hz)/x   //A/r
	+eorto*(dx(vHphi)*(Hphi-M*Hr)+dx(Hphi)*(vHphi-M*vHr))-epara*M*(vHz*dy(Hphi)+Hz*dy(vHphi)) //B
	+x*(eorto*dx(vHphi)*dx(Hphi)+epara*((dx(vHz)-dy(vHr))*(dx(Hz)-dy(Hr))+dy(vHphi)*dy(Hphi))) //C
)/(eorto*epara)
+alpha*(
	(vHr*Hr-M*(vHphi*Hr+Hphi*vHr)+M^2*vHphi*Hphi)/x  //D/r
	+(dx(vHr)+dy(vHz))*(Hr-M*Hphi)+(vHr-M*vHphi)*(dx(Hr)+dy(Hz)) //E
	+x*(dx(vHr)+dy(vHz))*(dx(Hr)+dy(Hz))  //F
)  
-sigma*x*(vHr*Hr+vHphi*Hphi+vHz*Hz)
)
//electric wall boundary condition on the boundary of computation domain
+int1d(Th,1)(EWall(Hr,Hphi,Hz)*EWall(vHr, vHphi, vHz));

//setting sparce matrices and assigning the solver UMFPACK to solve eigenvalue problem
matrix B=b(Vh,Vh,solver="SPARSESOLVER");
matrix OP= op(Vh,Vh,solver="SPARSESOLVER");

real[int] ev(nev); // to store the nev eigenvalue
Vh[int] [eHr,eHphi,eHz](nev); // to store the nev eigenvector
//calling ARPACK on sparce matrices with the assigned solver UMFPACK:
int k=EigenValue(OP,B,sym=true,sigma=sigma,value=ev,vector=eHr,tol=1e-10,maxit=0,ncv=0);

k=min(k,nev); //  sometimes the number of converged eigen values 
              // can be greater than nev;


//file to output mode values
ofstream f("modes.txt");
//setting number of digits in the file output
int nold=f.precision(11);


for (int i=0;i<k;i++)
{
 real lambda=2*pi/sqrt(ev[i]);
 eHsqr=(sqrt(eHr[i]^2+eHphi[i]^2+eHz[i]^2)); // intensity from magnetic field components
 plot(eHsqr,WindowIndex=i, value=1, nbiso=20,LabelColors=1, aspectratio=1, cmm="Mode "+i+", lambda="+lambda+", F="+(299792.458/lambda));
 f << "Mode "<<i<<", ka=" << sqrt(ev[i])*radius << endl;

};
load "lapack"

//  laplace with matrix  
verbosity=1;
int nn=5;
mesh Th=square(nn,nn,[2*pi*x,2*pi*y]);
fespace Vh(Th,P2);
Vh<complex> u1,u2;
Vh ur,ui;
int n=u1.n;
complex[int] Bu1(n),Bu2(n);
complex[int] Au1(n),Au2(n);

real sigma=0.0;                     
complex nu=1.0+1i;

varf op(u1,u2)= int2d(Th)( nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 - sigma* u1*u2 )
              //+ on(1,2,3,4,u1=0)
              ;
varf  a(u1,u2)= int2d(Th)( nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2)) + (dx(u1)+dy(u1))*u2 )
              //+ on(1,2,3,4,u1=0)
              ;
                   
varf b(u1,u2) = int2d(Th)(  u1*u2 
              + 1i*u1*dx(u2)
              );

matrix<complex> OP=op(Vh,Vh,solver=sparsesolver); 
matrix<complex> A=a(Vh,Vh,solver=sparsesolver); 
matrix<complex> B=b(Vh,Vh,solver=sparsesolver); 
int nev=10;

complex[int] ev(nev); // to store eigenvalues 
Vh<complex>[int] eV(nev);   // to store eigenvectors  
  
//int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0); // the default driver is number 4 (M positive definite Hermitian)
int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,driver=2); // driver 2 works when M is arbitrary (non Hermitian)
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
for (int kk=0;kk<k;kk++)
  { 
  int i=kk;	
  u1=eV[i];	
  complex v= ev[i];
  Bu1=B*u1[];
  Au1=A*u1[];
  // The Rayleigh quotient lambda = x'Ax/x'Bx 
  // gives the eigenvalue
  // Vincent Laude, 12/01/2017: don't we need the left and right eigenvectors to form the Rayleigh quotient in the general case? 
  complex xAx = u1[]'*Au1 ;
  complex xBx = u1[]'*Bu1 ;
  //  A u = l * B u
  //Bu1 =   v*Bu1;
  //u1[] = Au1 -Bu1; 
  // Vincent Laude, 12/01/2017: why is a zero sum a good indicator of nullity of a vector? Don't we need a norm instead?
  //if(norm(u1[].sum)>1e-5)
  //      cout << "BUG :::   zero ==  " <<u1[].sum << endl;
  cout << " ---- " <<  i<< " " <<  v << " Rayleigh quotient difference: " << abs(v-xAx/xBx) << endl;
  ur=real(eV[i]);
  ui=imag(eV[i]);
  //  plot(ur,cmm="Eigen  Vector (real)  "+i+" valeur =" + v  ,wait=1,value=1);
  //  plot(ui,cmm="Eigen  Vector (imag)  "+i+" valeur =" + v  ,wait=1,value=1);

  // FFCS: add 3d view
  //plot(eV[i],dim=3,fill=1);
  }
 
// Comparison with lapack (full matrices)
// Doesn't seem to work when the on() condition is used (because of tgv)
complex[int, int] Afull(Vh.ndof,Vh.ndof), Bfull(Vh.ndof,Vh.ndof), EVl(Vh.ndof,Vh.ndof), EVr(Vh.ndof,Vh.ndof);
complex[int] eva(Vh.ndof), evb(Vh.ndof);
int[int] I(1), J(1);
complex[int] C(1);
[I,J,C]=A;
for(int i=0; i<I.n; i++) Afull(I(i),J(i))=C(i);
//cout << Afull << endl;
[I,J,C]=B;
for(int i=0; i<I.n; i++) Bfull(I(i),J(i))=C(i);
//zggev(Afull,Bfull,eva,evb,EVl,EVr);
zggev(Afull,Bfull,eva,evb,EVr);
cout << "\n\n Eigenvalues with LAPACK" << endl;
for (int i=0;i<Vh.ndof;i++) cout << i << " " << eva(i)/evb(i) << endl;
cout << endl;


// Comparison with slepc
// Note: only sigma=0.0 case can be tested
/*
// export matrix A in ascii Morse format
{
  ofstream file("matA.txt");
  file.scientific; 
  file << A << endl;
};	
// converts matrix A to PETSC binary format
exec("ffpp2petsc -fin matA.txt -fout matA.petsc");
// export matrix B in ascii Morse format
{
  ofstream file("matB.txt");
  file.scientific; 
  file << B << endl;
};	
// converts matrix B to PETSC binary format
exec("ffpp2petsc -fin matB.txt -fout matB.petsc");

exec("inveigenpb -f1 matA.petsc -f2 matB.petsc -nval "+nev); 
*/

//  laplace with matrix  
verbosity=1;
mesh Th=square(20,20,[pi*x,pi*y]);
fespace Vh(Th,P2);
Vh<complex> u1,u2;
Vh ur,ui;
int n=u1.n;
complex[int] Bu1(n),Bu2(n);
complex[int] Au1(n),Au2(n);

complex  sigma = 0; //1.000+1i;                     
complex nu=1+1i;

varf  op(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2))  - sigma*u1*u2  )
                    +  on(1,2,3,4,u1=0)
;
varf  a(u1,u2)= int2d(Th)(  nu*(dx(u1)*dx(u2) + dy(u1)*dy(u2))   )
                    +  on(1,2,3,4,u1=0)
;
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ;//+  on(1,2,3,4,u1=0);


matrix<complex> OP= op(Vh,Vh,solver="SPARSESOLVER"); 
matrix<complex> A= a(Vh,Vh,solver=GMRES); 
matrix<complex> B= b(Vh,Vh,solver=GMRES,eps=1e-20); 
int nev=10;

complex[int] ev(nev); // to store 10 eigen value 
Vh<complex>[int] eV(nev);   // to store 10 eigen vector  

int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,
	         tol=1e-10,maxit=90000,ncv=100);

k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
for (int kk=0;kk<k;kk++)
{ 
  int i=kk;	
  u1=eV[i];	
  complex v= ev[i];
  Bu1=B*u1[];
  Au1=A*u1[];
    //  The Rayleigh quotient lambda = x'Ax/x'Bx 
    //  given the eigen value 
  complex xAx = u1[]'*Au1 ;
  complex xBx = u1[]'*Bu1 ;
  //  A u = l * B u
  Bu1 =   v*Bu1;
  u1[] = Au1 -Bu1; 
  if(norm(u1[].sum)>1e-5)
        cout << "BUG :::   zero ==  " <<u1[].sum << endl;
  cout << " ---- " <<  i<< " " <<  v << endl;
  ur=real(eV[i]);
  ui=imag(eV[i]);
//  plot(ur,cmm="Eigen  Vector (real)  "+i+" valeur =" + v  ,wait=1,value=1);
//  plot(ui,cmm="Eigen  Vector (imag)  "+i+" valeur =" + v  ,wait=1,value=1);

    // FFCS: add 3d view
    plot(eV[i],dim=3,fill=1);
}

//  Eigen Values of Stelov Poincare Problem of Laplacian Operator
// in FreeFEM
int[int] l4=[1,1,1,1];
mesh Th=square(50,50,[x,y],label=l4);
fespace Vh(Th,P1);


macro Grad(u) [dx(u),dy(u)]//
real sigma = 1;//
varf vA(u,v)=int1d(Th)(-sigma*u*v)+int2d(Th)(Grad(v)'*Grad(u)) ; //'
varf vM(u,v)= int1d(Th)(u*v);
matrix A = vA(Vh,Vh,solver=sparsesolver);
matrix B = vM(Vh,Vh);
int nev = 20;
real[int] ev(nev);
Vh[int] eV(nev);
int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV);
k=min(k,nev); //  some time the number of converged eigen value is  greater then nev..
cout << ev <<endl;
for(int i=0;i<k;++i)
 	plot(eV[i],cmm=" vp " + ev[i],wait=1,dim=3,fill=1);
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh u1,u2;
int n=Vh.ndof; 

real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    +  on(1,2,3,4,u1=0) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=sparsesolver); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

func real[int] FA(real[int] & u) { real[int] Au=A^-1*u;return Au;}
func real[int] FB(real[int] & u) { real[int] Au=B*u;return Au;}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(n,FA,FB,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0;
real[int]  eev(36);
eev=1e100;
for(int i=1,k=0;i<6;++i)
for(int j=1;j<6;++j)
  eev[k++]=i*i+j*j;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1));
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  if(abs(ev[i]-eev[i]) > 1e-1) nerr++;
  cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,ps="eigen"+i+".eps",dim=3,fill=1,CutPlane=0,ShowAxes=0);
}
assert(nerr==0);
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
int bottombeam = 2;
border aaa(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
border bbb(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
border ccc(t=0,2)  { x=10; y=t ;label=1;};       //  rigth beam
border ddd(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
real E = 21.5;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
mesh Th = buildmesh( bbb(20)+ccc(5)+ddd(20)+aaa(5));
fespace Vh(Th,[P1,P1]);
Vh [uu,vv], [w,s];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 

real shift = -1;  // value of the shift 

varf a([uu,vv],[w,s])=
	int2d(Th)(  
		2*mu*(dx(uu)*dx(w)+dy(vv)*dy(s)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/2 )
               + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))
        - shift* (uu*w + vv*s)      
             )
  + on(1,uu=0,vv=0)
  ;

varf b([uu,vv],[w,s])=
	int2d(Th)(uu*w + vv*s)      ;



matrix A= a(Vh,Vh,solver="SPARSESOLVER"); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] [eV,eW](nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=shift,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for (int i=0;i<k;i++)
{
  [uu,vv]=[eV[i],eW[i]];
  cout << ev[i] << endl; 
  plot([uu,vv],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,ps="eigen"+i+".eps");
}

//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
int bottombeam = 2;
border aaa(t=2,0)  { x=0; y=t ;label=1;};        //  left beam
border bbb(t=0,10) { x=t; y=0 ;label=bottombeam;};        //  bottom of beam
border ccc(t=0,2)  { x=10; y=t ;label=4;};       //  rigth beam
border ddd(t=0,10) { x=10-t; y=2; label=3;};     //  top beam 
real E = 21.5;
real sigma = 0.29;
real mu = E/(2*(1+sigma));
real lambda = E*sigma/((1+sigma)*(1-2*sigma));
real gravity = -0.05;
mesh Th = buildmesh( bbb(20)+ccc(5)+ddd(20)+aaa(5));
fespace Vh(Th,[P1,P1],periodic=[ [bottombeam,x],[3,x],[1,y],[4,y] ]);
Vh [uu,vv], [w,s];
cout << "lambda,mu,gravity ="<<lambda<< " " << mu << " " << gravity << endl;
// deformation of a beam under its own weight 

real shift = 1;  // value of the shift 

varf a([uu,vv],[w,s])=
	int2d(Th)(  
		2*mu*(dx(uu)*dx(w)+dy(vv)*dy(s)+ ((dx(vv)+dy(uu))*(dx(s)+dy(w)))/2 )
               + lambda*(dx(uu)+dy(vv))*(dx(w)+dy(s))
        - shift* (uu*w + vv*s)      
             )
//  + on(1,uu=0,vv=0)
  ;

varf b([uu,vv],[w,s])=
	int2d(Th)(uu*w + vv*s)      ;



matrix A= a(Vh,Vh,solver=Crout,factorize=3); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] [eV,eW](nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for (int i=0;i<k;i++)
{
  [uu,vv]=[eV[i],eW[i]];
  plot([uu,vv],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,ps="eigen"+i+".eps");
}

// remark: the sign of p is correct 
real s0=clock();
mesh Th=square(20,20);
fespace Xh(Th,P2);
fespace Mh(Th,P1);
fespace XhxXhxMh(Th,[P2,P2,P1]);

Xh u1,u2;
Mh p;

real alpha=0;
real  nu=1;
int i=0,iter=0;

varf vfStokes ([u1,u2,p],[v1,v2,q]) =
    int2d(Th)(
             alpha*( u1*v1 + u2*v2) 
            + nu * ( dx(u1)*dx(v1) + dy(u1)*dy(v1)
            +        dx(u2)*dx(v2) + dy(u2)*dy(v2) )
            + p*q*(0.000001) 
            - p*dx(v1) - p*dy(v2)
            - dx(u1)*q - dy(u2)*q
           )
  + on(1,2,3,4,u1=0,u2=0) 
;
varf b([u1,u2,p],[v1,v2,q]) = int2d(Th)(  u1*v1+u2*v2+p*q*0.) ; // no  Boundary condition

matrix A= vfStokes(XhxXhxMh,XhxXhxMh,solver="SPARSESOLVER",factorize=0); 
matrix B= b(XhxXhxMh,XhxXhxMh,solver=CG,eps=1e-20); 

real sigma=0;
int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
XhxXhxMh[int] [eu1,eu2,ep](nev);   // to store nev eigen vector

int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eu1,tol=1e-10,maxit=0,ncv=0);
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for (int i=0;i<k;i++)
{
  cout << " valeur propre : " << i << "  : " << ev[i] << endl;
  u1=eu1[i];
  u2=eu2[i];
  p=ep[i];

  // FFCS: changed to 3D view
  plot([u1,u2],p,cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,value=1,ArrowSize=-1.6,dim=3,fill=1);
}

cout << "CPU " << clock()-s0 << "s " << endl;     
assert(abs(ev[0]-52.3471) < 0.1); 
mesh Th=square(50,50,[x*pi,y*pi]);
macro grad(u) [dx(u),dy(u)]//
int[int] L=[1,2,3,4];
varf vlapWithBC(u,v)= int2d(Th)(grad(u)'*grad(v))+ on(L,u=0);
varf vlapWithoutBC(u,v)= int2d(Th)(grad(u)'*grad(v));
varf vMass(u,v)= int2d(Th)(u*v);
fespace Vh(Th,P1);
Vh u,v;
u=1; 
matrix Id=u[]; // vMass(Vh,Vh,solver=CG) ;
set(Id,solver=CG,verb=0);
matrix Abc= vlapWithBC(Vh,Vh,solver=sparsesolver);
matrix Ancl= vlapWithoutBC(Vh,Vh,solver=CG);
real[int] aevmin(2),aevmax(2);
int kmin=EigenValue(Abc,Id,sym=true,value=aevmin);
int kmax=EigenValue(Id,Ancl,sym=true,value=aevmax);
real evmin = aevmin(0);
real evmax = 1./aevmax(0);
cout << "VP min = " << evmin << "VP max = " << evmax << " cond number = " << evmax/evmin << endl; 
//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on cube  $]0,\pi[^3$
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$

load "msh3"	
int nn=15;
mesh Th2=square(nn,nn,[pi*x,pi*y]);
fespace Vh2(Th2,P1);
int[int] rup=[0,1],  rdown=[0,1], rmid=[4,1,2,1, 1,1 ,3,1];
real zmin=0,zmax=pi;

mesh3 Th=buildlayers(Th2,nn,
		     zbound=[zmin,zmax],
		     // region=r1, 
		     labelmid=rmid, 
		     reffaceup = rup,
		     reffacelow = rdown);
cout << "Th :  nv = " << Th.nv << " nt =" << Th.nt << endl;

fespace Vh(Th,P1);
Vh u1,u2;


real sigma = 00;  // value of the shift 
macro Grad(u) [dx(u),dy(u),dz(u)] // EOM
  varf  a(u1,u2)= int3d(Th)(  Grad(u1)'*Grad(u2)  - sigma* u1*u2 ) //') 
  +  on(1,u1=0.) ;  // Boundary condition
                   
varf b([u1],[u2]) = int3d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver="SPARSESOLVER"); 
cout << " fin A .. " << endl;
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=10;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

int nerr=0;
real[int]  eev(6*6*6);
eev=1e100;
for(int i=1,k=0;i<6;++i)
  for(int j=1;j<6;++j)
    for(int l=1;l<6;++l)
      eev[k++]=i*i+j*j+l*l;
eev.sort;
cout << eev << endl;
for (int i=0;i<k;i++)
  {
    u1=eV[i];
    real gg = int3d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) + dz(u1)*dz(u1) );
    real mm= int3d(Th)(u1*u1) ;
    real err = int3d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) + dz(u1)*dz(u1) - (ev[i])*u1*u1) ;
    if(abs(err) > 1e-6) nerr++;
    if(abs(ev[i]-eev[i]) > eev[i]*1e-1) nerr++;
    cout << " ---- " <<  i<< " " << ev[i] << " == " << eev[i] << " err= " << err << " --- "<<endl;
    plot(eV[i],cmm="Eigen 3d  Vector "+i+" valeur =" + ev[i]+ " == " + eev[i]    ,wait=1,value=1,ps="eigen"+i+".eps");
  }

// FFCS: avoid this assert because the list of eigenvalues is not
// always sorted in the same way
//assert(nerr==0);
border ccc(t=0,2*pi){x=cos(t);y=sin(t);}
mesh Th=buildmesh(ccc(10));
//mesh Th=readmesh("Th.msh");
fespace Vh(Th,P2);
Vh u1,u2;
real sigma = 1e-5;

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 );

                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=Crout,factorize=3); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector

int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0);
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;

for(int i=0;i<k;i++){
  cout << " Valeur propre " << i << " = " << ev[i] << endl;

  // FFCS: add 3D view
  plot(eV[i],dim=3,fill=1);
}
// test to validate the addition of surfacic finite elements in FreeFEM

load "msh3"
load "medit"


/////variational form

/////////////////////////////////
// laplacian 2D
real R = 3, r=1; 
real h = 0.1; // 
int nx = R*2*pi/h;
func torex= (R+r*cos(y*pi*2))*cos(x*pi*2);
func torey= (R+r*cos(y*pi*2))*sin(x*pi*2);
func torez= r*sin(y*pi*2);


meshL Th=segment(nx,[torex,torey,torez],removeduplicate=true) ;
fespace Vh(Th,P1);
macro Grad3(uSVar) [dx(uSVar),dy(uSVar),dz(uSVar)]  // EOM

//with variational form
real sigma = 1; 
varf a(u,v) = int1d(Th)(Grad3(u)'*Grad3(v)- sigma* u*v);
varf m(u,v) = int1d(Th)( u*v);

matrix A =a(Vh,Vh);
matrix B =m(Vh,Vh,solver=CG);
int nev=100;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector

int k=EigenValue(A,B,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=0,ncv=0,which="LM"); // which="LM" default 

for (int i=0;i<k;i++) 
	plot(eV[i],cmm=" (new plot in test) Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=1,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=1, nbiso=40);  

//  Computation of the eigen value and eigen vector of the 
// Dirichlet problem  on square $]0,\pi[^2$
// Functionnal interface 
// ----------------------------------------
// we use the inverse shift mode 
// the shift is given with sigma real
// -------------------------------------
//  find $\lamda$ such that:
// $$  \int_{\omega}  \nabla u_ \nabla v = \lamba \int_{\omega} u \nabla v  $$
verbosity=1;
mesh Th=square(20,20,[pi*y,pi*x]);
fespace Vh(Th,P2);
Vh u1,u2;
int n=Vh.ndof; 

real sigma = 00;  // value of the shift 

varf  a(u1,u2)= int2d(Th)(  dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2 )
                    + int1d(Th)(u1*u2) ;  // Boundary condition
                   
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; // no  Boundary condition

matrix A= a(Vh,Vh,solver=sparsesolver); 
matrix B= b(Vh,Vh,solver=sparsesolver); 

func real[int] FA1(real[int] & u) { real[int] Au=A^-1*u;return Au;}
func real[int] FB(real[int] & u) { real[int] Au=B*u;return Au;}
func real[int] FA(real[int] & u) { real[int] Au=A*u;return Au;}
func real[int] FB1(real[int] & u) { real[int] Au=B^-1*u;return Au;}
// important remark:
// the boundary condition is make with exact penalisation:
//     we put 1e30=tgv  on the diagonal term of the lock degre of freedom.
//  So take dirichlet boundary condition just on $a$ variationnal form
// and not on  $b$ variationnanl form.
// because we solve
//  $$ w=A^-1*B*v $$

int nev=20;  // number of computed eigen valeu close to sigma

real[int] ev(nev); // to store nev eigein value
Vh[int] eV(nev);   // to store nev eigen vector


int k=EigenValue(n,A1=FA1,B=FB,A=FA,B1=FB1,sym=true,sigma=sigma,value=ev,vector=eV,tol=1e-10,maxit=1000,ncv=200
	,mode=3,which="LM");
//   tol= the tolerace
//   maxit= the maximal iteration see arpack doc.
//   ncv   see arpack doc.
//  the return value is number of converged eigen value.
k=min(k,nev); //  some time the number of converged eigen value 
              // can be greater than nev;
int nerr=0; 
for (int i=0;i<k;i++)
{
  u1=eV[i];
  real gg = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1)) + int1d(Th)(u1*u1);
  real mm= int2d(Th)(u1*u1) ;
  real err = int2d(Th)(dx(u1)*dx(u1) + dy(u1)*dy(u1) - (ev[i])*u1*u1) +  int1d(Th)(u1*u1) ;
  if(abs(err) > 1e-6) nerr++;
  cout << " ---- " <<  i<< " " << ev[i]  << " err= " << err << " --- "<<endl;

  // FFCS: add 3D view capabilities
  plot(eV[i],cmm="Eigen  Vector "+i+" valeur =" + ev[i]  ,wait=0,value=1,dim=3,fill=1,CutPlane=0,ShowAxes=0);
}

//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
//
// code borrowed from examples/ffddm/heat-torus-3d-surf.edp

load "hpddm"                        // HPDDM plugin
macro dimension()3S// EOM           // 2D, 3D, or 3S
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // two-dimensional gradient
func Pk = P2;                               // finite element space

int s = getARGV("-split", 1);               // refinement factor
real dt = getARGV("-dt", 0.1);              // time step
int iMax = getARGV("-iMax", 50);            // number of iterations

real R = 3, r = 1;
int nx = r*2*pi*getARGV("-global", 5);
int ny = R*2*pi*getARGV("-global", 5);

meshS Th = square3(nx, ny, [(R+r*cos(2*pi*x))*cos(2*pi*y), (R+r*cos(2*pi*x))*sin(2*pi*y), r*sin(2*pi*x)]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
buildMinimalist(Th, intersection, D, Pk)

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> mat;                           // local operator

Wh<real> u = 0;
Wh<real> w = 0;
func f = 100 * exp(-20*(x^2 + (y-(R+r))^2 + z^2));
varf vPb(u, v) = int2d(Th)(u * v + dt * grad(u)' * grad(v)) + int2d(Th)(w * v + f * v);
mat = vPb(Wh, Wh, solver = GMRES);
matrix Neumann = mat;
schwarz A(mat, intersection, D);
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, A = Neumann);
}

for(int i = 0; i < iMax; ++i) {
    rhs = vPb(0, Wh);
    u[] = A^-1 * rhs;
    macro myplot()cmm = "Global solution at iteration " + i, fill = 1, value = 1//
    plotMPI(Th, u, Pk, def, real, myplot);
    w[] = u[];
    mat = vPb(Wh, Wh, solver = GMRES);
    ChangeOperator(A, mat);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro BC(u, val)u = val// EOM       // Dirichlet boundary conditions
func Pk = P1;                       // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d-substructuring.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
int[int] labDirichlet = [1, 3];
{
    int[int] l = [2, 1, 3, 2];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, 10, labDirichlet, labNeumann, s, intersection, Pk, BC, comm, excluded)
}

func f = 10;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(f * v) + on(labDirichlet, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

bdd A(Mat, intersection, communicator = comm);
// this can be replaced by feti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

pair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        AttachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(labDirichlet, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(1);
            Rb[0][] = 1;
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            Wh def(mu) = 1.0;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = mu[]);
        }
        AttachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u) = 0.0;    // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, rhs, u[], excluded = excluded);

if(!excluded)
    OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"                // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat<complex> A;
int s = getARGV("-split", 1);
macro ThRefinementFactor()s//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space

func real wedge(real a, real b) {
    if(y < 0.4 + 0.1 * 0.75 * x)
        return 2;
    else if(y < 0.8 - 0.2 * 0.75 * x)
        return 1.5;
    else
        return 3;
}
real omega = 2 * pi * 5;
func f = 80 * 100 * s * exp(-20 * 100 * s * ((x-0.5)^2 + (y-0.25)^2));
complex[int] rhs(Wh.ndof);                  // local right-hand side
matrix<complex> Loc;                        // local operator
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph val = wedge(x, y);
    Ph k = omega / val;
    varf vPb(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, -111111)(1i * k * u * v) + int1d(Th, 2)(1i * k * u * v) + int2d(Th)(f * v) + on(1, u = 0.0);
    Loc = vPb(Wh, Wh, tgv = -1);
    rhs = vPb(0, Wh, tgv = -1);
}

A = Loc;
if(usedARGV("-optimized_Schwarz") != -1)
    set(A, sparams = "-ksp_view -sub_pc_type lu", O = Loc);
else
    set(A, sparams = "-ksp_view -pc_type lu");
Wh<complex> u;                      // local solution

u[] = A^-1 * rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "medit"
load "PETSc"                        // PETSc plugin
load "parmmg"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

mesh3 Th = cube(getARGV("-global", 30), getARGV("-global", 30), getARGV("-global", 30));
DmeshCreate(Th);
fespace Vh(Th, P1);
{
    mesh3 ThParMmg;
    int[int] n2o;
    int[int][int] communicators;
    ParMmgCreateCommunicators(Th, ThParMmg, n2o, communicators);
    fespace VhParMmg(ThParMmg, P1);
    VhParMmg met = sqrt((x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2) - 0.3;
    real hmin = 2.0e-2;
    real hmax = 1.0e-0;
    met = max(hmin, min(hmax, abs(met)));
    mesh3 ThNew = parmmg3d(ThParMmg, metric = met[], hausd = 0.05, nodeCommunicators = communicators);
    DmeshReconstruct(ThNew);
    DmeshCopy(ThNew, Th);
}
Vh u = sqrt((x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2) - 0.3;
medit("Th", Th, u);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -sizeComm 2 -Dpartitioner=scotch -Dwith=PETSc

IFMACRO(!with)
macro with()PETSc//
ENDIFMACRO
include "DmeshRedistribute.idp"
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int[int] LL = [1,2, 1,2, 1,1];
mesh3 ThBorder, Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb(u, v) = int3d(ThAugmented)(grad(u)' * grad(v)) + int3d(ThAugmented)(v) + on(1, u = 1.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = cube(1, 1, 1, [x, y, z]);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int3d(Th)(grad(u)' * grad(v)) + int2d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 1.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int3d(Th)(grad(u)' * grad(v)) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int2d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

func Pk = P2;

macro def(u)u//
{
    include "macro_ddm.idp"

    mesh ThGlobal = square(getARGV("-global_2d", 40), getARGV("-global_2d", 40));
    fespace Ph(ThGlobal, P0);
    Ph part;
    if(mpirank == 0) {
        partitionerSeq(part[], ThGlobal, mpisize);
    }
    partitionerPar(part[], ThGlobal, mpiCommWorld, mpisize);
    mesh Th = trunc(ThGlobal, abs(part - mpirank) < 1.0e-2, renum = 1, label = -111112);
    DmeshReconstruct(Th);
    fespace Wh(Th, Pk);
    Wh<real> u;
    PartitionCreate(Th, u[], Pk);
    plotMPI(Th, u, Pk, def, real, cmm = "Partition of unity");
}
{
    macro dimension()3// EOM
    include "macro_ddm.idp"

    mesh3 ThGlobal = cube(getARGV("-global_3d", 10), getARGV("-global_3d", 10), getARGV("-global_3d", 10));
    fespace Ph(ThGlobal, P0);
    Ph part;
    if(mpirank == 0) {
        partitionerSeq(part[], ThGlobal, mpisize);
    }
    partitionerPar(part[], ThGlobal, mpiCommWorld, mpisize);
    mesh3 Th = trunc(ThGlobal, abs(part - mpirank) < 1.0e-2, renum = 1, label = -111112);
    DmeshReconstruct(Th);
    fespace Wh(Th, Pk);
    Wh<real> u;
    PartitionCreate(Th, u[], Pk);
    plotMPI(Th, u, Pk, def, real, cmm = "Partition of unity");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"
include "cube.idp"
macro def(i)[i, i#y]// EOM // vector field definition
macro init(i)[i, i]// EOM  // vector field initialization

macro Curl(ux, uy)[dx(uy)-dy(ux)]// EOM
func Pk = RT0Ortho;

int Dirichlet = 1;

int[int] chlab = [Dirichlet, Dirichlet, Dirichlet, Dirichlet];
mesh Th = square(getARGV("-global", 10), getARGV("-global", 10), label = chlab);

fespace Wh(Th, Pk);

int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;
{
    buildMinimalist(Th, intersection, D, Pk)
    Wh def(u);
    varf onG(def(u), def(v)) = on(-111111, u = 10 + x + y, uy = 100 + y - x);
    u[] = onG(0, Wh);
    D = u[];
    for [j, dj : D] dj = abs(dj) > 1e-1 ? 0.0 : 1.0;
}

matrix Loc;
real[int] rhs(Wh.ndof);
{
    varf vPb([Ex,Ey],[vx,vy]) =
        int2d(Th)(Curl(vx,vy)'*Curl(Ex,Ey))
        + int2d(Th)([vx,vy]'*[Ex,Ey])
        + on(Dirichlet, Ex=0,Ey=0);
    Loc = vPb(Wh, Wh, tgv = -1);
    func f = exp(-8.0*((x-0.5)^2+(y-0.5)^2));
    varf vPbRhs([Ex,Ey],[vx,vy]) =
        - int2d(Th)(100*[vx,vy]'*[0,f])
        + on(Dirichlet, Ex=0,Ey=0);
    rhs = vPbRhs(0, Wh, tgv = -1);
}

Mat A(Loc, intersection, D);
set(A, sparams = "-pc_type lu");

Wh def(sol);
sol[] = A^-1 * rhs;
macro params()cmm = "Global solution", wait = 1, fill = 1// EOM
plotMPI(Th, def(sol), Pk, def, real, params);
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

load "hpddm"                        // HPDDM plugin
load "medit"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
/*# DiffMacros #*/
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
/*# DiffMacrosEnd #*/
func Pk = [P1, P1, P1];             // finite element space

/*# DDMoptions #*/
int s = getARGV("-split", 1);                                   // refinement factor

int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
/*# SchwarzMethod #*/
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh3 ThBorder;
    Th = cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, 10, s, 1, intersection, D, Pk, mpiCommWorld, false)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11; // steel
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = intN(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
Mat = vPb(Wh, Wh, sym = 1, tgv = -2);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction balanced -hpddm_variant right -hpddm_verbosity 1 -hpddm_geneo_nu 20");

{
    if(mpisize > 1 &&
       isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        varf vPbNoPen(def(u), def(v)) = intN(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
        matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1, tgv = -2);
        AttachCoarseOperator(mpiCommWorld, A, A = noPen);
    }
}

real alpha = 5.0e3;
Wh def(u), def(d);
real[int] uBlock(u[].n * 2);
real[int] rhsBlock(u[].n * 2);

varf vPbC(def(u), def(v)) = intN(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
rhsBlock(0 * u[].n:1 * u[].n - 1) = vPbC(0, Wh, tgv = -2);

varf vPbB(def(u), def(v)) = intN(Th)(f * vB) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
rhsBlock(1 * u[].n:2 * u[].n - 1) = vPbB(0, Wh, tgv = -2);

uBlock = A^-1 * rhsBlock;

u[] = uBlock(0 * u[].n:1 * u[].n - 1);
d[] = uBlock(1 * u[].n:2 * u[].n - 1);
mesh3 ThMoved1 = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
mesh3 ThMoved2 = movemesh3(Th, transfo = [x + alpha * d, y + alpha * dB, z + alpha * dC]);
macro def1(u)u// EOM
plotMPI(ThMoved1, u, P1, def1, real, cmm = "Global moved solution");
plotMPI(ThMoved2, u, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

real k = getARGV("-waven", 40.0);
func f = 100 * exp(-10 * k * ((x-0.5)^2 + (y-0.5)^2));

real lambda = 2 * pi / k;

real epsilonA = 0;
real epsilonE = 0;

int Dirichlet = 1;
int Robin = 2;

int s = getARGV("-split", 3);
real nw = 15.0 / s;
mesh ThCoarse = square(nw * 1/lambda, nw * 1/lambda);

{
    int[int] chlab = [1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];
    ThCoarse = change(ThCoarse, refe = chlab);
}

mesh Th;
fespace Wh(Th, Pk);
real[int] part;
fespace PhCoarse(ThCoarse, P0);
PhCoarse partCoarse;
if(mpirank == 0)
    partitionerSeq(partCoarse[], ThCoarse, mpisize);
partitionerPar(partCoarse[], ThCoarse, mpiCommWorld, mpisize);
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = trunc(ThCoarse, 1, split = s);
    fespace Ph(Th, P0);
    Ph part;
    part = partCoarse;
    buildWithPartitioning(Th, part[], 1, intersection, D, Pk, mpiCommWorld);
}

real epsilon = epsilonA;
varf vPb(u, v) = int2d(Th)(-(k^2 - 1i*epsilon)*u*v + grad(u)'*grad(v))
               + int1d(Th, Robin)(1i*k*u*v)
               - int2d(Th)(f*v)
               + on(Dirichlet, u = 0);
matrix<complex> Mat = vPb(Wh, Wh, sym = 1);
fespace WhCoarse(ThCoarse, Pk);
matrix<complex> MatCoarse;
{
    mesh ThBackup = Th;
    Th = ThCoarse;
    epsilon = epsilonE;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    epsilon = epsilonA;
    Th = ThBackup;
}
set(MatCoarse, solver = sparsesolverSym, sym = 1);
schwarz<complex> ACoarseSeq(MatCoarse);
set(ACoarseSeq, prefix = "level_2_");
matrix R = interpolate(Wh, WhCoarse);
complex[int] rhs = vPb(0, Wh);

schwarz<complex> A(Mat, intersection, D);
set(A, sparams = "-hpddm_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_schwarz_method ras -hpddm_variant right -hpddm_gmres_restart 200 -hpddm_max_it 200");

Wh<complex> u;
u[] = A^-1 * rhs;
plotMPI(Th, real(u), Pk, def, real, cmm = "Global solution with a one-level method");

set(A, sparams = "-hpddm_verbosity " + (!mpirank ? "3" : "0") + " -hpddm_schwarz_coarse_correction deflated -hpddm_variant flexible -hpddm_level_2_verbosity 0");
func complex[int] correctionExact(complex[int]& in) {
    complex[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    for[i, di: D] in[i] *= di;
    tmp = R' * in;
    mpiAllReduce(tmp, tmpReduced, mpiCommWorld, mpiSUM);
    tmp = ACoarseSeq^-1 * tmpReduced;
    out = R * tmp;
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionExact);

u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, real(u), Pk, def, real, cmm = "Global solution with a redundant coarse correction");

int[int][int] intersectionCoarse;
real[int] DCoarse;
{
    buildWithPartitioning(ThCoarse, partCoarse[], 1, intersectionCoarse, DCoarse, Pk, mpiCommWorld);
    mesh ThBackup = Th;
    Th = ThCoarse;
    epsilon = epsilonE;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    epsilon = epsilonA;
    Th = ThBackup;
}
R = interpolate(Wh, WhCoarse);
schwarz<complex> ACoarse(MatCoarse, intersectionCoarse, DCoarse);
set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_level_2_schwarz_method ras -hpddm_level_2_tol 1e-1 -hpddm_level_2_gmres_restart 200 -hpddm_level_2_max_it 200 -hpddm_level_2_krylov_method gcrodr -hpddm_level_2_recycle 10", prefix = "level_2_");
macro mplot()wait = 1, cmm = "Transfers on the correction at iteration " + ijk//
int ijk = 1;
func complex[int] correctionInexact(complex[int]& in) {
    complex[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        Wh outW;
        for[i, xi: in] outW[][i] = real(xi);
        plotMPI(Th, outW, Pk, def, real, mplot);
    }
    tmpReduced = R' * in;
    exchange(ACoarse, tmpReduced, scaled = true);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        WhCoarse outWCoarse;
        for[i, xi: tmpReduced] outWCoarse[][i] = real(tmpReduced[i]);
        plotMPI(ThCoarse, outWCoarse, Pk, def, real, mplot);
        ++ijk;
    }
    tmp = ACoarse^-1 * tmpReduced;
    out = R * tmp;
    exchange(A, out);
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionInexact);
else
    exit(0);

u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, real(u), Pk, def, real, cmm = "Global solution with a one-level inner coarse correction (two levels in total)");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
macro BC(u, val)u = val, u#B = val// EOM // Dirichlet boundary conditions
func Pk = [P2, P2];                 // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-2d-substructuring.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
{
    int[int] l = [2, 1, 2, 2];
    Th = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, 10, 1, labNeumann, s, intersection, Pk, BC, comm, excluded)
}

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

bdd A(Mat, intersection, communicator = comm);
// this can be replaced by feti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

pair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        AttachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(1, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(3);
            [Rb[0], RbB[0]] = [1, 0];
            [Rb[1], RbB[1]] = [0, 1];
            [Rb[2], RbB[2]] = [y, -x];
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            real strain = 100.0;
            real Young = 1.0e8;
            real poisson = 0.45;
            real tmp = 1.0 + poisson;
            real mu = Young  / (2.0 * tmp);
            real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
            Wh def(muFunc) = mu;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = muFunc[]);
        }
        AttachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u);          // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, rhs, u[], excluded = excluded);

if(!excluded)
    OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]// EOM// vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// two-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];             // finite element space

string deflation = getARGV("-deflation", "geneo");            // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - stokes-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh3 ThBorder, Th = buildlayers(square(1, 1), 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(ThAugmented)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs, eps = -1);
}
ThBorder = buildlayers(square(1, 1), 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_mkl_pardiso_iparm_13 1 --hpddm_schwarz_method oras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 1");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + int2d(Th, fakeInterface)(transmission * ([u, uB, uC]' * [v, vB, vC])) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;
int[int] fforder(2);
fforder = [1, 1];
savevtk("stokes-io-3d.vtu", Th, [u, uB, uC], uD, order = fforder, dataname = "velocity pressure");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "Element_Mixte3d"
load "PETSc"
macro dimension()3//
include "macro_ddm.idp"

include "cube.idp"
int[int] LL = [1,2, 1,2, 1,1];
mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL); // global mesh
mesh3 ThGlobal = Th;

Mat A;
int[int] n2o;
macro ThN2O()n2o//
DmeshCreate(Th);
func Pk = [RT03d, P0];
fespace Wh(Th, Pk);
{
macro def(u)[u, u#B, u#C, u#D]//
macro init(u)[u, u, u, u]//
macro ThPostProcessD(D) {
    Wh def(u), def(v);
    varf onG(def(u), def(v)) = on(-111111, u = 10 + x - z, uB = 100 + y - x, uC = 1000 + z - y);
    v[] = D;
    u[] = onG(0, Wh);
    for [j, dj : u[]] dj = abs(dj) > 1e-2 ? 0.0 : 1.0;
    def(u) = [u, uB, uC, vD];
    D = u[];
}// EOM
MatCreate(Th, A, Pk);
}

macro div(u1, u2, u3)(dx(u1) + dy(u2) + dz(u3))//
varf vMixedLaplace([u1, u2, u3, p], [v1, v2, v3, q]) = int3d(Th)(u1 * v1 + u2 * v2 + u3 * v3 + p*div(v1, v2, v3) + div(u1, u2, u3)*q)
                                                     - int3d(Th)(q)
                                                     + int2d(Th, 1)(v1*N.x + v2*N.y + v3*N.z)
                                                     + on(2, u1 = 2.0, u2 = 3.0, u3 = 4.0);

real[int] rhs = vMixedLaplace(0, Wh, tgv = -1);
A = vMixedLaplace(Wh, Wh, tgv = -1);
set(A, sparams ="-pc_type lu");
Wh [u1, u2, u3, u4];
u1[] = A^-1 * rhs;
fespace WhGlobal(ThGlobal, Pk);
int[int] rest = restrict(Wh, WhGlobal, n2o);
WhGlobal [uG1, uG2, uG3, uG4];
real[int] reduce(uG1[].n);
{
    real[int] tmp;
    ChangeNumbering(A, u1[], tmp);
    ChangeNumbering(A, u1[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u1[][i];
mpiReduce(reduce, uG1[], processor(0), mpiSUM);
if(mpirank == 0) {
    medit("Global solution", ThGlobal, uG4);
}
[u1, u2, u3, u4] = [0.0, 0.0, 0.0, 1.0];
u1[] += 1.0;
set(A, sparams = "-pc_type fieldsplit -ksp_monitor -ksp_view " +
    "-ksp_type fgmres " +
    "-pc_fieldsplit_type schur " +
    "-pc_fieldsplit_schur_fact_type full " +
    "-fieldsplit_0_ksp_type preonly " +
    "-fieldsplit_1_ksp_type gmres " +
    "-fieldsplit_1_ksp_converged_reason -fieldsplit_1_ksp_rtol 1e-4 " +
    "-pc_fieldsplit_schur_precondition selfp " +
    "-fieldsplit_1_pc_type hypre", fields = u1[]);
u1[] = A^-1 * rhs;
{
    real[int] tmp;
    ChangeNumbering(A, u1[], tmp);
    ChangeNumbering(A, u1[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u1[][i];
mpiReduce(reduce, uG1[], processor(0), mpiSUM);
if(mpirank == 0) {
    medit("Global solution", ThGlobal, uG4);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
func Pk = P2;                       // finite element space
func Pkdc = P2dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
mesh ThBackup = Th;
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);
Vh b = 1;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, 3, 4, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, 3, 4, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, 3, 4, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

real[int] xPETSc, bPETSc;
u[] = vC(0, Vh);
ChangeNumbering(A, u[], bPETSc);
xPETSc.resize(bPETSc.n);
xPETSc = 0;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -ksp_monitor_true_residual -snes_max_it 4 -snes_converged_reason -ksp_converged_reason -pc_type lu -snes_view");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = false);
fespace VhG(ThBackup, Pk);
VhG uG, uReduce;
uReduce = u;
mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
if(mpirank == 0) {
    plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
    ThBackup = adaptmesh(ThBackup, uG);
}
broadcast(processor(0), ThBackup);
uG = uG;
plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
{
    Th = ThBackup;
    Mat Adapt;
    MatCreate(Th, Adapt, Pk);
    A = Adapt;
}
u = uG;
macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
xPETSc.resize(0);
ChangeNumbering(A, u[], xPETSc);
u[] = vC(0, Vh);
ChangeNumbering(A, u[], bPETSc);
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_max_it 40 -ksp_monitor_true_residual -snes_converged_reason -ksp_converged_reason -pc_type lu -snes_view");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "msh3"
load "mshmet"
load "mmg"
load "aniso"
load "PETSc"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]// EOM
macro init(i)[i, i, i, i]// EOM
func Pk = [P2, P2, P2, P1];
macro grad(u)[dx(u), dy(u), dz(u)]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM

real anisomax = getARGV("-anisomax", 4.0);
bool aniso = bool(anisomax > 1.0);
mesh3 Th;
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    //mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    //ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
}
mesh3 ThG = Th; // need to backup the original global mesh

Mat A;
int[int] n2o;       // need to know how to go from the local to the global mesh
if(mpirank==0) cout << "it = 0, Th.nv = " << ThG.nv << endl;
macro ThN2O()n2o//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk); // complete space [u, v, w, p]
fespace Zh(Th, P2); // velocity space
fespace Qh(Th, P1); // pressure space
Qh onlyP;
Zh onlyU;

varf vPb(def(u), def(v)) = int3d(Th)(
    grad(u)' * grad(v)
    + grad(uB)' * grad(vB)
    + grad(uC)' * grad(vC)
    - div(u) * vD - div(v) * uD
    )
    + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0)
    + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);

Wh def(u);

for(int i = 0; i < 5; ++i) {
    real[int] rhs = vPb(0, Wh, tgv = -1);
    A = vPb(Wh, Wh, tgv = -1);
    set(A, sparams = "-pc_type lu"); // add "-pc_factor_mat_solver_type mumps" to run on 1 proc
    u[] = A^-1*rhs;
    if(!NoGraphicWindow) {
        onlyP = uD;
        macro def1(i)i//
        plotMPI(Th, onlyP, P1, def1, real, cmm = "Pressure for it = " + (i+1));
        onlyU = u;
        plotMPI(Th, onlyU, P2, def1, real, cmm = "x-velocity for it = " + (i+1));
    }
    {
        fespace WhG(ThG, Pk);
        fespace ZhG(ThG, P2);
        fespace QhG(ThG, P1);
        WhG def(uG), def(uReduce);
        u[] .*= A.D;
        int[int] rest = restrict(Wh, WhG, n2o);
        uReduce[](rest) = u[];
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            // Since mshmet cannot regularize FE functions like adaptmesh,
            // first regularize solutions on [0,1];
            ZhG uMag = sqrt(uG^2+uGB^2+uGC^2);
            real unorm = uMag[].max-uMag[].min;
            QhG p = uGD;
            real pnorm = p[].max-p[].min;
            // Define normalized sol'n 
            def(uReduce) = [uG/unorm, uGB/unorm, uGC/unorm, uGD/pnorm];
            // create metric
            real[int] met = mshmet(ThG, [uReduce, uReduceB, uReduceC], uReduceD, normalization = bool(getARGV("-normalization",0)), aniso = aniso, hmin = 1.0e-3, hmax = 0.2, err = 1.0e-2, verbosity = verbosity);
            if(aniso) boundaniso(6, met, anisomax); // restrict anisotropy
            fespace METhG(ThG,[P1,P1,P1,P1,P1,P1]);
            METhG [m11,m21,m22,m31,m32,m33];
            QhG mm;
            if(!aniso) mm[] = met;
            else {
                m11[] = met;
                mm = m11+m22+m33; // trace of anisotropic metric tensor
            }
            plot(mm);
            ThG = mmg3d(ThG, metric = met, hmin = 1.0e-3, hmax = 0.2, hgrad = -1, verbose=verbosity-(verbosity==0));
            cout << "it = " << (i+1) << ", Th.nv = " << ThG.nv << endl;
            plot(ThG);
        }
        broadcast(processor(0), ThG);
        def(uG) = def(uG);
        Th = ThG;
        Mat Adapt;
        MatCreate(Th, Adapt, Pk) // decompose the adapted mesh
        A = Adapt; // replace the old Jacobian
        def(u) = init(0.0); // just to trigger a resize
        rest.resize(u[].n);
        rest = restrict(Wh, WhG, n2o);
        u[] = uG[](rest);
    }
}
DmeshSave(Th, "stokes-adapt-3d");
ofstream sol("stokes-adapt-3d_" + mpirank + "_" + mpisize + ".sol");
sol << u[];
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
real memory = PetscMemoryGetCurrentUsage();
u[] = A^-1 * rhs;
memory = PetscMemoryGetCurrentUsage() - memory;
if(mpirank == 0)
    cout << memory << " bytes of memory in usage" << endl;

real[int] err = A * u[];            // global matrix-vector product
real[int] transpose = A' * u[];
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");

Wh<real> Rb[1];
Rb[0] = 1;
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200", nearnullspace = Rb);
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -freq 2e+8

load "bem"
load "Element_Mixte3d"
load "PETSc-complex"
macro dimension()3S// EOM
include "macro_ddm.idp"
include "cobrameshcavity.idp"

if(!HasType("Mat", "Htool")) exit(0);

func Pk = RT0S;
func Qk = [P1,P1,P1];
real c0     = 299792458;
real f      = getARGV("-freq",5.e+8);
real k      = 2*pi*f/c0;
real lambda = c0/f;

// incident wave
real thetaI   = 2*pi*0./360.;
real[int] dir = [cos(thetaI),0,sin(thetaI)];
func fincx    = 0;
func fincy    = exp(1i*k*(dir[0]*x + dir[1]*y + dir[2]*z));
func fincz    = 0;
int nloc      = 4.0/lambda;

mesh3 Th3 = cube(nloc, nloc, nloc, [x-0.5, y-0.5, z-0.5]);

meshS ThG, ThS = extract(Th3);

Mat<complex> A;
int[int] n2o;
macro ThSN2O()n2o//
ThG = ThS;
DmeshCreate(ThS);
{
    Mat<complex> H, T;
    MatCreate(ThS, H, P1);
    MatCreate(ThS, T, P0);
    CoherentGlobalMesh(T, H, ThS, ThG);
}
{
    macro def(u)[u, u#2, u#3]//
    macro init(u)[u, u, u]//
    macro ThSPkPart()Edge0S//
    macro defPart(u)def(u)//
    macro initPart(u)init(u)//
    MatCreate(ThS, A, Pk);
}
fespace UhG(ThG, Pk);
fespace UhS(ThS, Pk);
// Maxwell is defined on a vector of size three
varf vk( [u1,u2,u3], [v1,v2,v3] ) = int2dx2d(ThG)(ThG)(BEM(BemKernel("MA_SL", k=k), [u1,u2,u3], [v1,v2,v3]));
A = vk(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-3 -mat_htool_eta 10");
varf vRHS([ux, uy, uz], [vx, vy, vz]) = int2d(ThG)([vx, vy, vz]' * [-fincx, -fincy, -fincz]);
UhG<complex> [bx, by, bz], [ux, uy, uz];
bx[] = vRHS(0, UhG);
Mat<complex> C;
string type = HasType("Mat", "ScaLAPACK") ? "scalapack" : "aij";
MatConvert(A, C, type = type);
set(C, sparams = "-pc_type lu");
int[int] range = C.range;
complex[int] rhs(C.n);
rhs = bx[](range(0):range(1)-1);
KSPSolve(C, rhs, rhs);
if(!NoGraphicWindow) {
    if (type == "scalapack") {
        complex[int] before(UhG.ndof), after(UhG.ndof);
        before(range(0):range(1)-1) = rhs;
        mpiAllReduce(before, after, mpiCommWorld, mpiSUM);
        rhs.resize(A.n);
        range = A.range;
        rhs = after(range(0):range(1)-1);
    }
    UhS<complex> [solx, soly, solz];
    bool flg = true;
    if(!flg)
        ChangeNumbering(A, solx[], rhs, inverse = 1, exchange = 1);
    nloc *= 15;
    nloc -= nloc%8;
    meshS ThOutG = square3(nloc, nloc, [4*(x-0.5), 4*(y-0.5), 0]);
    ThOutG = trunc(ThOutG, max(abs(x), abs(y)) > 0.5 + 4.0/nloc);
    meshS ThOutS = ThOutG;
    int[int] n2o;//
    macro ThOutSN2O()n2o//
    DmeshCreate(ThOutS);
    {
        Mat<complex> B, T;
        MatCreate(ThOutS, B, P1);
        MatCreate(ThOutS, T, P0);
        CoherentGlobalMesh(T, B, ThOutS, ThOutG);
    }
    Mat<complex> B;
    {
        macro def(u)[u, u#2, u#3]//
        macro init(u)[u, u, u]//
        MatCreate(ThOutS, B, Qk);
    }
    fespace UhOutG(ThOutG, Qk);
    fespace UhOutS(ThOutS, Qk);
    // Maxwell is defined on a vector of size three
    varf vP([u1,u2,u3], [v1,v2,v3] ) = int2d(ThG)(POT(BemPotential("MA_SL", k=k), [u1,u2,u3], [v1,v2,v3] )) ;
    Mat<complex> P(B, A);
    P = vP(UhG, UhOutG, sparams = "-mat_htool_epsilon 1.0e-3 -mat_htool_eta 10");
    ObjectView(P, format = "info");

    UhOutS<complex> [Ex, Ey, Ez];
    if(flg) {
        complex[int] E(B.n);
        MatMult(P, rhs, E);
        ChangeNumbering(B, Ex[], E, inverse = 1, exchange = 1);
    } else {
        Ex[] = P * solx[];
    }

    fespace Uh(ThOutS, P1);
    Uh Er = sqrt(real(Ex+fincx)^2 + real(Ey+fincy)^2 + real(Ez+fincz)^2);
    macro def1(u)u//
    plotMPI(ThOutS, Er, P1, def1, real, cmm = "Global solution");
}
if(0) {
    UhS<complex> [blx, bly, blz];
    varf vRHSl([ux, uy, uz], [vx, vy, vz]) = int2d(ThS)([vx, vy, vz]' * [-fincx, -fincy, -fincz]);
    blx[] = vRHSl(0, UhS);
    exchange(A, blx[], scaled = 1);
    complex[int] wrhs;
    ChangeNumbering(A, blx[], wrhs);
    wrhs -= rhs;
    cout << wrhs.l2 << endl;
    [blx, bly, blz] = [bx, by, bz];
    exchange(A, blx[], scaled = 1);
    ChangeNumbering(A, blx[], wrhs);
    wrhs -= rhs;
    cout << wrhs.l2 << endl;
    blx[] = vRHSl(0, UhS);
    complex[int] exchge;
    ChangeNumbering(A, blx[], exchge);
    ChangeNumbering(A, blx[], exchge, inverse = 1, exchange = 1);
    ChangeNumbering(A, blx[], wrhs);
    wrhs -= rhs;
    cout << wrhs.l2 << endl;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1, P1, P1]; // finite element space


int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

real f = -9000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
fespace Wh(Th, Pk);                 // local finite element space
matrix Loc = vPb(Wh, Wh);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view -ksp_max_it 100", bs = 3);
Wh<real> def(u);                    // local solution

A = Loc;
u[] = A^-1 * rhs;

real[int] err = A * u[];            // global matrix-vector product
exchange(A, rhs, scaled = true);
err -= rhs;

macro def1(u)u// EOM
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, P1, def1, real, cmm = "Global residual");

Wh<real> def(Rb)[6];
[Rb[0], RbB[0], RbC[0]] = [1, 0, 0];
[Rb[1], RbB[1], RbC[1]] = [0, 1, 0];
[Rb[2], RbB[2], RbC[2]] = [0, 0, 1];
[Rb[3], RbB[3], RbC[3]] = [y, -x, 0];
[Rb[4], RbB[4], RbC[4]] = [-z, 0, x];
[Rb[5], RbB[5], RbC[5]] = [0, z, -y];
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200 -pc_gamg_threshold 0.01", nearnullspace = Rb);
u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
real alpha = 1.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = mpirank;
plotMPI(ThMoved, u, P1, def1, real, cmm = "Global moved solution");
if(HasType("PC", "hpddm")) {
    u[] = 0;
    set(A, sparams = "-pc_type hpddm -pc_hpddm_coarse_p 2 -pc_hpddm_levels_1_eps_nev 20 -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_define_subdomains -pc_hpddm_has_neumann -pc_hpddm_levels_1_pc_type asm -ksp_monitor");
    u[] = A^-1 * rhs;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2//
include "macro_ddm.idp"

macro def(u)u//
macro init(u)u//
border C(t = 0, 2*pi){ x=cos(t); y=sin(t); }
mesh Th = buildmesh(C(getARGV("-global", 100)));

func Pk = P1dc;
fespace Vh(Th, Pk);
Mat dK;
MatCreate(Th, dK, Pk);
Vh v1 = y, v2 = -x;

macro diff(n)(abs(n) - (n))//

varf vK(c, w) = int2d(Th)((v1 * dx(c) + v2 * dy(c)) * w) + intalledges(Th)((1 - nTonEdge) * w * diff(v1 * N.x + v2 * N.y) * 0.5 * jump(c));
varf vM(c, w) = int2d(Th)(c * w);
matrix M = vM(Vh, Vh);
matrix K = vK(Vh, Vh);

dK = K;
Mat dM(dK, M);
set(dM, sparams = "-pc_type jacobi");
Mat dT(dM);

func real[int] funcExplicit(real t, real[int]& in) {
    real[int] temp(in.n), out(in.n);
    MatMult(dK, in, temp);
    temp *= -1;
    KSPSolve(dM, temp, out);
    return out;
}
func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] temp(in.n), out(in.n);
    MatMult(dM, inT, out);
    MatMult(dK, in, temp);
    out += temp;
    return out;
}
real shift = 0;
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    if(abs(a - shift) > 1.0e-10) {
        matrix B = a * M + K;
        dT = B;
        shift = a;
    }
    return 0;
}
Vh w;
string type;
func int funcM(int s, real t, real[int]& u) {
    ChangeNumbering(dT, w[], u, inverse = true, exchange = true);
    plotMPI(Th, w, Pk, def, real, cmm = "Global solution at step " + s + " (time " + t + ") with " + type + " method");
}
for(int j = 0; j < 3; ++j) {
    Vh c = exp(-10 * ((x - 0.3)^2 + (y - 0.3)^2));
    real[int] cPETSc;
    ChangeNumbering(dT, c[], cPETSc);
    real T = 3 * pi;
    string deflt = "-ts_view -ts_max_snes_failures -1 -ts_exact_final_time interpolate -ts_adapt_type basic -ts_max_time " + string(T);
    if(j == 0) {
        type = "explicit";
        TSSolve(dT, funcJ, funcExplicit, cPETSc, sparams = "-ts_type rk -ts_rk_type 5f " + deflt, monitor = funcM);
    }
    else if(j == 1) {
        type = "implicit";
        TSSolve(dT, funcJ, funcRes, cPETSc, sparams = "-ts_type rosw " + deflt, monitor = funcM);
    }
    else {
        type = "semi-implicit";
        TSSolve(dT, funcJ, funcRes, cPETSc, sparams = "-ts_type arkimex -ts_arkimex_type 5 " + deflt, monitor = funcM);
    }
    ChangeNumbering(dT, c[], cPETSc, inverse = true, exchange = true);
    macro params()cmm = "Global solution with " + type + " method", wait = 1, dim = 3, fill = 1// EOM
    plotMPI(Th, c, Pk, def, real, params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

assert(mpisize == 4);
load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro BC(u, val)u = val// EOM       // Dirichlet boundary conditions
func Pk = P1;                       // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d-substructuring.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
int[int] labDirichlet = [1, 3];
{
    int[int] l = [2, 1, 3, 2];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    fespace Ph(Th, P0);
    Ph part;
    part = (x > 0.5 && y > 0.5 ? 3 : (x > 0.5 ? 2 : (y < 0.5 ? 1 : 0)));
    buildSubstructuringWithPartitioning(Th, interfaceNb, part[], 10, labDirichlet, labNeumann, s, intersection, Pk, BC, comm, excluded);
}

func f = 10;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(f * v) + on(labDirichlet, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1); // local operator
real[int] rhs = vPb(0, Wh);                  // local right-hand side

bdd A(Mat, intersection, communicator = comm);
// this can be replaced by feti
bool adaptive = isSetOption("geneo_nu") || isSetOption("geneo_threshold");

pair ret;
if(mpisize == 1)
    renumber(A, Mat, interfaceNb, effort = rhs);
else {
    if(excluded)
        AttachCoarseOperator(mpiCommWorld, A);
    else {
        Wh[int] def(Rb)(0);
        real[int] float(Wh.ndof);
        varf floatingPb(def(u), def(v)) = on(labDirichlet, BC(u, 1.0));
        float = floatingPb(0, Wh);
        if(float.max < 0.9 && !adaptive) {
            Rb.resize(1);
            Rb[0][] = 1;
        }
        if(getARGV("-hpddm_substructuring_scaling", 0) != 2)
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs);
        else {
            Wh def(mu) = 1.0;
            renumber(A, Mat, interfaceNb, R = Rb, effort = rhs, rho = mu[]);
        }
        AttachCoarseOperator(mpiCommWorld, A, R = Rb, ret = ret);
    }
}

Wh<real> def(u) = 0.0;    // local solution

if(mpisize == mpiSize(comm))
    u[] = A^-1 * rhs;
else
    DDM(A, rhs, u[], excluded = excluded);

if(!excluded)
    OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");

statistics(A);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P1;                               // finite element space

macro ThRefinementFactor()getARGV("-split", 1)//
int[int] l = [1, 2, 2, 2];
mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);
fespace Wh(Th, Pk);           // local finite element space
Mat T;
MatCreate(Th, T, Pk);

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> Loc;                           // local operator
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph kappa = x < 0.25 ? 10.0 : 1.0;
    varf vPb(u, v) = int2d(Th)(-1.0 * kappa * grad(u)' * grad(v)) + on(1, u = 0.0);
    Loc = vPb(Wh, Wh, tgv = -2);
    rhs = vPb(0, Wh, tgv = -2);
}

func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] out(in.n);
    T = Loc;
    MatMult(T, in, out);
    out = inT - out;
    return out;
}
real shift = 0;
matrix Id;
{
    real[int] D(Loc.n);
    D = 1.0;
    Id = D;
}
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    matrix B = (-1.0) * Loc + a * Id;
    T = B;
    shift = a;
    return 0;
}
Wh w;
func int funcM(int s, real t, real[int]& u) {
    ChangeNumbering(T, w[], u, exchange = true, inverse = true);
    plotMPI(Th, w, Pk, def, real, cmm = "Global solution at step " + s + " (time " + t + ")");
}
w = (0.5 - x)^2 + (0.5 - y)^2 < 0.2 ? 1.0 : 0.0;
real[int] wPETSc;
ChangeNumbering(T, w[], wPETSc);
TSSolve(T, funcJ, funcRes, wPETSc, sparams = "-ts_type beuler -ts_dt 0.1 -ts_max_time 100 -ts_exact_final_time interpolate -ts_max_snes_failures -1 -ts_view -pc_type lu -ts_adapt_type basic -ts_rtol 1e-3", monitor = funcM);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2// EOM
include "macro_ddm.idp"

real c = 6.25;
int N  = 80;

// domain: unit square
border aa(t=0,1) { x=t;   y=0;   };
border bb(t=0,1) { x=1;   y=t;   };
border cc(t=0,1) { x=1-t; y=1;   };
border dd(t=0,1) { x=0;   y=1-t; };

mesh M = buildmesh(aa(N)+bb(N)+cc(N)+dd(N));

load "Element_P3"
func Pk = P1;
Mat A;
macro MRefinementFactor()getARGV("-split", 1)//
MatCreate(M, A, Pk);
fespace Vh(M, Pk);
Vh u;
func BC = cos(pi*x)*cos(pi*y);
varf vInit(w, v) = on(aa, bb, cc, dd, w = BC);
varf vJ(w, v) = int2d(M)(dx(w)*dx(v) + dy(w)*dy(v) - c*exp(u)*w*v) + on(aa, bb, cc, dd, w = 0);
varf vRes(w, v) = int2d(M)(dx(u)*dx(v) + dy(u)*dy(v) - c*exp(u)*v) + on(aa, bb, cc, dd, w = u);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    real[int] out(Vh.ndof);
    out = vRes(0, Vh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vJ(Vh, Vh, tgv = -2);
    return 0;
}
set(A);
if(HasType("PC", "hpddm")) {
    bool stage = usedARGV("-stage") != -1;
    for(int i = 0; i < 3; ++i) {
        string params;
        if(i == 0) {
            params = "";
            if(stage)
                PetscLogStagePush("Everything");
        }
        else if(i == 1) {
            params = "-pc_hpddm_coarse_ksp_reuse_preconditioner";
            Mat B = A;
            A = B;
            if(stage)
                PetscLogStagePush("Fine level");
        }
        else if(i == 2) {
            params = "-pc_hpddm_levels_1_ksp_reuse_preconditioner";
            Mat B = A;
            A = B;
            if(stage)
                PetscLogStagePush("Nothing");
        }
        set(A, sparams = "-pc_type hpddm -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_levels_1_eps_nev 10 -pc_hpddm_define_subdomains -pc_hpddm_has_neumann -ksp_converged_reason -pc_hpddm_levels_1_pc_type asm " + params);
        real[int] bPETSc;
        u[] = vInit(0, Vh, tgv = -2);
        ChangeNumbering(A, u[], bPETSc);
        real[int] xPETSc = bPETSc;
        SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_type newtonls -snes_converged_reason -ksp_converged_reason -snes_view");
        ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
        macro def(u)u//
        plotMPI(M, u, Pk, def, real, cmm = "Global solution");
        set(A, sparams = "-pc_type none");
        if(stage)
            PetscLogStagePop();
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
load "hpddm"

int n = 4;
real[int] b(n), u(n);
func real[int] matId(real[int]& u) { return u; };
func real[int] A(real[int]& u) {
    for(int i = 0; i < u.n; ++i)
        u[i] = (10 * mpirank + i + 1) * u[i];
    return u;
}
func real error(real[int]& u , real[int]& b) {
    real s = 0;
    for(int i = 0; i < u.n; ++i)
        s += abs((10 * mpirank + i + 1) * u[i] - b[i]);
    return s;
}

b = 1;
u = 0;
IterativeMethod(A, b, u, sparams = "-hpddm_tol 1e-6 -hpddm_foo_krylov_method gcrodr -hpddm_foo_recycle 4 -hpddm_foo_variant flexible" + (mpirank == 0 ? " -hpddm_foo_verbosity 4" : ""), prefix = "foo_");
assert(error(u, b) < 1e-5);
u = 0;
IterativeMethod(A, b, u, precon = matId, prefix = "foo_");
assert(error(u, b) < 1e-5);
func real[int] B(real[int]& u) {
    for(int i = 0; i < u.n; ++i)
        u[i] = (2 * mpirank + i + 1) * u[i];
    return u;
}
mpiWtime();
func real[int] time(real[int]& u) {
    for(int i = 0;i < u.n; ++i)
        u[i] *= (1.0 + 1.0 / mpiWtime());
    return u;
}
u = 0;
IterativeMethod(B, b, u, precon = time, prefix = "foo_");
func real errorB(real[int]& u , real[int]& b) {
    real s = 0;
    for(int i = 0; i < u.n; ++i)
        s += abs((2 * mpirank + i + 1) * u[i] - b[i]);
    return s;
}
assert(errorB(u, b) < 1e-5);
// This codes shows how to solve an eigenvalue problems
// in different coordinate systems. The example here is
// the Laplace equation on a toroidal surface embedded
// in R3. The cartesian coordinates on the torus read
//     x = (r1+r2*cos(u))*cos(v)
//     y = (r1+r2*cos(u))*sin(v)
//     z = r2*sin(v)
// with r1>r2 the major and minor radii and u,v \in [0,2\pi]
// The toroidal surface thus maps to a square domain of
// side 2\pi and periodic boundary conditions in both
// coordinates.
//
// Laplace-Beltrami on a torus, using SLEPc.
//
// Is the eigenspectrum known analytically?
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-torus-SLEPc.edp \
//        -split 1 -npts 400 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels = [1,2,3,4]; // labels : bottom, right, top, left sides
int[int] labPeriodic = [Labels[0],Labels[2],Labels[1],Labels[3]];

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

macro Pk() P1, periodic=[[Labels[0],x],[Labels[2],x],[Labels[1],y],[Labels[3],y]]//EOM

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 400) ; // Number of points on the perimeter
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real r1 = getARGV("-r1",2.0); // Large radius of the torus
real r2 = getARGV("-r2",1.0); // Small radius of the torus
if (r1<=r2){if(!mpirank) cout << "Error r1<r2 is a wrong dimensions of the torus"<<endl; exit(1);}
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-torus-SLEPc.edp "        << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts           << endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  Large radius of the torus = " << r1          << endl
        << "  Small radius of the torus = " << r2          << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Thetapts = int(0.25*Npts); // pts on the x-axis sides
    int Phipts   = int(0.25*Npts); // pts on the y-axis sides

    Th = square(Thetapts,Phipts,[2.0*x*pi,2.0*pi*y],label=Labels);
    // .....
    buildPeriodic(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld, // Communicator
            labPeriodic   // Array of labels for periodic boundaries
         );
}
/***********************************************************************/
/*         Coordinate dependant differential operators                 */
/***********************************************************************/
/*              Parametric coordinates in the (u,v)-plane              */
/*                                                                     */
/*                  u  --> x  in [0,2*pi]                              */
/*                  v  --> y  in [0,2*pi]                              */
/*                                                                     */
/*          Jacobian determinant on the bi-periodic square             */
/*        The det(J) = r2*(r1+r2*cos(u)) --> r2(r1+r2*cos(x))          */
/*                                                                     */
macro Jac()( r2*(r1+r2*cos(x)) )            // End Of Macro /*         */
     /*  The Jacobian                                                  */
/*                                                                     */
/*       The gradiant operator on the induced toroidal surface         */
/*                                                                     */
/*       grad =   1/r2*d/du              ->  1/r2*d/dx                 */
/*                1/(r1+r2*cos(u))*d/dv  ->  1/(r1+r2*cos(x)*d/dy      */
/*                                                                     */
macro Grad(u) [dx(u)/r2,dy(u)/(r1+r2*cos(x))]      // End Of Macro /*  */
     /*  The Gradient operator                                         */
macro Lap(u,v) ( Grad(u)'*Grad(v)) //')      // End Of Macro /*        */
     /*  The Laplace-Beltrami operator on the induced surface          */ 
/*                                                                     */
/***********************************************************************/
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
  (Jac*(Lap(uh,vh)))//  Bilinear form
  ;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
  ( Jac*uh*vh )           //  Bilinear form
  ;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type cholesky "       +
  " -st_matstructure same "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
macro grad(u)[dx(u), dy(u), dz(u)]// EOM

func Pk = P1;                       // finite element space
int level = getARGV("-level", 3);
int[int] LL = [1,2, 1,2, 1,1];
mesh3[int] ThTab(level);
ThTab[level - 1] = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [x, y, z], label = LL);
Mat[int] MG(level);
matrix[int] P(level - 1);
buildMatRecursive(ThTab, getARGV("-split", 2), level, P, MG, Pk, mpiCommWorld);
real[int] rhs;
for(int i = 0; i < level; ++i) {
    varf vPb(u, v) = int3d(ThTab[i])(grad(u)' * grad(v)) + int3d(ThTab[i])(v) + on(1, u = 0.0);
    fespace Wh(ThTab[i], Pk);
    MG[i] = vPb(Wh, Wh, tgv = -2);
    if(i == 0) {
        rhs.resize(Wh.ndof);
        rhs = vPb(0, Wh);
    }
}
set(MG, P, sparams = "-pc_type mg");
fespace Wh(ThTab[0], Pk);
Wh u;
u[] = MG[0]^-1 * rhs;
macro def(u)u//
plotMPI(ThTab[0], u, Pk, def, real, cmm = "Global solution");
real[int] tmp(Wh.ndof);
tmp = u[];
for(int i = 0; i < level; ++i) {
    fespace Vh(ThTab[i], Pk);
    Vh w;
    w[] = tmp;
    exchange(MG[i], w[], scaled = true);
    int[int] fforder = [1];
    savevtk("diffusion-mg-3d.vtu", ThTab[i], w, bin = 1, order = fforder, append = i ? true : false);
    if(i == level - 1)
        break;
    tmp.resize(P[i].m);
    tmp = P[i]' * w[];
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
macro trueRestrict()true//
macro removeZeros()true//
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space


mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
mesh ThBackup = Th;
int[int] n2o;
macro ThN2O()n2o//
DmeshCreate(Th);
fespace Wh(Th, Pk);           // local finite element space

varf vPb(u, v) = intN(Th)(u * v + grad(u)' * grad(v) - 10 * dy(v) * u) + intN(Th)(v * x) + on(1, 2, 3, 4, u = 0.0);
varf vPbT(u, v) = intN(Th)(u * v + grad(u)' * grad(v) - 10 * dy(u) * v) + intN(Th)(v * x) + on(1, 2, 3, 4, u = 0.0);
matrix<real> Loc  = vPb(Wh, Wh);
matrix<real> LocT = vPbT(Wh, Wh);
real[int] rhs = vPb(0, Wh);

Mat A;
MatCreate(Th, A, Pk);
A = Loc;
Mat AT(A, LocT);
Wh<real> def(u);  // local solution
Wh<real> def(v);  // local solution

u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = A'^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution transpose");
v[] = AT^-1 * rhs;
u[] -= v[];
real local = u[].linfty;
real norm;
mpiAllReduce(local, norm, mpiCommWorld, mpiMAX);
plotMPI(Th, v, Pk, def, real, cmm = "Global solution transposed problem (linfty of error = " + norm + ")");
if(!NoGraphicWindow) {
    fespace WhBackup(ThBackup, Pk);
    int[int] rest = restrict(Wh, WhBackup, n2o);
    u[] = v[];
    u[] .*= A.D;
    WhBackup sol, solReduced;
    for[i, v : rest] sol[][v] = u[][i];
    mpiReduce(sol[], solReduced[], processor(0), mpiSUM);
    plot(solReduced, wait = 1);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"                // SLEPc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(20, 20);
fespace Vh(Th, Pk);
complex lambda;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v) + lambda^0.5 * u * v);
Mat<complex> A, B;
MatCreate(Th, A, Pk);
func int FormFunction(complex mu) {
    lambda = mu;
    A = vPb(Vh, Vh);
    return 0;
}
func int FormJacobian(complex mu) {
    matrix<complex> Id = eye(Vh.ndof);
    Id = 0.5/mu^0.5 * Id;
    Mat<complex> C(A, Id);
    B = C;
    return 0;
}
FormFunction(1.0);
FormJacobian(1.0);
Vh<complex>[int] vec(1);
NEPSolve(A, FormFunction, B, FormJacobian, vectors = vec, sparams = "-nep_type nleigs -nep_nev 4 -rg_type ellipse -rg_ellipse_center 0.0 -rg_ellipse_radius 0.4 -nep_monitor -nep_view -nep_view_values");
vec.resize(5);
for(int i = 0; i < vec.n; ++i) {
    macro def(u)u//
    plotMPI(Th, vec[i], Pk, def, complex, cmm = "Eigenvector #" + i);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "msh3"
load "medit"
macro dimension()3S//
include "macro_ddm.idp"

real R  = 3.0, r = 1.0;
real h  = 0.2;
int nx  = R*2*pi/h;
int ny  = r*2*pi/h;
func tx = (R+r*cos(y*pi*2))*cos(x*pi*2);
func ty = (R+r*cos(y*pi*2))*sin(x*pi*2);
func tz = r*sin(y*pi*2);

meshS Th = square3(nx, ny, [tx,ty,tz], removeduplicate=true);

Mat A;
MatCreate(Th,A,P1);
fespace Vh(Th,P1);

macro Grad3(uvw) [dx(uvw), dy(uvw), dz(uvw)]//

real sigma = 1;
varf aS(u,v) = int2d(Th)(Grad3(u)'*Grad3(v));
varf mS(u,v) = int2d(Th)(u*v);

A = aS(Vh, Vh, sym = 1);
matrix LocB = mS(Vh, Vh, sym = 1, solver = CG);
Mat B(A, LocB);
int nev = 10;
real[int] ev(nev);
Vh[int] eV(nev);

string ssparams =
  " -eps_nev " + nev       +
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   +
  " -st_type sinvert "     +
  " -st_pc_type cholesky " +
  " -eps_view"             +
  " -eps_gen_hermitian";
int k = EPSSolve(A, B, values = ev, vectors = eV, sparams = ssparams);

for(int i = 0; i < k; ++i) {
    macro params()cmm = "Eigenvector #" + i + ", eigenvalue =" + ev[i], wait = 1, fill = 1, value = 1//
    plotD(Th, eV[i], params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "msh3"
load "mshmet"
load "PETSc"
macro with()PETSc//
load "parmmg"
load "mmg"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

int n = 12;
int[int] L=[1,1,1,1], LU=[0,2], LD=[1,1], LR=[0,1];
mesh3 Th3 = buildlayers(square(n, n, region=0, label=L), n, zbound=[0,1], labelmid=LD, labelup=LU, labeldown=LR);
Th3 = trunc(Th3, x < 0.5 || y < 0.5 || z < 0.5, label=3);

macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
macro MmgParameters(ThGather, met, rt, verbose)ThGather, metric = met, hgrad = getARGV("-hgrad", 2.3), requiredTriangle = rt, verbose = verbose// EOM
macro ParMmgCommunicatorsAndMetric(Th, met, ThParMmg, metParMmg, communicators) {
int[int] n2o;
ParMmgCreateCommunicators(Th, ThParMmg, n2o, communicators);
int[int] rest(ThParMmg.nv * (met.n / Th.nv));
if(met.n == 6 * Th.nv) {
    fespace VhMet(Th, [P1, P1, P1, P1, P1, P1]);
    fespace VhParMmg(ThParMmg, [P1, P1, P1, P1, P1, P1]);
    rest = restrict(VhParMmg, VhMet, n2o);
}
else if(met.n == Th.nv) {
    fespace VhMet(Th, P1);
    fespace VhParMmg(ThParMmg, P1);
    rest = restrict(VhParMmg, VhMet, n2o);
}
else
    assert(0);
metParMmg.resize(rest.n);
metParMmg = met(rest);
}//

varf vPoisson(u, v) = int3d(Th3)(grad(u)' * grad(v)) + int3d(Th3)(v) + on(1,2,3, u=0);

Mat<PetscScalar> A;
DmeshCreate(Th3);
MatCreate(Th3, A, P1);
fespace Vh(Th3, P1);
Vh<PetscScalar> u;
real err = 8.0e-3;

int iMax = getARGV("-iMax", 1);
int noTransfer = (getARGV("-transfer", 1) == 0);
int niter = getARGV("-niter", 3);
int verbose = getARGV("-verbose", 1);
bool isotropic = (usedARGV("-isotropic") != -1);
int elementsPerProcess = max(getARGV("-elements_per_process", 1), 8000);
int maxP = max(min(getARGV("-max_P", mpisize), mpisize), 1);
int[int] rt(2);
rt = [1,2];
for(int i = 0; i < iMax; ++i) {
    A = vPoisson(Vh, Vh, tgv = -2);
    set(A, sparams = "-ksp_monitor -pc_type gamg");
    PetscScalar[int] rhs = vPoisson(0, Vh, tgv = -1);
    u[] = A^-1 * rhs;
    mesh3 ThParMmg;
    DmeshInitialize(ThParMmg);
    int P = 1;
    if(maxP != 1) {
        fespace Ph(Th3, P0);
        Ph part;
        PartitionCreate(Th3, part[], P0);
        part = abs(part - 1.0) < 1e-1;
        int nt, ntLocal = part[].l1;
        mpiAllReduce(ntLocal, nt, mpiCommWorld, mpiSUM);
        P = min(maxP, min(mpisize, max(1, nt / elementsPerProcess)));
    }
    if(P != mpisize) {
        int div = mpisize / P;
        mpiComm commThGather(mpiCommWorld, (mpirank % div == 0 && mpirank / div < P) ? 0 : mpiUndefined, mpirank / div);
        mpiComm comm(mpiCommWorld, min(mpirank / div, P - 1), mpirank - div * min(mpirank / div, P - 1));
        macro ThGatherComm()commThGather//
        mesh3 ThGather;
        DmeshGather(Th3, comm, ThGather);
        fespace VhGather(ThGather, P1);
        VhGather<PetscScalar> uGather;
        VecGather(Th3, comm, ThGather, P1, u, uGather);
        macro ThGatherParMmgComm()commThGather//
        mesh3 ThGatherParMmg;
        DmeshInitialize(ThGatherParMmg);
        if((mpirank % div == 0 && mpirank / div < P) != 0) {
            real[int] met = mshmet(ThGather, abs(uGather), aniso = !isotropic, hmin = 1.0e-3, hmax = 1.0e-1, err = err);
            if(mpiSize(commThGather) > 1) {
                real[int] metParMmg;
                int[int][int] communicators;
                ParMmgCommunicatorsAndMetric(ThGather, met, ThGatherParMmg, metParMmg, communicators);
                ThGatherParMmg = parmmg3d(MmgParameters(ThGatherParMmg, metParMmg, rt, verbose), nodeCommunicators = communicators, niter = niter, comm = commThGather);
            }
            else
                ThGatherParMmg = mmg3d(MmgParameters(ThGather, met, rt, verbose));
        }
        DmeshScatter(ThGatherParMmg, comm, ThParMmg);
    }
    else {
        real[int] met = mshmet(Th3, abs(u), aniso = !isotropic, hmin = 1.0e-3, hmax = 1.0e-1, err = err);
        real[int] metParMmg;
        int[int][int] communicators;
        ParMmgCommunicatorsAndMetric(Th3, met, ThParMmg, metParMmg, communicators);
        ThParMmg = parmmg3d(MmgParameters(ThParMmg, metParMmg, rt, verbose), nodeCommunicators = communicators, niter = niter);
        DmeshReconstruct(ThParMmg);
    }
    int[int] fforder = [1];
    savevtk("laplace-adapt-dist-3d.vtu", Th3, abs(u), bin = 1, order = fforder, append = i ? true : false);
    if(!noTransfer) {
        fespace VhAdapt(ThParMmg, P1);
        VhAdapt<PetscScalar> uAdapt;
        VecInterpolate(Th3, P1, u, ThParMmg, P1, uAdapt);
        savevtk("laplace-adapt-dist-3d.vtu", ThParMmg, abs(uAdapt), bin = 1, order = fforder, append = true);
    }
    DmeshCopy(ThParMmg, Th3);
    Mat<PetscScalar> Adapt;
    MatCreate(Th3, Adapt, P1);
    A = Adapt;
    u = 0.0;
    err *= 0.5;
}
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with quadratic potential (the
// Quantum Harmonic Oscillator) on a pseudo-1d domain, using SLEPc.
//
// Here, we consider the problem of a 1d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + 0.5*x^2* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is the set half integrers :
//    E_n = n+1/2 (n \in N)
//
//   See e.g. :
//   - Chap. I in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//   - Landau & Lifshitz, Volume 3 : (Quantum Mechanics) Chap. III-23
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-1d-harmonic-oscillator-SLEPc.edp \
//        -split 1 -npts 1600 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 800) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 40.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 1)   ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-1d-harmonic-oscillator-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space
//fespace Vh(Th,Pk,periodic=[[Labels[0],x],[Labels[2],x]]); // Periodic does not work

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts); // pts on the x-axis sides
    int Ypts= 1;             // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= intN(Th)        //  Definion of  the problem
( 0.5*dx(uh)*dx(vh)
  +1000*dy(uh)*dy(vh)   // cheat for pseudo-1d since periodic does not work
  +( 0.5*x^2-sigma)*uh*vh      )//  Bilinear form
//  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
//  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
//  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
//  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= intN(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D, clean = true);
Mat DistB(DistA, B, clean = true);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);              // local finite element space
int[int][int] intersection(0);   // local-to-neighbors renumbering
real[int] D;                     // partition of unity
{
    mesh ThBorder;
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

matrix<real> Mat;                           // local operator
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 1.0);
Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(grad(u)' * grad(v)) + int1d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 1.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(grad(u)' * grad(v)) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err = A * u[]; // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

// sequential script from https://www.um.es/freefem/ff++/pmwiki.php?n=Main.Newton3D
// Navier--Stokes block solved using a modified augmented Lagrangian preconditioner,
// cf. [Moulin et al. 2019] (https://github.com/prj-/moulin2019al)

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
macro trueRestrict()true// EOM
macro removeZeros()true// EOM
include "macro_ddm.idp"             // additional DDM functions

mesh Th = square(getARGV("-global", 30), getARGV("-global", 30));
bool adaptation = usedARGV("-adaptation") != -1;
real gammaAL = 0.3;

macro grad(u)[dx(u), dy(u)]//
macro Grad(u)[grad(u#1), grad(u#2)]//
macro div(u)(dx(u#1) + dy(u#2))//
macro ugrad(u, v)([u#1, u#2]' * grad(v))//
macro UgradV(u, v, T)[ugrad(u, v#1), ugrad(u, v#2), ugrad(u, T)]//
macro Pk()[P2, P2, P1, P1]//
macro def(i)[i, i#B, i#C, i#D]// EOM      // vector field definition
macro init(i)[i, i, i, i]// EOM           // vector field initialization

fespace Wh(Th, [P2, P2, P1, P1]);
real nu        = 1/100.0;
real nuFinal   = 1/1500.0;
real Pr        = 56.2;
real k         = 1/Pr;
real nuCurrent = nu;


real[int] D;
int[int][int] intersection;
mesh ThBackup;
{
    if(adaptation)
        ThBackup = Th;
    int s = getARGV("-split", 1);
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

Wh [u1, u2, p, T] = [0, 0, 0, 1-x];

real c;
varf vPb([uw1, uw2, pw, Tw], [v1, v2, q, TT])
 = int2d(Th)(gammaAL * div(uw) * div(v) + UgradV(u, uw, Tw)' * [v1, v2, TT] + UgradV(uw, u, T)'  * [v1, v2, TT]
         + (Grad(uw) : Grad(v)) * nuCurrent
         + c * Tw * v2 + grad(Tw)' * grad(TT) * k - div(uw) * q - div(v) * pw)
 + int2d(Th)(gammaAL * div(u) * div(v) + UgradV(u, u, T)' * [v1, v2, TT]
         + (Grad(u) : Grad(v)) * nuCurrent
         + c * T * v2 + grad(T)' * grad(TT) * k - div(u) * q - div(v) * p)
 + on(1, 2, 3, 4, uw1 = 0, uw2 = 0) + on(2, 4, Tw = 0);
varf vS(p, q) = int2d(Th, qforder = 3)(-1/(gammaAL + nuCurrent) * p * q);

Mat dA(Wh.ndof, intersection, D);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(dA, u1[], inPETSc, inverse = true, exchange = true);
    real[int] out(Wh.ndof);
    out = vPb(0, Wh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(dA, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(dA, u1[], inPETSc, inverse = true, exchange = true);
    dA = vPb(Wh, Wh, tgv = -2);
    return 0;
}
while(nuCurrent > nuFinal) {
    if(adaptation || nu == nuCurrent) {
        Wh [list1, list2, listP, listT] = [1.0, 1.0, 1.0, 2.0];
        set(dA, sparams = "-ksp_monitor -ksp_max_it 100 -ksp_type fgmres -ksp_rtol 1.0e-2 -pc_type fieldsplit -fieldsplit_1_ksp_type gmres -fieldsplit_1_pc_type hypre", fields = list1[]);
        [list1, list2, listP, listT] = [1.0, 1.0, 2.0, 0.0];
        fespace Qh(Th, P1);
        Qh listS;
        listS[]= 1:Qh.ndof;
        Wh [uw1,uw2,pw,Tw] = [0.0, 0.0, listS, 0.0];
        matrix[int] S(1);
        S[0] = vS(Qh, Qh);
        string[int] names(2);
        names[0] = "v";
        names[1] = "p";
        string paramsNS = "-prefix_push fieldsplit_0_ -prefix_push fieldsplit_v_ -pc_type lu -prefix_pop -prefix_push fieldsplit_p_ -ksp_type cg -ksp_max_it 5 -pc_type jacobi -prefix_pop -ksp_type fgmres " + " -ksp_rtol 1.0e-2 -ksp_gmres_restart 200 -prefix_pop";
        set(dA, fieldsplit = 0, sparams = "-fieldsplit_0_ksp_type fgmres -fieldsplit_0_ksp_max_it 100 -fieldsplit_0_ksp_rtol 1.0e-1 -fieldsplit_0_pc_type fieldsplit " + paramsNS, fields = list1[], schurPreconditioner = S, schurList = uw1[], names = names);
    }
    c = -1/(nuCurrent * Pr);
    real[int] xPETSc;
    ChangeNumbering(dA, u1[], xPETSc);
    SNESSolve(dA, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_type newtonls -snes_rtol 1.0e-4");
    ChangeNumbering(dA, u1[], xPETSc, inverse = true, exchange = !adaptation);
    if(adaptation) {
        fespace VhG(ThBackup, Pk);
        VhG def(uG), def(uReduce);
        def(uReduce) = [u1, u2, p, T];
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0)
            ThBackup = adaptmesh(ThBackup, [uGD,uGD], [uG,uGB], ratio = 2.5);
        broadcast(processor(0), ThBackup);
        def(uG) = def(uG);
        Th = ThBackup;
        intersection.resize(0);
        D.resize(0);
        int s = getARGV("-split", 1);
        build(Th, s, intersection, D, Pk, mpiCommWorld)
        Mat dAdapt(Wh.ndof, intersection, D);
        dA = dAdapt;
        [u1, u2, p, T] = def(uG);
    }
    if(!NoGraphicWindow) {
        fespace Vh(Th, P1);
        Vh only = T;
        macro def1(i)i//
        plotMPI(Th, only, P1, def1, real, cmm = "Global temperature for viscosity = " + nuCurrent);
        only = p;
        plotMPI(Th, only, P1, def1, real, cmm = "Global pressure for viscosity = " + nuCurrent);
        fespace Zh(Th, [P2, P2]);
        Zh [onlyU, onlyV] = [u1, u2];
        macro def2(i)[i, i#B]//
        plotMPI(Th, [onlyU, onlyV], [P2, P2], def2, real, cmm = "Global velocity for viscosity = " + nuCurrent);
    }
    nuCurrent = max(nuFinal, nuCurrent/2.0);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

func Pk = P1;                       // finite element space
macro def(u)u//
func Pkdc = P1dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
mesh ThBackup = Th;
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);
Vh b = 100;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

func fu = sqrt((x - 0.5)^2 + (y - 0.5)^2) < 0.4 ? 0.1 : 1.0;
u[] = 0.0;
int step = 3;
real[int] xPETSc;
for(int i = 0; i < step; ++i) {
    xPETSc.resize(0);
    ChangeNumbering(A, u[], xPETSc);
    u[] = vC(0, Vh, tgv = -1);
    real[int] bPETSc, xuPETSc;
    ChangeNumbering(A, u[], bPETSc);
    {
        Vh xu = fu;
        plotMPI(Th, xu, Pk, def, real, cmm = "Upper bound");
        ChangeNumbering(A, xu[], xuPETSc);
    }
    SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, xu = xuPETSc, sparams = "-snes_monitor -snes_max_it " + (i != step - 1 ? 4 : 40) + " -ksp_converged_reason -snes_view -snes_vi_monitor -snes_type vinewtonrsls -snes_rtol 1.0e-6 -pc_type lu");
    if(i != step - 1) {
        ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = false);
        fespace VhG(ThBackup, Pk);
        VhG uG, uReduce;
        uReduce = u;
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
            ThBackup = adaptmesh(ThBackup, uG);
        }
        broadcast(processor(0), ThBackup);
        uG = uG;
        plot(uG, cmm = "Global solution", wait = 1, fill = 1, dim = 3);
        {
            Th = ThBackup;
            Mat Adapt;
            MatCreate(Th, Adapt, Pk);
            A = Adapt;
        }
        u = uG;
        plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
    }
}
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"                // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat<complex> A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int2d(Th)(1i*grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
complex[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<complex> u;                      // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

complex[int] err = A * u[];         // global matrix-vector product
complex[int] transpose = A' * u[];
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, complex, cmm = "Global residual");

set(A, sparams = "-pc_type lu");
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2, P1];             // finite element space

mesh Th;
{
    mesh ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]);    // global mesh
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-pc_type lu");
Wh<real> def(u);

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

macro def2(u)[u, u#B]// EOM
macro def1(u)u// EOM
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]// EOM// vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// two-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];             // finite element space

string deflation = getARGV("-deflation", "geneo");            // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - stokes-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh3 ThBorder, Th = buildlayers(square(1, 1), 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(ThAugmented)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs, eps = -1);
}
ThBorder = buildlayers(square(1, 1), 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_mkl_pardiso_iparm_13 1 --hpddm_schwarz_method oras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 1");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + int2d(Th, fakeInterface)(transmission * ([u, uB, uC]' * [v, vB, vC])) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = y*(0.5-y), uB = 0, uC = 0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

macro def1(u)u// EOM
plotMPI(Th, u, P2, def1, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

Mat A;
MatLoad(A, format = "binary", name = "stokes-mat-binary");
ObjectView(A, format = "info");
real[int, int] rhsView(1, 1);
MatLoad(rhsView, format = "binary", name = "stokes-rhs-binary");
real[int] rhs = rhsView.asarray;
real[int] x(rhs.n);
set(A, sparams = "-pc_type lu");
KSPSolve(A, rhs, x);
ObjectView(A, object = "ksp");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

load "PETSc-complex"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

assert(mpisize == 1);
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space
func real wedge(real a, real b) {
    if(y < 0.4 + 0.1 * 0.75 * x)
        return 2;
    else if(y < 0.8 - 0.2 * 0.75 * x)
        return 1.5;
    else
        return 3;
}
real omega = 2 * pi * 5;
func f = 80 * 100 * exp(-20 * 100 * ((x-0.5)^2 + (y-0.25)^2));

mesh Th = square(getARGV("-global", 30), getARGV("-global", 30));
fespace Ph(Th, P0);
Ph val = wedge(x, y);
Ph k = omega / val;
varf vPb(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, 2)(1i * k * u * v) + on(1, u = 0.0);

fespace Vh(Th, Pk);
Mat<complex> A(Vh.ndof);
A = vPb(Vh, Vh, tgv = -2);
int n = 10;
Vh<complex>[int]  sol(10);
complex[int] eigenvalues(10);
Vh<complex>[int] lsol(10);
Vh<complex>[int] rsol(10);
real[int] singularvalues(10);
int nconv = EPSSolve(A, values = eigenvalues, vectors = sol, sparams = "-eps_target 0 -eps_target_magnitude -eps_converged_reason -st_type sinvert -eps_nev " + n);
eigenvalues.resize(min(nconv, n));
sol.resize(min(nconv, n));
nconv = SVDSolve(A, values = singularvalues, lvectors = lsol, rvectors = rsol, sparams = "-svd_smallest -svd_converged_reason -svd_type lapack");
singularvalues.resize(min(nconv, n));
lsol.resize(min(nconv, n));
rsol.resize(min(nconv, n));
cout << eigenvalues << endl;
cout << singularvalues << endl;
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
include "macro_ddm.idp"

mesh ThNew, Th = square(getARGV("-global", 20), getARGV("-global", 20));
{
    int N = getARGV("-global", 20) / 2.0;
    border a(t=0,1) { x=t;   y=0;   };
    border b(t=0,1) { x=1;   y=t;   };
    border c(t=0,1) { x=1-t; y=1;   };
    border d(t=0,1) { x=0;   y=1-t; };
    ThNew = buildmesh(a(N)+b(N)+c(N)+d(N));
}
macro ThRefinementFactor()getARGV("-first_split", 1)//
macro ThNewRefinementFactor()getARGV("-second_split", 1)//
DmeshCreate(Th);
DmeshCreate(ThNew);
plotDmesh(Th, cmm = "First mesh");
plotDmesh(ThNew, cmm = "Second mesh");
func Pk = P2;
Mat A, B, P;
MatCreate(Th, A, Pk);
MatCreate(ThNew, B, Pk);
MatInterpolate(ThNew, Pk, B, Th, Pk, A, P);

macro grad(u)[dx(u), dy(u)]// EOM
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
fespace Vh(Th, Pk);
A = vPb(Vh, Vh);
Mat ANew;
MatPtAP(A, P, ANew);
ObjectView(A, format = "info");
ObjectView(ANew, format = "info");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "Morley"
include "macro_ddm.idp"
load "PETSc"

real f = 1;

mesh Th = square(40, 40);

fespace Wh(Th, P2);
fespace Vh(Th, P2Morley);

macro bilaplacian(u, v)(dxx(u)*dxx(v) + dyy(u)*dyy(v) + 2.0*dxy(u)*dxy(v))// EOM

varf vPb([u, ux, uy], [v, vx, vy]) = int2d(Th)(bilaplacian(u, v))
                                   + int2d(Th)(f*v)
                                   + on(1, 2, 3, 4, u=0, ux=0, uy=0);

Mat A;
MatCreate(Th, A, P2) // trick => use P2, not P2Morley!
A = vPb(Vh, Vh, tgv = -2);
real[int] rhs = vPb(0, Vh, tgv = -2);
Vh [u, ux, uy];
set(A, sparams = "-pc_type cholesky");
u[] = A^-1 * rhs;

macro def1(i)i// EOM
plotMPI(Th, u , P2, def1, real, wait = 1);
plotMPI(Th, ux, P2, def1, real, wait = 1);
plotMPI(Th, uy, P2, def1, real, wait = 1);

Wh v = u;
real loc = v[].max;
real glob;
mpiAllReduce(loc, glob, mpiCommWorld, mpiMAX);
int err = (abs(glob-0.0012782) > 1.0e-4);
assert(err == 0);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -sizeComm 2 -Dpartitioner=scotch

include "DmeshRedistribute.idp"
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with an axially symmetric potential
// well of finite depth and diameter, on a 2d domain, using SLEPc.
//
// Here, we consider the problem of a 2d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + V(x,y)* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is not known in general. Yet it features few
//  qualitative properties:
//      - the lowest excitations (eigenstates with the lowest eigenvalues)
//        are bound-states (the eigenstate is localized in the well since
//        it asymptotically goes to zero as a exponential)
//        and they are quantized (discrete eigenvalues)
//      - states with higher energies (when the eigenvalue is larger than
//        the depth of the potential well) are called diffusion states.
//        they are not localized (oscillating functions). This part of
//        the spectrum is also called radiative spectrum.
//        In principle, this is a continuous spectrum.
//
//   for the default values of the potential well, there are 11 bound-states
//   before entering the diffusion spectrum.
//
//   Note that here, the bound-states can be degenerate in energy
//
//   See e.g. :
//   - Complement H-I in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//   - Landau & Lifshitz, Volume 3 : (Quantum Mechanics) Chap. III-22
//   - Complement D-VI in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-2d-axial-well-SLEPc.edp \
//        -split 1 -npts 800 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 600) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 80.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 80.0); // Dimension of the domain
//
int nEV    = getARGV("-nev"  ,  20)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real width = getARGV("-width",10.0) ; // Diameter of the axial well
real depth = getARGV("-depth", 2.0) ; // Depth of the square well
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-2d-axial-well-SLEPc.edp "        << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  diameter of the well = " << width            << endl
        << "  depth of the well = " << depth               << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/
macro V(W,D)(0.5*(sqrt(x^2+y^2)-0.5*W < 0.0 ? 0.0 : D)) // End Of Macro

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( 0.5*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
+( V(width,depth)-sigma)*uh*vh               )//  Bilinear form
//  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
//  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
//  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
//  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type cholesky " +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
macro vectorialfe()P1// EOM
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
/*# DiffMacros #*/
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
/*# DiffMacrosEnd #*/
func Pk = [vectorialfe, vectorialfe, vectorialfe];             // finite element space

/*# DDMoptions #*/
string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));
/*# DDMoptionsEnd #*/

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
/*# SchwarzMethod #*/
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh3 ThBorder;
    Th = cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded, 3)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11; // steel
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
/*# SchwarzMethodEnd #*/

/*# OsmTwolevel #*/
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction balanced -hpddm_variant right -hpddm_verbosity 1 -hpddm_geneo_threshold 0.1");
/*# OsmTwolevelEnd #*/

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = 2 * kZero * mu * (2 * mu + lambda) / (lambda + 3 * mu);
        varf vOptimized(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th, fakeInterface)(transmission * (def(u)' * def(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 &&
       isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0, uC = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int2d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

/*# SolvePlot #*/
Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

mpiBarrier(mpiCommWorld);

macro def1(u)u// EOM
plotMPI(Th, u, vectorialfe, def1, real, cmm = "Global solution");
real alpha = 2000.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = err;
plotMPI(Th, u, vectorialfe, def1, real, cmm = "Global residual");
u[] = mpirank;
plotMPI(ThMoved, u, vectorialfe, def1, real, cmm = "Global moved solution");
/*# SolvePlotEnd #*/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

func Pk = P1;                       // finite element space
func Pkdc = P1dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);
Vh b = 1;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, 3, 4, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, 3, 4, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, 3, 4, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

Vh xu;
xu = sqrt((x - 0.5)^2 + (y - 0.5)^2) < 0.4 ? 0.2 : 1.0;
macro def(u)u//
plotMPI(Th, xu, Pk, def, real, cmm = "Upper bound");
real[int] xPETSc, bPETSc, xuPETSc;
u[] = vC(0, Vh, tgv = -1);
ChangeNumbering(A, u[], bPETSc);
ChangeNumbering(A, xu[], xuPETSc);
xPETSc.resize(bPETSc.n);
xPETSc = 0.1;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, xu = xuPETSc, sparams = "-snes_monitor -ksp_converged_reason -snes_view -snes_vi_monitor -snes_type vinewtonrsls -snes_rtol 1.0e-6 -pc_type lu");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]//    // vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// three-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];         // finite element space

string solver;
if(!HasType("MATSOLVER", "mumps") && !HasType("MATSOLVER", "superlu"))
    exit(0);
else
    solver = (HasType("MATSOLVER", "mumps") ? "mumps" : "superlu");

mesh3 Th;
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
real[int] rhs = vPb(0, Wh, tgv = -1);
Wh<real> def(u) = [1.0, 1.0, 1.0, 2.0];
string[int] names(2);
names[0] = "velocity";
names[1] = "pressure";

A = vPb(Wh, Wh, tgv = -1);
set(A, sparams = "-ksp_type fgmres -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_fact_type lower -pc_fieldsplit_detect_saddle_point -fieldsplit_velocity_sub_pc_type lu " + " -fieldsplit_pressure_sub_pc_type lu -fieldsplit_velocity_sub_pc_factor_mat_solver_type " + solver + " -fieldsplit_pressure_sub_pc_factor_mat_solver_type " + solver + " -ksp_monitor -ksp_view " + " -fieldsplit_velocity_ksp_type gmres -fieldsplit_velocity_ksp_max_it 5 -fieldsplit_pressure_ksp_type gmres -fieldsplit_pressure_ksp_max_it 5 -ksp_rtol 1e-6", fields = u[], names = names);
u[] = 0.0;
u[] = A^-1 * rhs;
macro def1(u)u//
plotMPI(Th, u, P2, def1, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

assert(mpisize == 1);
load "PETSc"

real[int, int] B(3, 3);
B = 1e-6;
matrix sp = B;
Mat T(sp);
func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] out(3);
    out[0] = inT[0] - 77.27*(in[1] + in[0]*(1 - 8.375e-6*in[0] - in[1]));
    out[1] = inT[1] - 1/77.27*(in[2] - (1 + in[0])*in[1]);
    out[2] = inT[2] - 0.161*(in[0] - in[2]);
    return out;
}
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    B = [[a - 77.27*((1 - 8.375e-6*in[0] - in[1]) - 8.375e-6*in[0]), -77.27*(1 - in[0]), 0],
         [1/77.27*in[1], a + 1/77.27*(1 + in[0]), -1/77.27],
         [-0.161, 0, a + 0.161]];
    sp = B;
    T = sp;
    return 0;
}
real[int] x(3);
x = [1, 2, 3];
func int funcM(int s, real t, real[int]& u) {
    cout << "step " << s << ", time " << t << ", sol " << u << endl;
}
TSSolve(T, funcJ, funcRes, x, sparams = "-ts_type rosw -ts_max_steps 2000 -ts_max_time 360 -ts_exact_final_time interpolate -ts_max_snes_failures -1 -ts_view -pc_type lu -ts_rtol 1e-3", monitor = funcM);
cout << x << endl;
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM

load "bem"
load "PETSc-complex"
load "msh3"
include "macro_ddm.idp"

if(!HasType("Mat", "Htool")) exit(0);

complex k     = getARGV("-k", 10.0);

// incident wave
real[int] dir = [1,0];
func finc     = exp(1i*k*(dir[0]*x + dir[1]*y));
int n         = 1000;
func Pk       = P1;
func Qk       = P1;

border circle(t=0, 2*pi) { x=cos(t); y=sin(t); z=0; }
meshL ThL = buildmeshL(circle(n));
ThL = OrientNormal(ThL, unbounded = 1);
meshL ThG = ThL;
int[int] n2o;
macro ThLN2O()n2o//

fespace UhL(ThL, Pk);
fespace UhG(ThG, Pk);
varf vk(u, v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("SL",k=k), u, v));
Mat<complex> H, MatT, MatV;
{
macro dimension()3L// EOM
MatCreate(ThL, H, Pk);
MatCreate(ThL, MatT, P0);
MatCreate(ThL, MatV, P1);
}
CoherentGlobalMesh(MatT, MatV, ThL, ThG);
MatDestroy(MatT);
MatDestroy(MatV);
H = vk(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-2", sym = 1);
bool mass = usedARGV("-mass") != -1;
matrix<complex> M;
if(mass) {
    varf vM(u, v) = int1d(ThL)(u * v);
    M = vM(UhL, UhL);
}

varf vRHS(u, v) = -int1d(ThL)(finc*v);

UhL<complex> bf;
bf[] = vRHS(0, UhL);
if(mass) {
    set(H, sparams = "-ksp_view_singularvalues -ksp_converged_reason -ksp_gmres_restart 1000 -pc_type asm", O = M);
}
complex[int] u = H^-1 * bf[];
// visualization
if(!NoGraphicWindow) {
    macro dimension()2// EOM
    int np = 200;
    int R = 4;

    border b1(t=-R, R) { x = t ; y = -R; }
    border b2(t=-R, R) { x = R ; y = t; }
    border b3(t=-R, R) { x = -t; y = R; }
    border b4(t=-R, R) { x = -R; y = -t; }
    border circleout(t=0, 2*pi){x=1.1*cos(t); y=1.1*sin(t); z=0;}

    mesh ThOutG = buildmesh(b1(np) + b2(np) + b3(np) + b4(np) + circleout(-np*pi/R));
    mesh ThOutL = ThOutG;
    int[int] n2o;//
    macro ThOutLN2O()n2o//
    Mat<complex> B;
    MatCreate(ThOutL, B, Qk);
    MatCreate(ThOutL, MatT, P0);
    MatCreate(ThOutL, MatV, P1);
    CoherentGlobalMesh(MatT, MatV, ThOutL, ThOutG);
    MatDestroy(MatT);
    MatDestroy(MatV);
    fespace UhOutG(ThOutG, Qk);
    fespace UhOutL(ThOutL, Qk);
    varf vp(u, v) = int1d(ThG)(POT(BemPotential("SL", k=k), u, v));
    Mat<complex> HPot(B, H);
    HPot = vp(UhG, UhOutG, sparams = "-mat_htool_epsilon 1.0e-4");
    ObjectView(HPot);
    UhOutL<complex> v, vinc;
    vinc = finc;
    v[] = HPot*u;
    v[] += vinc[];
    UhOutL vr = abs(v);
    plotMPI(ThOutL, vr, P1, def, real, cmm = "Global first kind solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4 

/* ################################################################################## */
/*
    Solution of the Blasius boundary layer local spatial stability eigenproblem
    The eigenvalues exported in the "Blasius_EV.dat" file match those in figure 7.3a, Chapter 7, in

    Schmid, Peter & Henningson, Dan. (2001). Stability and Transition in Shear Flows. 10.1007/978-1-4613-0185-1.
*/
/* ################################################################################## */

load "PETSc-complex"

load "msh3"
macro dimension()3L//
include "macro_ddm.idp"

func Pb2 = [P2, P2];
func Pc = [P2, P2, P1];

real ymin = 0.;
real ymax = 15.;
border yline(t=ymin,log(ymax+1)){x=0.;y=exp(t)-1;}
int np = 1000;

meshL thL=buildmeshL(yline(np));
meshL thLzero = thL;
fespace VhC(thL,Pc);
fespace VhBzero(thLzero,Pb2);
VhBzero<complex> [fG1,fG2];

/* ################################################################################## */
/* ######################## Solution of the Blasius equation ######################## */
/* ################################################################################## */
{
    meshL thL2 = thL;
    fespace VhB(thL2,Pb2);
    VhB<complex> [f1, f2];

    varf Resid([u1, u2], [v1, v2]) = int1d(thL2)(
          -dy(f1)*v1 + f2*v1
           +0.5*dy(f2)*f1*v2 - dy(f2)*dy(v2))
    + on(1, u1 = f1-0.)     /*  wall */
    + on(2, u2 = f2-1.)     /*  free stream  */
    + on(1, u2 = f2-0.);    /*  wall */
    varf Jacob([u1, u2], [v1, v2]) = int1d(thL2)(
          -1.*dy(u1)*v1 + u2*v1
           +0.5*dy(f2)*u1*v2 - dy(u2)*dy(v2) +0.5*dy(u2)*f1*v2)
    + on(1, u1 = f1-0.)     /*  wall */
    + on(2, u2 = f2-1.)     /*  free stream  */
    + on(1, u2 = f2-0.);    /*  wall */

    int[int] n2othL2;
    macro thL2N2O()n2othL2//
    Mat<complex> dJ;
    {
        macro def(u)[u, u#B]//EOM
        macro init(i)[i, i]//EOM
        MatCreate(thL2, dJ, Pb2);
    }
    set(dJ, sparams = "-ksp_type preonly -pc_type lu");

    [f1, f2] = [y, 1];

    func complex[int] funcRes(complex[int]& inPETSc) {
        ChangeNumbering(dJ, f1[], inPETSc, inverse = true, exchange = true);
        complex[int] out(VhB.ndof);
        out = Resid(0, VhB, tgv = -1);
        complex[int] outPETSc;
        ChangeNumbering(dJ, out, outPETSc);
        return outPETSc;
    }
    func int funcJ(complex[int]& inPETSc) {
        ChangeNumbering(dJ, f1[], inPETSc, inverse = true, exchange = true);
        dJ = Jacob(VhB, VhB, tgv = -1);
        return 0;
    }

    complex[int] xPETSc;

    ChangeNumbering(dJ, f1[], xPETSc);
    SNESSolve(dJ, funcJ, funcRes, xPETSc, sparams =  "-snes_monitor  -snes_max_it 20 -snes_linesearch_monitor -snes_linesearch_order 2 -snes_atol 1e-10 -snes_rtol 1e-10 -snes_stol 1e-10 -snes_converged_reason");
    ChangeNumbering(dJ, f1[], xPETSc, inverse = true, exchange = true);

    int[int] rest = restrict(VhB, VhBzero, n2othL2);
    f1[].re .*= dJ.D;
    f1[].im .*= dJ.D;
    VhBzero<complex> [fReduce1,fReduce2];
    for[i, v : rest] fReduce1[][v] = f1[][i];
    mpiAllReduce(fReduce1[], fG1[], mpiCommWorld, mpiSUM);

    /* scaling: displacement thickness */
    real Cm = 1.72089;
    [fG1, fG2] = [fG1(x,Cm*y,z), fG2(x,Cm*y,z)];

}

/* ################################################################################## */
/* ########################## Solution of the Eigenproblem ########################## */
/* ################################################################################## */

real Rey = getARGV("-Rey", 1000.);
real omega = getARGV("-omega", 0.26);
real shiftr = getARGV("-shiftr", 0.4);
real shifti = getARGV("-shifti", 0.1);
complex shift = shiftr + 1i*shifti;
int nEV = getARGV("-nEV", 100);
int nKryl = getARGV("-nKryl", 300);

real nu = 1./Rey;

varf A0mat([u1, u2, p], [v1, v2, q]) = int1d(thL)(
    -1i*omega*u1*v1 + nu*(dx(u1)*dx(v1) + dy(u1)*dy(v1)) + dy(fG2)*u2*v1
    -1i*omega*u2*v2 + nu*(dx(u2)*dx(v2) + dy(u2)*dy(v2)) + dy(p)*v2 +
    dy(u2)*q)
+ on(1, u1 = 0., u2 = 0.)                              /*  bot wall */
+ on(2, u1 = 0., u2 = 0.);                             /*  Free-stream */

varf A1mat([u1, u2, p], [v1, v2, q]) = int1d(thL)(
    1i*fG2*u1*v1 + 1i*p*v1 +
    1i*fG2*u2*v2 +
    1i*u1*q)
+ on(1, u1 = 0., u2 = 0.)                              /*  bot wall */
+ on(2, u1 = 0., u2 = 0.);                             /*  Free-stream */

varf A2mat([u1, u2, p], [v1, v2, q]) = int1d(thL)(
    nu*u1*v1 +
    nu*u2*v2)
+ on(1, u1 = 0., u2 = 0.)                              /*  bot wall */
+ on(2, u1 = 0., u2 = 0.);                             /*  Free-stream */

Mat<complex>[int] Apep(3);
macro def(u)[u, u#B, u#C]//EOM
macro init(i)[i, i, i]//EOM
{
    MatCreate(thL, Apep[0], Pc);
    MatCreate(thL, Apep[1], Pc);
    MatCreate(thL, Apep[2], Pc);
}

Apep[2] = A2mat(VhC,VhC,tgv=-1);
Apep[1] = A1mat(VhC,VhC,tgv=-1);
Apep[0] = A0mat(VhC,VhC,tgv=-1);

VhC<complex>[int] def(eigenvecVec)(nEV);
complex[int]  eigvalVec(nEV);
real[int]  errestVec(nEV);  
string PEPParamsbase =
  " -pep_basis monomial " +
  " -pep_general " +
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -pep_monitor_all"      ;

string PEPspar = PEPParamsbase + " -pep_target " + shift +
  " -pep_nev " + nEV       +
  " -pep_ncv " + nKryl + " ";

int nEvalConv = PEPSolve(Apep, vectors = eigenvecVec, values = eigvalVec, sparams = PEPspar, errorestimate = errestVec);

if(mpirank==0){
    cout << "Same output manually" << endl;
    cout <<  "    PEP nconv=" << nEvalConv << " Values (Errors)";
    for(int i=0; i<nEvalConv; i++){
        cout << " " << real(eigvalVec[i]) << "+" << imag(eigvalVec[i]) << "i (" << errestVec[i] << ")";
    }
    cout << endl;
}

if(mpirank == 0) {
    ofstream ofile("Blasius_EV.dat");
    ofile.precision(16);
    ofile << eigvalVec << endl;
}

/* ------------------------------------------------------------ */
/*                same problem solution with EPS                */
/* ------------------------------------------------------------ */
 
Mat<complex> dA, dB;

/* -1 factor for the companion matrix */
Apep[0] *= -1;
Apep[1] *= -1;

{
    matrix<complex> Id = eye(VhC.ndof);
    Mat<complex> IMat(Apep[0], Id);
    Mat<complex> dAux;
    dAux = [[IMat, 0],
            [0, Apep[2]]];
    MatConvert(dAux, dB);
    dAux = [[0, IMat],
            [Apep[0], Apep[1]]];
    MatConvert(dAux, dA); 
}

VhC<complex>[int] def(eigenvecCompVec)(nEV);
complex[int]  eigvalCompVec(nEV);  
real[int]  errestCompVec(nEV);  

string EPSParamsbase =            
  " -eps_type krylovschur" +
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_monitor_all"      +
  " -eps_gen_non_hermitian ";

string EPSpar = EPSParamsbase + " -eps_target " + shift +    
  " -eps_nev " + nEV       + 
  " -eps_ncv " + nKryl 	   + " "; 


int nEvalCompConv = EPSSolve(dA, dB, vectors = eigenvecCompVec, values = eigvalCompVec, sparams = EPSpar, errorestimate = errestCompVec); 

if(mpirank==0){
    cout << "Same output manually" << endl;
    cout <<  "    EPS nconv=" << nEvalCompConv << " Values (Errors)";
    for(int i=0; i<nEvalCompConv; i++){
        cout << " " << real(eigvalCompVec[i]) << "+" << imag(eigvalCompVec[i]) << "i (" << errestCompVec[i] << ")";
    }
    cout << endl;
}

//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -freq 1e+9

load "bem"
load "PETSc-complex"
macro dimension()3S// EOM
include "macro_ddm.idp"
include "cobrameshcavity.idp"

if(!HasType("Mat", "Htool")) exit(0);

real sec1   = 0.01;
real angle  = 2*pi*35/360;
real radius = 0.186;
real sec2   = 0.08;
real sec3   = 0.1;
real height = 0.084;
real width  = 0.11;

int npangler = 4;
int npangleR = radius/(radius-height)*npangler;

real c0     = 299792458;
real f      = getARGV("-freq", 3.0e+9);
complex k   = 2*pi*f/c0;
real lambda = c0/f;
real distx  = 0.2*lambda;
real disty  = distx;
real distz  = distx;

int labextxm    = 11, labextxM = 12, labextym = 13, labextyM = 14, labextzm = 15, labextzM = 16;
int regint      = 4, regext = 5;
int labtomerge  = 7;
int labmetal    = 1;
int labi        = 2; // label in: entrance n = (-1,0,0)
int labo        = labmetal; // label out

// incident wave
real[int] dir   = [1,0,0];
func finc       = exp(1i*k*(dir[0]*x + dir[1]*y + dir[2]*z));
int nloc        = 10.0*sec3/lambda;

meshS ThS, ThG;
fespace Uh(ThS, P1);
fespace UhG(ThG, P1);
varf vk(u, v) = int2dx2d(ThG)(ThG)(BEM(BemKernel("SL", k=k), u, v));
Mat<complex> H;
{
    mesh3 Th3;
    buildcobramesh(Th3);
    Th3 = buildBdMesh(Th3);

    ThS = Th3.Gamma;
    ThS = trunc(ThS, region == labmetal);
    ThG = ThS;
    int[int] n2o;
    macro ThSN2O()n2o//
    MatCreate(ThS, H, P1);
    Mat<complex> T;
    MatCreate(ThS, T, P0);
    CoherentGlobalMesh(T, H, ThS, ThG);
}
H = vk(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-4");
plotDmesh(ThS, cmm = "Partitioning");
bool mass = usedARGV("-mass") != -1;
matrix<complex> M;
if(mass) {
    varf vM(u, v) = int2d(ThS)(u * v);
    M = vM(Uh, Uh);
}

varf vRHS(u, v) = -int2d(ThS)(finc*v);

Uh<complex> bf;
bf[] = vRHS(0, Uh);
if(mass) {
    set(H, sparams = "-ksp_type fgmres -ksp_view_singularvalues -ksp_converged_reason -ksp_gmres_restart 1000 -pc_type asm", O = M);
}
complex[int] u = H^-1 * bf[];
// visualization
if(!NoGraphicWindow) {
    distx = 2*lambda;
    disty = distx;
    distz = distx;

    int np = 100;
    meshS ThOutG = square3(np,np,
                         [(sec1+(radius-height)*sin(angle)+sec2*cos(angle)+radius*sin(angle)+sec3+2*distx)*x-distx,
                          (height+disty-((radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty))*y
                          +(radius-height)*cos(angle)-(radius-height)-sec2*sin(angle)-radius+radius*cos(angle)-disty,
                          width/2]);
    meshS ThOutS = ThOutG;
    int[int] n2o;//
    macro ThOutSN2O()n2o//
    Mat<complex> B, T;
    MatCreate(ThOutS, B, P1);
    MatCreate(ThOutS, T, P0);
    CoherentGlobalMesh(T, B, ThOutS, ThOutG);
    MatDestroy(T);
    fespace UhOutG(ThOutG, P1);
    fespace UhOutS(ThOutS, P1);
    varf vp(u, v) = int2d(ThS)(POT(BemPotential("SL", k=k), u, v));
    Mat<complex> HPot(B, H);
    HPot = vp(UhG, UhOutG, sparams = "-mat_htool_epsilon 1.0e-4");
    ObjectView(HPot, format = "ascii_info_detail");
    UhOutS<complex> v, vinc;
    vinc = finc;
    v[] = HPot*u;
    v[] += vinc[];
    UhOutS vr = real(v);
    plotMPI(ThOutS, vr, P1, def, real, cmm = "Global first kind solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2//
include "macro_ddm.idp"

macro def(i)i// EOM
macro init(i)i// EOM
func Pk = P2;
macro grad(u)[dx(u), dy(u)]// EOM

mesh ThNo, Th = square(getARGV("-global", 20), getARGV("-global", 20), [1 + x, y]);
fespace Vh(Th, Pk);
Mat H;
MatCreate(Th, H, Pk);
{
    fespace Ph(Th, P0);
    Ph part;
    PartitionCreate(Th, part[], P0);
    ThNo = trunc(Th, abs(part - 1.0) < 1e-1);
}
func g = cos(pi*x)*cos(pi*y);
func real J(real[int]& X) {
    Vh u;
    ChangeNumbering(H, u[], X, inverse = true, exchange = true);
    real glob, loc = int2d(ThNo)(sqrt(1 + grad(u)'*grad(u)));
    mpiAllReduce(loc, glob, mpiCommWorld, mpiSUM);
    return glob;
}

func real[int] DJ(real[int]& X) {
    Vh u;
    ChangeNumbering(H, u[], X, inverse = true, exchange = true);
    varf vG(w, v) = int2d(Th)((grad(u)'*grad(v)) / sqrt(1 + grad(u)'*grad(u)));
    real[int] out = vG(0, Vh);
    real[int] outPETSc;
    ChangeNumbering(H, out, outPETSc);
    return outPETSc;
}

func int HJ(real[int]& X) {
    Vh u;
    ChangeNumbering(H, u[], X, inverse = true, exchange = true);
    varf vH(v, w) = int2d(Th)((grad(w)'*grad(v)) / sqrt(1 + grad(u)'*grad(u))
            - (grad(w)'*grad(u)) * (grad(v)'*grad(u)) *(1 + grad(u)'*grad(u))^-1.5);
    matrix Loc = vH(Vh, Vh);
    H = Loc;
    return 0;
}
varf onGamma(u, v) = on(1, 2, 3, 4, u = 1);
Vh onG;
onG[] = onGamma(0, Vh, tgv = 1);
real[int] lbPETSc, ubPETSc;
{
    Vh lb = onG != 0 ? g : -1e19;
    Vh ub = onG != 0 ? g :  1e19;
    lb = max(lb, 3-100*(((x-1.5)^2 + (y-0.5)^2))^2);
    ChangeNumbering(H, lb[], lbPETSc);
    ChangeNumbering(H, ub[], ubPETSc);
}

{
    Vh u = onG != 0 ? g : 0;
    real[int] uPETSc;
    ChangeNumbering(H, u[], uPETSc);
    TaoSolve(H, J, DJ, uPETSc, xl = lbPETSc, xu = ubPETSc, sparams = "-tao_monitor -tao_view -tao_type bqnls -tao_max_it 40 -tao_gatol 1e-4");
    ChangeNumbering(H, u[], uPETSc, inverse = true, exchange = true);
    real Ju = J(uPETSc);
    plotMPI(Th, u, Pk, def, real, cmm = "Global solution, J(u) = " + Ju);
}
{
    Vh u = onG != 0 ? g : 0;
    real[int] uPETSc;
    ChangeNumbering(H, u[], uPETSc);
    TaoSolve(H, J, DJ, uPETSc, xl = lbPETSc, xu = ubPETSc, sparams = "-tao_monitor -tao_view -tao_type bnls -tao_max_it 40 -tao_gatol 1e-4", HessianRoutine = HJ);
    ChangeNumbering(H, u[], uPETSc, inverse = true, exchange = true);
    real Ju = J(uPETSc);
    plotMPI(Th, u, Pk, def, real, cmm = "Global solution, J(u) = " + Ju);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM

load "msh3"
load "bem"
load "PETSc-complex"
include "macro_ddm.idp"

if(!HasType("Mat", "Htool")) exit(0);

complex k     = getARGV("-k", 10.0);

// incident wave
real[int] dir = [1,0];
func finc     = exp(1i*k*(dir[0]*x + dir[1]*y));
int n         = 1000;

border circle(t=0, 2*pi) { x=cos(t); y=sin(t); z=0; }
meshL ThG, ThL = buildmeshL(circle(n));
ThL = OrientNormal(ThL, unbounded = 1);
ThG = ThL;
int[int] n2o;
macro ThLN2O()n2o//
Mat<complex> A;
{
    macro dimension()3L// EOM
    MatCreate(ThL, A, P1);
    Mat<complex> T;
    MatCreate(ThL, T, P0);
    CoherentGlobalMesh(T, A, ThL, ThG);
}

fespace Uh(ThL, P1);
fespace UhG(ThG, P1);
varf vk(u, v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("SL", k=k), u, v));
A = vk(UhG, UhG);

varf vRHS(u, v) = -int1d(ThL)(finc*v);
Uh<complex> b, u;
b[] = vRHS(0, Uh);
Mat<complex> E, D;
MatConvert(A, E);
MatConvert(E, D);
set(D, sparams = "-ksp_view -ksp_monitor -pc_type cholesky");
ObjectView(D, format = "info");
complex[int] uP, bP;
ChangeNumbering(A, b[], bP);
uP.resize(bP.n);
KSPSolve(D, bP, uP);
ChangeNumbering(A, u[], uP, inverse = true, exchange = true);
// visualization
if(!NoGraphicWindow) {
    macro dimension()2// EOM
    int np = 200;
    int R = 4;

    border b1(t=-R, R) { x = t ; y = -R; }
    border b2(t=-R, R) { x = R ; y = t; }
    border b3(t=-R, R) { x = -t; y = R; }
    border b4(t=-R, R) { x = -R; y = -t; }

    mesh ThOutG, ThOutL = buildmesh(b1(np) + b2(np) + b3(np) + b4(np) + circle(-np*pi/R));
    fespace UhOut(ThOutL, P1);
    int[int] n2o;//
    macro ThOutLN2O()n2o//
    Mat<complex> B, T;
    ThOutG = ThOutL;
    MatCreate(ThOutL, B, P1);
    MatCreate(ThOutL, T, P0);
    CoherentGlobalMesh(T, B, ThOutL, ThOutG);
    MatDestroy(T);
    varf vp(u, v) = int1d(ThL)(POT(BemPotential("SL", k=k), u, v));
    Mat<complex> HPot(B, A);
    fespace UhOutG(ThOutG, P1);
    HPot = vp(UhG, UhOutG);
    UhOut<complex> v, vinc;
    vinc = finc;
    v[] = HPot*u[];
    v[] += vinc[];
    UhOut vr = abs(v);
    plotMPI(ThOutL, vr, P1, def, real, cmm = "Global first kind solution");
}
//ff-mpirun -np 4 Helmholtz-2d-FEM-BEM-coupling-PETSc-composite.edp -wg

/* example of wave guiding with gradient-index lenses */

load "bem"
load "msh3"
load "PETSc-complex"

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int[int] nsl(10); // number of lenses
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

// Fem mesh :
mesh Th = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l)+circle(nsl));

plot(Th, wait=1, dim=2, cmm="FEM mesh Th");

int[int] lab = [interface];
meshL ThL = extract(Th, label=lab); // BEM mesh
ThL = OrientNormal(ThL,unbounded=1); // BEM mesh

plot(ThL, wait=1, dim=2, cmm="BEM mesh ThL");

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1; 
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);
reg = region;

func ind = reg == -1 ? 1 : 2./(1+((x-nsx[max(0.,reg-1)])^2+(y-nsy[max(0.,reg-1)])^2)); // gradient index in lenses

fespace Uh(Th,P1);
fespace UhL(ThL,P1);
fespace Ch=Uh*UhL;

macro Grad(u) [dx(u),dy(u)] // EOM

/* the coupled problem we want to solve is :
(  F     TDL ) (ufem) = (Frhs)
(  mass  -SL ) (ubem)   ( 0  ) */

Uh<complex> ufem,v1;
UhL<complex> ubem,v2;

// problem formulation
varf vfLenses(<[ufem],[ubem]>,<[v1],[v2]>) =
                                int2d(Th)(-ind*k^2*ufem*v1 + Grad(ufem)'*Grad(v1)) // F
                              + int1dx1d(ThL)(ThL)(BEM(BemKernel("TDL",k=k),ubem,v1)) + int1d(ThL)(0.5*ubem*v1) // TDL
                              + int1d(ThL)(ufem*v2)                        // mass
                              + int1dx1d(ThL)(ThL)(BEM(-1*BemKernel("SL",k=k),ubem,v2))  // -SL
                              + int2d(Th)(finc*v1) + on(waveguide,ufem=0) ; // RHS

// the linear system is assembled in parallel ; the distributed matrix is then passed to PETSc as a nested Mat (MatNest)
Mat<complex> HC = vfLenses(Ch,Ch);
complex[int] rhs = vfLenses(0,Ch);

// example of fieldsplit preconditioner ; the fields are automatically deduced from the composite FE space Ch
set(HC,sparams="-ksp_view -ksp_monitor -ksp_type fgmres -ksp_view_final_residual -ksp_gmres_restart 200 -pc_type fieldsplit -fieldsplit_0_pc_type lu -fieldsplit_0_pc_mat_solver_type mumps "+"-fieldsplit_1_ksp_type gmres -fieldsplit_1_ksp_max_it 20");

complex[int] u = HC^-1*rhs;

[ufem[],ubem[]] = u; // dispatch solution

plot(ufem, fill=1, value=1, wait=1, dim=2, cmm="FEM solution");
plot(ubem, fill=1, value=1, wait=1, dim=2, cmm="BEM ansatz on ThL");

// output mesh for visualization
int np = 200/2;
real R = 20;
real rr = 20;

border b1(t=-rr, R){x=t; y=-rr;}
border b2(t=-rr, rr){x=R; y=t;}
border b3(t=R, -rr){x=t; y=rr;}
border b4(t=rr, -rr){x=-rr; y=t;}

nsl = -nsl;
// exterior mesh
mesh ThOut = buildmesh(b1(np*R/rr)+b2(np)+b3(np*R/rr)+b4(np)+circle(nsl)
              +a(-nloc*(2*L+2*dd))+b(-nloc*(2*l+2*dd))+c(-nloc*(2*L+2*dd))+d(-nloc*(2*l+2*dd)));

fespace UhOut(ThOut,P1);

varf vp(u,v)=int1d(ThL)(POT(BemPotential("SL",k=k),u,v));
HMatrix<complex> B = vp(UhL,UhOut);
if (mpirank == 0) cout << B.infos << endl;

UhOut<complex> uext;

uext[] = B*ubem[];

plot(ufem, uext, dim=2, fill=1, value=1, nbiso=40, cmm="u");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - helmholtz-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

func real wedge(real a, real b) {
    if(y < 0.4 + 0.1 * 0.75 * x)
        return 2.0;
    else if(y < 0.8 - 0.2 * 0.75 * x)
        return 1.5;
    else
        return 3.0;
}
real omega = 2 * pi * 5;
func f = 80 * 100 * s * exp(-20 * 100 * s * ((x-0.5)^2 + (y-0.25)^2));
complex[int] rhs;                           // local right-hand side
matrix<complex> Mat;                        // local operator
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    fespace PhAugmented(ThAugmented, P0);
    PhAugmented val = wedge(x, y);
    PhAugmented k = omega / val;
    varf vPb(u, v) = int2d(ThAugmented)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(ThAugmented, 2)(1i * k * u * v) + int2d(ThAugmented)(f * v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    complex[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz<complex> A(Mat, intersection, D, scaled = false);

matrix<complex> Opt;                        // local operator with optimized boundary conditions
pair<complex> ret;
{
    int solver = getOption("schwarz_method");
    fespace Ph(Th, P0);
    Ph val = wedge(x, y);
    Ph k = omega / val;
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        varf vOptimized(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, 2)(1i * k * u * v) + int2d(Th)(f * v) + int1d(Th, fakeInterface)(1i *  k * u * v) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(-k^2 * u * v + (grad(u)' * grad(v))) + int1d(Th, 2)(1i * k * u * v) + int2d(Th)(f * v) + on(1, u = 0.0);
            matrix<complex> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<complex> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<complex> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

complex[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, complex, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, complex, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

int[int] n2oSaved;
int[int] n2oLoaded;
{
    macro dimension()3//
    include "macro_ddm.idp"
    mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z]);
    Mat A;
    macro ThN2O()n2oSaved//
    MatCreate(Th, A, P1);
    DmeshSave(Th, "dump-3d");
}
{
    macro dimension()2//
    include "macro_ddm.idp"
    mesh Th = square(40, 40);
    Mat A;
    MatCreate(Th, A, P1);
    DmeshSave(Th, "dump-2d");
}
{
    macro dimension()3//
    include "macro_ddm.idp"
    mesh3 Th;
    Mat A;
    macro ThN2O()n2oLoaded//
    DmeshLoad(Th, "dump-3d");
    MatCreate(Th, A, P2);
}
{
    macro dimension()2//
    include "macro_ddm.idp"
    mesh Th;
    Mat A;
    DmeshLoad(Th, "dump-2d");
    MatCreate(Th, A, P0);
}
if(mpisize > 1) {
    n2oLoaded -= n2oSaved;
    assert(n2oLoaded.linfty < 1.0e-12);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

int[int] I(1), J(1);
I(0) = 0;
J(0) = 0;

if(mpisize != 4)
    exit(1);

int[int] Ji;
matrix[int] Ai(0);
if(mpirank == 0) {
    Ji.resize(2);
    Ai.resize(2);
    Ji[0] = 0; Ji[1] = 2;
    real[int] C(1);
    C(0) = 10.0;
    Ai[0] = [I, J, C];
    C(0) = 2.0;
    Ai[1] = [I, J, C];
}
else if(mpirank == 1) {
    Ji.resize(2);
    Ai.resize(2);
    Ji[0] = 1; Ji[1] = 2;
    real[int] C(1);
    C(0) = -10.0;
    Ai[0] = [I, J, C];
    C(0) = 3.0;
    Ai[1] = [I, J, C];
}
else if(mpirank == 2) {
    Ji.resize(2);
    Ai.resize(2);
    Ji[0] = 0; Ji[1] = 2;
    real[int] C(1);
    C(0) = -1.0;
    Ai[0] = [I, J, C];
    C(0) = 5.0;
    Ai[1] = [I, J, C];
}
else if(mpirank == 3) {
    Ji.resize(1);
    Ai.resize(1);
    Ji[0] = 3;
    real[int] C(1);
    C(0) = 7.0;
    Ai[0] = [I, J, C];
}
Mat A(Ai, columns = Ji);
real[int] x(1), b(1);
b = (mpirank + 1) * 10;
x = A^-1 * b;
for(int i = 0; i < mpisize; ++i) { mpiBarrier(mpiCommWorld); if(i == mpirank) cout << "rhs on process #" << mpirank << ": " << b[0] << ", solution: " << x[0] << endl; mpiBarrier(mpiCommWorld); }
real[int] y(1);
y = A * x;
for(int i = 0; i < mpisize; ++i) { mpiBarrier(mpiCommWorld); if(i == mpirank) cout << "A * x on process #" << mpirank << ": " << y[0] << ", rhs: " << b[0] << endl; mpiBarrier(mpiCommWorld); }
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
macro vectorialfe()P2// EOM
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [vectorialfe, vectorialfe];                 // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - elasticity-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);              // local finite element space
int[int][int] intersection(0);   // local-to-neighbors renumbering
real[int] D;                     // partition of unity
{
    int[int] l = [2, 1, 2, 2];
    mesh ThBorder;
    Th = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l);    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded, 2)
}

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
matrix<real> Mat;                           // local operator
varf vPb(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
Mat = vPb(Wh, Wh, sym = 1);
real[int] rhs = vPb(0, Wh);

schwarz A(Mat, intersection, D);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = 2 * kZero * mu * (2 * mu + lambda) / (lambda + 3 * mu);
        varf vOptimized(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int1d(Th, fakeInterface)(transmission * (def(u)' * def(v))) + on(1, u = 0.0, uB = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + on(1, u = 0.0, uB = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
u[] = err;
macro def1(u)u// EOM
plotMPI(Th, u, vectorialfe, def1, real, cmm = "Global residual");
real alpha = 1.0e+1;
mesh ThMoved = movemesh(Th, [x + alpha * u, y + alpha * uB]);
u[] = mpirank;
plotMPI(ThMoved, u, vectorialfe, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2//
include "macro_ddm.idp"
mesh Th = square(80, 80);

Mat A;
func Pk = P2;

{
    fespace Ph(Th, P0);
    Ph reg = (x-0.5)^2 + (y-0.5)^2 < 0.1 ? 2 : 1;
    plot(reg, wait = 1, value = 1, fill = 1);
    Th = change(Th, fregion = reg[][nuTriangle]);
    real[int] part(Ph.ndof);
    {
        Ph cond = region == 1;

        int[int] new2oldCond(1), new2oldNoCond(1);

        mesh ThCond = trunc(Th, abs(cond) > 0.01, new2old = new2oldCond);
        mesh ThNoCond = trunc(Th, abs(cond) < 0.01, new2old = new2oldNoCond);

        fespace PhCond(ThCond, P0);
        fespace PhNoCond(ThNoCond, P0);

        real[int] partCond(PhCond.ndof);
        real[int] partNoCond(PhNoCond.ndof);

        if(mpirank == 0) {
            partitionerSeq(partCond, ThCond, mpisize);
            partitionerSeq(partNoCond, ThNoCond, mpisize);
        }
        partitionerPar(partCond, ThGlCond, mpiCommWorld, mpisize);
        partitionerPar(partNoCond, ThGlNoCond, mpiCommWorld, mpisize);

        for[i, v : partCond]   part[new2oldCond[i]] = v;
        for[i, v : partNoCond] part[new2oldNoCond[i]] = v;

    }
    macro ThUserPartitioning()part// EOM
    DmeshCreate(Th);
    MatCreate(Th, A, Pk);
}

fespace Ph(Th, P0);
Ph cond = region == 2;
int[int] n2o;
mesh ThCond = trunc(Th, abs(cond), new2old = n2o, label = 5);
fespace Vh(Th, Pk);
fespace VhCond(ThCond, Pk);
matrix R;
int[int] restCond = restrict(VhCond, Vh, n2o);
{
    int[int] I = 0:restCond.n - 1;
    real[int] C(I.n);
    C = 1;
    R = [I, restCond, C];
    R.resize(VhCond.ndof, Vh.ndof);
}
Mat B(A, restriction = R);
varf vPb(u, v) = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(Th)(v) + on(1,2,3,4, u=0);
VhCond g;
varf vPbCond(u, v) = int2d(ThCond)(dx(u)*dx(v) + dy(u)*dy(v)) + int2d(ThCond)(10*v) + on(5, u=10*g);
A = vPb(Vh, Vh, tgv = -2);
B = vPbCond(VhCond, VhCond, tgv = -1);
set(A, sparams = "-pc_type hypre -ksp_converged_reason");
set(B, sparams = "-pc_type hypre -ksp_converged_reason");
Vh u;
real[int] rhs = vPb(0, Vh, tgv = -2);
u[] = A^-1 * rhs;
g[] = u[](restCond);
// g[] = R * u[];
// the two lines above are strictly equivalent! I prefer line 71 because you can see that it's just
// a matter of picking up the correct indices to restrict u into g
real[int] rhsCond = vPbCond(0, VhCond, tgv = -1);
VhCond uCond;
uCond[] = B^-1 * rhsCond;
macro params()cmm = "Solution", wait = 1, dim = 3, value = 1//
plotD(Th, u, params);
plotD(ThCond, uCond, params);
u[] = 0;
u[](restCond) = uCond[];
// u[] = R' * uCond[];
// the two lines above are strictly equivalent! I prefer line 82 because you can see that it's just
// a matter of picking up the correct indices to prolong uCond into u
plotD(Th, u, params);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2, P1];             // finite element space

string deflation = getARGV("-deflation", "geneo");            // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - stokes-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    mesh ThGlobal = square(getARGV("-global", 30), getARGV("-global", 30), [x, y]);    // global mesh
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    varf vPb([u, uB, p], [v, vB, q]) = int2d(ThAugmented)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented);
    real[int] rhsFull = vPb(0, WhAugmented);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs, eps = -1);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_mkl_pardiso_iparm_13 1 -hpddm_schwarz_method oras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 1");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + int1d(Th, fakeInterface)(transmission * ([u, uB]' * [v, vB])) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
        Opt = vOptimized(Wh, Wh);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

macro def2(u)[u, u#B]// EOM
macro def1(u)u// EOM
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure");
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with square potential of finite depth
// and width, on a pseudo-1d domain, using SLEPc.
//
// Here, we consider the problem of a 1d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + V(x)* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is not known in general. Yet it features few
//  qualitative properties:
//      - the lowest excitations (eigenstates with the lowest eigenvalues)
//        are bound-states (the eigenstate is localized in the well since
//        it asymptotically goes to zero as a exponential)
//        and they are quantized (discrete eigenvalues)
//      - states with higher energies (when the eigenvalue is larger than
//        the depth of the potential well) are called diffusion states.
//        they are not localized (oscillating functions). This part of
//        the spectrum is also called radiative spectrum.
//        In principle, this is a continuous spectrum.
//
//   for the default values of the potential well, there are 5 bound-states
//   before entering the diffusion spectrum.
//
//   See e.g. :
//   - Complement H-I in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//   - Landau & Lifshitz, Volume 3 : (Quantum Mechanics) Chap. III-22
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-1d-square-well-SLEPc.edp \
//        -split 1 -npts 400 -nev 10 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 400) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 80.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 1)   ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real width = getARGV("-width",10.0) ; // Width of the square well
real depth = getARGV("-depth", 2.0) ; // Depth of the square well
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-1d-square-well-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  width of the well = " << width               << endl
        << "  depth of the well = " << depth               << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space
//fespace Vh(Th,Pk,periodic=[[Labels[0],x],[Labels[2],x]]); // Periodic does not work

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts); // pts on the x-axis sides
    int Ypts= 1;             // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/
macro V(W,D)(0.5*(abs(x)-0.5*W < 0.0 ? 0.0 : D)) // End Of Macro

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= intN(Th)        //  Definion of  the problem
( 0.5*dx(uh)*dx(vh)
  +1000*dy(uh)*dy(vh)   // cheat for pseudo-1d since periodic does not work
  //  ( 0.5*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
  +( V(width,depth)-sigma)*uh*vh               )//  Bilinear form
  //  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
  //  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
  //  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
  //  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= intN(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D, clean = true);
Mat DistB(DistA, B, clean = true);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

int s = getARGV("-split", 8);       // refinement factor

border aa(t=0,1) { x=t;   y=0;   label=1; };
border bb(t=0,1) { x=1;   y=t;   label=2; };
border cc(t=0,1) { x=1-t; y=1;   label=3; };
border dd(t=0,1) { x=0;   y=1-t; label=4; };

mesh Th, ThCoarse = buildmesh(aa(getARGV("-global", 20)) + bb(getARGV("-global", 20)) + cc(getARGV("-global", 20)) + dd(getARGV("-global", 20)));
fespace Wh(Th, Pk);                 // local finite element space
real[int] part;
fespace PhCoarse(ThCoarse, P0);
PhCoarse partCoarse;
if(mpirank == 0)
    partitionerSeq(partCoarse[], ThCoarse, mpisize);
partitionerPar(partCoarse[], ThCoarse, mpiCommWorld, mpisize);
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = trunc(ThCoarse, 1, split = s);
    fespace Ph(Th, P0);
    Ph part;
    part = partCoarse;
    buildWithPartitioning(Th, part[], 1, intersection, D, Pk, mpiCommWorld);
}

varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, sym = 1);
fespace WhCoarse(ThCoarse, Pk);
matrix MatCoarse;
{
    mesh ThBackup = Th;
    Th = ThCoarse;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    Th = ThBackup;
}
set(MatCoarse, solver = sparsesolverSym, sym = 1);
matrix R = interpolate(Wh, WhCoarse);
real[int] rhs = vPb(0, Wh);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_verbosity " + (!mpirank ? "3" : "0") + "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_variant flexible");
func real[int] correctionExact(real[int]& in) {
    real[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    in .*= D;
    tmp = R' * in;
    mpiAllReduce(tmp, tmpReduced, mpiCommWorld, mpiSUM);
    tmp = MatCoarse^-1 * tmpReduced;
    out = R * tmp;
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionExact);
}

Wh<real> def(u);    // local solution
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution with a redundant coarse correction");

int[int][int] intersectionCoarse;
real[int] DCoarse;
{
    buildWithPartitioning(ThCoarse, partCoarse[], 1, intersectionCoarse, DCoarse, Pk, mpiCommWorld);
    mesh ThBackup = Th;
    Th = ThCoarse;
    MatCoarse = vPb(Wh, Wh, sym = 1);
    Th = ThBackup;
}
matrix NeumannCoarse = MatCoarse;
R = interpolate(Wh, WhCoarse);
schwarz ACoarse(MatCoarse, intersectionCoarse, DCoarse);
set(A, sparams = "-hpddm_variant flexible -hpddm_verbosity " + (!mpirank ? "3" : "0"));
set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_level_2_schwarz_method ras -hpddm_level_2_tol 1e-10", prefix = "level_2_");
macro mplot()wait = 1, cmm = "Transfers on the correction at iteration " + ijk//
int ijk = 1;
func real[int] correctionInexact(real[int]& in) {
    real[int] out(in.n), tmp(WhCoarse.ndof), tmpReduced(WhCoarse.ndof);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        Wh outW;
        outW[] = in;
        plotMPI(Th, outW, Pk, def, real, mplot);
    }
    tmpReduced = R' * in;
    exchange(ACoarse, tmpReduced, scaled = true);
    if(!NoGraphicWindow && ijk > 0 && ijk < 10) {
        WhCoarse outWCoarse;
        outWCoarse[] = tmpReduced;
        plotMPI(ThCoarse, outWCoarse, Pk, def, real, mplot);
        ++ijk;
    }
    tmp = ACoarse^-1 * tmpReduced;
    out = R * tmp;
    exchange(A, out);
    return out;
}
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) // two-level Schwarz methods
    AttachCoarseOperator(mpiCommWorld, A, correctionInexact);
else
    exit(0);

u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution with a one-level inner coarse correction (two levels in total)");

set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "4" : "0") + " -hpddm_level_2_schwarz_coarse_correction deflated -hpddm_level_2_geneo_nu 10");
AttachCoarseOperator(mpiCommWorld, ACoarse, A = NeumannCoarse);
set(ACoarse, sparams = "-hpddm_level_2_verbosity " + (!mpirank ? "1" : "0") + " -hpddm_level_3_verbosity 0");

ijk = 0;
u[] = 0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution with a two-level inner coarse correction (three levels in total)");

statistics(A);
statistics(ACoarse);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4
// PARAM -DCartesianPartitioning=1

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro simple2d(Ph, function, comm, deltaX, deltaY)
    Ph xx = x / deltaX, yy = y / deltaY;
    int i = int(sqrt(mpiSize(comm)));
    while(mpiSize(comm) % i != 0)
        --i;
    int j = mpiSize(comm) / i;
    function = int(j * xx) + int(i * yy) * j;// EOM

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

mesh Th = square(getARGV("-global", 13), getARGV("-global", 13)); // global mesh
Mat A;
fespace Ph(Th, P0);
IFMACRO(!CartesianPartitioning)
Ph part;
{
    simple2d(Ph, part, mpiCommWorld, 1.0, 1.0)
    plot(part, fill = 1, wait = 1);
}
macro ThUserPartitioning()part[]// EOM
ENDIFMACRO
IFMACRO(CartesianPartitioning)
macro ThCartesianPartitioning()// EOM
ENDIFMACRO

DmeshCreate(Th);
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
real[int] rhs = vPb(0, Wh, tgv = -2);
matrix unassembled(Wh.ndof);
Wh<real> u;                         // local solution
A = vPb(Wh, Wh, sym = 0, tgv = -2);
set(A, sparams = "-pc_type asm -sub_pc_type cholesky", O = unassembled);
Mat[int] Q(1);
Mat[int] Z(1);
{
    Mat P(Wh.ndof, communicator = mpiCommSelf);
    Q[0] = P;
    matrix one(Wh.ndof, 1);
    for(int i = 0; i < Wh.ndof; ++i) one(i, 0) = 1.0;
    Mat Wn(one, communicator = mpiCommSelf);
    Z[0] = Wn;
}
set(Q, Z, parent = A, sparams = "-custom_sub_" + mpirank + "_pc_type mg -custom_sub_0_ksp_converged_reason", prefix = "custom_sub_" + mpirank + "_");
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P1;                               // finite element space

macro ThRefinementFactor()getARGV("-split", 1)//
int[int] l = [1, 2, 2, 2];
mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);
fespace Wh(Th, Pk);           // local finite element space
Mat T;
MatCreate(Th, T, Pk);

real[int] rhs(Wh.ndof);                     // local right-hand side
matrix<real> Loc;                           // local operator
{                                           // local weak form
    fespace Ph(Th, P0);
    Ph kappa = x < 0.25 ? 10.0 : 1.0;
    varf vPb(u, v) = int2d(Th)(-1.0 * kappa * grad(u)' * grad(v)) + on(1, u = 0.0);
    Loc = vPb(Wh, Wh, tgv = -2);
    rhs = vPb(0, Wh, tgv = -2);
}

func real[int] funcRes(real t, real[int]& in, real[int]& inT) {
    real[int] out(in.n);
    T = Loc;
    MatMult(T, in, out);
    out = inT - out;
    return out;
}
real shift = 0;
matrix Id;
{
    real[int] D(Loc.n);
    D = 1.0;
    Id = D;
}
func int funcJ(real t, real[int]& in, real[int]& inT, real a) {
    matrix B = (-1.0) * Loc + a * Id;
    T = B;
    shift = a;
    return 0;
}
Wh w;
func real[int] funcRHS(real t, real[int]& u) {
    real[int] ret(u.n);
    if(t < 4.0 || t > 20.0)
        w = 0.0;
    else
        w = y < 0.5 ? 0.0 : 1.0;
    ChangeNumbering(T, w[], ret);
    return ret;
}
func int funcM(int s, real t, real[int]& u) {
    ChangeNumbering(T, w[], u, exchange = true, inverse = true);
    plotMPI(Th, w, Pk, def, real, cmm = "Global solution at step " + s + " (time " + t + ")");
}
w = (0.5 - x)^2 + (0.5 - y)^2 < 0.2 ? 1.0 : 0.0;
real[int] wPETSc;
ChangeNumbering(T, w[], wPETSc);
TSSolve(T, funcJ, funcRes, funcRHS, wPETSc, sparams = "-ts_type cn -ts_dt 0.1 -ts_max_time 100 -ts_exact_final_time interpolate -ts_max_snes_failures -1 -ts_view -pc_type lu -ts_adapt_type basic -ts_rtol 1e-3", monitor = funcM);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2]; // finite element space

int[int] l = [2, 1, 2, 2];
mesh Th = square(2 * getARGV("-global", 10), getARGV("-global", 10), [2 * x, y], label = l); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

real f = -90000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int2d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(Th)(f * vB) + on(1, u = 0.0, uB = 0.0);
fespace Wh(Th, Pk);                 // local finite element space
matrix Loc = vPb(Wh, Wh);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view", bs = 2);
Wh<real> def(u);                    // local solution

A = Loc;
u[] = A^-1 * rhs;
if(mpirank == 0)
    cout << "KSPGetIterationNumber = " << KSPGetIterationNumber(A) << endl;

real[int] err = A * u[];            // global matrix-vector product
exchange(A, rhs, scaled = true);
err -= rhs;

plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
u[] = err;
macro def1(u)u// EOM
plotMPI(Th, u, P2, def1, real, cmm = "Global residual");

Wh<real> def(Rb)[3];
[Rb[0], RbB[0]] = [1, 0];
[Rb[1], RbB[1]] = [0, 1];
[Rb[2], RbB[2]] = [y, -x];
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200", nearnullspace = Rb);
u[] = 0.0;
real[int] residuals(200);
KSPSetResidualHistory(A, residuals);
u[] = A^-1 * rhs;
if(mpirank == 0)
    cout << "KSPResidualHistory = " << residuals(0:KSPGetIterationNumber(A)) << endl;
plotMPI(Th, def(u), Pk, def, real, cmm = "Global solution");
real alpha = 1.0e+1;
mesh ThMoved = movemesh(Th, [x + alpha * u, y + alpha * uB]);
u[] = mpirank;
plotMPI(ThMoved, u, P2, def1, real, cmm = "Global moved solution");
if(HasType("PC", "hpddm")) {
    u[] = 0;
    set(A, sparams = "-pc_type hpddm -pc_hpddm_coarse_p 2 -pc_hpddm_levels_1_eps_nev 20 -pc_hpddm_levels_1_sub_pc_type lu -pc_hpddm_define_subdomains -pc_hpddm_has_neumann -pc_hpddm_levels_1_pc_type asm -ksp_monitor");
    u[] = A^-1 * rhs;
}
if(HasType("PC", "fancy_bug")) {
    exit(1);
}
if(HasType("KSP", "fancy_bug_bis")) {
    exit(2);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro removeZeros()true// EOM
macro trueRestrict()true// EOM
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

int s = getARGV("-split", 1);                                   // refinement factor

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = square(getARGV("-global", 40), getARGV("-global", 40));    // global mesh
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);

matrix Loc = vPb(Wh, Wh, tgv = -2);
Mat A(Loc, intersection, D);
Wh<real> def(u);    // local solution

set(A, sparams = "-pc_type lu -ksp_type gmres");
real[int] rhs = vPb(0, Wh, tgv = -2);
real[int] rhsPETSc;
ChangeNumbering(A, rhs, rhsPETSc);
func real[int] funcRes(real[int]& inPETSc) {
    real[int] outPETSc(inPETSc.n);
    MatMult(A, inPETSc, outPETSc);
    outPETSc -= rhsPETSc;
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    return 0;
}
Wh xu;
xu = sqrt((x - 0.5)^2 + (y - 0.5)^2) < 0.4 ? 0.1 : 1.0;
plotMPI(Th, xu, Pk, def, real, cmm = "Upper bound");
real[int] xPETSc, xuPETSc;
u[] = 0;
ChangeNumbering(A, u[], xPETSc);
ChangeNumbering(A, xu[], xuPETSc);
SNESSolve(A, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_view -snes_vi_monitor -snes_type vinewtonrsls", xu = xuPETSc);
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
// NBPROC 4
/***********************************************************************
  > File Name: oseen-2d-PETSc.edp
  > Author: Zhao Gang
  > Mail: zhaog6@lsec.cc.ac.cn
  > Created Time: 2020/10/22 Thursday 10:43:34
  > Run with mpi: ff-mpirun -np 4 script.edp -v 0 (# of Procs: 4)
 ***********************************************************************/

load "PETSc"
include "macro_ddm.idp"

//-----------------
//   Parameters
//-----------------
int n = getARGV("-global", 64);
int[int] labs = [1, 2, 4, 3];
int s = getARGV("-split", 0); // refinement index of mesh
real Re = getARGV("-Re", 100.);
real nu = 1./Re;

//-------------------------
//   Analytic Functions
//-------------------------
func b1 = 2 * (2*y - 1) * (1 - (2*x - 1)^2);
func b2 = -2 * (2*x - 1) * (1 - (2*y - 1)^2);

//--------------------
//   mesh
//--------------------
mesh Th = square(n, n);
DmeshCreate(Th);
fespace Ph(Th, P0);
Ph part;
PartitionCreate(Th, part[], P0);
mesh ThNo = trunc(Th, abs(part-1.0)<1e-1, split=2^s, label=-111111, renum=true);
if(s > 0) {
    Th = ThNo;
    DmeshReconstruct(Th);
}

//------------------------
//   fespace
//------------------------
macro feV [P2, P2] //
macro feQ P1 //
fespace Vh(Th, feV), Qh(Th, feQ);
Vh [uh, vh];
Qh ph;

//------------------------
//   varf
//------------------------
macro grad(u) [dx(u), dy(u)] //
macro Grad(u, v) [dx(u),dy(u), dx(v),dy(v)] //
macro Ugradv(u1, u2, v) ( u1*dx(v) + u2*dy(v) ) //
macro UgradV(u1, u2, v1, v2) [u1*dx(v1) + u2*dy(v1), u1*dx(v2) + u2*dy(v2)] //
macro div(u, v) ( dx(u) + dy(v) ) //
varf vF([u, v], [uu, vv]) = int2d(Th) ( nu*Grad(u, v)'*Grad(uu, vv) + UgradV(b1, b2, u, v)' * [uu, vv] ) + on(labs[3], u=1, v=0) + on(labs(0:2), u=0, v=0);
varf vB([p], [uu, vv]) = int2d(Th) ( - p * div(uu, vv) );
varf vC(p, pp) = int2d(Th) (0.0 * p * pp);  // pressure stabilization

//------------------------
//   Solving Equations
//------------------------
Mat dF, dC;
{
    macro def(u) [u, u#B] // for velocity
    macro init(u) [u, u] // for velocity
    MatCreate(Th, dF, feV);
}
MatCreate(Th, dC, feQ);
dF = vF(Vh, Vh, tgv=-1);
dC = vC(Qh, Qh);
matrix B = vB(Qh, Vh);
Mat dB(dF, dC, B);
{ // for Dirichlet BC on dF
    varf vonBorder([u, v], [uu, vv]) = on(labs, u=1, v=1);
    real[int] onBorder = vonBorder(0, Vh, tgv=-1);
    real[int] onBorderPETSc;
    ChangeNumbering(dF, onBorder, onBorderPETSc);
    MatZeroRows(dB, onBorderPETSc);
}
Mat dA = [[dF,  dB],
          [dB', dC]];
real[int] rhsV = vF(0, Vh, tgv=-1);
real[int] rhsP(Qh.ndof);
rhsP = 0;
real[int] rhsPETSc;
ChangeNumbering([dF, dC], [rhsV, rhsP], rhsPETSc);

// Defining names of velocity and pressure fields
real[int] list(rhsPETSc.n);
list(0 : dF.n-1) = 1;
list(dF.n : list.n-1) = 2;
string[int] names(2);
names[0] = "velocity";
names[1] = "pressure";

// Building PCD preconditioner
varf vAp(p, q) = int2d(Th) (nu * grad(p)' * grad(q));
varf vFp(p, q) = int2d(Th) (nu * grad(p)' * grad(q) + Ugradv(b1, b2, p)' * q);
varf vMp(p, q) = int2d(Th) (p * q);
Mat dAp(dC), dFp(dC), dMp(dC); // all Mat share the same distribution of the pressure space
dAp = vAp(Qh, Qh);
dFp = vFp(Qh, Qh);
dMp = vMp(Qh, Qh, sym = 1);
set(dAp, sparams="-prefix_push stiffness_ -ksp_constant_null_space -pc_type gamg -ksp_type cg -ksp_max_it 5 -prefix_pop", prefix="stiffness_");
set(dMp, sparams="-prefix_push mass_ -pc_type jacobi -ksp_type cg -ksp_max_it 5 -prefix_pop", prefix="mass_");
func real[int] PCD(real[int]& in) {
    real[int] out;
    KSPSolve(dAp, in, out);
    MatMult(dFp, out, in);
    KSPSolve(dMp, in, out);
    out *= -1.0;
    return out;
}

set(dA, sparams="-pc_type fieldsplit -prefix_push fieldsplit_velocity_ -pc_type hypre -ksp_type gmres -prefix_pop " + "-ksp_type fgmres -ksp_gmres_restart 200 -ksp_converged_reason -ksp_view -ksp_monitor", fields=list, names=names);
set(dC, parent=dA, precon=PCD, sparams="-prefix_push fieldsplit_pressure_ -pc_type shell -prefix_pop");

// Solving Oseen problem
real[int] uhPETSc;
KSPSolve(dA, rhsPETSc, uhPETSc);
ChangeNumbering([dF, dC], [uh[], ph[]], uhPETSc, inverse=true, exchange=true);

// Normalizing pressure
real[int] dpAverage(2), pAverage(2);
dpAverage[0] = int2d(ThNo) ( ph );
dpAverage[1] = ThNo.measure;
mpiAllReduce(dpAverage, pAverage, mpiCommWorld, mpiSUM);
ph = ph - pAverage[0]/pAverage[1];

int[int] fforder = [1, 1];
savevtk("oseen-2d.vtu", Th, [uh, vh], ph, dataname="velocity pressure", order=fforder);
load "PETSc"
include "macro_ddm.idp"

macro def2(i)[i, i#B]//
macro init2(i)[i, i]//
macro grad(u)[dx(u), dy(u)]//
macro div(u)(dx(u) + dy(u#B))//

int global = getARGV("-global", 50);
bool sym = usedARGV("-sym") != -1;
int[int] l = [2, 2, 1, 2];
mesh Th = square(global, global, [x, y], label = l, flags = 1); // global mesh
func Vk = P2;
func Pk = P1;

macro ThRefinementFactor()getARGV("-split", 1)//
DmeshCreate(Th);
Mat A, C;
{
    macro def(i)def2(i)//
    macro init(i)init2(i)//
    MatCreate(Th, A, [Vk, Vk]);
}
{
    MatCreate(Th, C, Pk);
}
fespace Wh(Th, [Vk, Vk]);
fespace Ph(Th, Pk);

varf vPbA(def2(u), def2(v)) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB)) + on(1, u = 1.0, uB = 0.0) + on(2, u = 0.0, uB = 0.0);
varf vPbB(def2(u), [q]) = int2d(Th)(-div(u) * q);

tgv = -2.0;
matrix NA;
matrix NB = vPbB(Wh, Ph);
NB.thresholding(1.0E-16);

real[int] rhs(Wh.ndof + Ph.ndof);
rhs(0:Wh.ndof - 1)                 = vPbA(0, Wh);
rhs(Wh.ndof:Wh.ndof + Ph.ndof - 1) = 0.0;
if(tgv < 0.0) {
    assert(abs(tgv + 2.0) < 1.0E-6);
    NA = vPbA(Wh, Wh, tgv = -10.0);
    if (!sym)
        NA.thresholding(1.0E-16);
    varf vPbRHS(def2(u), def2(v)) =                                                  on(1, u = 1.0, uB = 0.0) + on(2, u = 0.0, uB = 0.0);
    real[int] tmp = vPbRHS(0, Wh);
    real[int] rhsA = NA * tmp;
    real[int] rhsB = NB * tmp;
    rhs(0:Wh.ndof - 1) -= rhsA;
    rhs(Wh.ndof:rhs.n - 1) -= rhsB;
    varf vPbG(def2(u), def2(v)) = on(1, 2, u = 1.0, uB = 1.0);
    rhsA = vPbG(0, Wh);
    setBC(NA, rhsA, -2.0);
    if(sym)
        symmetrizeCSR(NA);
    for [i, j, v : NB] if(abs(rhsA(j) - 1.0) < 1.0E-2) v = 0.0;
}
else {
    NA.thresholding(1.0E-16);
    NA = vPbA(Wh, Wh);
}

A = NA;
Mat B(C, A, NB);
Mat Stokes = [[A, B'],
              [B, 0 ]];
set(Stokes, sparams = "-pc_type none");
if(HasType("PC", "hpddm")) {
    string common = " -ksp_converged_reason -ksp_view_final_residual -ksp_monitor_true_residual -ksp_type fgmres";
    set(Stokes, sparams = common + " -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self "
        + "-prefix_push fieldsplit_1_ "
        + " -ksp_type fgmres -pc_type hpddm -pc_hpddm_has_neumann -ksp_monitor -pc_hpddm_ksp_rtol 1.0E-2 -pc_hpddm_schur_precondition geneo "
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 20 -eps_threshold 0.5 -st_share_sub_ksp -eps_gen_non_hermitian -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky -eps_tol 1.0E-2 "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -correction balanced -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop", setup = 1);
    set(A, parent = Stokes, bs = sym ? 1 : 2, sparams =
          "-prefix_push fieldsplit_0_ -pc_type hpddm -ksp_pc_side right -pc_hpddm_has_neumann -pc_hpddm_define_subdomains"
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 40 -eps_threshold 0.3 -st_share_sub_ksp -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop");
    set(C, parent = Stokes);

    real[int] sol(Wh.ndof + Ph.ndof);
    sol = Stokes^-1 * rhs;
    Wh def2(u);
    u[] = sol(0:Wh.ndof - 1);
    Ph p;
    p[] = sol(Wh.ndof:sol.n - 1);
    plotMPI(Th, def2(u), [Vk, Vk], def2, real, cmm = "Global velocity (overlap = 1)");
    plotD(Th, p, cmm = "Global pressure (overlap = 1)");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

int[int] n2o;
macro ThN2O()n2o//
{
    macro dimension()2//
    include "macro_ddm.idp"
    mesh Th = square(60, 60);
    fespace Vh(Th, [P1, P1]);
    fespace Ph(Th, P1);
    Ph u = (x-0.5)^2 + (y-0.5)^2 - 0.1;
    Vh [vx, vy] = [cos(x), sin(y)];
    real dt = 0.2;
    u = convect([vx, vy], dt, u);
    mesh ThG = Th;
    fespace PhG(ThG, P1);
    PhG w;
    w[] = u[];
    DmeshCreate(Th);
    u = (x-0.5)^2 + (y-0.5)^2 - 0.1;
    convectParallel(Th, [vx, vy], dt, u, 20)
    plotD(Th, u, cmm = "Global 2D solution");
    if(mpisize > 1) {
        real[int] D;
        PartitionCreate(Th, D, P1);
        u[] .*= D;
        int[int] map = restrict(Ph, PhG, n2o);
        PhG uG, v;
        uG[](map) = u[];
        mpiAllReduce(uG[], v[], mpiCommWorld, mpiSUM);
        w[] -= v[];
        assert(w[].l2 < 1.0e-2);
    }
}
{
    macro dimension()3//
    include "macro_ddm.idp"
    mesh3 Th = cube(10, 10, 10);
    fespace Vh(Th, [P1, P1, P1]);
    fespace Ph(Th, P1);
    Ph u = (x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2 - 0.1;
    Vh [vx, vy, vz] = [0.5, 0.5, z/2.0];
    real dt = 0.05;
    u = convect([vx, vy, vz], -dt, u);
    mesh3 ThG = Th;
    fespace PhG(ThG, P1);
    PhG w;
    w[] = u[];
    DmeshCreate(Th);
    u = (x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2 - 0.1;
    [vx, vy, vz] = [0.5, 0.5, z/2.0];
    convectParallel(Th, [vx, vy, vz], -dt, u, 20)
    plotD(Th, u, cmm = "Global 3D solution");
    if(0 && mpisize > 1) {
        real[int] D;
        PartitionCreate(Th, D, P1);
        u[] .*= D;
        int[int] map = restrict(Ph, PhG, n2o);
        PhG uG, v;
        uG[](map) = u[];
        mpiAllReduce(uG[], v[], mpiCommWorld, mpiSUM);
        w[] -= v[];
        assert(w[].l2 < 1.0e-2);
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
include "getARGV.idp"
int overlap = getARGV("-overlap", 1);
int s = getARGV("-split", 2);
int[int][int] intersection;
{
    macro dimension()2// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions

    func Pk = P2;                       // finite element space
    int level = 4;
    mesh[int] ThTab(level);
    mesh[int] ThBorderTab(level);
    real[int][int] DTab(level);
    ThTab[level - 1] = square(getARGV("-global", 10), getARGV("-global", 10));
    matrix[int] P(level - 1);
    buildOverlapEdgeRecursive(ThTab, ThBorderTab, 10, s, overlap, level, P, intersection, DTab, Pk, mpiCommWorld, false, Pk, def, init);
    for(int i = 0; i < level; ++i) {
        fespace Vh(ThTab[i], Pk);
        Vh u;
        u[] = DTab[i];
        plotMPI(ThTab[i], u, Pk, def, real, cmm = "Global recursive partition of unity at level " + (i + 1));
    }
}
{
    macro dimension()3// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions

    func Pk = P1;                       // finite element space
    int level = 3;
    mesh3[int] ThTab(level);
    mesh3[int] ThBorderTab(level);
    real[int][int] DTab(level);
    ThTab[level - 1] = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [x, y, z]);
    matrix[int] P(level - 1);
    buildOverlapEdgeRecursive(ThTab, ThBorderTab, -111111, s, overlap, level, P, intersection, DTab, Pk, mpiCommWorld, false, Pk, def, init);
    for(int i = 0; i < level; ++i) {
        fespace Vh(ThTab[i], Pk);
        Vh u;
        u[] = DTab[i];
        plotMPI(ThTab[i], u, Pk, def, real, cmm = "Global recursive partition of unity at level " + (i + 1));
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
macro grad(u)[dx(u), dy(u)]// EOM

func Pk = P1;                       // finite element space

real r = 0.25;
real f = 5.0;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh Th0, Th1, Th2;
macro buildMesh(Th, i) {
    Th#i = buildmesh(a(getARGV("-global", 60) / (f^i)) + b(getARGV("-global", 60) / (f^i)) + c(getARGV("-global", 60) / (f^i)) + d(getARGV("-global", 60) / (f^i)) + e(getARGV("-global", 60)));
} //

for(int i = 0; i < 2; ++i) {
    Mat[int] A(3), P(2);
    buildMesh(Th, 0)
    buildMesh(Th, 1)
    buildMesh(Th, 2)
    if(i == 0) { // naive partitioning
        MatCreate(Th0, A[0], Pk);
        MatCreate(Th1, A[1], Pk);
        MatCreate(Th2, A[2], Pk);
        MatInterpolate(Th1, Pk, A[1], Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, A[2], Th1, Pk, A[1], P[1]);
    }
    else { // efficient (nested) partitioning
        mesh[int] ThGlobal(3);
        ThGlobal[2] = Th2;
        ThGlobal[1] = Th1;
        ThGlobal[0] = Th0;
        fespace Ph2(Th2, P0);
        fespace Ph1(Th1, P0);
        fespace Ph0(Th0, P0);
        Ph2 part2;
        if(mpirank == 0) {
            partitionerSeq(part2[], Th2, mpisize);
        }
        partitionerPar(part2[], Th2, mpiCommWorld, mpisize);
        Ph1 part1 = part2;
        Ph0 part0 = part1;
        macro Th2UserPartitioning()part2[]// EOM
        macro Th1UserPartitioning()part1[]// EOM
        macro Th0UserPartitioning()part0[]// EOM
        MatCreate(Th2, A[2], Pk);
        MatCreate(Th1, A[1], Pk);
        MatCreate(Th0, A[0], Pk);
        macro Th1NestedInTh0()//
        macro Th2NestedInTh1()//
        MatInterpolate(Th1, Pk, A[1], Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, A[2], Th1, Pk, A[1], P[1]);
    }

    real[int] rhs;
    for(int i = 0; i < 3; ++i) {
        mesh Th;
        if(i == 0) Th = Th0;
        else if(i == 1) Th = Th1;
        else Th = Th2;
        varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(v) + on(1, u = 0.0);
        fespace Wh(Th, Pk);
        A[i] = vPb(Wh, Wh, tgv = -2);
        if(i == 0) {
            rhs.resize(Wh.ndof);
            rhs = vPb(0, Wh);
        }
    }
    set(A, P, sparams = "-pc_type mg");
    fespace Wh(Th0, Pk);
    Wh u;
    u[] = A[0]^-1 * rhs;
    plotDmesh(Th0, cmm = "Mesh #0 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th1, cmm = "Mesh #1 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th2, cmm = "Mesh #2 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    macro def(u)u//
    plotMPI(Th0, u, Pk, def, real, cmm = "Global solution with " + (i == 0 ? "naive" : "efficient") + " partitioning");
}
for(int i = 0; i < 2; ++i) {
    Mat[int] A(1), P(2);
    buildMesh(Th, 0)
    buildMesh(Th, 1)
    buildMesh(Th, 2)
    if(i == 0) { // naive partitioning
        MatCreate(Th0, A[0], Pk);
        Mat B, C;
        MatCreate(Th1, B, Pk);
        MatCreate(Th2, C, Pk);
        MatInterpolate(Th1, Pk, B, Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, C, Th1, Pk, B, P[1]);
    }
    else { // efficient (nested) partitioning
        mesh[int] ThGlobal(3);
        ThGlobal[2] = Th2;
        ThGlobal[1] = Th1;
        ThGlobal[0] = Th0;
        fespace Ph2(Th2, P0);
        fespace Ph1(Th1, P0);
        fespace Ph0(Th0, P0);
        Ph2 part2;
        if(mpirank == 0) {
            partitionerSeq(part2[], Th2, mpisize);
        }
        partitionerPar(part2[], Th2, mpiCommWorld, mpisize);
        Ph1 part1 = part2;
        Ph0 part0 = part1;
        macro Th2UserPartitioning()part2[]// EOM
        macro Th1UserPartitioning()part1[]// EOM
        macro Th0UserPartitioning()part0[]// EOM
        Mat B, C;
        MatCreate(Th2, C, Pk);
        MatCreate(Th1, B, Pk);
        MatCreate(Th0, A[0], Pk);
        MatInterpolate(Th1, Pk, B, Th0, Pk, A[0], P[0]);
        MatInterpolate(Th2, Pk, C, Th1, Pk, B, P[1]);
    }

    real[int] rhs;
    varf vPb(u, v) = int2d(Th0)(grad(u)' * grad(v)) + int2d(Th0)(v) + on(1, u = 0.0);
    fespace Wh(Th0, Pk);
    A[0] = vPb(Wh, Wh, tgv = -2);
    rhs.resize(Wh.ndof);
    rhs = vPb(0, Wh);
    set(A, P, sparams = "-pc_type mg");
    Wh u;
    u[] = A[0]^-1 * rhs;
    plotDmesh(Th0, cmm = "Mesh #0 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th1, cmm = "Mesh #1 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    plotDmesh(Th2, cmm = "Mesh #2 with " + (i == 0 ? "naive" : "efficient") + " partitioning");
    macro def(u)u//
    plotMPI(Th0, u, Pk, def, real, cmm = "Global solution with " + (i == 0 ? "naive" : "efficient") + " partitioning");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P2;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
real dt = getARGV("-dt", 0.01);                                 // time step
int iMax = getARGV("-iMax", 10);                                // number of iterations

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int[int] LL = [1,2, 1,1, 1,1];
mesh3 ThBorder, Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);      // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    mesh3 ThAugmented = Th + ThBorder;
    varf vPb(u, v) = int3d(ThAugmented)(u * v + dt * (grad(u)' * grad(v))) + int3d(ThAugmented)(dt * v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM(u, v) = int3d(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = cube(1, 1, 1, [x, y, z]);

schwarz A(Mat, intersection, D, scaled = false);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int3d(Th)(u * v + dt * (grad(u)' * grad(v))) + int2d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int3d(Th)(u * v + dt * (grad(u)' * grad(v))) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int2d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}
/*# SolvePlot #*/
set(A, sparams = "-hpddm_reuse_preconditioner=1");
Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs);     // newRhs = M * u[]
    newRhs += rhs;

    if(Opt.n > 0)       // optimized Schwarz methods
        DDM(A, newRhs, u[], excluded = excluded, ret = ret, O = Opt);
    else
        u[] = A^-1 * newRhs;

    plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
}
/*# SolvePlotEnd #*/
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
int[int] labPeriodic = [2, 4, 1, 3];
macro Pk() P2, periodic=[[labPeriodic[0],x+y], [labPeriodic[1],x+y], [labPeriodic[2],x-y], [labPeriodic[3],x-y]]// EOM
macro PkNoPeriodic() P2// EOM

int s = getARGV("-split", 1);                                   // refinement factor

real r = 0.25;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh Th = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
Mat A;
if(mpisize > 1) {
    fespace Wh(Th, Pk);
    fespace Ph(Th, P0);
    Ph part;
    mesh ThExtended = Th;
    {
        partitionerSeq(part[], Th, mpisize);
        fespace PhExtended(ThExtended, P0);
        PhExtended partExtended;
        partExtended = part;
        for(int i = 0; i < mpisize; ++i) {
            mesh ThLocal = trunc(Th, abs(part - i) < 1e-6 && (y > 1-x-Th.hmax || y < -1-x+Th.hmax || y > 1+x-Th.hmax || y < -1+x+Th.hmax), label = 0);
            int j = 0;
            varf vOn(u, v) = on(labPeriodic[j], u = 1);
            fespace Vh(ThLocal, P1);
            Vh u;
            int[int] touch(4);
            touch = 0;
            for(j = 0; j < labPeriodic.n; ++j) {
                u[] = vOn(0, Vh);
                mesh ThLocalMoved;
                if(u[].linfty > 1e-12) {
                    if(j == 0) {
                        ThLocalMoved = movemesh(ThLocal, [x + 1, y - 1]);
                        touch[0] = 1;
                    }
                    else if(j == 1) {
                        ThLocalMoved = movemesh(ThLocal, [x - 1, y + 1]);
                        touch[1] = 1;
                    }
                    else if(j == 2) {
                        ThLocalMoved = movemesh(ThLocal, [x - 1, y - 1]);
                        touch[2] = 1;
                    }
                    else if(j == 3) {
                        ThLocalMoved = movemesh(ThLocal, [x + 1, y + 1]);
                        touch[3] = 1;
                    }
                }
                if(j == 3) {
                    if(touch[0] == 1 && touch[2] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x, y - 2]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[0] == 1 && touch[3] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x + 2, y]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[1] == 1 && touch[2] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x - 2, y]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[1] == 1 && touch[3] == 1) {
                        mesh ThLocalMovedSecond = movemesh(ThLocal, [x, y + 2]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                }
                if(ThLocalMoved.nt > 0) {
                    real[int] backup = partExtended[];
                    ThLocalMoved = trunc(ThLocalMoved, y <= 1-x+ThLocalMoved.hmax && y >= -1-x-ThLocalMoved.hmax && y <= 1+x+ThLocalMoved.hmax && y >= -1+x-ThLocalMoved.hmax);
                    ThExtended = ThExtended + ThLocalMoved;
                    partExtended = 0;
                    partExtended[](0:ThExtended.nt - ThLocalMoved.nt - 1) = backup;
                    partExtended[](ThExtended.nt - ThLocalMoved.nt:ThExtended.nt - 1) = i;
                }
            }
        }
        Th = ThExtended;
        part = partExtended;
    }
    broadcast(processor(0), Th);
    broadcast(processor(0), part[]);
    plot(part, fill = 1, wait = 1);
    int[int][int] intersection;
    real[int] D;
    buildWithPartitioning(ThExtended, part[], s, intersection, D, PkNoPeriodic, mpiCommWorld);
    Th = trunc(ThExtended, y <= 1-x && y >= -1-x && y <= 1+x && y >= -1+x);
    fespace WhExtended(ThExtended, PkNoPeriodic);
    matrix R = interpolate(Wh, WhExtended);
    periodicity(R, intersection, D);
    constructor(A, D.n, intersection, D);
}
else {
    if(s > 1)
        Th = trunc(Th, 1, split = s);
    fespace Wh(Th, Pk);
    constructor(A, Wh.ndof);
}

fespace Wh(Th, Pk);                 // local finite element space
func f = (y+x+1) * (y+x-1) * (y-x+1) * (y-x-1);
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) - int2d(Th)((0.39 - f) * v) + on(0, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C, i#D]//    // vector field definition
macro init(i)[i, i, i, i]// EOM     // vector field initialization
macro grad(u)[dx(u), dy(u), dz(u)]//// two-dimensional gradient
real Sqrt = sqrt(2.);
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P2, P2, P2, P1];         // finite element space

mesh3 Th;
{
    mesh ThGlobal2d = square(getARGV("-global", 12), getARGV("-global", 12), [x, y]);    // global mesh
    ThGlobal2d = trunc(ThGlobal2d, (x <= 0.5) || (y <= 0.5), label = 5);
    ThGlobal2d = trunc(ThGlobal2d, (y >= 0.25) || (x >= 0.25), label = 5);
    mesh Th2d = movemesh(ThGlobal2d, [-x, y]);
    ThGlobal2d = ThGlobal2d + Th2d;
    Th = buildlayers(ThGlobal2d, getARGV("-global", 12) / 2, zbound = [0, 0.4]);
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb([u, uB, uC, p], [v, vB, vC, q]) = int3d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) + grad(uC)' * grad(vC) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(0, 1, 3, 5, u = 0, uB = 0, uC = 0) + on(2, u = 1000*y*(0.5-y)*z*(0.4-z), uB = 0, uC = 0);
real[int] rhs = vPb(0, Wh, tgv = -1);

set(A, sparams = "-pc_type lu");
Wh<real> def(u);

A = vPb(Wh, Wh, tgv = -1);
u[] = A^-1 * rhs;

macro def1(u)u// EOM
plotMPI(Th, u, P2, def1, real, cmm = "Global solution");
// This codes shows how to calculate the eigenvalue spectrum of
// the Laplace operator on a 2d square domain, using SLEPc.
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg lplace-complex-2d-SLEPc.edp \
//        -split 1 -npts 400 -nev 10
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc-complex"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , pi)  ; // Dimension of the domain
real Ly    = getARGV("-ly"   , pi)  ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-complex-2d-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
complex sigma = 1.0 + 1i;
complex nu = 1.0 + 1i;
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( nu*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
    -sigma*uh*vh               )//  Bilinear form
    +on(Labels[3], uh = 0.0)    //  Boundary Conditions
    +on(Labels[2], uh = 0.0)    //  Boundary Conditions
    +on(Labels[1], uh = 0.0)    //  Boundary Conditions
    +on(Labels[0], uh = 0.0)    //  Boundary Conditions
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<complex> A = vA(Vh,Vh);
matrix<complex> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat<complex> DistA(A, intersection, D, clean = true);
Mat<complex>   DistB(DistA, B, clean = true);
/***************************************/
/*          Problem resolution         */
/***************************************/
complex[int]     EigenVAL(0);       // array to store eigenvalues
Vh<complex>[int] def(EigenVEC)(1);  // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_pos_gen_non_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<complex> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            complex,// Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "mmg"
load "Element_P4"
load "Element_P3"
macro def1(u)u//

int[int] fforder = [1];
{
    func Pk = P4;                       // finite element space
    func PkNew = P3;                    // finite element space

    macro dimension()2// EOM            // 2D or 3D
    include "macro_ddm.idp"             // additional DDM functions
    mesh ThNew, Th = square(getARGV("-global_2d", 20), getARGV("-global_2d", 20)); // global mesh
    {
        int N = 80;
        border a(t=0,1) { x=t;   y=0;   };
        border b(t=0,1) { x=1;   y=t;   };
        border c(t=0,1) { x=1-t; y=1;   };
        border d(t=0,1) { x=0;   y=1-t; };
        ThNew = buildmesh(a(N)+b(N)+c(N)+d(N));
    }
    DmeshCreate(Th);
    DmeshCreate(ThNew);
    fespace Vh(Th, Pk);
    fespace VhNew(ThNew, PkNew);
    Vh u = cos(8*pi*x) * sin(8*pi*y);
    VhNew uNew;
    VecInterpolate(Th, Pk, u, ThNew, PkNew, uNew);
    plotMPI(Th, u, Pk, def1, real, cmm = "Old FE function");
    plotMPI(ThNew, uNew, PkNew, def1, real, cmm = "New FE function");
    savevtk("transfer_2d.vtu", Th, u, order = fforder);
    savevtk("transfer_2d.vtu", ThNew, uNew, order = fforder, append = true);
}
{
    func PkSingle = P3;
    func Pk = [PkSingle, PkSingle];          // finite element space
    func PkNewSingle = P2;
    func PkNew = [PkNewSingle, PkNewSingle]; // finite element space

    macro dimension()3// EOM            // 2D or 3D
    macro def(u)[u, u#B]//
    macro init(u)[u, u]//
    include "macro_ddm.idp"             // additional DDM functions
    mesh3 ThNew, Th = cube(getARGV("-global_3d", 5), getARGV("-global_3d", 5), getARGV("-global_3d", 5)); // global mesh
    if(mpirank == 0)
        ThNew = mmg3d(Th, hmax = 8.0e-2);
    broadcast(processor(0), ThNew);
    DmeshCreate(Th);
    DmeshCreate(ThNew);
    fespace Vh(Th, Pk);
    fespace VhNew(ThNew, PkNew);
    Vh def(u) = [cos(2*pi*x) * sin(2*pi*y) * cos(2*pi*z), cos(2*pi*z)];
    VhNew def(uNew);
    VecInterpolate(Th, Pk, u, ThNew, PkNew, uNew);
    plotMPI(Th, def1(u), PkSingle, def1, real, cmm = "Old FE function");
    plotMPI(ThNew, def1(uNew), PkNewSingle, def1, real, cmm = "New FE function");
    savevtk("transfer_3d.vtu", Th, u, order = fforder);
    savevtk("transfer_3d.vtu", ThNew, uNew, order = fforder, append = true);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"

macro dimension()2//
include "macro_ddm.idp"

macro def(i)[i, i#B, i#C]//
macro init(i)[i, i, i]//
func Pk = [P2, P2, P1];
macro grad(u)[dx(u), dy(u)]//
macro div(u)(dx(u#1) + dy(u#2))//
macro UgradV(u, v)[[u#1, u#2]' * [dx(v#1), dy(v#1)],
                   [u#1, u#2]' * [dx(v#2), dy(v#2)]]//
real Re = getARGV("-Re", 75.0);
real nu = 1.0/Re;

mesh Th;
fespace Wh(Th, Pk); // complete space [u, v, p]
DmeshLoad(Th, "navier-stokes-2d");
Wh<complex> [uc1, uc2, pc];
ifstream sol("navier-stokes-2d_" + mpirank + "_" + mpisize + ".sol");
sol >> uc1[];
Mat<complex> J;
MatCreate(Th, J, Pk);
varf vJ([u1, u2, p], [v1, v2, q]) = int2d(Th)(
      (UgradV(uc, u) + UgradV(u, uc))' * [v1, v2]
    + nu * (grad(u1)' * grad(v1) +
            grad(u2)' * grad(v2))
    - p * div(v)
    - div(u) * q)
    + on(3, u1 = 0)
    + on(1, 2, u1 = 0, u2 = 0);
{
    matrix<complex> Loc = vJ(Wh, Wh);
    Loc = -Loc; // opposite of the Jacobian because SLEPc solves J*q=sigma*M*q
    J = Loc;
}
varf vM([u1, u2, p], [v1, v2, q]) = int2d(Th)(u1 * v1 + u2 * v2);
matrix<complex> Loc = vM(Wh, Wh);
Mat<complex> M(J, Loc, clean = true);

int nev = 1;
complex[int]     val(nev);      // array to store eigenvalues
Wh<complex>[int] def(vec)(nev); // array to store eigenvectors
complex s = getARGV("-shift_real", 1.0e-6) + getARGV("-shift_imag", 0.6) * 1i;
string params = "-eps_tol 1.0e-6 -eps_nev " + nev + " " +
    "-eps_type krylovschur -st_type sinvert -eps_monitor_all " +
    "-eps_target " + real(s) + "+" + imag(s) + "i";
int k = EPSSolve(J, M, vectors = vec, values  = val, sparams = params);
if(!NoGraphicWindow) {
    fespace Zh(Th, [P2, P2]);
    fespace Qh(Th, P1); // pressure space
    macro def1(i)i//
    Qh only = real(vecC[0]);
    plotMPI(Th, only, P1, def1, real, cmm = "Leading pressure eigenmode for Re = " + Re + ", eigenvalue = " + val[0]);
    macro def2(i)[i, i#B]//
    Zh [onlyU, onlyV] = [real(vec[0]), real(vecB[0])];
    plotMPI(Th, [onlyU, onlyV], [P2, P2], def2, real, cmm = "Leading velocity eigenmode for Re = " + Re + ", eigenvalue = " + val[0]);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1, P1, P1]; // finite element space


int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th =  cube(10 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [10 * x, y, z], label = LL);
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
real f = -9000.0;
real strain = 100.0;
real Young = 1.0e8;
real poisson = 0.45;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(1, u = 0.0, uB = 0.0, uC = 0.0);

Wh<real> def(u);                    // local solution

Wh<real> def(Rb)[6];
[Rb[0], RbB[0], RbC[0]] = [1, 0, 0];
[Rb[1], RbB[1], RbC[1]] = [0, 1, 0];
[Rb[2], RbB[2], RbC[2]] = [0, 0, 1];
[Rb[3], RbB[3], RbC[3]] = [y, -x, 0];
[Rb[4], RbB[4], RbC[4]] = [-z, 0, x];
[Rb[5], RbB[5], RbC[5]] = [0, z, -y];
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_pc_side right -ksp_max_it 200 -pc_gamg_threshold 0.01", nearnullspace = Rb, bs = 3);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    real[int] out(Wh.ndof);
    out = A * u[];
    real[int] rhs = vPb(0, Wh, tgv = -2);
    out -= rhs;
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    A = vPb(Wh, Wh, tgv = -2);
    return 0;
}
real[int] xPETSc;
u[] = 0;
ChangeNumbering(A, u[], xPETSc);
SNESSolve(A, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_linesearch_monitor -snes_type newtonls");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
macro def1(u)u// EOM
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
real alpha = 1.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = mpirank;
plotMPI(ThMoved, u, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

assert(mpisize == 1);
load "PETSc"
{
    real[int, int] A(2, 2);
    A(0, 0) = 2;
    A(0, 1) = 4;
    A(1, 1) = -4;
    A(1, 0) = 0.3;
    matrix sp = A;
    Mat dA(sp);
    real[int] list(2);
    list = 0;
    list(1) = 1;
    real[int, int] S(1, 1);
    set(dA, sparams = "-ksp_type preonly -pc_type lu -pc_factor_mat_solver_type mumps", schurList = list, schurComplement = S);
    cout << S << endl;
    assert(abs(S(0, 0) - (A(1, 1) - 1.0 / A(0, 0) * A(1, 0) * A(0, 1))) < 1e-10);
}
include "ExtractDofsonBorder.idp"
macro grad(u) [dx(u), dy(u)]//
real h = 0.1;
mesh Th = square(2/h, 1/h, [2*x, y]);
Th = trunc(Th, (abs(x-1) > 3*h) || (abs(y-0.45) > h/2), label = 10);
plot(Th, wait = 1);
fespace Vh(Th,P1);
varf vA(u,v) = int2d(Th)(grad(u)' * grad(v)) + on(1, 3, 4, u = 0);
{
    matrix A = vA(Vh, Vh, tgv = -2);
    Mat dA(A);
    int[int] I;
    ExtractDofsonBorder(2, Vh, I, 1);
    real[int] list(Vh.ndof);
    for [j, ij : I] list[ij] = j + 1;
    real[int, int] S(1, 1);
    set(dA, sparams = "-ksp_type preonly -pc_type lu -pc_factor_mat_solver_type mumps", schurList = list, schurComplement = S);
    cout << S << endl;
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P2;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    fespace Ph(ThAugmented, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = int2d(ThAugmented)(u * v + dt * (grad(u)' * grad(v))) + int2d(ThAugmented)(dt * f *  v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM(u, v) = int2d(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + int1d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

set(A, sparams = "-hpddm_reuse_preconditioner=1");
Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs);
    newRhs += rhs;

    if(Opt.n > 0)       // optimized Schwarz methods
        DDM(A, newRhs, u[], excluded = excluded, ret = ret, O = Opt);
    else
        u[] = A^-1 * newRhs;

    plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "msh3"
load "medit"

int[int] out;
int[int] part;
{
    DM dm("rectangle.msh");
    mesh localMesh2D = dm;
    macro dimension()2//
    include "macro_ddm.idp"
    plotDmesh(localMesh2D, cmm = "Distributed 2D mesh");
    DmeshReconstruct(localMesh2D);
    fespace Vh(localMesh2D, P1);
    Vh u;
    PartitionCreate(localMesh2D, u[], P1);
    plotD(localMesh2D, u, cmm = "Reconstructed 2D partition of unity");
}
if(0) { // not sure why this doesn't work on Jenkins
if(mpirank == 0) {
    DM dm("cube_5tets.cas", communicator = mpiCommSelf);
    mesh3 Th = dm;
    medit("Fluent .cas", Th);
}
DM dm("cube.msh", overlap = 0, neighbors = out, partition = part);
mesh3 localMesh3D = dm;
fespace Ph(localMesh3D, P0);
Ph plt;
for[i, v : part] plt[][i] = v;
mesh3 Th;
localMesh3D = Th;
localMesh3D = dm;
macro dimension()3//
include "macro_ddm.idp"
plotDmesh(localMesh3D, cmm = "Distributed 3D mesh");
DmeshReconstruct(localMesh3D);
fespace Vh(localMesh3D, P1);
Vh u;
PartitionCreate(localMesh3D, u[], P1);
plotD(localMesh3D, u, cmm = "Reconstructed 3D partition of unity");
DM overlap("cube.msh", overlap = 1, prefix = "with_overlap_", sparams = "-petscpartitioner_type ptscotch");
localMesh3D = overlap;
plotDmesh(localMesh3D, cmm = "Distributed 3D mesh");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
load "mat_edgeP1"
load "Element_Mixte3d"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"
include "cube.idp"

macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
func Pk = Edge03d;
func PkNode = P1;

int Dirichlet = 1;

mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10));
int[int] chlab = [1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet, 5, Dirichlet, 6, Dirichlet];
Th = change(Th, refface = chlab);

fespace Wh(Th, Pk);

Mat A;
int[int] n2o;
macro ThN2O()n2o// EOM
DmeshCreate(Th);
{
    macro ThPkPart()Edge03ds0// EOM special FE for the domain partitioning
    MatCreate(Th, A, Pk);
}

real[int] rhs(Wh.ndof);
varf vPb([Ex,Ey,Ez],[vx,vy,vz]) =
    int3d(Th)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
    + int3d(Th)([vx,vy,vz]'*[Ex,Ey,Ez])
    + on(Dirichlet, Ex=0, Ey=0, Ez=0);
A = vPb(Wh, Wh);
func f = exp(-2.0*((x-0.5)^2+(y-0.5)^2+(z-0.5)^2));
varf vPbRhs([Ex,Ey,Ez],[vx,vy,vz]) =
    - int3d(Th)([vx,vy,vz]'*[0,0,f])
    + on(Dirichlet, Ex=0,Ey=0,Ez=0);
rhs = vPbRhs(0, Wh);

{
    Mat B;
    MatCreate(Th, B, P1);
    fespace VhNode(Th, PkNode);
    matrix GLoc;
    MatrixEdgeP1(GLoc, Th);
    Mat G(A, B, GLoc);
    VhNode coord = x;
    real[int] tmp;
    ChangeNumbering(B, coord[], tmp);
    real[int, int] coordPETSc(3, tmp.n);
    for(int j = 0; j < 3; ++j) {
        for[i, ui : tmp] coordPETSc(j, i) = ui;
        if(j == 0)
            coord = y;
        else if(j == 1)
            coord = z;
        ChangeNumbering(B, coord[], tmp);
    }
    set(A, sparams = "-pc_type hypre -pc_hypre_type ams -ksp_monitor -ksp_view -ksp_max_it 40", coordinates = coordPETSc, gradient = G);
}

Wh [solx, soly, solz];
solx[] = A^-1 * rhs;
if(!NoGraphicWindow) {
    real[int] sol;
    ChangeNumbering(A, solx[], sol);
    ChangeNumbering(A, solx[], sol, inverse = true);
    mesh3 ThPlt = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10));
    fespace WhPlt(ThPlt, Pk);
    WhPlt [pltx, plty, pltz];
    WhPlt [reducex, reducey, reducez];
    int[int] rest = restrict(Wh, WhPlt, n2o);
    for[i, v : rest] pltx[][v] = solx[][i];
    mpiReduce(pltx[], reducex[], processor(0, mpiCommWorld), mpiSUM);
    if(mpirank == 0)
        medit("Global solution", ThPlt, [real(reducex), real(reducey), real(reducez)]);
}
// This codes shows how to calculate the eigenvalue spectrum of
// the Laplace operator on a 2d square domain, using SLEPc.
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-SLEPc.edp \
//        -split 1 -npts 400 -nev 10 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , pi)  ; // Dimension of the domain
real Ly    = getARGV("-ly"   , pi)  ; // Dimension of the domain
//
int nEV    = getARGV("-nev"  , 10)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( dx(uh)*dx(vh)+dy(uh)*dy(vh)  )//  Bilinear form
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D, clean = true);
Mat DistB(DistA, B, clean = true);

real[int, int] space(DistA.n, 1);
space = 1;

/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1);  // array to store eigenvectors
string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_view_values"             +
  " -eps_gen_nonhermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 // values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams, // Parameters for the distributed EigenValue solver
 deflation = space
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

if(0)
for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                  // SLEPc plugin
macro dimension()2// EOM      // 2D or 3D
include "macro_ddm.idp"       // additional DDM functions

macro def2(u)[u, u#B]// EOM
macro init2(u)[u, u]// EOM
macro def1(u)u// EOM
macro init1(u)u// EOM
macro grad(u)[dx(u), dy(u)]// EOM // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func PkV = [P2, P2];          // finite element space for the velocities
func PkP = P1;                // finite element space for the pressure

int s = getARGV("-split", 1); // refinement factor

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]);
fespace VhV(Th, PkV);         // local finite element space for the velocities
fespace VhP(Th, PkP);         // local finite element space for the pressure
DmeshCreate(Th);
Mat A, M;
{
    macro def(u)def2(u)//
    macro init(u)init2(u)//
    MatCreate(Th, A, PkV);
}
{
    macro def(u)def1(u)//
    macro init(u)init1(u)//
    MatCreate(Th, M, PkP);
}

varf vPbA([u, uB], [v, vB]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB)) + on(1, 2, 4, u = 0, uB = 0) + on(3, u = 1.0, uB = 0);
varf vPbB([q], [u, uB]) = int2d(Th)(-div(u) * q);
varf vPbM(p, q) = int2d(Th)(-p * q);
A = vPbA(VhV, VhV, tgv = -2);
M = vPbM(VhP, VhP);
Mat B(A, M);
Mat Z(A);
{
    B = vPbB(VhP, VhV);
    real[int] diag(VhV.ndof);
    matrix zeros = diag;
    Z = zeros;
    varf onGamma([u, uB], [v, vB]) = on(1, 3, 5, u = 1, uB = 1) + on(2, u = 1, uB = 1);
    VhV def2(g);
    g[] = onGamma(0, VhV, tgv = -1);
    real[int] gPETSc;
    ChangeNumbering(A, g[], gPETSc);
    MatZeroRows(B, gPETSc);
}
Mat LHS = [[A , B],
           [B', 0]];
Mat RHS = [[Z, 0],
           [0, M]];
int nV, nP;
{
    real[int] in(VhV.ndof), out;
    ChangeNumbering(A, in, out);
    nV = out.n;
    in.resize(VhP.ndof);
    ChangeNumbering(M, in, out);
    nP = out.n;
}
real[int] list(nV + nP);
list(0:nV - 1) = 1.0;
list(nV:nV + nP - 1) = 2.0;
real[int] nev(1);
EPSSolve(LHS, RHS, sparams = "-eps_gen_non_hermitian -st_pc_type fieldsplit -st_fieldsplit_1_pc_type jacobi -st_fieldsplit_0_pc_type hypre -st_ksp_type gmres -st_ksp_rtol 1e-1 " + " -eps_error_relative ::ascii_info_detail -st_ksp_converged_reason -eps_target_magnitude -st_type sinvert -eps_target 1.0e-5 -eps_nev 1", fields = list, values = nev);
assert(nev[0] > 0);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                  // PETSc plugin
macro dimension()2// EOM      // 2D or 3D
include "macro_ddm.idp"       // additional DDM functions

macro def2(u)[u, u#B]// EOM
macro init2(u)[u, u]// EOM
macro def1(u)u// EOM
macro init1(u)u// EOM
macro grad(u)[dx(u), dy(u)]// EOM // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func PkV = [P2, P2];          // finite element space for the velocities
func PkP = P1;                // finite element space for the pressure

int s = getARGV("-split", 1); // refinement factor

mesh Th = square(1, 1);
fespace VhV(Th, PkV);         // local finite element space for the velocities
fespace VhP(Th, PkP);         // local finite element space for the pressure
Mat dA, dC;
{
    mesh ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]);
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
    DmeshCreate(Th);
    {
        macro def(u)def2(u)//
        macro init(u)init2(u)//
        MatCreate(Th, dA, PkV);
    }
    {
        macro def(u)def1(u)//
        macro init(u)init1(u)//
        MatCreate(Th, dC, PkP);
    }
}

varf vPbA([u, uB], [v, vB]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB)) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
varf vPbB([q], [u, uB]) = int2d(Th)(-div(u) * q);
int vPETSc;
int pPETSc;
{
    matrix B = vPbB(VhP, VhV);
    real[int] rhsV = vPbA(0, VhV);

    dA = vPbA(VhV, VhV);
    Mat dB(dA, dC, B);
    Mat dS = [[dA , dB],
              [dB', 0 ]];
    ObjectView(dS);
    set(dS, sparams = "-pc_type lu");
    real[int] rhs(rhsV.n + VhP.ndof);
    rhs(0:rhsV.n - 1) = rhsV;
    real[int] sol = dS^-1 * rhs;
    VhV def2(solV);
    solV[] = sol(0:sol.n - VhP.ndof - 1);
    VhP solP;
    solP[] = sol(sol.n - VhP.ndof:sol.n - 1);
    plotMPI(Th, def2(solV), PkV, def2, real, cmm = "Global velocity");
    plotMPI(Th, solP, PkP, def1, real, cmm = "Global pressure");
}
{
    matrix B = vPbB(VhP, VhV);
    real[int] rhs = vPbA(0, VhV);

    Mat dB(dA, dC, B);
    Mat dS = [[dA , dB],
              [dB', 0 ]];
    Mat dF;
    MatConvert(dS, dF);
    set(dF, sparams = "-pc_type lu");
    real[int] sol;
    real[int] rhsPETScV, rhsPETScP;
    VhV def2(solV);
    VhP solP;
    ChangeNumbering(dA, rhs, rhsPETScV);
    ChangeNumbering(dC, solP[], rhsPETScP);
    vPETSc = rhsPETScV.n;
    pPETSc = rhsPETScP.n;
    real[int] rhsPETSc = [rhsPETScV,
                          rhsPETScP];
    {
        ObjectView(dF, format = "binary", name = "stokes-mat-binary");
        real[int, int] rhsView(rhsPETSc.n, 1);
        rhsView(:, 0) = rhsPETSc;
        ObjectView(rhsView, format = "binary", name = "stokes-rhs-binary");
        if(0) { // very costly
            ObjectView(dF, format = "ascii", name = "stokes-mat-ascii");
            ObjectView(dF, format = "matlab", name = "stokes-mat-matlab");
            ObjectView(rhsView, format = "ascii", name = "stokes-rhs-ascii");
            ObjectView(rhsView, format = "matlab", name = "stokes-rhs-matlab");
        }
    }
    KSPSolve(dF, rhsPETSc, sol);
    ChangeNumbering([dA, dC], [solV[], solP[]], sol, inverse = true, exchange = true);
    plotMPI(Th, def2(solV), PkV, def2, real, cmm = "Global velocity");
    plotMPI(Th, solP, PkP, def1, real, cmm = "Global pressure");
}
matrix<real> B = vPbB(VhP, VhV);

dA = vPbA(VhV, VhV, tgv = -1);
Mat dB(dA, dC, B);
{
    varf onGamma([u, uB], [v, vB]) = on(1, 3, 5, u = 1, uB = 1) + on(2, u = 1, uB = 1);
    VhV def2(g);
    g[] = onGamma(0, VhV, tgv = -1);
    real[int] gPETSc;
    ChangeNumbering(dA, g[], gPETSc);
    MatZeroRows(dB, gPETSc);
}
matrix BT = B';
Mat dBT(dC, dA, BT);
Mat dS = [[dA , dB],
          [dBT, 0 ]];
real[int] rhsPETSc;
VhV def2(solV);
VhP solP;
{
    real[int] rhs = vPbA(0, VhV, tgv = -1);
    ChangeNumbering([dA, dC], [rhs, solP[]], rhsPETSc);
}
for(int i = 0; i < 2; ++i) {
    real[int] sol;
    if(i == 0) {
        Mat dF;
        MatConvert(dS, dF);
        set(dF, sparams = "-pc_type lu");
        KSPSolve(dF, rhsPETSc, sol);
    }
    else {
        varf vSAL(p, q) = int2d(Th)(p * q);
        matrix SAL = vSAL(VhP, VhP);
        Mat[int] tab(1);
        Mat dSAL(dC, SAL);
        tab[0] = dSAL;
        real[int] list(rhsPETSc.n);
        list(0:vPETSc - 1) = 1.0;
        list(vPETSc:list.n - 1) = 2.0;
        set(dS, sparams = "-pc_type fieldsplit -ksp_type fgmres -ksp_view -ksp_monitor -fieldsplit_0_pc_type hypre -fieldsplit_0_ksp_type gmres -fieldsplit_0_ksp_rtol 1e-2 " + " -fieldsplit_0_ksp_monitor -fieldsplit_1_pc_type jacobi -fieldsplit_1_ksp_type cg -fieldsplit_1_ksp_max_it 5", fields = list, schur = tab);
        KSPSolve(dS, rhsPETSc, sol);
    }
    ChangeNumbering([dA, dC], [solV[], solP[]], sol, inverse = true, exchange = true);
    string plus = (i == 1 ? " + mAL preconditioning" : "");
    plotMPI(Th, def2(solV), PkV, def2, real, cmm = "Global velocity with tgv = -1" + plus);
    plotMPI(Th, solP, PkP, def1, real, cmm = "Global pressure with tgv = -1" + plus);
}
{
    ObjectView(dS);
    real c = 20.0;
    real[int] v, vPETSc;
    v.resize(VhV.ndof);
    v = mpirank;
    ChangeNumbering(dA, v, vPETSc);
    {
        Mat dSC = [[dA     , dB, vPETSc],
                   [dBT    , 0 , 0     ],
                   [vPETSc', 0 , c     ]];
        ObjectView(dSC);
    }
    {
        Mat dSC = [[dA     , vPETSc],
                   [vPETSc', c     ]];
        ObjectView(dSC);
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def1(i)i// EOM
macro def2(i)[i, i#B]// EOM
macro def(i)[i, i#B, i#C]// EOM
macro init(i)[i, i, i]// EOM
load "Element_Mixte"
func PkV = RT2;
func PkP = P2dc;
func Pk = [PkV, PkP];               // finite element space
border a(t=0,1) { x = -t+1; y = t; label = 1; };
border b(t=0,1) { x = -t; y = 1-t; label = 2; };
border c(t=0,1) { x = t-1; y = -t; label = 3; };
border d(t=0,1) { x = t; y = -1+t; label = 4; };
mesh Th = buildmesh(a(getARGV("-global", 20)) + b(getARGV("-global", 20)) + c(getARGV("-global", 20)) + d(getARGV("-global", 20)));
mesh ThGlobal = Th;
fespace Wh(Th, Pk);           // local finite element space
Mat A;
int[int] n2o;
macro ThN2O()n2o//
DmeshCreate(Th);
{
macro ThPostProcessD(D) {
    Wh def(u), def(v);
    varf onG(def(u), def(v)) = on(-111111, u = 10 + x + y, uB = 100 + y - x);
    v[] = D;
    u[] = onG(0, Wh);
    for [j, dj : u[]] dj = abs(dj) > 1e-2 ? 0.0 : 1.0;
    def(u) = [u, uB, vC];
    D = u[];
}// EOM
MatCreate(Th, A, Pk);
}

varf vMixedLaplace([u1, u2, p], [v1, v2, q]) = int2d(Th)(u1 * v1 + u2 * v2 + p*(dx(v1) + dy(v2)) + (dx(u1) + dy(u2))*q)
                                             + int2d(Th)(q)
                                             - int1d(Th, 1, 2, 3)(v1*N.x + v2*N.y)
                                             + on(4, u1 = 1.0, u2 = 1.0);

real[int] rhs = vMixedLaplace(0, Wh, tgv = -1);
A = vMixedLaplace(Wh, Wh, tgv = -1);
set(A, sparams ="-pc_type lu");
Wh def(u);
u[] = A^-1 * rhs;
macro params()// EOM
fespace WhGlobal(ThGlobal, Pk);
int[int] rest = restrict(Wh, WhGlobal, n2o);
WhGlobal def(uGlobal);
real[int] reduce(uGlobal[].n);
{
    real[int] tmp;
    ChangeNumbering(A, u[], tmp);
    ChangeNumbering(A, u[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u[][i];
mpiReduce(reduce, uGlobal[], processor(0), mpiSUM);
if(mpirank == 0) {
    plot(ThGlobal, def2(uGlobal), cmm = "Global solution", wait = 1, fill = 1);
    plot(ThGlobal, uGlobalC, cmm = "Global solution", wait = 1, fill = 1);
}
[u, uB, uC] = [0.0, 0.0, 1.0];
u[] += 1.0;
set(A, sparams = "-pc_type fieldsplit -ksp_monitor -ksp_view " +
    "-ksp_type fgmres " +
    "-pc_fieldsplit_type schur " +
    "-pc_fieldsplit_schur_fact_type full " +
    "-fieldsplit_0_ksp_type preonly " +
    "-fieldsplit_1_ksp_type gmres " +
    "-fieldsplit_1_ksp_converged_reason -fieldsplit_1_ksp_rtol 1e-4 " +
    "-pc_fieldsplit_schur_precondition selfp " +
    "-fieldsplit_1_pc_type hypre", fields = u[]);
u[] = A^-1 * rhs;
{
    real[int] tmp;
    ChangeNumbering(A, u[], tmp);
    ChangeNumbering(A, u[], tmp, inverse = true, exchange = false);
}
for[i, v : rest] reduce[v] = u[][i];
mpiReduce(reduce, uGlobal[], processor(0), mpiSUM);
if(mpirank == 0) {
    plot(ThGlobal, def2(uGlobal), cmm = "Global solution", wait = 1, fill = 1);
    plot(ThGlobal, uGlobalC, cmm = "Global solution", wait = 1, fill = 1);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"
load "Element_Mixte3d"
macro dimension()3// EOM
include "macro_ddm.idp"
include "cube.idp"

macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
macro def(i)[i, i#y, i#z]// EOM
macro init(i)[i, i, i]// EOM
macro defPart(i)i// EOM
macro initPart(i)i// EOM

int level = 2;
int s = 3;

Mat<complex>[int] MG(level);
mesh3[int] Th(level);
matrix[int] P(level - 1);
int Robin = 2;
int[int] LL = [Robin, Robin, Robin, Robin, Robin, Robin];
real n = getARGV("-n", 21) / s;
Th[level - 1] = cube(n, n, n, [x, y, z], label = LL);
func Pk = Edge03d;
func PkPart = Edge03ds0;
buildMatEdgeRecursive(Th, s, level, P, MG, Pk, mpiCommWorld, PkPart, defPart, initPart);

func k = 6 * pi;
func f = exp(-60 * ((x-0.5)^2 + (y-0.5)^2 + (z-0.5)^2));

complex[int] rhs;
matrix<complex>[int] Opt(level);
for(int i = 0; i < level; ++i) {
    fespace Vh(Th[i], Pk);
    varf vPb([Ex,Ey,Ez], [vx,vy,vz]) =
        int3d(Th[i])(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
      + int3d(Th[i])(-k^2*[vx,vy,vz]'*[Ex,Ey,Ez])
      + int2d(Th[i],Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
      + int2d(Th[i],-111111)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez));
    Opt[i] = vPb(Vh, Vh, sym = 1);
    MG[i] = Opt[i];
    if(i == 0) {
        varf vRHS([Ex,Ey,Ez],[vx,vy,vz]) = -int3d(Th[i])([vx,vy,vz]'*[0,0,f]);
        rhs.resize(Vh.ndof);
        rhs = vRHS(0, Vh);
    }
}
set(MG, P, sparams = "-pc_type mg -ksp_monitor -ksp_view_final_residual -ksp_type fgmres -ksp_gmres_restart 200 -ksp_max_it 200");
set(MG, 0, sparams = "-mg_coarse_ksp_type gmres -mg_coarse_ksp_rtol 1e-1 -mg_coarse_ksp_pc_side right " + " -mg_coarse_ksp_max_it 50 -mg_coarse_ksp_converged_reason -mg_coarse_pc_type asm -mg_coarse_sub_pc_factor_mat_solver_type mumps -mg_coarse_sub_pc_type cholesky -mg_coarse_pc_asm_type restrict", O = Opt[level - 1]);
set(MG, level - 1, sparams = "-mg_levels_ksp_type richardson -mg_levels_ksp_pc_side left -mg_levels_pc_type asm -mg_levels_sub_pc_type cholesky -mg_levels_sub_pc_factor_mat_solver_type mumps -mg_levels_pc_asm_type restrict", O = Opt[0]);
fespace Vh(Th[0], Pk);
Vh<complex> def(u);
u[] = MG[0]^-1 * rhs;
mesh3 ThFine = Th[0];
fespace VhFine(ThFine, P1);
VhFine plt = sqrt(real(u)^2 + real(uy)^2 + real(uz)^2);
plotD(ThFine, plt, cmm = "Solution");
int[int] fforder = [1, 1];
savevtk("maxwell-mg-3d.vtu", ThFine, [real(u), real(uy), real(uz)], [imag(u), imag(uy), imag(uz)], order = fforder, bin = 1);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), dz(u#C), (dz(u#B) + dy(u#C)) / Sqrt, (dz(u) + dx(u#C)) / Sqrt, (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B) + dz(u#C))// EOM
func Pk = [P1, P1, P1];             // finite element space

int s = getARGV("-split", 1);                                   // refinement factor

int[int] LL = [2,3, 2,1, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(6 * getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5), [6 * x, y, z], label = LL);
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

real f = -9000.0;
real strain = 100.0;
real Young = 2.0e11;
real poisson = 0.35;
real tmp = 1.0 + poisson;
real mu = Young  / (2.0 * tmp);
real lambda = Young * poisson / (tmp * (1.0 - 2.0 * poisson));
int dirichlet = 1;
varf vPb(def(u), def(v)) = int3d(Th)(lambda * div(u) * div(v) + 2.0 * mu * (epsilon(u)' * epsilon(v))) + int3d(Th)(f * vC) + on(dirichlet, u = 0.0, uB = 0.0, uC = 0.0);
matrix<real> Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_coarse_correction balanced -hpddm_geneo_nu 10");

int solver = getOption("schwarz_method");
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    matrix<real> noPen = vPb(Wh, Wh, sym = 1);
    AttachCoarseOperator(mpiCommWorld, A, A = noPen);
}

Wh<real> def(u);    // local solution

u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

mpiBarrier(mpiCommWorld);

macro def1(u)u// EOM
plotMPI(Th, u, P1, def1, real, cmm = "Global solution");
real alpha = 20000.0;
mesh3 ThMoved = movemesh3(Th, transfo = [x + alpha * u, y + alpha * uB, z + alpha * uC]);
u[] = err;
plotMPI(Th, u, P1, def1, real, cmm = "Global residual");
u[] = mpirank;
plotMPI(ThMoved, u, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P1;                       // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40)); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = intN(Th)(grad(u)' * grad(v));
func f = 1 + x - y;
varf vL(u, v)  = intN(Th)(f * v);
varf vb(u, v)  = intN(Th)(v);
real[int] F = vL(0, Wh);
real[int] B = vb(0, Wh);
real[int] pB, pF, pSol;
A = vPb(Wh, Wh);
ChangeNumbering(A, B, pB);
ChangeNumbering(A, F, pF);

Mat N = [[ A  , pB ],
         [ pB', 0  ]];
if(mpirank == 0) {
    pF.resize(pF.n + 1);
    pF = [pF(0:pF.n - 2), 0];
    F.resize(F.n + 1);
    F = [F(0:F.n - 2), 0];
}
{
    set(N, sparams = "-pc_type lu");
    real[int] x = N^-1 * F;
    if(mpirank == 0)
        x.resize(x.n - 1);
    Wh sol;
    sol[] = x;
    macro params()cmm = "Global solution #1", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
{
    Mat C;
    MatConvert(N, C);
    set(C, sparams = "-pc_type lu");
    KSPSolve(C, pF, pSol);
    if(mpirank == 0)
        pSol.resize(pSol.n - 1);
    Wh sol;
    ChangeNumbering(A, sol[], pSol, inverse = true, exchange = true);
    macro params()cmm = "Global solution #2", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
{
    set(N, sparams = "-ksp_view_pre -pc_type fieldsplit -fieldsplit_0_pc_type lu -fieldsplit_0_mat_mumps_cntl_3 1e-12 -fieldsplit_0_mat_mumps_icntl_24 1 -pc_fieldsplit_detect_saddle_point");
    KSPSolve(N, pF, pSol);
    if(mpirank == 0)
        pSol.resize(pSol.n - 1);
    Wh sol;
    ChangeNumbering(A, sol[], pSol, inverse = true, exchange = true);
    macro params()cmm = "Global solution #3", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
{
    Mat M = [[ 0 , pB'],
             [ pB, A  ]];
    set(M, sparams = "-pc_type lu");
    if(mpirank == 0) {
        real[int] tmp = F(0:F.n - 2);
        F(0) = 0;
        F(1:F.n - 1) = tmp;
    }
    real[int] x = M^-1 * F;
    if(mpirank == 0) {
        real[int] tmp = x(1:F.n - 1);
        x.resize(x.n - 1);
        x = tmp;
    }
    Wh sol;
    sol[] = x;
    macro params()cmm = "Global solution #4", wait = 1, dim = 3// EOM
    macro def(u)u//
    plotMPI(Th, sol, Pk, def, real, params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
int[int] labPeriodic = [2, 4, 1, 3];
macro Pk() P2, periodic=[[labPeriodic[0],x+y], [labPeriodic[1],x+y], [labPeriodic[2],x-y], [labPeriodic[3],x-y]]// EOM

real r = 0.25;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh Th = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
Mat A;
int[int] n2o;
macro ThPeriodicity()labPeriodic//
macro ThN2O()n2o//
DmeshCreate(Th);
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
func f = (y+x+1) * (y+x-1) * (y-x+1) * (y-x-1);
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) - int2d(Th)((0.39 - f) * v) + on(0, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

real[int] err = A * u[];            // global matrix-vector product
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");

set(A, sparams = "-pc_type gamg -ksp_type gmres -pc_gamg_threshold -1.0 -ksp_max_it 200");
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
if(!NoGraphicWindow) {
    real[int] sol;
    ChangeNumbering(A, u[], sol);
    ChangeNumbering(A, u[], sol, inverse = true);
    mesh ThPlt = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
    fespace WhPlt(ThPlt, Pk);
    WhPlt plt;
    WhPlt reduce;
    int[int] rest = restrict(Wh, WhPlt, n2o);
    plt[](rest) = u[];
    mpiReduce(plt[], reduce[], processor(0, mpiCommWorld), mpiSUM);
    if(mpirank == 0)
        plot(reduce);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u), dz(u)]// // three-dimensional gradient
func Pk = P1;                       // finite element space

int[int] LL = [1,2, 1,2, 1,1];
mesh3 Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);    // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
varf vPb(u, v) = int3d(Th)(grad(u)' * grad(v)) + int3d(Th)(v) + on(1, u = 0.0);
real[int] rhs = vPb(0, Wh);

set(A, sparams = "-ksp_view");
Wh<real> u;                         // local solution

A = vPb(Wh, Wh);
u[] = A^-1 * rhs;

real[int] err = A * u[];            // global matrix-vector product
real[int] transpose = A' * u[];
exchange(A, rhs, scaled = true);
err -= rhs;

macro def(u)u//
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");

Wh<real> Rb[1];
Rb[0] = 1;
set(A, sparams = "-pc_type gamg -ksp_type gmres -ksp_max_it 200", nearnullspace = Rb);
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "bem"
load "PETSc-complex"
load "msh3"
include "macro_ddm.idp"

if(!HasType("Mat", "Htool")) exit(0);

complex k = 10; // wavenumber

real lambda = 2*pi/real(k);

real nloc = 10./lambda;
real n = nloc*2*pi;

int[int] nsl(10); // number of lenses
nsl = n;

real theta = 10*2*pi/360; // angular shift between lenses

real[int] nsx(nsl.n), nsy(nsl.n);
nsx[0] = 3.2;
nsy[0] = 0;

for (int i=1; i< nsl.n; i++) {
  nsx[i] = nsx[i-1] + 2.01*cos(i*theta);
  nsy[i] = nsy[i-1] + 2.01*sin(i*theta);
}

int interface = 1;
int waveguide = 2;

border circle(t=0, 2*pi; i){x=cos(t)+nsx[i]; y=sin(t)+nsy[i]; z=0; label=interface;}

real L = 2;
real l = 0.3;
real dd = 0.1;

func finc = exp(-100*((x+L-0.1)^2+y^2+z^2)); // source for waveguide excitation

// interface around the waveguide :
border a(t=-L-dd, L+dd){x=t; y=-l-dd; z=0; label=interface;}
border b(t=-l-dd, l+dd){x=L+dd; y=t; z=0; label=interface;}
border c(t=L+dd, -L-dd){x=t; y=l+dd; z=0; label=interface;}
border d(t=l+dd, -l-dd){x=-L-dd; y=t; z=0; label=interface;}

// waveguide :
border ga(t=-L, L){x=t; y=-l; z=0; label=waveguide;}
border gc(t=L, -L){x=t; y=l; z=0; label=waveguide;}
border gd(t=l, -l){x=-L; y=t; z=0; label=waveguide;}

mesh Thwaveguide = buildmesh(a(nloc*(2*L+2*dd))+b(nloc*(2*l+2*dd))+c(nloc*(2*L+2*dd))+d(nloc*(2*l+2*dd))
                         +ga(nloc*2*L)+gc(nloc*2*L)+gd(nloc*2*l));

mesh Thlenses = buildmesh(circle(nsl));
// we do not want any region with label 0 for the lenses, as 0 is the waveguide region in Thwaveguide :
Thlenses = change(Thlenses,fregion=region+1);

mesh Th = Thwaveguide + Thlenses; // FEM mesh

meshL ThG = extract(Th);
ThG = trunc(ThG,region==interface);
ThG = OrientNormal(ThG,unbounded=1); // BEM mesh

// change region labels in the fem mesh to define gradient index in lenses
fespace Ph(Th,P0);
Ph reg = region;

int[int] regs(2*nsl.n+2);
for (int i=0; i< nsl.n; i++){
  int regi = reg(nsx[i], nsy[i]); // the lenses
  regs[2*i] = regi;
  regs[2*i+1] = i+1;
}
regs[2*nsl.n] = reg(0,0); // the waveguide
regs[2*nsl.n+1] = -1;
Th = change(Th,region=regs);

func ind = region == -1 ? 1 : 2./(1+((x-nsx[region-1])^2+(y-nsy[region-1])^2)); // gradient index in lenses

plot(ThG);
Mat<complex> A, T;
if(usedARGV("-user_partitioning") == -1) {
    MatCreate(Th, A, P1);
    MatCreate(Th, T, P0);
}
else {
    int[int] n2o;
    mesh withBEM = trunc(Th, (x-3.2)^2+y^2 > 0.6, new2old = n2o);
    fespace PhPart(withBEM, P0);
    PhPart partWithBEM;
    partitionerSeq(partWithBEM[], withBEM, mpisize - 1);
    partitionerPar(partWithBEM[], withBEM, mpiCommWorld, mpisize - 1);
    Ph part;
    part[] = mpisize - 1;        // last rank has no BEM unknown
    part[](n2o) = partWithBEM[]; // no need for restrict since using P0
    plot(part);
    macro ThUserPartitioning()part[]//
    MatCreate(Th, A, P1);
    MatCreate(Th, T, P0);
}
meshL ThL;
{
    int[int] labels=labels(Th);
    if(labels.max > 0) {
        fespace PhL(ThG, P0);
        PhL u = (region==interface)*chi(Th);
        ThL = trunc(ThG,abs(u-1.0)<1.0e-2);
    }
}
fespace Vh(Th, P1);
macro Grad(u) [dx(u),dy(u)] // EOM
varf varfA(u,v) = int2d(Th)(-ind*k^2*u*v+Grad(u)'*Grad(v)) + on(waveguide,u=0);
A = varfA(Vh, Vh, tgv = -1);
fespace VhS(ThL, P1);
matrix RVtoS = interpolate(VhS, Vh);
Mat<complex> ASurf(A, restriction = RVtoS);
{
    fespace PhS(ThL, P0);
    matrix PVtoS = interpolate(PhS, Ph);
    Mat<complex> TSurf(T, restriction = PVtoS);
    CoherentGlobalMesh(TSurf, ASurf, ThL, ThG);
    MatDestroy(T);
}
matrix<complex> Mass;
if(ThL.nt) {
    varf varfMass(u,v) = int1d(Th,interface)(u*v) + on(waveguide,u=0);
    Mass = varfMass(Vh, Vh, tgv = -10);
    matrix IdV = eye(Vh.ndof);
    renumbering(Mass, RVtoS, R = IdV);
}
Mat<complex> TDL(ASurf);
{
    fespace UhG(ThG, P1);
    varf varfTDL(u,v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("TDL",k=k),u,v)) + int1d(ThG)(0.5*u*v);
    TDL = varfTDL(UhG, UhG);
    varf varfSL(u,v) = int1dx1d(ThG)(ThG)(BEM(BemKernel("SL",k=k),u,v));
    ASurf = varfSL(UhG, UhG, sym = 1, sparams = "-mat_htool_epsilon 1.0e-3");
    ASurf *= -1.0;
}
Mat<complex> VtoS(ASurf, A, Mass);
Mat<complex> StoV(A, ASurf);
{
    matrix<complex> PStoV = RVtoS;
    PStoV = PStoV';
    StoV = PStoV;
}
complex[int] rhs(Vh.ndof + VhS.ndof);
varf varfRHS(u,v) = int2d(Th)(finc*v) + on(waveguide,u=0);
rhs(0:Vh.ndof - 1) = varfRHS(0, Vh, tgv = -1);
Mat<complex> N;
if(usedARGV("-aij") == -1) {
    N = [[A,    StoV*TDL],
         [VtoS, ASurf   ]];
    real[int] list(N.n);
    list(0:A.n-1) = 1.0;
    if(ThL.nt)
        list(A.n:list.n-1) = 2.0;
    set(N, sparams = "-ksp_view -ksp_monitor -ksp_type fgmres -ksp_view_final_residual -fieldsplit_1_ksp_max_it 2000 -ksp_gmres_restart 200 -pc_type fieldsplit "+" -fieldsplit_0_pc_type asm -fieldsplit_0_sub_pc_type lu -fieldsplit_0_ksp_type gmres -fieldsplit_1_ksp_type gmres -fieldsplit_1_ksp_gmres_restart 2000 "+" -prefix_push fieldsplit_1_ -ksp_pc_side right -ksp_max_it 20 -prefix_pop", fields = list);
}
else {
    Mat<complex> DTDL;
    MatConvert(TDL, DTDL);
    Mat<complex> R;
    MatMatMult(StoV, DTDL, R);
    N = [[A,    R    ],
         [VtoS, ASurf]];
    set(N, sparams = "-pc_type lu");
}
complex[int] x = N^-1 * rhs;
Vh<complex> plt;
plt[] = x(0:Vh.ndof-1);
macro def(u)u//
plotMPI(Th, real(plt), P1, def, real, cmm = "FEM solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "msh3"
load "mshmet"
load "mmg"
load "medit"
load "PETSc"
macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

int n = 12;
int[int] L=[1,1,1,1], LU=[0,2], LD=[1,1], LR=[0,1];
mesh3 Th3 = buildlayers(square(n, n, region=0, label=L), n, zbound=[0,1], labelmid=LD, labelup=LU, labeldown=LR);
Th3 = trunc(Th3, x < 0.5 || y < 0.5 || z < 0.5, label=3);

macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient

varf vPoisson(u, v) = int3d(Th3)(grad(u)' * grad(v)) + int3d(Th3)(v) + on(1,2,3, u=0);

mesh3 ThBackup = Th3;
Mat A;
int[int] n2o;
NewMacro Th3N2O() n2o EndMacro
DmeshCreate(Th3);
MatCreate(Th3, A, P1);
fespace Vh(Th3, P1);
Vh u;
real err = 1.0e-2;

int iMax = 4;
int[int] rt(2);
rt = [1,2];
for(int i = 0; i < iMax; ++i) {
    A = vPoisson(Vh, Vh, tgv = -2);
    set(A, sparams = "-ksp_monitor -pc_type hypre");
    real[int] rhs = vPoisson(0, Vh, tgv = -1);
    u[] = A^-1 * rhs;
    int[int] fforder = [1];
    savevtk("laplace-adapt-3d.vtu", Th3, u, bin = 1, order = fforder, append = i ? true : false);
    if(i < iMax - 1) {
        fespace VhBackup(ThBackup, P1);
        VhBackup h, hReduced;
        u[] .*= A.D;
        int[int] rest = restrict(Vh, VhBackup, n2o);
        for[i, v : rest] h[][v] = u[][i];
        mpiAllReduce(h[], hReduced[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            real[int] met = mshmet(ThBackup, hReduced, aniso = 0, hmin = 1.0e-3, hmax = 2.0e-1, err = err);
            plot(hReduced);
            Th3 = mmg3d(ThBackup, metric = met, hgrad = 3.0, requiredTriangle = rt);
            medit("U-adapt-iso-" + i, Th3, hReduced);
        }
        broadcast(processor(0), Th3);
        ThBackup = Th3;
        Mat Adapt;
        MatCreate(Th3, Adapt, P1);
        A = Adapt;
        u = 0.0;
        err *= 0.5;
    }
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

int[int] l = [1, 1, 1, 1];
mesh Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l); // global mesh
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);                 // local finite element space
real[int] rhs(Wh.ndof);             // local right-hand side
matrix<real> M;                     // local mass matrix
{                                   // local weak form
    fespace Ph(Th, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + int2d(Th)(dt * f *  v) + on(1, u = 0.0);
    A = vPb(Wh, Wh, tgv = -1);
    rhs = vPb(0, Wh, tgv = -1);
    varf vPbM(u, v) = int2d(Th)(u * v);
    M = vPbM(Wh, Wh);
}

set(A, sparams = "-ksp_view");
Wh<real> u = 0.0;                   // local solution

for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    newRhs = M * u[];
    newRhs += rhs;

    u[] = A^-1 * newRhs;

    macro def(u)u//
    plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro trueRestrict()true// EOM
macro removeZeros()true// EOM
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
func Pk = P2;                       // finite element space
func Pkdc = P2dc;                   // finite element space

mesh Th = square(getARGV("-global", 40), getARGV("-global", 40));
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);
fespace Vh(Th, Pk);
fespace Ph(Th, Pkdc);

Vh b = 1;
real a = 0.001;
func real f(real u) { return u*a+u-log(1+u); }
func real df(real u) { return a+u/(1+u); }
func real ddf(real u) { return 1/((1+u)*(1+u)); }

Ph alpha;
Ph dfalpha;
Ph ddfalpha;
Vh u = 0;

varf vdJ(uh, vh) = int2d(Th)(dfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)))
    + on(1, 2, 3, 4, uh = 0);
varf vC(uh, vh) = int2d(Th)(b*vh)
    + on(1, 2, 3, 4, uh = 0);
varf vhJ(uh, vh) = int2d(Th)(dfalpha*(dx(uh)*dx(vh) + dy(uh)*dy(vh)) + ddfalpha*(dx(u)*dx(vh) + dy(u)*dy(vh)) * (dx(u)*dx(uh) + dy(u)*dy(uh)))
    + on(1, 2, 3, 4, uh = 0);

func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    alpha = dx(u)*dx(u) + dy(u)*dy(u);
    dfalpha = df(alpha);
    ddfalpha = 2 * ddf(alpha);
    real[int] v = vdJ(0, Vh, tgv = -1);
    real[int] outPETSc;
    ChangeNumbering(A, v, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vhJ(Vh, Vh, tgv = -1);
    return 0;
}

real[int] xPETSc, bPETSc;
u[] = vC(0, Vh);
ChangeNumbering(A, u[], bPETSc);
xPETSc.resize(bPETSc.n);
xPETSc = 0;
int ret;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -ksp_monitor_true_residual -snes_converged_reason -ksp_converged_reason -pc_type lu -snes_view", reason = ret);
assert(ret == 3);
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");

xPETSc = 0;
Vh v;
int j;
real absTol = 1e-2;
macro myplot() cmm = "Global " + (j == 0 ? "solution" : "decrement") + " at iteration " + it, wait = 1, fill = 1, dim = 3// EOM
func int funcMonitor(int it, real xnorm, real gnorm, real f, real[int]& u, real[int]& du) {
    ChangeNumbering(A, v[], u, inverse = true, exchange = true);
    j = 0;
    plotMPI(Th, v, Pk, def, real, myplot);
    ChangeNumbering(A, v[], du, inverse = true, exchange = true);
    j = 1;
    plotMPI(Th, v, Pk, def, real, myplot);
    real abs = du.linfty, red;
    mpiAllReduce(abs, red, mpiCommWorld, mpiMAX);
    return it > 0 && red < absTol ? 2 : 0; // reasons defined there https://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/SNES/SNESConvergedReason.html
}
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_converged_reason", monitor = funcMonitor, reason = ret);
assert(ret == 2);
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro trueRestrict()true// EOM
macro removeZeros()true// EOM
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions
macro def(i)[i, i#B]// EOM          // vector field definition
macro init(i)[i, i]// EOM           // vector field initialization
func Pk = [P1, P1];                 // finite element space

//  Macros for the gradient of a vector field (u1, u2)
macro grad11(u1, u2) (dx(u1)) //
macro grad21(u1, u2) (dy(u1)) //
macro grad12(u1, u2) (dx(u2)) //
macro grad22(u1, u2) (dy(u2)) //

//  Macros for the deformation gradient
macro F11(u1, u2) (1.0 + grad11(u1,u2)) //
macro F12(u1, u2) (0.0 + grad12(u1,u2)) //
macro F21(u1, u2) (0.0 + grad21(u1,u2)) //
macro F22(u1, u2) (1.0 + grad22(u1,u2)) //

//  Macros for the incremental deformation gradient
macro dF11(varu1, varu2) (grad11(varu1, varu2)) //
macro dF12(varu1, varu2) (grad12(varu1, varu2)) //
macro dF21(varu1, varu2) (grad21(varu1, varu2)) //
macro dF22(varu1, varu2) (grad22(varu1, varu2)) //

//  Macro for the determinant of the deformation gradient
macro J(u1, u2) (
F11(u1, u2)*F22(u1, u2) - F12(u1, u2)*F21(u1, u2)
) //

//  Macros for the inverse of the deformation gradient
macro Finv11 (u1, u2) (
F22(u1, u2) / J(u1, u2)
) //
macro Finv22 (u1, u2) (
F11(u1, u2) / J(u1, u2)
) //
macro Finv12 (u1, u2) (
-F12(u1, u2) / J(u1, u2)
) //
macro Finv21 (u1, u2) (
-F21(u1, u2) / J(u1, u2)
) //

//  Macros for the square of the inverse of the deformation gradient
macro FFinv11 (u1, u2) (
Finv11(u1, u2)^2 + Finv12(u1, u2)*Finv21(u1, u2)
) //

macro FFinv12 (u1, u2) (
Finv12(u1, u2)*(Finv11(u1, u2) + Finv22(u1, u2))
) //

macro FFinv21 (u1, u2) (
Finv21(u1, u2)*(Finv11(u1, u2) + Finv22(u1, u2))
) //

macro FFinv22 (u1, u2) (
Finv12(u1, u2)*Finv21(u1, u2) + Finv22(u1, u2)^2
) //

//  Macros for the inverse of the transpose of the deformation gradient
macro FinvT11(u1, u2) (Finv11(u1, u2)) //
macro FinvT12(u1, u2) (Finv21(u1, u2)) //
macro FinvT21(u1, u2) (Finv12(u1, u2)) //
macro FinvT22(u1, u2) (Finv22(u1, u2)) //

macro B11(u1, u2)
(
F11(u1, u2)^2 + F12(u1, u2)^2
)//

macro B12(u1, u2)
(
F11(u1, u2)*F21(u1, u2) + F12(u1, u2)*F22(u1, u2)
)//

macro B21(u1, u2)
(
F11(u1, u2)*F21(u1, u2) + F12(u1, u2)*F22(u1, u2)
)//

macro B22(u1, u2)
(
F21(u1, u2)^2 + F22(u1, u2)^2
)//

macro d0Aux11 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * F11(u1, u2) + dF12(varu1, varu2) * F12(u1, u2)
)//

macro d0Aux12 (u1, u2, varu1, varu2)
(
dF21(varu1, varu2) * F11(u1, u2) + dF22(varu1, varu2) * F12(u1, u2)
)//

macro d0Aux21 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * F21(u1, u2) + dF12(varu1, varu2) * F22(u1, u2)
)//

macro d0Aux22 (u1, u2, varu1, varu2)
(
dF21(varu1, varu2) * F21(u1, u2) + dF22(varu1, varu2) * F22(u1, u2)
)//

////  The tensor quantity D1 = D0 + D0^T
macro d1Aux11 (u1, u2, varu1, varu2)
(
2.0 * d0Aux11 (u1, u2, varu1, varu2)
)//

macro d1Aux12 (u1, u2, varu1, varu2)
(
d0Aux12 (u1, u2, varu1, varu2) + d0Aux21 (u1, u2, varu1, varu2)
)//

macro d1Aux21 (u1, u2, varu1, varu2)
(
d1Aux12 (u1, u2, varu1, varu2)
)//

macro d1Aux22 (u1, u2, varu1, varu2)
(
2.0 * d0Aux22 (u1, u2, varu1, varu2)
)//

////  The tensor quantity D2 = F^{-T}_{n} dF_{n+1}
macro d2Aux11 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * FinvT11(u1, u2) + dF21(varu1, varu2) * FinvT12(u1, u2)
)//

macro d2Aux12 (u1, u2, varu1, varu2)
(
dF12(varu1, varu2) * FinvT11(u1, u2) + dF22(varu1, varu2) * FinvT12(u1, u2)
)//

macro d2Aux21 (u1, u2, varu1, varu2)
(
dF11(varu1, varu2) * FinvT21(u1, u2) + dF21(varu1, varu2) * FinvT22(u1, u2)
)//

macro d2Aux22 (u1, u2, varu1, varu2)
(
dF12(varu1, varu2) * FinvT21(u1, u2) + dF22(varu1, varu2) * FinvT22(u1, u2)
)//

////  The tensor quantity D3 = F^{-2}_{n} dF_{n+1}
macro d3Aux11 (u1, u2, varu1, varu2, w1, w2)
(
dF11(varu1, varu2) *FFinv11(u1, u2) *grad11(w1, w2) + dF21(varu1, varu2) *FFinv12(u1, u2)
*grad11(w1, w2)
+ dF11(varu1, varu2) *FFinv21(u1, u2) *grad12(w1, w2) + dF21(varu1, varu2) *FFinv22(u1, u2) *grad12(w1, w2)
)//

macro d3Aux12 (u1, u2, varu1, varu2, w1, w2)
(
dF12(varu1, varu2) *FFinv11(u1, u2) *grad11(w1, w2) + dF22(varu1, varu2) *FFinv12(u1, u2)
*grad11(w1, w2)
+ dF12(varu1, varu2) *FFinv21(u1, u2) *grad12(w1, w2) + dF22(varu1, varu2) *FFinv22(u1, u2) *grad12(w1, w2)
)//

macro d3Aux21 (u1, u2, varu1, varu2, w1, w2)
(
dF11(varu1, varu2) *FFinv11(u1, u2) *grad21(w1, w2) + dF21(varu1, varu2) *FFinv12(u1, u2)
*grad21(w1, w2)
+ dF11(varu1, varu2) *FFinv21(u1, u2) *grad22(w1, w2) + dF21(varu1, varu2) *FFinv22(u1, u2) *grad22(w1, w2)
)//

macro d3Aux22 (u1, u2, varu1, varu2, w1, w2)
(
dF12(varu1, varu2) *FFinv11(u1, u2) *grad21(w1, w2) + dF22(varu1, varu2) *FFinv12(u1, u2)
*grad21(w1, w2)
+ dF12(varu1, varu2) *FFinv21(u1, u2) *grad22(w1, w2) + dF22(varu1, varu2) *FFinv22(u1, u2) *grad22(w1, w2)
)//

////  The tensor quantity D4 = (grad w) * Finv
macro d4Aux11 (w1, w2, u1, u2)
(
Finv11(u1, u2)*grad11(w1, w2) + Finv21(u1, u2)*grad12(w1, w2)
)//

macro d4Aux12 (w1, w2, u1, u2)
(
Finv12(u1, u2)*grad11(w1, w2) + Finv22(u1, u2)*grad12(w1, w2)
)//

macro d4Aux21 (w1, w2, u1, u2)
(
Finv11(u1, u2)*grad21(w1, w2) + Finv21(u1, u2)*grad22(w1, w2)
)//

macro d4Aux22 (w1, w2, u1, u2)
(
Finv12(u1, u2)*grad21(w1, w2) + Finv22(u1, u2)*grad22(w1, w2)
)//

//  The Kirchhoff stress tensor
macro StressK11(u1, u2)
(
mu * (B11(u1, u2) - 1.0)
)//

//  The Kirchhoff stress tensor
macro StressK12(u1, u2)
(
mu * B12(u1, u2)
)//

//  The Kirchhoff stress tensor
macro StressK21(u1, u2)
(
mu * B21(u1, u2)
)//

//  The Kirchhoff stress tensor
macro StressK22(u1, u2)
(
mu * (B22(u1, u2) - 1.0)
)//

//  The tangent Kirchhoff stress tensor
macro TanK11(u1, u2, varu1, varu2)
(
mu * d1Aux11(u1, u2, varu1, varu2)
)//

macro TanK12(u1, u2, varu1, varu2)
(
mu * d1Aux12(u1, u2, varu1, varu2)
)//

macro TanK21(u1, u2, varu1, varu2)
(
mu * d1Aux21(u1, u2, varu1, varu2)
)//

macro TanK22(u1, u2, varu1, varu2)
(
mu * d1Aux22(u1, u2, varu1, varu2)
)//

//  Elastic coefficients
real mu = 5.e2; //  kg/cm^2

//  Stress loads
real Pa = -3.e2;

//  The wound radius
real InnerRadius = 1.e0;

//  The outer (truncated) radius
real OuterRadius = 4.e0;

//  Extension of the inner ellipse ((major axis) - (minor axis))
real InnerEllipseExtension = 1.e0;

int m = 40, n = 20;

border InnerEdge(t = 0, 2.0*pi) {x = (1.0 + InnerEllipseExtension) * InnerRadius * cos(t); y = InnerRadius * sin(t); label = 1;}

border OuterEdge(t = 0, 2.0*pi) {x = (1.0 + 0.0 * InnerEllipseExtension) * OuterRadius * cos(t); y = OuterRadius * sin(t); label = 2;}

mesh Th = buildmesh(InnerEdge(-m) + OuterEdge(n));

plot(Th);
fespace Vh(Th, Pk);
Vh [u1n,u2n];

varf neoHookeanInc ([varu1, varu2], [w1, w2]) =
int2d(Th, qforder=1)
( // BILINEAR part
-(
  StressK11 (u1n, u2n) * d3Aux11(u1n, u2n, varu1, varu2, w1, w2)
+ StressK12 (u1n, u2n) * d3Aux12(u1n, u2n, varu1, varu2, w1, w2)
+ StressK21 (u1n, u2n) * d3Aux21(u1n, u2n, varu1, varu2, w1, w2)
+ StressK22 (u1n, u2n) * d3Aux22(u1n, u2n, varu1, varu2, w1, w2)
)
+ TanK11 (u1n, u2n, varu1, varu2) * d4Aux11(w1, w2, u1n, u2n)
+ TanK12 (u1n, u2n, varu1, varu2) * d4Aux12(w1, w2, u1n, u2n)
+ TanK21 (u1n, u2n, varu1, varu2) * d4Aux21(w1, w2, u1n, u2n)
+ TanK22 (u1n, u2n, varu1, varu2) * d4Aux22(w1, w2, u1n, u2n)
)
+
 int2d(Th, qforder=1)
( // LINEAR part
  StressK11 (u1n, u2n) * d4Aux11(w1, w2, u1n, u2n)
+ StressK12 (u1n, u2n) * d4Aux12(w1, w2, u1n, u2n)
+ StressK21 (u1n, u2n) * d4Aux21(w1, w2, u1n, u2n)
+ StressK22 (u1n, u2n) * d4Aux22(w1, w2, u1n, u2n)
)

//  Choose one of the following two boundary conditions involving Pa:

// Load vectors normal to the boundary:
 + int1d(Th,1)( Pa * (w1*N.x + w2*N.y) )

//  Load vectors tangential to the boundary:
// + int1d(Th,1)( Pa * (w1*N.y - w2*N.x) )

   + on(2, varu1 = 0, varu2 = 0);

int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    int s = getARGV("-split", 1);
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

Mat A(Vh.ndof, intersection, D, bs = 2);
Vh<real> def(Rb)[3];
[Rb[0], RbB[0]] = [1, 0];
[Rb[1], RbB[1]] = [0, 1];
[Rb[2], RbB[2]] = [y, -x];
set(A, sparams = "-ksp_converged_reason -pc_type gamg", nearnullspace = Rb);
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u1n[], inPETSc, inverse = true, exchange = true);
    real[int] out(Vh.ndof);
    out = neoHookeanInc(0, Vh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u1n[], inPETSc, inverse = true, exchange = true);
    A = neoHookeanInc(Vh, Vh, tgv = -2);
    return 0;
}
real[int] xPETSc;
[u1n, u2n] = [0.0, 0.0];
ChangeNumbering(A, u1n[], xPETSc);
SNESSolve(A, funcJ, funcRes, xPETSc, sparams = "-snes_monitor -snes_linesearch_monitor -snes_type newtonls -snes_converged_reason -snes_view -snes_rtol 1e-4");
ChangeNumbering(A, u1n[], xPETSc, inverse = true, exchange = true);
plotMPI(Th, [u1n, u2n], Pk, def, real, cmm = "Global solution");
real alpha = 1.0;
mesh ThMoved = movemesh(Th, [x + alpha * u1n, y + alpha * u2n]);
u1n[] = mpirank;
macro def1(u)u// EOM
plotMPI(ThMoved, u1n, P1, def1, real, cmm = "Global moved solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro partitioner()metis// EOM      // metis, scotch, or parmetis
macro dimension()3// EOM            // 2D or 3D
load "Element_Mixte3d"
include "macro_ddm.idp"
include "cube.idp"

macro def(i)[i, i#y, i#z]// EOM             // vector field definition
macro init(i)[i, i, i]// EOM                // vector field initialization
macro defPart(u)u// EOM                     // partition of unity definition
macro initPart(u)u// EOM                    // partition of unity initialization
macro Curl(ux, uy, uz)[dy(uz)-dz(uy), dz(ux)-dx(uz), dx(uy)-dy(ux)]// EOM
macro CrossN(ux, uy, uz)[uy*N.z-uz*N.y, uz*N.x-ux*N.z, ux*N.y-uy*N.x]// EOM
func Pk = Edge03d;
func PkPart = Edge03ds0;

int Dirichlet = 1, Robin = 2;

int overlap = getARGV("-overlap", 2);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - maxwell-3d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

int [int,int] LL = [[1,2], [3,4], [5,6]];
real[int, int] BB = [[0,1], [0,1], [0,1]];
int[int] NN = [getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10)];
int[int] CC = [1, 1, 1];
mesh3 Th = Cube(NN, BB, LL);
func k = 6 * pi;
int[int] chlab = [1, Robin, 2, Robin, 3, Robin, 4, Robin, 5, Robin, 6, Robin];
Th = change(Th, refface = chlab);

fespace Wh(Th, Pk);

mesh3 ThBorder;
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;
{
    buildOverlapEdge(Th, ThBorder, 10, s, overlap, intersection, D, Pk, mpiCommWorld, 0, PkPart, defPart, initPart)
}

matrix<complex> Mat;
matrix<complex> Opt;
complex[int] rhs(Wh.ndof);
{
    mesh3 ThAugmented = Th + ThBorder;
    ThBorder = Cube(CC, BB, LL);
    fespace WhAugmented(ThAugmented, Pk);
    varf vPb([Ex,Ey,Ez],[vx,vy,vz]) =
        int3d(ThAugmented)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
        - int3d(ThAugmented)(k^2*[vx,vy,vz]'*[Ex,Ey,Ez])
        - int2d(ThAugmented, Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
        + on(Dirichlet, Ex=0, Ey=0, Ez=0);
    Mat = vPb(WhAugmented, WhAugmented, solver=GMRES);
    func f = exp(-((x-0.5)^2+(y-0.5)^2+(z-0.5)^2)*60);
    varf vPbRhs([Ex,Ey,Ez],[vx,vy,vz]) =
        - int3d(ThAugmented)([vx,vy,vz]'*[0,0,f])
        + on(Dirichlet, Ex=0,Ey=0,Ez=0);
    if(mpisize > 1) {
        complex[int] rhsFull(WhAugmented.ndof);
        rhsFull = vPbRhs(0, WhAugmented);
        matrix R = interpolate(Wh, WhAugmented);
        R.thresholding(1.0e-10);
        renumbering(Mat, R, rhsFull, rhs);
    }
    else
        rhs = vPbRhs(0, WhAugmented);
}

schwarz<complex> A(Mat, intersection, D, scaled = false, communicator = mpiCommWorld);
set(A, sparams = "-hpddm_schwarz_method oras");

complex[int] nEx(Wh.ndof);
nEx = 0.0;

int solver = getOption("schwarz_method");
if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
    varf vPbOpt([Ex,Ey,Ez],[vx,vy,vz]) =
        int3d(Th)(Curl(vx,vy,vz)'*Curl(Ex,Ey,Ez))
        - int3d(Th)(k^2*[vx,vy,vz]'*[Ex,Ey,Ez])
        - int2d(Th, Robin)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
        - int2d(Th, fakeInterface)(1i*k*CrossN(vx,vy,vz)'*CrossN(Ex,Ey,Ez))
        + on(Dirichlet, Ex=0, Ey=0, Ez=0);
    Opt = vPbOpt(Wh, Wh);
}
DDM(A, rhs, nEx, O = Opt);
Wh<complex> def(sol);
sol[] = nEx;
medit("Global solution", Th, [real(sol), real(soly), real(solz)]);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
macro dimension()2// EOM
include "macro_ddm.idp"

real c = 6.25;
int N  = 80;

// domain: unit square
border aa(t=0,1) { x=t;   y=0;   };
border bb(t=0,1) { x=1;   y=t;   };
border cc(t=0,1) { x=1-t; y=1;   };
border dd(t=0,1) { x=0;   y=1-t; };

mesh M = buildmesh(aa(N)+bb(N)+cc(N)+dd(N));

load "Element_P3"
func Pk = P3;
Mat A;
macro MRefinementFactor()getARGV("-split", 1)//
MatCreate(M, A, Pk);
fespace Vh(M, Pk);
Vh u;
func BC = cos(pi*x)*cos(pi*y);
varf vInit(w, v) = on(aa, bb, cc, dd, w = BC);
varf vJ(w, v) = int2d(M)(dx(w)*dx(v) + dy(w)*dy(v) - c*exp(u)*w*v) + on(aa, bb, cc, dd, w = 0);
varf vRes(w, v) = int2d(M)(dx(u)*dx(v) + dy(u)*dy(v) - c*exp(u)*v) + on(aa, bb, cc, dd, w = u);
set(A, sparams = "-pc_type asm -sub_pc_type lu -ksp_converged_reason");
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    real[int] out(Vh.ndof);
    out = vRes(0, Vh, tgv = -2);
    real[int] outPETSc;
    ChangeNumbering(A, out, outPETSc);
    return outPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(A, u[], inPETSc, inverse = true, exchange = true);
    A = vJ(Vh, Vh, tgv = -2);
    return 0;
}
real[int] bPETSc;
u[] = vInit(0, Vh, tgv = -2);
ChangeNumbering(A, u[], bPETSc);
real[int] xPETSc = bPETSc;
SNESSolve(A, funcJ, funcRes, bPETSc, xPETSc, sparams = "-snes_monitor -snes_linesearch_monitor -snes_type newtontr -snes_converged_reason -snes_view");
ChangeNumbering(A, u[], xPETSc, inverse = true, exchange = true);
macro def(u)u//
plotMPI(M, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "function-PETSc"
int isInitialized = PetscInitialized();
assert(isInitialized == 1);
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"

mesh Th;
{
    real R = 5, L = 35;
    border a(t=0, 2*pi) {x=2.0+cos(t)/2; y=sin(t)/2; label=1;}
    border b(t=pi/2, 3*pi/2) {x=cos(t)*R; y=sin(t)*R; label=2;}
    border c(t=0, 1) {x=t^0.9*L; y=-R; label=3;}
    border d(t=1, 0) {x=t^0.9*L; y=R; label=3;}
    border e(t=-R, R) {x=L; y=t; label=0;}
    real ratio = 1.0;
    Th = buildmesh(a(-70*ratio) + b(30*ratio) + c(80*ratio) + d(80*ratio) + e(20*ratio));
    plot(Th);
}

macro dimension()2//
include "macro_ddm.idp"

macro def(i)[i, i#B, i#C]//
macro init(i)[i, i, i]//
func Pk = [P2, P2, P1];
macro grad(u)[dx(u), dy(u)]//
macro div(u)(dx(u#1) + dy(u#2))//
macro UgradV(u, v)[[u#1, u#2]' * [dx(v#1), dy(v#1)],
                   [u#1, u#2]' * [dx(v#2), dy(v#2)]]//
real Re = getARGV("-Re", 50.0);
real nu;
fespace Wh(Th, Pk); // complete space [u, v, p]
fespace Qh(Th, P1); // pressure space for Schur complement

Mat J;
int[int] n2o;       // need to know how to go from the local to the global mesh
mesh ThBackup = Th; // need to backup the original global mesh
macro ThN2O()n2o//
MatCreate(Th, J, Pk);
Wh [uc1, uc2, pc] = [1, 0, 0];
varf vRes([u1, u2, p], [v1, v2, q]) = int2d(Th)(
      nu * (grad(uc1)' * grad(v1) +
            grad(uc2)' * grad(v2))
    + UgradV(uc, uc)' * [v1, v2]
    - pc * div(v) - div(uc) * q)
    + on(3, u1 = uc1-1)
    + on(1, u1 = uc1-0, u2 = uc2-0)
    + on(2, u1 = uc1-1, u2 = uc2-0);
varf vJ([u1, u2, p], [v1, v2, q]) = int2d(Th)(
      (UgradV(uc, u) + UgradV(u, uc))' * [v1, v2] +
      nu * (grad(u1)' * grad(v1) +
            grad(u2)' * grad(v2))
    - p * div(v) - div(u) * q)
    + on(3, u1 = uc1-1)
    + on(1, u1 = uc1-0, u2 = uc2-0)
    + on(2, u1 = uc1-1, u2 = uc2-0);
set(J, sparams = "-pc_type lu");
func real[int] funcRes(real[int]& inPETSc) {
    ChangeNumbering(J, uc1[], inPETSc, inverse = true, exchange = true);
    real[int] out(Wh.ndof);
    out = vRes(0, Wh, tgv = -1);
    ChangeNumbering(J, out, inPETSc);
    return inPETSc;
}
func int funcJ(real[int]& inPETSc) {
    ChangeNumbering(J, uc1[], inPETSc, inverse = true, exchange = true);
    J = vJ(Wh, Wh, tgv = -1);
    return 0;
}
for(int i = 0; i < 50 && Re < 100.0; ++i) {
    real[int] xPETSc;
    ChangeNumbering(J, uc1[], xPETSc);
    nu = 1.0/Re;
    SNESSolve(J, funcJ, funcRes, xPETSc, sparams = "-snes_monitor ");
    ChangeNumbering(J, uc1[], xPETSc, inverse = true, exchange = true);
    if(!NoGraphicWindow) {
        Qh only = pc;
        macro def1(i)i//
        plotMPI(Th, only, P1, def1, real, cmm = "Pressure for Re = " + Re);
        fespace Zh(Th, [P2, P2]);
        Zh [onlyU, onlyV] = [uc1, uc2];
        macro def2(i)[i, i#B]//
        plotMPI(Th, [onlyU, onlyV], [P2, P2], def2, real, cmm = "Velocity for Re = " + Re);
    }
    Re *= 1.5;
    if(usedARGV("-adaptation") != -1) {
        fespace WhBackup(ThBackup, Pk);
        WhBackup def(uG), def(uReduce);
        uc1[] .*= J.D; // scale the solution by the partition of unity to avoid multiple summations on the overlap
        int[int] rest = restrict(Wh, WhBackup, n2o);
        for[i, v : rest] uReduce[][v] = uc1[][i]; // going from local to global
        mpiAllReduce(uReduce[], uG[], mpiCommWorld, mpiSUM);
        if(mpirank == 0) {
            ThBackup = adaptmesh(ThBackup, def(uG));
            plot(ThBackup, wait = 1);
        }
        broadcast(processor(0), ThBackup);
        def(uG) = def(uG);
        Th = ThBackup;
        Mat Adapt;
        MatCreate(Th, Adapt, Pk) // decompose the adapted mesh
        J = Adapt; // replace the old Jacobian
        rest = restrict(Wh, WhBackup, n2o);
        [uc1, uc2, pc] = [0, 0, 0]; // just to trigger a resize
        for[i, v : rest] uc1[][i] = uG[][v]; // going from global to local
    }
}
DmeshSave(Th, "navier-stokes-2d");
ofstream sol("navier-stokes-2d_" + mpirank + "_" + mpisize + ".sol");
sol << uc1[];
// This codes shows how to calculate the eigenvalue spectrum of
// the Schrodinger operator with quadratic potential (the
// Quantum Harmonic Oscillator) on a 2d domain, using SLEPc.
//
// Here, we consider the problem of a 1d quantum harmonic oscillator:
//   -0.5 \nabla^2 u + 0.5*(x^2+y^2)* u = E u
//  since this is an hermitian operator, its eigenvalues E are real
//  The eigenspectrum is the set integrers :
//    E_n = n+1 (n \in N)
//  in 2d, the eigenstates are degenerate with degeneracy n+1.
//  In other words, the eigenspectrum is
//    E_0 = 1 deg(0)=1  ->  ground-state (unique)
//    E_1 = 2 deg(1)=2  ->  first excited states (two)
//    E_2 = 3 deg(1)=3  ->  second excited states (three)
//    ....
//
//   See e.g. :
//   - Complement D-VI in Quantum mechanics Vol. 1 by C. Cohen-Tannoudji, B. Diu, F. Laloe
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg schrodinger-2d-harmonic-oscillator-SLEPc.edp \
//        -split 1 -npts 800 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

func Pk = P1;                    // Finite-element space

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 800) ; // Number of points on the perimeter
real Lx    = getARGV("-lx"   , 20.0); // Dimension of the domain
real Ly    = getARGV("-ly"   , 20.0); // Dimension of the domain
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- schrodinger-2d-harmonic-oscillator-SLEPc.edp "     << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts
        << "  Domain size [Lx,Ly]    = ["<<Lx<<","<<Ly<<"]"<< endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels=[1,2,3,4]; // labels : bottom, right, top, left sides

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Xpts= int(0.5*Npts*Lx/(Lx+Ly)); // pts on the x-axis sides
    int Ypts= int(0.5*Npts*Ly/(Lx+Ly)); // pts on the y-axis sides

    Th = square(Xpts,Ypts,[Lx*(x-0.5),Ly*(y-0.5)],label=Labels);
    // .....
    build(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld // Communicator
         );
}
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
( 0.5*(dx(uh)*dx(vh)+dy(uh)*dy(vh))
+( 0.5*(x^2+y^2)-sigma)*uh*vh)//  Bilinear form
//  +on(Labels[3], uh = 0.0)      //  Boundary Conditions bottom
//  +on(Labels[2], uh = 0.0)      //  Boundary Conditions right
//  +on(Labels[1], uh = 0.0)      //  Boundary Conditions top
//  +on(Labels[0], uh = 0.0)      //  Boundary Conditions left
;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
( uh*vh )               //  Bilinear form
;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type lu "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp = EigenVEC[i];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "hpddm_substructuring"         // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm_substructuring.idp" // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
macro BC(u, val)u = val// EOM       // Dirichlet boundary conditions
func Pk = P1;                       // finite element space

int labNeumann = getARGV("-labNeumann", 2);                     // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-2d-substructuring-PETSc.edp - input parameters: refinement factor = " << s << endl;
}

mesh Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
int[int] interfaceNb;         //
{
    int[int] l = [2, 1, 2, 2];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildSubstructuring(Th, interfaceNb, 10, 1, labNeumann, s, intersection, Pk, BC, mpiCommWorld, false)
}

func f = 10;
varf vPb(u, v) = int2d(Th)(grad(u)' * grad(v)) + int2d(Th)(f * v) + on(1, u = 0.0);
matrix<real> Loc = vPb(Wh, Wh, sym = 1, tgv = -2); // local operator
real[int] rhs = vPb(0, Wh, tgv = -2);              // local right-hand side

MatIS A(Loc, intersection, interfaceNb, communicator = mpiCommWorld);
Wh<real> def(u) = 0.0;    // local solution

int[int] numbering;
GlobalNumbering(A, numbering);
cout << "GlobalNumbering  " <<  numbering.n << " " << u[].n <<  endl; 
for(int i = 0; i < u[].n; ++i)
    u[][i] = numbering[i];
OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global numbering");

set(A, sparams = "-pc_type bddc -ksp_monitor");
u[] = A^-1 * rhs;

OriginalNumbering(A, u[], interfaceNb);
plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
load "msh3"
load "medit"
macro dimension()3L//
include "macro_ddm.idp"

real R  = 3.0, r = 1.0;
real h  = 0.1;
int nx  = R*2*pi/h;
int ny  = r*2*pi/h;
func tx = (R+r*cos(y*pi*2))*cos(x*pi*2);
func ty = (R+r*cos(y*pi*2))*sin(x*pi*2);
func tz = r*sin(y*pi*2);

meshL Th = segment(nx, [tx,ty,tz], removeduplicate=true);

Mat A;
int[int] n2o;
macro ThN2O()n2o//
MatCreate(Th,A,P1);
fespace Vh(Th,P1);

macro Grad3(uvw) [dx(uvw), dy(uvw), dz(uvw)]//

real sigma = 1;
varf aS(u,v) = int1d(Th)(Grad3(u)'*Grad3(v));
varf mS(u,v) = int1d(Th)(u*v);

matrix LocA = aS(Vh, Vh);
A = LocA;
matrix LocB = mS(Vh, Vh);
Mat B(A, LocB);
int nev = 10;
real[int] ev(nev);
Vh[int] eV(nev);

string ssparams =
  " -eps_nev " + nev       +
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   +
  " -st_type sinvert "     +
  " -st_pc_type cholesky " +
  " -eps_view"             +
  " -eps_gen_hermitian";
int k = EPSSolve(A, B, values = ev, vectors = eV, sparams = ssparams);

for(int i = 0; i < k; ++i) {
    macro params()cmm = "Eigenvector #" + i + ", eigenvalue =" + ev[i], wait = 1, fill = 1, value = 1//
    plotD(Th, eV[i], params);
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

macro dimension()2// EOM
include "macro_ddm.idp"

border circle(t=0, 2*pi) { x=cos(t); y=sin(t); label=1; }
mesh Th = buildmesh(circle(100));

IFMACRO(paraview)
load "hpddm"
ENDIFMACRO

real[int] D;
PartitionCreate(Th, D, P0);
fespace Ph(Th, P0);
fespace Vh(Th, P1);
fespace Wh(Th, P2);
Ph p;
p[] = D;
PartitionCreate(Th, D, P1);
Vh v;
v[] = D;
PartitionCreate(Th, D, P2);
Wh w;
w[] = D;
macro def(u)u// EOM
plotMPI(Th, p, P0, def, real, cmm = "P_0 partition of unity");
plotMPI(Th, v, P1, def, real, cmm = "P_1 partition of unity");
plotMPI(Th, w, P2, def, real, cmm = "P_2 partition of unity");
IFMACRO(paraview)
int[int] fforder = [0, 1, 1];
savevtk("PartitionCreate.vtu", Th, p, v, w, dataname = "p v w", order = fforder);
ENDIFMACRO
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                 // scalar field definition
macro init(i)i// EOM                // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
int[int] labPeriodic = [2, 4, 1, 3];
macro Pk() P2, periodic=[[labPeriodic[0],x+y], [labPeriodic[1],x+y], [labPeriodic[2],x-y], [labPeriodic[3],x-y]]// EOM

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - diffusion-periodic-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

real r = 0.25;
border a(t=0,1)    { x = -t+1; y = t;             label = 1; };
border b(t=0,1)    { x = -t; y = 1-t;             label = 2; };
border c(t=0,1)    { x = t-1; y = -t;             label = 3; };
border d(t=0,1)    { x = t; y = -1+t;             label = 4; };
border e(t=0,2*pi) { x = r*cos(t); y = -r*sin(t); label = 0; };

mesh ThBorder, Th = buildmesh(a(getARGV("-global", 40)) + b(getARGV("-global", 40)) + c(getARGV("-global", 40)) + d(getARGV("-global", 40)) + e(getARGV("-global", 40)));
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    buildOverlapPeriodic(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded, labPeriodic)
}

func f = (y+x+1) * (y+x-1) * (y-x+1) * (y-x-1);
real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    varf vPb(u, v) = int2d(ThAugmented)(grad(u)' * grad(v)) - int2d(ThAugmented)((0.39 - f) * v) + on(0, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);
set(A, sparams = "-hpddm_schwarz_method ras -hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(grad(u)' * grad(v)) + int1d(Th, fakeInterface)(transmission * (u * v));
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(grad(u)' * grad(v)) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

Wh<real> def(u);    // local solution

if(Opt.n > 0)       // optimized Schwarz methods
    DDM(A, rhs, u[], excluded = excluded, ret = ret, O = Opt);
else
    u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension 3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u), dz(u)]// EOM    // three-dimensional gradient
func Pk = P1;                               // finite element space

int s = getARGV("-split", 1);                                   // refinement factor

int[int] LL = [2,2, 1,2, 2,2];
mesh3 Th = cube(1, 1, 1, [x, y, z]);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    Th = cube(getARGV("-global", 10), getARGV("-global", 10), getARGV("-global", 10), [x, y, z], label = LL);      // global mesh
    build(Th, s, intersection, D, Pk, mpiCommWorld)
}

varf vPb(u, v) = int3d(Th)(grad(u)' * grad(v)) + int3d(Th)(v) + on(1, u = 1.0);
matrix<real> Mat = vPb(Wh, Wh, tgv = -1);
real[int] rhs = vPb(0, Wh, tgv = -1);

schwarz A(Mat, intersection, D);
set(A, sparams = "-hpddm_schwarz_coarse_correction deflated -hpddm_geneo_nu 10");

int solver = getOption("schwarz_method");
if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
    matrix<real> noPen = vPb(Wh, Wh, sym = 1);
    AttachCoarseOperator(mpiCommWorld, A, A = noPen);
}

Wh<real> def(u);    // local solution

u[] = A^-1 * rhs;

real[int] err(u[].n);
err = A * u[];      // global matrix-vector product
err -= rhs;

plotMPI(Th, u, Pk, def, real, cmm = "Global solution");
u[] = err;
plotMPI(Th, u, Pk, def, real, cmm = "Global residual");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"                        // PETSc plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)[i, i#B, i#C]// EOM     // vector field definition
macro init(i)[i, i, i]// EOM        // vector field initialization
macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
real Sqrt = sqrt(2.);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]// EOM
macro div(u)(dx(u) + dy(u#B))// EOM
func Pk = [P2, P2, P1];             // finite element space

mesh Th;
{
    mesh ThGlobal = square(getARGV("-global", 40), getARGV("-global", 40), [x, y]); // global mesh
    ThGlobal = trunc(ThGlobal, (x < 0.5) || (y < 0.5), label = 5);
    Th = movemesh(ThGlobal, [-x, y]);
    Th = ThGlobal + Th;
}
Mat A;
macro ThRefinementFactor()getARGV("-split", 1)//
MatCreate(Th, A, Pk);

fespace Wh(Th, Pk);
varf vPb([u, uB, p], [v, vB, q]) = int2d(Th)(grad(u)' * grad(v) + grad(uB)' * grad(vB) - div(u) * q - div(v) * p + 1e-10 * p * q) + on(1, 3, 5, u = 0, uB = 0) + on(2, u = y*(0.5-y), uB = 0);
real[int] rhs = vPb(0, Wh, tgv = -1);
Wh<real> def(u) = [1.0, 1.0, 2.0];
string[int] names(2);
names[0] = "velocity";
names[1] = "pressure";

A = vPb(Wh, Wh, tgv = -1);
set(A, prefix = "block_", sparams = "-block_pc_type fieldsplit -block_ksp_type fgmres -block_pc_fieldsplit_type schur -block_pc_fieldsplit_detect_saddle_point "
+ " -block_fieldsplit_velocity_pc_type lu "
+ " -block_ksp_monitor -block_ksp_view", fields = u[], names = names);
u[] = 0.0;
u[] = A^-1 * rhs;
macro def2(u)[u, u#B]// EOM
macro def1(u)u// EOM
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity with fieldsplit preconditioner");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure with fieldsplit preconditioner");
set(A, prefix = "monolithic_", sparams = "-monolithic_pc_type lu -monolithic_ksp_view -monolithic_ksp_rtol 1e-6");
u[] = 0.0;
u[] = A^-1 * rhs;
plotMPI(Th, def2(u), [P2, P2], def2, real, cmm = "Global velocity with monolithic preconditioner");
plotMPI(Th, uC, P1, def1, real, cmm = "Global pressure with monolithic preconditioner");
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

include "macro_ddm.idp"
load "PETSc"

mesh Th = square(40, 40);
func Pk = P1;
fespace Vh(Th, Pk);
varf vPb(u, v) = int2d(Th)(dx(u) * dx(v) + dy(u) * dy(v)) + on(1, 2, 3, 4, u = 0.0);
DmeshCreate(Th);
Mat A;
MatCreate(Th, A, Pk);
matrix Loc = vPb(Vh, Vh, tgv = -2);
A = Loc;
mesh ThTrunc;
matrix R;
real[int] bb(4);
boundingbox(Th, bb);
fespace VhTrunc(ThTrunc, Pk);
matrix prod;
if(bb[0] < 0.5) { // careful because some subdomains may not satisfy this condition!
    int[int] n2o;
    ThTrunc = trunc(Th, x < 0.5, new2old = n2o);
    int[int] rest = restrict(VhTrunc, Vh, n2o);
    real[int] V(VhTrunc.ndof);
    V = 1;
    int[int] I = 0:VhTrunc.ndof-1;
    R = [I, rest, V];
    R.resize(VhTrunc.ndof, Vh.ndof);
    prod = Loc * R';
}
Mat B(A, restriction = R); // if the above condition is not met,
Mat C(A, B, prod);         // these two distributed matrices won't have any local unknowns
real[int] values;
Vh[int] lvec(10);
VhTrunc[int] rvec(10);
int nsv = SVDSolve(C, sparams = "-svd_largest -svd_view_values -svd_type cyclic -svd_nsv 10", values = values, lvectors = lvec, rvectors = rvec);
func real[int] prodFunc(real[int]& up) {
    real[int] u;
    ChangeNumbering(B, u, up, inverse = true, exchange = true); // from PETSc to FreeFEM numbering + need to exchange ghost values
    real[int] v = R' * u;
    u.resize(Loc.n);
    u = A * v;
    ChangeNumbering(A, u, up); // from FreeFEM to PETSc numbering
    return up;
}
func real[int] prodFuncTranspose(real[int]& utp) {
    real[int] ut;
    ChangeNumbering(A, ut, utp, inverse = true, exchange = true); // from PETSc to FreeFEM numbering + need to exchange ghost values
    real[int] v = A' * ut;
    ut.resize(R.n);
    ut = R * v;
    ChangeNumbering(B, ut, utp); // from FreeFEM to PETSc numbering
    return utp;
}
Mat MF(A, B, prodFunc, transpose = prodFuncTranspose); // defines a "rectangular" operator (I = A.size and J = B.size)
ObjectView(MF, format = "info");
real[int] valuesMF;
real[int, int] lvecMF(A.n, 10);
real[int, int] rvecMF(B.n, 10);
int nsvMF = SVDSolve(MF, sparams = "-svd_largest -svd_type cyclic -svd_nsv 10", values = valuesMF, larray = lvecMF, rarray = rvecMF);
values -= valuesMF;
assert(values.linfty < 1.0e-4 && nsv == nsvMF);

Vh u, uMF, du;
VhTrunc v, vMF, dv;
for (int idSV = 0; idSV < nsv; ++idSV)
{
  // check same (or opposite) left vectors
  ChangeNumbering(A, uMF[], lvecMF(:,idSV), inverse = true, exchange = true);
  du[] = lvec[idSV][] - uMF[];
  if(du[].linfty >= 1.0e-6) { // sign flip?
      du[] = lvec[idSV][];
      du[] *= -1.0;
      du[] -= uMF[];
  }
  assert(du[].linfty < 1.0e-4);

  // check same (or opposite) right vectors
  ChangeNumbering(B, vMF[], rvecMF(:,idSV), inverse = true, exchange = true);
  dv[] = rvec[idSV][] - vMF[];
  if(dv[].linfty >= 1.0e-6) {
      dv[] = rvec[idSV][];
      dv[] *= -1.0;
      dv[] -= vMF[];
  }
  assert(dv[].linfty < 1.0e-4);

  // check C v = sigma u
  real[int] temp1(A.n), temp2(lvecMF.n);
  MatMult(MF, rvecMF(:,idSV), temp1); // rectangular MF, so use vectors un PETSc numbering + MatMult
  temp2 = valuesMF[idSV] * lvecMF(:,idSV);
  temp2 -= temp1;
  assert(temp2.linfty < 1.0e-4);
  MatMult(MF, rvecMF(:,idSV), temp2);
  ChangeNumbering(A, temp1, temp2, inverse = true, exchange = true);
  temp2.resize(uMF[].n);
  temp2 = MF * vMF[];
  temp2 -= temp1;
  assert(temp2.linfty < 1.e-4);
}
//  run with MPI:  ff-mpirun -np 2 script.edp
// NBPROC 2

macro dimension()3// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro def2(i)[i, i#B]// EOM
macro init2(i)[i, i]// EOM
func Pk = P1;                               // finite element space
func Zk = [P1, P2];                         // finite element space

mesh3 Th = cube(1, 1, 1);
fespace Wh(Th, Pk);            // local finite element space
fespace Qh(Th, Zk);            // local finite element space
int[int][int] intersectionP;   // local-to-neighbors renumbering
int[int][int] intersectionZ;   // local-to-neighbors renumbering
real[int] DP;                  // partition of unity
real[int] DZ;                  // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    mesh3 ThBorder;
    Th = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5));    // global mesh
    fespace Ph(Th, P0);
    real[int] part(Ph.ndof);
    if(mpirank == 0)
        partitionerSeq(part, Th, mpisize);
    partitionerPar(part, Th, mpiCommWorld, mpisize);
    buildOverlapWithPartitioning(Th, ThBorder, part, 11111, 1, 1, intersectionZ, DP, Pk, mpiCommWorld, false);
    Th = cube(getARGV("-global", 5), getARGV("-global", 5), getARGV("-global", 5)); // need to reload the global mesh because it is destroyed in ''build*''
    buildOverlapEdgeWithPartitioning(Th, ThBorder, part, 22222, 1, 1, intersectionP, DZ, Zk, mpiCommWorld, false, Zk, def2, init2);
    ThBorder = cube(1, 1, 1);
}
// This codes shows how to solve an eigenvalue problems
// in different coordinate systems. The example here is
// the Laplace equation in spherical coordinates, in the
// [theta,phi] plane. Solutions are the spherical harmonics.
// the [theta,phi] plane is a 2d domain, using SLEPc.
//
// Here, we consider the problem in spherical coordinates
// \theta \in [0,\pi] and \phi \in [0,2\pi], for  a fixed
// radius: -\nabla^2 u = E u
//
//  The eigenspectrum is :
//    E_n = n(n+1)  ;  deg(n) = 2n+1
//
// Usage :
// mpirun -np 4 FreeFem++-mpi -wg laplace-2d-spherical-harmonics-SLEPc.edp \
//        -split 1 -npts 400 -nev 15 -sigma 0.0
//
// Authors: Julien Garaud <julien.garaud@gmail.com>
//          Pierre Jolivet <pierre.jolivet@enseeiht.fr>

/***************************************/
/*         Geometry parameters         */
/***************************************/
int[int] Labels = [1,2,3,4]; // labels : bottom, right, top, left sides
int[int] labPeriodic = [Labels[0],Labels[2]];

/**************************************/
/*     Load PETSc & SLEPc macros      */
/**************************************/
load "PETSc"                             // PETSc plugin
macro dimension(      )2// End Of Macro  // 2D or 3D
include "macro_ddm.idp"                  // Additional DDM functions
macro def(i)i// EOM
macro init(i)i// EOM

macro Pk() P1, periodic=[[Labels[0],x],[Labels[2],x]]//EOM

/***************************************/
/*    Options for distributed solver   */
/***************************************/
int s      = getARGV("-split", 1)   ; // Refinement factor
//
int Npts   = getARGV("-npts" , 200) ; // Number of points on the perimeter
//
int nEV    = getARGV("-nev"  ,  5)  ; // Number of eigenvalues
real sigma = getARGV("-sigma", 0.0) ; // Shift
//
real radius = getARGV("-radius",1.0); // Radius of the sphere
/***************************************/
/*     Verbosity and passed options    */
/***************************************/
if(verbosity > 0 && mpirank == 0) {
    cout << "********************************************"  << endl
        << " --- " << mpirank << "/" << mpisize
        << "- laplace-2d-spherical-harmonics-SLEPc.edp "   << endl
        << "********************************************"  << endl
        << "- input parameters: "                          << endl
        << "  refinement factor  = " << s                  << endl
        << "********************************************"  << endl
        << "  nb of pts on perimeter = " << Npts           << endl
        << "********************************************"  << endl
        << "  nb of eigenvalues  = " << nEV                << endl
        << "  value of the shift = " << sigma              << endl
        << "********************************************"  << endl
        << "  Radius of the sphere = " << radius           << endl
        << "********************************************"  << endl
        << endl;
}
/***************************************/
/*   ###############################   */
/***************************************/
mesh Th = square(1, 1);      // Local mesh
int[int][int] intersection;   // Local-to-neighbors renumbering
real[int] D;                  // Partition of unity

/***************************************/
/*         Finite Element space        */
/***************************************/
// Definition of the finite element space on the domain Th
// P1 are the first order Lagrange elements
fespace Vh(Th, Pk);      // local finite element space

/***************************************/
/*            ##############           */
/***************************************/
{ // Construction of the rectangular domain
    int Thetapts = int(Npts/6.0); // pts on the x-axis sides
    int Phipts   = int(Npts/3.0); // pts on the y-axis sides

    Th = square(Thetapts,Phipts,[x*pi,2.0*pi*y],label=Labels);
    // .....
    buildPeriodic(Th,       // The local mesh
            s,        // Refinement factor
            intersection, // local-to-neighbors renumbering
            D,        // partition of unity
            Pk,           // FE-space
            mpiCommWorld, // Communicator
            labPeriodic   // Array of labels for periodic boundaries
         );
}
/***********************************************************************/
/*         Coordinate dependant differential operators                 */
/***********************************************************************/
/*        Spherical coordinates in the (theta,phi)-plane               */
/*                                                                     */
/*                  r     --> not used                                 */
/*                  theta --> x  in [0,pi]                             */
/*                  phi   --> y  in [0,2*pi]                           */
/*                                                                     */
/*           Jacobian determinant on the half-plane                    */
/*              The det(J) = r^2*sin(theta) --> r^2*sin(x)             */
/*                                                                     */
macro Jac()( radius^2*sin(x) )             // End Of Macro /*          */
     /*  The Jacobian                                                  */
/*                                                                     */
/*        The gradiant operator in spherical coordinates               */
/*                                                                     */
/*                d/dr                                                 */
/*       grad =   1/r*d/dtheta              ->  1/radius*d/dx          */
/*                1/(r*sin(theta))*d/dphi   ->                         */
/*                                   1/(radius*sin(x)*d/dy             */
/*                                                                     */
macro Grad(u) [dx(u)/radius,dy(u)/(radius*sin(x))] // End Of Macro /*  */
     /*  The Gradient operator                                         */
macro Lap(u,v) ( Grad(u)'*Grad(v)) //')      // End Of Macro /*        */
     /*  The Laplace operator                                          */
/*                                                                     */
/*                                                                     */
/***********************************************************************/
/***************************************/
/*          Problem parameters         */
/***************************************/

/***************************************/
/*          Problem definition         */
/***************************************/
varf vA(uh,vh)= int2d(Th)        //  Definion of  the problem
  (Jac*(Lap(uh,vh)))//  Bilinear form
  ;

varf vB(uh,vh)= int2d(Th)  //  Definion of  the problem
  ( Jac*uh*vh )           //  Bilinear form
  ;

matrix<real> A = vA(Vh,Vh);
matrix<real> B = vB(Vh,Vh);
/***************************************/
/*      Build distributed matrices     */
/***************************************/
Mat DistA(A, intersection, D);
Mat DistB(DistA, B);
/***************************************/
/*          Problem resolution         */
/***************************************/
real[int]     EigenVAL(0);       // array to store eigenvalues
Vh<real>[int] def(EigenVEC)(1); // array to store eigenvectors

string ssparams =            // Parameters for the distributed EigenValue solver
  " -eps_nev " + nEV       + // Number of eigenvalues
  " -eps_type krylovschur" +
  " -eps_target "+ sigma   + // Shift value
  " -st_type sinvert "     +
  " -st_pc_type cholesky "       +
  " -st_matstructure same "       +
  " -eps_view"             +
  " -eps_gen_hermitian"      // The problem is symmetric
  ;

int k = EPSSolve
(DistA,              // matrix OP = A  sigma*B
 DistB,              //
 vectors = EigenVEC, // Array to store the FEM-EigenFunctions
 values  = EigenVAL, // Array to store the EigenValues
 sparams = ssparams  // Parameters for the distributed EigenValue solver
);

k=min(k,nEV); // some time the number of converged eigen value
              // can be greater than nev;
/***************************************/
/*           View the solution         */
/***************************************/
Vh<real> Temp;

for(int i=0;i<k;i++){
    if(!mpirank) cout << " Eigenvalue #"+i+" = "+EigenVAL[i]<<endl;
    Temp[] = EigenVEC[i][];
    plotMPI(Th,     // The local mesh
            Temp,   // The local solution
            Pk,     // Local FE-space
            def,    // Macro for field definition
            real,   // Type
            cmm = "Psi("+i+")  EV = "+EigenVAL[i]
           )
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "hpddm"                        // HPDDM plugin
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro def(i)i// EOM                         // scalar field definition
macro init(i)i// EOM                        // scalar field initialization
macro grad(u)[dx(u), dy(u)]// EOM           // two-dimensional gradient
func Pk = P2;                               // finite element space

string deflation = getARGV("-deflation", "geneo");              // coarse space construction
int overlap = getARGV("-overlap", 1);                           // geometric overlap between subdomains
int fakeInterface = getARGV("-interface", 10);                  // interface between subdomains
int s = getARGV("-split", 1);                                   // refinement factor
real dt = getARGV("-dt", 0.1);                                 // time step
real mu = 0.01;
int iMax = getARGV("-iMax", 10);                                // number of iterations

mpiComm comm;
int p = getARGV("-hpddm_level_2_p", 1);
bool excluded = splitComm(mpiCommWorld, p, comm, topology = getARGV("-hpddm_level_2_topology", 0), exclude = (usedARGV("-hpddm_level_2_exclude") != -1));

if(verbosity > 0 && mpirank == 0) {
    cout << " --- " << mpirank << "/" << mpisize;
    cout << " - heat-2d.edp - input parameters: refinement factor = " << s << " - overlap = " << overlap << endl;
}

mesh ThBorder, Th = square(1, 1);
fespace Wh(Th, Pk);           // local finite element space
int[int][int] intersection;   // local-to-neighbors renumbering
real[int] D;                  // partition of unity
{
    int[int] l = [1, 1, 1, 1];
    Th = square(getARGV("-global", 40), getARGV("-global", 40), label = l);    // global mesh
    buildOverlap(Th, ThBorder, fakeInterface, s, overlap, intersection, D, Pk, comm, excluded)
}

real[int] rhs;                              // local right-hand side
matrix<real> Mat;                           // local operator
matrix<real> M;                             // local mass matrix
{                                           // local weak form
    mesh ThAugmented = Th + ThBorder;
    fespace Ph(ThAugmented, P0);
    Ph f = x < 0.25 ? 1.0e+3 : 1.0e-3;
    varf vPb(u, v) = int2d(ThAugmented)(u * v + dt * (grad(u)' * grad(v))) + int2d(ThAugmented)(dt * f *  v) + on(1, u = 0.0);
    fespace WhAugmented(ThAugmented, Pk);
    Mat = vPb(WhAugmented, WhAugmented, tgv = -1);
    real[int] rhsFull = vPb(0, WhAugmented, tgv = -1);
    matrix R = interpolate(Wh, WhAugmented);
    varf vPbM(u, v) = int2d(ThAugmented)(u * v);
    M = vPbM(WhAugmented, WhAugmented);
    renumbering(M, R, rhsFull, rhs);
    renumbering(Mat, R, rhsFull, rhs);
}
ThBorder = square(1, 1);

schwarz A(Mat, intersection, D, scaled = false);

matrix<real> Opt;                           // local operator with optimized boundary conditions
pair ret;
{
    int solver = getOption("schwarz_method");
    if(solver == 1 || solver == 2 || solver == 4) { // optimized Schwarz methods
        fespace Ph(Th, P0);
        real kZero = getARGV("-kZero", 10.0);
        Ph transmission = kZero;
        varf vOptimized(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + int1d(Th, fakeInterface)(transmission * (u * v)) + on(1, u = 0.0);
        Opt = vOptimized(Wh, Wh, tgv = -1);
    }
    if(mpisize > 1 && isSetOption("schwarz_coarse_correction")) { // two-level Schwarz methods
        if(excluded)
            AttachCoarseOperator(mpiCommWorld, A/*, A = noPen, B = overlapRestriction, threshold = 2. * h[].max / diam*/);
        else {
            varf vPbNoPen(u, v) = int2d(Th)(u * v + dt * (grad(u)' * grad(v))) + on(1, u = 0.0);
            matrix<real> noPen = vPbNoPen(Wh, Wh, sym = 1);
            if(deflation == "geneo") // standard GenEO, no need for RHS -> deduced from LHS (Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen/*, threshold = 2. * h[].max / diam,*/, ret = ret);
            else if(deflation == "dtn") {
                varf vMass(def(u), def(v)) = int1d(Th, fakeInterface)(u * v);
                matrix<real> massMatrix = vMass(Wh, Wh, sym = 1);
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = massMatrix, pattern = Opt/*, threshold = k,*/, ret = ret);
            }
            else if(deflation == "geneo-2") // GenEO-2 for optimized Schwarz methods, need for RHS (LHS is still Neumann matrix)
                AttachCoarseOperator(mpiCommWorld, A, A = noPen, B = Opt, pattern = Opt/*, threshold = 2. * h[].max / diam,*/, ret = ret);
        }
    }
}

set(A, sparams = "-hpddm_reuse_preconditioner=1");
Wh<real> def(u) = init(0.0);    // local solution
for(int i = 0; i < iMax; ++i) {
    real[int] newRhs(rhs.n);
    dmv(A, M, u[], newRhs);
    newRhs += rhs;

    if(Opt.n > 0)       // optimized Schwarz methods
        DDM(A, newRhs, u[], excluded = excluded, ret = ret, O = Opt);
    else
        u[] = A^-1 * newRhs;

    int[int] fforder = [1];
    savevtk("heat-io-2d.vtu", Th, u, order = fforder, append = i ? true : false);
}
load "PETSc"
include "macro_ddm.idp"

macro def2(i)[i, i#B]//
macro init2(i)[i, i]//
real Sqrt = sqrt(2.0);
macro epsilon(u)[dx(u), dy(u#B), (dy(u) + dx(u#B)) / Sqrt]//
macro div(u)(dx(u) + dy(u#B))//

int global = getARGV("-global", 10);
int n = getARGV("-n", global);
bool sym = usedARGV("-sym") != -1;
mesh ThPressure = square(5 * global, global, [5 * x, y]); // global mesh
func Vk = P2;
func Pk = P0;

macro ThPressureRefinementFactor()getARGV("-split", 1)//
macro ThPressureOverlap()2// need two layers of overlap in each direction for the pressure
DmeshCreate(ThPressure);
Mat AUnneeded, C;
{
    macro def(i)def2(i)//
    macro init(i)init2(i)//
    MatCreate(ThPressure, AUnneeded, [Vk, Vk]); // this Mat won't be needed, we will only consider a restriction
                                                // with a single layer of overlap in each direction for the velocity
}
{
    MatCreate(ThPressure, C, Pk);
}
matrix two2one; // two layers of overlap to one layer of overlap
mesh ThVelocity; // build this mesh using ThPressure and by removing the extra layer of overlap (label = -111111)
fespace Wh(ThVelocity, [Vk, Vk]);
fespace Ph(ThPressure, Pk);
{
    fespace Qh(ThPressure, P1);
    varf vGamma(u, v) = on(-111111, u = 1.0);
    Qh gamma;
    gamma[] = vGamma(0, Qh, tgv = -1.0);
    int[int] n2o;
    if(gamma[].linfty > 1.0E-6)
        ThVelocity = trunc(ThPressure, abs(gamma) < 1.0E-2, label = -111111, new2old = n2o);
    else {
        ThVelocity = ThPressure;
        n2o.resize(ThVelocity.nt);
        n2o = 0:ThVelocity.nt - 1;
    }
    fespace WhUnneeded(ThPressure, [Vk, Vk]); // again, unneeded velocity space since this has two layers of overlap
    int[int] restriction = restrict(Wh, WhUnneeded, n2o);
    int[int] I = 0:restriction.n - 1;
    real[int] C(I.n);
    C = 1;
    two2one = [I, restriction, C];
    two2one.resize(Wh.ndof, WhUnneeded.ndof);
}
Mat A(AUnneeded, restriction = two2one); // proper Mat for the velocity with a single layer of overlap

real f = -100.0;
func nu = int(y * n) % 2 == 0 ? 0.4999 : 0.35;
func E = int(y * n) % 2 == 0 ? 1.0E+7 : 200.0E+9;
func mu = E / (2.0*(1.0 + nu));
func lambda = E*nu / ((1.0 + nu)*(1.0 - 2.0*nu));
varf vPbA(def2(u), def2(v)) = int2d(ThVelocity)(2.0 * mu * (epsilon(u)' * epsilon(v))) + int2d(ThVelocity)(f * vB) + on(4, u = 0.0, uB = 0.0);
varf vPbC([p], [q]) = int2d(ThPressure)(-1.0/lambda * p * q);
varf vPbB(def2(u), [q]) = int2d(ThPressure)(div(u) * q);

tgv = -2.0;
matrix NA;
matrix NB = vPbB(Wh, Ph);
NB.thresholding(1.0E-16);
matrix NC = vPbC(Ph, Ph);
NC.thresholding(1.0E-16);

real[int] rhs(Wh.ndof + Ph.ndof);
rhs(0:Wh.ndof - 1)                 = vPbA(0, Wh);
rhs(Wh.ndof:Wh.ndof + Ph.ndof - 1) = 0.0;
if(tgv < 0.0) {
    assert(abs(tgv + 2.0) < 1.0E-6);
    NA = vPbA(Wh, Wh, tgv = -10.0);
    NA.thresholding(1.0E-16);
    varf vPbRHS(def2(u), def2(v)) =                                                                                  on(4, u = 0.0, uB = 0.0);
    real[int] tmp = vPbRHS(0, Wh);
    real[int] rhsA = NA * tmp;
    real[int] rhsB = NB * tmp;
    rhs(0:Wh.ndof - 1) -= rhsA;
    rhs(Wh.ndof:rhs.n - 1) -= rhsB;
    varf vPbG(def2(u), def2(v)) = on(4, u = 1.0, uB = 1.0);
    rhsA = vPbG(0, Wh);
    setBC(NA, rhsA, -2.0);
    if(sym)
        symmetrizeCSR(NA);
    for [i, j, v : NB] if(abs(rhsA(j) - 1.0) < 1.0E-2) v = 0.0;
}
else {
    NA.thresholding(1.0E-16);
    NA = vPbA(Wh, Wh);
}

A = NA;
Mat B(C, A, NB);
C = NC;
Mat Elas = [[A, B'],
            [B, C ]];
set(Elas, sparams = "-pc_type none");
if(HasType("PC", "hpddm")) {
    string common = " -ksp_converged_reason -ksp_view_final_residual -ksp_monitor_true_residual -ksp_type fgmres";
    set(Elas, sparams = common + " -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_precondition self "
        + "-prefix_push fieldsplit_1_ "
        + " -ksp_type fgmres -ksp_rtol 1.0E-1 -pc_type hpddm -pc_hpddm_has_neumann -ksp_monitor -pc_hpddm_ksp_pc_side right -pc_hpddm_ksp_rtol 1.0E-1 -pc_hpddm_schur_precondition geneo "
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 10 -eps_threshold 0.5 -st_share_sub_ksp -eps_gen_non_hermitian -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky -eps_tol 1.0E-2 "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -correction balanced -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop", setup = 1);
    set(A, parent = Elas, bs = sym ? 1 : 2, sparams =
          "-prefix_push fieldsplit_0_ -pc_type hpddm -ksp_pc_side right -pc_hpddm_has_neumann -pc_hpddm_define_subdomains"
        + " -prefix_push pc_hpddm_levels_1_ "
            + " -eps_nev 20 -eps_threshold 0.3 -st_share_sub_ksp -sub_pc_factor_mat_solver_type mumps -sub_pc_type cholesky "
        + " -prefix_pop -prefix_push pc_hpddm_coarse_ "
            + " -pc_type cholesky -pc_factor_mat_solver_type mumps "
        + " -prefix_pop"
       + " -prefix_pop");
    set(C, parent = Elas);

    real[int] sol(Wh.ndof + Ph.ndof);
    sol = Elas^-1 * rhs;
    Wh def2(u);
    u[] = sol(0:Wh.ndof - 1);
    Ph p;
    p[] = sol(Wh.ndof:sol.n - 1);
    plotMPI(ThVelocity, def2(u), [Vk, Vk], def2, real, cmm = "Global velocity (overlap = 1)");
    real alpha = 1.0E4;
    mesh ThMoved = movemesh(ThVelocity, [x + alpha * u, y + alpha * uB]);
    u[] = mpirank;
    plotMPI(ThMoved, u, P2, unneeded, real, cmm = "Global moved solution");
    plotD(ThPressure, p, cmm = "Global pressure (overlap = 2)");
    p = nu;
    plotMPI(ThPressure, p, P0, unneeded, real, cmm = "Material coefficient");
}
//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc-complex"
macro dimension()2// EOM            // 2D or 3D
include "macro_ddm.idp"             // additional DDM functions

macro grad(u)[dx(u), dy(u)]// EOM   // two-dimensional gradient
func Pk = P2;                       // finite element space

real k = getARGV("-waven", 40.0);
func f = 100 * exp(-10 * k * ((x-0.5)^2 + (y-0.5)^2));

real lambda = 2 * pi / k;

real epsilonA = 0;
real epsilonE = 0;

int Dirichlet = 1;
int Robin = -111111;

int s = getARGV("-split", 2);
int level = getARGV("-level", 2);
mesh[int] ThTab(level);
int nloc = (20.0 * k) / ((level - 1) * s * 2 * pi);
ThTab[level - 1] = square(nloc, nloc);
{
    int[int] chlab = [1, Dirichlet, 2, Dirichlet, 3, Dirichlet, 4, Dirichlet];
    ThTab[level - 1] = change(ThTab[level - 1], refe = chlab);
}
Mat<complex>[int] MG(level);
matrix[int] P(level - 1);
buildMatRecursive(ThTab, s, level, P, MG, Pk, mpiCommWorld);

complex[int] rhs;
matrix<complex>[int] Opt(level);
for(int i = 0; i < level; ++i) {
    real epsilon = (i == level - 1 ? k : 0);
    varf vPb(u, v) = int2d(ThTab[i])(-(k^2 - 1i*epsilon)*u*v + grad(u)'*grad(v))
                   + int1d(ThTab[i], Robin)(1i*k*u*v)
                   - int2d(ThTab[i])(f*v)
                   + on(Dirichlet, u = 0);
    fespace Wh(ThTab[i], Pk);
    matrix<complex> Loc = vPb(Wh, Wh, tgv = -2, sym = 1);
    Opt[i] = Loc;
    MG[i] = Loc;
    if(i == 0) {
        rhs.resize(Wh.ndof);
        rhs = vPb(0, Wh);
    }
}
set(MG, P, sparams = "-pc_type mg -ksp_monitor -ksp_view -ksp_type fgmres -ksp_gmres_restart 200 -ksp_max_it 200");
set(MG, 0, sparams = "-mg_coarse_ksp_type gmres -mg_coarse_ksp_rtol 1e-1 -mg_coarse_ksp_pc_side right -mg_coarse_ksp_gmres_restart 100 " + " -mg_coarse_ksp_max_it 100 -mg_coarse_ksp_converged_reason -mg_coarse_pc_type cholesky -mg_coarse_pc_asm_type restrict");
set(MG, level - 1, sparams = "-mg_levels_ksp_type gmres -mg_levels_ksp_max_it 1 -mg_levels_ksp_pc_side right -mg_levels_pc_type asm -mg_levels_sub_pc_type icc -mg_levels_pc_asm_type restrict");
fespace Wh(ThTab[0], Pk);
Wh<complex> u;
u[] = MG[0]^-1 * rhs;
macro def(u)u//
plotMPI(ThTab[0], real(u), Pk, def, real, cmm = "Global solution");
//  run with MPI:  ff-mpirun -np 1 script.edp
// NBPROC 1

assert(mpisize == 1);
load "PETSc"
int n = 2;
real[int] D(n);
D = 1;
int[int][int] restriction(1);
restriction[0].resize(0);
matrix sp = D;
Mat H(sp, restriction, D);
func real J(real[int]& in) {
    return (in[0]-2.0)^2 + (in[1]-2.0)^2 - 2.0*(in[0]+in[1]);
}
func real[int] DJ(real[int]& in) {
    real[int] out(in.n);
    out[0] = 2.0*(in[0]-2.0) - 2.0;
    out[1] = 2.0*(in[1]-2.0) - 2.0;
    return out;
}
real[int] xl = [-1, -1];
real[int] xu = [ 2,  2];
int me = 1;
D.resize(1);
D = 1;
sp = D;
Mat E(sp, restriction, D);
real[int, int] full(1, 2);
full = 1;
sp = full;
Mat JE(E, H, sp);
func real[int] funcE(real[int]& in) {
    real[int] out(me);
    out[0] = in[0]^2 + in[1] - 2.0;
    return out;
}
func int funcJE(real[int]& in) {
    real[int, int] full(me, in.n);
    full(0, 0) = 2 * in[0];
    full(0, 1) = 1;
    matrix sp = full;
    JE = sp;
    return 0;
}
string solver;
if(!HasType("MATSOLVER", "mumps") && !HasType("MATSOLVER", "superlu"))
    exit(0);
else
    solver = (HasType("MATSOLVER", "mumps") ? "mumps" : "superlu");
{
    func int funcH(real[int]& in) {
        real[int] diag(n);
        diag = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    for(int i = 0; i < 2; ++i) {
        real[int] x = [0, 0];
        if(i == 0)
            TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type bqnls -pc_type lu -pc_factor_mat_solver_type " + solver);
        else
            TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type bnls -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcH);
        cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << endl;
    }
}
{
    func int funcH(real[int]& in, real[int]& DE) {
        real[int] diag(n);
        diag[0] = 2 * (1+DE[0]);
        diag[1] = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    real[int] x = [0, 0];
    TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type ipm -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcH, EqualityConstraints = funcE, JacobianEquality = funcJE, JE = JE);
    cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << ", E(x) = " << funcE(x)[0] << " (= 0)" << endl;
}
{
    int mi = 2;
    D.resize(mi);
    D = 1;
    full.resize(mi, mi);
    full = 1;
    sp = full;
    Mat I(sp, restriction, D);
    Mat JI(I, H, sp);
    func int funcHnoE(real[int]& in, real[int]& DI) {
        real[int] diag(n);
        diag[0] = 2 * (1+DI[0]-DI[1]);
        diag[1] = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    func int funcH(real[int]& in, real[int]& DE, real[int]& DI) {
        real[int] diag(n);
        diag[0] = 2 * (1+DE[0]+DI[0]-DI[1]);
        diag[1] = 2;
        matrix sp = diag;
        H = sp;
        return 0;
    }
    func real[int] funcI(real[int]& in) {
        real[int] out(mi);
        out[0] = in[0]^2 - in[1];
        out[1] = -in[0]^2 + in[1] + 1.0;
        return out;
    }
    func int funcJI(real[int]& in) {
        real[int, int] full(mi, in.n);
        full(0, 0) = 2 * in[0];
        full(0, 1) = -1;
        full(1, 0) = -2 * in[0];
        full(1, 1) = 1;
        matrix sp = full;
        JI = sp;
        return 0;
    }
    real[int] x = [0, 0];
    TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type ipm -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcHnoE, InequalityConstraints = funcI, JacobianInequality = funcJI, JI = JI);
    cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << ", I(x) = [" << funcI(x)[0] << ", " << funcI(x)[0] << "] (>= [0, 0])" << endl;
    x = [0, 0];
    TaoSolve(H, J, DJ, x, xl = xl, xu = xu, sparams = "-tao_monitor -tao_type ipm -pc_type lu -pc_factor_mat_solver_type " + solver, HessianRoutine = funcH, EqualityConstraints = funcE, JacobianEquality = funcJE, JE = JE, InequalityConstraints = funcI, JacobianInequality = funcJI, JI = JI);
    cout << "J([" << x[0] << ", " << x[1] << "]) = " << J(x) << ", E(x) = " << funcE(x)[0] << " (= 0), I(x) = [" << funcI(x)[0] << ", " << funcI(x)[0] << "] (>= [0, 0])" << endl;
}
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
real E = 21e5, nu = 0.28;
real f = -1;

// Mesh
mesh Th = square(10, 10, [20*x, 2*y-1]);

// Fespace
fespace Vh(Th, P2);
Vh u, v, uu, vv;

// Macro
real sqrt2 = sqrt(2.);
macro epsilon(u1, u2) [dx(u1), dy(u2), (dy(u1)+dx(u2))/sqrt2] // EOM
// Remark: the 1/sqrt2 term in (dy(u1)+dx(u2)) is here
// to obtain a 1/2 when we use epsilon(u1, u2)'*epsilon(v1, v2)
macro div(u, v) (dx(u) + dy(v)) // EOM

// Problem
real mu = E/(2*(1 + nu));
real lambda = E*nu/((1 + nu)*(1 - 2*nu));

solve lame([u, v], [uu, vv])
  = int2d(Th)(
      lambda*div(u,v)*div(uu,vv)
    + 2.*mu*(epsilon(u,v)'*epsilon(uu,vv))
  )
  - int2d(Th)(f*vv)
  + on(4, u=0, v=0);

// Plot
real coef = 100;
plot([u, v], wait=1, ps="lamevect.eps", coef=coef);

// Move mesh
mesh th1 = movemesh(Th, [x+u*coef, y+v*coef]);
plot(th1, wait=1, ps="lamedeform.eps");

// Display
real dxmin = u[].min;
real dymin = v[].min;
cout << " - dep.  max x = " << dxmin << " y = " << dymin << endl;
cout << "   dep. (20,0) = " << u(20,0) << " " << v(20,0) << endl;
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
int C1 = 99, C2 = 98; // could be anything

// Mesh
border C0(t=0, 2*pi){x=5*cos(t); y=5*sin(t);}

border C11(t=0, 1){x=1+t;  y=3;      label=C1;}
border C12(t=0, 1){x=2;    y=3-6*t;  label=C1;}
border C13(t=0, 1){x=2-t;  y=-3;     label=C1;}
border C14(t=0, 1){x=1;    y=-3+6*t; label=C1;}

border C21(t=0, 1){x=-2+t; y=3;      label=C2;}
border C22(t=0, 1){x=-1;   y=3-6*t;  label=C2;}
border C23(t=0, 1){x=-1-t; y=-3;     label=C2;}
border C24(t=0, 1){x=-2;   y=-3+6*t; label=C2;}

mesh Th=buildmesh(C0(50)
  + C11(5) + C12(20) + C13(5) + C14(20)
  + C21(-5) + C22(-20) + C23(-5) + C24(-20));
plot(Th, wait=1, ps="heatexTh.ps");

// Fespace
fespace Vh(Th, P1);
Vh u, v;
Vh kappa = 1 + 4*(x<-1)*(x>-2)*(y<3)*(y>-3);

// Problem
solve a(u, v)
  = int2d(Th)(
    kappa*(dx(u)*dx(v) + dy(u)*dy(v))
  )
  + on(C0, u=20)
  +on(C1, u=100);

// Plot
plot(u, value=true, wait=1, fill=true);
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

/// Characteristics Galerkin
// Parameters
verbosity = 1;
real dt = 0.17;
real t = 0;

// Mesh
border C(t=0, 2*pi){x=cos(t); y=sin(t);}
mesh Th = buildmesh(C(100));

// Fespace
fespace Uh(Th, P1);
Uh cold, c = exp(-10*((x-0.3)^2 +(y-0.3)^2));
Uh u1 = y, u2 = -x;

// Loop
for (int m = 0; m < 2*pi/dt; m++) {
	t += dt;
	cold = c;
	c = convect([u1, u2], -dt, cold);
	plot(c, cmm=" t="+t + ", min=" + c[].min + ", max=" +  c[].max);
}

/// Now with Discontinuous Galerkin
// Parameters
real u, al=0.5;
dt = 0.05;

// Fespace
fespace Vh(Th, P1dc);
Vh w, ccold, v1 = y, v2 = -x, cc = exp(-10*((x-0.3)^2 +(y-0.3)^2));

// Macro
macro n()(N.x*v1+N.y*v2) //

// Problem
problem  Adual(cc, w, init=t)
	= int2d(Th)((cc/dt + (v1*dx(cc) + v2*dy(cc)))*w)
	+ intalledges(Th)((1-nTonEdge)*w*(al*abs(n) - n/2)*jump(cc))
//  - int1d(Th, C)((n(u)<0)*abs(n(u))*cc*w)	// unused because cc=0 on d(Omega)^-
	- int2d(Th)(ccold*w/dt);

// Loop
for (t = 0; t < 2*pi; t += dt) {
	ccold = cc;
	Adual;
	plot(cc, fill=1, cmm="t="+t + ", min=" + cc[].min + ", max=" +  cc[].max);
}

// Plot
real [int] viso=[-0.1, 0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.9, 1];
plot(c, wait=1, fill=1, value=1, ps="convectCG.eps", viso=viso);
plot(cc, wait=1, fill=1, value=1, ps="convectDG.eps", viso=viso);

/// Discontinuous Galerkin very much faster
// Problem
varf aadual(cc, w)
	= int2d(Th)((cc/dt + (v1*dx(cc) + v2*dy(cc)))*w)
	+ intalledges(Th)((1-nTonEdge)*w*(al*abs(n) - n/2)*jump(cc));

varf bbdual(ccold, w) = -int2d(Th)(ccold*w/dt);

matrix  AA = aadual(Vh, Vh, verb=1);
matrix BB = bbdual(Vh, Vh);

// Loop
Vh rhs = 0;
for (t = 0; t < 2*pi ; t += dt) {
	ccold = cc;
	rhs[] = BB* ccold[];
	cc[] = AA^-1*rhs[];
	plot(cc, fill=0, cmm="t="+t + ", min=" + cc[].min + ", max=" +  cc[].max);
}

// Plot
plot(cc, wait=1, fill=1, value=1, ps="convectDG.eps", viso=viso);
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Mesh
border aa(t=0, 2*pi) {x = 5*cos(t); y = 5*sin(t);}
border bb(t=0, 2*pi) {x = cos(t); y = sin(t);}
border cc(t=0, 2*pi) {x = -3+cos(t); y = sin(t);}
border dd(t=0, 2*pi) {x = cos(t); y = -3+sin(t);}
mesh th = buildmesh(aa(70) + bb(35) + cc(35) + dd(35));

// Fespace
fespace Vh(th, P1);
Vh Ib = ((x^2+y^2)<1.0001),
   Ic = (((x+3)^2+ y^2)<1.0001),
   Id = ((x^2+(y+3)^2)<1.0001),
   Ie = (((x-1)^2+ y^2)<=4),
   ud, u, uh, du;

// Problem
real[int] z(3);
problem A(u, uh)
  = int2d(th)(
    (1 + z[0]*Ib + z[1]*Ic + z[2]*Id)*(dx(u)*dx(uh) + dy(u)*dy(uh))
  )
  + on(aa, u=x^3-y^3);
z[0] = 2; z[1] = 3; z[2] = 4;

// Solve
A; ud = u;

ofstream f("J.txt");
func real J(real[int] & Z) {
    for (int i = 0;i < z.n; i++) z[i] = Z[i];
    A;
    real s = int2d(th)(Ie*(u-ud)^2);
    f << s << "   ";
    return s;
}

real[int] dz(3), dJdz(3);

problem B(du, uh)
  =int2d(th)(
    (1 + z[0]*Ib + z[1]*Ic + z[2]*Id)*(dx(du)*dx(uh) + dy(du)*dy(uh))
  )
  +int2d(th)(
    (dz[0]*Ib + dz[1]*Ic + dz[2]*Id)*(dx(u)*dx(uh) + dy(u)*dy(uh))
  )
  +on(aa, du=0);

func real[int] DJ(real[int] &Z) {
  for(int i = 0; i < z.n; i++) {
    for(int j = 0; j < dz.n; j++)
      dz[j]=0;
    dz[i] = 1;
    B;
    dJdz[i] = 2*int2d(th)(Ie*(u-ud)*du);
  }
  return dJdz;
}

real[int] Z(3);
for(int j = 0; j < z.n; j++) Z[j] = 1;

BFGS(J, DJ, Z, eps=1.e-6, nbiter=15, nbiterline=20);
cout << "BFGS: J(z) = " << J(Z) << endl;
for(int j = 0; j < z.n; j++) cout << z[j] << endl;
plot(ud, value=1, ps="u.eps");
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/
// Author: F. Hecht
// (jul. 2014)

verbosity=0;

// Parameters
int n = 1;
real nu = 0.0025; // Reynolds=200
real dt = 0.2;
real epsv = 1e-6, epsu = 1e-6, epsp = 1e-6;// Eps CG ..

// Mesh
border a0(t=1, 0){x=-2; y=t; label=1;} // inlet
border a1(t=-2, 0){x=t; y=0; label=2;}
border a2(t=0, -0.5){x=0; y=t; label=2;}
border a3(t=0, 1){x=18*t^1.2; y=-0.5; label=2;}
border a4(t=-0.5, 1){x=18; y=t; label=3;} // outlet
border a5(t=1, 0){x=-2+20*t; y=1; label=4;}

mesh Th = buildmesh(a0(3*n) + a1(20*n) + a2(10*n) + a3(150*n) + a4(5*n) + a5(100*n));
plot(Th);

// Fespace
fespace Vh(Th, P1);
Vh w, u = 0, v = 0, p = 0, q = 0;

// Definitions of Matrix dtMx and dtMy
matrix dtM1x, dtM1y;

macro  BuildMat()
  { /* for memory managenemt */
    varf vM(unused, v) = int2d(Th)(v) ;
    varf vdx(u, v) = int2d(Th)(v*dx(u)*dt) ;
    varf vdy(u, v) = int2d(Th)(v*dy(u)*dt) ;

    real[int] Mlump = vM(0, Vh);
    real[int] one(Vh.ndof); one = 1;
    real[int] M1 = one ./ Mlump;
    matrix dM1 = M1;
    matrix Mdx = vdx(Vh, Vh);
    matrix Mdy = vdy(Vh, Vh);
    dtM1x = dM1*Mdx;
    dtM1y = dM1*Mdy;
  }//

BuildMat

real err = 1, outflux = 1;
for(int n = 0; n < 200; n++) {
  Vh uold = u, vold = v, pold = p;

  solve pb4u(u, w, init=n, solver=CG, eps=epsu)
    = int2d(Th)(
      u*w/dt + nu*(dx(u)*dx(w) + dy(u)*dy(w))
    )
    - int2d(Th)(
      (convect([uold, vold], -dt, uold)/dt - dx(p))*w
    )
    + on(1, u=4*y*(1-y))
    + on(2, 4, u=0);
  plot(u);

  solve pb4v(v, w, init=n, solver=CG, eps=epsv)
    = int2d(Th)(
      v*w/dt + nu*(dx(v)*dx(w) + dy(v)*dy(w))
    )
    - int2d(Th)(
      (convect([uold, vold], -dt, vold)/dt - dy(p))*w
    )
    + on(1, 2, 3, 4, v=0);

  solve pb4p(q, w, solver=CG, init=n, eps=epsp)
    = int2d(Th)(dx(q)*dx(w) + dy(q)*dy(w))
    - int2d(Th)((dx(u) + dy(v))*w/dt)
    + on(3, q=0);

  // to have absolute epsilon in CG algorithm.
  epsv = -abs(epsv);
  epsu = -abs(epsu);
  epsp = -abs(epsp);

  p = pold-q;
  u[] += dtM1x*q[];
  v[] += dtM1y*q[];

  if(n%50 == 49) {
    Th = adaptmesh(Th, [u, v], q, err=0.06, nbvx=100000);
    plot(Th, wait=true);
    BuildMat // rebuild mat.
  }

  err = sqrt(int2d(Th)(square(u - uold) + square(v - vold))/Th.area);
  outflux = int1d(Th)([u, v]'*[N.x, N.y]) ;
  cout << " iter " << n << " Err L2 = " << err << " - Outflow = " << outflux << endl;
  if (err < 1e-3) break;
}
assert(abs(outflux) < 5e-3); // verification
plot(p, wait=1, ps="NSprojP.eps");
plot(u, wait=1, ps="NSprojU.eps");
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
int n = 2;
real a = 20, b = 20, c = 15, d = 8, e = 2, l = 12, f = 2, g = 2;

// Mesh
border a0(t=0, 1) {x=a*t; y=0; label=1;}
border a1(t=1, 2) {x=a; y= b*(t-1); label=1;}
border a2(t=2, 3) {x=a*(3-t); y=b; label=1;}
border a3(t=3, 4) {x=0; y=b-(b-c)*(t-3); label=1;}
border a4(t=4, 5) {x=0; y=c-(c-d)*(t-4); label=2;}
border a5(t=5, 6) {x=0; y= d*(6-t); label=1;}

border b0(t=0, 1) {x=a-f+e*(t-1); y=g; label=3;}
border b1(t=1, 4) {x=a-f; y=g+l*(t-1)/3; label=3;}
border b2(t=4, 5) {x=a-f-e*(t-4); y=l+g; label=3;}
border b3(t=5, 8) {x=a-e-f; y=l+g-l*(t-5)/3; label=3;}

mesh Th = buildmesh(a0(10*n) + a1(10*n) + a2(10*n) + a3(10*n) + a4(10*n) + a5(10*n)
  + b0(5*n) + b1(10*n) + b2(5*n) + b3(10*n));

real meat = Th(a-f-e/2, g+l/2).region, air= Th(0.01, 0.01).region;
plot(Th, wait=1);

// Fespace (wave)
fespace Vh(Th, P1);
Vh R = (region-air)/(meat-air);
Vh<complex> v, w;

// Problem (wave)
solve muwave(v, w)
  = int2d(Th)(
      v*w*(1+R)
    -(dx(v)*dx(w)+dy(v)*dy(w))*(1-0.5i)
  )
  + on(1, v=0)
  + on(2, v=sin(pi*(y-c)/(c-d)));

// Plot
Vh vr = real(v), vi = imag(v);
plot(vr, wait=1, ps="rmuonde.ps", fill=true);
plot(vi, wait=1, ps="imuonde.ps", fill=true);

// Fespace (heat)
fespace Uh(Th,P1);
Uh u, uu, ff=1e5*(vr^2 + vi^2)*R;

// Problem (heat)
solve temperature(u, uu)
  = int2d(Th)(
      dx(u) * dx(uu)
    + dy(u) * dy(uu)
  )
  - int2d(Th)(ff*uu)
  + on(1, 2, u=0);

// Plot
plot(u, wait=1, ps="tempmuonde.ps", fill=true);
// Regression tests
// ----------------

// $Id$

// Regression tests
// ----------------

// The tests are checked against reference values by "make check" in
// each examples subdirectory

// "ref.edp" contains all reference values and may be rebuilt with
// "make Ref"

// $Id$

// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.

NoUseOfWait=true;
int verbosityy=verbosity;




include "ref.edp";





// The values tested here may not have a physical or mathematical
// meaning. Their main property is to gather numerical values from the
// whole domain, to be checked for consistency with previous runs.


/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
real theta = 4.*pi/3.;
real a = 2., b = 1.; // the length of the semimajor axis and semiminor axis
func z = x;

// Mesh
border Gamma1(t=0, theta)    {x=a*cos(t); y=b*sin(t);}
border Gamma2(t=theta, 2*pi) {x=a*cos(t); y=b*sin(t);}
mesh Th = buildmesh(Gamma1(100) + Gamma2(50));

// Fespace
fespace Vh(Th,P2); // P2 conforming triangular finite element space
Vh phi, w, f = 1;

// Problem (resolution of laplace equation)
solve Laplace(phi, w)
  =int2d(Th)(
    dx(phi)*dx(w) + dy(phi)*dy(w)
  )
  - int2d(Th)(f*w)
  + on(Gamma1, phi=z);

// Plot
plot(phi, wait=true, ps="membrane.eps"); //Plot Th and phi
plot(Th, wait=true, ps="membraneTh.eps"); //Plot Th

// Export to gnupot
{
  ofstream ff("graph.txt");
  for (int i = 0; i < Th.nt; i++) {
    for (int j = 0; j < 3; j++)
      ff << Th[i][j].x  << "    " << Th[i][j].y << "  " << phi[][Vh(i,j)] << endl;
  ff << Th[i][0].x << "    " << Th[i][0].y << "  " << phi[][Vh(i,0)] << endl << endl << endl;
  }
}

// Save the mesh
savemesh(Th, "Th.msh");
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
int C1 = 99;
int C2 = 98; // could be anything

// Mesh
border C0(t=0, 2*pi){x=5*cos(t); y=5*sin(t);}

border C11(t=0, 1){ x=1+t;  y=3;      label=C1;}
border C12(t=0, 1){ x=2;    y=3-6*t;  label=C1;}
border C13(t=0, 1){ x=2-t;  y=-3;     label=C1;}
border C14(t=0, 1){ x=1;    y=-3+6*t; label=C1;}

border C21(t=0, 1){ x=-2+t; y=3;      label=C2;}
border C22(t=0, 1){ x=-1;   y=3-6*t;  label=C2;}
border C23(t=0, 1){ x=-1-t; y=-3;     label=C2;}
border C24(t=1, 0){ x=-2;   y=-3+6*t; label=C2;}

mesh Th=buildmesh(C0(50)
    +C11(5)+C12(20)+C13(5)+C14(20)
    +C21(5)+C22(20)+C23(5)+C24(-20));
plot(Th, wait=true);

// Fespace
fespace Vh(Th, P1);
Vh u, v;

// Problem
solve a(u, v)
    = int2d(Th)(
          dx(u)*dx(v)
        + dy(u)*dy(v)
    )
    + on(C0, u=0)
    + on(C1, u=1)
    + on(C2, u=-1);

// Plot
plot(u, value=true, ps="condersor.eps");
/*
solving Stokes problem with the following boundary condition for velocity:
- periodic boundary condition in x-direction 
- dirichlet boundary condition in y-direction
*/

macro grad(u) [dx(u),dy(u)]//
macro Grad(u1,u2) [grad(u1), grad(u2)]//
macro div(u1,u2) (dx(u1)+dy(u2))//

mesh Th=square(60,60,[2*pi*x,2*pi*y],flags=3);
mesh ThU=trunc(Th,1,split=2);
mesh ThP=Th;

fespace UhPerio(ThU,[P1],periodic=[[2,y],[4,y]]);
fespace Uh(ThU,[P1]);
fespace Ph(Th,P1);

fespace Vh=UhPerio*Uh*Ph; // definition of the composite FE space

UhPerio u1;
Uh u2;
Ph p;

func g1 = sin(x)*cos(y);
func g2 = -cos(x)*sin(y);

func f1 = 0;
func f2 = -4*cos(x)*sin(y);
func fp = 2*cos(x)*cos(y);

varf Stokes ( [u1,u2,p], [v1,v2,q] )
= int2d(Th)( (Grad(u1,u2):Grad(v1,v2)) ) + int2d(Th)( - div(u1,u2)*q - div(v1,v2)*p ) + int2d(Th)( -1e-10*p*q )
+ int2d(Th) ( [f1,f2]'*[v1,v2] )
+ on(1,2,3,4,u2=g2) + on(1,3,u1=g1);

matrix A = Stokes(Vh,Vh);
real[int] b1 = Stokes(0,Vh);
real[int] sol = A^(-1)*b1;

[u1[],u2[],p[]]=sol;

plot( u1, cmm="u1" );
plot( u2, cmm="u2");
plot( p,  cmm="p" );

fespace VhU(ThU,P1);
fespace VhP(ThP,P1);

VhU ue1=g1;
VhU ue2=g2;
VhP pe=fp;

cout << " int2d(Th) (dx(fu1)+dy(fu2)) =" << int2d(Th)(dx(ue1)+dy(ue2)) << endl;

cout << "error L2 (u) = " << int2d(Th)( (u1-ue1)^2 + (u2-ue2)^2 ) << endl;
cout << "error L2 (p) = " << int2d(Th)( (p-pe)^2 ) << endl;
cout << "error L2 relative (u) = " << int2d(Th)( (u1-ue1)^2 + (u2-ue2)^2 ) / int2d(Th)( ue1^2+ue2^2 ) << endl;
cout << "error L2 relative (p) = " << int2d(Th)( (p-pe)^2 ) / int2d(Th)( pe^2 ) << endl;
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
bool withplot = 0;
real cpu1, cpu2;
func k = 1.8*(y < 0.5) + 0.2;
real kf = 1, ue = 20, T = 5, dt = 0.1;

// Mesh
mesh Th = square(150, 50, [3*x, y]);

// Fespace
fespace Vh(Th, P1);
Vh u, uold, v, usave;

// Problem
int kk=0;
problem Heat(u, v, init=kk)
  = int2d(Th)(
      u*v/dt
    + k*(dx(u)*dx(v) + dy(u)*dy(v))
  )
  + int1d(Th, 1, 3)(kf*v*u)
  - int1d(Th, 1, 3)(kf*v*ue)
  - int2d(Th)(uold*v/dt)
  + on(2, 4, u=30);

real cpu = clock();

// Initialization
u = 0;

// Basic time loop
for (real t = 0; t < T; t += dt) {
  uold = u;
  Heat;
  kk++;
  if (withplot) plot(u);
}

cpu1 = clock()-cpu;

plot(u);
usave[] = u[];

/// Optimized code
// Problem definition
varf vA(u, v)
  = int2d(Th)(
      u*v/dt
    + k*(dx(u)*dx(v) + dy(u)*dy(v))
    )
  + int1d(Th, 1, 3)(kf*v*u)
  + on(2, 4, u=30);
varf vB(u, v) = int2d(Th)(u*v/dt) ;
varf vRHS(u, v) = int1d(Th, 1, 3)(kf*v*ue);
varf vL(u, v) = on(2, 4, u=30);

{
  cpu = clock();
  real[int] rhsbc = vL(0, Vh);
  real[int] rhs0 = vRHS(0, Vh);
  matrix A = vA(Vh, Vh, solver=sparsesolver);
  matrix B = vB(Vh, Vh);

  // Initialization
  u = 0;

  // Optimized time loop (speed of C language)
  for (real t = 0; t < T; t += dt) {
    real[int] b = B*u[];
    b += rhs0;
    b = rhsbc ? rhsbc : b;
    u[] = A^-1*b;
    if(withplot) plot(u);
  }
  cpu2 = clock() - cpu;
}

plot(u, cmm="u2");
cout << " cpu method 1 = " << cpu1 << " cpu method matrix = " << cpu2 << " ratio = " <<  cpu1/cpu2 << endl;
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

verbosity=0;

// Parameters
real theta = 4.*pi/3.;
real a = 1., b = 1.; // the length of the semimajor axis and semiminor axis
func f = -4*(cos(x^2+y^2-1) - (x^2+y^2)*sin(x^2+y^2-1));

// Mesh
border Gamma1(t=0, theta)    {x=a*cos(t); y=b*sin(t);}
border Gamma2(t=theta, 2*pi) {x=a*cos(t); y=b*sin(t);}

// Exact solution
func phiexact = sin(x^2+y^2-1);

// Solve loop
real[int] L2error(2);
for(int n = 0; n < 2; n++) {
  mesh Th = buildmesh(Gamma1(40*(n+1)) + Gamma2(20*(n+1)));
  fespace Vh(Th, P2);
   Vh phi, w;

  solve laplace(phi, w)
    =int2d(Th)(
        dx(phi)*dx(w)
      + dy(phi)*dy(w)
    )
    - int2d(Th)(f*w)
    - int1d(Th,Gamma2)(2*w)
    + on(Gamma1, phi=0);
  plot(Th, phi, wait=true, ps="membrane.eps"); //Plot Th and phi

  L2error[n] = sqrt(int2d(Th)((phi - phiexact)^2));
}

for(int n = 0; n < 2; n++)
  cout << " L2error " << n << " = " <<  L2error[n] << endl;

cout << " convergence rate = " << log(L2error[0]/L2error[1])/log(2.) << endl;
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
real n = 4; // Mesh quality

// Mesh
border a(t=0, 1){x=t; y=0;}
border a1(t=1, 2){x=t; y=0;}
border b(t=0, 1){x=2; y=t;}
border c(t=2, 0){x=t; y=1;}
border d(t=1, 0){x=0; y=t;}
border e(t=0, pi/2){x=cos(t); y=sin(t);}
border e1(t=pi/2, 2*pi){x=cos(t); y=sin(t);}

//Omega1 (rectangle)
mesh th = buildmesh(a(5*n) + a1(5*n) + b(5*n) + c(10*n) + d(5*n));
fespace Vh(th, P1);
Vh v, u=0;

//Omega2 (circle)
mesh TH = buildmesh(e(5*n) + e1(25*n));
fespace VH(TH,P1);
VH V, U=0;

for (int i = 0; i < 4; i++) {
  plot(U, u, wait=1, cmm="Iteration "+i);
  // Solve on Omega2
  solve AA(U, V)
    = int2d(TH)(dx(U)*dx(V) + dy(U)*dy(V))
    - int2d(TH)(V)
    + on(e, U=u)
    + on(e1, U=0);

  // Solve on Omega1
  solve aa(u, v)
    = int2d(th)(dx(u)*dx(v) + dy(u)*dy(v))
    - int2d(th)(v)
    + on(a, d, u=U)
    + on(a1, b, c, u=0);
}

plot(U, u, wait=1, cmm="Final solution");
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
int C1 = 99, C2 = 98; // could be anything

// Mesh
border C0(t=0, 2*pi){x=5*cos(t); y=5*sin(t);}

border C11(t=0, 1){x=1+t;  y=3;      label=C1;}
border C12(t=0, 1){x=2;    y=3-6*t;  label=C1;}
border C13(t=0, 1){x=2-t;  y=-3;     label=C1;}
border C14(t=0, 1){x=1;    y=-3+6*t; label=C1;}

border C21(t=0, 1){x=-2+t; y=3;      label=C2;}
border C22(t=0, 1){x=-1;   y=3-6*t;  label=C2;}
border C23(t=0, 1){x=-1-t; y=-3;     label=C2;}
border C24(t=0, 1){x=-2;   y=-3+6*t; label=C2;}

mesh Th=buildmesh(C0(50)
  + C11(5) + C12(20) + C13(5) + C14(20)
  + C21(-5) + C22(-20) + C23(-5) + C24(-20));
plot(Th, wait=1);

// Fespace
fespace Vh(Th, P1);
Vh u, v;
Vh kappa = 1 + 4*(x<-1)*(x>-2)*(y<3)*(y>-3);

// Problem
solve a(u, v)
  = int2d(Th)(kappa*(dx(u)*dx(v) + dy(u)*dy(v)))
  + on(C0, u=20)
  + on(C1, u=100);
plot(u, value=true, wait=1, fill=true);
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/
// Your first program

// Define a boundary
border C(t=0, 2*pi){x=cos(t); y=sin(t);}

// Build the mesh from boundary
mesh Th = buildmesh(C(50));

// Create a finite element space of order 2
fespace Vh(Th, P2);
// Defines u and v, piecewise-P2 continuous functions
Vh u, v;

// Define an algebraic function
func f = x*y;

real cpu = clock();

// Define and solve a PDE
solve Poisson(u, v, solver=LU)
  = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v)) // bilinear part
  - int2d(Th)(f*v) // right hand side
  + on(C, u=0); // Dirichlet boundary condition

// Plot the solution
plot(u, wait=1, cmm="Solution");

// Display the CPU time
cout << " CPU time = " << clock()-cpu << endl;

// FOR THE PRO: The same problem solved with total control over the algebra
varf a(u, v) // the weak form
  = int2d(Th)(dx(u)*dx(v) + dy(u)*dy(v))
  + on(C, u=0);
matrix A = a(Vh, Vh); // stiffness matrix

varf b(u,v) = int2d(Th)(u*v);
matrix B = b(Vh, Vh);

Vh F = f;
v[] = B*F[];
u[] = A^-1*v[];
plot(u, wait=1, cmm="PRO Solution");
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/
// Author: F. Hecht
// Stationnary imcompressible Navier Stokes Equation with Newton method (jan. 2012)

verbosity=0;

// Parameters
func bb = [[-1, -2], [4, 2]]; // bounding box for the plot
real R = 5, L = 15;
// physical parameters
real nu = 1./50, nufinal = 1/200., cnu = 0.5;
// stop test for Newton
real eps = 1e-4;

// Mesh
border cc(t=0, 2*pi) {x=cos(t)/2; y=sin(t)/2; label=2;}
border ce(t=pi/2, 3*pi/2) {x=cos(t)*R; y=sin(t)*R; label=1;}
border beb(tt=0, 1) {real t=tt^1.2; x=t*L; y=-R; label=1;}
border beu(tt=1, 0) {real t=tt^1.2; x=t*L; y=R; label=1;}
border beo(t=-R, R) {x=L; y=t; label=0;}
border bei(t=-R/4, R/4) {x=L/2; y=t; label=0;}
mesh Th = buildmesh(cc(-40) + ce(20) + beb(15) + beu(15) + beo(8) + bei(10));
plot(Th);

// Macro
macro Grad(u1, u2) [dx(u1), dy(u1), dx(u2), dy(u2)]//
macro UgradV(u1, u2, v1, v2) [[u1, u2]'*[dx(v1), dy(v1)], [u1, u2]'*[dx(v2), dy(v2)] ]//
macro div(u1, u2)  (dx(u1) + dy(u2))//

//  FE Space
fespace Xh(Th, P2);
Xh u1, u2;
Xh v1, v2;
Xh du1, du2;
Xh u1p, u2p;

fespace Mh(Th, P1);
Mh p, q;
Mh dp, pp;

// Intial guess with B.C.
u1 = (x^2+y^2) > 2;
u2 = 0;

// Loop on vicosity
while(1) {
	int n;
	real err = 0;
	// Newton Loop
	for (n = 0; n < 15; n++) {
		solve Oseen([du1, du2, dp], [v1, v2, q])
			= int2d(Th)(
					nu*(Grad(du1,du2)'*Grad(v1,v2))
				+ UgradV(du1,du2, u1, u2)'*[v1,v2]
				+ UgradV( u1, u2,du1,du2)'*[v1,v2]
				- div(du1,du2)*q - div(v1,v2)*dp
				- 1e-8*dp*q // stabilization term
			)
			- int2d(Th)(
				  nu*(Grad(u1,u2)'*Grad(v1,v2))
				+ UgradV(u1,u2, u1, u2)'*[v1,v2]
				- div(u1,u2)*q - div(v1,v2)*p
				- 1e-8*p*q
			)
			+ on(1,2,du1=0,du2=0)
			;

		u1[] -= du1[];
		u2[] -= du2[];
		p[] -= dp[];

		real Lu1 = u1[].linfty, Lu2 = u2[].linfty, Lp = p[].linfty;
		err = du1[].linfty/Lu1 + du2[].linfty/Lu2 + dp[].linfty/Lp;

		cout << n << " err = " << err << " " << eps << " rey  = " << 1./nu << endl;
		if(err < eps) break; // converge
		if( n > 3 && err > 10.) break; // Blowup ?
	}
	if(err < eps) {// if converge  decrease nu (more difficult)
		plot([u1, u2], p, wait=1, cmm=" rey = " + 1./nu, coef=0.3, bb=bb);
		if(nu == nufinal) break;
		if(n < 4) cnu = cnu^1.5; // fast converge => change faster
		nu = max(nufinal, nu*cnu); // new vicosity
		u1p = u1;
		u2p = u2;
		pp = p; // save correct solution
	}
	else {  // if blowup, increase nu (more simple)
		assert(cnu < 0.95); // final blowup
		nu = nu/cnu; //  get previous value of viscosity
		cnu = cnu^(1./1.5); // no conv. => change lower
		nu = nu* cnu;  // new vicosity
		cout << " restart nu = " << nu << " Rey = " << 1./nu << "  (cnu = " << cnu << " ) \n";
		// restore correct solution
		u1 = u1p;
		u2 = u2p;
		p = pp;
	}
}
cout << " CPU "<< clock()<< " s " << endl;
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
real kc2 = 1; // try this value 19.4256
func g = y*(1-y);
real sigma = 20; // value of the shift
int nev = 2; // number of computed eigen value close to sigma

// Mesh
border a0(t=0, 1) { x=5; y=1+2*t;}
border a1(t=0, 1) { x=5-2*t; y=3;}
border a2(t=0, 1) { x=3-2*t; y=3-2*t;}
border a3(t=0, 1) { x=1-t; y=1;}
border a4(t=0, 1) { x=0; y=1-t;}
border a5(t=0, 1) { x=t; y=0;}
border a6(t=0, 1) { x=1+4*t; y=t;}

mesh Th=buildmesh(a0(20) + a1(20) + a2(20) + a3(20) + a4(20) + a5(20) + a6(20));

// Fespace
fespace Vh(Th, P1);
Vh u,v;
Vh u1, u2;

// Problem
solve sound(u, v)
  =int2d(Th)(u*v*kc2 - dx(u)*dx(v) - dy(u)*dy(v))
  - int1d(Th, a4)(g*v);

plot(u, wait=1, ps="sound0.eps");

// Eigen values
varf op(u1, u2)
  = int2d(Th)(dx(u1)*dx(u2) + dy(u1)*dy(u2) - sigma* u1*u2);

varf b([u1], [u2])
  = int2d(Th)(u1*u2); // no boundary condition

matrix OP = op(Vh, Vh, solver=Crout);  // crout solver because the matrix in not positive
matrix B = b(Vh, Vh, solver=CG, eps=1e-20);

real[int] ev(nev); // to store the nev eigenvalue
Vh[int] eV(nev); // to store the nev eigenvector

int k = EigenValue(OP, B, sym=true, sigma=sigma, value=ev, vector=eV,
  tol=1e-10, maxit=0, ncv=0);
cout << ev(0) << " 2 eigen values " << ev(1) << endl;
v = eV[0];
plot(v, wait=1, ps="eigen.eps");
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
int m = 30;
int L = 80;
int LL = 80;
int j = 100;
real sigmax = 0.3;
real sigmay = 0.3;
real rho = 0.3;
real r = 0.05;
real K = 40;
real dt = 0.01;

// Mesh
mesh th = square(m, m, [L*x, LL*y]);

// Fespace
fespace Vh(th, P1);
Vh u = max(K - max(x, y), 0.);
Vh xveloc, yveloc, v, uold;

// Time loop
for (int n = 0; n*dt <= 1.0; n++) {
    // Mesh adaptation
    if (j > 20) {
        th = adaptmesh(th, u, verbosity=1, abserror=1, nbjacoby=2,
            err=0.001, nbvx=5000, omega=1.8, ratio=1.8, nbsmooth=3,
            splitpbedge=1, maxsubdiv=5, rescaling=1) ;
        j = 0;
        xveloc = -x*r + x*sigmax^2 + x*rho*sigmax*sigmay/2;
        yveloc = -y*r + y*sigmay^2 + y*rho*sigmax*sigmay/2;
        u = u;
    }

    // Update
    uold = u;

    // Solve
    solve eq1(u, v, init=j, solver=LU)
        = int2d(th)(
              u*v*(r + 1/dt)
            + dx(u)*dx(v)*(x*sigmax)^2/2
            + dy(u)*dy(v)*(y*sigmay)^2/2
            + dy(u)*dx(v)*rho*sigmax*sigmay*x*y/2
            + dx(u)*dy(v)*rho*sigmax*sigmay*x*y/2
        )
        + int2d(th)(
            - v*convect([xveloc, yveloc], dt, uold)/dt
        )
        + on(2,3,u=0)
        ;

    j = j + 1;
}

// Plot
plot(u, wait=true, value=true);
plot(th, wait=true);
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/
// Corrected by F. Hecht may 2021 
// Parameters
real S = 99;

border C(t=0, 2*pi){x=3*cos(t); y=3*sin(t);} // Label 1,2 
border Splus(t=0, 1){x=t-0.5; y=0.17735*sqrt(t) - 0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4); label=S;}
border Sminus(t=1, 0){x=t-0.5; y=-(0.17735*sqrt(t) - 0.075597*t - 0.212836*(t^2) + 0.17363*(t^3) - 0.06254*(t^4)); label=S;}
mesh Th = buildmesh(C(50) + Splus(70) + Sminus(70));
// Fespace
fespace Vh(Th, P2);
Vh psi, w;
real cost = cos(5.*pi/180.), sint=sin(5.*pi/180.);// incidence 5 degres
// Problem
solve potential(psi, w)
  = int2d(Th)(dx(psi)*dx(w)+dy(psi)*dy(w))
  + on(C, psi = cost*y-sint*x) 
  + on(S, psi=0);

// Plot
plot(psi, wait=1);

/// Thermic
// Parameters
real dt = 0.005, nbT = 50;

// Mesh
border D(t=0, 2.){x=0.5+t*cost; y=+t*sint;}
mesh Sh = buildmesh(C(25) + Splus(-90) + Sminus(-90) + D(200));
int steel = Sh(0.5, 0).region, air = Sh(-1, 0).region;
// Change label to put BC on In flow 
// Fespace
fespace Wh(Sh, P1);
Wh  vv;

fespace W0(Sh, P0);
W0 k = 0.01*(region == air) + 0.1*(region == steel);
W0 u1 = dy(psi)*(region == air), u2 = -dx(psi)*(region == air);
Wh v = 120*(region == steel), vold;
// pul label 10 on inflow boundary to inforce the temperature.
Sh = change(Sh,flabel = (label == C &&  [u1,u2]'*N<0) ? 10 : label);
int i;
problem thermic(v, vv, init=i, solver=LU)
  = int2d(Sh)(
      v*vv/dt + k*(dx(v)*dx(vv) + dy(v)*dy(vv))
    + 10*(u1*dx(v) + u2*dy(v))*vv
  )
  - int2d(Sh)(vold*vv/dt)
  + on(10, v= 0);
  

for(i = 0; i < nbT; i++) {
    vold[]= v[];
    thermic;
    plot(v);
}
plot(v, wait=1,fill=1,value=1);
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
int n = 3; // mesh quality

// Mesh
mesh Th = square(10*n, 10*n);

// Fespace
fespace Uh(Th, P1b);
Uh u, v;
Uh uu, vv;
fespace Ph(Th, P1);
Ph p, pp;

// Problem
solve stokes([u, v, p], [uu, vv, pp])
  = int2d(Th)(
      dx(u)*dx(uu) + dy(u)*dy(uu)
    + dx(v)*dx(vv) + dy(v)*dy(vv)
    + dx(p)*uu + dy(p)*vv
    + pp*(dx(u) + dy(v))
    -1e-10*p*pp
  )
  + on(1, 2, 4, u=0, v=0)
  + on(3, u=1, v=0)
  ;

// Plot
plot([u,v],p,wait=1);
// test dist and projection on meshL
load "msh3"
border C(t=0,2*pi){ x= cos(t); y=sin(t); label=1; region =1;}
meshL Lh =buildmeshL(C(20));
mesh Th= square(20,20,[(x-0.5)*3,(y-0.5)*3]);
mesh Th2= square(10,10,[(x-0.5)*3,(y-1.06)*3]);
fespace Vh(Th,P1);
Vh d=dist(Lh);
int nu;
R3 ph; 
Vh Ux = projection(Lh,nu=nu,Phat=ph).x-x;
Vh Uy = projection(Lh).y-y;
cout << nu << " " << ph << endl; 

//cout << Lh[nu](ph) << endl; 
plot(d, [Ux,Uy],Lh, wait=1);
 Ux = projection(Th2,nu=nu,Phat=ph).x-x;
 Uy = projection(Th2,nu=nu,Phat=ph).y-y;
 x=0;y=0;z=0;
 cout << projection(Th2,nu=nu,Phat=ph) <<", " << nu <<","<< ph << endl; 
 cout << Th2[nu][0].x << endl;
 cout << Th2[nu][0].y  << endl;
 cout << Th2[nu][1].x << endl;
 cout << Th2[nu][1].y  << endl;
 cout << Th2[nu][2].x << endl;
 cout << Th2[nu][2].y  << endl;
plot([Ux,Uy],Th2, wait=1);
load "msh3";
meshL Lh2 = extract(Th2);
//savemesh(Th2,"/tmp/Th2.mesh");
//savemesh(Lh2,"/tmp/Lh2.mesh");
meshS ThS= square3(10,10,[(x-0.5)*3,(y-1.06)*3,(x+y)/2]);
mesh3 Th3=cube(10,10,10,[(x-0.5)*3,(y-1.06)*3,z*2-1]);
fespace Uh(Th3,P1);
Uh d3=signeddist(ThS);
plot(d3,wait=1);
/****************************************************************************/
/* This file is part of FreeFEM.                                            */
/*                                                                          */
/* FreeFEM is free software: you can redistribute it and/or modify          */
/* it under the terms of the GNU Lesser General Public License as           */
/* published by the Free Software Foundation, either version 3 of           */
/* the License, or (at your option) any later version.                      */
/*                                                                          */
/* FreeFEM is distributed in the hope that it will be useful,               */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of           */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
/* GNU Lesser General Public License for more details.                      */
/*                                                                          */
/* You should have received a copy of the GNU Lesser General Public License */
/* along with FreeFEM. If not, see <http://www.gnu.org/licenses/>.          */
/****************************************************************************/

// Parameters
func u0 = 10+90*x/6;
func k = 1.8*(y<0.5) + 0.2;
real ue = 25, alpha = 0.25, T = 5, dt = 0.1;
real rad = 1e-8, uek = ue + 273.;

// Mesh
mesh Th = square(30, 5, [6*x, y]);

// Fespace
fespace Vh(Th,P1);
Vh vold, w, v=u0-ue, b;

// Problem
problem thermradia(v, w)
  = int2d(Th)(
      v*w/dt
    + k*(dx(v)*dx(w) + dy(v)*dy(w))
  )
  + int1d(Th, 1, 3)(b*v*w)
  - int2d(Th)(vold*w/dt)
  + on(2, 4, v=u0-ue);

for(real t = 0; t < T; t+=dt) {
  vold = v;
  for (int m = 0; m < 5; m++) {
    b = alpha + rad*(v + 2*uek)*((v+uek)^2 + uek^2);
    thermradia;
  }
}
vold = v + ue;

// Plot
plot(vold);
/*
solving stokes problem in 2 dimension:
-Delta u + Grad(p) = (f1,f2) in \Omega 
 div(u) = 0    in \Omega
 u = (g1,g2)   on \gamma 
*/

macro grad(u) [dx(u),dy(u)]//
macro Grad(u1,u2) [ grad(u1), grad(u2)]//
macro div(u1,u2) (dx(u1)+dy(u2))//

// definition of the boundary condition 
func g1 = sin(x)*cos(y);
func g2 = -cos(x)*sin(y);

// defintion of the right hand side
func f1 = 0;
func f2 = -4*cos(x)*sin(y);

int nn = 30; // number of edge in each direction
mesh Th=square(nn,nn,[2*pi*x,2*pi*y],flags=3);
mesh ThP=Th;                    // Pressure mesh
mesh ThU=trunc(ThP,1,split=2);  // Velocity mesh

fespace Uh(ThU,[P1,P1]);
fespace Ph(ThP,P1);

Uh [u1,u2],[v1,v2];
Ph p,q;

solve Stokes ( <[u1,u2],[p]>, <[v1,v2],[q]>) = int2d(ThU)( (Grad(u1,u2):Grad(v1,v2)) )
+ int2d(ThU)( - div(u1,u2)*q - div(v1,v2)*p )
+ int2d(ThP)( -1e-10*p*q )
- int2d(ThU) ( [f1,f2]'*[v1,v2] )
+ on(1,2,3,4,u1=g1,u2=g2);

plot( u1, cmm="u1" );
plot( u2, cmm="u2" );
plot( p,  cmm="p" );
