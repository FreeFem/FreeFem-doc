%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



\usepackage[margin=8pt]{subcaption}
\captionsetup{labelfont=bf}
\def\R{{\mathbb{R}}}
\def\C{{\mathbb{C}}}
\def\P{{\mathbb{P}}}
\def\p{{\partial}}
\def\n{{\nabla}}
\def\boldx{{\mathbf{x}}}
\def\boldxi{{\boldsymbol{\xi}}}
\def\arccosh{{\text{arccosh}}}
\def\arcsinh{{\text{arcsinh}}}
\def\arctanh{{\text{arctanh}}}
\def\vecttwo#1#2{\left|\begin{smallmatrix} #1 \\ #2 \end{smallmatrix}\right.}
\def\vectthree#1#2#3{\left|\begin{smallmatrix} #1 \\ #2 \\ #3\end{smallmatrix}\right.}
\def\bR{{\bf R}}
\def\bP{{\bf P}}
\def\bZ{{\bf Z}}
\def\bC{{\bf C}}
\def\VS{\bR^2}
\def\SVS{\underline V}
\def\SO{{\bf SO}}
\def\Sym{{\bf Sym}}
\def\qi{{\bf i}}
\def\qj{{\bf j}}
\def\qk{{\bf k}}
\def\ec{\hat{\bf e}}
\def\xc{\hat{\bf x}}
\def\bdr{\partial}
\def\PD{\partial_}
\def\strain{\underline \epsilon}
\def\stress{\underline \sigma}
\def\strainrate{\underline \epsilon^.}
\def\stressrate{\underline \sigma^.}
\def\stiff{\; \underline{\underline C}\;}
\def\comply{\underline{\underline \kappa}\;}
\def\Id{{\bf I}}
\def\Div{\nabla \cdot}
\def\Grad{\mathbf{\nabla}}
\def\rot{\nabla \times}
\def\lap{\triangle}
\def\tr{{\bf tr}\;}
\def\udH{\underline H}
\def\refX{\mathbf X}
\def\Jac{\overline{J}}
\def\spatx{\mathbf x}
\def\ani{\overline a}
\def\mat{\left[\begin{array}}
\def\tam{\end{array}\right]}
\def\arr{\left.\begin{array}}
\def\rra{\end{array}\right\}}
\def\arl{\left\{\begin{array}}
\def\lra{\end{array}\right.}
\def\ar{\begin{array}}
\def\ra{\end{array}}
\def\const{\mbox{ const.}}
\def\eps{\; \epsilon}
\def\sig{\; \sigma}
\def\th{\theta}
\def\sgn{\mbox{sgn}}
\def\qed{\; Q.E.D.\\}
\def\ranqe{\end{eqnarray}}
\def\ol{\overline}
\def\ul{\underline}
\def\bB{{\bf B}}
\def\bC{{\bf C}}
\def\bD{{\bf D}}
\def\bE{{\bf E}}
\def\bF{{\bf F}}
\def\bK{{\bf K}}
\def\bP{{\bf P}}
\def\bS{{\bf S}}
\def\bT{{\bf T}}
\def\bsig{{\bf \sigma}}
\def\T{{\mathbb{T}}}
\def\d{{text{d}}}
    

\title{FreeFEM Documentation}
\date{Feb 01, 2022}
\release{4.8}
\author{Frederic Hecht}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}

        \sphinxmaketitle
        \clearpage
        In collaboration with:
        \vfill
        \begin{minipage}{.49\linewidth}
            \centering
            \sphinxincludegraphics[width=.8\linewidth]{logo_LJLL.png}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\linewidth}
            \centering
            \sphinxincludegraphics[width=.8\linewidth]{logo_UPMC.png}
        \end{minipage}
        \vfill
        \begin{minipage}{.49\linewidth}
            \centering
            \sphinxincludegraphics[width=.8\linewidth]{logo_Sorbonne.png}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\linewidth}
            \centering
            \sphinxincludegraphics[width=.8\linewidth]{logo_ANR.png}
        \end{minipage}
        \vfill
        \begin{minipage}{.49\linewidth}
            \centering
            \sphinxincludegraphics[width=.8\linewidth]{logo_INRIA.png}
        \end{minipage}
        \hfill
        \begin{minipage}{.49\linewidth}
            \centering
            \sphinxincludegraphics[width=.8\linewidth]{logo_CNRS.png}
        \end{minipage}
    
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}




\bigskip\hrule\bigskip


\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\item[] 
\item[] 
\end{DUlineblock}


\chapter{\sphinxstylestrong{Introduction}}
\label{\detokenize{introduction/index:introduction}}\label{\detokenize{introduction/index::doc}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} is a partial differential equation solver for non\sphinxhyphen{}linear multi\sphinxhyphen{}physics systems in 1D, 2D, 3D and 3D border domains (surface and curve).

\sphinxAtStartPar
Problems involving partial differential equations from several branches of physics, such as fluid\sphinxhyphen{}structure interactions, require interpolations of data on several meshes and their manipulation within one program.
\sphinxstylestrong{FreeFEM} includes a fast interpolation algorithm and a language for the manipulation of data on multiple meshes.

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} is written in C++ and its language is a C++ idiom.

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} currently interfaces to the following libraries:
\begin{multicols}{3}\raggedright
\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.caam.rice.edu/software/ARPACK/}{ARPACK}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.netlib.org/blas/}{BLAS}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.openblas.net/}{OpenBLAS}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.fftw.org}{FFTW 3.3.2}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/coin-or/Ipopt}{Ipopt 3.12.4}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://getfem.org/gmm.html}{Gmm++ 4.2}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.ljll.math.upmc.fr/frey/software.html}{freeYams}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://glaros.dtc.umn.edu/gkhome/metis/metis/overview}{METIS}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://glaros.dtc.umn.edu/gkhome/metis/parmetis/overview}{ParMETIS}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.mmgtools.org/}{Mmg}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.ljll.math.upmc.fr/frey/software.html}{mshmet}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://ab-initio.mit.edu/wiki/index.php/NLopt}{NLopt 2.2.4}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.netlib.org/scalapack/}{ScaLAPACK}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://gforge.inria.fr/projects/scotch/}{Scotch}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://faculty.cse.tamu.edu/davis/suitesparse.html}{SuiteSparse}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.tetgen.org/}{TetGen}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://slepc.upv.es/}{SLEPc}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://pierremarchand.netlify.com/project/htool/}{HTool}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/hpddm/hpddm}{HPDDM}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/PierreMarchand20/BemTool}{BemTool}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/MmgTools/ParMmg}{ParMmg}

\end{itemize}\raggedcolumns\end{multicols}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.650\linewidth]{{Logo}.png}\hspace*{\fill}}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\item[] 
\item[] 
\item[] 
\item[] 
\end{DUlineblock}

\begin{center}\sphinxincludegraphics[scale=0.4]{{logo_cnrs_SU_UP}.png}  \sphinxincludegraphics[scale=0.2]{{inr_logo_rouge_300}.jpg}  \sphinxincludegraphics[scale=0.6]{{logo_LJLL}.png}    \sphinxincludegraphics[scale=0.45]{{logo_alpines}.png}
\end{center}

\section{Version 4.5: new features}
\label{\detokenize{introduction/new-features:version-4-5-new-features}}\label{\detokenize{introduction/new-features::doc}}
\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}


\subsection{Release, binaries packages}
\label{\detokenize{introduction/new-features:release-binaries-packages}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Since the version 4.5, the FreeFEM binary packages provides with a compiled PETSc library.

\item {} 
\sphinxAtStartPar
FreeFEM is now interfaced with ParMmg.

\end{itemize}


\subsection{New meshes and FEM border}
\label{\detokenize{introduction/new-features:new-meshes-and-fem-border}}
\sphinxAtStartPar
After Surface FEM, Line FEM is possible with a new mesh type \sphinxcode{\sphinxupquote{meshL}}, \sphinxcode{\sphinxupquote{P0}} \sphinxcode{\sphinxupquote{P1}} \sphinxcode{\sphinxupquote{P2}} \sphinxcode{\sphinxupquote{P1dc}} FE, basic FEM, mesh generation.
This new development allows to treat a 1d problem, such as a problem described on a 3d curve.


\bigskip\hrule\bigskip


\sphinxAtStartPar
Abstract about Line FEM in FreeFEM.
\begin{itemize}
\item {} 
\sphinxAtStartPar
new \sphinxstylestrong{meshL} type, refer to the section {\hyperref[\detokenize{documentation/mesh-generation:meshstype}]{\sphinxcrossref{\DUrole{std,std-ref}{The type meshL in 3 dimension}}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
new type of surface mesh: \sphinxcode{\sphinxupquote{meshL}}

\item {} 
\sphinxAtStartPar
the functionalities on the \sphinxcode{\sphinxupquote{meshL}} type, it is necessary to load the plugin ”msh3”.

\item {} 
\sphinxAtStartPar
generator of meshL \sphinxcode{\sphinxupquote{segment}}, define multi \sphinxcode{\sphinxupquote{border}} and \sphinxcode{\sphinxupquote{buildmesh}} function.

\item {} 
\sphinxAtStartPar
basic transformation are avalaible: \sphinxcode{\sphinxupquote{movemesh}}, \sphinxcode{\sphinxupquote{trunc}}, \sphinxcode{\sphinxupquote{extract}}, \sphinxcode{\sphinxupquote{checkmesh}}, \sphinxcode{\sphinxupquote{change}}, \sphinxcode{\sphinxupquote{AddLayers}}, glue of \sphinxcode{\sphinxupquote{meshL}}.

\sphinxAtStartPar
It is possible to build the underlying \sphinxcode{\sphinxupquote{meshL}} from a \sphinxcode{\sphinxupquote{meshS}} with the function \sphinxcode{\sphinxupquote{buildBdMesh}}: \sphinxcode{\sphinxupquote{ThS=buildBdMesh(ThS)}} builds the boundary domain associated to the \sphinxcode{\sphinxupquote{meshS}} ThS and extract it by the command \sphinxcode{\sphinxupquote{meshL}} ThL=ThS. \sphinxcode{\sphinxupquote{Gamma}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
new finite element space with curve finite element type

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FESpace}} \sphinxcode{\sphinxupquote{P0}} \sphinxcode{\sphinxupquote{P1}}, \sphinxcode{\sphinxupquote{P2}}, \sphinxcode{\sphinxupquote{P1dc}} Lagrange finite elements and possible to add a custumed finite element with the classical method (like a plugin).

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
as in the standard 2d, 3d, surface 3d case, the variational problem associated to surface PDE can be defined by using the keywords
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{problem}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{varf}} to access to matrix and RHS vector

\item {} 
\sphinxAtStartPar
available operators are \sphinxcode{\sphinxupquote{int1d}}, \sphinxcode{\sphinxupquote{on}} and the operator \sphinxcode{\sphinxupquote{int0d}} to define a Neumann boundary condition

\end{itemize}

\item {} 
\sphinxAtStartPar
visualisation tools
\begin{itemize}
\item {} 
\sphinxAtStartPar
plot with \sphinxcode{\sphinxupquote{plot}} of ffglut, \sphinxcode{\sphinxupquote{medit}} meshes meshL and solutions

\item {} 
\sphinxAtStartPar
2d or 3d view, with in 3d the option to visualize the elememt Normals at element (touch ‘T’) and the deformed domain according to it (touch ‘2’).

\item {} 
\sphinxAtStartPar
loading, saving of meshes and solution at FreeFEM’s format
\begin{itemize}
\item {} 
\sphinxAtStartPar
“.mesh”  mesh format file of Medit (P. Frey LJLL)

\item {} 
\sphinxAtStartPar
“.msh” for mesh and “.sol” data solution at freefem format

\item {} 
\sphinxAtStartPar
“.msh” data file of Gmsh (Mesh generator) (load  “gmsh”)

\item {} 
\sphinxAtStartPar
vtk format for meshes and solutions (load “iovtk” and use the “.vtu” extension)

\end{itemize}

\end{itemize}

\end{itemize}


\bigskip\hrule\bigskip



\subsection{Boundary Element Method}
\label{\detokenize{introduction/new-features:boundary-element-method}}
\sphinxAtStartPar
Allows to define and solve a 2d/3d BEM formulation and rebuild the associated potential.
The document is in construction.


\section{Installation guide}
\label{\detokenize{introduction/installation:installation-guide}}\label{\detokenize{introduction/installation::doc}}
\sphinxAtStartPar
To use FreeFEM, two installation methods are available: user access (binary package) and access developers (from the source code).
Follow the section corresponding to your type of installation.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Since the version 4.5, FreeFEM relese provides with the last version of PETSc.
\end{sphinxadmonition}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}


\subsection{Using binary package}
\label{\detokenize{introduction/installation:using-binary-package}}
\sphinxAtStartPar
First, open the following web page {\hyperref[\detokenize{introduction/download:download}]{\sphinxcrossref{\DUrole{std,std-ref}{download page}}}} and choose your platform: Linux, MacOS or Windows.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Binary packages are available for Microsoft Windows, MacOS and some Linux distributions. Since the release 4.5, FreeFEM binaries provide with the current version of PETSc.
\end{sphinxadmonition}

\sphinxAtStartPar
Install \sphinxstylestrong{FreeFEM} by double\sphinxhyphen{}clicking on the appropriate file. Under Linux and MacOS the install directory is one of the following \sphinxcode{\sphinxupquote{/usr/local/bin}}, \sphinxcode{\sphinxupquote{/usr/local/share/freefem++}}, \sphinxcode{\sphinxupquote{/usr/local/lib/ff++}}


\subsubsection{Windows installation}
\label{\detokenize{introduction/installation:windows-installation}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The windows package is build for Window 7 64bits. The support ended for all releases under Windows 32 bits since the V4.
\end{sphinxadmonition}

\sphinxAtStartPar
First download the windows installation executable, then double click to install \sphinxstylestrong{FreeFEM}.
Install MSMPI for parallel version under window64 MS MPI V10.1.2, and install both msmpisdk.msi and MSMpiSetup.exe.

\sphinxAtStartPar
In most cases just answer yes (or type return) to all questions.

\sphinxAtStartPar
Otherwise in the Additional Task windows, check the box “Add application directory to your system path.” This is required otherwise the program \sphinxcode{\sphinxupquote{ffglut.exe}} will not be found.

\sphinxAtStartPar
By now you should have two new icons on your desktop:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FreeFem++ (VERSION).exe}}, the \sphinxcode{\sphinxupquote{freefem++}} application.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FreeFem++ (VERSION) Examples}}, a link to the \sphinxcode{\sphinxupquote{freefem++}} examples folder.

\end{itemize}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{(VERSION)}} is the version of the files (for example 4.5).

\sphinxAtStartPar
By default, the installed files are in \sphinxcode{\sphinxupquote{C:\textbackslash{}Programs Files\textbackslash{}FreeFem++}}. In this directory, you have all the \sphinxcode{\sphinxupquote{.dll}} files and other applications: \sphinxcode{\sphinxupquote{FreeFem++\sphinxhyphen{}nw.exe}}, \sphinxcode{\sphinxupquote{ffglut.exe}}, … The syntax for the command\sphinxhyphen{}line tools are the same as those of \sphinxcode{\sphinxupquote{FreeFem.exe}}.

\sphinxAtStartPar
To use FreeFEM binaries under Windows, two methods are possible:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use the FreeFEM launcher (launchff++.exe)

\end{itemize}

\sphinxAtStartPar
Warning: if you launch FreeFEM without filename script by double\sphinxhyphen{}clicking, your get a error due (it is bug of usage GetOpenFileName in win64).
\begin{itemize}
\item {} 
\sphinxAtStartPar
In shell terminal (cmd, powershell, bash, … ):
\begin{itemize}
\item {} 
\sphinxAtStartPar
To launch sequential version:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
C:\PYG{l+s+se}{\PYGZbs{}\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}Program Files (x86)\PYGZbs{}FreeFem++\PYGZbs{}FreeFem++.exe\PYGZdq{}} \PYGZlt{}mySequentialScript.edp\PYGZgt{}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
To launch parallel version:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
C:\PYG{l+s+se}{\PYGZbs{}\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}Program Files\PYGZbs{}Microsoft MPI\PYGZbs{}Bin\PYGZbs{}mpiexec.exe\PYGZdq{}} \PYGZhy{}n \PYGZlt{}nbProcs\PYGZgt{} C:\PYG{l+s+se}{\PYGZbs{}\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}Program Files (x86)\PYGZbs{}FreeFem++\PYGZbs{}FreeFem++\PYGZhy{}mpi.exe\PYGZdq{}} \PYGZlt{}myParallelScript.edp\PYGZgt{}
\end{sphinxVerbatim}

\end{itemize}


\subsubsection{macOS X installation}
\label{\detokenize{introduction/installation:macos-x-installation}}
\sphinxAtStartPar
Download the macOS X binary version file, extract all the files by double clicking on the icon of the file, go the the directory and put the \sphinxcode{\sphinxupquote{FreeFem++.app}} application in the \sphinxcode{\sphinxupquote{/Applications}} directory.

\sphinxAtStartPar
If you want terminal access to \sphinxstylestrong{FreeFEM} just copy the file \sphinxcode{\sphinxupquote{FreeFem++}} in a directory of your \sphinxcode{\sphinxupquote{\$PATH}} shell environment variable.


\subsubsection{Ubuntu installation}
\label{\detokenize{introduction/installation:ubuntu-installation}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The Debian package is built for Ubuntu 16.04
\end{sphinxadmonition}

\sphinxAtStartPar
Beforehand, install the following dependances libraries using the apt tool:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo apt\PYGZhy{}get install libgsl\PYGZhy{}dev libhdf5\PYGZhy{}dev
             liblapack\PYGZhy{}dev libopenmpi\PYGZhy{}dev freeglut3\PYGZhy{}dev
\end{sphinxVerbatim}

\sphinxAtStartPar
Download the package FreeFEM .deb, install it by the command

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
dpkg \PYGZhy{}i FreeFEM\PYGZus{}VERSION\PYGZus{}Ubuntu\PYGZus{}withPETSc\PYGZus{}amd64.deb
\end{sphinxVerbatim}

\sphinxAtStartPar
FreeFEM is directly available in your terminal by the command “FreeFem++”.


\subsubsection{Arch AUR package}
\label{\detokenize{introduction/installation:arch-aur-package}}
\sphinxAtStartPar
An up\sphinxhyphen{}to\sphinxhyphen{}date package of \sphinxstylestrong{FreeFEM} for Arch is available on the \sphinxhref{https://aur.archlinux.org/packages/freefem\%2B\%2B-git/}{Archlinux user repository}.

\sphinxAtStartPar
To install it:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://aur.archlinux.org/freefem++\PYGZhy{}git.git
\PYG{n+nb}{cd} freefem++\PYGZhy{}git
makepkg \PYGZhy{}si
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Thanks to \sphinxhref{https://github.com/stefanhusmann}{Stephan Husmann}
\end{sphinxadmonition}


\subsubsection{Fedora installation}
\label{\detokenize{introduction/installation:fedora-installation}}
\sphinxAtStartPar
Packages are available in the
\sphinxhref{https://src.fedoraproject.org/rpms/freefem++}{Fedora Repositories},
and they are managed by the
\sphinxhref{https://fedoraproject.org/wiki/SIGs/SciTech/PackageList}{Fedora SciTech special interest group}.
The packages are usually recent builds, but may not be the latest released version.

\sphinxAtStartPar
You can install them using the dnf tool, for both the serial and parallel (MPI)
versions. :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo dnf install freefem++
sudo dnf install freefem++\PYGZhy{}openmpi
sudo dnf install freefem++\PYGZhy{}mpich
\end{sphinxVerbatim}

\sphinxAtStartPar
FreeFEM is directly available in your terminal by the command “FreeFem++”.
To use the OpenMPI version, in your terminal first load the OpenMPI module,
for example using

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
module load mpi/openmpi\PYGZhy{}x86\PYGZus{}64
\end{sphinxVerbatim}

\sphinxAtStartPar
and then the command “FreeFem++\sphinxhyphen{}mpi\_openmpi” will be available in your
terminal. To use the MPICH version, in your terminal first load the MPICH
module using

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
module load mpi/mpich\PYGZhy{}x86\PYGZus{}64
\end{sphinxVerbatim}

\sphinxAtStartPar
and then the command “FreeFem++\sphinxhyphen{}mpi\_mpich” will be available in your
terminal.


\subsection{Compiling source code}
\label{\detokenize{introduction/installation:compiling-source-code}}\begin{description}
\item[{Various versions of FreeFEM are possible:}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
sequential and without plugins (contains in 3rdparty)

\item {} 
\sphinxAtStartPar
parallel with plugins (and with PETSc).

\end{itemize}
\begin{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We advise you to use the package manager for macOS Homebrew to get the different packages required avalaible \sphinxhref{https://brew.sh}{here}
\end{sphinxadmonition}
\end{quote}

\end{description}


\subsubsection{Compilation on OSX (\textgreater{}=10.13)}
\label{\detokenize{introduction/installation:compilation-on-osx-10-13}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install Xcode, Xcode Command Line tools and Xcode Additional Tools from the \sphinxhref{https://developer.apple.com/download/more/}{Apple website}

\item {} 
\sphinxAtStartPar
Install gfortran from Homebrew

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 brew cask install gfortran
\end{sphinxVerbatim}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If you have installed gcc via brew, gfortran comes with it and you do not need this line
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
To use \sphinxstylestrong{FreeFEM} parallel version, install \sphinxhref{https://www.open-mpi.org/software/ompi/v4.0/}{openmpi}  or  \sphinxhref{http://www.mpich.org/downloads/}{mpich}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{c+c1}{\PYGZsh{} to install openmpi}
 curl \PYGZhy{}L https://download.open\PYGZhy{}mpi.org/release/open\PYGZhy{}mpi/v4.0/openmpi\PYGZhy{}4.0.1.tar.gz \PYGZhy{}\PYGZhy{}output openmpi\PYGZhy{}4.0.1.tar.gz
 tar xf openmpi\PYGZhy{}4.0.1
 \PYG{n+nb}{cd} openmpi\PYGZhy{}4.0.1/
 \PYG{c+c1}{\PYGZsh{} to install mpich}
 curl \PYGZhy{}L http://www.mpich.org/static/downloads/3.3.2/mpich\PYGZhy{}3.3.2.tar.gz \PYGZhy{}\PYGZhy{}output mpich\PYGZhy{}3.3.2.tar.gz
 tar xf mpich\PYGZhy{}3.3.2
 \PYG{n+nb}{cd} mpich\PYGZhy{}3.3.2
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=4,stepnumber=1]
 \PYG{c+c1}{\PYGZsh{} with brew gcc gfortran compilers}
 ./configure \PYG{n+nv}{CC}\PYG{o}{=}clang \PYG{n+nv}{CXX}\PYG{o}{=}clang++ \PYG{n+nv}{FC}\PYG{o}{=}gfortran\PYGZhy{}9 \PYG{n+nv}{F77}\PYG{o}{=}gfortran\PYGZhy{}9 \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed

 \PYG{c+c1}{\PYGZsh{} with LLVM gcc and brew gfortran compilers}
 ./configure \PYG{n+nv}{CC}\PYG{o}{=}gcc\PYGZhy{}9 \PYG{n+nv}{CXX}\PYG{o}{=}g++\PYGZhy{}9 \PYG{n+nv}{FC}\PYG{o}{=}gfortran\PYGZhy{}9 \PYG{n+nv}{F77}\PYG{o}{=}gfortran\PYGZhy{}9 \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=5,stepnumber=1]
 make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{}
 make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{} install
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Install the minimal libraries for \sphinxstylestrong{FreeFEM}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
brew install m4 git flex bison
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
If you want build your own configure according your system, install autoconf and automake from Homebrew (optional, see note in step 10)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
brew install autoconf automake
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
To use \sphinxstylestrong{FreeFEM} with its plugins, install from Homebrew suitesparse, hdf5, cmake, wget

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
brew install suitesparse hdf5 cmake wget
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Install \sphinxhref{https://www.gnu.org/software/gsl}{gsl}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
curl \PYGZhy{}O http://mirror.cyberbits.eu/gnu/gsl/gsl\PYGZhy{}2.5.tar.gz
tar zxvf gsl\PYGZhy{}2.5.tar.gz
\PYG{n+nb}{cd} gsl\PYGZhy{}2.5
./configure
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{}
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{} install \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download the latest Git for Mac installer \sphinxhref{https://git-scm.com/download/mac}{git} and the \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Configure your source code

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
 autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
if your autoreconf version is too old, do \sphinxcode{\sphinxupquote{tar zxvf AutoGeneratedFile.tar.gz}}
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxAtStartPar
following your compilers

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=3,stepnumber=1]
// with brew gcc gfortran compilers
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYG{n+nv}{CC}\PYG{o}{=}clang \PYG{n+nv}{CXX}\PYG{o}{=}clang++ \PYG{n+nv}{F77}\PYG{o}{=}gfortran\PYGZhy{}9
    \PYG{n+nv}{FC}\PYG{o}{=}gfortran\PYGZhy{}9 \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed

// with LLVM gcc and brew gfortran compilers
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYG{n+nv}{CC}\PYG{o}{=}clang \PYG{n+nv}{CXX}\PYG{o}{=}clang++ \PYG{n+nv}{F77}\PYG{o}{=}gfortran\PYGZhy{}9
    \PYG{n+nv}{FC}\PYG{o}{=}gfortran\PYGZhy{}9 \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download the 3rd party packages to use FreeFEM plugins

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./3rdparty/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
All the third party packages have their own licence
\end{sphinxadmonition}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{10}
\item {} 
\sphinxAtStartPar
If you want use PETSc/SLEPc and \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} (High Performance Domain Decomposition Methods)

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} 3rdparty/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc // add \PYG{n+nv}{SUDO}\PYG{o}{=}sudo \PYG{k}{if} your installation directory is the default /usr/local
\PYG{n+nb}{cd} \PYGZhy{}
./reconfigure
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{11}
\item {} 
\sphinxAtStartPar
Build your \sphinxstylestrong{FreeFEM} library and executable

\end{enumerate}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{}
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{} check
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make check}} is optional, but advised to check the validity of your \sphinxstylestrong{FreeFEM} build
\end{sphinxadmonition}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{12}
\item {} \begin{description}
\item[{Install the \sphinxstylestrong{FreeFEM} apllication}] \leavevmode
\sphinxAtStartPar
make install // add SUDO=sudo might be necessary

\end{description}

\end{enumerate}
\begin{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
it isn’t necessary to execute this last command, FreeFEM executable is avalaible here your\_installation/src/nw/FreeFem++ and mpi executable here your\_installation/src/mpi/ff\sphinxhyphen{}mpirun.
\end{sphinxadmonition}
\end{quote}


\subsubsection{Compilation on Ubuntu}
\label{\detokenize{introduction/installation:compilation-on-ubuntu}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install the following packages on your system

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo apt\PYGZhy{}get update \PYG{o}{\PYGZam{}\PYGZam{}} sudo apt\PYGZhy{}get upgrade
sudo apt\PYGZhy{}get install cpp freeglut3\PYGZhy{}dev g++ gcc gfortran \PYG{l+s+se}{\PYGZbs{}}
    m4 make patch pkg\PYGZhy{}config wget python unzip \PYG{l+s+se}{\PYGZbs{}}
    liblapack\PYGZhy{}dev libhdf5\PYGZhy{}dev libgsl\PYGZhy{}dev \PYG{l+s+se}{\PYGZbs{}}
    autoconf automake autotools\PYGZhy{}dev bison flex gdb git cmake

\PYG{c+c1}{\PYGZsh{} mpich is required for the FreeFEM parallel computing version}
sudo apt\PYGZhy{}get install mpich
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In the oldest distribution of Ubuntu, \sphinxcode{\sphinxupquote{libgsl\sphinxhyphen{}dev}} does not exist, use \sphinxcode{\sphinxupquote{libgsl2\sphinxhyphen{}dev}} instead
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Download \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
if your autoreconf version is too old, do \sphinxcode{\sphinxupquote{tar zxvf AutoGeneratedFile.tar.gz}}
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim
    \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
To see all the options, type \sphinxcode{\sphinxupquote{./configure \sphinxhyphen{}\sphinxhyphen{}help}}
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Download the 3rd party packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./3rdparty/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
If you want use PETSc/SLEPc and \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} (High Performance Domain Decomposition Methods) for massively parallel computing

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} 3rdparty/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc // add \PYG{n+nv}{SUDO}\PYG{o}{=}sudo \PYG{k}{if} your installation directory is the default /usr/local
\PYG{n+nb}{cd} \PYGZhy{}
./reconfigure
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Build your \sphinxstylestrong{FreeFEM} library and executable

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{}
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{} check
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make check}} is optional, but advised to check the validity of your \sphinxstylestrong{FreeFEM} build
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Install the executable

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make install
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
it isn’t necessary to execute this last command, FreeFEM executable is avalaible here your\_installation/src/nw/FreeFem++ and mpi executable here your\_installation/src/mpi/ff\sphinxhyphen{}mpirun
\end{sphinxadmonition}

\end{enumerate}


\subsubsection{Compilation on Arch Linux}
\label{\detokenize{introduction/installation:compilation-on-arch-linux}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
As Arch is in rolling release, the following information can be quickly outdated !
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} fails to compile using the newest version of gcc 8.1.0, use an older one instead.
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install the following dependencies:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syu
pacman \PYGZhy{}S git openmpi gcc\PYGZhy{}fortran wget python
    freeglut m4 make patch gmm
    blas lapack hdf5 gsl fftw arpack suitesparse
    gnuplot autoconf automake bison flex gdb
    valgrind cmake texlive\PYGZhy{}most
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download the \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
To see all the options, type \sphinxcode{\sphinxupquote{./configure \sphinxhyphen{}\sphinxhyphen{}help}}
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Download the packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./3rdparty/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
If you want use \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} (High Performance Domain Decomposition Methods) for massively parallel computing, install PETSc/SLEPc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} 3rdparty/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc \PYG{n+nv}{SUDO}\PYG{o}{=}sudo
\PYG{n+nb}{cd} \PYGZhy{}
./reconfigure
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Compile the \sphinxstylestrong{FreeFEM} source

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If your computer has many threads, you can run \sphinxcode{\sphinxupquote{make}} in parallel using \sphinxcode{\sphinxupquote{make \sphinxhyphen{}j16}} for 16 threads, for example.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Optionally, check the compilation with \sphinxcode{\sphinxupquote{make check}}
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Install the \sphinxstylestrong{FreeFEM} application

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo make install
\end{sphinxVerbatim}

\end{enumerate}


\subsubsection{Compilation on Fedora}
\label{\detokenize{introduction/installation:compilation-on-fedora}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install the following packages on your system

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
sudo dnf update
sudo dnf install freeglut\PYGZhy{}devel gcc\PYGZhy{}gfortran gcc\PYGZhy{}c++ gcc \PYG{l+s+se}{\PYGZbs{}}
                  m4 make wget python2 python3 unzip \PYG{l+s+se}{\PYGZbs{}}
                  lapack\PYGZhy{}devel hdf5\PYGZhy{}devel gsl gsl\PYGZhy{}devel \PYG{l+s+se}{\PYGZbs{}}
                  autoconf automake bison flex gdb git cmake

\PYG{c+c1}{\PYGZsh{} MPICH or OpenMPI is required for the FreeFEM parallel computing version}
sudo dnf install mpich\PYGZhy{}devel
sudo dnf install openmpi\PYGZhy{}devel

\PYG{c+c1}{\PYGZsh{} Then load one of the modules, for example}
module load mpi/mpich\PYGZhy{}x86\PYGZus{}64
\PYG{c+c1}{\PYGZsh{} or}
module load mpi/openmpi\PYGZhy{}x86\PYGZus{}64
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download \sphinxstylestrong{FreeFEM} source from the repository

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources.git
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Autoconf

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
if your autoreconf version is too old, do \sphinxcode{\sphinxupquote{tar zxvf AutoGeneratedFile.tar.gz}}
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Configure

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim
    \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
To see all the options, type \sphinxcode{\sphinxupquote{./configure \sphinxhyphen{}\sphinxhyphen{}help}}
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Download the 3rd party packages

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./3rdparty/getall \PYGZhy{}a
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
All the third party packages have their own licence
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
If you want use PETSc/SLEPc and \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} (High Performance Domain Decomposition Methods) for massively parallel computing

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} 3rdparty/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc // add \PYG{n+nv}{SUDO}\PYG{o}{=}sudo \PYG{k}{if} your installation directory is the default /usr/local
\PYG{n+nb}{cd} \PYGZhy{}
./reconfigure
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Build your \sphinxstylestrong{FreeFEM} library and executable

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{}
make \PYGZhy{}j\PYGZlt{}nbProcs\PYGZgt{} check
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{make check}} is optional, but advised to check the validity of your \sphinxstylestrong{FreeFEM} build
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
Install the executable

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
make install
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
it isn’t necessary to execute this last command, FreeFEM executable is avalaible here your\_installation/src/nw/FreeFem++ and mpi executable here your\_installation/src/mpi/ff\sphinxhyphen{}mpirun
\end{sphinxadmonition}

\end{enumerate}


\subsubsection{Compilation on Linux with Intel software tools}
\label{\detokenize{introduction/installation:compilation-on-linux-with-intel-software-tools}}
\sphinxAtStartPar
Follow the \sphinxhref{https://software.intel.com/en-us/articles/building-freefem-with-intel-software-tools-for-developers}{guide}


\subsubsection{Compilation on Windows}
\label{\detokenize{introduction/installation:compilation-on-windows}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The support ended for all releases under Windows 32 bits since the V4.
We assume your development machine is 64\sphinxhyphen{}bit, and you want your compiler to target 64\sphinxhyphen{}bit windows by default.
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Install the \sphinxhref{https://www.microsoft.com/en-us/download/details.aspx?id=100593}{Microsoft MPI v10.1.2 (archived)} (msmpisdk.msi and MSMpiSetup.exe)

\item {} 
\sphinxAtStartPar
Download \sphinxhref{http://repo.msys2.org/distrib/msys2-x86\_64-latest.exe}{msys2\sphinxhyphen{}x86\_64\sphinxhyphen{}latest.exe} (x86\_64 version) and run it.

\item {} 
\sphinxAtStartPar
Install the version control system \sphinxhref{https://git-scm.com/download/win}{Git} for Windows

\end{enumerate}

\sphinxAtStartPar
4. In the MSYS2 shell, execute the following.
Hint: if you right click the title bar, go to Options \sphinxhyphen{}\textgreater{} Keys and tick “Ctrl+Shift+letter shortcuts” you can use Ctrl+Shift+V to paste in the MSYS shell.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syuu
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Close the MSYS2 shell once you’re asked to. There are now 3 MSYS subsystems installed: MSYS2, MinGW32 and MinGW64.
They can respectively be launched from C:devmsys64msys2.exe, C:devmsys64mingw32.exe and C:devmsys64mingw64.exe
Reopen MSYS2 (doesn’t matter which version, since we’re merely installing packages).
Repeatedly run the following command until it says there are no further updates. You might have to restart your shell again.
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}Syuu
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Now that MSYS2 is fully up\sphinxhyphen{}to\sphinxhyphen{}date, install the following dependancies
\begin{itemize}
\item {} 
\sphinxAtStartPar
for 64 bit systems:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}S autoconf make automake\PYGZhy{}wrapper bison git \PYG{l+s+se}{\PYGZbs{}}
  mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}freeglut mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}toolchain \PYG{l+s+se}{\PYGZbs{}}
  mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}openblas patch python perl pkg\PYGZhy{}config pkgfile \PYG{l+s+se}{\PYGZbs{}}
  rebase tar \PYG{n+nb}{time} tzcode unzip which mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}libmicroutils \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}ignore mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gcc\PYGZhy{}ada \PYGZhy{}\PYGZhy{}ignore mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gcc\PYGZhy{}objc \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}ignore mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}gdb mingw\PYGZhy{}w64\PYGZhy{}x86\PYGZus{}64\PYGZhy{}cmake \PYGZhy{}\PYGZhy{}noconfirm
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
for 32 bit systems (\sphinxstylestrong{FreeFEM} lower than version 4):

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
pacman \PYGZhy{}S autoconf automake\PYGZhy{}wrapper bash bash\PYGZhy{}completion \PYG{l+s+se}{\PYGZbs{}}
  bison bsdcpio bsdtar bzip2 coreutils curl dash file filesystem \PYG{l+s+se}{\PYGZbs{}}
  findutils flex gawk gcc gcc\PYGZhy{}fortran gcc\PYGZhy{}libs grep gzip inetutils \PYG{l+s+se}{\PYGZbs{}}
  info less lndir make man\PYGZhy{}db git mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}freeglut \PYG{l+s+se}{\PYGZbs{}}
  mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}toolchain mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}gsl mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}hdf5 \PYG{l+s+se}{\PYGZbs{}}
  mingw\PYGZhy{}w64\PYGZhy{}i686\PYGZhy{}openblas mintty msys2\PYGZhy{}keyring msys2\PYGZhy{}launcher\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
  msys2\PYGZhy{}runtime ncurses pacman pacman\PYGZhy{}mirrors pactoys\PYGZhy{}git patch pax\PYGZhy{}git \PYG{l+s+se}{\PYGZbs{}}
  perl pkg\PYGZhy{}config pkgfile rebase sed tar tftp\PYGZhy{}hpa \PYG{n+nb}{time} tzcode unzip \PYG{l+s+se}{\PYGZbs{}}
  util\PYGZhy{}linux which
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Open a \sphinxcode{\sphinxupquote{MingW64 terminal}} (or \sphinxcode{\sphinxupquote{MingW32}} for old 32 bit \sphinxstylestrong{FreeFEM} version) and compile the \sphinxstylestrong{FreeFEM} source

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
git clone https://github.com/FreeFem/FreeFem\PYGZhy{}sources
\PYG{n+nb}{cd} FreeFem\PYGZhy{}sources
autoreconf \PYGZhy{}i
./configure \PYGZhy{}\PYGZhy{}enable\PYGZhy{}generic \PYGZhy{}\PYGZhy{}enable\PYGZhy{}optim \PYG{l+s+se}{\PYGZbs{}}
  \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}enable\PYGZhy{}maintainer\PYGZhy{}mode \PYG{l+s+se}{\PYGZbs{}}
  \PYG{n+nv}{CXXFLAGS}\PYG{o}{=}\PYGZhy{}mtune\PYG{o}{=}generic \PYG{n+nv}{CFLAGS}\PYG{o}{=}\PYGZhy{}mtune\PYG{o}{=}generic \PYG{l+s+se}{\PYGZbs{}}
  \PYG{n+nv}{FFLAGS}\PYG{o}{=}\PYGZhy{}mtune\PYG{o}{=}generic \PYGZhy{}\PYGZhy{}enable\PYGZhy{}download \PYGZhy{}\PYGZhy{}disable\PYGZhy{}hips
          \PYGZhy{}\PYGZhy{}prefix\PYG{o}{=}/where/you/want/to/have/files/installed
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
If you want use \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} (High Performance Domain Decomposition Methods) for massively parallel computing, install PETSc/SLEPc

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{cd} 3rdparty/ff\PYGZhy{}petsc
make petsc\PYGZhy{}slepc \PYG{n+nv}{SUDO}\PYG{o}{=}sudo
\PYG{n+nb}{cd} \PYGZhy{}
./reconfigure
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download the 3rd party packages and build your \sphinxstylestrong{FreeFEM} library and executable

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
./3rdparty/getall \PYGZhy{}a
make
make check
make install
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxstylestrong{FreeFEM} executable (and some other like \sphinxcode{\sphinxupquote{ffmedit}}, …) are in \sphinxcode{\sphinxupquote{C:\textbackslash{}msys64\textbackslash{}mingw64\textbackslash{}bin}} (or \sphinxcode{\sphinxupquote{C:\textbackslash{}msys32\textbackslash{}mingw32\textbackslash{}bin}}).
\end{sphinxadmonition}

\end{enumerate}


\subsection{Environment variables and init file}
\label{\detokenize{introduction/installation:environment-variables-and-init-file}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} reads a user’s init file named \sphinxcode{\sphinxupquote{freefem++.pref}} to initialize global variables: \sphinxcode{\sphinxupquote{verbosity}}, \sphinxcode{\sphinxupquote{includepath}}, \sphinxcode{\sphinxupquote{loadpath}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The variable \sphinxcode{\sphinxupquote{verbosity}} changes the level of internal printing (0: nothing unless there are syntax errors, 1: few, 10: lots, etc. …), the default value is 2.

\sphinxAtStartPar
The included files are found in the \sphinxcode{\sphinxupquote{includepath}} list and the load files are found in the \sphinxcode{\sphinxupquote{loadpath}} list.
\end{sphinxadmonition}

\sphinxAtStartPar
The syntax of the file is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{verbosity} \PYG{o}{=} \PYG{l+m}{5}
\PYG{n+nv}{loadpath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Library/FreeFem++/lib\PYGZdq{}}
\PYG{n+nv}{loadpath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Users/hecht/Library/FreeFem++/lib\PYGZdq{}}
\PYG{n+nv}{includepath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Library/FreeFem++/edp\PYGZdq{}}
\PYG{n+nv}{includepath} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}/Users/hecht/Library/FreeFem++/edp\PYGZdq{}}
\PYG{c+c1}{\PYGZsh{} This is a comment}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}funcTemplate\PYGZdq{}}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}myfunction\PYGZdq{}}
\PYG{n+nv}{load} \PYG{o}{+=} \PYG{l+s+s2}{\PYGZdq{}MUMPS\PYGZus{}seq\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The possible paths for this file are
\begin{itemize}
\item {} 
\sphinxAtStartPar
under Unix and MacOs

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
/etc/freefem++.pref
\PYG{k}{\PYGZdl{}(}HOME\PYG{k}{)}/.freefem++.pref
freefem++.pref
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
under windows

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
freefem++.pref
\end{sphinxVerbatim}

\sphinxAtStartPar
We can also use shell environment variables to change verbosity and the search rule before the init files.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}VERBOSITY}\PYG{o}{=}\PYG{l+m}{50}
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}INCLUDEPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dir;;dir2\PYGZdq{}}
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}LOADPATH}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}dir;;dir3\PYGZdq{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The separator between directories must be “;” and not “:” because “:” is used under Windows.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
To show the list of init of \sphinxstylestrong{FreeFEM} , do

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nb}{export} \PYG{n+nv}{FF\PYGZus{}VERBOSITY}\PYG{o}{=}\PYG{l+m}{100}\PYG{p}{;}
./FreeFem++\PYGZhy{}nw
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}


\subsection{Coloring Syntax FreeFem++}
\label{\detokenize{introduction/installation:coloring-syntax-freefem}}

\subsubsection{Atom}
\label{\detokenize{introduction/installation:atom}}
\sphinxAtStartPar
In order to get the syntax highlighting in \sphinxhref{https://atom.io/}{Atom}, you have to install the \sphinxhref{https://atom.io/packages/language-freefem-official}{FreeFEM language support}.

\sphinxAtStartPar
You can do it directly in Atom: Edit \sphinxhyphen{}\textgreater{} Preferences \sphinxhyphen{}\textgreater{} Install, and search for \sphinxcode{\sphinxupquote{language\sphinxhyphen{}freefem\sphinxhyphen{}offical}}.

\sphinxAtStartPar
To launch scripts directly from Atom, you have to install the \sphinxcode{\sphinxupquote{atom\sphinxhyphen{}runner}} package. Once installed, modify the Atom configuration file (Edit \sphinxhyphen{}\textgreater{} Config…) to have something like that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+s+s2}{\PYGZdq{}*\PYGZdq{}}:
   ...

   runner:
      extensions:
         edp: \PYG{l+s+s2}{\PYGZdq{}FreeFem++\PYGZdq{}}
      scopes:
         \PYG{l+s+s2}{\PYGZdq{}Freefem++\PYGZdq{}}: \PYG{l+s+s2}{\PYGZdq{}FreeFem++\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Reboot Atom, and use Alt+R to run a FreeFem++ script.


\subsubsection{Gedit}
\label{\detokenize{introduction/installation:gedit}}
\sphinxAtStartPar
In order to get the syntax highlighting in Gedit, you have to downlaod the \sphinxhref{https://github.com/FreeFem/FreeFem-parser-gedit}{Gedit parser} and copy it in \sphinxcode{\sphinxupquote{/usr/share/gtksourceview\sphinxhyphen{}3.0/language\sphinxhyphen{}specs/}}.


\subsubsection{Textmate 2, an editor under macOS}
\label{\detokenize{introduction/installation:textmate-2-an-editor-under-macos}}
\sphinxAtStartPar
To use the coloring \sphinxstylestrong{FreeFEM} syntax with the Textmate 2 editor on Mac 10.7 or better, download from macromates.com and download the textmate freefem++ syntax \sphinxhref{http://www3.freefem.org/ff++/Textmate2-ff++.zip}{here} (version june 2107). To install this parser, unzip Textmate2\sphinxhyphen{}ff++.zip and follow the explanation given in file How\_To.rtf.

\sphinxAtStartPar
rom www.freefem.org/ff++/Textmate2\sphinxhyphen{}ff++.zip (version june 2107) unzip Textmate2\sphinxhyphen{}


\subsubsection{Notepad++,an editor under windows}
\label{\detokenize{introduction/installation:notepad-an-editor-under-windows}}
\sphinxAtStartPar
Read and follow the instruction, \sphinxhref{http://www3.freefem.org/ff++/color-syntax-win.pdf}{FREEFEM++ COLOR SYNTAX OF WINDOWS} .


\subsubsection{Emacs editor}
\label{\detokenize{introduction/installation:emacs-editor}}
\sphinxAtStartPar
For emacs editor you can download \sphinxhref{https://github.com/rrgalvan/freefem-mode/}{ff++\sphinxhyphen{}mode.el} .


\section{Download}
\label{\detokenize{introduction/download:download}}\label{\detokenize{introduction/download:id1}}\label{\detokenize{introduction/download::doc}}

\subsection{Latest binary packages}
\label{\detokenize{introduction/download:latest-binary-packages}}
\sphinxAtStartPar
FreeFEM v4.6 runs under macOS, Ubuntu, and 64\sphinxhyphen{}bit Windows.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Operating System
&\sphinxstyletheadfamily 
\sphinxAtStartPar
FreeFEM Version
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Size
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Date
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/v4.5/FreeFem++-4.5-full-MacOS\_10.11.pkg}{macOS 10.10.5 or higher}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{4.5}}
&
\sphinxAtStartPar
412 MB
&
\sphinxAtStartPar
Feb 11, 2020
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/v4.6/FreeFEM\_4.6\_Ubuntu\_withPETSc\_amd64.deb}{Ubuntu 16.04 or higher}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{4.6}}
&
\sphinxAtStartPar
212 MB
&
\sphinxAtStartPar
Mar 02, 2020
\\
\hline\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/releases/download/v4.6/FreeFEM-4.6-win7-64.exe}{64\sphinxhyphen{}bit Windows}             | \sphinxcode{\sphinxupquote{4.6}}           |  185 MB
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&
\sphinxAtStartPar
Mar 02, 2020
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://hub.docker.com/r/freefem/freefem}{Docker image}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{4.6}}
&
\sphinxAtStartPar
487 MB
&
\sphinxAtStartPar
Mar 02, 2020
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/archive/v4.6.tar.gz}{Source 4.6}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{4.6}}
&
\sphinxAtStartPar
12.4 MB
&
\sphinxAtStartPar
Mar 02, 2020
\\
\hline
\sphinxAtStartPar
\sphinxhref{http://www3.freefem.org/ff++/ftp/}{previous releases}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The source code is available on the \sphinxhref{https://github.com/FreeFem/FreeFem-sources}{FreeFEM GitHub Repository}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The support ended for all releases under Windows 32 bits.
\end{sphinxadmonition}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}


\subsection{Syntax highlighters}
\label{\detokenize{introduction/download:syntax-highlighters}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Lexer type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Version
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\hline
\sphinxAtStartPar
Emacs
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0.3}}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/freefem-parser-emacs}{freefem\sphinxhyphen{}mode.el}
\\
\hline
\sphinxAtStartPar
Textmate 2
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-textmate}{FreeFem.tmbundle}
\\
\hline
\sphinxAtStartPar
Gedit
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/Freefem-parser-gedit}{ffpp.lang}
\\
\hline
\sphinxAtStartPar
Atom
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0.3}}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-atom}{language\sphinxhyphen{}freefem} or via the Atom package manager
\\
\hline
\sphinxAtStartPar
Pygments
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1.0}}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-pygments}{freefem.py}
\\
\hline
\sphinxAtStartPar
Vim
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0.1}}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-parser-vim}{edp.vim}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{History}
\label{\detokenize{introduction/history:history}}\label{\detokenize{introduction/history::doc}}\begin{quote}

\sphinxAtStartPar
The project has evolved from MacFem, PCfem, written in Pascal.
The first C version lead to \sphinxcode{\sphinxupquote{freefem 3.4}}; it offered mesh adaptivity on a single mesh only.

\sphinxAtStartPar
A thorough rewriting in \sphinxcode{\sphinxupquote{C++}} led to \sphinxcode{\sphinxupquote{freefem+}} (\sphinxcode{\sphinxupquote{freefem+}} 1.2.10 was its last release), which included interpolation over multiple meshes (functions defined on one mesh can be used on any other mesh); this software is no longer maintained but is still in use because it handles a problem description using the strong form of the PDEs.
Implementing the interpolation from one unstructured mesh to another was not easy because it had to be fast and non\sphinxhyphen{}diffusive; for each point, one had to find the containing triangle.
This is one of the basic problems of computational geometry (see \sphinxcite{bibliography:preparata1985} for example).
Doing it in a minimum number of operations was the challenge.
Our implementation is \(\mathcal{O}(n log n)\) and based on a quadtree.
This version also grew out of hand because of the evolution of the template syntax in \sphinxcode{\sphinxupquote{C++}}.

\sphinxAtStartPar
We have been working for a few years now on \sphinxstylestrong{FreeFEM} , entirely re\sphinxhyphen{}written again in \sphinxcode{\sphinxupquote{C++}} with a thorough usage of template and generic programming for coupled systems of unknown size at compile time.
Like all versions of \sphinxcode{\sphinxupquote{freefem}}, it has a high level user friendly input language which is not too far from the mathematical writing of the problems.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{freefem}} language allows for a quick specification of any partial differential system of equations.
The language syntax of \sphinxstylestrong{FreeFEM} is the result of a new design which makes use of the STL \sphinxcite{bibliography:stroustrup2000}, templates, and bison for its implementation; more details can be found in \sphinxcite{bibliography:hecht2002}.
The outcome is a versatile software in which any new finite elements can be included in a few hours; but a recompilation is then necessary.
Therefore the library of finite elements available in \sphinxstylestrong{FreeFEM} will grow with the version number and with the number of users who program more new elements.
So far we have discontinuous \(P_0\) elements,linear \(P_1\) and quadratic \(P_2\) Lagrangian elements, discontinuous \(P_1\) and Raviart\sphinxhyphen{}Thomas elements and a few others like bubble elements.
\end{quote}

\begin{DUlineblock}{0em}
\item[] 
\item[] 
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
The development of FreeFEM through more than 30 years

\begin{DUlineblock}{0em}
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
\sphinxstylestrong{1987}
\begin{quote}

\sphinxAtStartPar
MacFem/PCFem the old ones (O. Pironneau in Pascal) no free.
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{1992}
\begin{quote}

\sphinxAtStartPar
\sphinxhref{http://www3.freefem.org/ff++/freefem/fraold.htm}{FreeFem} rewrite in C++ (P1,P0 one mesh ) O. Pironneau, D. Bernardi, F.Hecht (mesh adaptation , bamg) , C. Prudhomme .
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{1996}
\begin{quote}

\sphinxAtStartPar
\sphinxhref{http://www3.freefem.org/ff++/freefem/index.html}{FreeFem+} rewrite in C++ (P1,P0 more mesh) O. Pironneau, D. Bernardi, F.Hecht (algebra of function).
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{1998}
\begin{quote}

\sphinxAtStartPar
FreeFem++ rewrite with an other finite element kernel and an new language F. Hecht, O. Pironneau, K.Ohtsuka.
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{1999}
\begin{quote}

\sphinxAtStartPar
FreeFem 3d (S. Del Pino),  a fist 3d version base on fictitious domaine method.
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{2008}
\begin{quote}

\sphinxAtStartPar
FreeFem++ v3 use a new finite element kernel multidimensionnels: 1d,2d,3d…
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{2014}
\begin{quote}

\sphinxAtStartPar
FreeFem++ v3.34 parallel version
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{2017}
\begin{quote}

\sphinxAtStartPar
FreeFem++ v3.57 parallel version
\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{2018}
\begin{quote}

\sphinxAtStartPar
FreeFem++ v4: New matrix type, Surface element, New Parallel tools …
\end{quote}


\section{Citation}
\label{\detokenize{introduction/citation:citation}}\label{\detokenize{introduction/citation::doc}}

\subsection{If you use \sphinxstylestrong{FreeFEM}, please cite the following reference in your work:}
\label{\detokenize{introduction/citation:if-you-use-freefem-please-cite-the-following-reference-in-your-work}}

\subsubsection{BibTeX}
\label{\detokenize{introduction/citation:bibtex}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nc}{@article}\PYG{p}{\PYGZob{}}\PYG{n+nl}{MR3043640}\PYG{p}{,}
  \PYG{n+na}{AUTHOR} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{Hecht, F.}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{TITLE} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{New development in FreeFem++}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{JOURNAL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{J. Numer. Math.}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{FJOURNAL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{Journal of Numerical Mathematics}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{VOLUME} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{20}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,} \PYG{n+na}{YEAR} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{2012}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{NUMBER} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{3\PYGZhy{}4}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,} \PYG{n+na}{PAGES} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{251\PYGZhy{}\PYGZhy{}265}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{ISSN} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{1570\PYGZhy{}2820}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{MRCLASS} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{65Y15}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{MRNUMBER} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{3043640}\PYG{l+s}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n+na}{URL} \PYG{p}{=} \PYG{l+s}{\PYGZob{}}\PYG{l+s}{https://freefem.org/}\PYG{l+s}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{APA}
\label{\detokenize{introduction/citation:apa}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Hecht, F. (2012). New development in FreeFem++. Journal of numerical mathematics, 20(3\PYGZhy{}4), 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{ISO690}
\label{\detokenize{introduction/citation:iso690}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
HECHT, Frédéric. New development in FreeFem++. Journal of numerical mathematics, 2012, vol. 20, no 3\PYGZhy{}4, p. 251\PYGZhy{}266.
\end{sphinxVerbatim}


\subsubsection{MLA}
\label{\detokenize{introduction/citation:mla}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Hecht, Frédéric. \PYGZdq{}New development in FreeFem++.\PYGZdq{} Journal of numerical mathematics 20.3\PYGZhy{}4 (2012): 251\PYGZhy{}266.
\end{sphinxVerbatim}


\section{Authors}
\label{\detokenize{introduction/authors:authors}}\label{\detokenize{introduction/authors::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Frédéric Hecht
\\
\hline
\sphinxAtStartPar
Professor at \sphinxhref{https://www.ljll.math.upmc.fr/}{Laboratoire Jacques Louis Lions}
(LJLL), Sorbonne University, Paris
\\
\hline
\sphinxAtStartPar
\sphinxhref{mailto:frederic.hecht@sorbonne-universite.fr}{frederic.hecht@sorbonne\sphinxhyphen{}universite.fr}
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://www.ljll.math.upmc.fr/hecht/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Sylvain Auliac
\\
\hline
\sphinxAtStartPar
Former PhD student at LJLL, optimization interface with
\sphinxhref{https://nlopt.readthedocs.io/en/latest/}{nlopt},
\sphinxhref{https://projects.coin-or.org/Ipopt}{ipopt},
\sphinxhref{https://en.wikipedia.org/wiki/CMA-ES}{cmaes}, …
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://www.ljll.math.upmc.fr/auliac/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Olivier Pironneau
\\
\hline
\sphinxAtStartPar
Professor of numerical analysis at the Paris VI university and at
LJLL, numerical methods in fluid
\\
\hline
\sphinxAtStartPar
Member of the \sphinxhref{http://www.iufrance.fr/}{Institut Universitaire de
France} and \sphinxhref{http://www.academie-sciences.fr/fr/}{Academie des
Sciences}
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://www.ljll.math.upmc.fr/pironneau/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Jacques Morice
\\
\hline
\sphinxAtStartPar
Former Post\sphinxhyphen{}Doc at LJLL, three dimensions mesh generation and
coupling with
\sphinxhref{https://www.ljll.math.upmc.fr/frey/logiciels/Docmedit.dir/index.html}{medit}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Antoine Le Hyaric
\\
\hline
\sphinxAtStartPar
\sphinxhref{http://www.cnrs.fr}{CNRS} research engineer at \sphinxhref{https://www.ljll.math.upmc.fr/}{Laboratoire Jacques Louis
Lions}, expert in
software engineering for scientific applications, electromagnetics
simulations, parallel computing and three\sphinxhyphen{}dimensionsal visualization
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://www.ljll.math.upmc.fr/lehyaric/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Kohji Ohtsuka
\\
\hline
\sphinxAtStartPar
Professor at \sphinxhref{http://www.hkg.ac.jp/html/}{Hiroshima Kokusai Gakuin
University}, Japan and chairman of the
\sphinxhref{http://www.wseas.org}{World Scientific and Engineering Academy and
Society}, Japan. Fracture dynamic, modeling
and computing
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://sites.google.com/a/comfos.org/comfos/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pierre\sphinxhyphen{}Henri Tournier
\\
\hline
\sphinxAtStartPar
\sphinxhref{http://www.cnrs.fr}{CNRS} research engineer at \sphinxhref{https://www.ljll.math.upmc.fr/}{Laboratoire Jacques Louis
Lions} (LJLL), Sorbonne University, Paris
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Pierre Jolivet
\\
\hline
\sphinxAtStartPar
\sphinxhref{http://www.cnrs.fr}{CNRS} researcher, MPI interface with \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc}, \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM}, …
\\
\hline
\sphinxAtStartPar
\sphinxurl{http://jolivet.perso.enseeiht.fr/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Frédéric Nataf
\\
\hline
\sphinxAtStartPar
\sphinxhref{http://www.cnrs.fr}{CNRS} senior researcher at \sphinxhref{https://www.ljll.math.upmc.fr/}{Laboratoire Jacques Louis
Lions} (LJLL), Sorbonne University, Paris
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://www.ljll.math.upmc.fr/nataf/}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Simon Garnotel
\\
\hline
\sphinxAtStartPar
Reasearch engineer at \sphinxhref{https://www.airthium.com}{Airthium}
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://github.com/sgarnotel}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Karla Pérez
\\
\hline
\sphinxAtStartPar
Developer, \sphinxhref{https://www.airthium.com}{Airthium} internship
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://github.com/karlaprzbr}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Loan Cannard
\\
\hline
\sphinxAtStartPar
Web designer, \sphinxhref{https://www.airthium.com}{Airthium} internship
\\
\hline
\sphinxAtStartPar
\sphinxurl{https://www.linkedin.com/in/loancannard}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
And all the dedicated \sphinxhref{https://github.com/FreeFem/FreeFem-doc/graphs/contributors}{Github contributors}


\section{Contributing}
\label{\detokenize{introduction/contributing:contributing}}\label{\detokenize{introduction/contributing::doc}}

\subsection{Bug report}
\label{\detokenize{introduction/contributing:bug-report}}

\subsubsection{Concerning the \sphinxstylestrong{FreeFEM} documentation}
\label{\detokenize{introduction/contributing:concerning-the-freefem-documentation}}
\sphinxAtStartPar
Open an \sphinxhref{https://github.com/FreeFem/FreeFem-doc/issues}{Issue} on \sphinxstylestrong{FreeFem\sphinxhyphen{}doc} repository.


\subsubsection{Concerning the \sphinxstylestrong{FreeFEM} compilation or usage}
\label{\detokenize{introduction/contributing:concerning-the-freefem-compilation-or-usage}}
\sphinxAtStartPar
Open an \sphinxhref{https://github.com/FreeFem/FreeFem-sources/issues}{Issue} on \sphinxstylestrong{FreeFem\sphinxhyphen{}sources} repository.


\subsection{Improve content}
\label{\detokenize{introduction/contributing:improve-content}}
\sphinxAtStartPar
Ask one of the contributors for Collaborator Access or make a \sphinxhref{https://github.com/FreeFem/FreeFem-doc/pulls}{Pull Request}.


\chapter{Learning by Examples}
\label{\detokenize{tutorials/index:learning-by-examples}}\label{\detokenize{tutorials/index:tutorial}}\label{\detokenize{tutorials/index::doc}}
\begin{DUlineblock}{0em}
\item[] 
\item[] 
\end{DUlineblock}

\sphinxAtStartPar
The \sphinxstylestrong{FreeFEM} language is {\hyperref[\detokenize{references/types:referencetypes}]{\sphinxcrossref{\DUrole{std,std-ref}{typed}}}}, polymorphic and reentrant with {\hyperref[\detokenize{references/types:typemacrodesign}]{\sphinxcrossref{\DUrole{std,std-ref}{macro generation}}}}.

\sphinxAtStartPar
Every variable must be typed and declared in a statement, that is separated from the next by a semicolon \sphinxcode{\sphinxupquote{;}}.

\sphinxAtStartPar
The \sphinxstylestrong{FreeFEM} language is a C++ idiom with something that is more akin to LaTeX.

\sphinxAtStartPar
For the specialist, one key guideline is that \sphinxstylestrong{FreeFEM} rarely generates an internal finite element array, this was adopted for speed and consequently \sphinxstylestrong{FreeFEM} could be hard to beat in terms of execution speed, except for the time lost in the interpretation of the language (which can be reduced by a systematic usage of \sphinxcode{\sphinxupquote{varf}} and \sphinxcode{\sphinxupquote{matrix}} instead of \sphinxcode{\sphinxupquote{problem}}).

\sphinxAtStartPar
The Development Cycle: Edit\textendash{}Run/Visualize\textendash{}Revise

\sphinxAtStartPar
Many examples and tutorials are given there after and in the {\hyperref[\detokenize{examples/index:examples}]{\sphinxcrossref{\DUrole{std,std-ref}{examples section}}}}.
It is better to study them and learn by example.

\sphinxAtStartPar
If you are a beginner in the finite element method, you may also have to read a book on variational formulations.

\sphinxAtStartPar
The development cycle includes the following steps:

\sphinxAtStartPar
\sphinxstylestrong{Modeling:} From strong forms of PDE to weak forms, one must know the variational formulation to use \sphinxstylestrong{FreeFEM}; one should also have an eye on the reusability of the variational formulation so as to keep the same internal matrices; a typical example is the time dependent heat equation with an implicit time scheme: the internal matrix can be factorized only once and \sphinxstylestrong{FreeFEM} can be taught to do so.

\sphinxAtStartPar
\sphinxstylestrong{Programming:} Write the code in \sphinxstylestrong{FreeFEM} language using a text editor such as the one provided in your integrated environment.

\sphinxAtStartPar
\sphinxstylestrong{Run:} Run the code (here written in file \sphinxcode{\sphinxupquote{mycode.edp}}).
That can also be done in terminal mode by :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ mycode.edp
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Visualization:} Use the keyword \sphinxcode{\sphinxupquote{plot}} directly in \sphinxcode{\sphinxupquote{mycode.edp}} to display functions while \sphinxstylestrong{FreeFEM} is running.
Use the plot\sphinxhyphen{}parameter \sphinxcode{\sphinxupquote{wait=1}} to stop the program at each plot.

\sphinxAtStartPar
\sphinxstylestrong{Debugging:} A global variable \sphinxcode{\sphinxupquote{debug}} (for example) can help as in \sphinxcode{\sphinxupquote{wait=true}} to \sphinxcode{\sphinxupquote{wait=false}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{debug} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot the borders to see the intersection}
\PYG{c+c1}{//so change (0.8 in 0.3 in b)}
\PYG{c+c1}{//if debug == true, press Enter to continue}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot Th then press Enter}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{g} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot the function f}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{n}{debug}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot the function g}
\end{sphinxVerbatim}

\sphinxAtStartPar
Changing debug to false will make the plots flow continuously.
Watching the flow of graphs on the screen (while drinking coffee) can then become a pleasant experience.

\sphinxAtStartPar
Error management

\sphinxAtStartPar
Error messages are displayed in the console window.
They are not always very explicit because of the template structure of the C++ code (we did our best!).
Nevertheless they are displayed at the right place.
For example, if you forget parenthesis as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{debug} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then you will get the following message from \sphinxstylestrong{FreeFEM}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{2} : mesh \PYG{n+nv}{Th} \PYG{o}{=} square\PYG{o}{(}\PYG{l+m}{10},10\PYG{p}{;}
Error line number \PYG{l+m}{2}, in file bb.edp, before  token \PYG{p}{;}
parse error
current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{2}
syntax error
current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{2}
Compile error : syntax error
line number :2, \PYG{p}{;}
error Compile error : syntax error
line number :2, \PYG{p}{;}
\PYG{n+nv}{code} \PYG{o}{=} \PYG{l+m}{1} mpirank: \PYG{l+m}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you use the same symbol twice as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{aaa} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{aaa}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then you will get the message:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{2} : real aaa\PYG{p}{;} The identifier aaa exists
      the existing \PYG{n+nb}{type} is \PYGZlt{}Pd\PYGZgt{}
      the new  \PYG{n+nb}{type} is \PYGZlt{}Pd\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you find that the program isn’t doing what you want you may also use \sphinxcode{\sphinxupquote{cout}} to display in text format on the console window the value of variables, just as you would do in C++.

\sphinxAtStartPar
The following example works:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{fespace} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Another trick is to \sphinxstyleemphasis{comment in and out} by using \sphinxcode{\sphinxupquote{//}} as in C++.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{aaa} \PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{c+c1}{// real aaa;}
\end{sphinxVerbatim}


\section{Getting started}
\label{\detokenize{tutorials/poisson:getting-started}}\label{\detokenize{tutorials/poisson:tutorialpoisson}}\label{\detokenize{tutorials/poisson::doc}}
\sphinxAtStartPar
For a given function \(f(x,y)\), find a function \(u(x,y)\) satisfying :
\begin{equation}\label{equation:tutorials/poisson:eqn:Poisson}
\begin{split}\begin{array}{rcl}
    -\Delta u(x,y) &= f(x,y) & \mbox{ for all }(x,y)\mbox{ in }\Omega\\
    u(x,y) &= 0 & \mbox{ for all }(x,y)\mbox{ on }\partial\Omega
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
Here \(\partial\Omega\) is the boundary of the bounded open set \(\Omega\subset\mathbb{R}^2\) and \(\Delta u = \frac{\partial^2 u}{\partial x^2 } + \frac{\partial^2 u}{\partial y^2}\).

\sphinxAtStartPar
We will compute \(u\) with \(f(x,y)=xy\) and \(\Omega\) the unit disk. The boundary \(C=\partial\Omega\) is defined as:
\begin{equation*}
\begin{split}C=\{(x,y)|\; x=\cos(t),\, y=\sin(t),\, 0\le t\le 2\pi\}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM}, the domain \(\Omega\) is assumed to be described by the left side of its boundary.
\end{sphinxadmonition}

\sphinxAtStartPar
The following is the \sphinxstylestrong{FreeFEM} program which computes \(u\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Define mesh boundary}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// The triangulated domain Th is on the left side of its boundary}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// The finite element space defined over Th is called here Vh}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}\PYG{c+c1}{// Define u and v as piecewise\PYGZhy{}P1 continuous functions}

\PYG{c+c1}{// Define a function f}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Get the clock in second}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Define the PDE}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{c+c1}{// The bilinear part}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{c+c1}{// The right hand side}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// The Dirichlet boundary condition}

\PYG{c+c1}{// Plot the result}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display the total computational time}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPU time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
As illustrated in \hyperref[\detokenize{tutorials/poisson:figpoissonu}]{Fig.\@ \ref{\detokenize{tutorials/poisson:figpoissonu}}}, we can see the isovalue of \(u\) by using \sphinxstylestrong{FreeFEM} \sphinxcode{\sphinxupquote{plot}} command (see line 29 above).

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{firstTh}.png}
\caption{Mesh Th by \sphinxcode{\sphinxupquote{buildmesh(C(50))}}}\label{\detokenize{tutorials/poisson:id1}}\label{\detokenize{tutorials/poisson:figpoissonmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{firstU}.png}
\caption{Isovalue by \sphinxcode{\sphinxupquote{plot(u)}}}\label{\detokenize{tutorials/poisson:id2}}\label{\detokenize{tutorials/poisson:figpoissonu}}\end{subfigure}
\caption{Poisson’s equation}\phantomsection\label{\detokenize{tutorials/poisson:Poisson}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The qualifier \sphinxcode{\sphinxupquote{solver=LU}} (line 18) is not required and by default a multi\sphinxhyphen{}frontal \sphinxcode{\sphinxupquote{LU}} is used.

\sphinxAtStartPar
The lines containing \sphinxcode{\sphinxupquote{clock}} are equally not required.
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Note how close to the mathematics \sphinxstylestrong{FreeFEM} language is.

\sphinxAtStartPar
Lines 19 to 24 correspond to the mathematical variational equation:
\begin{equation*}
\begin{split}\int_{T_h}
(
   \frac{\partial u}{\partial x}\frac{\partial v}{\partial x}
   + \frac{\partial u}{\partial y}\frac{\partial v}{\partial y}
)\text{d} x \text{d} y
= \int_{T_h}f v\text{d} x\text{d} y\end{split}
\end{equation*}
\sphinxAtStartPar
for all \(v\) which are in the finite element space \(V_h\) and zero on the boundary \(C\).
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Change \sphinxcode{\sphinxupquote{P1}} into \sphinxcode{\sphinxupquote{P2}} and run the program.
\end{sphinxadmonition}

\sphinxAtStartPar
This first example shows how \sphinxstylestrong{FreeFEM} executes with no effort all the usual steps required by the finite element method (FEM).
Let’s go through them one by one.

\sphinxAtStartPar
\sphinxstylestrong{On the line 2}:

\sphinxAtStartPar
The boundary \(\Gamma\) is described analytically by a parametric equation for \(x\) and for \(y\).
When \(\Gamma=\sum_{j=0}^J \Gamma_j\) then each curve \(\Gamma_j\) must be specified and crossings of \(\Gamma_j\) are not allowed except at end points.

\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{label}} can be added to define a group of boundaries for later use (boundary conditions for instance).
Hence the circle could also have been described as two half circle with the same label:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Boundaries can be referred to either by name (\sphinxcode{\sphinxupquote{Gamma1}} for example) or by label (\sphinxcode{\sphinxupquote{C}} here) or even by its internal number here 1 for the first half circle and 2 for the second (more examples are in {\hyperref[\detokenize{examples/mesh-generation:examplemeshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Meshing Examples}}}}).

\sphinxAtStartPar
\sphinxstylestrong{On the line 5}

\sphinxAtStartPar
The triangulation \(\mathcal{T}_h\) of \(\Omega\) is automatically generated by \sphinxcode{\sphinxupquote{buildmesh(C(50))}} using 50 points on \sphinxcode{\sphinxupquote{C}} as in \hyperref[\detokenize{tutorials/poisson:figpoissonmesh}]{Fig.\@ \ref{\detokenize{tutorials/poisson:figpoissonmesh}}}.

\sphinxAtStartPar
The domain is assumed to be on the left side of the boundary which is implicitly oriented by the parametrization. So an elliptic hole can be added by typing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If by mistake one had written:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then the inside of the ellipse would be triangulated as well as the outside.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Automatic mesh generation is based on the Delaunay\sphinxhyphen{}Voronoi algorithm.
Refinement of the mesh are done by increasing the number of points on \(\Gamma\), for example \sphinxcode{\sphinxupquote{buildmesh(C(100))}}, because inner vertices are determined by the density of points on the boundary.

\sphinxAtStartPar
Mesh adaptation can be performed also against a given function \sphinxtitleref{f} by calling \sphinxcode{\sphinxupquote{adaptmesh(Th,f)}}.
\end{sphinxadmonition}

\sphinxAtStartPar
Now the name \(\mathcal{T}_h\) (\sphinxcode{\sphinxupquote{Th}} in \sphinxstylestrong{FreeFEM}) refers to the family \(\{T_k\}_{k=1,\cdots,n_t}\) of triangles shown in \hyperref[\detokenize{tutorials/poisson:figpoissonmesh}]{Fig.\@ \ref{\detokenize{tutorials/poisson:figpoissonmesh}}}.

\sphinxAtStartPar
Traditionally \(h\) refers to the mesh size, \(n_t\) to the number of triangles in \(\mathcal{T}_h\) and \(n_v\) to the number of vertices, but it is seldom that we will have to use them explicitly.

\sphinxAtStartPar
If \(\Omega\) is not a polygonal domain, a “skin” remains between the exact domain \(\Omega\) and its approximation \(\Omega_h=\cup_{k=1}^{n_t}T_k\).
However, we notice that all corners of \(\Gamma_h = \partial\Omega_h\) are on \(\Gamma\).

\sphinxAtStartPar
\sphinxstylestrong{On line 8:}

\sphinxAtStartPar
A finite element space is, usually, a space of polynomial functions on elements, triangles here only, with certain matching properties at edges, vertices etc. Here \sphinxcode{\sphinxupquote{fespace Vh(Th, P1)}} defines \(V_h\) to be the space of continuous functions which are affine in \(x,y\) on each triangle of \(T_h\).

\sphinxAtStartPar
As it is a linear vector space of finite dimension, basis can be found.
The canonical basis is made of functions, called the \sphinxstyleemphasis{hat function} \(\phi_k\), which are continuous piecewise affine and are equal to 1 on one vertex and 0 on all others. A typical hat function is shown on \hyperref[\detokenize{tutorials/poisson:figpoissonhat}]{Fig.\@ \ref{\detokenize{tutorials/poisson:figpoissonhat}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{meshTh_2}.png}
\caption{\sphinxcode{\sphinxupquote{mesh Th}}}\label{\detokenize{tutorials/poisson:id3}}\label{\detokenize{tutorials/poisson:figpoissonmesh2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{hat_functions}.png}
\caption{Graph of \(\phi_1\) (left) and \(\phi_6\) (right)}\label{\detokenize{tutorials/poisson:id4}}\label{\detokenize{tutorials/poisson:figpoissonhat}}\end{subfigure}
\caption{Hat functions}\phantomsection\label{\detokenize{tutorials/poisson:HatFunctions}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The easiest way to define \(\phi_k\) is by making use of the \sphinxstyleemphasis{barycentric coordinates} \(\lambda_i(x,y),~i=1,2,3\) of a point \(q=(x,y)\in T\), defined by \(\sum_i\lambda_i=1,~~~\sum_i\lambda_i\vec q^i=\vec q\) where \(q^i,~i=1,2,3\) are the 3 vertices of \(T\).
Then it is easy to see that the restriction of \(\phi_k\) on \(T\) is precisely \(\lambda_k\).
\end{sphinxadmonition}

\sphinxAtStartPar
Then:
\begin{equation}\label{equation:tutorials/poisson:equation3}
\begin{split}V_h(\mathcal{T}_h,P_1)=\left\{w(x,y)\left|\; w(x,y)=\sum_{k=1}^{M}w_k\phi_k(x,y),\, w_k\textrm{ are real numbers}\right.\right\}\end{split}
\end{equation}
\sphinxAtStartPar
where \(M\) is the dimension of \(V_h\), i.e. the number of vertices.
The \(w_k\) are called the \sphinxstyleemphasis{degrees of freedom} of \(w\) and \(M\) the number of degree of freedom.

\sphinxAtStartPar
It is said also that the \sphinxstyleemphasis{nodes} of this finite element method are the vertices.

\sphinxAtStartPar
\sphinxstylestrong{Setting the problem}

\sphinxAtStartPar
On line 9, \sphinxcode{\sphinxupquote{Vh u, v}} declares that \(u\) and \(v\) are approximated as above, namely:
\begin{equation}\label{equation:tutorials/poisson:defu}
\begin{split}u(x,y)\simeq u_h(x,y)=\sum_{k=0}^{M-1} u_k\phi_k(x,y)\end{split}
\end{equation}
\sphinxAtStartPar
On the line 12, the right hand side \sphinxcode{\sphinxupquote{f}} is defined analytically using the keyword \sphinxcode{\sphinxupquote{func}}.

\sphinxAtStartPar
Line 18 to 26 define the bilinear form of equation \eqref{equation:tutorials/poisson:eqn:Poisson} and its Dirichlet boundary conditions.

\sphinxAtStartPar
This \sphinxstyleemphasis{variational formulation} is derived by multiplying \eqref{equation:tutorials/poisson:eqn:Poisson} by \(v(x,y)\) and integrating the result over \(\Omega\):
\begin{equation*}
\begin{split}-\int_{\Omega}v\Delta u \,\text{d} x\text{d} y = \int_{\Omega} vf\, \text{d} x\text{d} y\end{split}
\end{equation*}
\sphinxAtStartPar
Then, by Green’s formula, the problem is converted into finding \(u\) such that
\begin{equation*}
\begin{split}a(u,v) - \ell(f,v) = 0 \quad \forall v \mbox{ satisfying }v=0\mbox{ on }\partial\Omega.\end{split}
\end{equation*}
\sphinxAtStartPar
with:
\begin{equation}\label{equation:tutorials/poisson:eqn:weakform}
\begin{split}\begin{array}{rcl}
    a(u,v) &=& \int_{\Omega}\nabla u\cdot \nabla v \,\text{d} x\text{d} y\\
    \ell(f,v) &=& \int_{\Omega}fv\, \text{d} x\text{d} y
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} the \sphinxstylestrong{Poisson} problem can be declared only as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{;} \PYG{k+kt}{problem} \PYG{n}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
and solved later as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Poisson}\PYG{p}{;} \PYG{c+c1}{//the problem is solved here}
\end{sphinxVerbatim}

\sphinxAtStartPar
or declared and solved at the same time as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{;} \PYG{k+kt}{solve} \PYG{n}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
and \eqref{equation:tutorials/poisson:eqn:weakform} is written with \sphinxcode{\sphinxupquote{dx(u)}} \(=\partial u/\partial x\), \sphinxcode{\sphinxupquote{dy(u)}} \(=\partial u/\partial y\) and:

\sphinxAtStartPar
\(\displaystyle{\int_{\Omega}\nabla u\cdot \nabla v\, \text{d} x\text{d} y \longrightarrow}\)
\sphinxcode{\sphinxupquote{int2d(Th)( dx(u)*dx(v) + dy(u)*dy(v) )}}

\sphinxAtStartPar
\(\displaystyle{\int_{\Omega}fv\, \text{d} x\text{d} y \longrightarrow}\)
\sphinxcode{\sphinxupquote{int2d(Th)( f*v )}} (Notice here, \(u\) is unused)

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} \sphinxstylestrong{bilinear terms and linear terms should not be under the same integral} indeed to construct the linear systems \sphinxstylestrong{FreeFEM} finds out which integral contributes to the bilinear form by checking if both terms, the unknown (here \sphinxcode{\sphinxupquote{u}}) and test functions (here \sphinxcode{\sphinxupquote{v}}) are present.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Solution and visualization}

\sphinxAtStartPar
On line 15, the current time in seconds is stored into the real\sphinxhyphen{}valued variable \sphinxcode{\sphinxupquote{cpu}}.

\sphinxAtStartPar
Line 18, the problem is solved.

\sphinxAtStartPar
Line 29, the visualization is done as illustrated in \hyperref[\detokenize{tutorials/poisson:figpoissonu}]{Fig.\@ \ref{\detokenize{tutorials/poisson:figpoissonu}}}.

\sphinxAtStartPar
\sphinxstylestrong{(see} {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot}}}} \sphinxstylestrong{for zoom, postscript and other commands).}

\sphinxAtStartPar
Line 32, the computing time (not counting graphics) is written on the console. Notice the C++\sphinxhyphen{}like syntax; the user needs not study C++ for using \sphinxstylestrong{FreeFEM}, but it helps to guess what is allowed in the language.

\sphinxAtStartPar
\sphinxstylestrong{Access to matrices and vectors}

\sphinxAtStartPar
Internally \sphinxstylestrong{FreeFEM} will solve a linear system of the type
\begin{equation}\label{equation:tutorials/poisson:eqn:Equation}
\begin{split}\sum_{j=0}^{M-1} A_{ij}u_j - F_i=0 ,\quad i=0,\cdots,M-1;\qquad
F_i=\int_{\Omega}f\phi_i\, \text{d} x\text{d} y\end{split}
\end{equation}
\sphinxAtStartPar
which is found by using \eqref{equation:tutorials/poisson:defu} and replacing \(v\) by \(\phi_i\) in \eqref{equation:tutorials/poisson:eqn:weakform}.
The Dirichlet conditions are implemented by penalty, namely by setting \(A_{ii}=10^{30}\) and \(F_i=10^{30}*0\) if \(i\) is a boundary degree of freedom.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The number \(10^{30}\) is called \sphinxcode{\sphinxupquote{tgv}} (\sphinxstyleemphasis{très grande valeur} or \sphinxstyleemphasis{very high value} in english) and it is generally possible to change this value, see the item :freefem\textasciigrave{}solve, tgv=\textasciigrave{}
\end{sphinxadmonition}

\sphinxAtStartPar
The matrix \(A=(A_{ij})\) is called \sphinxstyleemphasis{stiffness matrix}.
If the user wants to access \(A\) directly he can do so by using (see section {\hyperref[\detokenize{documentation/finite-element:variationalformsparsematrixpde}]{\sphinxcrossref{\DUrole{std,std-ref}{Variational form, Sparse matrix, PDE data vector}}}} for details).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//stiffness matrix}
\end{sphinxVerbatim}

\sphinxAtStartPar
The vector \(F\) in \eqref{equation:tutorials/poisson:eqn:Equation} can also be constructed manually:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{l}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{k+kr}{unused}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{F}\PYG{p}{;}
\PYG{n}{F}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//F[] is the vector associated to the function F}
\end{sphinxVerbatim}

\sphinxAtStartPar
The problem can then be solved by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{F}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//u[] is the vector associated to the function u}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{u}} and \sphinxcode{\sphinxupquote{F}} are finite element function, and \sphinxcode{\sphinxupquote{u{[}{]}}} and \sphinxcode{\sphinxupquote{F{[}{]}}} give the array of value associated (\sphinxcode{\sphinxupquote{u{[}{]}}} \(\equiv (u_i)_{i=0,\dots,M-1}\) and \sphinxcode{\sphinxupquote{F{[}{]}}} \(\equiv (F_i)_{i=0,\dots,M-1}\)).

\sphinxAtStartPar
So we have:
\begin{equation*}
\begin{split}\mathtt{u}(x,y) = \sum_{i=0}^{M-1} \mathtt{u[][}i\mathtt{]} \phi_i(x,y) ,
\qquad \mathtt{F}(x,y) = \sum_{i=0}^{M-1} \mathtt{F[][}i\mathtt{]} \phi_i(x,y)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\phi_i, i=0...,,M-1\) are the basis functions of \sphinxtitleref{Vh} like in equation :eq: \sphinxtitleref{equation3}, and \(M = \mathtt{Vh.ndof}\) is the number of degree of freedom (i.e. the dimension of the space \sphinxtitleref{Vh}).
\end{sphinxadmonition}

\sphinxAtStartPar
The linear system \eqref{equation:tutorials/poisson:eqn:Equation} is solved by \sphinxcode{\sphinxupquote{UMFPACK}} unless another option is mentioned specifically as in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
meaning that \sphinxcode{\sphinxupquote{Poisson}} is declared only here and when it is called (by simply writing \sphinxcode{\sphinxupquote{Poisson;}}) then \eqref{equation:tutorials/poisson:eqn:Equation} will be solved by the Conjugate Gradient method.


\section{Classification of partial differential equations}
\label{\detokenize{tutorials/equationsClassification:classification-of-partial-differential-equations}}\label{\detokenize{tutorials/equationsClassification::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{It is usually not easy to determine the type of a system.}
\sphinxstyleemphasis{Yet the approximations and algorithms suited to the problem depend on its type:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Finite Elements compatible (LBB conditions) for elliptic systems}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Finite difference on the parabolic variable and a time loop on each elliptic subsystem of parabolic systems; better stability diagrams when the schemes are implicit in time.}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Upwinding, Petrov\sphinxhyphen{}Galerkin, Characteristics\sphinxhyphen{}Galerkin, Discontinuous\sphinxhyphen{}Galerkin, Finite Volumes for hyperbolic systems plus, possibly, a time loop.}

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{When the system changes type, then expect difficulties (like shock discontinuities) !}

\sphinxAtStartPar
\sphinxstylestrong{Elliptic, parabolic and hyperbolic equations}

\sphinxAtStartPar
A partial differential equation (PDE) is a relation between a function of several variables and its derivatives.
\begin{equation*}
\begin{split}F\left(\varphi(x),{\partial\varphi\over\partial
x_1}(x),\cdots,{\partial\varphi\over\partial
x_d}(x),{\partial^2\varphi\over\partial
x^2_1}(x),\cdots,{\partial^m\varphi\over\partial x^m_d}(x)\right) =
0,\quad\forall x\in\Omega\subset \mathbb{R}^d\end{split}
\end{equation*}
\sphinxAtStartPar
The range of \(x\) over which the equation is taken, here \(\Omega\), is called the \sphinxstyleemphasis{domain} of the PDE.
The highest derivation index, here \(m\), is called the \sphinxstyleemphasis{order}.
If \(F\) and \(\varphi\) are vector valued functions, then the PDE is actually a \sphinxstyleemphasis{system} of PDEs.

\sphinxAtStartPar
Unless indicated otherwise, here by convention \sphinxstyleemphasis{one} PDE corresponds to one scalar valued \(F\) and \(\varphi\).
If \(F\) is linear with respect to its arguments, then the PDE is said to be \sphinxstyleemphasis{linear}.

\sphinxAtStartPar
The general form of a second order, linear scalar PDE is
\begin{equation*}
\begin{split}\alpha\varphi + a\cdot\nabla\varphi + B :\nabla(\nabla\varphi) =
f{\quad\hbox{ in }\quad}\Omega\subset \mathbb{R}^d,\end{split}
\end{equation*}
\sphinxAtStartPar
where \({\partial^2\varphi\over\partial x_i\partial x_j}\) and \(A:B\) means \(\sum^d_{i,j=1} a_{ij} b_{ij}.\),
\(f(x),\alpha(x)\in \mathbb{R}\), \(a(x)\in \mathbb{R}^d\), \(B(x)\in \mathbb{R}^{d\times d}\) are the PDE \sphinxstyleemphasis{coefficients}.
If the coefficients are independent of \(x\), the PDE is said to have \sphinxstyleemphasis{constant coefficients}.

\sphinxAtStartPar
To a PDE we associate a quadratic form, by replacing \(\varphi\) by \(1\), \(\partial\varphi/\partial x_i\) by \(z_i\) and \(\partial^2\varphi/\partial x_i\partial x_j\) by \(z_i z_j\), where \(z\) is a vector in \(\mathbb{R}^d\):
\begin{equation*}
\begin{split}\alpha + A\cdot z + z^T Bz = f.\end{split}
\end{equation*}
\sphinxAtStartPar
If it is the equation of an ellipse (ellipsoid if \(d \geq 2\)), the PDE is said to be \sphinxstyleemphasis{elliptic}; if it is the equation of a parabola or a hyperbola, the PDE is said to be \sphinxstyleemphasis{parabolic} or \sphinxstyleemphasis{hyperbolic}.

\sphinxAtStartPar
If \(B \equiv 0\), the degree is no longer 2 but 1, and for reasons that will appear more clearly later, the PDE is still said to be hyperbolic.

\sphinxAtStartPar
These concepts can be generalized to systems, by studying whether or not the polynomial system \(P(z)\) associated with the PDE system has branches at infinity (ellipsoids have no branches at infinity, paraboloids have one, and hyperboloids have several).

\sphinxAtStartPar
If the PDE is not linear, it is said to be \sphinxstyleemphasis{non\sphinxhyphen{}linear}.
These are said to be locally elliptic, parabolic, or hyperbolic according to the type of the linearized equation.

\sphinxAtStartPar
For example, for the non\sphinxhyphen{}linear equation
\begin{equation*}
\begin{split}{\partial^2\varphi\over\partial t^2} - {\partial\varphi\over\partial x}{\partial^2\varphi\over\partial x^2} = 1\end{split}
\end{equation*}
\sphinxAtStartPar
we have \(d=2\), \(x_1 = t\), \(x_2 = x\) and its linearized form is:
\begin{equation*}
\begin{split}{\partial^2 u\over\partial t^2} - {\partial u\over\partial x}{\partial^2\varphi\over\partial x^2} - {\partial\varphi\over\partial x}{\partial^2 u\over\partial x^2} = 0\end{split}
\end{equation*}
\sphinxAtStartPar
which for the unknown \(u\) is locally elliptic if \({\partial\varphi\over\partial x} < 0\) and locally hyperbolic if \({\partial\varphi\over\partial x} > 0\).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Laplace’s equation is elliptic:
\begin{equation*}
\begin{split}\Delta\varphi \equiv {\partial^2\varphi\over\partial x^2_1}
    + {\partial^2\varphi\over\partial x^2_2}
    + \cdots
    + {\partial^2\varphi\over\partial x^2_d} = f,\ \forall x
    \in \Omega\subset \mathbb{R}^d\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
The \sphinxstyleemphasis{heat} equation is parabolic in \(Q = \Omega\times]0,T[\subset \mathbb{R}^{d+1}\):
\begin{equation*}
\begin{split}{\partial\varphi\over\partial t} - \mu\Delta\varphi = f
    \ \forall x\in\Omega\subset \mathbb{R}^d, \ \forall t\in]0,T[\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
If \(\mu>0\), the \sphinxstyleemphasis{wave} equation is hyperbolic:
\begin{equation*}
\begin{split}{\partial^2\varphi\over\partial t^2} - \mu\Delta\varphi
    = f{\ \hbox{ in }\ } Q.\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
The \sphinxstyleemphasis{convection diffusion} equation is parabolic if \(\mu \neq 0\) and hyperbolic otherwise:
\begin{equation*}
\begin{split}{\partial\varphi\over\partial t}
    + a\nabla\varphi
    - \mu\Delta\varphi
    = f\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
The \sphinxstyleemphasis{biharmonic} equation is elliptic:
\begin{equation*}
\begin{split}\Delta(\Delta\varphi) = f{\ \hbox{ in }\ }\Omega.\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Boundary conditions}

\sphinxAtStartPar
A relation between a function and its derivatives is not sufficient to define the function.
Additional information on the boundary \(\Gamma=\partial\Omega\) of \(\Omega\), or on part of \(\Gamma\) is necessary.
Such information is called a \sphinxstyleemphasis{boundary condition}.

\sphinxAtStartPar
For example:
\begin{equation*}
\begin{split}\varphi(x) \ \hbox{given},\ \forall x\in \Gamma,\end{split}
\end{equation*}
\sphinxAtStartPar
is called a \sphinxstyleemphasis{Dirichlet boundary condition}. The \sphinxstyleemphasis{Neumann} condition is
\begin{equation*}
\begin{split}{\partial\varphi\over\partial \boldsymbol{n}}(x) \ \hbox{given on }\
\Gamma \hbox{ (or } \boldsymbol{n}\cdot B\nabla\varphi,\hbox{given on }\
\Gamma\hbox{ for a general second order PDE)}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\boldsymbol{n}\) is the normal at \(x\in\Gamma\) directed towards the exterior of \(\Omega\) (by definition \({\partial\varphi\over\partial \boldsymbol{n}}=\nabla\varphi\cdot \boldsymbol{n}\)).

\sphinxAtStartPar
Another classical condition, called a \sphinxstyleemphasis{Robin} (or \sphinxstyleemphasis{Fourier}) condition is written as:
\begin{equation*}
\begin{split}\varphi(x) + \beta(x) {\partial\varphi\over\partial \boldsymbol{n}}(x) \ \hbox{given on}\ \Gamma.\end{split}
\end{equation*}
\sphinxAtStartPar
Finding a set of boundary conditions that defines a unique \(\varphi\) is a difficult art.

\sphinxAtStartPar
In general, an elliptic equation is well posed (\sphinxstyleemphasis{i.e.} \(\varphi\) is unique) with one Dirichlet, Neumann or Robin condition on the whole boundary.

\sphinxAtStartPar
Thus, Laplace’s equation is well posed with a Dirichlet or Neumann condition but also with :
\begin{equation*}
\begin{split}\varphi \ \hbox{given on}\ \Gamma_1,\ {\partial\varphi\over\partial \boldsymbol{n}} \ \hbox{given on}\ \Gamma_2, \ \Gamma_1\cup\Gamma_2 =\Gamma,\ {\dot{\Gamma_1}\cap\dot{\Gamma_2}} =\emptyset.\end{split}
\end{equation*}
\sphinxAtStartPar
Parabolic and hyperbolic equations rarely require boundary conditions on all of \(\Gamma\times]0,T[\).
For instance, the heat equation is well posed with :
\begin{equation*}
\begin{split}\varphi \ \hbox{given at}\ t=0 \ \hbox{and Dirichlet or Neumann or mixed conditions on}\
\partial\Omega.\end{split}
\end{equation*}
\sphinxAtStartPar
Here \(t\) is time so the first condition is called an initial condition.
The whole set of conditions is also called Cauchy condition.

\sphinxAtStartPar
The wave equation is well posed with :
\begin{equation*}
\begin{split}\varphi \ \hbox{and}\ {\partial\varphi\over\partial t} \
\hbox{given at}\ t=0
\ \hbox{and Dirichlet or Neumann or mixed conditions on}\
\partial\Omega.\end{split}
\end{equation*}

\section{Membrane}
\label{\detokenize{tutorials/membrane:membrane}}\label{\detokenize{tutorials/membrane:tutorialmembrane}}\label{\detokenize{tutorials/membrane::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we shall learn how to solve a Dirichlet and/or mixed Dirichlet Neumann problem for the Laplace operator with application to the equilibrium of a membrane under load.
We shall also check the accuracy of the method and interface with other graphics packages}

\sphinxAtStartPar
An elastic membrane \(\Omega\) is attached to a planar rigid support \(\Gamma\), and a force \(f(x) dx\) is exerted on each surface element \(\text{d}{x}=\text{d}{x}_1 \text{d}{x}_2\).
The vertical membrane displacement, \(\varphi(x)\), is obtained by solving Laplace’s equation:
\begin{equation*}
\begin{split}-\Delta \varphi =f ~\hbox{in}~ \Omega\end{split}
\end{equation*}
\sphinxAtStartPar
As the membrane is fixed to its planar support, one has:
\begin{equation*}
\begin{split}\varphi |_{\Gamma }=0\end{split}
\end{equation*}
\sphinxAtStartPar
If the support wasn’t planar but had an elevation \(z(x_1,x_2)\) then the boundary conditions would be of non\sphinxhyphen{}homogeneous Dirichlet type.
\begin{equation*}
\begin{split}\varphi|_{\Gamma}=z\end{split}
\end{equation*}
\sphinxAtStartPar
If a part \(\Gamma_2\) of the membrane border \(\Gamma\) is not fixed to the support but is left hanging, then due to the membrane’s rigidity the angle with the normal vector \(\boldsymbol{n}\) is zero; thus the boundary conditions are:
\begin{equation*}
\begin{split}\varphi|_{\Gamma_1}=z,~~~~\frac{\partial\varphi}{\partial\boldsymbol{n}}|_{\Gamma_2}=0\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Gamma_1=\Gamma-\Gamma_2\); recall that \(\frac{\partial\varphi}{\partial\boldsymbol{n}}=\nabla\varphi\cdot \boldsymbol{n}\)
Let us recall also that the Laplace operator \(\Delta\) is defined by:
\begin{equation*}
\begin{split}\Delta \varphi = {\partial ^{2}\varphi \over \partial x^{2}_{1} }
+ {\partial ^{2}\varphi \over \partial x_{2}^{2} }\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{\label{\detokenize{tutorials/membrane:id1}}Todo:}
\sphinxAtStartPar
Check references
\end{sphinxadmonition}

\sphinxAtStartPar
With such \sphinxstyleemphasis{“mixed boundary conditions”} the problem has a unique solution (see Dautray\sphinxhyphen{}Lions (1988), Strang (1986) and Raviart\sphinxhyphen{}Thomas (1983)).
The easiest proof is to notice that \(\varphi\) is the state of least energy, i.e.
\begin{equation*}
\begin{split}E(\phi) =\min_{\varphi-z\in V} E(v) ,\quad \mbox{with} \quad E(v)=\int_\Omega(\frac12|\nabla v|^2-fv )\end{split}
\end{equation*}
\sphinxAtStartPar
and where \(V\) is the subspace of the Sobolev space \(H^1(\Omega)\) of functions which have zero trace on \(\Gamma_1\).
Recall that (\(x\in\mathbb{R}^d,~d=2\) here):
\begin{equation*}
\begin{split}H^1(\Omega)=\{u\in L^2(\Omega)~:~\nabla u\in (L^2(\Omega))^d\}\end{split}
\end{equation*}
\sphinxAtStartPar
Calculus of variation shows that the minimum must satisfy, what is known as the weak form of the PDE or its variational formulation (also known here as the theorem of virtual work)
\begin{equation*}
\begin{split}\int_\Omega \nabla\varphi\cdot\nabla w = \int_\Omega f w\quad\forall w\in V\end{split}
\end{equation*}
\sphinxAtStartPar
Next an integration by parts (Green’s formula) will show that this is equivalent to the PDE when second derivatives exist.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Unlike the previous version Freefem+ which had both weak and strong forms, \sphinxstylestrong{FreeFEM} implements only weak formulations.
It is not possible to go further in using this software if you don’t know the weak form (i.e. variational formulation) of your problem: either you read a book, or ask help form a colleague or drop the matter.
Now if you want to solve a system of PDE like \(A(u,v)=0,~ B(u,v)=0\) don’t close this manual, because in weak form it is
\end{sphinxadmonition}
\begin{equation*}
\begin{split}\int_\Omega(A(u,v)w_1+B(u,v)w_2)=0~~\forall w_1,w_2...\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Example}

\sphinxAtStartPar
Let an ellipse have the length of the semimajor axis \(a=2\), and unitary the semiminor axis.
Let the surface force be \(f=1\).
Programming this case with \sphinxstylestrong{FreeFEM} gives:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{c+c1}{//The length of the semimajor axis}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//The length of the semiminor axis}
\PYG{k+kt}{func} \PYG{k+kr}{z} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{theta}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//P2 conforming triangular FEM}
\PYG{n}{Vh} \PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{f}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{Laplace}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{,} \PYG{n}{phi}\PYG{o}{=}\PYG{k+kr}{z}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{membrane.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Plot phi}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{membraneTh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Plot Th}

\PYG{c+c1}{// Save mesh}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A triangulation is built by the keyword \sphinxcode{\sphinxupquote{buildmesh}}.
This keyword calls a triangulation subroutine based on the Delaunay test, which first triangulates with only the boundary points, then adds internal points by subdividing the edges.
How fine the triangulation becomes is controlled by the size of the closest boundary edges.

\sphinxAtStartPar
The PDE is then discretized using the triangular second order finite element method on the triangulation; as was briefly indicated in the previous chapter, a linear system is derived from the discrete formulation whose size is the number of vertices plus the number of mid\sphinxhyphen{}edges in the triangulation.

\sphinxAtStartPar
The system is solved by a multi\sphinxhyphen{}frontal Gauss LU factorization implemented in the package \sphinxcode{\sphinxupquote{UMFPACK}}.

\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{plot}} will display both \(\T_h\) and \(\varphi\) (remove \sphinxcode{\sphinxupquote{Th}} if \(\varphi\) only is desired) and the qualifier \sphinxcode{\sphinxupquote{fill=true}} replaces the default option (colored level lines) by a full color display.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,}\PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Plot phi with full color display}
\end{sphinxVerbatim}

\sphinxAtStartPar
Results are on \hyperref[\detokenize{tutorials/membrane:figmembranemesh}]{Fig.\@ \ref{\detokenize{tutorials/membrane:figmembranemesh}}} and \hyperref[\detokenize{tutorials/membrane:figmembranelevellines}]{Fig.\@ \ref{\detokenize{tutorials/membrane:figmembranelevellines}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{membraneTh}.png}
\caption{Mesh of the ellipse}\label{\detokenize{tutorials/membrane:id2}}\label{\detokenize{tutorials/membrane:figmembranemesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{membrane}.png}
\caption{Level lines of the membrane deformation}\label{\detokenize{tutorials/membrane:id3}}\label{\detokenize{tutorials/membrane:figmembranelevellines}}\end{subfigure}
\caption{Membrane}\phantomsection\label{\detokenize{tutorials/membrane:Membrane}}

\end{figure}


\sphinxAtStartPar
Next we would like to check the results !

\sphinxAtStartPar
One simple way is to adjust the parameters so as to know the solutions.
For instance on the unit circle \sphinxcode{\sphinxupquote{a=1}}, \(\varphi_e=\sin(x^2+y^2-1)\) solves the problem when:
\begin{equation*}
\begin{split}z=0, f=-4(\cos(x^2+y^2-1)-(x^2+y^2)\sin(x^2+y^2-1))\end{split}
\end{equation*}
\sphinxAtStartPar
except that on \(\Gamma_2\) \(\partial_n\varphi=2\) instead of zero.
So we will consider a non\sphinxhyphen{}homogeneous Neumann condition and solve:
\begin{equation*}
\begin{split}\int_\Omega\nabla\varphi\cdot\nabla w = \int_\Omega f w+\int_{\Gamma_2}2w\quad\forall w\in V\end{split}
\end{equation*}
\sphinxAtStartPar
We will do that with two triangulations, compute the \(L^2\) error:
\begin{equation*}
\begin{split}\epsilon = \int_\Omega|\varphi-\varphi_e|^2\end{split}
\end{equation*}
\sphinxAtStartPar
and print the error in both cases as well as the log of their ratio an indication of the rate of convergence.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//  Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//to remove all default output}
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//the length of the semimajor axis}
\PYG{k+kt}{real} \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//the length of the semiminor axis}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{phiexact} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{theta}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{theta}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Error loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L2error}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of two values}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{solve} \PYG{n+nf}{Laplace}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{f}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Gamma2}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{,}\PYG{n}{phi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{membrane.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{L2error}\PYG{p}{[}\PYG{k+kr}{n}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{phi}\PYG{o}{\PYGZhy{}}\PYG{n}{phiexact}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{L2error }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{L2error}\PYG{p}{[}\PYG{k+kr}{n}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Convergence rate}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{convergence rate = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{log}\PYG{p}{(}\PYG{n}{L2error}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{/}\PYG{n}{L2error}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
L2error \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}.00462991
L2error \PYG{n+nv}{1} \PYG{o}{=} \PYG{l+m}{0}.00117128
convergence \PYG{n+nv}{rate} \PYG{o}{=} \PYG{l+m}{1}.9829
times: compile \PYG{l+m}{0}.02s, execution \PYG{l+m}{6}.94s
\end{sphinxVerbatim}

\sphinxAtStartPar
We find a rate of 1.98 , which is not close enough to the 3 predicted by the theory.

\sphinxAtStartPar
The Geometry is always a polygon so we lose one order due to the geometry approximation in \(O(h^2)\).

\sphinxAtStartPar
Now if you are not satisfied with the \sphinxcode{\sphinxupquote{.eps}} plot generated by \sphinxstylestrong{FreeFEM} and you want to use other graphic facilities, then you must store the solution in a file very much like in \sphinxcode{\sphinxupquote{C++}}.
It will be useless if you don’t save the triangulation as well, consequently you must do

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{phi.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
For the triangulation the name is important: \sphinxstylestrong{the extension determines the format}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{gnumembrane}.png}
\caption{The 3D version drawn by \sphinxcode{\sphinxupquote{gnuplot}}  from a file generated by \sphinxstylestrong{FreeFEM}}\label{\detokenize{tutorials/membrane:figmembrane}}\end{figure}

\sphinxAtStartPar
Still that may not take you where you want. Here is an interface with gnuplot (see :   \sphinxhref{http://www.gnuplot.info}{web site link}  ) to produce the \hyperref[\detokenize{tutorials/membrane:figmembrane}]{Fig.\@ \ref{\detokenize{tutorials/membrane:figmembrane}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//to build a gnuplot data file}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{graph.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

        \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We use the finite element numbering, where \sphinxcode{\sphinxupquote{Wh(i,j)}} is the global index of \(j^{Th}\) degrees of freedom of triangle number \(i\).

\sphinxAtStartPar
Then open \sphinxcode{\sphinxupquote{gnuplot}} and do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{set} \PYG{n+nb}{palette} \PYG{n}{rgbformulae} \PYG{l+m+mi}{30}\PYG{o}{,}\PYG{l+m+mi}{31}\PYG{o}{,}\PYG{l+m+mi}{32}
\PYG{k}{splot} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{graph.txt}\PYG{l+s}{\PYGZdq{}} \PYG{n+nb}{w} \PYG{n}{l} \PYG{n}{pal}
\end{sphinxVerbatim}

\sphinxAtStartPar
This works with \sphinxcode{\sphinxupquote{P2}} and \sphinxcode{\sphinxupquote{P1}}, but not with \sphinxcode{\sphinxupquote{P1nc}} because the 3 first degrees of freedom of \sphinxcode{\sphinxupquote{P2}} or \sphinxcode{\sphinxupquote{P2}} are on vertices and not with \sphinxcode{\sphinxupquote{P1nc}}.


\section{Heat Exchanger}
\label{\detokenize{tutorials/heatExchanger:heat-exchanger}}\label{\detokenize{tutorials/heatExchanger::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary:}
\sphinxstyleemphasis{Here we shall learn more about geometry input and triangulation files, as well as read and write operations.}

\sphinxAtStartPar
\sphinxstylestrong{The problem} Let \(\{C_{i}\}_{1,2}\), be 2 thermal conductors within an enclosure \(C_0\) (see \hyperref[\detokenize{tutorials/heatExchanger:figheatgeo}]{Fig.\@ \ref{\detokenize{tutorials/heatExchanger:figheatgeo}}}).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{heat_exchangerGeo}.png}
\caption{Heat exchanger geometry}\label{\detokenize{tutorials/heatExchanger:figheatgeo}}\end{figure}

\sphinxAtStartPar
The first one is held at a constant temperature \({u} _{1}\) the other one has a given thermal conductivity \(\kappa_2\) 3 times larger than the one of \(C_0\).

\sphinxAtStartPar
We assume that the border of enclosure \(C_0\) is held at temperature \(20^\circ C\) and that we have waited long enough for thermal equilibrium.

\sphinxAtStartPar
In order to know \({u} (x)\) at any point \(x\) of the domain \(\Omega\), we must solve:
\begin{equation*}
\begin{split}\nabla\cdot(\kappa\nabla{u}) = 0 \hbox{ in } \Omega,
\quad {u}_{|\Gamma} = g\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Omega\) is the interior of \(C_0\) minus the conductor \(C_1\) and \(\Gamma\) is the boundary of \(\Omega\), that is \(C_0\cup C_1\).

\sphinxAtStartPar
Here \(g\) is any function of \(x\) equal to \({u}_i\) on \(C_i\).

\sphinxAtStartPar
The second equation is a reduced form for:
\begin{equation*}
\begin{split}{u} ={u} _{i} \hbox{ on } C_{i}, \quad i=0,1.\end{split}
\end{equation*}
\sphinxAtStartPar
The variational formulation for this problem is in the subspace \(H^1_0(\Omega) \subset H^1(\Omega)\) of functions which have zero traces on \(\Gamma\).
\begin{equation*}
\begin{split}u-g\in H^1_0(\Omega): \int_{\Omega}{\nabla u \nabla v} = 0\forall v\in H^1_0(\Omega)\end{split}
\end{equation*}
\sphinxAtStartPar
Let us assume that \(C_0\) is a circle of radius 5 centered at the origin, \(C_i\) are rectangles, \(C_1\) being at the constant temperature \(u_1=60^\circ C\) (so we can only consider its boundary).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2}\PYG{o}{=}\PYG{l+m+mi}{98}\PYG{p}{;} \PYG{c+c1}{//could be anything such that !=0 and C1!=C2}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{o}{+}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{o}{+}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{plot}\PYG{p}{(}   \PYG{n}{C0}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{c+c1}{//to see the border of the domain}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
    \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{heatexb.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{+}\PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{kappa}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HeatExchanger.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C0}} is oriented counterclockwise by \(t\), while \sphinxcode{\sphinxupquote{C1}} is oriented clockwise and \sphinxcode{\sphinxupquote{C2}} is oriented counterclockwise.
This is why \sphinxcode{\sphinxupquote{C1}} is viewed as a hole by \sphinxcode{\sphinxupquote{buildmesh}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C1}} and \sphinxcode{\sphinxupquote{C2}} are built by joining pieces of straight lines.
To group them in the same logical unit to input the boundary conditions in a readable way we assigned a label on the boundaries.
As said earlier, borders have an internal number corresponding to their order in the program (check it by adding a \sphinxcode{\sphinxupquote{cout \textless{}\textless{} C22;}} above).
This is essential to understand how a mesh can be output to a file and re\sphinxhyphen{}read (see below).

\item {} 
\sphinxAtStartPar
As usual the mesh density is controlled by the number of vertices assigned to each boundary.
It is not possible to change the (uniform) distribution of vertices but a piece of boundary can always be cut in two or more parts, for instance \sphinxcode{\sphinxupquote{C12}} could be replaced by \sphinxcode{\sphinxupquote{C121+C122}}:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// border C12(t=0.,1.)\PYGZob{}x=2.; y=3.\PYGZhy{}6.*t; label=C1;\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C121}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C122}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+cm}{/*+ C12(20) */} \PYG{o}{+} \PYG{n}{C121}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C122}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{heat_exchangerTh}.png}
\caption{Heat exchanger mesh}\label{\detokenize{tutorials/heatExchanger:id1}}\label{\detokenize{tutorials/heatExchanger:figheatmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{heat_exchanger}.png}
\caption{Heat exchanger solution}\label{\detokenize{tutorials/heatExchanger:id2}}\label{\detokenize{tutorials/heatExchanger:figheatsolution}}\end{subfigure}
\caption{Heat exchanger}\phantomsection\label{\detokenize{tutorials/heatExchanger:HeatExchanger}}

\end{figure}


\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
\sphinxstylestrong{Exercise :}

\sphinxAtStartPar
Use the symmetry of the problem with respect to the \sphinxtitleref{x} axes.

\sphinxAtStartPar
Triangulate only one half of the domain, and set homogeneous Neumann conditions on the horizontal axis.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Writing and reading triangulation files} Suppose that at the end of the previous program we added the line

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{condensor.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
and then later on we write a similar program but we wish to read the mesh from that file.
Then this is how the condenser should be computed:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{condensor.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{us}\PYG{p}{,} \PYG{n}{vs}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{vs}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the names of the boundaries are lost but either their internal number (in the case of \sphinxcode{\sphinxupquote{C0}}) or their label number (for \sphinxcode{\sphinxupquote{C1}} and \sphinxcode{\sphinxupquote{C2}}) are kept.


\section{Acoustics}
\label{\detokenize{tutorials/acoustics:acoustics}}\label{\detokenize{tutorials/acoustics::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we go to grip with ill posed problems and eigenvalue problems}

\sphinxAtStartPar
Pressure variations in air at rest are governed by the wave equation:
\begin{equation*}
\begin{split}{\partial^2 u \over \partial t^2} - c^2 \Delta u =0\end{split}
\end{equation*}
\sphinxAtStartPar
When the solution wave is monochromatic (and that depends on the boundary and initial conditions), \(u\) is of the form \(u(x,t)=Re(v(x) e^{ik t})\) where \(v\) is a solution of Helmholtz’s equation:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    k^{2}v + c^{2}\Delta v &= 0 &\hbox{ in } \Omega\\
    \frac{\partial v}{\partial\boldsymbol{n}}|_\Gamma &= g &
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(g\) is the source.

\sphinxAtStartPar
Note the “+” sign in front of the Laplace operator and that \(k > 0\) is real.
This sign may make the problem ill posed for some values of \(\frac c k\), a phenomenon called “resonance”.

\sphinxAtStartPar
At resonance there are non\sphinxhyphen{}zero solutions even when \(g=0\).
So the following program may or may not work:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{kc2} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{3.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a2}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{a3}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a4}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a5}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a6}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n+nf}{sound}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v} \PYG{o}{*} \PYG{n}{kc2}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{a4}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{g} \PYG{o}{*} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sound.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Results are on \hyperref[\detokenize{tutorials/acoustics:figacoustics1}]{Fig.\@ \ref{\detokenize{tutorials/acoustics:figacoustics1}}}. But when \(kc2\) is an eigenvalue of the problem, then the solution is not unique:
\begin{itemize}
\item {} 
\sphinxAtStartPar
if \(u_e \neq 0\) is an eigen state, then for any given solution \(u+u_e\) is \sphinxstylestrong{another} solution.

\end{itemize}

\sphinxAtStartPar
To find all the \(u_e\) one can do the following :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//value of the shift}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{// OP = A \PYGZhy{} sigma B ; // The shifted matrix}
\PYG{k+kt}{varf} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{k+kp}{sigma}\PYG{o}{*} \PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}
   \PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u2}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}
   \PYG{p}{)}
   \PYG{p}{;} \PYG{c+c1}{// No Boundary condition see note \PYGZbs{}ref\PYGZob{}note BC EV\PYGZcb{}}

\PYG{k+kt}{matrix} \PYG{n}{OP} \PYG{o}{=} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}20}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Eigen values}
\PYG{k+kt}{int} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// Number of requested eigenvalues near sigma}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ev}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// To store the nev eigenvalue}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{eV}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// To store the nev eigenvector}

\PYG{k+kt}{int} \PYG{n}{k}\PYG{o}{=}\PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{sym}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{,} \PYG{k+kp}{vector}\PYG{o}{=}\PYG{n}{eV}\PYG{p}{,}
   \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{maxit}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ncv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ev}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 eigen values }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ev}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{eV}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eigen.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{acoustics_0}.png}
\caption{Amplitude of an acoustic signal coming from the left vertical wall.}\label{\detokenize{tutorials/acoustics:id1}}\label{\detokenize{tutorials/acoustics:figacoustics1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{acoustics}.png}
\caption{First eigen state (\(\lambda=(k/c)^2=14.695\)) close to \(15\) of eigenvalue problem: \(-\Delta \varphi = \lambda\varphi\) and \(\frac{\partial \varphi}{\partial\boldsymbol{n}} = 0\) on \(\Gamma\)\}}\label{\detokenize{tutorials/acoustics:id2}}\label{\detokenize{tutorials/acoustics:figacoustics2}}\end{subfigure}
\caption{Acoustics}\phantomsection\label{\detokenize{tutorials/acoustics:figAcoustics0}}

\end{figure}



\section{Thermal Conduction}
\label{\detokenize{tutorials/thermalConduction:thermal-conduction}}\label{\detokenize{tutorials/thermalConduction:thermalconduction}}\label{\detokenize{tutorials/thermalConduction::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we shall learn how to deal with a time dependent parabolic problem.
We shall also show how to treat an axisymmetric problem and show also how to deal with a nonlinear problem}

\sphinxAtStartPar
\sphinxstylestrong{How air cools a plate}

\sphinxAtStartPar
We seek the temperature distribution in a plate \((0,Lx)\times(0,Ly)\times(0,Lz)\) of rectangular cross section \(\Omega=(0,6)\times(0,1)\); the plate is surrounded by air at temperature \(u_e\) and initially at temperature \(u=u_0+\frac x L u_1\).
In the plane perpendicular to the plate at \(z=Lz/2\), the temperature varies little with the coordinate \(z\); as a first approximation the problem is 2D.

\sphinxAtStartPar
We must solve the temperature equation in \(\Omega\) in a time interval (0,T).
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t u -\nabla\cdot(\kappa\nabla u) &= 0 & \hbox{ in } \Omega\times(0,T)\\
    u(x,y,0) &= u_0+x u_1 &\\
    \kappa\frac{\partial u}{\partial \boldsymbol{n}} +\alpha(u-u_e) &= 0 & \hbox{ on } \Gamma\times(0,T)
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Here the diffusion \(\kappa\) will take two values, one below the middle horizontal line and ten times less above, so as to simulate a thermostat.

\sphinxAtStartPar
The term \(\alpha(u-u_e)\) accounts for the loss of temperature by convection in air.
Mathematically this boundary condition is of Fourier (or Robin, or mixed) type.

\sphinxAtStartPar
The variational formulation is in \(L^2(0,T;H^1(\Omega))\); in loose terms and after applying an implicit Euler finite difference approximation in time; we shall seek \(u^n(x,y)\) satisfying for all \(w\in H^1(\Omega)\):
\begin{equation*}
\begin{split}\int_\Omega(\frac{u^n-u^{n-1}}{\delta t} w + \kappa\nabla u^n\nabla w) +\int_\Gamma\alpha(u^n-u_ue)w=0\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mf}{10.} \PYG{o}{+} \PYG{l+m+mf}{90.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{25.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.1} \PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{thermic}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{uold}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time iterations}
\PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{thermic.dat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{uold} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//equivalent to u\PYGZca{}\PYGZob{}n\PYGZhy{}1\PYGZcb{} = u\PYGZca{}n}
    \PYG{n}{thermic}\PYG{p}{;} \PYG{c+c1}{//here the thermic problem is solved}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We must separate by hand the bilinear part from the linear one.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The way we store the temperature at point (3, 0.5) for all times in file \sphinxcode{\sphinxupquote{thermic.dat}}.
Should a one dimensional plot be required (you can use gnuplot tools), the same procedure can be used. For instance to print \(x\mapsto \frac{\partial u}{\partial y}(x,0.9)\) one would do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{6.0}\PYG{o}{*}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.0}\PYG{p}{,}\PYG{l+m+mf}{0.9}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
Results are shown on \hyperref[\detokenize{tutorials/thermalConduction:figthermalt}]{Fig.\@ \ref{\detokenize{tutorials/thermalConduction:figthermalt}}} and \hyperref[\detokenize{tutorials/thermalConduction:figthermalcurve}]{Fig.\@ \ref{\detokenize{tutorials/thermalConduction:figthermalcurve}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{thermic}.png}
\caption{Temperature at \(t=4.9\).}\label{\detokenize{tutorials/thermalConduction:id1}}\label{\detokenize{tutorials/thermalConduction:figthermalt}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{thermicvst}.png}
\caption{Decay of temperature versus time at \(x=3, y=0.5\)}\label{\detokenize{tutorials/thermalConduction:id2}}\label{\detokenize{tutorials/thermalConduction:figthermalcurve}}\end{subfigure}
\caption{Thermal conduction}

\end{figure}



\subsection{Axisymmetry: 3D Rod with circular section}
\label{\detokenize{tutorials/thermalConduction:axisymmetry-3d-rod-with-circular-section}}\label{\detokenize{tutorials/thermalConduction:ThermalConduction}}
\sphinxAtStartPar
Let us now deal with a cylindrical rod instead of a flat plate.
For simplicity we take \(\kappa=1\).

\sphinxAtStartPar
In cylindrical coordinates, the Laplace operator becomes (\(r\) is the distance to the axis, \(z\) is the distance along the axis, \(\theta\) polar angle in a fixed plane perpendicular to the axis):
\begin{equation*}
\begin{split}\Delta u = {1\over r}\partial _r(r\partial _r u) + {1\over r^2}\partial ^2_{\theta\theta} u
 + \partial ^2_{z z}.\end{split}
\end{equation*}
\sphinxAtStartPar
Symmetry implies that we loose the dependence with respect to \(\theta\); so the domain \(\Omega\) is again a rectangle \(]0,R[\times]0,|[\) .
We take the convention of numbering of the edges as in \sphinxcode{\sphinxupquote{square()}} (1 for the bottom horizontal …); the problem is now:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    r\partial_t u-\partial _r(r\partial _r u) - \partial _z(r\partial _z u) &= 0 &\hbox{ in } \Omega\\
    u(t=0) &= u_0 + \frac z{L_z} (u_1-u)&\\
    u|_{\Gamma_4} &= u_0&\\
    u|_{\Gamma_2} &= u_1&\\
    \alpha(u-u_e) + {\partial u\over \partial\boldsymbol{n}} |_{\Gamma_1\cup\Gamma_3} &= 0&
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Note that the PDE has been multiplied by \(r\).

\sphinxAtStartPar
After discretization in time with an implicit scheme, with time steps \sphinxcode{\sphinxupquote{dt}}, in the \sphinxstylestrong{FreeFEM} syntax \(r\) becomes \(x\) and \(z\) becomes \(y\) and the problem is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{thermaxi}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{uold}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The bilinear form degenerates at \(x=0\).
Still one can prove existence and uniqueness for \(u\) and because of this degeneracy no boundary conditions need to be imposed on \(\Gamma_1\).
\end{sphinxadmonition}


\subsection{A Nonlinear Problem : Radiation}
\label{\detokenize{tutorials/thermalConduction:a-nonlinear-problem-radiation}}
\sphinxAtStartPar
Heat loss through radiation is a loss proportional to the absolute temperature to the fourth power (Stefan’s Law).
This adds to the loss by convection and gives the following boundary condition:
\begin{equation*}
\begin{split}\kappa{\partial u\over \partial\boldsymbol{n}} +\alpha(u-u_e) + c[(u + 273)^4 - (u_e+273)^4] = 0\end{split}
\end{equation*}
\sphinxAtStartPar
The problem is nonlinear, and must be solved iteratively with fixed\sphinxhyphen{}point iteration
where \(m\) denotes the iteration index, a semi\sphinxhyphen{}linearization of the radiation condition gives
\begin{equation*}
\begin{split}{\partial u^{m+1}\over \partial\boldsymbol{n}} + \alpha(u^{m+1}-u_e)+ c(u^{m+1}-u_e)
(u^m+u_e +546) ((u^m + 273)^2 + (u_e+273)^2) = 0,\end{split}
\end{equation*}
\sphinxAtStartPar
because we have the identity \(a^4 - b^4 = (a-b)(a+b)(a^2+b^2)\).

\sphinxAtStartPar
The iterative process will work with \(v=u-u_e\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{fespace} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n}{u0}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,}\PYG{n}{vp}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{thermradia}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{b}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{vold}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n}{u0}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// to remove spurious FREEfem print}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{k+kp}{t}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{;}\PYG{k+kp}{t}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{n}{vold}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{// just copy DoF\PYGZsq{}s, faster than interpolation pv=v;}
  \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{vp}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{// save previous state of commute error}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{alpha} \PYG{o}{+} \PYG{n}{rad} \PYG{o}{*} \PYG{p}{(}\PYG{n}{v} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{uek}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{v}\PYG{o}{+}\PYG{n}{uek}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{uek}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{thermradia}\PYG{p}{;}
    \PYG{n}{vp}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{vp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{;}\PYG{c+c1}{// error value}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ time }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{// if error is enough  small break fixed\PYGZhy{}point loop}
    \PYG{p}{\PYGZcb{}}
  \PYG{p}{\PYGZcb{}}
\PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}\PYG{c+c1}{//  add a constant to all DoF\PYGZsq{}s of v}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Irrotational Fan Blade Flow and Thermal effects}
\label{\detokenize{tutorials/fanBlade:irrotational-fan-blade-flow-and-thermal-effects}}\label{\detokenize{tutorials/fanBlade::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Here we will learn how to deal with a multi\sphinxhyphen{}physics system of PDEs on a complex geometry, with multiple meshes within one problem.
We also learn how to manipulate the region indicator and see how smooth is the projection operator from one mesh to another.}

\sphinxAtStartPar
\sphinxstylestrong{Incompressible flow}

\sphinxAtStartPar
Without viscosity and vorticity incompressible flows have a velocity given by:
\begin{equation*}
\begin{split}\boldsymbol{u}=\left(\begin{matrix}{\partial \psi \over \partial x }\\
-\partial \psi \over \partial y \end{matrix}\right), \quad
\mbox{ where }\psi\mbox{ is solution of }\quad \Delta \psi =0\end{split}
\end{equation*}
\sphinxAtStartPar
This equation expresses both incompressibility (\(\nabla\cdot u=0\)) and absence of vortex (\(\nabla\times u =0\)).

\sphinxAtStartPar
As the fluid slips along the walls, normal velocity is zero, which means that \(\psi\) satisfies:
\begin{equation*}
\begin{split}\psi \hbox{ constant on the walls}.\end{split}
\end{equation*}
\sphinxAtStartPar
One can also prescribe the normal velocity at an artificial boundary, and this translates into non constant Dirichlet data for \(\psi\).

\sphinxAtStartPar
\sphinxstylestrong{Airfoil}

\sphinxAtStartPar
Let us consider a wing profile \(S\) in a uniform flow.
Infinity will be represented by a large circle \(C\) where the flow is assumed to be of uniform velocity; one way to model this problem is to write:
\begin{equation*}
\begin{split}\Delta \psi =0 \hbox{ in } \Omega, \qquad
\psi |_{S}=-l, \quad
\psi|_{C}= {\boldsymbol{u}_\infty}.\boldsymbol{x}^\perp\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\partial\Omega=C\cup S\) and \(l\) is the lift force.

\sphinxAtStartPar
\sphinxstylestrong{The NACA0012 Airfoil}

\sphinxAtStartPar
An equation for the upper surface of a NACA0012 (this is a classical wing profile in aerodynamics) is:
\begin{equation*}
\begin{split}y = 0.17735\sqrt{x}-0.075597x- 0.212836x^2+0.17363x^3-0.06254x^4.\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}  \PYG{n}{S} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}\PYG{c+c1}{// wing label}
\PYG{c+c1}{// u infty}
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{180}\PYG{p}{;}\PYG{c+c1}{// // 1 degree on incidence =\PYGZgt{}  lift}
\PYG{k+kt}{real} \PYG{n}{lift} \PYG{o}{=} \PYG{n}{theta}\PYG{o}{*}\PYG{l+m+mf}{0.151952}\PYG{o}{/}\PYG{l+m+mf}{0.0872665}\PYG{p}{;} \PYG{c+c1}{//  lift approximation formula}
\PYG{k+kt}{real}  \PYG{n}{uinfty1}\PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{,} \PYG{n}{uinfty2}\PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{func} \PYG{n}{naca12} \PYG{o}{=} \PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Splus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{naca12}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Sminus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{naca12}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Splus}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Sminus}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{// def of grad operator}
\PYG{c+c1}{// Solve}
\PYG{k+kt}{solve} \PYG{n}{potential}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{c+c1}{//  scalar product}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{psi} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uinfty1}\PYG{p}{,}\PYG{n}{uinfty2}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{k+kr}{y}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{n}{psi}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{lift}\PYG{p}{)} \PYG{c+c1}{// to get a correct value}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A zoom of the streamlines are shown on \hyperref[\detokenize{tutorials/fanBlade:figfanpotential}]{Fig.\@ \ref{\detokenize{tutorials/fanBlade:figfanpotential}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{potential}.png}
\caption{Zoom around the NACA0012 airfoil showing the streamlines (curve \(\psi=\) constant).
To obtain such a plot use the interactive graphic command: “+” and p.}\label{\detokenize{tutorials/fanBlade:id1}}\label{\detokenize{tutorials/fanBlade:figfanpotential}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{potential_heat}.png}
\caption{Temperature distribution at time T=25 (now the maximum is at 90 instead of 120).}\label{\detokenize{tutorials/fanBlade:id2}}\label{\detokenize{tutorials/fanBlade:figfantemperature}}\end{subfigure}
\caption{The NACA0012 Airfoil}

\end{figure}



\subsection{Heat Convection around the airfoil}
\label{\detokenize{tutorials/fanBlade:heat-convection-around-the-airfoil}}\label{\detokenize{tutorials/fanBlade:Potential}}
\sphinxAtStartPar
Now let us assume that the airfoil is hot and that air is there to cool it.
Much like in the previous section the heat equation for the temperature \(v\) is
\begin{equation*}
\begin{split}\partial_t v -\nabla\cdot(\kappa\nabla v) + u\cdot\nabla v =0,~~v(t=0)=v_0, ~~\frac{\partial v}{\partial\boldsymbol{n}}|_{C,u\cdot n>0}=0, v|_{C,u\cdot n<0}=0\end{split}
\end{equation*}
\sphinxAtStartPar
But now the domain is outside AND inside \(S\) and \(\kappa\) takes a different value in air and in steel.
Furthermore there is convection of heat by the flow, hence the term \(u\cdot\nabla v\) above.

\sphinxAtStartPar
Consider the following, to be plugged at the end of the previous program:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Corrected by F. Hecht may 2021}
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{// Label 1,2}
\PYG{k+kt}{border} \PYG{n+nf}{Splus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Sminus}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{S}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Splus}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Sminus}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{potential}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
     \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,} \PYG{n}{psi} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{)}
     \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,} \PYG{n}{psi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{/// Thermic}
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.005}\PYG{p}{,} \PYG{n}{nbT} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{D}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Splus}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Sminus}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{90}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D}\PYG{p}{(}\PYG{l+m+mi}{200}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{steel} \PYG{o}{=} \PYG{n}{Sh}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{,} \PYG{n}{air} \PYG{o}{=} \PYG{n}{Sh}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{c+c1}{// Change label to put BC on In flow}
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh}  \PYG{n}{vv}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{W0}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{W0} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{air}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{steel}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{W0} \PYG{n}{u1} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{air}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{air}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{v} \PYG{o}{=} \PYG{l+m+mi}{120}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{steel}\PYG{p}{)}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{;}
\PYG{c+c1}{// set the label to 10 on inflow boundary to inforce the temperature.}
\PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,}\PYG{k+kp}{flabel} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{label} \PYG{o}{=}\PYG{o}{=} \PYG{n}{C} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}  \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kr}{N}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mi}{10} \PYG{o}{:} \PYG{k+kr}{label}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{thermic}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{v}\PYG{o}{*}\PYG{n}{vv}\PYG{o}{/}\PYG{n}{dt} \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vv}
           \PYG{p}{)}
\PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{)}\PYG{p}{(}\PYG{n}{vold}\PYG{o}{*}\PYG{n}{vv}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}


\PYG{k}{for}\PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nbT}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{n}{vold}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
  \PYG{n}{thermic}\PYG{p}{;}
  \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
How steel and air are identified by the mesh parameter region which is defined when buildmesh is called and takes an integer value corresponding to each connected component of \(\Omega\);
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We use the change function to put label 10 on inflow boundary, remark the trick to chanhe only label C \sphinxcode{\sphinxupquote{flabel = (label == C \&\&  {[}u1,u2{]}\textquotesingle{}*N\textless{}0) ? 10 : label}}

\sphinxAtStartPar
How the convection terms are added without upwinding.
Upwinding is necessary when the Pecley number \(|u|L/\kappa\) is large (here is a typical length scale), The factor 10 in front of the convection terms is a quick way of multiplying the velocity by 10 (else it is too slow to see something).

\sphinxAtStartPar
The solver is Gauss’ LU factorization and when \sphinxcode{\sphinxupquote{init}} \(\neq 0\) the LU decomposition is reused so it is much faster after the first iteration.
\end{sphinxadmonition}


\section{Pure Convection : The Rotating Hill}
\label{\detokenize{tutorials/rotatingHill:pure-convection-the-rotating-hill}}\label{\detokenize{tutorials/rotatingHill::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary:}
\sphinxstyleemphasis{Here we will present two methods for upwinding for the simplest convection problem.
We will learn about Characteristics\sphinxhyphen{}Galerkin and Discontinuous\sphinxhyphen{}Galerkin Finite Element Methods.}

\sphinxAtStartPar
Let \(\Omega\) be the unit disk centered at \((0,0)\); consider the rotation vector field
\begin{equation*}
\begin{split}\mathbf{u} = [u1,u2], \qquad u_1 = y,\quad u_2 = -x\end{split}
\end{equation*}
\sphinxAtStartPar
Pure convection by \(\mathbf{u}\) is
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t c + \mathbf{u}.\nabla c &= 0 &\hbox{ in } \Omega\times(0,T)\\
    c (t=0) &= c ^0 &\hbox{ in } \Omega.
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The exact solution \(c(x_t,t)\) at time \(t\) en point \(x_t\) is given by:
\begin{equation*}
\begin{split}c(x_t,t)=c^0(x,0)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(x_t\) is the particle path in the flow starting at point \(x\) at time \(0\). So \(x_t\) are solutions of
\begin{equation*}
\begin{split}\dot{x_t} = u(x_t), \quad\ x_{t=0} =x , \quad\mbox{where}\quad \dot{x_t} = \frac{\text{d} ( x_t }{\text{d} t}\end{split}
\end{equation*}
\sphinxAtStartPar
The ODE are reversible and we want the solution at point \(x\) at time \(t\) ( not at point \(x_t\)) the initial point is \(x_{-t}\), and we have
\begin{equation*}
\begin{split}c(x,t)=c^0(x_{-t},0)\end{split}
\end{equation*}
\sphinxAtStartPar
The game consists in solving the equation until \(T=2\pi\), that is for a full revolution and to compare the final solution with the initial one; they should be equal.


\subsection{Solution by a Characteristics\sphinxhyphen{}Galerkin Method}
\label{\detokenize{tutorials/rotatingHill:solution-by-a-characteristics-galerkin-method}}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} there is an operator called \sphinxcode{\sphinxupquote{convect({[}u1,u2{]}, dt, c)}} which compute \(c\circ X\) with \(X\) is the convect field defined by \(X(x)= x_{dt}\) and where \(x_\tau\) is particule path in the steady state velocity field \(\mathbf{u}=[u1,u2]\) starting at point \(x\) at time \(\tau=0\), so \(x_\tau\) is solution of the following ODE:
\begin{equation*}
\begin{split}\dot{x}_\tau = u(x_\tau), {x}_{\tau=0}=x.\end{split}
\end{equation*}
\sphinxAtStartPar
When \(\mathbf{u}\) is piecewise constant; this is possible because \(x_\tau\) is then a polygonal curve which can be computed exactly and the solution exists always when \(\mathbf{u}\) is divergence free; convect returns \(c(x_{df})=C\circ X\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{cold}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{cold} \PYG{o}{=} \PYG{n}{c}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{cold}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
3D plots can be done by adding the qualifyer \sphinxcode{\sphinxupquote{dim=3}} to the plot instruction.
\end{sphinxadmonition}

\sphinxAtStartPar
The method is very powerful but has two limitations:
\begin{itemize}
\item {} 
\sphinxAtStartPar
it is not conservative

\item {} 
\sphinxAtStartPar
it may diverge in rare cases when \(|\mathbf{u}|\) is too small due to quadrature error.

\end{itemize}


\subsection{Solution by Discontinuous\sphinxhyphen{}Galerkin FEM}
\label{\detokenize{tutorials/rotatingHill:solution-by-discontinuous-galerkin-fem}}
\sphinxAtStartPar
Discontinuous Galerkin methods take advantage of the discontinuities of \(c\) at the edges to build upwinding.
There are may formulations possible.
We shall implement here the so\sphinxhyphen{}called dual\sphinxhyphen{}\(P_1^{DC}\) formulation (see \sphinxcite{bibliography:ern2006}):
\begin{equation*}
\begin{split}\int_\Omega(\frac{c^{n+1}-c^n}{\delta t} +u\cdot\nabla c)w
+\int_E(\alpha|n\cdot u|-\frac 12 n\cdot u)[c]w
=\int_{E_\Gamma^-}|n\cdot u| cw~~~\forall w\end{split}
\end{equation*}
\sphinxAtStartPar
where \(E\) is the set of inner edges and \(E_\Gamma^-\) is the set of boundary edges where \(u\cdot n<0\) (in our case there is no such edges).
Finally \([c]\) is the jump of \(c\) across an edge with the convention that \(c^+\) refers to the value on the right of the oriented edge.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{al}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w}\PYG{p}{,} \PYG{n}{ccold}\PYG{p}{,} \PYG{n}{v1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{v2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{cc} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{k+kr}{n}\PYG{p}{(}\PYG{p}{)} \PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)} \PYG{c+c1}{// Macro without parameter}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Adual}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{cc}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{+}\PYG{p}{(}\PYG{n}{v1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}\PYG{o}{+}\PYG{n}{v2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{nTonEdge}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{ccold}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time iterations}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{ccold} \PYG{o}{=} \PYG{n}{cc}\PYG{p}{;}
    \PYG{n}{Adual}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{cc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{cc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ConvectCG.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ConvectDG.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
New keywords: \sphinxcode{\sphinxupquote{intalledges}} to integrate on all edges of all triangles
\begin{equation*}
\begin{split}\mathtt{intalledges}(\mathtt{Th}) \equiv \sum_{T\in\mathtt{Th}}\int_{\partial T }\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
(so all internal edges are see two times), nTonEdge which is one if the triangle has a boundary edge and two otherwise, \sphinxcode{\sphinxupquote{jump}} to implement \([c]\).

\sphinxAtStartPar
Results of both methods are shown on \hyperref[\detokenize{tutorials/rotatingHill:figrotatingcg}]{Fig.\@ \ref{\detokenize{tutorials/rotatingHill:figrotatingcg}}} nad \hyperref[\detokenize{tutorials/rotatingHill:figrotatingdg}]{Fig.\@ \ref{\detokenize{tutorials/rotatingHill:figrotatingdg}}} with identical levels for the level line; this is done with the plot\sphinxhyphen{}modifier viso.

\sphinxAtStartPar
Notice also the macro where the parameter \(\mathbf{u}\) is not used (but the syntax needs one) and which ends with a \sphinxcode{\sphinxupquote{//}}; it simply replaces the name \sphinxcode{\sphinxupquote{n}} by \sphinxcode{\sphinxupquote{(N.x*v1+N.y*v2)}}.
As easily guessed \sphinxcode{\sphinxupquote{N.x,N.y}} is the normal to the edge.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{convectCG}.png}
\caption{The rotating hill after one revolution with Characteristics\sphinxhyphen{}Galerkin}\label{\detokenize{tutorials/rotatingHill:id2}}\label{\detokenize{tutorials/rotatingHill:figrotatingcg}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{convectDG}.png}
\caption{The rotating hill after one revolution with Discontinuous \(P_1\) Galerkin}\label{\detokenize{tutorials/rotatingHill:id3}}\label{\detokenize{tutorials/rotatingHill:figrotatingdg}}\end{subfigure}
\caption{Rotating hill}\phantomsection\label{\detokenize{tutorials/rotatingHill:RotatingHill}}

\end{figure}


\sphinxAtStartPar
Now if you think that DG is too slow try this:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//P1,P2,P0,P1dc,P2dc, uncond stable}

\PYG{n}{Vh} \PYG{n}{vh}\PYG{p}{,}\PYG{n}{vo}\PYG{p}{,}\PYG{n}{u1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{v} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.03}\PYG{p}{,}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{tmax}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{n}{al}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{alp}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{;}

\PYG{k+kt}{problem}  \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vh}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{\PYGZhy{}}\PYG{n}{v}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{vh}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{mean}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}
                   \PYG{o}{+}\PYG{n}{alp}\PYG{o}{*}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}
  \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{vo}\PYG{o}{*}\PYG{n}{vh}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf}  \PYG{n+nf}{Adual}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{+}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{nTonEdge}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vh}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}
                             \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{rhs}\PYG{p}{(}\PYG{n}{vo}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{vo}\PYG{o}{*}\PYG{n}{vh}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.6}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{AA}\PYG{o}{=}\PYG{n}{Adual}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{,}\PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{GMRES}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{BB}\PYG{o}{=}\PYG{n}{rhs}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t}\PYG{o}{\PYGZlt{}} \PYG{n}{tmax} \PYG{p}{;} \PYG{k+kp}{t}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dt}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{n}{vo}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{vh}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{n}{BB}\PYG{o}{*}\PYG{n}{vo}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+}  \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{The System of elasticity}
\label{\detokenize{tutorials/elasticity:the-system-of-elasticity}}\label{\detokenize{tutorials/elasticity::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Elasticity}

\sphinxAtStartPar
Solid objects deform under the action of applied forces:

\sphinxAtStartPar
a point in the solid, originally at \((x,y,z)\) will come to \((X,Y,Z)\) after some time; the vector \(\mathbf{u}=(u_1,u_2,u_3) = (X-x, Y-y, Z-z)\) is called the displacement.
When the displacement is small and the solid is elastic, Hooke’s law gives a relationship between the stress tensor \(\sigma(u)=(\sigma_{ij}(u) )\) and the strain tensor \(\epsilon(u)=\epsilon_{ij}(u)\)
\begin{equation*}
\begin{split}\sigma_{ij}(u) = \lambda \delta_{ij} \nabla.\mathbf{u}+ 2\mu\epsilon_{ij}(u),\end{split}
\end{equation*}
\sphinxAtStartPar
where the Kronecker symbol \(\delta_{ij} = 1\) if \(i=j\), \(0\) otherwise, with
\begin{equation*}
\begin{split}\epsilon_{ij}(u) = {1\over 2}({\partial u_i\over\partial x_j} + {\partial u_j\over\partial x_i} ),\end{split}
\end{equation*}
\sphinxAtStartPar
and where \(\lambda, \mu\) are two constants that describe the mechanical properties of the solid, and are themselves related to the better known constants \(E\), Young’s modulus, and \(\nu\), Poisson’s ratio:
\begin{equation*}
\begin{split}\mu = {E\over 2( 1+\nu)}, \quad \lambda = {E\nu\over (1+\nu)(1-2\nu)}.\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Lamé’s system}

\sphinxAtStartPar
Let us consider a beam with axis \(Oz\) and with perpendicular section \(\Omega\).
The components along \(x\) and \(y\) of the strain \({\bf u}(x)\) in a section \(\Omega\) subject to forces \({\bf f}\) perpendicular to the axis are governed by:
\begin{equation*}
\begin{split}-\mu \Delta {\bf u} - (\mu+\lambda) \nabla (\nabla .{\bf u})={\bf f}~~\hbox{in}~~\Omega,\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\lambda\) ,\(\mu\) are the Lamé coefficients introduced above.

\sphinxAtStartPar
Remark, we do not use this equation because the associated variational form does not give the right boundary condition, we simply use:
\begin{equation*}
\begin{split}- div( \sigma ) = \mathbf{f} \quad \mbox{in}~~\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
where the corresponding variational form is:
\begin{equation*}
\begin{split}\int_{\Omega} \sigma(u) : \epsilon(\mathbf{v})\;dx - \int_{\Omega} \mathbf{v} f \;dx =0;\end{split}
\end{equation*}
\sphinxAtStartPar
where \(:\) denotes the tensor scalar product, i.e. \(a: b = \sum_{i,j} a_{ij}b_{ij}\).

\sphinxAtStartPar
So the variational form can be written as :
\begin{equation*}
\begin{split}\int_{\Omega} \lambda \nabla.u \nabla.v + 2 \mu \epsilon(\mathbf{u}):\epsilon(\mathbf{v}) \; dx - \int_{\Omega} \mathbf{v} f \;dx =0;\end{split}
\end{equation*}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Consider an elastic plate with the undeformed rectangle shape \([0,20]\times [-1,1]\).

\sphinxAtStartPar
The body force is the gravity force \(\mathbf{f}\) and the boundary force \(\mathbf{g}\) is zero on lower, upper and right sides.
The left vertical side of the beam is fixed.
The boundary conditions are:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \sigma . {\bf n} &= \mathbf{g} &= 0 & \hbox{ on }\Gamma_1, \Gamma_4, \Gamma_3, \\
    {\bf u} &= \mathbf{0} && \hbox{ on }\Gamma_2
\end{array}\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
Here \({\bf u}=(u,v)\) has two components.

\sphinxAtStartPar
The above two equations are strongly coupled by their mixed derivatives, and thus any iterative solution on each of the components is risky.
One should rather use \sphinxstylestrong{FreeFEM}’s system approach and write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21e5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.28}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2}\PYG{o}{=}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{c+c1}{// The sqrt2 is because we want: epsilon(u1,u2)\PYGZsq{}* epsilon(v1,v2) = epsilon(u): epsilon(v)}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{p}{(} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu}\PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{nu}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{n}{nu}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{nu}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{nu}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{lame}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{lambda} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}
      \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu} \PYG{o}{*} \PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)} \PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{vv}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k+kt}{real} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lamevect.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{k+kp}{coef}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Move mesh}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lamedeform.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Output}
\PYG{k+kt}{real} \PYG{n}{dxmin} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dymin} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} dep. max x = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dxmin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ y=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dymin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{   dep. (20, 0) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} square mesh : nb \PYG{n+nv}{vertices}  \PYG{o}{=}\PYG{l+m}{121} ,  nb \PYG{n+nv}{triangles} \PYG{o}{=} \PYG{l+m}{200} ,  nb boundary edges \PYG{l+m}{40}
\PYGZhy{}\PYGZhy{} Solve :           min \PYGZhy{}0.00174137  max \PYG{l+m}{0}.00174105
         min \PYGZhy{}0.0263154  max \PYG{l+m}{1}.47016e\PYGZhy{}29
\PYGZhy{} dep.  max   \PYG{n+nv}{x} \PYG{o}{=} \PYGZhy{}0.00174137 \PYG{n+nv}{y}\PYG{o}{=}\PYGZhy{}0.0263154
   dep.  \PYG{o}{(}\PYG{l+m}{20},0\PYG{o}{)}  \PYG{o}{=} \PYGZhy{}1.8096e\PYGZhy{}07 \PYGZhy{}0.0263154
times: compile \PYG{l+m}{0}.010219s, execution \PYG{l+m}{1}.5827s
\end{sphinxVerbatim}

\sphinxAtStartPar
Solution of Lamé’s equations for elasticity for a 2D beam deflected by its own weight and clamped by its left vertical side is shown \hyperref[\detokenize{tutorials/elasticity:figelasticityvector}]{Fig.\@ \ref{\detokenize{tutorials/elasticity:figelasticityvector}}} and \hyperref[\detokenize{tutorials/elasticity:figelasticitydeformation}]{Fig.\@ \ref{\detokenize{tutorials/elasticity:figelasticitydeformation}}}.
Result are shown with a amplification factor equal to 100.
The size of the arrow is automatically bound, but the color gives the real length.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{lame_vector}.png}
\caption{Vector}\label{\detokenize{tutorials/elasticity:id1}}\label{\detokenize{tutorials/elasticity:figelasticityvector}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{lame_deformation}.png}
\caption{Deformation}\label{\detokenize{tutorials/elasticity:id2}}\label{\detokenize{tutorials/elasticity:figelasticitydeformation}}\end{subfigure}
\caption{Elasticity}\phantomsection\label{\detokenize{tutorials/elasticity:Elasticity}}

\end{figure}



\section{The System of Stokes for Fluids}
\label{\detokenize{tutorials/stokes:the-system-of-stokes-for-fluids}}\label{\detokenize{tutorials/stokes::doc}}
\sphinxAtStartPar
In the case of a flow invariant with respect to the third coordinate (two\sphinxhyphen{}dimensional flow), flows at low Reynolds number (for instance micro\sphinxhyphen{}organisms) satisfy,
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta \mathbf{u} + \nabla p &=& 0\\
    \nabla\cdot \mathbf{u} &=& 0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathbf{u}=(u_1,u_2)\) is the fluid velocity and \(p\) its pressure.

\sphinxAtStartPar
The driven cavity is a standard test.
It is a box full of liquid with its lid moving horizontally at speed one.
The pressure and the velocity must be discretized in compatible fintie element spaces for the LBB conditions to be satisfied:
\begin{equation*}
\begin{split}\sup_{p\in P_h}\frac{(\mathbf{u},\nabla p)}{|p|}\geq \beta|\mathbf{u}|~~~\forall \mathbf{u}\in U_h\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{p}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{stokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{uu}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vv}
        \PYG{o}{+} \PYG{n}{pp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{pp}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We add a stabilization term \(\bf{-10e-10*p*pp}\) to fix the constant part of the pressure.
\end{sphinxadmonition}

\sphinxAtStartPar
Results are shown on \hyperref[\detokenize{tutorials/stokes:figstokes}]{Fig.\@ \ref{\detokenize{tutorials/stokes:figstokes}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{stokes}.png}
\caption{Solution of Stokes’ equations for the driven cavity problem, showing the velocity field and the pressure level lines.}\label{\detokenize{tutorials/stokes:figstokes}}\end{figure}


\section{A projection algorithm for the Navier\sphinxhyphen{}Stokes equations}
\label{\detokenize{tutorials/navierStokesProjection:a-projection-algorithm-for-the-navier-stokes-equations}}\label{\detokenize{tutorials/navierStokesProjection::doc}}
\sphinxAtStartPar
\sphinxstylestrong{Summary :}
\sphinxstyleemphasis{Fluid flows require good algorithms and good triangultions. We show here an example of a complex algorithm and or first example of mesh adaptation.}

\sphinxAtStartPar
An incompressible viscous fluid satisfies:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t \mathbf{u} + \mathbf{u}\cdot\nabla\mathbf{u} + \nabla p - \nu\Delta\mathbf{u} &= 0 &\hbox{ in } \Omega\times ]0,T[\\
    \nabla\cdot\mathbf{u} &= 0 &\hbox{ in } \Omega\times ]0,T[\\
    \mathbf{u}|_{t=0} &= \mathbf{u}^0\\
    \mathbf{u}|_\Gamma &= \mathbf{u}_\Gamma
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
A possible algorithm, proposed by Chorin, is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    {1\over \delta t}[\mathbf{u}^{m+1} - \mathbf{u}^mo\mathbf{X}^m] + \nabla p^m -\nu\Delta \mathbf{u}^m &=& 0\\
    \mathbf{u}|_\Gamma &=& \mathbf{u}_\Gamma\\
    \nu \partial_n \mathbf{u}|_{\Gamma_{out}} &=&0
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta p^{m+1} &= -\nabla\cdot \mathbf{u}^mo\mathbf{X}^m &\\
    \partial_n p^{m+1} &= 0 &\mbox{ on } \Gamma\\
    p^{m+1} &= 0 &\mbox{ on } \Gamma_{out}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathbf{u}o\mathbf{X}(x) = \mathbf{u}(\mathbf{x}-\mathbf{u}(\mathbf{x})\delta t)\) since \(\partial_t \mathbf{u} + \mathbf{u}\cdot\nabla \mathbf{u}\) is approximated by the method of characteristics, as in the previous section.

\sphinxAtStartPar
We use the Chorin’s algorithm with free boundary condition at outlet (i.e. \(p=0,\nu \partial_n u = 0\)), to compute a correction, q, to the pressure.
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta q &= \nabla\cdot\mathbf{u}&\\
    q &= 0 \mbox{ on } &\Gamma_{out}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
and define
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \mathbf{u}^{m+1} &=& \tilde{\mathbf{u}} + P \nabla q\delta t\\
    p^{m+1} &=& p^m-q
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\tilde{\mathbf{u}}\) is the \((\mathbf{u}^{m+1}, v^{m+1})\) of Chorin’s algorithm, and where \(P\) is the \(L^2\) projection with mass lumping ( a sparse matrix).

\sphinxAtStartPar
\sphinxstylestrong{The backward facing step}

\sphinxAtStartPar
The geometry is that of a channel with a backward facing step so that the inflow section is smaller than the outflow section.
This geometry produces a fluid recirculation zone that must be captured correctly.

\sphinxAtStartPar
This can only be done if the triangulation is sufficiently fine, or well adapted to the flow.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
There is a technical difficulty in the example: the output B.C.
Here we put \(p=0\) and \(\nu \partial_n u = 0\).
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.0025}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{epsv} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{epsu} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{epsp} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{18}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{18}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a3}\PYG{p}{(}\PYG{l+m+mi}{150}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a4}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a5}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{q}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Definition of Matrix dtMx and dtMy}
\PYG{k+kt}{matrix} \PYG{n}{dtM1x}\PYG{p}{,} \PYG{n}{dtM1y}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{BuildMat}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}   \PYG{c+cm}{/* for memory managenemt */}
    \PYG{k+kt}{varf} \PYG{n}{vM}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{vdx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{vdy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Mlump} \PYG{o}{=} \PYG{n}{vM}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{one}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{one} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{M1} \PYG{o}{=} \PYG{n}{one} \PYG{p}{.}\PYG{o}{/} \PYG{n}{Mlump}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{dM1} \PYG{o}{=} \PYG{n}{M1}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Mdx} \PYG{o}{=} \PYG{n}{vdx}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Mdy} \PYG{o}{=} \PYG{n}{vdy}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dtM1x} \PYG{o}{=} \PYG{n}{dM1}\PYG{o}{*}\PYG{n}{Mdx}\PYG{p}{;}
    \PYG{n}{dtM1y} \PYG{o}{=} \PYG{n}{dM1}\PYG{o}{*}\PYG{n}{Mdy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//}

\PYG{c+c1}{// Build matrices}
\PYG{n}{BuildMat}

\PYG{c+c1}{// Time iterations}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{outflux} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{300}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{Vh} \PYG{n}{uold}\PYG{o}{=}\PYG{n}{u}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{n}{v}\PYG{p}{,} \PYG{n}{pold}\PYG{o}{=}\PYG{n}{p}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{solve} \PYG{n+nf}{pb4u} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsu}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{u}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
            \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*}\PYG{n}{w}
            \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{solve} \PYG{n+nf}{pb4v} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsv}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
            \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,}\PYG{n}{vold}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{vold}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*}\PYG{n}{w}
            \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}
        \PYG{p}{)}
        \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{solve} \PYG{n+nf}{pb4p} \PYG{p}{(}\PYG{n}{q}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsp}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{/}\PYG{n}{dt}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{q}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{//to have absolute epsilon in CG algorithm.}
    \PYG{n}{epsv} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{epsv}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{epsu} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{epsu}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{epsp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{epsp}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{p} \PYG{o}{=} \PYG{n}{pold}\PYG{o}{\PYGZhy{}}\PYG{n}{q}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dtM1x}\PYG{o}{*}\PYG{n}{q}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dtM1y}\PYG{o}{*}\PYG{n}{q}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{50} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{49}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.04}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{BuildMat} \PYG{c+c1}{// Rebuild mat.}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Error \PYGZam{} Outflux}
    \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{uold}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{v}\PYG{o}{\PYGZhy{}}\PYG{n}{vold}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outflux} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Err L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ outflux = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{outflux} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Verification}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{outflux}\PYG{p}{)}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{2e\PYGZhy{}3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NSprojP.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NSprojU.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Rannacher’s projection algorithm: result on an adapted mesh, \hyperref[\detokenize{tutorials/navierStokesProjection:fignavierprojectionmesh}]{Fig.\@ \ref{\detokenize{tutorials/navierStokesProjection:fignavierprojectionmesh}}}, showing the pressure, \hyperref[\detokenize{tutorials/navierStokesProjection:fignavierprojectionp}]{Fig.\@ \ref{\detokenize{tutorials/navierStokesProjection:fignavierprojectionp}}}, and the horizontal velocity \hyperref[\detokenize{tutorials/navierStokesProjection:fignavierprojectionu}]{Fig.\@ \ref{\detokenize{tutorials/navierStokesProjection:fignavierprojectionu}}} for a Reynolds number of 400 where mesh adaptation is done after 50 iterations on the first mesh.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.9\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{navier_stokes_projection_Th}.png}
\caption{Adapted mesh}\label{\detokenize{tutorials/navierStokesProjection:id1}}\label{\detokenize{tutorials/navierStokesProjection:fignavierprojectionmesh}}\end{subfigure}
\begin{subfigure}[t]{0.9\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{navier_stokes_projection_P}.png}
\caption{Pressure}\label{\detokenize{tutorials/navierStokesProjection:id2}}\label{\detokenize{tutorials/navierStokesProjection:fignavierprojectionp}}\end{subfigure}
\begin{subfigure}[t]{0.9\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{navier_stokes_projection_U}.png}
\caption{Velocity}\label{\detokenize{tutorials/navierStokesProjection:id3}}\label{\detokenize{tutorials/navierStokesProjection:fignavierprojectionu}}\end{subfigure}
\caption{Navier\sphinxhyphen{}Stokes projection}\phantomsection\label{\detokenize{tutorials/navierStokesProjection:NavierStokesProjection}}

\end{figure}



\section{Newton Method for the Steady Navier\sphinxhyphen{}Stokes equations}
\label{\detokenize{tutorials/navierStokesNewton:newton-method-for-the-steady-navier-stokes-equations}}\label{\detokenize{tutorials/navierStokesNewton::doc}}
\sphinxAtStartPar
The problem is find the velocity field \(\mathbf{u}=(u_i)_{i=1}^d\) and the pressure \(p\) of a Flow satisfying in the domain \(\Omega \subset \mathbb{R}^d (d=2,3)\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    (\mathbf{u}\cdot\nabla) \mathbf{u}-\nu \Delta \mathbf{u}+\nabla p&=&0\\
    \nabla\cdot \mathbf{u}&=&0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\nu\) is the viscosity of the fluid, \(\nabla = (\partial_i )_{i=1}^d\), the dot product is \(\cdot\), and \(\Delta = \nabla\cdot\nabla\) with the same boundary conditions (\(\mathbf{u}\) is given on \(\Gamma\)).

\sphinxAtStartPar
The weak form is find \(\mathbf{u}, p\) such that for \(\forall \mathbf{v}\) (zero on \(\Gamma\)), and \(\forall q\):
\begin{equation*}
\begin{split}\int_\Omega  ((\mathbf{u}\cdot\nabla) \mathbf{u} ). \mathbf{v} + \nu \nabla \mathbf{u}:\nabla \mathbf{v}
- p \nabla\cdot \mathbf{v} - q \nabla\cdot \mathbf{u} = 0\end{split}
\end{equation*}
\sphinxAtStartPar
The Newton Algorithm to solve nonlinear problem is:

\sphinxAtStartPar
Find \(u\in V\) such that \(F(u)=0\) where \(F : V \mapsto V\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
choose \(u_0\in \mathbb{R}^n\) , ;

\item {} 
\sphinxAtStartPar
for ( \(i =0\); \(i\) \textless{} niter; \(i = i+1\))
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{.}%
\item {} 
\sphinxAtStartPar
solve \(DF(u_i) w_i = F(u_i)\);

\item {} 
\sphinxAtStartPar
\(u_{i+1} = u_i - w_i\);

\end{enumerate}

\end{enumerate}

\sphinxAtStartPar
break \(|| w_i|| < \varepsilon\).

\sphinxAtStartPar
Where \(DF(u)\) is the differential of \(F\) at point \(u\), this is a linear application such that:
\begin{equation*}
\begin{split}F(u+\delta) = F(u) + DF(u) \delta + o(\delta)\end{split}
\end{equation*}
\sphinxAtStartPar
For Navier Stokes, \(F\) and \(DF\) are:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    F(\mathbf{u},p) &=& \int_\Omega((\mathbf{u}\cdot\nabla) \mathbf{u} ). \mathbf{v} + \nu \nabla \mathbf{u}:\nabla \mathbf{v}
    - p \nabla\cdot \mathbf{v} - q \nabla\cdot \mathbf{u}\\
    DF(\mathbf{u},p)(\mathbf{\delta u} ,\delta p) &=& \int_\Omega ((\mathbf{\delta u}\cdot\nabla) \mathbf{u} ). \mathbf v + ((\mathbf{u}\cdot\nabla) \mathbf{\delta u} ). \mathbf{v} \\
    &+& \nu \nabla \mathbf{\delta u}:\nabla \mathbf{v} - \delta p \nabla\cdot \mathbf{v} - q \nabla\cdot \mathbf{\delta u}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
So the Newton algorithm become:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{R} \PYG{o}{=} \PYG{l+m+mf}{5.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{15.}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{50.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nufinal} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{200.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cnu} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}

\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{ce}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{beb}\PYG{p}{(}\PYG{n}{tt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{tt}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{beu}\PYG{p}{(}\PYG{n}{tt}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{tt}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{R}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{beo}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{R}\PYG{p}{,} \PYG{n}{R}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bei}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{R}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{R}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ce}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beb}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beu}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{beo}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bei}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//bounding box for the plot}
\PYG{k+kt}{func} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1p}\PYG{p}{,}\PYG{n}{u2p}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{q}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{dp}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{pp}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{UgradV}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)} \PYG{p}{[}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                        \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Initialization}
\PYG{n}{u1} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{u2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Viscosity loop}
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// Newton loop}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{15}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Newton}
        \PYG{k+kt}{solve} \PYG{n}{Oseen} \PYG{p}{(}\PYG{p}{[}\PYG{n}{du1}\PYG{p}{,} \PYG{n}{du2}\PYG{p}{,} \PYG{n}{dp}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                    \PYG{n}{nu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{+} \PYG{n}{UgradV}\PYG{p}{(}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{]}
                \PYG{o}{+} \PYG{n}{UgradV}\PYG{p}{(} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{]}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{du1}\PYG{p}{,}\PYG{n}{du2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{dp}
                \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{o}{*}\PYG{n}{dp}\PYG{o}{*}\PYG{n}{q} \PYG{c+c1}{//stabilization term}
            \PYG{p}{)}
            \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)} \PYG{p}{(}
                    \PYG{n}{nu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{+} \PYG{n}{UgradV}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{]}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
                \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{p}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{du1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{du2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{;}

        \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{du1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{du2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{p}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{dp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{n}{Lu1}\PYG{o}{=}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,} \PYG{n}{Lu2}\PYG{o}{=}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,} \PYG{n}{Lp}\PYG{o}{=}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{;}
        \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{du1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{/}\PYG{n}{Lu1} \PYG{o}{+} \PYG{n}{du2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{/}\PYG{n}{Lu2} \PYG{o}{+} \PYG{n}{dp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{/}\PYG{n}{Lp}\PYG{p}{;}

        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ rey = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//converge}
        \PYG{k}{if}\PYG{p}{(} \PYG{k+kr}{n}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kp}{err} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{10.}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//blowup}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps}\PYG{p}{)}\PYG{p}{\PYGZob{}}  \PYG{c+c1}{//converge: decrease \PYGZdl{}\PYGZbs{}nu\PYGZdl{} (more difficult)}
        \PYG{c+c1}{// Plot}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ rey = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nu} \PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{k+kp}{bb}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Change nu}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{nu} \PYG{o}{=}\PYG{o}{=} \PYG{n}{nufinal}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{cnu} \PYG{o}{=} \PYG{n}{cnu}\PYG{o}{\PYGZca{}}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{c+c1}{//fast converge =\PYGZgt{} change faster}
        \PYG{n}{nu} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nufinal}\PYG{p}{,} \PYG{n}{nu}\PYG{o}{*} \PYG{n}{cnu}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//new viscosity}

        \PYG{c+c1}{// Update}
        \PYG{n}{u1p} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{;}
        \PYG{n}{u2p} \PYG{o}{=} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{pp} \PYG{o}{=} \PYG{n}{p}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}\PYG{p}{\PYGZob{}}   \PYG{c+c1}{//blowup: increase \PYGZdl{}\PYGZbs{}nu\PYGZdl{} (more simple)}
        \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{cnu}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.95}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the method finally blowup}

        \PYG{c+c1}{// Recover nu}
        \PYG{n}{nu} \PYG{o}{=} \PYG{n}{nu}\PYG{o}{/}\PYG{n}{cnu}\PYG{p}{;}
        \PYG{n}{cnu}\PYG{o}{=} \PYG{n}{cnu}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//no conv. =\PYGZgt{} change lower}
        \PYG{n}{nu} \PYG{o}{=} \PYG{n}{nu}\PYG{o}{*} \PYG{n}{cnu}\PYG{p}{;} \PYG{c+c1}{//new viscosity}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ restart nu = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Rey = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ (cnu = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ) }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

        \PYG{c+c1}{// Recover a correct solution}
        \PYG{n}{u1} \PYG{o}{=} \PYG{n}{u1p}\PYG{p}{;}
        \PYG{n}{u2} \PYG{o}{=} \PYG{n}{u2p}\PYG{p}{;}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{pp}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We use a trick to make continuation on the viscosity \(\nu\), because the Newton method blowup owe start with the final viscosity \(\nu\).

\sphinxAtStartPar
\(\nu\) is gradually increased to the desired value.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{NSNewtonTh}.jpg}
\caption{Mesh}\label{\detokenize{tutorials/navierStokesNewton:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{NSNewtonUP}.jpg}
\caption{Velocity and pressure}\label{\detokenize{tutorials/navierStokesNewton:id2}}\end{subfigure}
\caption{Naver\sphinxhyphen{}Stokes newton}\phantomsection\label{\detokenize{tutorials/navierStokesNewton:NSNewton}}

\end{figure}



\section{A Large Fluid Problem}
\label{\detokenize{tutorials/aLargeFluidProblem:a-large-fluid-problem}}\label{\detokenize{tutorials/aLargeFluidProblem::doc}}
\sphinxAtStartPar
A friend of one of us in Auroville\sphinxhyphen{}India was building a ramp to access an air conditioned room.
As I was visiting the construction site he told me that he expected to cool air escaping by the door to the room to slide down the ramp and refrigerate the feet of the coming visitors.
I told him “no way” and decided to check numerically.

\sphinxAtStartPar
The fluid velocity and pressure are solution of the Navier\sphinxhyphen{}Stokes equations with varying density function of the temperature.

\sphinxAtStartPar
The geometry is trapezoidal with prescribed inflow made of cool air at the bottom and warm air above and so are the initial conditions; there is free outflow, slip velocity at the top (artificial) boundary and no\sphinxhyphen{}slip at the bottom.
However the Navier\sphinxhyphen{}Stokes cum temperature equations have a RANS \(k-\epsilon\) model and a Boussinesq approximation for the buoyancy.
This comes to :
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \partial_t\theta+u\nabla\theta-\nabla\cdot(\kappa_T^m\nabla\theta) &=& 0\\
    \partial_t u +u\nabla u -\nabla\cdot(\mu_T\nabla u) +\nabla p+ e(\theta-\theta_0)\vec e_2 &=&0\\
    \nabla\cdot u &=& 0\\
    \mu_T &=& c_\mu\frac{k^2}\epsilon\\
    \kappa_T &=& \kappa\mu_T\\
    \partial_t k + u\nabla k + \epsilon -\nabla\cdot(\mu_T\nabla k) &=& \frac{\mu_T}2|\nabla u+\nabla u^T|^2\\
    \partial_t\epsilon+u\nabla\epsilon + c_2\frac{\epsilon^2} k -\frac{c_\epsilon}{c_\mu}\nabla\cdot (\mu_T\nabla\epsilon) &=& \frac{c_1}2 k|\nabla u+\nabla u^T|^2\\
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
We use a time discretization which preserves positivity and uses the method of characteristics (\(X^m(x)\approx x-u^m(x)\delta t\))
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \frac 1{\delta t}(\theta^{m+1}-\theta^m \circ X^m)-\nabla\cdot(\kappa_T^m\nabla\theta^{m+1}) &=& 0\\
    \frac1{\delta t}(u^{m+1}-u^m \circ X^m) -\nabla\cdot(\mu_T^m\nabla u^{m+1}) +\nabla p^{m+1}+ e(\theta^{m+1}-\theta_0)\vec e_2 &=& 0\\
    \nabla\cdot u^{m+1} &=& 0\\
    \frac1{\delta t}(k^{m+1}-k^m \circ X^m) + k^{m+1}\frac{\epsilon^m}{k^m} -\nabla\cdot(\mu_T^m\nabla k^{m+1}) &=& \frac{\mu_T^m}2|\nabla u^m+{\nabla u^m}^T|^2\\
    \frac1{\delta t}(\epsilon^{m+1}-\epsilon^m \circ X^m) + c_2\epsilon^{m+1}\frac{\epsilon^m} {k^m} -\frac{c_\epsilon}{c_\mu}\nabla\dot(\mu_T^m\nabla\epsilon^{m+1}) &=& \frac{c_1}2 k^m|\nabla u^m+{\nabla u^m}^T|^2\\
    \mu_T ^{m+1} &=& c_\mu\frac{{k^{m+1}}^2}{\epsilon^{m+1}}\\
    \kappa_T^{m+1} &=& \kappa\mu_T^{m+1}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
In variational form and with appropriated boundary conditions the problem is :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nnPlus} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{15.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hSlope} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{reylnods} \PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{beta} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{9.81}\PYG{o}{/}\PYG{l+m+mf}{303.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{numu} \PYG{o}{=} \PYG{n}{nu}\PYG{o}{/}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{0.09}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{nuep} \PYG{o}{=} \PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{4.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{Penalty} \PYG{o}{=} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{hSlope}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{hSlope}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nnPlus}\PYG{o}{*}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{n}{hSlope}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H} \PYG{o}{+} \PYG{n}{hSlope}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{L}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b5}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b6}\PYG{p}{(}\PYG{n}{nnPlus}\PYG{o}{*}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespaces}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{Vx}\PYG{p}{,} \PYG{n}{Vy}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{q}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Tp}\PYG{p}{,} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{35}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{,} \PYG{n}{kp}\PYG{o}{=}\PYG{n}{k}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ep}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{,} \PYG{n}{epp}\PYG{o}{=}\PYG{n}{ep}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{V0h}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{muT}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{prodk}\PYG{p}{,} \PYG{n}{prode}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{kappa}\PYG{o}{=}\PYG{l+m+mf}{0.25e\PYGZhy{}4}\PYG{p}{,} \PYG{n}{stress}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Functions}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Temperature}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha} \PYG{o}{*} \PYG{n}{T} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{+} \PYG{n}{kappa}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{T}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{Tp}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b6}\PYG{p}{,} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{KineticTurbulence}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{epp}\PYG{o}{/}\PYG{n}{kp} \PYG{o}{+} \PYG{n}{alpha}\PYG{p}{)} \PYG{o}{*} \PYG{n}{k} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{+} \PYG{n}{muT}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{prodk} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{kp}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{k}\PYG{o}{=}\PYG{n}{beta}\PYG{o}{*}\PYG{n}{numu}\PYG{o}{*}\PYG{n}{stress}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{ViscosityTurbulence}\PYG{p}{(}\PYG{n}{ep}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{l+m+mf}{1.92}\PYG{o}{*}\PYG{n}{epp}\PYG{o}{/}\PYG{n}{kp} \PYG{o}{+} \PYG{n}{alpha}\PYG{p}{)} \PYG{o}{*} \PYG{n}{ep} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{+} \PYG{n}{muT} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{ep}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{T} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{l+m+mf}{0.001}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{prode} \PYG{o}{*} \PYG{n}{q}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{epp}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{ep}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{ep}\PYG{o}{=}\PYG{n}{beta}\PYG{o}{*}\PYG{n}{nuep}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{stress}\PYG{p}{,}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Initialization with stationary solution}
\PYG{k+kt}{solve} \PYG{n+nf}{NavierStokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vx}\PYG{p}{,} \PYG{n}{Vy}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha} \PYG{o}{*} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{Vx}\PYG{p}{,} \PYG{n}{Vy}\PYG{p}{]}
      \PYG{o}{+} \PYG{n}{muT} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{o}{:} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{p} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{n}{Penalty}
      \PYG{o}{\PYGZhy{}} \PYG{n}{p} \PYG{o}{*} \PYG{n}{Div}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n}{Div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Ux} \PYG{o}{*} \PYG{n}{Vx} \PYG{o}{*} \PYG{l+m+mf}{0.1}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{k+kp}{eps} \PYG{o}{*} \PYG{p}{(}\PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{*} \PYG{n}{Vx}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{Upx}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vx}
      \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Upx}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{Upy}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vy}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b6}\PYG{p}{,} \PYG{n}{Ux}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b5}\PYG{p}{,} \PYG{n}{Ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b2}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{Upx}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{/}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b3}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[Ux, Uy] \PYGZhy{} p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{21}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.}\PYG{p}{;}
      \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ux}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{pp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{p}\PYG{p}{(}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.}\PYG{p}{,}\PYG{l+m+mf}{0.999}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Ux x=0.5 cup}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{yy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{p y=0.999 cup}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Initialization}
\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//probably too big}
\PYG{k+kt}{int} \PYG{k+kp}{nbiter} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{coefdt} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kp}{nbiter}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{coefcut} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kp}{nbiter}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cut} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{tol} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{coeftol} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kp}{nbiter}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{reylnods}\PYG{p}{;}

\PYG{n}{T} \PYG{o}{=} \PYG{n}{T} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Convergence loop}
\PYG{k+kt}{real} \PYG{n}{T0} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k+kp}{nbiter}\PYG{p}{;} \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Iteration }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} dt = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}

   \PYG{c+c1}{// Time loop}
   \PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{500}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Time step }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} t = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

      \PYG{c+c1}{// Update}
      \PYG{n}{Upx} \PYG{o}{=} \PYG{n}{Ux}\PYG{p}{;}
      \PYG{n}{Upy} \PYG{o}{=} \PYG{n}{Uy}\PYG{p}{;}
      \PYG{n}{kp} \PYG{o}{=} \PYG{n}{k}\PYG{p}{;}
      \PYG{n}{epp} \PYG{o}{=} \PYG{n}{ep}\PYG{p}{;}
      \PYG{n}{Tp} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for beauty only should be removed}
      \PYG{n}{Tp} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{Tp}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for security only should be removed}
      \PYG{n}{kp} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;} \PYG{n}{epp} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{ep}\PYG{p}{,} \PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// to be secure: should not be active}
      \PYG{n}{muT} \PYG{o}{=} \PYG{l+m+mf}{0.09}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{/}\PYG{n}{epp}\PYG{p}{;}

      \PYG{c+c1}{// Solve NS}
      \PYG{n}{NavierStokes}\PYG{p}{;}

      \PYG{c+c1}{// Update}
      \PYG{n}{prode} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.126}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
      \PYG{n}{prodk} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{prode}\PYG{o}{*}\PYG{n}{kp}\PYG{o}{/}\PYG{n}{epp}\PYG{o}{*}\PYG{l+m+mf}{0.09}\PYG{o}{/}\PYG{l+m+mf}{0.126}\PYG{p}{;}
      \PYG{n}{kappa} \PYG{o}{=} \PYG{n}{muT}\PYG{o}{/}\PYG{l+m+mf}{0.41}\PYG{p}{;}
      \PYG{n}{stress} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

      \PYG{c+c1}{// Solve k\PYGZhy{}eps\PYGZhy{}T}
      \PYG{n}{KineticTurbulence}\PYG{p}{;}
      \PYG{n}{ViscosityTurbulence}\PYG{p}{;}
      \PYG{n}{Temperature}\PYG{p}{;}

      \PYG{c+c1}{// Plot}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{T}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ [Ux, Uy] \PYGZhy{} p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

      \PYG{c+c1}{// Time}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{T0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+c1}{// Check}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{k+kp}{nbiter}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Adaptmesh}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{cutoff}\PYG{o}{=}\PYG{n}{cut}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{k+kp}{tol}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Update}
   \PYG{n}{dt} \PYG{o}{=} \PYG{n}{dt} \PYG{o}{*} \PYG{n}{coefdt}\PYG{p}{;}
   \PYG{k+kp}{tol} \PYG{o}{=} \PYG{k+kp}{tol} \PYG{o}{*} \PYG{n}{coeftol}\PYG{p}{;}
   \PYG{n}{cut} \PYG{o}{=} \PYG{n}{cut} \PYG{o}{*} \PYG{n}{coefcut}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Total Time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{T0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_100}.png}
\caption{Temperature at time step 100}\label{\detokenize{tutorials/aLargeFluidProblem:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_100}.png}
\caption{Velocity at time step 100}\label{\detokenize{tutorials/aLargeFluidProblem:id2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_200}.png}
\caption{Temperature at time step 200}\label{\detokenize{tutorials/aLargeFluidProblem:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_200}.png}
\caption{Velocity at time step 200}\label{\detokenize{tutorials/aLargeFluidProblem:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_300}.png}
\caption{Temperature at time step 300}\label{\detokenize{tutorials/aLargeFluidProblem:id5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_300}.png}
\caption{Velocity at time step 300}\label{\detokenize{tutorials/aLargeFluidProblem:id6}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_400}.png}
\caption{Temperature at time step 400}\label{\detokenize{tutorials/aLargeFluidProblem:id7}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_400}.png}
\caption{Velocity at time step 400}\label{\detokenize{tutorials/aLargeFluidProblem:id8}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_T_500}.png}
\caption{Temperature at time step 500}\label{\detokenize{tutorials/aLargeFluidProblem:id9}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{ALargeFluidProblem_U_500}.png}
\caption{Velocity at time step 500}\label{\detokenize{tutorials/aLargeFluidProblem:id10}}\end{subfigure}
\caption{A large fluid problem}\phantomsection\label{\detokenize{tutorials/aLargeFluidProblem:ALargeFluidProblem}}

\end{figure}



\section{An Example with Complex Numbers}
\label{\detokenize{tutorials/complexNumbers:an-example-with-complex-numbers}}\label{\detokenize{tutorials/complexNumbers::doc}}
\sphinxAtStartPar
In a microwave oven heat comes from molecular excitation by an electromagnetic field.
For a plane monochromatic wave, amplitude is given by Helmholtz’s equation:
\begin{equation*}
\begin{split}\beta v + \Delta v = 0.\end{split}
\end{equation*}
\sphinxAtStartPar
We consider a rectangular oven where the wave is emitted by part of the upper wall.
So the boundary of the domain is made up of a part \(\Gamma_1\) where \(v=0\) and of another part \(\Gamma_2=[c,d]\) where for instance \(\displaystyle v=\sin\left(\pi{y-c\over c-d}\right)\).

\sphinxAtStartPar
Within an object to be cooked, denoted by \(B\), the heat source is proportional to \(v^2\).
At equilibrium, one has :
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta\theta &=& v^2 I_B\\
    \theta_\Gamma &=& 0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(I_B\) is \(1\) in the object and \(0\) elsewhere.

\sphinxAtStartPar
In the program below \(\beta = 1/(1-i/2)\) in the air and \(2/(1-i/2)\) in the object (\(i=\sqrt{-1}\)):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{20.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{20.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{15.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{8.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{12.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{b0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{o}{+}\PYG{n}{e}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{g}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{g}\PYG{o}{+}\PYG{n}{l}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{n}{e}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{l}\PYG{o}{+}\PYG{n}{g}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{e}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{l}\PYG{o}{+}\PYG{n}{g}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a3}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+}\PYG{n}{a4}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a5}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{meat} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{o}{\PYGZhy{}}\PYG{n}{e}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{g}\PYG{o}{+}\PYG{n}{l}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{air}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.01}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{R}\PYG{o}{=}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{\PYGZhy{}}\PYG{n}{air}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{meat}\PYG{o}{\PYGZhy{}}\PYG{n}{air}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vr}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{ff}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{muwave}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{R}\PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{n}{i}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n}{vr} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vi} \PYG{o}{=} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vr}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rmuonde.ps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{imuonde.ps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem (temperature)}
\PYG{n}{ff}\PYG{o}{=}\PYG{l+m+mf}{1e5}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vr}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{vi}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{R}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{temperature}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}\PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{ff}\PYG{o}{*}\PYG{n}{uu}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tempmuonde.ps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Results are shown on \hyperref[\detokenize{tutorials/complexNumbers:figcomplexreal}]{Fig.\@ \ref{\detokenize{tutorials/complexNumbers:figcomplexreal}}}, \hyperref[\detokenize{tutorials/complexNumbers:figcompleximaginary}]{Fig.\@ \ref{\detokenize{tutorials/complexNumbers:figcompleximaginary}}} and \hyperref[\detokenize{tutorials/complexNumbers:figcomplextemperature}]{Fig.\@ \ref{\detokenize{tutorials/complexNumbers:figcomplextemperature}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{real_microwave}.png}
\caption{Real part}\label{\detokenize{tutorials/complexNumbers:id1}}\label{\detokenize{tutorials/complexNumbers:figcomplexreal}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{imaginary_microwave}.png}
\caption{Imaginary part}\label{\detokenize{tutorials/complexNumbers:id2}}\label{\detokenize{tutorials/complexNumbers:figcompleximaginary}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{temperature_microwave}.png}
\caption{Temperature}\label{\detokenize{tutorials/complexNumbers:id3}}\label{\detokenize{tutorials/complexNumbers:figcomplextemperature}}\end{subfigure}
\caption{Microwave}\phantomsection\label{\detokenize{tutorials/complexNumbers:Microwave}}

\end{figure}



\section{Optimal Control}
\label{\detokenize{tutorials/optimalControl:optimal-control}}\label{\detokenize{tutorials/optimalControl::doc}}
\sphinxAtStartPar
Thanks to the function \sphinxcode{\sphinxupquote{BFGS}} it is possible to solve complex nonlinear optimization problem within \sphinxstylestrong{FreeFEM}.
For example consider the following inverse problem
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \min_{b, c, d\in R}J &=& \int_E(u-u_d)^2\\
    -\nabla(\kappa(b, c, d)\cdot\nabla u) &=& 0\\
    u|_\Gamma &=& u_\Gamma
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where the desired state \(u_d\), the boundary data \(u_\Gamma\) and the observation set \(E\subset\Omega\) are all given.
Furthermore let us assume that:
\begin{equation*}
\begin{split}\kappa(x)=1+bI_B(x)+cI_C(x)+dI_D(x)\quad\forall x\in\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
where \(B,C,D\) are separated subsets of \(\Omega\).

\sphinxAtStartPar
To solve this problem by the quasi\sphinxhyphen{}Newton BFGS method we need the derivatives of \(J\) with respect to \(b,c,d\).
We self explanatory notations, if \(\delta b,\delta c,\delta d\) are variations of \(b,c,d\) we have:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \delta J &\approx& 2\int_E(u-u_d)\delta u\\
    -\nabla(\kappa\cdot\nabla\delta u) &\approx& \nabla(\delta\kappa\cdot\nabla u)\\
    \delta u|_\Gamma &=& 0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Obviously \(J'_b\) is equal to \(\delta J\) when \(\delta b=1,\delta c=0,\delta d=0\), and so on for \(J'_c\) and \(J'_d\).

\sphinxAtStartPar
All this is implemented in the following program:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{aa}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{dd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dd}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Ib}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1.0001}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{Ic}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1.0001}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{Id}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1.0001}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{Ie}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{ud}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{du}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{z}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ib}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ic}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Id}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{k+kp}{A}\PYG{p}{;}
\PYG{n}{ud} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{k+kt}{ofstream} \PYG{n+nf}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{Z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{k+kr}{z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=}\PYG{n}{Z}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kp}{A}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Ie}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ud}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem BFGS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dJdz}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{k+kp}{B} \PYG{p}{(}\PYG{n}{du}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ib}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ic}\PYG{o}{+}\PYG{k+kr}{z}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Id}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{du}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{du}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ib}\PYG{o}{+}\PYG{n+nf}{dz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Ic}\PYG{o}{+}\PYG{n+nf}{dz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Id}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{n}{du}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{Z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n+nf}{dz}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
         \PYG{n+nf}{dz}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{n+nf}{dz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{k+kp}{B}\PYG{p}{;}
      \PYG{n}{dJdz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Ie}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ud}\PYG{p}{)}\PYG{o}{*}\PYG{n}{du}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{return} \PYG{n}{dJdz}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Z}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{n}{Z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(z) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{Z}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{z}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ud}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In this example the sets \(B,C,D,E\) are circles of boundaries \(bb,cc,dd,ee\) and the domain \(\Omega\) is the circle of boundary \(aa\).

\sphinxAtStartPar
The desired state \(u_d\) is the solution of the PDE for \(b=2,c=3,d=4\). The unknowns are packed into array \(z\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
It is necessary to recopy \(Z\) into \(z\) because one is a local variable while the other one is global.
\end{sphinxadmonition}

\sphinxAtStartPar
The program found \(b=2.00125,c=3.00109,d=4.00551\).

\sphinxAtStartPar
\hyperref[\detokenize{tutorials/optimalControl:figoptimalu}]{Fig.\@ \ref{\detokenize{tutorials/optimalControl:figoptimalu}}} and \hyperref[\detokenize{tutorials/optimalControl:figoptimalj}]{Fig.\@ \ref{\detokenize{tutorials/optimalControl:figoptimalj}}} show \(u\) at convergence and the successive function evaluations of \(J\).

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{u-bfgs}.png}
\caption{Level line of \(u\).}\label{\detokenize{tutorials/optimalControl:id1}}\label{\detokenize{tutorials/optimalControl:figoptimalu}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{OptimalControl_J}.png}
\caption{Successive evaluations of \(J\) by BFGS (5 values above 500 have been removed for readability)}\label{\detokenize{tutorials/optimalControl:id2}}\label{\detokenize{tutorials/optimalControl:figoptimalj}}\end{subfigure}
\caption{Optimal control}\phantomsection\label{\detokenize{tutorials/optimalControl:OptimalControl}}

\end{figure}


\sphinxAtStartPar
Note that an \sphinxstyleemphasis{adjoint state} could have been used.
Define \(p\) by:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\nabla\cdot(\kappa\nabla p) &=& 2I_E(u-u_d)\\
    p|_\Gamma &=& 0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Consequently:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \delta J &=& -\int_{\Omega}(\nabla\cdot(\kappa\nabla p))\delta u\nonumber\\
    &=& \int_\Omega(\kappa\nabla p\cdot\nabla\delta u)\\
    &=&-\int_\Omega(\delta\kappa\nabla p\cdot\nabla u)
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Then the derivatives are found by setting \(\delta b=1, \delta c=\delta d=0\) and so on:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    J'_b&=&-\int_B \nabla p\cdot\nabla u\\
    J'_c&=&-\int_C \nabla p\cdot\nabla u\\
    J'_d&=&-\int_D \nabla p\cdot\nabla u
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
As BFGS stores an \(M\times M\) matrix where \(M\) is the number of unknowns, it is dangerously expensive to use this method when the unknown \(x\) is a Finite Element Function.
One should use another optimizer such as the NonLinear Conjugate Gradient \sphinxcode{\sphinxupquote{NLCG}} (also a key word of \sphinxstylestrong{FreeFEM}).
\end{sphinxadmonition}


\section{A Flow with Shocks}
\label{\detokenize{tutorials/flowWithShocks:a-flow-with-shocks}}\label{\detokenize{tutorials/flowWithShocks::doc}}
\sphinxAtStartPar
Compressible Euler equations should be discretized with Finite Volumes or FEM with flux up\sphinxhyphen{}winding scheme but these are not implemented in \sphinxstylestrong{FreeFEM}.
Nevertheless acceptable results can be obtained with the method of characteristics provided that the mean values \(\displaystyle \bar f=\frac12\left(f^++f^-\right)\) are used at shocks in the scheme, and finally mesh adaptation.
\begin{equation}\label{equation:tutorials/flowWithShocks:euler}
\begin{split}\begin{array}{rcl}
    \partial_t\rho+\bar u\nabla\rho + \bar\rho\nabla\cdot u &=& 0\nonumber\\
    \bar\rho( \partial_t u+\frac{\overline{\rho u}}{\bar\rho}\nabla u +\nabla p &=& 0\nonumber\\
    \partial_t p + \bar u\nabla p +(\gamma-1)\bar p\nabla\cdot u &=& 0\\
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
One possibility is to couple \(u,p\) and then update \(\rho\), i.e.:
\begin{equation}\label{equation:tutorials/flowWithShocks:eulalgo}
\begin{split}\begin{array}{rcl}
    \frac 1{(\gamma-1)\delta t\bar p^m} (p^{m+1}-p^m \circ X^m) + \nabla\cdot u^{m+1} &=& 0\nonumber\\
    \frac{\bar\rho^m}{\delta t}(u^{m+1}-u^m \circ {\tilde X}^m ) +\nabla p^{m+1} &=& 0\nonumber\\
    \rho^{m+1} = \rho^m \circ X^m + \frac{\bar\rho^m}{(\gamma-1)\bar p^m}(p^{m+1} &-& p^m \circ X^m)
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
A numerical result is given on \hyperref[\detokenize{tutorials/flowWithShocks:figflowmach}]{Fig.\@ \ref{\detokenize{tutorials/flowWithShocks:figflowmach}}} and the \sphinxstylestrong{FreeFEM} script is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{anew} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{err0} \PYG{o}{=} \PYG{l+m+mf}{0.00625}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{ddd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{aaa1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{x0}\PYG{o}{\PYGZhy{}}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{cercle}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{x0}\PYG{o}{+}\PYG{n}{rr}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{y0}\PYG{o}{+}\PYG{n}{rr}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{aaa2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{x0}\PYG{o}{+}\PYG{n}{rr}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{bbb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

 \PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{anew}\PYG{p}{)}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh} \PYG{p}{(}\PYG{n}{ccc}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ddd}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{aaa1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cercle}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{aaa2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bbb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZus{}circle.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{r}\PYG{p}{,} \PYG{n}{rh}\PYG{p}{,} \PYG{n}{r1}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{dn}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Initialization}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{anew}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{u1} \PYG{o}{=} \PYG{n}{u0}\PYG{p}{;}
   \PYG{n}{v1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{r1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{ifstream} \PYG{n}{g}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{g} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ifstream} \PYG{n+nf}{gg}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{gg} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ifstream} \PYG{n+nf}{ggg}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ggg} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{r1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{eta.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{err0} \PYG{o}{=} \PYG{n}{err0}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
   \PYG{n}{dt} \PYG{o}{=} \PYG{n}{dt}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{euler}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{n}{rh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{uh} \PYG{o}{+} \PYG{n}{v}\PYG{o}{*}\PYG{n}{vh} \PYG{o}{+} \PYG{n}{r}\PYG{o}{*}\PYG{n}{rh}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
      \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{o}{*}\PYG{n}{uh} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rh}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rh}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
      \PYG{o}{\PYGZhy{}} \PYG{p}{(}
           \PYG{n}{rh}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{r1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{uh}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{u1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{vh}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{v1}\PYG{p}{)}
      \PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
   \PYG{p}{)}
   \PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{rh}\PYG{o}{*}\PYG{n}{u}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Iterations}
\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{k}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{err0} \PYG{o}{=} \PYG{n}{err0}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{dt} \PYG{o}{=} \PYG{n}{dt}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+c1}{// Solve}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{euler}\PYG{p}{;}
      \PYG{n}{u1}\PYG{o}{=}\PYG{n}{u}\PYG{p}{;}
      \PYG{n}{v1}\PYG{o}{=}\PYG{n}{v}\PYG{p}{;}
      \PYG{n}{r1}\PYG{o}{=}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{k = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ E = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{v}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{r}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{c+c1}{// Mesh adaptation}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{r}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{40000}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{err0}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbjacoby}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{omega}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{nbsmooth}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{maxsubdiv}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kp}{rescaling}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{v} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;}
   \PYG{n}{r} \PYG{o}{=} \PYG{n}{r}\PYG{p}{;}

   \PYG{c+c1}{// Save}
   \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZus{}circle.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{ofstream} \PYG{n+nf}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{ofstream} \PYG{n+nf}{fff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{fff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{r1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{u}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mach.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{r1} \PYG{o}{=} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{mach_2r}.png}
\caption{Pressure for a Euler flow around a disk at Mach 2 computed by \eqref{equation:tutorials/flowWithShocks:eulalgo}}\label{\detokenize{tutorials/flowWithShocks:figflowmach}}\end{figure}


\section{Time dependent schema optimization for heat equations}
\label{\detokenize{tutorials/heatEquationOptimization:time-dependent-schema-optimization-for-heat-equations}}\label{\detokenize{tutorials/heatEquationOptimization::doc}}
\sphinxAtStartPar
First, it is possible to define variational forms, and use this forms to build matrix and vector to make very fast script (4 times faster here).

\sphinxAtStartPar
For example solve the {\hyperref[\detokenize{tutorials/thermalConduction:thermalconduction}]{\sphinxcrossref{\DUrole{std,std-ref}{ThermalConduction}}}} problem, we must solve the temperature equation in \(\Omega\) in a time interval (0,T).
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \partial_t u -\nabla\cdot(\kappa\nabla u) &=& 0 &\hbox{ in } \Omega\times(0,T)\\
    u(x,y,0) &=& u_0 + x u_1\\
    u &=& 30 &\hbox{ on } \Gamma_{24}\times(0,T)\\
    \kappa\frac{\partial u}{\partial n} + \alpha(u-u_e) &=& 0 &\hbox{ on } \Gamma\times(0,T)
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The variational formulation is in \(L^2(0,T;H^1(\Omega))\); we shall seek \(u^n\) satisfying:
\begin{equation*}
\begin{split}\forall w \in V_{0};\ \int_\Omega \frac{u^n-u^{n-1}}{\delta t} w + \kappa\nabla u^n\nabla w) +\int_\Gamma\alpha(u^n-u_{ue})w=0\end{split}
\end{equation*}
\sphinxAtStartPar
where \(V_0 = \{w\in H^1(\Omega)/ w_{|\Gamma_{24}}=0\}\).

\sphinxAtStartPar
So, to code the method with the matrices \(A=(A_{ij})\), \(M=(M_{ij})\), and the vectors \(u^n, b^n, b',b", b_{cl}\) (notation if \(w\) is a vector then \(w_i\) is a component of the vector).
\begin{equation*}
\begin{split}u^n = A^{-1} b^n,
    \quad b' = b_0 + M u^{n-1},
    \quad b"= \frac{1}{\varepsilon} \; b_{cl} ,
    \quad b^n_i = \left\{
        \begin{array}{cl}
            b''_i & \mbox{if }\ i \in \Gamma_{24} \\
            b'_i & \mbox{else }
        \end{array}\right.
    \label{eq tgv}\end{split}
\end{equation*}
\sphinxAtStartPar
Where with \(\frac{1}{\varepsilon} = \mathtt{tgv} = 10^{30}\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A_{ij} &=&
      \left\{\begin{array}{cl}
      \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and}\quad j=i\\
      \displaystyle{\int_{\Omega} w_j w_i / dt + k (\nabla w_j. \nabla w_i ) + \int_{\Gamma_{13}} \alpha w_j w_i} & \mbox{else}
      \end{array}\right.\\
    M_{ij} &=&
      \left\{\begin{array}{cl}
      \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and}\quad j=i \\
      \displaystyle n{\int_{\Omega} w_j w_i / dt} & \mbox{else}
      \end{array}\right. \\
    b_{0,i} &=& n{\int_{\Gamma_{13}} \alpha u_{ue} w_i } \\
    b_{cl} &=& u^{0} \quad \mbox{the initial data}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The Fast version script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vh} \PYG{n}{u0}\PYG{o}{=}\PYG{n}{fu0}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Create three variational formulation, and build the matrices \(A\),\(M\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vthermic} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vthermic0} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vMass} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, to build the right hand size; we need 4 vectors.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{vthermic0}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant part of RHS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcn} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tgv on Dirichlet part}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcl} \PYG{o}{=} \PYG{k+kp}{tgv}\PYG{o}{*}\PYG{n}{u0}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}   \PYG{c+c1}{//the Dirichlet B.C. part}

\PYG{c+c1}{// The fast loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b0}\PYG{p}{;}   \PYG{c+c1}{//the RHS}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add the the time dependent part}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcn} \PYG{o}{?} \PYG{n+nl}{bcl} \PYG{o}{:} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//do \PYGZdl{}\PYGZbs{}forall i\PYGZdl{}: b[i] = bcn[i] ? bcl[i] : b[i];}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//solve linear problem}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{Tutorial to write a transient Stokes solver in matrix form}
\label{\detokenize{tutorials/timeDependentStokes:tutorial-to-write-a-transient-stokes-solver-in-matrix-form}}\label{\detokenize{tutorials/timeDependentStokes::doc}}
\sphinxAtStartPar
Consider the following script to solve a time dependent Stokes problem in a cavity

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Qh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Qh} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{Qh} \PYG{n}{pp}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{stokes} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{pp}\PYG{o}{*}\PYG{l+m+mf}{1.e\PYGZhy{}6}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{pp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{uold}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{vold}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{int} \PYG{k+kr}{m}\PYG{p}{,} \PYG{n}{M} \PYG{o}{=} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{stokes}\PYG{p}{;}
    \PYG{n}{uold} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{n}{vold} \PYG{o}{=} \PYG{n}{v}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{m}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Every iteration is in fact of the form \(A[u,v,p] = B[uold,vold,pold] + b\) where \(A,B\) are matrices and \(b\) is a vector containing the boundary conditions.
\(A,B,b\) are constructed by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{aa} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{v}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{pp}\PYG{o}{*}\PYG{l+m+mf}{1.e\PYGZhy{}6}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{pp}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{k+kp}{bb} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{pold}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{uold}\PYG{o}{*}\PYG{n}{uu}\PYG{o}{+}\PYG{n}{vold}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{c+c1}{//+ on(1, 2, 4, uold=0, vold=0)}
    \PYG{c+c1}{//+ on(3, uold=1, vold=0)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{bcl} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{pold}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{uold}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{vold}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{aa}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcl}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that the boundary conditions are not specified in \(bb\).
Removing the comment \sphinxcode{\sphinxupquote{//}} would cause the compiler to multiply the diagonal terms corresponding to a Dirichlet degree of freedom by a very large term (\sphinxcode{\sphinxupquote{tgv}}); if so \(b\) would not be needed, on the condition that \(uold=1\) on boundary 3 initially.
Note also that b has a tgv on the Dirichlet nodes, by construction, and so does A.

\sphinxAtStartPar
The loop will then be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{aux}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{aux} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{sol}\PYG{p}{;} \PYG{n}{aux} \PYG{o}{+}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{sol} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
There is yet a difficulty with the initialization of \sphinxcode{\sphinxupquote{sol}} and with the solution from \sphinxcode{\sphinxupquote{sol}}.
For this we need a temporary vector in \(X_h\) and here is a solution:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{p}{[}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{wp}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uold}\PYG{p}{,} \PYG{n}{vold}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{w1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//cause also the copy of w2 and wp}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{n}{M}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{aux} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{sol}\PYG{p}{;} \PYG{n}{aux} \PYG{o}{+}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
    \PYG{n}{sol} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{aux}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{w1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=}\PYG{n}{sol}\PYG{p}{;} \PYG{n}{u}\PYG{o}{=}\PYG{n}{w1}\PYG{p}{;} \PYG{n}{v}\PYG{o}{=} \PYG{n}{w2}\PYG{p}{;} \PYG{n}{p}\PYG{o}{=}\PYG{n}{wp}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{m}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The freefem team agrees that the line \sphinxcode{\sphinxupquote{sol=w1{[}{]};}} is mysterious as it copies also w2 and wp into sol.
Structured data such as vectors of \(X_h\) here cannot be written component by component.
Hence \sphinxcode{\sphinxupquote{w1=u}} is not allowed.


\section{Wifi Propagation}
\label{\detokenize{tutorials/wifiPropagation:wifi-propagation}}\label{\detokenize{tutorials/wifiPropagation::doc}}

\subsection{Summary}
\label{\detokenize{tutorials/wifiPropagation:summary}}
\sphinxAtStartPar
In this tutorial, we will study the wifi signal power in a flat.
An awesome flat is especially designed for the experiment, with \sphinxstylestrong{2} walls:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{house}.png}
\caption{Flat}\label{\detokenize{tutorials/wifiPropagation:id1}}\end{figure}

\sphinxAtStartPar
Even if the flat seems small enough to be covered by wifi everywhere, it is still interesting to study where the signal’s power is the lowest.
We will study where to put the hotspot to get the best coverage, and as we’re a bit lazy we will only put it next to the left wall.


\subsection{Physics}
\label{\detokenize{tutorials/wifiPropagation:physics}}
\sphinxAtStartPar
In a nutshell, the Wifi is a electromagnetic wave that contains a signal : Internet data.
Electromagnetic waves are well know by physicists and are ruled by the \sphinxstylestrong{4 Maxwell equations} which give you the solution for \sphinxstyleemphasis{E}, the electrical field, and \sphinxstyleemphasis{B}, the magnetic field, in space but also in time.

\sphinxAtStartPar
We don’t care about the time here, because the signal period is really short so our internet quality will not change with time.
Without time, we’re looking for stationaries solutions, and the Maxwell equations can be simplified to one equation, the Helmholtz one :
\begin{equation*}
\begin{split}\nabla^{2}E + \frac{k^{2}}{n^{2}}E = 0\end{split}
\end{equation*}
\sphinxAtStartPar
Where \sphinxstyleemphasis{k} is the angular wavenumber of the wifi signal, and \sphinxstyleemphasis{n} the refractive index of the material the wave is in.

\sphinxAtStartPar
Indeed, the main point of this study is the impact of \sphinxstylestrong{walls} on the signal’s power, where the \sphinxstyleemphasis{n} is different from air (where it is 1).
In walls, the refractive index is a complex number in which the two parts have a physic interpretation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{real part} defines the \sphinxstylestrong{reflexion} of the wall (the amount of signal that doesn’t pass).

\item {} 
\sphinxAtStartPar
The \sphinxstyleemphasis{imaginary part} defines the \sphinxstylestrong{absorption} of the wall (the amount that disappears).

\end{itemize}

\sphinxAtStartPar
The wifi hotspot (simulated by a simple circle) will be the boundary condition, with a non null value for our electrical field.


\subsection{Coding}
\label{\detokenize{tutorials/wifiPropagation:coding}}

\subsubsection{The domain}
\label{\detokenize{tutorials/wifiPropagation:the-domain}}
\sphinxAtStartPar
In order to create the domain of experimentation, we need to create \sphinxcode{\sphinxupquote{border}} objects, like this :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{a00}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a10}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a20}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a30}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a31}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b00}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b10}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{o}{+}\PYG{n+nf}{d}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{o}{+}\PYG{n}{e}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b20}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{o}{+}\PYG{n}{e}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b30}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{p}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{q}\PYG{o}{+}\PYG{n}{e}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=}\PYG{l+m+mi}{1} \PYG{p}{,} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c00}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{+}\PYG{n}{j}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c10}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{+}\PYG{n}{j}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{o}{+}\PYG{n}{u}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c20}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{+}\PYG{n}{j}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{o}{+}\PYG{n}{u}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c30}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{s}\PYG{o}{+}\PYG{n}{u}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Let’s create a mesh}
\label{\detokenize{tutorials/wifiPropagation:lets-create-a-mesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{13}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Sh} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a00}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a10}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a20}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a30}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{a01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a11}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a21}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a31}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{b00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{c00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
So we are creating a \sphinxcode{\sphinxupquote{mesh}}, and plotting it :

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{mesh}.png}
\caption{Mesh}\label{\detokenize{tutorials/wifiPropagation:id2}}\end{figure}

\sphinxAtStartPar
There is currently no wifi hotspot, and as we want to resolve the equation for a multiple number of position next to the left wall, let’s do a \sphinxcode{\sphinxupquote{for}} loop:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{bx}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{bx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{bx} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;} \PYG{n}{bx}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{border} \PYG{n}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bx}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a00}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a10}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a20}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a30}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{a01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a11}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a21}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a31}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{b00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{c00}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c10}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c20}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c30}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The border \sphinxcode{\sphinxupquote{C}} is our hotspot and as you can see a simple circle.
\sphinxcode{\sphinxupquote{Th}} is our final mesh, with all borders and the hotspot.
Let’s resolve this equation !

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{wall}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{|}\PYG{o}{|} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mf}{20.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{|}\PYG{o}{|} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{=}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{30.5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
   \PYG{k}{else} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{p}{;}

\PYG{n+nf}{randinit}\PYG{p}{(}\PYG{l+m+mi}{900}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{wallreflexion} \PYG{o}{=} \PYG{n+nf}{randreal1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{wallabsorption} \PYG{o}{=} \PYG{n+nf}{randreal1}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{n}{i}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Reflexion of walls min/max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{wallreflexion}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{wallreflexion}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Absorption of walls min/max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{wallabsorption}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}   \PYG{n}{wallabsorption}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{muwave}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{w}\PYG{p}{)} \PYG{o}{=}
    \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{k}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{p}{(}\PYG{n}{wallreflexion}\PYG{o}{+}\PYG{n}{wallabsorption}\PYG{p}{)}\PYG{o}{*}\PYG{n}{wall}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{muwave}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{vm} \PYG{o}{=} \PYG{n+nf}{log}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vm}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{65}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A bit of understanding here :
\begin{itemize}
\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{fespace}} keyword defines a finite elements space, no need to know more here.

\item {} 
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{wall}} return 0 if in air and 1 if in a wall (x and y are global variables).

\item {} 
\sphinxAtStartPar
For this example, random numbers are used for the reflexion and the absorption.

\item {} 
\sphinxAtStartPar
The problem is defined with \sphinxcode{\sphinxupquote{problem}} and we solve it by calling it.

\end{itemize}

\sphinxAtStartPar
Finally, I plotted the \(\log\) of the module of the solution \sphinxcode{\sphinxupquote{v}} to see the signal’s power, and here we are :

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{point1}.png}
\caption{Solution}\label{\detokenize{tutorials/wifiPropagation:id3}}\end{figure}

\sphinxAtStartPar
Beautiful isn’t it ? This is the first position for the hotspot, but there are 6 others, and the electrical field is evolving depending on the position.
You can see the other positions here :

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point2}.png}
\caption{Point 2}\label{\detokenize{tutorials/wifiPropagation:id4}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point3}.png}
\caption{Point 3}\label{\detokenize{tutorials/wifiPropagation:id5}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point4}.png}
\caption{Point 4}\label{\detokenize{tutorials/wifiPropagation:id6}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point5}.png}
\caption{Point 5}\label{\detokenize{tutorials/wifiPropagation:id7}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point6}.png}
\caption{Point 6}\label{\detokenize{tutorials/wifiPropagation:id8}}\end{subfigure}
\begin{subfigure}[t]{0.32\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{point7}.png}
\caption{Point 7}\label{\detokenize{tutorials/wifiPropagation:id9}}\end{subfigure}
\caption{Wifi propagation}\phantomsection\label{\detokenize{tutorials/wifiPropagation:WifiPropagation}}

\end{figure}



\section{Plotting in Matlab and Octave}
\label{\detokenize{tutorials/matlabOctavePlot:plotting-in-matlab-and-octave}}\label{\detokenize{tutorials/matlabOctavePlot:tutorialmatlaboctaveplot}}\label{\detokenize{tutorials/matlabOctavePlot::doc}}

\subsection{Overview}
\label{\detokenize{tutorials/matlabOctavePlot:overview}}
\sphinxAtStartPar
In order to create a plot of a \sphinxstylestrong{FreeFEM} simulation in \sphinxhref{https://www.mathworks.com/}{Matlab©} or \sphinxhref{https://www.gnu.org/software/octave/}{Octave} two steps are necessary:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The mesh, the finite element space connectivity and the simulation data must be exported into files

\item {} 
\sphinxAtStartPar
The files must be imported into the Matlab / Octave workspace. Then the data can be visualized with the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib} library

\end{itemize}

\sphinxAtStartPar
The steps are explained in more detail below using the example of a stripline capacitor.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Finite element variables must be in P1 or P2. The simulation data can be 2D or 3D.
\end{sphinxadmonition}


\subsection{2D Problem}
\label{\detokenize{tutorials/matlabOctavePlot:d-problem}}
\sphinxAtStartPar
Consider a stripline capacitor problem which is also shown in \hyperref[\detokenize{tutorials/matlabOctavePlot:figmatlabboundaryplot}]{Fig.\@ \ref{\detokenize{tutorials/matlabOctavePlot:figmatlabboundaryplot}}}. On the two boundaries (the electrodes) \(C_{A}\), \(C_{K}\) a Dirichlet condition and on the enclosure \(C_{B}\) a Neumann condition is set. The electrostatic potential \(u\) between the two electrodes is given by the Laplace equation
\begin{equation*}
\begin{split}\Delta u(x,y) = 0\end{split}
\end{equation*}
\sphinxAtStartPar
and the electrostatic field \(\mathbf{E}\) is calculated by
\begin{equation*}
\begin{split}\mathbf{E} = -\nabla u\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{CA}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{CK}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{CB}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{w2}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{d2}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{bottomA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{,}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{rightA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{d2}\PYG{p}{,}\PYG{n}{d2}\PYG{o}{+}\PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{topA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{d2}\PYG{o}{+}\PYG{n}{h}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{leftA}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{d2}\PYG{o}{+}\PYG{n}{h}\PYG{p}{,}\PYG{n}{d2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CA}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{bottomK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{,}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{rightK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{topK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{w2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{leftK}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{d2}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CK}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{enclosure}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{CB}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{enclosure}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}
             \PYG{n}{bottomA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{topA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{rightA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{leftA}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}
             \PYG{n}{bottomK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{topK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{rightK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{leftK}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{u0}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Laplace}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{,}\PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)} \PYG{o}{=}
          \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{CA}\PYG{p}{,}\PYG{n}{u}\PYG{o}{=}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{CK}\PYG{p}{,}\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{error}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Laplace}\PYG{p}{;}
   \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error}\PYG{o}{=}\PYG{n}{error}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{Laplace}\PYG{p}{;}

\PYG{n}{Vh} \PYG{n}{Ex}\PYG{p}{,} \PYG{n}{Ey}\PYG{p}{;}
\PYG{n}{Ex} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ey} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Exporting Data}
\label{\detokenize{tutorials/matlabOctavePlot:exporting-data}}
\sphinxAtStartPar
The mesh is stored with the \sphinxstylestrong{FreeFEM} command {\hyperref[\detokenize{documentation/mesh-generation:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{savemesh()}}}}, while the connectivity of the finite element space and the simulation data are stored with the macro commands \sphinxcode{\sphinxupquote{ffSaveVh()}} and \sphinxcode{\sphinxupquote{ffSaveData()}}. These two commands are located in the \sphinxcode{\sphinxupquote{ffmatlib.idp}} file which is included in the \sphinxcode{\sphinxupquote{ffmatlib}}. Therefore, to export the stripline capacitor data the following statement sequence must be added to the \sphinxstylestrong{FreeFEM} code:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmatlib.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{//Save mesh}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Save finite element space connectivity}
\PYG{n}{ffSaveVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor\PYGZus{}vh.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Save some scalar data}
\PYG{n}{ffSaveData}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor\PYGZus{}potential.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Save a 2D vector field}
\PYG{n}{ffSaveData2}\PYG{p}{(}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{capacitor\PYGZus{}field.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Importing Data}
\label{\detokenize{tutorials/matlabOctavePlot:importing-data}}
\sphinxAtStartPar
The mesh file can be loaded into the Matlab / Octave workspace using the \sphinxcode{\sphinxupquote{ffreadmesh()}} command. A mesh file consists of {\hyperref[\detokenize{documentation/mesh-generation:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{three main sections}}}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The mesh points as nodal coordinates

\item {} 
\sphinxAtStartPar
A list of boundary edges including boundary labels

\item {} 
\sphinxAtStartPar
List of triangles defining the mesh in terms of connectivity

\end{enumerate}

\sphinxAtStartPar
The three data sections mentioned are returned in the variables \sphinxcode{\sphinxupquote{p}}, \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{t}}. The finite element space connectivity and the simulation data can be loaded using the \sphinxcode{\sphinxupquote{ffreaddata()}} command. Therefore, to load the example data the following statement sequence must be executed in Matlab / Octave:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c}{\PYGZpc{}Add ffmatlib to the search path}
\PYG{n}{addpath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add here the link to the ffmatlib\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load the mesh}
\PYG{p}{[}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{nv}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{,}\PYG{n}{nt}\PYG{p}{,}\PYG{n}{labels}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreadmesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load the finite element space connectivity}
\PYG{n}{vh}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor\PYGZus{}vh.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load scalar data}
\PYG{n}{u}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor\PYGZus{}potential.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}Load 2D vector field data}
\PYG{p}{[}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{capacitor\PYGZus{}field.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{2D Plot Examples}
\label{\detokenize{tutorials/matlabOctavePlot:d-plot-examples}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffpdeplot()}} is a plot solution for creating patch, contour, quiver, mesh, border, and region plots of 2D geometries. The basic syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{[}\PYG{n}{handles}\PYG{p}{,}\PYG{n}{varargout}\PYG{p}{]} \PYG{p}{=} \PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{varargin}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{varargin}} specifies parameter name / value pairs to control the plot behaviour.
A table showing all options can be found in the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib} documentation. A small selection of possible plot commands is given as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Plot of the boundary and the mesh:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_boundary_mesh_500x400}.png}
\caption{Boundary and Mesh}\label{\detokenize{tutorials/matlabOctavePlot:figmatlabboundaryplot}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Patch plot (2D map or density plot) including mesh and boundary:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_patch_500x400}.png}
\caption{Patch Plot with Mesh}\label{\detokenize{tutorials/matlabOctavePlot:figmatlabpatchplot}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
3D surf plot:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ZStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{continuous\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{lighting} \PYG{n}{gouraud}\PYG{p}{;}
\PYG{n}{view}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{47}\PYG{p}{,}\PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{camlight}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{headlight\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_surf_500x400}.png}
\caption{3D Surf Plot}\label{\detokenize{tutorials/matlabOctavePlot:figmatlabsurf}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Contour (isovalue) and quiver (vector field) plot:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{YLim\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Contour\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CColor\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{CGridParam\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{150}\PYG{p}{,} \PYG{l+m+mi}{150}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ColorBar\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,} \PYG{c}{...}
          \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FlowData\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Ex}\PYG{p}{,}\PYG{n}{Ey}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FGridParam\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{24}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor_contour_quiver_500x400}.png}
\caption{Contour and Quiver Plot}\label{\detokenize{tutorials/matlabOctavePlot:figmatlabcontour}}\end{figure}

\sphinxAtStartPar
\sphinxstylestrong{Download run through example:}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Matlab / Octave file}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FreeFEM script}}


\subsection{3D Plot Examples}
\label{\detokenize{tutorials/matlabOctavePlot:id1}}
\sphinxAtStartPar
3D problems are handled by the \sphinxcode{\sphinxupquote{ffpdeplot3D()}} command, which works similarly to the \sphinxcode{\sphinxupquote{ffpdeplot()}} command. In particular in three\sphinxhyphen{}dimensions cross sections of the solution can be created. The following example shows a cross\sphinxhyphen{}sectional problem of a three\sphinxhyphen{}dimensional parallel plate capacitor.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{capacitor3d_slice_500x400}.png}
\caption{Slice on a 3D Parallel Plate Capacitor}\label{\detokenize{tutorials/matlabOctavePlot:figmatlabslice}}\end{figure}

\sphinxAtStartPar
\sphinxstylestrong{Download run through example:}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Matlab / Octave file}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FreeFEM script}}


\subsection{References}
\label{\detokenize{tutorials/matlabOctavePlot:references}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.gnu.org/software/octave/}{Octave}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.mathworks.com/}{Matlab}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib}

\end{itemize}


\chapter{Documentation}
\label{\detokenize{documentation/index:documentation}}\label{\detokenize{documentation/index::doc}}
\sphinxAtStartPar
The fruit of a long maturing process, \sphinxstylestrong{freefem}, in its last avatar, \sphinxstylestrong{FreeFEM} , is a high level integrated development environment (IDE) for numerically solving partial differential equations (PDE) in dimension 1,2 3 and surface and line 3D.
It is the ideal tool for teaching the finite element method but it is also perfect for research to quickly test new ideas or multi\sphinxhyphen{}physics and complex applications.

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} has an advanced automatic mesh generator, capable of a posteriori mesh adaptation; it has a general purpose elliptic solver interfaced with fast algorithms, such as the multi\sphinxhyphen{}frontal method UMFPACK, SuperLU, MUMPS.
Hyperbolic and parabolic problems are solved by iterative algorithms prescribed by the user with the high level language of \sphinxstylestrong{FreeFEM}.
It has several triangular finite elements, including discontinuous elements.
Everything is there in \sphinxstylestrong{FreeFEM} to prepare research quality reports with online color display, zooming and other features as well as postscript printouts.

\sphinxAtStartPar
This manual is meant for students at a Masters level, for researchers at any level, and for engineers (including financial engineering) with some understanding of variational methods for partial differential equations.

\sphinxAtStartPar
Introduction

\sphinxAtStartPar
A partial differential equation is a relation between a function of several variables and its (partial) derivatives.
Many problems in physics, engineering, mathematics and even banking are modeled by one or several partial differential equations.

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} is a software to solve these equations numerically.
As its name implies, it is a free software (see the copyrights for full detail) based on the Finite Element Method; it is not a package, it is an integrated product with its own high level programming language.
This software runs on all UNIX OS (with g++ 3.3 or later, and OpenGL), on Window XP, Vista and 7, 8, 10 and on MacOS 10 intel.

\sphinxAtStartPar
Moreover \sphinxstylestrong{FreeFEM} is highly adaptive.
Many phenomena involve several coupled systems.
Fluid\sphinxhyphen{}structure interactions, Lorentz forces for aluminum casting and ocean\sphinxhyphen{}atmosphere problems are three such systems.
These require different finite element approximations and polynomial degrees, possibly on different meshes.
Some algorithms like the Schwarz’ domain decomposition method also requires data interpolation on multiple meshes within one program.
\sphinxstylestrong{FreeFEM} can handle these difficulties, i.e. arbitrary finite element spaces on arbitrary unstructured and adapted bi\sphinxhyphen{}dimensional meshes.

\sphinxAtStartPar
The characteristics of \sphinxstylestrong{FreeFEM} are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Problem description (real or complex valued) by their variational formulations, with access to the internal vectors and matrices if needed.

\item {} 
\sphinxAtStartPar
Multi\sphinxhyphen{}variables, multi\sphinxhyphen{}equations, bi\sphinxhyphen{}dimensional and three\sphinxhyphen{}dimensional static or time dependent, linear or nonlinear coupled systems; however the user is required to describe the iterative procedures which reduce the problem to a set of linear problems.

\item {} 
\sphinxAtStartPar
Easy geometric input by analytic description of boundaries by pieces; however this part is not a CAD system; for instance when two boundaries intersect, the user must specify the intersection points.

\item {} 
\sphinxAtStartPar
Automatic mesh generator, based on the Delaunay\sphinxhyphen{}Voronoi algorithm; the inner point density is proportional to the density of points on the boundaries \sphinxcite{bibliography:george1996}.

\item {} 
\sphinxAtStartPar
Metric\sphinxhyphen{}based anisotropic mesh adaptation.
The metric can be computed automatically from the Hessian of any \sphinxstylestrong{FreeFEM} function \sphinxcite{bibliography:hecht1998}.

\item {} 
\sphinxAtStartPar
High level user friendly typed input language with an algebra of analytic and finite element functions.

\item {} 
\sphinxAtStartPar
Multiple finite element meshes within one application with automatic interpolation of data on different meshes and possible storage of the interpolation matrices.

\item {} 
\sphinxAtStartPar
A large variety of triangular finite elements: linear, quadratic Lagrangian elements and more, discontinuous P1 and Raviart\sphinxhyphen{}Thomas elements, elements of a non\sphinxhyphen{}scalar type, the mini\sphinxhyphen{}element,… (but no quadrangles).

\item {} 
\sphinxAtStartPar
Tools to define discontinuous Galerkin finite element formulations P0, P1dc, P2dc and keywords: jump, mean, intalledges.

\item {} 
\sphinxAtStartPar
A large variety of linear direct and iterative solvers (LU, Cholesky, Crout, CG, GMRES, UMFPACK, MUMPS, SuperLU, …) and eigenvalue and eigenvector solvers (ARPARK) .

\item {} 
\sphinxAtStartPar
Near optimal execution speed (compared with compiled \sphinxcode{\sphinxupquote{C++}} implementations programmed directly).

\item {} 
\sphinxAtStartPar
Online graphics, generation of ,.txt,.eps,.gnu, mesh files for further manipulations of input and output data.

\item {} 
\sphinxAtStartPar
Many examples and tutorials: elliptic, parabolic and hyperbolic problems, Navier\sphinxhyphen{}Stokes flows, elasticity, fluid structure interactions, Schwarz’s domain decomposition method, eigenvalue problem, residual error indicator, …

\item {} 
\sphinxAtStartPar
A parallel version using MPI

\end{itemize}


\section{Notations}
\label{\detokenize{documentation/notations:notations}}\label{\detokenize{documentation/notations::doc}}
\sphinxAtStartPar
Here mathematical expressions and corresponding \sphinxstylestrong{FreeFEM} commands are explained.


\subsection{Generalities}
\label{\detokenize{documentation/notations:generalities}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(\delta_{ij}\){]} Kronecker delta (\(0\) if \(i\neq j\), 1 if \(i=j\) for integers \(i,j\))

\item {} 
\sphinxAtStartPar
{[}\(\forall\){]} for all

\item {} 
\sphinxAtStartPar
{[}\(\exists\){]} there exists

\item {} 
\sphinxAtStartPar
{[}i.e.{]} that is

\item {} 
\sphinxAtStartPar
{[}PDE{]} partial differential equation (with boundary conditions)

\item {} 
\sphinxAtStartPar
{[}\(\emptyset\){]} the empty set

\item {} 
\sphinxAtStartPar
{[}\(\mathbb{N}\){]} the set of integers (\(a\in \mathbb{N}\Leftrightarrow\) \sphinxcode{\sphinxupquote{int a}}), \sphinxcode{\sphinxupquote{int}} means \sphinxcode{\sphinxupquote{long int}} inside \sphinxstylestrong{FreeFEM}

\item {} 
\sphinxAtStartPar
{[}\(\mathbb{R}\){]} the set of real numbers (\(a\in \mathbb{R}\Leftrightarrow\) \sphinxcode{\sphinxupquote{real a}}), \sphinxcode{\sphinxupquote{double}} inside \sphinxstylestrong{FreeFEM}

\item {} 
\sphinxAtStartPar
{[}\(\mathbb{C}\){]} the set of complex numbers (\(a\in \mathbb{C}\Leftrightarrow\) \sphinxcode{\sphinxupquote{complex a}}), \sphinxcode{\sphinxupquote{complex\textless{}double\textgreater{}}}

\item {} 
\sphinxAtStartPar
{[}\(\mathbb{R}^d\){]} \(d\)\sphinxhyphen{}dimensional Euclidean space

\end{itemize}


\subsection{Sets, Mappings, Matrices, Vectors}
\label{\detokenize{documentation/notations:sets-mappings-matrices-vectors}}
\sphinxAtStartPar
Let \(E,\, F,\, G\) be three sets and \(A\) the subset of \(E\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(\{x\in E|\; P\}\){]} the subset of \(E\) consisting of the elements possessing the property \(P\)

\item {} 
\sphinxAtStartPar
{[}\(E\cup F\){]} the set of elements belonging to \(E\) or \(F\)

\item {} 
\sphinxAtStartPar
{[}\(E\cap F\){]} the set of elements belonging to \(E\) and \(F\)

\item {} 
\sphinxAtStartPar
{[}\(E\setminus A\){]} the set \(\{x\in E|\; x\not\in A\}\)

\item {} 
\sphinxAtStartPar
{[}\(E+F\){]} \(E\cup F\) with \(E\cap F=\emptyset\)

\item {} 
\sphinxAtStartPar
{[}\(E\times F\){]} the Cartesian product of \(E\) and \(F\)

\item {} 
\sphinxAtStartPar
{[}\(E^n\){]} the \(n\)\sphinxhyphen{}th power of \(E\) (\(E^2=E\times E\), \(E^n=E\times E^{n-1}\))

\item {} 
\sphinxAtStartPar
{[}\(f:\; E\to F\){]} the mapping form \(E\) into \(F\), i.e., \(E\ni x\mapsto f(x)\in F\)

\item {} 
\sphinxAtStartPar
{[}\(I_E\) or \(I\){]} the identity mapping in \(E\),i.e., \(I(x)=x\quad \forall x\in E\)

\item {} 
\sphinxAtStartPar
{[}\(f\circ g\){]} for \(f:\; F\to G\) and \(g:\; E\to F\), \(E\ni x\mapsto (f\circ g)(x)=f(g(x))\in G\) (see {\hyperref[\detokenize{references/types:typeelementaryfunctions}]{\sphinxcrossref{\DUrole{std,std-ref}{Elementary function}}}})

\item {} 
\sphinxAtStartPar
{[}\(f|_A\){]} the restriction of \(f:\; E\to F\) to the subset \(A\) of \(E\)

\item {} 
\sphinxAtStartPar
{[}\(\{a_k\}\){]} column vector with components \(a_k\)

\item {} 
\sphinxAtStartPar
{[}\((a_k)\){]} row vector with components \(a_k\)

\item {} 
\sphinxAtStartPar
{[}\((a_{k})^T\){]} denotes the transpose of a matrix \((a_{k})\), and is \(\{a_{k}\}\)

\item {} 
\sphinxAtStartPar
{[}\(\{a_{ij}\}\){]} matrix with components \(a_{ij}\), and \((a_{ij})^T=(a_{ji})\)

\end{itemize}


\subsection{Numbers}
\label{\detokenize{documentation/notations:numbers}}
\sphinxAtStartPar
For two real numbers \(a,b\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\([a,b]\) is the interval \(\{x\in \mathbb{R}|\; a\le x\le b\}\)

\item {} 
\sphinxAtStartPar
\(]a,b]\) is the interval \(\{x\in \mathbb{R}|\; a< x\le b\}\)

\item {} 
\sphinxAtStartPar
\([a,b[\) is the interval \(\{x\in \mathbb{R}|\; a\le x< b\}\)

\item {} 
\sphinxAtStartPar
\(]a,b[\) is the interval \(\{x\in \mathbb{R}|\; a< x< b\}\)

\end{itemize}


\subsection{Differential Calculus}
\label{\detokenize{documentation/notations:differential-calculus}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(\partial f/\partial x\){]} the partial derivative of \(f:\mathbb{R}^d\to \mathbb{R}\) with respect to \(x\) (\sphinxcode{\sphinxupquote{dx(f)}})

\item {} 
\sphinxAtStartPar
{[}\(\nabla f\){]} the gradient of \(f:\Omega\to \mathbb{R}\),i.e., \(\nabla f=(\partial f/\partial x,\, \partial f/\partial y)\)

\item {} 
\sphinxAtStartPar
{[}\(\text{div}(\mathbf{f})\) or \(\nabla.\mathbf{f}\){]} the divergence of \(\mathbf{f}:\Omega\to \mathbb{R}^d\), i.e., \(\text{div}(\mathbf{f})=\partial f_1/\partial x+\partial f_2/\partial y\)

\item {} 
\sphinxAtStartPar
{[}\(\Delta f\){]} the Laplacian of \(f:\; \Omega\to \mathbb{R}\), i.e., \(\Delta f=\partial^2f/\partial x^2+\partial^2 f/\partial y^2\)

\end{itemize}


\subsection{Meshes}
\label{\detokenize{documentation/notations:meshes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(\Omega\){]} usually denotes a domain on which PDE is defined

\item {} 
\sphinxAtStartPar
{[}\(\Gamma\){]} denotes the boundary of \(\Omega\),i.e., \(\Gamma=\partial\Omega\) (keyword \sphinxcode{\sphinxupquote{border}}, see {\hyperref[\detokenize{documentation/mesh-generation:meshborder}]{\sphinxcrossref{\DUrole{std,std-ref}{Border}}}})

\item {} 
\sphinxAtStartPar
{[}\(\mathcal{T}_h\){]} the triangulation of \(\Omega\), i.e., the set of triangles \(T_k\), where \(h\) stands for mesh size (keyword \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{buildmesh}}, see {\hyperref[\detokenize{documentation/mesh-generation:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}})

\item {} 
\sphinxAtStartPar
{[}\(n_t\){]} the number of triangles in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nt}})

\item {} 
\sphinxAtStartPar
{[}\(\Omega_h\){]} denotes the approximated domain \(\Omega_h=\cup_{k=1}^{n_t}T_k\) of \(\Omega\).
If \(\Omega\) is polygonal domain, then it will be \(\Omega=\Omega_h\)

\item {} 
\sphinxAtStartPar
{[}\(\Gamma_h\){]} the boundary of \(\Omega_h\)

\item {} 
\sphinxAtStartPar
{[}\(n_v\){]} the number of vertices in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nv}})

\item {} 
\sphinxAtStartPar
{[}\(n_{be}\){]} the number of boundary element in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.nbe}})

\item {} 
\sphinxAtStartPar
{[}\(|\Omega_h|\){]} the measure (area or volume) in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.measure}})

\item {} 
\sphinxAtStartPar
{[}\(|\partial \Omega_h|\){]} the measure of the border (length or area) in \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.bordermeasure}})

\item {} 
\sphinxAtStartPar
{[}\(h_{min}\){]} the minimum edge size of \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.hmin}})

\item {} 
\sphinxAtStartPar
{[}\(h_{max}\){]} the maximum edge size of \(\mathcal{T}_h\) (get by \sphinxcode{\sphinxupquote{Th.hmax}})

\item {} 
\sphinxAtStartPar
{[}{[}\(q^iq^j\){]}{]} the segment connecting \(q^i\) and \(q^j\)

\item {} 
\sphinxAtStartPar
{[}\(q^{k_1},q^{k_2},q^{k_3}\){]} the vertices of a triangle \(T_k\) with anti\sphinxhyphen{}clock direction (get the coordinate of \(q^{k_j}\) by \sphinxcode{\sphinxupquote{(Th{[}k\sphinxhyphen{}1{]}{[}j\sphinxhyphen{}1{]}.x, Th{[}k\sphinxhyphen{}1{]}{[}j\sphinxhyphen{}1{]}.y)}})

\item {} 
\sphinxAtStartPar
{[}\(I_{\Omega}\){]} the set \(\{i\in \mathbb{N}|\; q^i\not\in \Gamma_h\}\)

\end{itemize}


\subsection{Functional Spaces}
\label{\detokenize{documentation/notations:functional-spaces}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(L^2(\Omega)\){]} the set \(\displaystyle{\left\{w(x,y)\left|\; \int_{\Omega}|w(x,y)|^2\text{d} x\text{d} y<\infty\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{norm:}\; \| w\|_{0,\Omega}&=\left(\int_{\Omega}|w(x,y)|^2\text{d} x\text{d} y\right)^{1/2}\\
\textrm{scalar product:}\; (v,w)&=\int_{\Omega}vw\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(H^1(\Omega)\){]} the set \(\displaystyle{\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}\left(|\partial w/\partial x|^2+|\partial w/\partial y|^2\right)\text{d} x\text{d} y <\infty\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{norm:}\; \| w\|_{1,\Omega}=\left(\| w\|_{0,\Omega}^2+\|\nabla u\|_{0.\Omega}^2\right)^{1/2}\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(H^m(\Omega)\){]} the set \(\displaystyle{\left\{w\in L^2(\Omega)\left|\; \int_{\Omega}\frac{\partial^{|\alpha|} w}{\partial x^{\alpha_1}\partial y^{\alpha_2}}\in L^2(\Omega)\quad\forall \alpha=(\alpha_1,\alpha_2)\in \mathbb{N}^2,\, |\alpha|=\alpha_1+\alpha_2\right.\right\}}\)

\end{itemize}
\begin{quote}
\begin{equation*}
\begin{split}\textrm{scalar product:}\; (v,w)_{1,\Omega}=
\sum_{|\alpha|\le m}\int_{\Omega} D^{\alpha}v D^{\alpha}w\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(H^1_0(\Omega)\){]} the set \(\left\{w\in H^1(\Omega)\left|\; u=0\quad \textrm{on }\Gamma\right.\right\}\)

\sphinxAtStartPar
{[}\(L^2(\Omega)^2\){]} denotes \(L^2(\Omega)\times L^2(\Omega)\), and also \(H^1(\Omega)^2=H^1(\Omega)\times H^1(\Omega)\)

\end{itemize}


\subsection{Finite Element Spaces}
\label{\detokenize{documentation/notations:finite-element-spaces}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{[}\(V_h\){]} denotes the finite element space created by \sphinxcode{\sphinxupquote{fespace Vh(Th, *)}} in \sphinxstylestrong{FreeFEM} (see {\hyperref[\detokenize{documentation/finite-element:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Elements}}}} for \sphinxcode{\sphinxupquote{*}})

\item {} 
\sphinxAtStartPar
{[}\(\Pi_h f\){]} the projection of the function \(f\) into \(V_h\) (\sphinxcode{\sphinxupquote{func f=x\textasciicircum{}2*y\textasciicircum{}3; Vh v = f;}}) means \(v = Pi_h (f) * [\{v\}]\) for FE\sphinxhyphen{}function \(v\) in \(V_h\) means the column vector \((v_1,\cdots,v_M)^T\) if \(v=v_1\phi_1+\cdots+v_M\phi_M\), which is shown by \sphinxcode{\sphinxupquote{fespace Vh(Th, P2); Vh v; cout \textless{}\textless{} v{[}{]} \textless{}\textless{} endl;}}

\end{itemize}


\section{Mesh Generation}
\label{\detokenize{documentation/mesh-generation:mesh-generation}}\label{\detokenize{documentation/mesh-generation:meshgeneration}}\label{\detokenize{documentation/mesh-generation::doc}}
\sphinxAtStartPar
In this section, operators and tools on meshes are presented.

\sphinxAtStartPar
FreeFEM type for mesh variable:
\begin{itemize}
\item {} 
\sphinxAtStartPar
1D mesh: \sphinxcode{\sphinxupquote{meshL}}

\item {} 
\sphinxAtStartPar
2D mesh: \sphinxcode{\sphinxupquote{mesh}}

\item {} 
\sphinxAtStartPar
3D volume mesh: \sphinxcode{\sphinxupquote{mesh3}}

\item {} \begin{description}
\item[{3D border meshes}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
3D surface \sphinxcode{\sphinxupquote{meshS}}

\item {} 
\sphinxAtStartPar
3D curve \sphinxcode{\sphinxupquote{meshL}}

\end{itemize}

\end{description}

\end{itemize}

\sphinxAtStartPar
Through this presentation, the principal commands for the mesh generation and links between \sphinxcode{\sphinxupquote{mesh}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{mesh3}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{meshS}} \sphinxhyphen{} \sphinxcode{\sphinxupquote{meshL}} are described.


\subsection{\sphinxstylestrong{The type mesh in 2 dimension}}
\label{\detokenize{documentation/mesh-generation:the-type-mesh-in-2-dimension}}\label{\detokenize{documentation/mesh-generation:mesh2d}}

\subsubsection{Commands for 2d mesh Generation}
\label{\detokenize{documentation/mesh-generation:commands-for-2d-mesh-generation}}
\sphinxAtStartPar
The \sphinxstylestrong{FreeFEM} type to define a 2d mesh object is \sphinxcode{\sphinxupquote{mesh}}.


\paragraph{The command \sphinxstyleemphasis{square}}
\label{\detokenize{documentation/mesh-generation:the-command-square}}\label{\detokenize{documentation/mesh-generation:meshsquare}}
\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{square}} triangulates the unit square.

\sphinxAtStartPar
The following generates a \(4 \times 5\) grid in the unit square \([0,1]^2\). The labels of the boundaries are shown in \hyperref[\detokenize{documentation/mesh-generation:figboundarylabels}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:figboundarylabels}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Square}.png}
\caption{Boundary labels of the mesh by \sphinxcode{\sphinxupquote{square(10,10)}}}\label{\detokenize{documentation/mesh-generation:figboundarylabels}}\end{figure}

\sphinxAtStartPar
To construct a \(n\times m\) grid in the rectangle \([x_0,x_1]\times [y_0,y_1]\), proceed as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{1.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Adding the named parameter \sphinxcode{\sphinxupquote{flags=icase}} with icase:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
\sphinxAtStartPar
will produce a mesh where all quads are split with diagonal \(x-y=constant\)

\item {} 
\sphinxAtStartPar
will produce a \sphinxstyleemphasis{Union Jack flag} type of mesh

\item {} 
\sphinxAtStartPar
will produce a mesh where all quads are split with diagonal \(x+y=constant\)

\item {} 
\sphinxAtStartPar
same as in case 0, except two corners where the triangles are the same as case 2, to avoid having 3 vertices on the boundary

\item {} 
\sphinxAtStartPar
same as in case 2, except two corners where the triangles are the same as case 0, to avoid having 3 vertices on the boundary

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{icase}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Adding the named parameter \sphinxcode{\sphinxupquote{label=labs}} will
change the 4 default label numbers to \sphinxcode{\sphinxupquote{labs{[}i\sphinxhyphen{}1{]}}}, for
example \sphinxcode{\sphinxupquote{int{[}int{]} labs={[}11, 12, 13, 14{]}}}, and adding the
named parameter \sphinxcode{\sphinxupquote{region=10}} will change the region number
to \(10\), for instance (v 3.8).

\sphinxAtStartPar
To see all of these flags at work, check {\hyperref[\detokenize{examples/mesh-generation:examplemeshsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{Square mesh example}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square flags = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\paragraph{The command \sphinxstyleemphasis{buildmesh}}
\label{\detokenize{documentation/mesh-generation:the-command-buildmesh}}\label{\detokenize{documentation/mesh-generation:meshborder}}
\sphinxAtStartPar
\sphinxstyleemphasis{mesh building with} \sphinxcode{\sphinxupquote{border}}

\sphinxAtStartPar
Boundaries are defined piecewise by parametrized curves. The pieces can only intersect at their endpoints, but it is possible to join more than two endpoints. This can be used to structure the mesh if an area touches a border and create new regions by dividing larger ones:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
  \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
  \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 1 has region number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 2 has redion number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Borders and mesh are respectively shown in \hyperref[\detokenize{documentation/mesh-generation:figmultipleborder}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:figmultipleborder}}} and \hyperref[\detokenize{documentation/mesh-generation:figgeneratedmesh}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:figgeneratedmesh}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border1}.png}
\caption{Multiple border ends intersect}\label{\detokenize{documentation/mesh-generation:id31}}\label{\detokenize{documentation/mesh-generation:figmultipleborder}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border2}.png}
\caption{Generated mesh}\label{\detokenize{documentation/mesh-generation:id32}}\label{\detokenize{documentation/mesh-generation:figgeneratedmesh}}\end{subfigure}
\caption{Border}\phantomsection\label{\detokenize{documentation/mesh-generation:MeshGeneration_Border}}

\end{figure}


\sphinxAtStartPar
Triangulation keywords assume that the domain is defined as being on the \sphinxstyleemphasis{left} (resp \sphinxstyleemphasis{right}) of its oriented parameterized boundary
\begin{equation*}
\begin{split}\Gamma_j = \{(x,y)\left|\; x=\varphi_x(t),\, y=\varphi_y(t),\, a_j\le t\le b_j\right.\}\end{split}
\end{equation*}
\sphinxAtStartPar
To check the orientation plot \(t\mapsto (\varphi_x(t),\varphi_y(t)),\, t_0\le t\le t_1\). If it is as in \hyperref[\detokenize{documentation/mesh-generation:figborder}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:figborder}}}, then the domain lies on the shaded area, otherwise it lies on the opposite side.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_Border3}.png}
\caption{Orientation of the boundary defined by \((\phi_x(t),\phi_y(t))\)}\label{\detokenize{documentation/mesh-generation:figborder}}\end{figure}

\sphinxAtStartPar
The general expression to define a triangulation with \sphinxcode{\sphinxupquote{buildmesh}} is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Mesh\PYGZus{}Name} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{n}{m1}\PYG{p}{)}\PYG{o}{+}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{o}{+}\PYG{n}{GammaJ}\PYG{p}{(}\PYG{n}{mj}\PYG{p}{)}\PYG{p}{,} \PYG{n}{OptionalParameter}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \(m_j\) are positive or negative numbers to indicate how many vertices should be on \(\Gamma_j,\, \Gamma=\cup_{j=1}^J \Gamma_J\), and the optional parameter (see also {\hyperref[\detokenize{references/functions:referencebuildmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{References}}}}), separated with a comma, can be:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbvx= int}}, to set the maximum number of vertices in the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fixedborder= bool}}, to say if the mesh generator can change the boundary mesh or not (by default the boundary mesh can change; beware that with periodic boundary conditions (see. {\hyperref[\detokenize{documentation/finite-element:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}), it can be dangerous.

\end{itemize}

\sphinxAtStartPar
The orientation of boundaries can be changed by changing the sign of \(m_j\).

\sphinxAtStartPar
The following example shows how to change the orientation. The example generates the unit disk with a small circular hole, and assigns “1” to the unit disk (“2” to the circle inside). The boundary label \sphinxstylestrong{must be non\sphinxhyphen{}zero}, but it can also be omitted.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see a plot of the border mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thwithouthole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithouthole}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thwithouthole.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithhole}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thwithhole.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Notice that the orientation is changed by \sphinxcode{\sphinxupquote{b(\sphinxhyphen{}30)}} in the 5th line. In the 7th line, \sphinxcode{\sphinxupquote{ps="fileName"}} is used to generate a postscript file with identification shown on the figure.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border4}.png}
\caption{Mesh without hole}\label{\detokenize{documentation/mesh-generation:id33}}\label{\detokenize{documentation/mesh-generation:figmeswithouthhole}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Border5}.png}
\caption{Mesh with hole}\label{\detokenize{documentation/mesh-generation:id34}}\label{\detokenize{documentation/mesh-generation:figmeshwithhole}}\end{subfigure}
\caption{Mesh with a hole}\phantomsection\label{\detokenize{documentation/mesh-generation:MeshWithHole}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Borders are evaluated only at the time \sphinxcode{\sphinxupquote{plot}} or \sphinxcode{\sphinxupquote{buildmesh}} is called so the global variables are defined at this time. In this case, since \(r\) is changed between the two border calls, the following code will not work because the first border will be computed with r=0.3:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// bug (a trap) because}
    \PYG{c+c1}{// the two circles have the same radius = :math:`0.3`}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstyleemphasis{mesh building with array of} \sphinxcode{\sphinxupquote{border}}

\sphinxAtStartPar
Sometimes it can be useful to make an array of the border, but unfortunately it is incompatible with the \sphinxstylestrong{FreeFEM} syntax. To bypass this problem, if the number of segments of the discretization \(n\) is an array, we make an implicit loop on all of the values of the array, and the index variable \(i\) of the loop is defined after the parameter definition, like in \sphinxcode{\sphinxupquote{border a(t=0, 2*pi; i)}} …

\sphinxAtStartPar
A first very small example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nn} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//plot 3 circles with 10, 20, 30 points}
\end{sphinxVerbatim}

\sphinxAtStartPar
And a more complex example to define a square with small circles:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{yy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//radius, center of the 4 circles}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{RC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{XC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{,}
          \PYG{n}{YC} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NC} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//list number of :math:`\PYGZbs{}pm` segments of the 4 circles borders}

\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// i is the index variable of the multi border loop}
    \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{t1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{t1} \PYG{o}{+} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{t1} \PYG{o}{+} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{RC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{n}{XC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{RC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{n}{YC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{label} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nn} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//4 border, with 4, 4, 5, 7 segment respectively}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{(}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{k+kp}{bb}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{cc}\PYG{p}{(}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Mesh Connectivity and data}
\label{\detokenize{documentation/mesh-generation:mesh-connectivity-and-data}}
\sphinxAtStartPar
The following example explains methods to obtain mesh information.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Get data of the mesh}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{NbTriangles} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{MeshArea} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{BorderLength} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of triangle(s) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{MeshArea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Border length = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{BorderLength} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Th(i) return the vextex i of Th}
    \PYG{c+c1}{// Th[k] return the triangle k of Th}
    \PYG{c+c1}{// Th[k][i] return the vertex i of the triangle k of Th}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Th[i][j] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{x}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, y= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{y}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, label=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Hack to get vertex coordinates}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{femp1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{femp1} \PYG{n}{Thx}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{Thy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{NbVertices} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of vertices = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbVertices} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NbVertices}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{old method: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Thx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Thy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Method to find information of point (0.55,0.6)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;} \PYG{c+c1}{//the triangle number}
    \PYG{k+kt}{int} \PYG{n}{RLabel} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//the region label}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle number in point (0.55, 0.6): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Region label in point (0.55, 0.6): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{RLabel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Information of triangle}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{TArea} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;} \PYG{c+c1}{//triangle area}
    \PYG{k+kt}{real} \PYG{n}{TRegion} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//triangle region}
    \PYG{k+kt}{real} \PYG{n}{TLabel} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{TNumber}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label}\PYG{p}{;} \PYG{c+c1}{//triangle label, same as region for triangles}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Area of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TArea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Region of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TRegion} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label of triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TLabel} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Hack to get a triangle containing point x, y or region number (old method)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{femp0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{femp0} \PYG{n}{TNumbers}\PYG{p}{;} \PYG{c+c1}{//a P0 function to get triangle numbering}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{TNumbers}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{n}{femp0} \PYG{n}{RNumbers} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//a P0 function to get the region number}

    \PYG{k+kt}{int} \PYG{n}{TNumber} \PYG{o}{=} \PYG{n}{TNumbers}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Number of the triangle containing (0.55, 0,6)}
    \PYG{k+kt}{int} \PYG{n}{RNumber} \PYG{o}{=} \PYG{n}{RNumbers}\PYG{p}{(}\PYG{l+m+mf}{0.55}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Number of the region containing (0.55, 0,6)}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Point (0.55,0,6) :}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Triangle number = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{TNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Region number = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{RNumber} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// New method to get boundary information and mesh adjacent}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{e}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

    \PYG{c+c1}{// Number of boundary elements}
    \PYG{k+kt}{int} \PYG{n}{NbBoundaryElements} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of boundary element = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{NbBoundaryElements} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Boundary element k in \PYGZob{}0, ..., Th.nbe\PYGZcb{}}
    \PYG{k+kt}{int} \PYG{n}{BoundaryElement} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{BoundaryElement} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Vertice l in \PYGZob{}0, 1\PYGZcb{} of boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Vertex} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Vertex }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ of boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Vertex} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Triangle containg the boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Triangle} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Element}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle containing the boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Triangle} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Triangle egde nubmer containing the boundary element k}
    \PYG{k+kt}{int} \PYG{n}{Edge} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{whoinElement}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Triangle edge number containing the boundary element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Edge} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// Adjacent triangle of the triangle k by edge e}
    \PYG{k+kt}{int} \PYG{n}{Adjacent} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//The value of e is changed to the corresponding edge in the adjacent triangle}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Adjacent triangle of the triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ by edge }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Adjacent} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}t}\PYG{l+s}{Corresponding edge = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{c+c1}{// If there is no adjacent triangle by edge e, the same triangle is returned}
    \PYG{c+c1}{//Th[k] == Th[k].adj(e)}
    \PYG{c+c1}{// Else a different triangle is returned}
    \PYG{c+c1}{//Th[k] != Th[k].adj(e)}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{// Print mesh connectivity }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{NbTriangles} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, label }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{label} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbTriangles}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ee}\PYG{p}{;} \PYG{n}{e} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{e}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{c+c1}{//set ee to e, and ee is change by method adj,}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{}=\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ee}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ee}
                 \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, adj: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ee}\PYG{o}{=}\PYG{n}{e}\PYG{p}{)}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{NbBoundaryElements} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{n}{NbBoundaryElements}\PYG{p}{;} \PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , label }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, triangle }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Element}\PYG{p}{)}
             \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{be}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{whoinElement} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{boundingbox}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// bb[0] = xmin, bb[1] = xmax, bb[2] = ymin, bb[3] =ymax}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{boundingbox:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xmin = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, xmax = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ymin = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
         \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ymax = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
// Get data of the mesh
Number of \PYG{n+nv}{triangle} \PYG{o}{=} \PYG{l+m}{8}
Mesh \PYG{n+nv}{area} \PYG{o}{=} \PYG{l+m}{1}
Border \PYG{n+nv}{length} \PYG{o}{=} \PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{0} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{1} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{2} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{2}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{2} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{4} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{4} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{4} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{5} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{3}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{5} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{5} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{6}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{4}
\PYG{l+m}{6} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{6} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{2}
\PYG{l+m}{6} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{7} \PYG{l+m}{0} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{0}
\PYG{l+m}{7} \PYG{l+m}{1} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
\PYG{l+m}{7} \PYG{l+m}{2} \PYGZhy{} Th\PYG{o}{[}i\PYG{o}{]}\PYG{o}{[}j\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{7}, \PYG{n+nv}{x} \PYG{o}{=} \PYG{l+m}{0}.5, \PYG{n+nv}{y}\PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{label}\PYG{o}{=}\PYG{l+m}{3}
// Hack to get vertex coordinates
Number of \PYG{n+nv}{vertices} \PYG{o}{=} \PYG{l+m}{9}
Th\PYG{o}{(}\PYG{l+m}{0}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{1}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{0} \PYG{l+m}{1}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{2}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{0} \PYG{l+m}{2}
   old method: \PYG{l+m}{1} \PYG{l+m}{0}
Th\PYG{o}{(}\PYG{l+m}{3}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{0}.5 \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{4}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{0}.5 \PYG{l+m}{0}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{5}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{0}.5 \PYG{l+m}{2}
   old method: \PYG{l+m}{1} \PYG{l+m}{0}.5
Th\PYG{o}{(}\PYG{l+m}{6}\PYG{o}{)} : \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{4}
   old method: \PYG{l+m}{0} \PYG{l+m}{1}
Th\PYG{o}{(}\PYG{l+m}{7}\PYG{o}{)} : \PYG{l+m}{0}.5 \PYG{l+m}{1} \PYG{l+m}{3}
   old method: \PYG{l+m}{0}.5 \PYG{l+m}{1}
Th\PYG{o}{(}\PYG{l+m}{8}\PYG{o}{)} : \PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{3}
   old method: \PYG{l+m}{1} \PYG{l+m}{1}
// Method to find the information of point \PYG{o}{(}\PYG{l+m}{0}.55,0.6\PYG{o}{)}
Triangle number in point \PYG{o}{(}\PYG{l+m}{0}.55, \PYG{l+m}{0}.6\PYG{o}{)}: \PYG{l+m}{7}
Region label in point \PYG{o}{(}\PYG{l+m}{0}.55, \PYG{l+m}{0}.6\PYG{o}{)}: \PYG{l+m}{0}
// Information of a triangle
Area of triangle \PYG{l+m}{7}: \PYG{l+m}{0}.125
Region of triangle \PYG{l+m}{7}: \PYG{l+m}{0}
Label of triangle \PYG{l+m}{7}: \PYG{l+m}{0}
// Hack to get a triangle containing point x, y or region number \PYG{o}{(}old method\PYG{o}{)}
Point \PYG{o}{(}\PYG{l+m}{0}.55,0,6\PYG{o}{)} :
   Triangle \PYG{n+nv}{number} \PYG{o}{=} \PYG{l+m}{7}
   Region \PYG{n+nv}{number} \PYG{o}{=} \PYG{l+m}{0}
// New method to get boundary information and mesh adjacent
Number of boundary \PYG{n+nv}{element} \PYG{o}{=} \PYG{l+m}{8}
Boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}
Vertex \PYG{l+m}{1} of boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{1}
Triangle containing the boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{0}
Triangle edge number containing the boundary element \PYG{n+nv}{0} \PYG{o}{=} \PYG{l+m}{2}
Adjacent triangle of the triangle \PYG{l+m}{0} by edge \PYG{n+nv}{1} \PYG{o}{=} \PYG{l+m}{1}
   Corresponding \PYG{n+nv}{edge} \PYG{o}{=} \PYG{l+m}{2}
// Print mesh connectivity
\PYG{l+m}{0} : \PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{4}, label \PYG{l+m}{0}
\PYG{l+m}{1} : \PYG{l+m}{0} \PYG{l+m}{4} \PYG{l+m}{3}, label \PYG{l+m}{0}
\PYG{l+m}{2} : \PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{5}, label \PYG{l+m}{0}
\PYG{l+m}{3} : \PYG{l+m}{1} \PYG{l+m}{5} \PYG{l+m}{4}, label \PYG{l+m}{0}
\PYG{l+m}{4} : \PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{7}, label \PYG{l+m}{0}
\PYG{l+m}{5} : \PYG{l+m}{3} \PYG{l+m}{7} \PYG{l+m}{6}, label \PYG{l+m}{0}
\PYG{l+m}{6} : \PYG{l+m}{4} \PYG{l+m}{5} \PYG{l+m}{8}, label \PYG{l+m}{0}
\PYG{l+m}{7} : \PYG{l+m}{4} \PYG{l+m}{8} \PYG{l+m}{7}, label \PYG{l+m}{0}
\PYG{l+m}{0} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{2}, adj: \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{1} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{1}, adj: \PYG{l+m}{0}
\PYG{l+m}{1} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{2} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{2}, adj: \PYG{l+m}{0}
\PYG{l+m}{3} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{0} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{3} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{2} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{4} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{1} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{5} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{5} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{5} \PYG{l+m}{1}, adj: \PYG{l+m}{0}
\PYG{l+m}{5} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{6} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{6} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{2}, adj: \PYG{l+m}{1}
\PYG{l+m}{6} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{3} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{7} \PYG{l+m}{0} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{7} \PYG{l+m}{0}, adj: \PYG{l+m}{0}
\PYG{l+m}{7} \PYG{l+m}{1} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{4} \PYG{l+m}{0}, adj: \PYG{l+m}{1}
\PYG{l+m}{7} \PYG{l+m}{2} \PYGZlt{}\PYG{o}{=}\PYGZgt{} \PYG{l+m}{6} \PYG{l+m}{1}, adj: \PYG{l+m}{1}
\PYG{l+m}{0} : \PYG{l+m}{0} \PYG{l+m}{1} , label \PYG{l+m}{1}, triangle \PYG{l+m}{0} \PYG{l+m}{2}
\PYG{l+m}{1} : \PYG{l+m}{1} \PYG{l+m}{2} , label \PYG{l+m}{1}, triangle \PYG{l+m}{2} \PYG{l+m}{2}
\PYG{l+m}{2} : \PYG{l+m}{2} \PYG{l+m}{5} , label \PYG{l+m}{2}, triangle \PYG{l+m}{2} \PYG{l+m}{0}
\PYG{l+m}{3} : \PYG{l+m}{5} \PYG{l+m}{8} , label \PYG{l+m}{2}, triangle \PYG{l+m}{6} \PYG{l+m}{0}
\PYG{l+m}{4} : \PYG{l+m}{6} \PYG{l+m}{7} , label \PYG{l+m}{3}, triangle \PYG{l+m}{5} \PYG{l+m}{0}
\PYG{l+m}{5} : \PYG{l+m}{7} \PYG{l+m}{8} , label \PYG{l+m}{3}, triangle \PYG{l+m}{7} \PYG{l+m}{0}
\PYG{l+m}{6} : \PYG{l+m}{0} \PYG{l+m}{3} , label \PYG{l+m}{4}, triangle \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{7} : \PYG{l+m}{3} \PYG{l+m}{6} , label \PYG{l+m}{4}, triangle \PYG{l+m}{5} \PYG{l+m}{1}
boundingbox:
\PYG{n+nv}{xmin} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{xmax} \PYG{o}{=} \PYG{l+m}{1}, \PYG{n+nv}{ymin} \PYG{o}{=} \PYG{l+m}{0}, \PYG{n+nv}{ymax} \PYG{o}{=} \PYG{l+m}{1}
\end{sphinxVerbatim}

\sphinxAtStartPar
The real characteristic function of a mesh \sphinxcode{\sphinxupquote{Th}} is \sphinxcode{\sphinxupquote{chi(Th)}} in 2D and 3D where:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chi(Th)(P)=1}} if \(P\in Th\)

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chi(Th)(P)=0}} if \(P\not\in Th\)


\subsubsection{The keyword “triangulate”}
\label{\detokenize{documentation/mesh-generation:the-keyword-triangulate}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} is able to build a triangulation from a set of points.
This triangulation is a Delaunay mesh of the convex hull of the set of points.
It can be useful to build a mesh from a table function.

\sphinxAtStartPar
The coordinates of the points and the value of the table function are defined separately with rows of the form: \sphinxcode{\sphinxupquote{x y f(x,y)}} in a file such as:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mf}{0.51387} \PYG{l+m+mf}{0.175741} \PYG{l+m+mf}{0.636237}
\PYG{l+m+mf}{0.308652} \PYG{l+m+mf}{0.534534} \PYG{l+m+mf}{0.746765}
\PYG{l+m+mf}{0.947628} \PYG{l+m+mf}{0.171736} \PYG{l+m+mf}{0.899823}
\PYG{l+m+mf}{0.702231} \PYG{l+m+mf}{0.226431} \PYG{l+m+mf}{0.800819}
\PYG{l+m+mf}{0.494773} \PYG{l+m+mf}{0.12472} \PYG{l+m+mf}{0.580623}
\PYG{l+m+mf}{0.0838988} \PYG{l+m+mf}{0.389647} \PYG{l+m+mf}{0.456045}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Triangulate1}.png}
\caption{Delaunay mesh of the convex hull of point set in file xy}\label{\detokenize{documentation/mesh-generation:id35}}\label{\detokenize{documentation/mesh-generation:figdelaunaymesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Triangulate2}.png}
\caption{Isolvalue of table function}\label{\detokenize{documentation/mesh-generation:id36}}\label{\detokenize{documentation/mesh-generation:figisovalue}}\end{subfigure}
\caption{Triangulate}\phantomsection\label{\detokenize{documentation/mesh-generation:Triangulate}}

\end{figure}


\sphinxAtStartPar
The third column of each line is left untouched by the \sphinxcode{\sphinxupquote{triangulate}} command.
But you can use this third value to define a table function with rows of the form: \sphinxcode{\sphinxupquote{x y f(x,y)}}.

\sphinxAtStartPar
The following example shows how to make a mesh from the file \sphinxcode{\sphinxupquote{xyf}} with the format stated just above.
The command \sphinxcode{\sphinxupquote{triangulate}} only uses the 1st and 2nd columns.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Build the Delaunay mesh of the convex hull}
\PYG{k+kt}{mesh} \PYG{n}{Thxy}\PYG{o}{=}\PYG{n+nf}{triangulate}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xyf}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//points are defined by the first 2 columns of file `xyf`}

\PYG{c+c1}{// Plot the created mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thxy}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vhxy}\PYG{p}{(}\PYG{n}{Thxy}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhxy} \PYG{n}{fxy}\PYG{p}{;}

\PYG{c+c1}{// Reading the 3rd column to define the function fxy}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xyf}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{fxy}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{yy} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{fxy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//to read third row only.}
                                      \PYG{c+c1}{//xx and yy are just skipped}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fxy}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
One new way to build a mesh is to have two arrays: one for the \(x\) values and the other for the \(y\) values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//set two arrays for the x\PYGZsq{}s and y\PYGZsq{}s}
\PYG{n}{Vhxy} \PYG{n}{xx}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{yy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{c+c1}{//build the mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{triangulate}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{2d Finite Element space on a boundary}
\label{\detokenize{documentation/mesh-generation:d-finite-element-space-on-a-boundary}}
\sphinxAtStartPar
To define a Finite Element space on a boundary, we came up with the idea of a mesh with no internal points (called empty mesh).
It can be useful to handle Lagrange multipliers in mixed and mortar methods.

\sphinxAtStartPar
So the function \sphinxcode{\sphinxupquote{emptymesh}} removes all the internal points of a mesh except points on internal boundaries.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is also possible to build an empty mesh of a pseudo subregion with \sphinxcode{\sphinxupquote{emptymesh(Th, ssd)}} using the set of edges from the mesh \sphinxcode{\sphinxupquote{Th}}; an edge \(e\) is in this set when, with the two adjacent triangles \(e =t1\cap t2\) and \(ssd[T1] \neq ssd[T2]\) where \(ssd\) refers to the pseudo region numbering of triangles, they are stored in the \sphinxcode{\sphinxupquote{int{[}int{]}}} array of size “the number of triangles”.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ssd}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//build the pseudo region numbering}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ssd}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{iq} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//because 2 triangles per quad}
        \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
        \PYG{n}{ssd}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ix}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iy}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{//build emtpy with all edges \PYGZdl{}e=T1 \PYGZbs{}cap T2\PYGZdl{} and \PYGZdl{}ssd[T1] \PYGZbs{}neq ssd[T2]\PYGZdl{}}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{emptymesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_EmptyMesh1}.png}
\caption{The empty mesh with boundary}\label{\detokenize{documentation/mesh-generation:id37}}\label{\detokenize{documentation/mesh-generation:figemptymesh1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_EmptyMesh2}.png}
\caption{An empty mesh defined from a pseudo region numbering of triangle}\label{\detokenize{documentation/mesh-generation:id38}}\label{\detokenize{documentation/mesh-generation:figemptymesh2}}\end{subfigure}
\caption{Empty mesh}

\end{figure}



\subsubsection{Remeshing}
\label{\detokenize{documentation/mesh-generation:remeshing}}\label{\detokenize{documentation/mesh-generation:EmptyMesh}}

\paragraph{The command \sphinxstyleemphasis{movemesh}}
\label{\detokenize{documentation/mesh-generation:the-command-movemesh}}\label{\detokenize{documentation/mesh-generation:meshgenerationmovemesh}}
\sphinxAtStartPar
Meshes can be translated, rotated, and deformed by \sphinxcode{\sphinxupquote{movemesh}}; this is useful for elasticity to watch the deformation due to the displacement \(\mathbf{\Phi}(x,y)=(\Phi_1(x,y),\Phi_2(x,y))\) of shape.

\sphinxAtStartPar
It is also useful to handle free boundary problems or optimal shape problems.

\sphinxAtStartPar
If \(\Omega\) is triangulated as \(T_h(\Omega)\), and \(\mathbf{\Phi}\) is a displacement vector then \(\mathbf{\Phi}(T_h)\) is obtained by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Sometimes the transformed mesh is invalid because some triangles have flipped over (meaning it now has a negative area).
To spot such problems, one may check the minimum triangle area in the transformed mesh with \sphinxcode{\sphinxupquote{checkmovemesh}} before any real transformation.

\sphinxAtStartPar
For example:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \Phi_1(x,y) &=& x+k*\sin(y*\pi)/10)\\
    \Phi_2(x,y) &=& y+k*\cos(y\pi)/10)
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
for a big number \(k>1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lshape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{uu} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{vv} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Checkmovemesh}
\PYG{k+kt}{real} \PYG{n}{minT0} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return the min triangle area}
\PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{// find a correct move mesh}
    \PYG{k+kt}{real} \PYG{n}{minT} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{minT} \PYG{o}{\PYGZgt{}} \PYG{n}{minT0}\PYG{o}{/}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;} \PYG{c+c1}{//if big enough}
    \PYG{k+kp}{coef} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Movemesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MovedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_MoveMesh1}.png}
\caption{L\sphinxhyphen{}shape}\label{\detokenize{documentation/mesh-generation:id39}}\label{\detokenize{documentation/mesh-generation:figlshape}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_MoveMesh2}.png}
\caption{Moved L\sphinxhyphen{}shape}\label{\detokenize{documentation/mesh-generation:id40}}\label{\detokenize{documentation/mesh-generation:figmovedlshape}}\end{subfigure}
\caption{Move mesh}\phantomsection\label{\detokenize{documentation/mesh-generation:MoveMesh}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Consider a function \(u\) defined on a mesh \sphinxcode{\sphinxupquote{Th}}.
A statement like \sphinxcode{\sphinxupquote{Th=movemesh(Th...)}} does not change \(u\) and so the old mesh still exists.
It will be destroyed when no function uses it.
A statement like \(u=u\) redefines \(u\) on the new mesh \sphinxcode{\sphinxupquote{Th}} with interpolation and therefore destroys the old \sphinxcode{\sphinxupquote{Th}}, if \(u\) was the only function using it.
\end{sphinxadmonition}

\sphinxAtStartPar
Now, we give an example of moving a mesh with a Lagrangian function \(u\) defined on the moving mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{t} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{f}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{minarea} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{f}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{minarea} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//movemesh will be ok}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{f}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Min area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{minarea} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{tmp}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{tmp} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//save the value}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{c+c1}{//to change the FEspace and mesh associated with u}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tmp}\PYG{p}{;}\PYG{c+c1}{//set the value of u without any mesh update}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// In this program, since u is only defined on the last mesh, all the}
\PYG{c+c1}{// previous meshes are deleted from memory.}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{hTriangle}}
\label{\detokenize{documentation/mesh-generation:the-command-htriangle}}\label{\detokenize{documentation/mesh-generation:meshregulartriangulation}}
\sphinxAtStartPar
This section presents the way to obtain a regular triangulation with \sphinxstylestrong{FreeFEM}.

\sphinxAtStartPar
For a set \(S\), we define the diameter of \(S\) by
\begin{equation*}
\begin{split}\textrm{diam}(S)=\sup\{|\mathbf{x}-\mathbf{y}|; \; \mathbf{x},\, \mathbf{y}\in S\}\end{split}
\end{equation*}
\sphinxAtStartPar
The sequence \(\{\mathcal{T}_h\}_{h\rightarrow 0}\) of
\(\Omega\) is called \sphinxstyleemphasis{regular} if they satisfy the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\(\lim_{h\rightarrow 0}\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}=0\)

\item {} 
\sphinxAtStartPar
There is a number \(\sigma>0\) independent of \(h\) such that \(\frac{\rho(T_k)}{\textrm{diam}(T_k)}\ge \sigma\quad \textrm{for all }T_k\in \mathcal{T}_h\) where \(\rho(T_k)\) are the diameter of the inscribed circle of \(T_k\).

\end{enumerate}

\sphinxAtStartPar
We put \(h(\mathcal{T}_h)=\max\{\textrm{diam}(T_k)|\; T_k\in \mathcal{T}_h\}\), which is obtained by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size of mesh = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{adaptmesh}}
\label{\detokenize{documentation/mesh-generation:the-command-adaptmesh}}
\sphinxAtStartPar
The function:
\begin{equation*}
\begin{split}f(x,y) = 10.0x^3+y^3+\tan^{-1}[\varepsilon/(\sin(5.0y)-2.0x)],\ \varepsilon = 0.0001\end{split}
\end{equation*}
\sphinxAtStartPar
sharply varies in value and the initial mesh given by one of the commands in the {\hyperref[\detokenize{documentation/mesh-generation:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation part}}}} cannot reflect its sharp variations.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{hmin} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//old mesh is deleted}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_AdaptMesh1}.png}
\caption{3D graphs for the initial mesh and 1st and 2nd mesh adaptations}\label{\detokenize{documentation/mesh-generation:figmeshadaptation}}\end{figure}

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} uses a variable metric/Delaunay automatic meshing algorithm.

\sphinxAtStartPar
The command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{ATh} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
create the new mesh \sphinxcode{\sphinxupquote{ATh}} adapted to the Hessian
\begin{equation*}
\begin{split}D^2f=(\partial^2 f/\partial x^2,\, \partial^2 f/\partial x\partial y, \partial^2 f/\partial y^2)\end{split}
\end{equation*}
\sphinxAtStartPar
of a function (formula or FE\sphinxhyphen{}function).

\sphinxAtStartPar
Mesh adaptation is a very powerful tool when the solution of a problem varies locally and sharply.

\sphinxAtStartPar
Here we solve the {\hyperref[\detokenize{tutorials/poisson:tutorialpoisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s problem}}}}, when \(f=1\) and \(\Omega\) is an L\sphinxhyphen{}shape domain.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh2}.png}
\caption{L\sphinxhyphen{}shape domain and its boundary name}\label{\detokenize{documentation/mesh-generation:id41}}\label{\detokenize{documentation/mesh-generation:adaptmesh2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh3}.png}
\caption{Final solution after 4\sphinxhyphen{}times adaptation}\label{\detokenize{documentation/mesh-generation:id42}}\label{\detokenize{documentation/mesh-generation:adaptmesh3}}\end{subfigure}
\caption{Mesh adaptation}\phantomsection\label{\detokenize{documentation/mesh-generation:AdaptMesh}}

\end{figure}


\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
The solution has the singularity \(r^{3/2},\, r=|x-\gamma|\) at the point \(\gamma\) of the intersection of two lines \(bc\) and \(bd\) (see \hyperref[\detokenize{documentation/mesh-generation:adaptmesh2}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:adaptmesh2}}}).
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To speed up the adaptation, the default parameter \sphinxcode{\sphinxupquote{err}} of \sphinxcode{\sphinxupquote{adaptmesh}} is changed by hand; it specifies the required precision, so as to make the new mesh finer or coarser.

\sphinxAtStartPar
The problem is coercive and symmetric, so the linear system can be solved with the conjugate gradient method (parameter \sphinxcode{\sphinxupquote{solver=CG}}) with the stopping criteria on the residual, here \sphinxcode{\sphinxupquote{eps=1.e\sphinxhyphen{}6}}).

\sphinxAtStartPar
By \sphinxcode{\sphinxupquote{adaptmesh}}, the slope of the final solution is correctly computed near the point of intersection of \(bc\) and \(bd\) as in \hyperref[\detokenize{documentation/mesh-generation:adaptmesh3}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:adaptmesh3}}}.

\sphinxAtStartPar
This method is described in detail in \sphinxcite{bibliography:hecht1998}.
It has a number of default parameters which can be modified.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{f1,f2}} are functions and \sphinxcode{\sphinxupquote{thold, Thnew}} are meshes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{n}{f1} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Thold}\PYG{p}{,} \PYG{p}{[}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2}\PYG{p}{]} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The additional parameters of \sphinxcode{\sphinxupquote{adaptmesh}} are:

\sphinxAtStartPar
See {\hyperref[\detokenize{references/functions:referenceadaptmesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Reference part}}}} for more inforamtions
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{hmin=}} Minimum edge size.}] \leavevmode
\sphinxAtStartPar
Its default is related to the size of the domain to be meshed and the precision of the mesh generator.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{hmax=}} Maximum edge size.}] \leavevmode
\sphinxAtStartPar
It defaults to the diameter of the domain to be meshed.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{err=}} \(P_1\) interpolation error level (0.01 is the default).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{errg=}} Relative geometrical error.}] \leavevmode
\sphinxAtStartPar
By default this error is 0.01, and in any case it must be lower than \(1/\sqrt{2}\).
Meshes created with this option may have some edges smaller than the \sphinxcode{\sphinxupquote{\sphinxhyphen{}hmin}} due to geometrical constraints.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbvx=}} Maximum number of vertices generated by the mesh generator (9000 is the default).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbsmooth=}} number of iterations of the smoothing procedure (5 is the default).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbjacoby=}} number of iterations in a smoothing procedure during the metric construction, 0 means no smoothing, 6 is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ratio=}} ratio for a prescribed smoothing on the metric.}] \leavevmode
\sphinxAtStartPar
If the value is 0 or less than 1.1 no smoothing is done on the metric. 1.8 is the default.
If \sphinxcode{\sphinxupquote{ratio \textgreater{} 1.1}}, the speed of mesh size variations is bounded by \(log(\mathtt{ratio})\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
As \sphinxcode{\sphinxupquote{ratio}} gets closer to 1, the number of generated vertices increases.
This may be useful to control the thickness of refined regions near shocks or boundary layers.
\end{sphinxadmonition}

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{omega=}} relaxation parameter for the smoothing procedure. 1.0 is the default.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iso=}} If true, forces the metric to be isotropic. \sphinxcode{\sphinxupquote{false}} is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{abserror=}} If false, the metric is evaluated using the criteria of equi\sphinxhyphen{}repartion of relative error.}] \leavevmode
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{false}} is the default.
In this case the metric is defined by:
\begin{equation*}
\begin{split}\mathcal{M} = \left({1\over\mathtt{err}\,\, \mathtt{coef}^2} \quad {
|\mathcal{H}| \over max(\mathtt{CutOff},|\eta|)}\right)^p\end{split}
\end{equation*}
\sphinxAtStartPar
Otherwise, the metric is evaluated using the criteria of equi\sphinxhyphen{}distribution of errors.
In this case the metric is defined by:
\begin{equation*}
\begin{split}\mathcal{M} = \left({1\over \mathtt{err}\,\,\mathtt{coef}^2} \quad
{|{\mathcal{H}|} \over
{\sup(\eta)-\inf(\eta)}}\right)^p.\label{eq err abs}\end{split}
\end{equation*}
\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cutoff=}} lower limit for the relative error evaluation.
1.0e\sphinxhyphen{}6 is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{verbosity=}} informational messages level (can be chosen between 0 and \(\infty\)).}] \leavevmode
\sphinxAtStartPar
Also changes the value of the global variable verbosity (obsolete).

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inquire=}} To inquire graphically about the mesh.
\sphinxcode{\sphinxupquote{false}} is the default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{splitpbedge=}} If true, splits all internal edges in half with two boundary vertices.}] \leavevmode
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{maxsubdiv=}} Changes the metric such that the maximum subdivision of a background edge is bound by \sphinxcode{\sphinxupquote{val}}.}] \leavevmode
\sphinxAtStartPar
Always limited by 10, and 10 is also the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{rescaling=}} if true, the function, with respect to which the mesh is adapted, is rescaled to be between 0 and 1.}] \leavevmode
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{keepbackvertices=}} if true, tries to keep as many vertices from the original mesh as possible.}] \leavevmode
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{true}} is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{IsMetric=}} if true, the metric is defined explicitly.}] \leavevmode
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{false}} is the default.
If the 3 functions \(m_{11}, m_{12}, m_{22}\) are given, they directly define a symmetric matrix field whose Hessian is computed to define a metric.
If only one function is given, then it represents the isotropic mesh size at every point.

\sphinxAtStartPar
For example, if the partial derivatives \sphinxcode{\sphinxupquote{fxx}} (\(=\partial^2 f/\partial x^2\)), \sphinxcode{\sphinxupquote{fxy}} (\(=\partial^2 f/\partial x\partial y\)), \sphinxcode{\sphinxupquote{fyy}} (\(=\partial^2 f/\partial y^2\)) are given, we can set \sphinxcode{\sphinxupquote{Th = adaptmesh(Th, fxx, fxy, fyy, IsMetric=1, nbvx=10000, hmin=hmin);}}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{power=}} exponent power of the Hessian used to compute the metric.}] \leavevmode
\sphinxAtStartPar
1 is the default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{thetamax=}} minimum corner angle in degrees.}] \leavevmode
\sphinxAtStartPar
Default is \(10^\circ\) where the corner is \(ABC\) and the angle is the angle of the two vectors \({AB}, {BC}\), (\(0\) imply no corner, \(90\) imply perpendicular corner, …).

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{splitin2=}} boolean value.}] \leavevmode
\sphinxAtStartPar
If true, splits all triangles of the final mesh into 4 sub\sphinxhyphen{}triangles.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} an array of 3 real arrays to set or get metric data information.}] \leavevmode
\sphinxAtStartPar
The size of these three arrays must be the number of vertices.
So if \sphinxcode{\sphinxupquote{m11,m12,m22}} are three P1 finite elements related to the mesh to adapt, you can write: \sphinxcode{\sphinxupquote{metric={[}m11{[}{]},m12{[}{]},m22{[}{]}{]}}} (see file \sphinxcode{\sphinxupquote{convect\sphinxhyphen{}apt.edp}} for a full example)

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nomeshgeneration=}} If true, no adapted mesh is generated (useful to compute only a metric).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{periodic=}} Writing \sphinxcode{\sphinxupquote{periodic={[}{[}4,y{]},{[}2,y{]},{[}1,x{]},{[}3,x{]}{]};}} builds an adapted periodic mesh.}] \leavevmode
\sphinxAtStartPar
The sample builds a biperiodic mesh of a square.
(see {\hyperref[\detokenize{documentation/finite-element:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{periodic finite element spaces}}}}, and see {\hyperref[\detokenize{examples/mesh-generation:examplesphere}]{\sphinxcrossref{\DUrole{std,std-ref}{the Sphere example}}}} for a full example)

\end{description}

\end{itemize}

\sphinxAtStartPar
We can use the command \sphinxcode{\sphinxupquote{adaptmesh}} to build a uniform mesh with a constant mesh size.
To build a mesh with a constant mesh size equal to \(\frac{1}{30}\) try:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the initial mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}0.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}1.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//More the one time du to}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Adaptation bound `maxsubdiv=`}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square\PYGZhy{}2.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh4}.png}
\caption{Initial mesh}\label{\detokenize{documentation/mesh-generation:id43}}\label{\detokenize{documentation/mesh-generation:adaptmesh4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh5}.png}
\caption{First iteration}\label{\detokenize{documentation/mesh-generation:id44}}\label{\detokenize{documentation/mesh-generation:adaptmesh5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_AdaptMesh6}.png}
\caption{Last iteration}\label{\detokenize{documentation/mesh-generation:id45}}\label{\detokenize{documentation/mesh-generation:adaptmesh6}}\end{subfigure}
\caption{Mesh adaptation}

\end{figure}



\paragraph{The command \sphinxstyleemphasis{trunc}}
\label{\detokenize{documentation/mesh-generation:the-command-trunc}}\label{\detokenize{documentation/mesh-generation:AdaptMesh2}}
\sphinxAtStartPar
Two operators have been introduced to remove triangles from a mesh or to divide them.
Operator \sphinxcode{\sphinxupquote{trunc}} has the following parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
boolean function to keep or remove elements

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} sets the label number of new boundary item, one by default.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{split=}} sets the level \(n\) of triangle splitting.}] \leavevmode
\sphinxAtStartPar
Each triangle is split in \(n\times n\), one by default.

\end{description}

\end{itemize}

\sphinxAtStartPar
To create the mesh \sphinxcode{\sphinxupquote{Th3}} where all triangles of a mesh \sphinxcode{\sphinxupquote{Th}} are split in \(3{\times}3\), just write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following example construct all “trunced” meshes to the support of the basic function of the space \sphinxcode{\sphinxupquote{Vh}} (cf. \sphinxcode{\sphinxupquote{abs(u)\textgreater{}0}}), split all the triangles in \(5{\times} 5\), and put a label number to \(2\) on a new boundary.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Loop on all degrees of freedom}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// The basis function i}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Sh1} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1.e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Sh1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{trunc}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// reset}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.490\linewidth]{{MeshGeneration_Trunc1}.png}
\caption{Mesh of support the function P1 number 0, split in \(5{\times}5\)}\label{\detokenize{documentation/mesh-generation:id46}}\label{\detokenize{documentation/mesh-generation:trunc1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.490\linewidth]{{MeshGeneration_Trunc1}.png}
\caption{Mesh of support the function P1 number 6, split in \(5{\times}5\)}\label{\detokenize{documentation/mesh-generation:id47}}\label{\detokenize{documentation/mesh-generation:trunc6}}\end{subfigure}
\caption{Trunc}

\end{figure}



\paragraph{The command \sphinxstyleemphasis{change}}
\label{\detokenize{documentation/mesh-generation:the-command-change}}\label{\detokenize{documentation/mesh-generation:Trunc}}
\sphinxAtStartPar
This command changes the label of elements and border elements of a mesh.

\sphinxAtStartPar
Changing the label of elements and border elements will be done using the keyword \sphinxcode{\sphinxupquote{change}}.
The parameters for this command line are for two dimensional and three dimensional cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refe=}} is an array of integers to change the references on edges

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reft=}} is an array of integers to change the references on triangles

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} is an array of integers to change the 4 default label numbers

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region=}} is an array of integers to change the default region numbers

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{renumv=}} is an array of integers, which explicitly gives the new numbering of vertices in the new mesh. By default, this numbering is that of the original mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{renumt=}} is an array of integers, which explicitly gives the new numbering of elements in the new mesh, according the new vertices numbering given by \sphinxcode{\sphinxupquote{renumv=}}. By default, this numbering is that of the original mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flabel=}} is an integer function given the new value of the label

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fregion=}} is an integer function given the new value of the region

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rmledges=}} is an integer to remove edges in the new mesh, following a label

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rmInternalEdges=}} is a boolean, if equal to true to remove the internal edges. By default, the internal edges are stored

\end{itemize}

\sphinxAtStartPar
These vectors are composed of \(n_{l}\) successive pairs of numbers \(O,N\) where \(n_{l}\) is the number (label or region) that we want to change.
For example, we have :
\begin{equation}\label{equation:documentation/mesh-generation:eq.org.vector.change.label}
\begin{split}\mathtt{label} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}
\end{equation}
\sphinxAtStartPar
An application example is given here:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the label of Edges 2 in 0.}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// boundary label: 1 \PYGZhy{}\PYGZgt{} 1 bottom, 2 \PYGZhy{}\PYGZgt{} 1 right, 3\PYGZhy{}\PYGZgt{}1 top, 4\PYGZhy{}\PYGZgt{}1 left boundary label is 1}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{re}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{Th2}\PYG{o}{=}\PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{k+kp}{refe}\PYG{o}{=}\PYG{k+kr}{re}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{splitmesh}}
\label{\detokenize{documentation/mesh-generation:the-command-splitmesh}}
\sphinxAtStartPar
Another way to split mesh triangles is to use \sphinxcode{\sphinxupquote{splitmesh}}, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NotSplittedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Splitmesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{splitmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SplittedMesh.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_SplitMesh1}.png}
\caption{Initial mesh}\label{\detokenize{documentation/mesh-generation:id48}}\label{\detokenize{documentation/mesh-generation:splitmesh1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_SplitMesh2}.png}
\caption{All left mesh triangle is split conformaly in \sphinxcode{\sphinxupquote{int(1+5*(square(x\sphinxhyphen{}0.5)+y*y)\textasciicircum{}2}} triangles}\label{\detokenize{documentation/mesh-generation:id49}}\label{\detokenize{documentation/mesh-generation:splitmesh2}}\end{subfigure}
\caption{Split mesh}

\end{figure}



\subsubsection{Meshing Examples}
\label{\detokenize{documentation/mesh-generation:meshing-examples}}\label{\detokenize{documentation/mesh-generation:meshexamples}}\label{\detokenize{documentation/mesh-generation:SplitMesh}}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Two rectangles touching by a side

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TouchSide.esp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_NACA0012_1}.png}
\caption{Two rectangles touching by a side}\label{\detokenize{documentation/mesh-generation:naca00121}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
NACA0012 Airfoil

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{upper}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{lower}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NACA0012.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_NACA0012_2}.png}
\caption{NACA0012 Airfoil}\label{\detokenize{documentation/mesh-generation:naca00122}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Cardioid

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cardioid.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Cardioid1}.png}
\caption{Domain with Cardioid curve boundary}\label{\detokenize{documentation/mesh-generation:cardioid1}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Cassini Egg

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cassini.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Cardioid2}.png}
\caption{Domain with Cassini egg curve boundary}\label{\detokenize{documentation/mesh-generation:cardioid2}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
By cubic Bezier curve

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// A cubic Bezier curve connecting two points with two control points}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{bzi}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{p0}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{p1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q2}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{p0}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{q1}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{q2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p1}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p00} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.95}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{q30} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G3}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bezier.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Bezier}.png}
\caption{Boundary drawn by Bezier curves}\label{\detokenize{documentation/mesh-generation:bezier}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Section of Engine

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{a} \PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L7}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L8}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{b}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L3}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L4}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L5}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L6}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L7}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L8}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Engine.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_Engine}.png}
\caption{Section of Engine}\label{\detokenize{documentation/mesh-generation:engine}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Domain with U\sphinxhyphen{}shape channel

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//width of U\PYGZhy{}shape}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{U\PYGZhy{}shape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_UShape}.png}
\caption{Domain with U\sphinxhyphen{}shape channel changed by \sphinxcode{\sphinxupquote{d}}}\label{\detokenize{documentation/mesh-generation:ushape}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Domain with V\sphinxhyphen{}shape cut

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{dAg} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;} \PYG{c+c1}{//angle of V\PYGZhy{}shape}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{dAg}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pa}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{pc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{n}{dAg}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{seg1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{seg2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{pc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n}{pa}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{seg1}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{seg2}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{V\PYGZhy{}shape.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_VShape}.png}
\caption{Domain with V\sphinxhyphen{}shape cut changed by \sphinxcode{\sphinxupquote{dAg}}}\label{\detokenize{documentation/mesh-generation:vshape}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Smiling face

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{F}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{E1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{E2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{st}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{n}{c}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{st}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{F}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C4}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C0}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{E1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{E2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SmileFace.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Example_SmilingFace}.png}
\caption{Smiling face (Mouth is changeable)}\label{\detokenize{documentation/mesh-generation:smilingface}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
3 points bending

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Square for Three\PYGZhy{}Point Bend Specimens fixed on Fix1, Fix2}
\PYG{c+c1}{// It will be loaded on Load.}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{m} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Load}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Fix1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Fix2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Load}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThreePoint.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{MeshGeneration_Example_ThreePoints}.png}
\caption{Domain for three\sphinxhyphen{}point bending test}\label{\detokenize{documentation/mesh-generation:threepoints}}\end{figure}
\end{sphinxadmonition}


\subsection{\sphinxstylestrong{The type mesh3 in 3 dimension}}
\label{\detokenize{documentation/mesh-generation:the-type-mesh3-in-3-dimension}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Up to the version 3, FreeFEM allowed to consider a surface problem such as the PDE
is treated like boundary conditions on the boundary domain (on triangles describing
the boundary domain). With the version 4, in particular 4.2.1, a completed model for
surface problem is possible, with the definition of a surface mesh and a surface problem
with a variational form on domain ( with triangle elements) and application of boundary
conditions on border domain (describing by edges). The keywords to define a surface
mesh is \sphinxstylestrong{meshS}.
\end{sphinxadmonition}


\subsubsection{3d mesh generation}
\label{\detokenize{documentation/mesh-generation:d-mesh-generation}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
For 3D mesh tools, put \sphinxcode{\sphinxupquote{load "msh3"}} at the top of the .edp script.
\end{sphinxadmonition}


\paragraph{The command \sphinxstyleemphasis{cube}}
\label{\detokenize{documentation/mesh-generation:the-command-cube}}
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{cube}} like its 2d function \sphinxcode{\sphinxupquote{square}} is a simple way to build cubic objects, it is contained in plugin \sphinxcode{\sphinxupquote{msh3}} (import with \sphinxcode{\sphinxupquote{load "msh3"}}).

\sphinxAtStartPar
The following code generates a \(3\times 4 \times 5\) grid in the unit cube \([0, 1]^3\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default the labels are :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
face \(y=0\),

\item {} 
\sphinxAtStartPar
face \(x=1\),

\item {} 
\sphinxAtStartPar
face \(y=1\),

\item {} 
\sphinxAtStartPar
face \(x=0\),

\item {} 
\sphinxAtStartPar
face \(z=0\),

\item {} 
\sphinxAtStartPar
face \(z=1\)

\end{enumerate}

\sphinxAtStartPar
and the region number is \(0\).

\sphinxAtStartPar
A full example of this function to build a mesh of cube \(]-1,1[^3\) with face label given by \((ix + 4*(iy+1) + 16*(iz+1))\) where \((ix, iy, iz)\) are the coordinates of the barycenter of the current face, is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l6} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{r11} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l6}\PYG{p}{,} \PYG{k+kp}{flags} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, border area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sx} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sy} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{sz} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sx}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sy}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{iz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sz}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ix} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iy}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//value of ix,iy,iz =\PYGZgt{} face min 0, face max 2, no face 1}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, s = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ix} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(} \PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ii} \PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{real} \PYG{n}{volr11} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume region = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{volr11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{volr11} \PYG{o}{\PYGZhy{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nb err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nl}{Enter}\PYG{o}{:} \PYG{n+nl}{BuildCube}\PYG{o}{:} \PYG{l+m+mi}{3}
  \PYG{n}{kind} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{k+kr}{n} \PYG{n}{tet} \PYG{n}{Cube} \PYG{o}{=} \PYG{l+m+mi}{6} \PYG{o}{/} \PYG{k+kr}{n} \PYG{n}{slip} \PYG{l+m+mi}{6} \PYG{l+m+mi}{19}
\PYG{n}{Cube}  \PYG{k+kr}{nv}\PYG{o}{=}\PYG{l+m+mi}{210} \PYG{k+kr}{nt}\PYG{o}{=}\PYG{l+m+mi}{720} \PYG{k+kr}{nbe}\PYG{o}{=}\PYG{l+m+mi}{296}
\PYG{n+nl}{Out}\PYG{o}{:}  \PYG{n}{BuildCube}
\PYG{n}{Volume} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{k+kt}{border} \PYG{k+kr}{area} \PYG{o}{=} \PYG{l+m+mi}{24}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{110} \PYG{o}{:} \PYG{l+m+mi}{25}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{37}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{101} \PYG{o}{:} \PYG{l+m+mi}{37}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mo}{011} \PYG{o}{:} \PYG{l+m+mi}{40}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{211} \PYG{o}{:} \PYG{l+m+mi}{42}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{121} \PYG{o}{:} \PYG{l+m+mi}{45}
\PYG{n}{Label} \PYG{o}{=} \PYG{l+m+mi}{57}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{4} \PYG{l+m+mi}{112} \PYG{o}{:} \PYG{l+m+mi}{57}
\PYG{n}{Volume} \PYG{k+kr}{region} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{o}{:} \PYG{l+m+mi}{8}
\PYG{n}{Nb} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Cube}.jpg}
\caption{The 3D mesh of function \sphinxcode{\sphinxupquote{cube(4, 5, 6, flags=3)}}}\label{\detokenize{documentation/mesh-generation:meshgeneration-cube}}\end{figure}


\paragraph{The command \sphinxstyleemphasis{buildlayers}}
\label{\detokenize{documentation/mesh-generation:the-command-buildlayers}}\label{\detokenize{documentation/mesh-generation:meshreadwrite3d}}
\sphinxAtStartPar
This mesh is obtained by extending a two dimensional mesh in the \(z\)\sphinxhyphen{}axis.

\sphinxAtStartPar
The domain \(\Omega_{3d}\) defined by the layer mesh is equal to \(\Omega_{3d} = \Omega_{2d} \times [zmin, zmax]\) where \(\Omega_{2d}\) is the domain defined by the two dimensional meshes.
\(zmin\) and \(zmax\) are functions of \(\Omega_{2d}\) in \(\R\) that defines respectively the lower surface and upper surface of \(\Omega_{3d}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{MeshGeneration_LayerMesh}.png}
\caption{Example of Layer mesh in three dimensions.}\label{\detokenize{documentation/mesh-generation:meshgenerationlayermesh}}\end{figure}

\sphinxAtStartPar
For a vertex of a two dimensional mesh \(V_{i}^{2d} = (x_{i},y_{i})\), we introduce the number of associated vertices in the \(z-\)axis \(M_{i}+1\).

\sphinxAtStartPar
We denote by \(M\) the maximum of \(M_{i}\) over the vertices of the two dimensional mesh.
This value is called the number of layers (if \(\forall i, \; M_{i}=M\) then there are \(M\) layers in the mesh of \(\Omega_{3d}\)).
\(V_{i}^{2d}\) generated \(M+1\) vertices which are defined by:
\begin{equation*}
\begin{split}\forall j=0, \ldots, M, \quad V_{i,j}^{3d} = ( x_{i}, y_{i}, \theta_{i}(z_{i,j}) ),\end{split}
\end{equation*}
\sphinxAtStartPar
where \((z_{i,j})_{j=0,\ldots,M}\) are the \(M+1\) equidistant points on the interval \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d})]\):
\begin{equation*}
\begin{split}z_{i,j} = j \: \delta \alpha + zmin(V_{i}^{2d}), \quad \delta \alpha= \frac{ zmax( V_{i}^{2d} ) - zmin( V_{i}^{2d}) }{M}.\end{split}
\end{equation*}
\sphinxAtStartPar
The function \(\theta_{i}\), defined on \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\), is given by:
\begin{equation*}
\begin{split}\theta_{i}(z) = \left \{
\begin{array}{cl}
\theta_{i,0} & \mbox{if} \: z=zmin(V_{i}^{2d}), \\
\theta_{i,j} & \mbox{if} \: z \in ] \theta_{i,j-1}, \theta_{i,j}],\\
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
with \((\theta_{i,j})_{j=0,\ldots,M_{i}}\) are the \(M_{i}+1\) equidistant points on the interval \([zmin( V_{i}^{2d} ), zmax( V_{i}^{2d} )]\).

\sphinxAtStartPar
Set a triangle \(K=(V_{i1}^{2d}\), \(V_{i2}^{2d}\), \(V_{i3}^{2d})\) of the two dimensional mesh.
\(K\) is associated with a triangle on the upper surface (resp. on the lower surface) of layer mesh:

\sphinxAtStartPar
\(( V_{i1,M}^{3d}, V_{i2,M}^{3d}, V_{i3,M}^{3d} )\) (resp. \(( V_{i1,0}^{3d}, V_{i2,0}^{3d}, V_{i3,0}^{3d})\)).

\sphinxAtStartPar
Also \(K\) is associated with \(M\) volume prismatic elements which are defined by:
\begin{equation*}
\begin{split}\forall j=0,\ldots,M, \quad H_{j} = ( V_{i1,j}^{3d}, V_{i2,j}^{3d}, V_{i3,j}^{3d}, V_{i1,j+1}^{3d}, V_{i2,j+1}^{3d}, V_{i3,j+1}^{3d} ).\end{split}
\end{equation*}
\sphinxAtStartPar
Theses volume elements can have some merged point:
\begin{itemize}
\item {} 
\sphinxAtStartPar
0 merged point : prism

\item {} 
\sphinxAtStartPar
1 merged points : pyramid

\item {} 
\sphinxAtStartPar
2 merged points : tetrahedra

\item {} 
\sphinxAtStartPar
3 merged points : no elements

\end{itemize}

\sphinxAtStartPar
The elements with merged points are called degenerate elements.
To obtain a mesh with tetrahedra, we decompose the pyramid into two tetrahedra and the prism into three tetrahedra.
These tetrahedra are obtained by cutting the quadrilateral face of pyramid and prism with the diagonal which have the vertex with the maximum index (see \sphinxcite{bibliography:hecht1992} for the reason of this choice).

\sphinxAtStartPar
The triangles on the middle surface obtained with the decomposition of the volume prismatic elements are the triangles generated by the edges on the border of the two dimensional mesh.
The label of triangles on the border elements and tetrahedra are defined with the label of these associated elements.

\sphinxAtStartPar
The arguments of \sphinxcode{\sphinxupquote{buildlayers}} is a two dimensional mesh and the number of layers \(M\).

\sphinxAtStartPar
The parameters of this command are:
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{zbound=}} \([zmin,zmax]\) where \(zmin\) and \(zmax\) are functions expression.}] \leavevmode
\sphinxAtStartPar
Theses functions define the lower surface mesh and upper mesh of surface mesh.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{coef=}} A function expression between {[}0,1{]}.}] \leavevmode
\sphinxAtStartPar
This parameter is used to introduce degenerate element in mesh.

\end{description}

\sphinxAtStartPar
The number of associated points or vertex \(V_{i}^{2d}\) is the integer part of \(coef(V_{i}^{2d}) M\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region=}} This vector is used to initialize the region of tetrahedra.

\sphinxAtStartPar
This vector contains successive pairs of the 2d region number at index \(2i\) and the corresponding 3d region number at index \(2i+1\), like {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{labelmid=}} This vector is used to initialize the 3d labels number of the vertical face or mid face from the 2d label number.

\sphinxAtStartPar
This vector contains successive pairs of the 2d label number at index \(2i\) and the corresponding 3d label number at index \(2i+1\), like {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{labelup=}} This vector is used to initialize the 3d label numbers of the upper/top face from the 2d region number.

\sphinxAtStartPar
This vector contains successive pairs of the 2d region number at index \(2i\) and the corresponding 3d label number at index \(2i+1\), like {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{labeldown=}} Same as the previous case but for the lower/down face label.

\end{itemize}

\sphinxAtStartPar
Moreover, we also add post processing parameters that allow to moving the mesh.
These parameters correspond to parameters \sphinxcode{\sphinxupquote{transfo}}, \sphinxcode{\sphinxupquote{facemerge}} and \sphinxcode{\sphinxupquote{ptmerge}} of the command line \sphinxcode{\sphinxupquote{movemesh}}.

\sphinxAtStartPar
The vector \sphinxcode{\sphinxupquote{region}}, \sphinxcode{\sphinxupquote{labelmid}}, \sphinxcode{\sphinxupquote{labelup}} and \sphinxcode{\sphinxupquote{labeldown}} These vectors are composed of \(n_{l}\) successive pairs of number \(O_i,N_l\) where \(n_{l}\) is the number (label or region) that we want to get.

\sphinxAtStartPar
An example of this command is given in the {\hyperref[\detokenize{examples/mesh-generation:examplebuildlayermesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Build layer mesh example}}}}.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Cube

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Cube.idp}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{func} \PYG{k+kt}{mesh3} \PYG{n}{Cube} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{NN}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{BB}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{x1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{z0} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{z1} \PYG{o}{=} \PYG{n}{BB}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nz} \PYG{o}{=} \PYG{n}{NN}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// 2D mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Thx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// 3D mesh}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{z0}\PYG{p}{,}\PYG{n}{z1}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{labelup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{labeldown} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{return} \PYG{n}{Th}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Unit cube

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NN} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the number of step in each direction}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BB} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the bounding box}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the label of the 6 face left,right, front, back, down, right}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{BB}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_LayerMesh_Example1}.png}
\caption{The mesh of a cube made with \sphinxcode{\sphinxupquote{cube.edp}}}\label{\detokenize{documentation/mesh-generation:meshgenerationlayermeshexample1}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Cone

\sphinxAtStartPar
An axisymtric mesh on a triangle with degenerateness

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{HH} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{nn}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Taxe}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{HH}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Hypo}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{HH}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{RR}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Vert}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{RR}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{HH}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Taxe}\PYG{p}{(}\PYG{n}{HH}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hypo}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{HH}\PYG{o}{*}\PYG{n}{HH}\PYG{o}{+}\PYG{n}{RR}\PYG{o}{*}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Vert}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 3D mesh}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nn}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayersT} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n}{RR}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{c+c1}{//number of layers}
\PYG{k+kt}{real} \PYG{n}{zminT} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmaxT} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{c+c1}{//height 2*pi}
\PYG{k+kt}{func} \PYG{n}{fx} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fy} \PYG{o}{=} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fz} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r4T} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{//trick function:}
\PYG{c+c1}{//The function defined the proportion}
\PYG{c+c1}{//of number layer close to axis with reference MaxLayersT}
\PYG{k+kt}{func} \PYG{n}{deg} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{l+m+mf}{.01}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{/}\PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{HH}\PYG{p}{,} \PYG{l+m+mf}{0.4}\PYG{p}{)}\PYG{o}{/}\PYG{n}{RR}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3T} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{n}{deg}\PYG{p}{,} \PYG{n}{MaxLayersT}\PYG{p}{,}
    \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zminT}\PYG{p}{,} \PYG{n}{zmaxT}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{,} \PYG{n}{fz}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{facemerge}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1T}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2T}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cone}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3T}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_LayerMesh_Example2}.png}
\caption{The mesh of a cone made with \sphinxcode{\sphinxupquote{cone.edp}}}\label{\detokenize{documentation/mesh-generation:meshgenerationlayermeshexample2}}\end{figure}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Buildlayer mesh

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2} \PYG{o}{=} \PYG{l+m+mi}{98}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a box with one hole and two regions}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r3} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{//the triangles of uppper surface mesh}
                        \PYG{c+c1}{//generated by the triangle in the 2D region}
                        \PYG{c+c1}{//of mesh Th of label 4 as label 12}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r4} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{//the triangles of lower surface mesh}
                        \PYG{c+c1}{//generated by the triangle in the 2D region}
                        \PYG{c+c1}{//of mesh Th of label 4 as label 45.}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{r3}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{box 2 regions 1 hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a sphere with TetGen}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{test} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paACQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{test}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere 2 regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Remeshing}
\label{\detokenize{documentation/mesh-generation:id3}}\phantomsection\label{\detokenize{documentation/mesh-generation:meshgenerationchangelabel}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
if an operation on a \sphinxcode{\sphinxupquote{mesh3}} is performed then the same operation is applyed on its surface part (its \sphinxcode{\sphinxupquote{meshS}} associated)
\end{sphinxadmonition}


\paragraph{The command \sphinxstyleemphasis{change}}
\label{\detokenize{documentation/mesh-generation:id4}}
\sphinxAtStartPar
This command changes the label of elements and border elements of a mesh. It’s the equivalent command in 2d mesh case.

\sphinxAtStartPar
Changing the label of elements and border elements will be done using the keyword \sphinxcode{\sphinxupquote{change}}.
The parameters for this command line are for two dimensional and three dimensional cases:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reftet=}} is a vector of integer that contains successive pairs of the old label number to the new label number.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refface=}} is a vector of integer that contains successive pairs of the old region number to new region number.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flabel=}} is an integer function given the new value of the label.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fregion=}} is an integer function given the new value of the region.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rmInternalFaces=}} is a boolean, equal true to remove the internal faces.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rmlfaces=}} is a vector of integer, where triangle’s label given are remove of the mesh

\end{itemize}

\sphinxAtStartPar
These vectors are composed of \(n_{l}\) successive pairs of numbers \(O,N\) where \(n_{l}\) is the number (label or region) that we want to change.
For example, we have:
\begin{equation*}
\begin{split}\mathtt{label} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}
\end{equation*}
\sphinxAtStartPar
An example of use:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the label of Edges 2 in 0.}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// boundary label: 1 \PYGZhy{}\PYGZgt{} 1 bottom, 2 \PYGZhy{}\PYGZgt{} 1 right, 3\PYGZhy{}\PYGZgt{}1 top, 4\PYGZhy{}\PYGZgt{}1 left boundary label is 1}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{re}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{Th2}\PYG{o}{=}\PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{k+kp}{refe}\PYG{o}{=}\PYG{k+kr}{re}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{trunc}}
\label{\detokenize{documentation/mesh-generation:meshgenerationtrunc}}\label{\detokenize{documentation/mesh-generation:id5}}
\sphinxAtStartPar
This operator have been introduce to remove a piece of mesh or/and split all element or for a particular label element
The three named parameter
\sphinxhyphen{} boolean function to keep or remove elements
\sphinxhyphen{} \sphinxcode{\sphinxupquote{split=}} sets the level n of triangle splitting. each triangle is splitted in n × n ( one by default)
\sphinxhyphen{} freefem:\sphinxtitleref{label=}   sets the label number of new boundary item (1 by default)

\sphinxAtStartPar
An example of use

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{int} \PYG{n}{nn}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{cube}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,}\PYG{n}{nn}\PYG{p}{,}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//  remove the small cube \PYGZdl{}]1/2,1[\PYGZca{}2\PYGZdl{}}
\PYG{n}{Th}\PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{z}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{cube}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{movemesh}}
\label{\detokenize{documentation/mesh-generation:id6}}
\sphinxAtStartPar
3D meshes  can be translated, rotated, and deformed using the command line \sphinxcode{\sphinxupquote{movemesh}} as in the 2D case (see {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{section movemesh}}}}).
If \(\Omega\) is tetrahedrized as \(T_{h}(\Omega)\), and \(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\) is the transformation vector then \(\Phi(T_{h})\) is obtained by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{,} \PYG{n}{Phi3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi1}\PYG{p}{,} \PYG{n}{Phi2}\PYG{p}{,} \PYG{n}{Phi3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}  \PYG{p}{(}\PYG{n}{syntax} \PYG{n}{with} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parameters of movemesh in three dimensions are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transfo=}} sets the geometric transformation \(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} sets the integer labels of the tetrahedra.}] \leavevmode
\sphinxAtStartPar
0 by default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} sets the labels of the border faces.}] \leavevmode
\sphinxAtStartPar
This parameter is initialized as the label for the keyword {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{facemerge=}} An integer expression.}] \leavevmode
\sphinxAtStartPar
When you transform a mesh, some faces can be merged.
This parameter equals to one if the merges’ faces is considered.
Otherwise it equals to zero.
By default, this parameter is equal to 1.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge =}} A real expression.}] \leavevmode
\sphinxAtStartPar
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\end{description}

\sphinxAtStartPar
where \(B\) is the smallest axis parallel boxes containing the discretion domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{orientation =}} An integer expression
equal 1, give the oientation of the triangulation, elements must be in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the tetrahedra

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The orientation of tetrahedra are checked by the positivity of its area and automatically corrected during the building of the adjacency.
\end{sphinxadmonition}

\sphinxAtStartPar
An example of this command can be found in the {\hyperref[\detokenize{examples/misc:examplepoissonequation3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s equation 3D example}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cube.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}  \PYG{n}{Nxyz}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]}  \PYG{n}{Bxyz}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{5.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]}  \PYG{n}{Lxyz}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5e4}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{sqrt2}\PYG{o}{=}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n}{Cube}\PYG{p}{(}\PYG{n}{Nxyz}\PYG{p}{,}\PYG{n}{Bxyz}\PYG{p}{,}\PYG{n}{Lxyz}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{,}\PYG{n}{v3}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)}  \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{,}\PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{,}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)} \PYG{p}{(} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)} \PYG{p}{)} \PYG{c+c1}{// EOM}

\PYG{k+kt}{solve} \PYG{n}{Lame}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{,}\PYG{n}{v3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{=}
  \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
            \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{,}\PYG{n}{v3}\PYG{p}{)}
            \PYG{o}{+}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{,}\PYG{n}{v3}\PYG{p}{)} \PYG{p}{)}
              \PYG{p}{)}
  \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)} \PYG{p}{(}\PYG{n}{gravity}\PYG{o}{*}\PYG{n}{v3}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{dmax}\PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{coef}\PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{/}\PYG{n}{dmax}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ref2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// array}
\PYG{k+kt}{mesh3} \PYG{n}{Thm}\PYG{o}{=}\PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u1}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,}\PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,}\PYG{k+kr}{z}\PYG{o}{+}\PYG{n}{u3}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{ref2}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// mesh3 Thm=movemesh3(Th,transfo=[x+u1*coef,y+u2*coef,z+u3*coef],label=ref2); older syntax}
\PYG{n}{Thm}\PYG{o}{=}\PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Thm}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{ref2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{Thm}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coef  amplification = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{coef} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
movemesh doesn’t use the prefix tranfo= {[}.,.,.{]}, the geometric transformation is directly given by  {[}.,.,.{]} in the arguments list


\paragraph{The command \sphinxstyleemphasis{extract}}
\label{\detokenize{documentation/mesh-generation:the-command-extract}}
\sphinxAtStartPar
This command offers the possibility to extract a boundary part of a \sphinxcode{\sphinxupquote{mesh3}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refface}}     , is a vector of integer that contains a list of triangle face references, where the extract function must be apply.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label}}       , is a vector of integer that contains a list of tetrahedra label

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Label numbering}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// extract the surface (boundary) of the cube}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{llabs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{ThS} \PYG{o}{=} \PYG{n+nf}{extract}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{llabs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{buildSurface}}
\label{\detokenize{documentation/mesh-generation:the-command-buildsurface}}
\sphinxAtStartPar
This new function allows to build the surface mesh of a volume mesh, under the condition the surface is the boundary of the volume.
By definition, a \sphinxstylestrong{mesh3} is defined by a list of vertices, tetrahedron elements and triangle border elements. \sphinxstyleemphasis{buildSurface} function create the meshS corresponding, given
the list vertices which are on the border domain, the triangle elements and build the list of edges.
Remark, for a closed surface mesh, the edges list is empty.


\paragraph{The command \sphinxstyleemphasis{movemesh23}}
\label{\detokenize{documentation/mesh-generation:the-command-movemesh23}}
\sphinxAtStartPar
A simple method to tranform a 2D mesh in 3D Surface mesh. The principe is to project a two dimensional domain in a three dimensional space, 2d surface in the (x,y,z)\sphinxhyphen{}space to create a surface mesh 3D, \sphinxstylestrong{meshS}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Since the release 4.2.1, the \sphinxstylestrong{FreeFEM} function movemesh23 returns a meshS type.
\end{sphinxadmonition}

\sphinxAtStartPar
This corresponds to translate, rotate or deforme the domain by a displacement vector of this form \(\mathbf{\Phi(x,y)} = (\Phi1(x,y), \Phi2(x,y), \Phi3(x,y))\).

\sphinxAtStartPar
The result of moving a two dimensional mesh Th2 by this three dimensional displacement is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{o}{*}\PYG{o}{*}\PYG{k+kt}{meshS}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parameters of this command line are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transfo=}} {[}\(\Phi 1\), \(\Phi 2\), \(\Phi 3\){]} sets the displacement vector of transformation \(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} sets an integer label of triangles.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{orientation=}} sets an integer orientation to give the global orientation of the surface of mesh. Equal 1, give a triangulation in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the triangles

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge=}} A real expression.}] \leavevmode
\sphinxAtStartPar
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\end{description}

\sphinxAtStartPar
where \(B\) is the smallest axis, parallel boxes containing the discretized domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.

\end{itemize}

\sphinxAtStartPar
We can do a “gluing” of surface meshes using the process given in {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{Change section}}}}.
An example to obtain a three dimensional mesh using the command line \sphinxcode{\sphinxupquote{tetg}} and \sphinxcode{\sphinxupquote{movemesh23}} is given below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{x10} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x11} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y10} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y11} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{ZZ1min} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1max} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x20} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x21} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y20}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y21}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{ZZ2} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX2} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY2min} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY2max} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x30}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x31}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y30}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{y31}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX3min} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{XX3max} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY3} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ3} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thsq1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{35}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x11}\PYG{o}{\PYGZhy{}}\PYG{n}{x10}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y10}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y11}\PYG{o}{\PYGZhy{}}\PYG{n}{y10}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thsq2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x20}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x21}\PYG{o}{\PYGZhy{}}\PYG{n}{x20}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y20}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y21}\PYG{o}{\PYGZhy{}}\PYG{n}{y20}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thsq3} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x30}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x31}\PYG{o}{\PYGZhy{}}\PYG{n}{x30}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{y30}\PYG{o}{+}\PYG{p}{(}\PYG{n}{y31}\PYG{o}{\PYGZhy{}}\PYG{n}{y30}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D to 3D surface}
\PYG{k+kt}{meshS} \PYG{n}{Th31h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1max}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th31b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1min}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{meshS} \PYG{n}{Th32h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX2}\PYG{p}{,} \PYG{n}{YY2max}\PYG{p}{,} \PYG{n}{ZZ2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th32b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX2}\PYG{p}{,} \PYG{n}{YY2min}\PYG{p}{,} \PYG{n}{ZZ2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{meshS} \PYG{n}{Th33h} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq3}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX3max}\PYG{p}{,} \PYG{n}{YY3}\PYG{p}{,} \PYG{n}{ZZ3}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th33b} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thsq3}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX3min}\PYG{p}{,} \PYG{n}{YY3}\PYG{p}{,} \PYG{n}{ZZ3}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Gluing surfaces}
\PYG{k+kt}{meshS} \PYG{n}{Th33} \PYG{o}{=} \PYG{n}{Th31h} \PYG{o}{+} \PYG{n}{Th31b} \PYG{o}{+} \PYG{n}{Th32h} \PYG{o}{+} \PYG{n}{Th32b} \PYG{o}{+} \PYG{n}{Th33h} \PYG{o}{+} \PYG{n}{Th33b}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th33}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th33}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Tetrahelize the interior of the cube with TetGen}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.0025}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Thfinal} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th33}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thfinal}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thfinal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Build a mesh of a half cylindrical shell of interior radius 1, and exterior radius 2 and a height of 1.5}
\PYG{k+kt}{func} \PYG{n}{mv2x} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{mv2y} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{mv2z} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Thmv2} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Thfinal}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mv2x}\PYG{p}{,} \PYG{n}{mv2y}\PYG{p}{,} \PYG{n}{mv2z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{facemerge}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thmv2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thmv2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{3d Meshing examples}
\label{\detokenize{documentation/mesh-generation:d-meshing-examples}}\label{\detokenize{documentation/mesh-generation:meshing-examples-1}}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Lake

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// 3D mesh}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,}
    \PYG{k+kp}{coef}\PYG{o}{=}\PYG{k+kr}{max}\PYG{p}{(}\PYG{p}{(}\PYG{n}{zmax}\PYG{o}{\PYGZhy{}}\PYG{n}{zmin}\PYG{p}{)}\PYG{o}{/}\PYG{n}{zmax}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,}
    \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,}
    \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,}
    \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{rlow}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Hole region

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0,2pi[}

\PYG{c+c1}{// 3D mesh}
\PYG{c+c1}{//parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//partial derivative of the parametrization}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//construction of the surface of spheres}
\PYG{k+kt}{real} \PYG{n}{Rmin} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{meshS} \PYG{n}{ThSsph} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1min}\PYG{p}{,} \PYG{n}{f2min}\PYG{p}{,} \PYG{n}{f3min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{Rmax} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3max} \PYG{o}{=} \PYG{n}{Rmax}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{meshS} \PYG{n}{ThSsph2} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1max}\PYG{p}{,} \PYG{n}{f2max}\PYG{p}{,} \PYG{n}{f3max}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//gluing meshes}
\PYG{k+kt}{meshS} \PYG{n}{ThS} \PYG{o}{=} \PYG{n}{ThSsph} \PYG{o}{+} \PYG{n}{ThSsph2}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ TetGen call without hole }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{145}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{18}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3fin} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sphere with two regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3fin}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ TetGen call with hole }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{hole} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3finhole} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
    \PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{hole}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sphere with a hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3finhole}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Build a 3d mesh of a cube with a balloon

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//mesh size on sphere}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Meshes}
\PYG{k+kt}{meshS} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{ThS} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{meshS} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThS}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hex\PYGZhy{}Sphere}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ThHS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{voltet = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{voltet} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube with ball}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_CubeSphere1}.png}
\caption{The surface mesh of the hex with internal sphere}\label{\detokenize{documentation/mesh-generation:id50}}\label{\detokenize{documentation/mesh-generation:meshgenerationcubesphere1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_CubeSphere2}.png}
\caption{The tetrahedral mesh of the cube with internal ball}\label{\detokenize{documentation/mesh-generation:id51}}\label{\detokenize{documentation/mesh-generation:meshgenerationcubesphere2}}\end{subfigure}
\caption{Cube sphere}

\end{figure}



\subsection{\sphinxstylestrong{The type meshS in 3 dimension}}
\label{\detokenize{documentation/mesh-generation:the-type-meshs-in-3-dimension}}\label{\detokenize{documentation/mesh-generation:meshstype}}\label{\detokenize{documentation/mesh-generation:CubeSphere}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Since the release 4.2.1, the surface \sphinxcode{\sphinxupquote{mesh3}} object (list of vertices and border elements, without tetahedra elements) is remplaced by \sphinxcode{\sphinxupquote{meshS}} type.
\end{sphinxadmonition}


\subsubsection{Commands for 3d surface mesh generation}
\label{\detokenize{documentation/mesh-generation:commands-for-3d-surface-mesh-generation}}

\paragraph{The command \sphinxstyleemphasis{square3}}
\label{\detokenize{documentation/mesh-generation:the-command-square3}}
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{square3}} like the function \sphinxcode{\sphinxupquote{square}} in 2d is the simple way to a build the unit square plan in the space \(\mathbb{R^3}\).
To use this command, it is necessary to load the pluging \sphinxcode{\sphinxupquote{msh3}} (need \sphinxcode{\sphinxupquote{load "msh3"}}).
A square in 3d consists in building a 2d square which is projected from \(\mathbb{R^2}\) to \(\mathbb{R^3}\).
The parameters of this command line are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
n,m  generates a n×m grid in the unit square

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}.,.,.{]}}} is  {[} \(\Phi 1\), \(\Phi 2\), \(\Phi 3\) {]} is the geometric transformation from \(\mathbb{R^2}\) to \(\mathbb{R^3}\). By default, {[} \(\Phi 1\), \(\Phi 2\), \(\Phi 3\) {]} = {[}x,y,0{]}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{orientation=}}
equal 1, gives the orientation of the triangulation, elements are in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the triangles
it’s the global orientation of the surface 1 extern (\sphinxhyphen{}1 intern)

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
     \PYG{k+kt}{real} \PYG{n}{R} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
     \PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;} \PYG{c+c1}{//}
     \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{R}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{h}\PYG{p}{;}
     \PYG{k+kt}{int} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{r}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{h}\PYG{p}{;}
     \PYG{k+kt}{func} \PYG{n}{torex}\PYG{o}{=} \PYG{p}{(}\PYG{n}{R}\PYG{o}{+}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{func} \PYG{n}{torey}\PYG{o}{=} \PYG{p}{(}\PYG{n}{R}\PYG{o}{+}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{func} \PYG{n}{torez}\PYG{o}{=} \PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}


     \PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n+nf}{square3}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{p}{[}\PYG{n}{torex}\PYG{p}{,}\PYG{n}{torey}\PYG{p}{,}\PYG{n}{torez}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following code generates a \(3\times 4 \times 5\) grid in the unit cube \([0, 1]^3\) with a clock wise triangulation.


\paragraph{surface mesh builders}
\label{\detokenize{documentation/mesh-generation:surface-mesh-builders}}
\sphinxAtStartPar
Adding at the top of a \sphinxstyleemphasis{FreeFEM} script \sphinxcode{\sphinxupquote{include "MeshSurface.idp"}}, constructors of sphere, ellipsoid, surface mesh of a 3d box are available.
\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SurfaceHex(N, B, L, orient)}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
this operator allows to build the surface mesh of a 3d box

\item {} 
\sphinxAtStartPar
int{[}int{]}  N={[}nx,ny,nz{]}; //  the number of seg in the 3 direction

\item {} 
\sphinxAtStartPar
real {[}int,int{]}  B={[}{[}xmin,xmax{]},{[}ymin,ymax{]},{[}zmin,zmax{]}{]}; // bounding bax

\item {} 
\sphinxAtStartPar
int {[}int,int{]}  L={[}{[}1,2{]},{[}3,4{]},{[}5,6{]}{]}; // the label of the 6 face left,right, front, back, down, right

\item {} 
\sphinxAtStartPar
orient the global orientation of the surface 1 extern (\sphinxhyphen{}1 intern),

\item {} 
\sphinxAtStartPar
returns a \sphinxcode{\sphinxupquote{meshS}} type

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ellipsoide (RX, RY, RZ, h, L, OX, OY, OZ, orient)}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
h is the mesh size

\item {} 
\sphinxAtStartPar
L is the label

\item {} 
\sphinxAtStartPar
orient the global orientation of the surface 1 extern (\sphinxhyphen{}1 intern)

\item {} 
\sphinxAtStartPar
OX, OY, OZ are real numbers to give the Ellipsoide center ( optinal, by default is (0,0,0) )

\item {} 
\sphinxAtStartPar
where RX, RY, RZ are real numbers such as the parametric equations of the ellipsoid is:

\item {} 
\sphinxAtStartPar
returns a \sphinxcode{\sphinxupquote{meshS}} type

\end{itemize}

\end{itemize}
\begin{equation*}
\begin{split}\forall u \in [- \frac{\pi}{2},\frac{\pi}{2}  [ \text{ and } v \in [0, 2 \pi], \vectthree{x=\text{Rx } cos(u)cos(v) + \text{Ox }}{y=\text{Ry } cos(u)sin(v) + \text{Oy }}{z = \text{Rz } sin(v)  + \text{Oz }    }\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Sphere(R, h, L, OX, OY, OZ, orient)}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
where R is the raduis of the sphere,

\item {} 
\sphinxAtStartPar
OX, OY, OZ are real numbers to give the Ellipsoide center ( optinal, by default is (0,0,0) )

\item {} 
\sphinxAtStartPar
h is the mesh size  of  the shpere

\item {} 
\sphinxAtStartPar
L is the label the the sphere

\item {} 
\sphinxAtStartPar
orient the global orientation of the surface 1 extern (\sphinxhyphen{}1 intern)

\item {} 
\sphinxAtStartPar
returns a \sphinxcode{\sphinxupquote{meshS}} type

\end{itemize}

\end{itemize}
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{meshS} \PYG{n+nf}{SurfaceHex}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{k+kr}{N}\PYG{p}{,}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{k+kp}{B} \PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{L}\PYG{p}{,}\PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{x0}\PYG{o}{=}\PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{x1}\PYG{o}{=}\PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n+nf}{y0}\PYG{o}{=}\PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{y1}\PYG{o}{=}\PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{z0}\PYG{o}{=}\PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{z1}\PYG{o}{=}\PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{nx}\PYG{o}{=}\PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ny}\PYG{o}{=}\PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{nz}\PYG{o}{=}\PYG{k+kr}{N}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{mesh} \PYG{n}{Thx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{ny}\PYG{p}{,}\PYG{n}{nz}\PYG{p}{,}\PYG{p}{[}\PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{z0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Thy} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{nz}\PYG{p}{,}\PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{z0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh} \PYG{n}{Thz} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refx}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{n}{refX}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}   \PYG{c+c1}{//  Xmin, Ymax faces labels renumbering}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refy}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{n}{refY}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}   \PYG{c+c1}{//  Ymin, Ymax faces labesl renumbering}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{refz}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{n}{refZ}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}   \PYG{c+c1}{//  Zmin, Zmax faces labels renumbering}

    \PYG{k+kt}{meshS} \PYG{n}{Thx0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x0}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refx}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{Thx1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thx}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x1}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refX}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{Thy0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thy}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n+nf}{y0}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refy}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{Thy1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thy}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n+nf}{y1}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refY}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{Thz0} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thz}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{n}{z0}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refz}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{Thz1} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Thz}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{n}{z1}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{+}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{refZ}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{Th}\PYG{o}{=} \PYG{n}{Thx0}\PYG{o}{+}\PYG{n}{Thx1}\PYG{o}{+}\PYG{n}{Thy0}\PYG{o}{+}\PYG{n}{Thy1}\PYG{o}{+}\PYG{n}{Thz0}\PYG{o}{+}\PYG{n}{Thz1}\PYG{p}{;}

 \PYG{k}{return} \PYG{n}{Th}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}

 \PYG{k+kt}{func} \PYG{k+kt}{meshS} \PYG{n+nf}{Ellipsoide} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{RX}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{RY}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{RZ}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{h}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{L}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{Ox}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{Oy}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{Oz}\PYG{p}{,}\PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh}  \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//  \PYGZdl{}]\PYGZbs{}frac\PYGZob{}\PYGZhy{}pi\PYGZcb{}\PYGZob{}2\PYGZcb{},frac\PYGZob{}\PYGZhy{}pi\PYGZcb{}\PYGZob{}2\PYGZcb{}[\PYGZbs{}times]0,2\PYGZbs{}pi[ \PYGZdl{}}
    \PYG{c+c1}{//  a parametrization of a sphere}
    \PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=}\PYG{n}{RX}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=}\PYG{n}{RY}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=}\PYG{n}{RZ}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{//    partiel derivative}
    \PYG{k+kt}{func} \PYG{n}{f1x}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{RX}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f1y}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{RX}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2x}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{RY}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f2y}\PYG{o}{=} \PYG{o}{+}\PYG{n}{RY}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{RZ}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{f3y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+c1}{// the metric on the sphere  \PYGZdl{}  M = DF\PYGZca{}t DF \PYGZdl{}}
    \PYG{k+kt}{func} \PYG{n}{m11}\PYG{o}{=}\PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{m21}\PYG{o}{=}\PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y}\PYG{o}{+}\PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y}\PYG{o}{+}\PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{m22}\PYG{o}{=}\PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{perio}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}  \PYG{c+c1}{// to store the periodic condition}
    \PYG{k+kt}{real} \PYG{n}{hh}\PYG{o}{=}\PYG{n}{h}\PYG{p}{;}\PYG{c+c1}{// hh  mesh size on unite sphere}
    \PYG{k+kt}{real} \PYG{n}{vv}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ref}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{L}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{f2}\PYG{p}{,}\PYG{n}{f3}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{k+kp}{orientation}\PYG{p}{,}\PYG{n}{refface}\PYG{o}{=}\PYG{n}{ref}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ThS}\PYG{o}{=}\PYG{n}{mmgs}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,}\PYG{k+kp}{hmin}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,}\PYG{k+kp}{hmax}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,}\PYG{n}{hgrad}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{return} \PYG{n}{ThS}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}

 \PYG{k+kt}{func} \PYG{k+kt}{meshS} \PYG{n+nf}{Ellipsoide} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{RX}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{RY}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{RZ}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{h}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{L}\PYG{p}{,}\PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{Ellipsoide} \PYG{p}{(}\PYG{n}{RX}\PYG{p}{,}\PYG{n}{RY}\PYG{p}{,}\PYG{n}{RZ}\PYG{p}{,}\PYG{n}{h}\PYG{p}{,}\PYG{n}{L}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{k+kt}{func} \PYG{k+kt}{meshS} \PYG{n+nf}{Sphere}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{R}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{h}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{L}\PYG{p}{,}\PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{Ellipsoide}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{h}\PYG{p}{,}\PYG{n}{L}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{k+kt}{func} \PYG{k+kt}{meshS} \PYG{n+nf}{Sphere}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{R}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{h}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{L}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{Ox}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{Oy}\PYG{p}{,}\PYG{k+kt}{real} \PYG{n}{Oz}\PYG{p}{,}\PYG{k+kt}{int} \PYG{k+kp}{orientation}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{n}{Ellipsoide}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{R}\PYG{p}{,}\PYG{n}{h}\PYG{p}{,}\PYG{n}{L}\PYG{p}{,}\PYG{n}{Ox}\PYG{p}{,}\PYG{n}{Oy}\PYG{p}{,}\PYG{n}{Oz}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\paragraph{2D mesh generators combined with  \sphinxstyleemphasis{movemesh23}}
\label{\detokenize{documentation/mesh-generation:d-mesh-generators-combined-with-movemesh23}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} ‘s meshes can be built by the composition of the \sphinxcode{\sphinxupquote{movemesh23}} command from a 2d mesh generation.
The operation is a projection of a 2d plane in \(\mathbb{R^3}\) following the geometric transformation  {[} \(\Phi 1\), \(\Phi 2\), \(\Phi 3\) {]}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{,}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{,}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{l}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{l}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{l}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{l}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{1.1}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th}\PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{c}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{i}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th}\PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Remeshing}
\label{\detokenize{documentation/mesh-generation:id7}}

\paragraph{The command \sphinxstyleemphasis{trunc}}
\label{\detokenize{documentation/mesh-generation:id8}}
\sphinxAtStartPar
This operator allows to define a \sphinxcode{\sphinxupquote{meshS}} by truncating another one, i.e. by removing triangles, and/or by splitting each triangle by a given positive integer s.
In a FreeFEM script, this function must be called as follows:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meshS}} TS2= \sphinxcode{\sphinxupquote{trunc}} (TS1, boolean function to keep or remove elements, split = s, label = …)

\sphinxAtStartPar
The command has the following arguments:
\begin{itemize}
\item {} 
\sphinxAtStartPar
boolean function to keep or remove elements

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{split=}} sets the level n of triangle splitting. each triangle is splitted in n × n ( one by default)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}}   sets the label number of new boundary item (1 by default)

\end{itemize}

\sphinxAtStartPar
An example of how to call the function

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{R} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;} \PYG{c+c1}{//}
\PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{R}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{h}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{r}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{h}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{torex}\PYG{o}{=} \PYG{p}{(}\PYG{n}{R}\PYG{o}{+}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{torey}\PYG{o}{=} \PYG{p}{(}\PYG{n}{R}\PYG{o}{+}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{torez}\PYG{o}{=} \PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// build a tore}
\PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n+nf}{square3}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{p}{[}\PYG{n}{torex}\PYG{p}{,}\PYG{n}{torey}\PYG{p}{,}\PYG{n}{torez}\PYG{p}{]}\PYG{p}{)} \PYG{p}{;}
\PYG{n}{ThS}\PYG{o}{=}\PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,} \PYG{p}{(}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{z} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{movemesh}}
\label{\detokenize{documentation/mesh-generation:id9}}
\sphinxAtStartPar
Like 2d and 3d type meshes in \sphinxstylestrong{FreeFEM}, \sphinxcode{\sphinxupquote{meshS}} can be translated, rotated or deformated by an application {[}\(\Phi 1\), \(\Phi 2\), \(\Phi 3\){]}.
The image \(T_{h}(\Omega)\) is obtained by the command \sphinxcode{\sphinxupquote{movemeshS}}.

\sphinxAtStartPar
The parameters of movemeshS are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transfo=}} sets the geometric transformation \(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} sets the integer labels of the triangles.}] \leavevmode
\sphinxAtStartPar
0 by default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} sets the labels of the border edges.}] \leavevmode
\sphinxAtStartPar
This parameter is initialized as the label for the keyword {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{edgemerge=}} An integer expression.}] \leavevmode
\sphinxAtStartPar
When you transform a mesh, some triangles can be merged and fix the parameter to 1, else 0
By default, this parameter is equal to 1.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{ptmerge =}} A real expression.}] \leavevmode
\sphinxAtStartPar
When you transform a mesh, some points can be merged.
This parameter is the criteria to define two merging points.
By default, we use
\begin{quote}
\begin{equation*}
\begin{split}ptmerge \: = \: 1e-7 \: \:Vol( B ),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(B\) is the smallest axis parallel boxes containing the discretion domain of \(\Omega\) and \(Vol(B)\) is the volume of this box.
\end{quote}

\end{description}

\end{itemize}
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{orientation =}} An integer expression}] \leavevmode
\sphinxAtStartPar
equal 1, give the oientation of the triangulation, elements must be in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the triangles. It’s the global orientation of the normals at the surface 1 extern (\sphinxhyphen{}1 intern)

\end{description}

\end{itemize}

\sphinxAtStartPar
Example of using

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{meshS} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th2}\PYG{o}{=}\PYG{n}{movemeshS}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th3}\PYG{o}{=}\PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{change}}
\label{\detokenize{documentation/mesh-generation:id10}}
\sphinxAtStartPar
Equivalent for a 2d or 3d mesh, the command \sphinxcode{\sphinxupquote{change}} changes the label of elements and border elements of a \sphinxcode{\sphinxupquote{meshS}}.

\sphinxAtStartPar
The parameters for this command line are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reftri=}} is a vector of integer that contains successive pairs of the old label number to the new label number for elements.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refedge=}} is a vector of integer that contains successive pairs of the old region number to new region number for boundary elements.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flabel=}} is an integer function given the new value of the label.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fregion=}} is an integer function given the new value of the region.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rmledges=}} is a vector of integer, where edge’s label given are remove of the mesh

\end{itemize}

\sphinxAtStartPar
These vectors are composed of \(n_{l}\) successive pairs of numbers \(O,N\) where \(n_{l}\) is the number (label or region) that we want to change.
For example, we have:
\begin{equation*}
\begin{split}\mathtt{label} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}
\end{equation*}

\subsubsection{Link with a mesh3}
\label{\detokenize{documentation/mesh-generation:link-with-a-mesh3}}
\sphinxAtStartPar
In topology and mathematics, the boundary of a subset S of a topological space X is the set of points which can be approached both from S and from the outside of S.
The general definitions to the boundary of a subset S of a topological space X are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the closure of S without the interior of S \(\partial S = S  \backslash \mathring S\).

\item {} 
\sphinxAtStartPar
the intersection of the closure of S with the closure of its complement \(\partial S = S  \cap (X  \backslash S)\).

\item {} 
\sphinxAtStartPar
the set of points p of X such that every neighborhood of p contains at least one point of S and at least one point not of S.

\end{itemize}

\sphinxAtStartPar
More concretely in FreeFEM, the gestion of a 3D mesh is as follows. Let be \(\Omega\) a subset of \(\mathbb{R}^3\) and \(\partial \Omega\) is boundary, the finite element discretization \(\Omega_h\) of this domain gives:
\begin{itemize}
\item {} 
\sphinxAtStartPar
a mesh3 type, denotes Th3, meshing the volume domain. It contains all the nodes, the tetrahedrons   \(\Omega_i\) such as  \(\Omega_h = \cup_i \Omega_i\) and the list of triangles describing the boundary domain

\item {} 
\sphinxAtStartPar
a meshS type, denotes ThS, meshing the boundary of the volume domain. Typically, containing the nodes belonging to the boundary of Th3 and, if it exists the boundary triangles and the edges.

\end{itemize}

\sphinxAtStartPar
Remark: Condition of meshS existence
| In FreeFEM, a meshS can be defined in 2 cases such as:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Th3 \(\subset\) ThS where it exactly describes the bounder of Th3.

\item {} 
\sphinxAtStartPar
a mehS is an explicite surface mesh given by a list of vertices, triangle finite elements and boundary edge elements (can be optional follows the geometry domain)

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Hence, if an input mesh (.msh freefem or .mesh format) contains a list of vertices, tetrahedra, triangles and edges, \sphinxstylestrong{FreeFEM} builds a \sphinxcode{\sphinxupquote{mesh3}} whitch contains explicitly a surface mesh type \sphinxcode{\sphinxupquote{meshS}}.
\end{sphinxadmonition}


\paragraph{The command \sphinxstyleemphasis{Gamma}}
\label{\detokenize{documentation/mesh-generation:the-command-gamma}}
\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{Gamma}} allows to build and manipulate the border mesh independly of a volume mesh such as the surface is described by triangle elements and edges border elements in 3d. Use this function, suppose that the \sphinxcode{\sphinxupquote{mesh3}} object even contains the geometric description of its surface. That means, the input mesh explicitly contains the list of vertices, tetrahedra, triangles and edges. In case where the surface mesh doesn’t exist, before calling \sphinxcode{\sphinxupquote{Gamma}}, must build it by calling the \sphinxcode{\sphinxupquote{buildSurface}} function (see the next function description).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
 \PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
 \PYG{k+kt}{int} \PYG{n}{nvb} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{c+c1}{// Nb boundary vertices}
 \PYG{k+kt}{int} \PYG{n}{ntb} \PYG{o}{=} \PYG{k+kr}{n}\PYG{o}{*}\PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{12}\PYG{p}{;} \PYG{c+c1}{// Nb of Boundary triangle}
 \PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{cube}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildBdMesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// build the surface mesh}
 \PYG{c+c1}{// build Th1, the surface of Th, defined by triangles elements and edges border elements list}
 \PYG{k+kt}{meshS} \PYG{n}{Th1} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{n+nf}{Gamma}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{buildBdMesh}}
\label{\detokenize{documentation/mesh-generation:the-command-buildbdmesh}}
\sphinxAtStartPar
Let Th3 a volume mesh (mesh3 type) ; such as the geometry description is a list of vertices, tetrahedra elements and triangle border elements.
\sphinxstylestrong{FreeFEM} can generate the surface mesh associated to Th3. The intern mechanism of \sphinxstylestrong{FreeFEM} created directly the \sphinxcode{\sphinxupquote{meshS}} associated to Th3 and accessible by the command \sphinxcode{\sphinxupquote{meshS ThS = Th3.Gamma;}}.


\paragraph{The command \sphinxstyleemphasis{savesurfacemesh}}
\label{\detokenize{documentation/mesh-generation:the-command-savesurfacemesh}}
\sphinxAtStartPar
Available for 3d meshes, the command \sphinxcode{\sphinxupquote{savesurfacemesh}} saves the entire surface of a 3d volume \sphinxcode{\sphinxupquote{mesh3}} at the format .mesh.
Two possibilies about the mesh3 surface:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the geometric surface isn’t explicite, that means the \sphinxcode{\sphinxupquote{mesh3}} doesn’t contain surface elements (triangles) and border surface elements (edge). The surface is defined by the border of the volume. Hence, \sphinxcode{\sphinxupquote{savesurfacemesh}} returns the list of vertices and faces of the volume mesh, according to a local numbring at the border mesh.

\item {} 
\sphinxAtStartPar
the geometric surface is explicite and known by the \sphinxcode{\sphinxupquote{mesh3}} type. This may be due to the nature of the data mesh (list of vertices, tetrahedra, triangles, edges) or a surface building by \sphinxstylestrong{FreeFEM} with the calling of \sphinxcode{\sphinxupquote{buildSurface}} operator. In this case, \sphinxcode{\sphinxupquote{savesurfacemesh}} allows to save the real geometry of the surface 3d mesh (list of vertices, triangles, edges)

\end{itemize}

\sphinxAtStartPar
Example of use

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
 \PYG{k+kt}{mesh3} \PYG{n}{Th3}\PYG{o}{=}\PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
 \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{surf.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{savesurfacemesh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{surfreal.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{k+kt}{mesh3} \PYG{n}{ThS3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
 \PYG{k+kt}{meshS} \PYG{n}{ThSS} \PYG{o}{=} \PYG{n}{ThS3}\PYG{p}{.}\PYG{n+nf}{Gamma}\PYG{p}{;}
 \PYG{n}{savesurfacemesh}\PYG{p}{(}\PYG{n}{ThS3}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{surfacesplit.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
 \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{ThSS}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{GammaSplit.mesh}\PYG{l+s}{\PYGZdq{}} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
volume mesh and meshS=NULL

\sphinxAtStartPar
savesurfmesh(Th,filename\_mesh)
write in the file the vertices list and the triangle list (face of the volum mesh) according to a numbering in local surface

\sphinxAtStartPar
savesurfmesh(Th,filename\_points,filename\_faces)
The operation does the same thing that the first exept to


\paragraph{Glue of meshS meshes}
\label{\detokenize{documentation/mesh-generation:glue-of-meshs-meshes}}
\sphinxAtStartPar
A surface 3d mesh can be the result of the generation of several assembled meshes, with caution of the right orientation at the merged interfaces.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kt}{meshS} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshS} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshS} \PYG{n}{Th11} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshS} \PYG{n}{Th22} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshS} \PYG{n}{Th5} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshS} \PYG{n}{Th6} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshS} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1}\PYG{o}{+}\PYG{n}{Th2}\PYG{o}{+}\PYG{n}{Th11}\PYG{o}{+}\PYG{n}{Th22}\PYG{o}{+}\PYG{n}{Th5}\PYG{o}{+}\PYG{n}{Th6}\PYG{p}{;}
     \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbnomanifold}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
For the moment, the case of no manifold mesh are not considered in FreeFEM. To check if the meshS contains no manifold elements, the command \sphinxcode{\sphinxupquote{nbnomanifold}}.
\end{sphinxadmonition}


\subsection{\sphinxstylestrong{The type meshL in 3 dimension}}
\label{\detokenize{documentation/mesh-generation:the-type-meshl-in-3-dimension}}\label{\detokenize{documentation/mesh-generation:meshltype}}

\subsubsection{Commands for 3d curve mesh generation}
\label{\detokenize{documentation/mesh-generation:commands-for-3d-curve-mesh-generation}}

\paragraph{The command \sphinxstyleemphasis{segment}}
\label{\detokenize{documentation/mesh-generation:the-command-segment}}
\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{segment}} is a basic command to define a curve in 3D space.

\sphinxAtStartPar
The parameters of this command line are:
\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
n generates a n subsegments from the unit line

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}.,.,.{]}}} is  {[} \(\Phi 1\), \(\Phi 2\), \(\Phi 3\) {]} is the geometric transformation from \(\mathbb{R^1}\) to \(\mathbb{R^3}\). By default, {[} \(\Phi 1\), \(\Phi 2\), \(\Phi 3\) {]} = {[}x,0,0{]}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{orientation=}}
equal 1, gives the orientation of the triangulation, elements are in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the triangles
it’s the global orientation of the surface 1 extern (\sphinxhyphen{}1 intern)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cleanmesh=}} is a boolean, allowing remove the duplicated nodes

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{removeduplicate=}} is a boolean, allowing remove the duplicated elements and border elements

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{precismesh}} this parameter is the criteria to define two merging points.}] \leavevmode
\sphinxAtStartPar
By default, it value is 1e\sphinxhyphen{}7 and define the smallest axis parallel boxes containing the discretion domain of \(\Omega\)

\end{description}

\end{itemize}

\sphinxAtStartPar
By defaut, the border points are marked by label 1 and 2.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
     \PYG{k+kt}{real} \PYG{n}{R} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
     \PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//}
     \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{R}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{h}\PYG{p}{;}
     \PYG{k+kt}{func} \PYG{n}{torex}\PYG{o}{=} \PYG{p}{(}\PYG{n}{R}\PYG{o}{+}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{func} \PYG{n}{torey}\PYG{o}{=} \PYG{p}{(}\PYG{n}{R}\PYG{o}{+}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{func} \PYG{n}{torez}\PYG{o}{=} \PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{meshL} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{segment}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{p}{[}\PYG{n}{torex}\PYG{p}{,}\PYG{n}{torey}\PYG{p}{,}\PYG{n}{torez}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{removeduplicate}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The following code generates a 10 subsegments from the unit line with a clock wise triangulation, according to the geometric transformation {[}torex,torey,torez{]} and removing the duplicated points/elements


\paragraph{The command \sphinxstyleemphasis{buildmesh}}
\label{\detokenize{documentation/mesh-generation:id11}}
\sphinxAtStartPar
This operator allows to define a curve mesh from multi\sphinxhyphen{}borders.
The domain can be defined by a parametrized curve (keyword \sphinxcode{\sphinxupquote{border}}), such as Th1 in the following example
or piecewise by parametrized curves, such as the construction of the mesh Th2.

\sphinxAtStartPar
The pieces can only intersect at their endpoints, but it is possible to join more than two endpoints.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// conical helix}
\PYG{k+kt}{border} \PYG{n}{E1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{10.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{meshL} \PYG{n}{Th1}\PYG{o}{=}\PYG{n}{buildmeshL}\PYG{p}{(}\PYG{n}{E1}\PYG{p}{(}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{D13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{z}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{meshL} \PYG{n}{Th2}\PYG{o}{=}\PYG{n}{buildmeshL}\PYG{p}{(}\PYG{n}{D01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{D06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Remeshing}
\label{\detokenize{documentation/mesh-generation:id12}}

\paragraph{The command \sphinxstyleemphasis{trunc}}
\label{\detokenize{documentation/mesh-generation:id13}}
\sphinxAtStartPar
This operator allows to define a \sphinxcode{\sphinxupquote{meshL}} by truncating another one, i.e. by removing segments, and/or by splitting each element by a given positive integer s.
Here, an example to use this function:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meshL}} ThL2= \sphinxcode{\sphinxupquote{trunc}} (ThL1, boolean function to keep or remove elements, split = s, label = …)

\sphinxAtStartPar
The command has the following arguments:
\begin{itemize}
\item {} 
\sphinxAtStartPar
boolean function to keep or remove elements

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{split=}} sets the level n of edge splitting, each edge is splitted in n subpart( one by default)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}}   sets the label number of new boundary item (1 by default)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{new2old}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{old2new}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{renum}}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{orientation=}}}] \leavevmode
\sphinxAtStartPar
equal 1, gives the orientation of the triangulation, elements are in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the triangles
it’s the global orientation of the surface 1 extern (\sphinxhyphen{}1 intern)

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cleanmesh=}} is a boolean, allowing remove the duplicated nodes

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{removeduplicate=}} is a boolean, allowing remove the duplicated elements and border elements

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{precismesh}} this parameter is the criteria to define two merging points.}] \leavevmode
\sphinxAtStartPar
By default, it value is 1e\sphinxhyphen{}7 and define the smallest axis parallel boxes containing the discretion domain of \(\Omega\)

\end{description}

\end{itemize}

\sphinxAtStartPar
An example of how to call this function

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{meshL} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{segment}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{(}\PYG{k+kr}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{z} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{movemesh}}
\label{\detokenize{documentation/mesh-generation:id14}}
\sphinxAtStartPar
This is the classical mesh transformation \sphinxstylestrong{FreeFEM} function, \sphinxcode{\sphinxupquote{meshL}} can be deformed by an application {[} \(\Phi 1\), \(\Phi 2\), \(\Phi 3\) {]}.
The image \(T_{h}(\Omega)\) is obtained by the command \sphinxcode{\sphinxupquote{movemeshL}}.

\sphinxAtStartPar
The parameters of movemesh are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{transfo=}} sets the geometric transformation \(\Phi(x,y)=(\Phi1(x,y,z), \Phi2(x,y,z), \Phi3(x,y,z))\)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{refedge=}} sets the integer labels of the triangles.}] \leavevmode
\sphinxAtStartPar
0 by default.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{refpoint=}} sets the labels of the border points.}] \leavevmode
\sphinxAtStartPar
This parameter is initialized as the label for the keyword {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{precismesh}} this parameter is the criteria to define two merging points.}] \leavevmode
\sphinxAtStartPar
By default, it value is 1e\sphinxhyphen{}7 and define the smallest axis parallel boxes containing the discretion domain of \(\Omega\)

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{orientation =}} An integer expression}] \leavevmode
\sphinxAtStartPar
equal 1, give the oientation of the triangulation, elements must be in the reference orientation (counter clock wise)
equal \sphinxhyphen{}1 reverse the orientation of the triangles. It’s the global orientation of the normals at the surface 1 extern (\sphinxhyphen{}1 intern)

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cleanmesh=}} is a boolean, allowing remove the duplicated nodes

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{removeduplicate=}} is a boolean, allowing remove the duplicated elements and border elements

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The definition of the geometric transformation depends on the space dimension of the studied problem. It means that, with curve FEM, it’s possible to treat a real 1D problem (space coordinate is x) then the transformation is given by x: \sphinxhyphen{}\textgreater{}F(x), that means {[}F\_x{]} and F\_y=F\_z=0 in FreeFEM function.
\end{sphinxadmonition}

\sphinxAtStartPar
Example of using

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{;}
\PYG{k+kt}{meshL} \PYG{n}{Th}\PYG{o}{=}\PYG{n}{Sline}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshL} \PYG{n}{Th31}\PYG{o}{=}\PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshL} \PYG{n}{Th32}\PYG{o}{=}\PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshL} \PYG{n}{Th3}\PYG{o}{=}\PYG{n}{Th31}\PYG{o}{+}\PYG{n}{Th32}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The command \sphinxstyleemphasis{change}}
\label{\detokenize{documentation/mesh-generation:id15}}
\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{change}} changes the label of elements and border elements of a \sphinxcode{\sphinxupquote{meshL}}.

\sphinxAtStartPar
The parameters for this command line are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refedge=}} is a vector of integer that contains successive pairs of the old label number to the new label number for elements.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refpoint=}} is a vector of integer that contains successive pairs of the old region number to new region number for boundary elements.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flabel=}} is an integer function given the new value of the label.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fregion=}} is an integer function given the new value of the region.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rmlpoint=}} is a vector of integer, where edge’s label given are remove of the mesh

\end{itemize}

\sphinxAtStartPar
These vectors are composed of \(n_{l}\) successive pairs of numbers \(O,N\) where \(n_{l}\) is the number (label or region) that we want to change.
For example, we have:
\begin{equation*}
\begin{split}\mathtt{label} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ] \\
\mathtt{region} &= [ O_{1}, N_{1}, ..., O_{n_{l}},N_{n_{l}} ]\end{split}
\end{equation*}

\paragraph{The commands \sphinxstyleemphasis{buildBdMesh} and \sphinxstyleemphasis{Gamma}}
\label{\detokenize{documentation/mesh-generation:the-commands-buildbdmesh-and-gamma}}
\sphinxAtStartPar
The command \sphinxcode{\sphinxupquote{Gamma}} allows to extract the border mesh independly of a surface mesh.
With this function, the constructed border mesh contains the full geometric description of th eboundary surface. In case where the border mesh doesn’t exist, before calling \sphinxcode{\sphinxupquote{Gamma}}, must build it by calling the \sphinxcode{\sphinxupquote{buildBdMesh}} function (see the next function description).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildBdMesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// build the border mesh}
\PYG{c+c1}{// build Th1, the border of Th, defined by edges elements and point border elements}
\PYG{k+kt}{meshL} \PYG{n}{Th1} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{.}\PYG{n+nf}{Gamma}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Glue of meshL meshes}
\label{\detokenize{documentation/mesh-generation:glue-of-meshl-meshes}}
\sphinxAtStartPar
An assembling of \sphinxcode{\sphinxupquote{meshL}} is possible thanks to the operator \sphinxcode{\sphinxupquote{+}}. The result returns a \sphinxcode{\sphinxupquote{meshL}}, with caution of the right orientation at the merged interfaces. Here, the function \sphinxcode{\sphinxupquote{checkmesh}} can be called.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kt}{int} \PYG{k+kr}{n}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;}
 \PYG{k+kt}{meshL} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{segment}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
 \PYG{k+kt}{meshL} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{segment}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{k+kt}{meshL} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{segment}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{k+kt}{meshL} \PYG{n}{Th4} \PYG{o}{=} \PYG{n+nf}{segment}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

 \PYG{k+kt}{meshL} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1}\PYG{o}{+}\PYG{n}{Th2}\PYG{o}{+}\PYG{n}{Th3}\PYG{o}{+}\PYG{n}{Th4}\PYG{p}{;}
 \PYG{n}{Th}\PYG{o}{=}\PYG{n}{rebuildBorder}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{ridgeangledetection}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
For the moment, the case of no manifold mesh are not considered in FreeFEM. To check if the meshL contains no manifold elements, the command \sphinxcode{\sphinxupquote{nbnomanifold}}.
\end{sphinxadmonition}


\paragraph{The command extract}
\label{\detokenize{documentation/mesh-generation:id16}}
\sphinxAtStartPar
This operator allows to extract a labeled piece or the entire border of a 2D mesh and project it in 3D. Optionally, a geometic transformation can be applied.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
     \PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
     \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ll}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
     \PYG{k+kt}{meshL} \PYG{n}{ThL} \PYG{o}{=} \PYG{n+nf}{extract}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,}\PYG{n}{refedge}\PYG{o}{=}\PYG{n}{ll}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{The commands \sphinxstyleemphasis{rebuildBorder}}
\label{\detokenize{documentation/mesh-generation:the-commands-rebuildborder}}
\sphinxAtStartPar
This operator, used in the last example, allows to reconstruted the border elements following a special criteria \sphinxcode{\sphinxupquote{ridgeangledetection}}. By default, it value is \(\frac{8}{9}*arctan(1)\approx40°\), the diedral angle for a decahedron.


\subsubsection{The commands \sphinxstyleemphasis{checkmesh}}
\label{\detokenize{documentation/mesh-generation:the-commands-checkmesh}}
\sphinxAtStartPar
This function is avalaible for all 3D meshes. It checkes and validates the a given mesh, allows to remove duplicate vertices and/or elements and border elements. The possible arguments are
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{precismesh=}} this parameter is the criteria to define two merging points.}] \leavevmode
\sphinxAtStartPar
By default, it value is 1e\sphinxhyphen{}7 and define the smallest axis parallel boxes containing the discretion domain of \(\Omega\)

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{removeduplicate=}} is a boolean, allowing remove the duplicated elements and border elements

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rebuildboundary=}} is a boolean, allowing rebuild the border elements (in case of incomplete list given by the mesh)

\end{itemize}

\sphinxAtStartPar
Example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{checkmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{TetGen: A tetrahedral mesh generator}
\label{\detokenize{documentation/mesh-generation:tetgen-a-tetrahedral-mesh-generator}}
\sphinxAtStartPar
TetGen is a software developed by Dr. Hang Si of Weierstrass Institute for Applied Analysis and Stochastics in Berlin, Germany \sphinxcite{bibliography:hang2006}.
TetGen is free for research and non\sphinxhyphen{}commercial use.
For any commercial license utilization, a commercial license is available upon request to Hang Si.

\sphinxAtStartPar
This software is a tetrahedral mesh generator of a three dimensional domain defined by its boundary (a surface).
The input domain takes into account a polyhedral or a piecewise linear complex.
This tetrahedralization is a constrained Delaunay tetrahedralization.

\sphinxAtStartPar
The method used in TetGen to control the quality of the mesh is a Delaunay refinement due to Shewchuk \sphinxcite{bibliography:shewchuk1998}.
The quality measure of this algorithm is the Radius\sphinxhyphen{}Edge Ratio (see Section 1.3.1 \sphinxcite{bibliography:hang2006} for more details).
A theoretical bound of this ratio of the Shewchuk algorithm is obtained for a given complex of vertices, constrained segments and facets of surface mesh, with no input angle less than 90 degrees.
This theoretical bound is 2.0.

\sphinxAtStartPar
The launch of TetGen is done with the keyword \sphinxcode{\sphinxupquote{tetg}}.
The parameters of this command line is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reftet=}} sets the label of tetrahedra.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} is a vector of integers that contains the old labels number at index \(2i\) and the new labels number at index \(2i+1\) of Triangles.}] \leavevmode
\sphinxAtStartPar
This parameter is initialized as a label for the keyword {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationchangelabel}]{\sphinxcrossref{\DUrole{std,std-ref}{change}}}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{switch=}} A string expression.}] \leavevmode
\sphinxAtStartPar
This string corresponds to the command line switch of TetGen see Section 3.2 of \sphinxcite{bibliography:hang2006}.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbofholes=}} Number of holes (default value: “size of \sphinxcode{\sphinxupquote{holelist}} / 3”).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{holelist=}} This array corresponds to \sphinxcode{\sphinxupquote{holelist}} of TetGenio data structure \sphinxcite{bibliography:hang2006}.}] \leavevmode
\sphinxAtStartPar
A real vector of size \sphinxcode{\sphinxupquote{3 * nbofholes}}.
In TetGen, each hole is associated with a point inside this domain.
This vector is \(x_{1}^{h}, y_{1}^{h}, z_{1}^{h}, x_{2}^{h}, y_{2}^{h}, z_{2}^{h}, \cdots,\) where \(x_{i}^{h},y_{i}^{h},z_{i}^{h}\) is the associated point with the \(i^{\mathrm{th}}\) hole.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbofregions=}} Number of regions (default value: “size of \sphinxcode{\sphinxupquote{regionlist}} / 5”).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{regionlist=}} This array corresponds to \sphinxcode{\sphinxupquote{regionlist}} of TetGenio data structure \sphinxcite{bibliography:hang2006}.

\sphinxAtStartPar
The attribute and the volume constraint of region are given in this real vector of size \sphinxcode{\sphinxupquote{5 * nbofregions}}.
The \(i^{\mathrm{th}}\) region is described by five elements: \(x-\)coordinate, \(y-\)coordinate and \(z-\)coordinate of a point inside this domain (\(x_{i},y_{i},z_{i}\)); the attribute (\(at_{i}\)) and the maximum volume for tetrahedra (\(mvol_{i}\)) for this region.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{regionlist}} vector is: \(x_{1}, y_{1}, z_{1}, at_{1}, mvol_{1}, x_{2}, y_{2}, z_{2}, at_{2}, mvol_{2}, \cdots\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nboffacetcl=}} Number of facets constraints “size of \sphinxcode{\sphinxupquote{facetcl}} / 2”).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{facetcl=}} This array corresponds to \sphinxcode{\sphinxupquote{facetconstraintlist}} of TetGenio data structure \sphinxcite{bibliography:hang2006}.

\sphinxAtStartPar
The \(i^{th}\) facet constraint is defined by the facet marker \(Ref_{i}^{fc}\) and the maximum area for faces \(marea_{i}^{fc}\).
The \sphinxcode{\sphinxupquote{facetcl}} array is: \(Ref_{1}^{fc}, marea_{1}^{fc}, Ref_{2}^{fc}, marea_{2}^{fc}, \cdots\).

\sphinxAtStartPar
This parameters has no effect if switch \sphinxcode{\sphinxupquote{q}} is not selected.

\end{itemize}

\sphinxAtStartPar
Principal switch parameters in TetGen:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{p}} Tetrahedralization of boundary.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{q}} Quality mesh generation.}] \leavevmode
\sphinxAtStartPar
The bound of Radius\sphinxhyphen{}Edge Ratio will be given after the option \sphinxcode{\sphinxupquote{q}}.
By default, this value is 2.0.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{a}} Constructs with the volume constraints on tetrahedra.}] \leavevmode
\sphinxAtStartPar
These volumes constraints are defined with the bound of the previous switch \sphinxcode{\sphinxupquote{q}} or in the parameter \sphinxcode{\sphinxupquote{regionlist}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{A}} Attributes reference to region given in the \sphinxcode{\sphinxupquote{regionlist}}.}] \leavevmode
\sphinxAtStartPar
The other regions have label 0.

\end{description}

\sphinxAtStartPar
The option \sphinxcode{\sphinxupquote{AA}} gives a different label at each region.
This switch works with the option \sphinxcode{\sphinxupquote{p}}.
If option \sphinxcode{\sphinxupquote{r}} is used, this switch has no effect.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{r}} Reconstructs and Refines a previously generated mesh.}] \leavevmode
\sphinxAtStartPar
This character is only used with the command line \sphinxcode{\sphinxupquote{tetgreconstruction}}.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Y}} This switch preserves the mesh on the exterior boundary.

\sphinxAtStartPar
This switch must be used to ensure a conformal mesh between two adjacent meshes.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{YY}} This switch preserves the mesh on the exterior and interior boundary.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C}} The consistency of the result’s mesh is testing by TetGen.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CC}} The consistency of the result’s mesh is testing by TetGen and also constrained checks of Delaunay mesh (if \sphinxcode{\sphinxupquote{p}} switch is selected) or the consistency of Conformal Delaunay (if \sphinxcode{\sphinxupquote{q}} switch is selected).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{V}} Give information of the work of TetGen.}] \leavevmode
\sphinxAtStartPar
More information can be obtained in specified \sphinxcode{\sphinxupquote{VV}} or \sphinxcode{\sphinxupquote{VVV}}.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Q}} Quiet: No terminal output except errors

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{M}} The coplanar facets are not merging.

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{T}} Sets a tolerance for coplanar test.}] \leavevmode
\sphinxAtStartPar
The default value is \(1e-8\).

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}} Intersections of facets are detected.

\end{itemize}

\sphinxAtStartPar
To obtain a tetrahedral mesh with TetGen, we need the surface mesh of a three dimensional domain.
We now give the command line in \sphinxstylestrong{FreeFEM} to construct these meshes.

\sphinxAtStartPar
\sphinxstylestrong{The keyword tetgtransfo}

\sphinxAtStartPar
This keyword corresponds to a composition of command line \sphinxcode{\sphinxupquote{tetg}} and \sphinxcode{\sphinxupquote{movemesh23}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th3surf}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Th3surf = movemesh23(Th2, transfo={[}Phi(1), Phi(2), Phi(3){]})}} and \sphinxcode{\sphinxupquote{Th2}} is the input two dimensional mesh of \sphinxcode{\sphinxupquote{tetgtransfo}}.

\sphinxAtStartPar
The parameters of this command line are, on one hand, the parameters \sphinxcode{\sphinxupquote{label}}, \sphinxcode{\sphinxupquote{switch}}, \sphinxcode{\sphinxupquote{regionlist}}, \sphinxcode{\sphinxupquote{nboffacetcl}}, \sphinxcode{\sphinxupquote{facetcl}} of keyword \sphinxcode{\sphinxupquote{tetg}} and on the other hand, the parameter \sphinxcode{\sphinxupquote{ptmerge}} of keyword \sphinxcode{\sphinxupquote{movemesh23}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
To use \sphinxcode{\sphinxupquote{tetgtransfo}}, the result’s mesh of \sphinxcode{\sphinxupquote{movemesh23}} must be a closed surface and define one region only. Therefore, the parameter \sphinxcode{\sphinxupquote{regionlist}} is defined for one region.

\sphinxAtStartPar
An example of this keyword can be found in line 61 of the {\hyperref[\detokenize{examples/mesh-generation:examplebuildlayermesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Build layer mesh example}}}}.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{The keyword tetgconvexhull}

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM}, using TetGen, is able to build a tetrahedralization from a set of points.
This tetrahedralization is a Delaunay mesh of the convex hull of the set of points.

\sphinxAtStartPar
The coordinates of the points can be initialized in two ways.
The first is a file that contains the coordinate of points \(X_{i}=(x_{i}, y_{i}, z_{i})\).
This file is organized as follows:
\begin{equation*}
\begin{split}\begin{array}{ccc}
n_{v} & & \\
x_{1} & y_{1} & z_{1} \\
x_{2} & y_{2} & z_{2} \\
\vdots &\vdots & \vdots \\
x_{n_v} & y_{n_v} & z_{n_v}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The second way is to give three arrays that correspond respectively to the \(x-\)coordinates, \(y-\)coordinates and \(z-\)coordinates.

\sphinxAtStartPar
The parameters of this command line are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{switch=}} A string expression.}] \leavevmode
\sphinxAtStartPar
This string corresponds to the command line \sphinxcode{\sphinxupquote{switch}} of TetGen see Section 3.2 of \sphinxcite{bibliography:hang2006}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{reftet=}} An integer expression.}] \leavevmode
\sphinxAtStartPar
Set the label of tetrahedra.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} An integer expression.}] \leavevmode
\sphinxAtStartPar
Set the label of triangles.

\end{description}

\end{itemize}

\sphinxAtStartPar
In the string \sphinxcode{\sphinxupquote{switch}}, we can’t used the option \sphinxcode{\sphinxupquote{p}} and \sphinxcode{\sphinxupquote{q}} of TetGen.


\subsubsection{Reconstruct/Refine a 3d mesh with TetGen}
\label{\detokenize{documentation/mesh-generation:reconstruct-refine-a-3d-mesh-with-tetgen}}
\sphinxAtStartPar
Meshes in three dimension can be refined using TetGen with the command line \sphinxcode{\sphinxupquote{tetgreconstruction}}.

\sphinxAtStartPar
The parameter of this keyword are
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{region=}} an integer array that changes the region number of tetrahedra.}] \leavevmode
\sphinxAtStartPar
This array is defined as the parameter \sphinxcode{\sphinxupquote{reftet}} in the keyword \sphinxcode{\sphinxupquote{change}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{label=}} an integer array that changes the label of boundary triangles.}] \leavevmode
\sphinxAtStartPar
This array is defined as the parameter \sphinxcode{\sphinxupquote{label}} in the keyword \sphinxcode{\sphinxupquote{change}}.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{sizeofvolume=}} a reel function.}] \leavevmode
\sphinxAtStartPar
This function constraints the volume size of the tetrahedra in the domain (see {\hyperref[\detokenize{documentation/mesh-generation:meshfirstisotropemeshadaptation}]{\sphinxcrossref{\DUrole{std,std-ref}{Isotrope mesh adaption section}}}} to build a 3d adapted mesh).

\end{description}

\end{itemize}

\sphinxAtStartPar
The parameters \sphinxcode{\sphinxupquote{switch}}, \sphinxcode{\sphinxupquote{nbofregions}}, \sphinxcode{\sphinxupquote{regionlist}}, \sphinxcode{\sphinxupquote{nboffacetcl}} and \sphinxcode{\sphinxupquote{facetcl}} of the command line which call TetGen (\sphinxcode{\sphinxupquote{tetg}}) is used for \sphinxcode{\sphinxupquote{tetgrefine}}.

\sphinxAtStartPar
In the parameter \sphinxcode{\sphinxupquote{switch=}}, the character \sphinxcode{\sphinxupquote{r}} should be used without the character \sphinxcode{\sphinxupquote{p}}.

\sphinxAtStartPar
For instance, see the manual of TetGen \sphinxcite{bibliography:hang2006} for effect of \sphinxcode{\sphinxupquote{r}} to other character.

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{regionlist}} defines a new volume constraint in the region.
The label in the \sphinxcode{\sphinxupquote{regionlist}} will be the previous label of region.

\sphinxAtStartPar
This parameter and \sphinxcode{\sphinxupquote{nbofregions}} can’t be used with the parameter \sphinxcode{\sphinxupquote{sizeofvolume}}.

\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/3d/refinesphere.edp}{**Example refinesphere.edp**}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{//  \PYGZdl{}]\PYGZbs{}frac\PYGZob{}\PYGZhy{}pi\PYGZcb{}\PYGZob{}2\PYGZcb{},frac\PYGZob{}\PYGZhy{}pi\PYGZcb{}\PYGZob{}2\PYGZcb{}[\PYGZbs{}times]0,2\PYGZbs{}pi[ \PYGZdl{}}
\PYG{c+c1}{//  a parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//  partiel derivative of the parametrization DF}
\PYG{k+kt}{func} \PYG{n}{f1x}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// \PYGZdl{}  M = DF\PYGZca{}t DF \PYGZdl{}}
\PYG{k+kt}{func} \PYG{n}{m11}\PYG{o}{=}\PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21}\PYG{o}{=}\PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y}\PYG{o}{+}\PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y}\PYG{o}{+}\PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22}\PYG{o}{=}\PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{perio}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{hh}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,}\PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{c+c1}{// construction of the surface of spheres}
\PYG{k+kt}{real} \PYG{n}{Rmin}  \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3min} \PYG{o}{=} \PYG{n}{Rmin}\PYG{o}{*}\PYG{n}{f3}\PYG{p}{;}

\PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1min}\PYG{p}{,}\PYG{n}{f2min}\PYG{p}{,}\PYG{n}{f3min}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mi}{145}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph}\PYG{o}{=}\PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,}\PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paAAQYY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newlabel} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{145}\PYG{p}{,}\PYG{l+m+mi}{18}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domainrefine} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mi}{145}\PYG{p}{,}\PYG{l+m+mf}{0.0001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sphrefine}\PYG{o}{=}\PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{,}\PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{newlabel}\PYG{p}{,}\PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domainrefine}\PYG{p}{,}\PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{l+m+mf}{0.0001}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{newlabel2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{145}\PYG{p}{,}\PYG{l+m+mi}{53}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fsize} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{z}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sphrefine2}\PYG{o}{=}\PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{,}\PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{newlabel2}\PYG{p}{,}\PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{n}{fsize}\PYG{p}{)}\PYG{p}{;}

 \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{Th3sph}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
 \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphererefinedomain}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Th3sphrefine}\PYG{p}{)}\PYG{p}{;}
 \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphererefinelocal}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Th3sphrefine2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// FFCS: testing 3d plots}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3sphrefine}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3sphrefine2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Read/Write Statements for meshes}
\label{\detokenize{documentation/mesh-generation:read-write-statements-for-meshes}}\label{\detokenize{documentation/mesh-generation:meshdatastructurereadwrite}}

\subsubsection{2d case}
\label{\detokenize{documentation/mesh-generation:d-case}}

\paragraph{format of  mesh data}
\label{\detokenize{documentation/mesh-generation:format-of-mesh-data}}
\sphinxAtStartPar
Users who want to read a triangulation made elsewhere should see the structure of the file generated below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2}\PYG{o}{=}\PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The mesh is shown on \hyperref[\detokenize{documentation/mesh-generation:figbuildmesh}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:figbuildmesh}}}.

\sphinxAtStartPar
The information about \sphinxcode{\sphinxupquote{Th}} are saved in the file \sphinxcode{\sphinxupquote{mesh.msh}} whose structure is shown on \hyperref[\detokenize{documentation/mesh-generation:tabmeshstructure}]{Table \ref{\detokenize{documentation/mesh-generation:tabmeshstructure}}}.
An external file contains a mesh at format .mesh can be read by the ommand \sphinxcode{\sphinxupquote{readmesh(file\_name)}}.

\sphinxAtStartPar
There, \(n_v\) denotes the number of vertices, \(n_t\) the number of triangles and \(n_s\) the number of edges on boundary.

\sphinxAtStartPar
For each vertex \(q^i,\, i=1,\cdots,n_v\), denoted by \((q^i_x,q^i_y)\) the \(x\)\sphinxhyphen{}coordinate and \(y\)\sphinxhyphen{}coordinate.

\sphinxAtStartPar
Each triangle \(T_k, k=1,\cdots,n_t\) has three vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}\) that are oriented counter\sphinxhyphen{}clockwise.

\sphinxAtStartPar
The boundary consists of 10 lines \(L_i,\, i=1,\cdots,10\) whose end points are \(q^{i_1},\, q^{i_2}\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MeshGeneration_Data}.png}
\caption{Mesh by \sphinxcode{\sphinxupquote{buildmesh(C(10))}}}\label{\detokenize{documentation/mesh-generation:figbuildmesh}}\end{figure}

\sphinxAtStartPar
In the \hyperref[\detokenize{documentation/mesh-generation:figbuildmesh}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:figbuildmesh}}}, we have the following.

\sphinxAtStartPar
\(n_v=14, n_t=16, n_s=10\)

\sphinxAtStartPar
\(q^1=(-0.309016994375, 0.951056516295)\)

\sphinxAtStartPar
\(\dots\)

\sphinxAtStartPar
\(q^{14}=(-0.309016994375, -0.951056516295)\)

\sphinxAtStartPar
The vertices of \(T_1\) are \(q^9, q^{12},\, q^{10}\).

\sphinxAtStartPar
\(\dots\)

\sphinxAtStartPar
The vertices of \(T_{16}\) are \(q^9, q^{10}, q^{6}\).

\sphinxAtStartPar
The edge of the 1st side \(L_1\) are \(q^6, q^5\).

\sphinxAtStartPar
\(\dots\)

\sphinxAtStartPar
The edge of the 10th side \(L_{10}\) are \(q^{10}, q^6\).


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{The structure of \sphinxstyleliteralintitle{\sphinxupquote{mesh\_sample.msh}}}\label{\detokenize{documentation/mesh-generation:tabmeshstructure}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Content of the file
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
14 16 10
&
\sphinxAtStartPar
\(n_v\quad n_t\quad n_e\)
\\
\hline
\sphinxAtStartPar
\sphinxhyphen{}0.309016994375 0.951056516295 1

\sphinxAtStartPar
0.309016994375 0.951056516295 1

\sphinxAtStartPar
…

\sphinxAtStartPar
\sphinxhyphen{}0.309016994375 \sphinxhyphen{}0.951056516295 1
&
\sphinxAtStartPar
\(q^1_x\quad q^1_y\quad\) boundary label \(=1\)

\sphinxAtStartPar
\(q^2_x\quad q^2_y\quad\) boundary label \(=1\)

\sphinxAtStartPar
…

\sphinxAtStartPar
\(q^{14}_x\quad q^{14}_y\quad\) boundary label \(=1\)
\\
\hline
\sphinxAtStartPar
9 12 10 0

\sphinxAtStartPar
5 9 6 0

\sphinxAtStartPar
…

\sphinxAtStartPar
9 10 6 0
&
\sphinxAtStartPar
\(1_1\quad 1_2\quad 1_3\quad\) region label \(=0\)

\sphinxAtStartPar
\(2_1\quad 2_2\quad 2_3\quad\) region label \(=0\)

\sphinxAtStartPar
…

\sphinxAtStartPar
\(16_1\quad 16_2\quad 16_3\quad\) region label \(=0\)
\\
\hline
\sphinxAtStartPar
6 5 1

\sphinxAtStartPar
5 2 1

\sphinxAtStartPar
…

\sphinxAtStartPar
10 6 1
&
\sphinxAtStartPar
\(1_1\quad 1_2\quad\) boundary label \(=1\)

\sphinxAtStartPar
\(2_1\quad 2_2\quad\) boundary label \(=1\)

\sphinxAtStartPar
…

\sphinxAtStartPar
\(10_1\quad 10_2\quad\) boundary label \(=1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} there are many mesh file formats available for communication with other tools such as \sphinxcode{\sphinxupquote{emc2}}, \sphinxcode{\sphinxupquote{modulef}}, … (see {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh format chapter}}}} ).

\sphinxAtStartPar
The extension of a file implies its format.
More details can be found on the file format .msh in the article by F. Hecht “bamg : a bidimensional anisotropic mesh generator” \sphinxcite{bibliography:hecht1998-2}.

\sphinxAtStartPar
A mesh file can be read into \sphinxstylestrong{FreeFEM} except that the names of the borders are lost and only their reference numbers are kept.
So these borders have to be referenced by the number which corresponds to their order of appearance in the program, unless this number is overwritten by the keyword \sphinxcode{\sphinxupquote{label}}. Here are some examples:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{ceiling}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n+nf}{floor}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ceiling}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//save mesh in different formats}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.am\PYGZus{}fmt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format \PYGZdq{}formated Marrocco\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format database db mesh \PYGZdq{}bamg\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format freefem}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.nopo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// modulef format}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{femp1}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{//save the fespace function in a file}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//the file is automatically closed at the end of the block}
\PYG{c+c1}{//read a file and put it in a fespace function}
\PYG{p}{\PYGZob{}}
  \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//the file is equally automatically closed}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{g}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2}
\PYG{c+c1}{//read the mesh for freefem format saved mesh}
\PYG{k+kt}{mesh} \PYG{n}{th2} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace 2}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{//solve:}
\PYG{c+c1}{//  \PYGZdl{}u + \PYGZbs{}Delta u = g\PYGZdl{} in \PYGZdl{}\PYGZbs{}Omega \PYGZdl{}}
\PYG{c+c1}{//  \PYGZdl{}u=0\PYGZdl{} on \PYGZdl{}\PYGZbs{}Gamma\PYGZus{}1\PYGZdl{}}
\PYG{c+c1}{//  \PYGZdl{}\PYGZbs{}frac\PYGZob{}\PYGZbs{}partial u \PYGZcb{}\PYGZob{}\PYGZbs{}partial n\PYGZcb{} = g\PYGZdl{} on \PYGZdl{}\PYGZbs{}Gamma\PYGZus{}2\PYGZdl{}}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
  \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{g}\PYG{o}{*}\PYG{n}{v}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{g}\PYG{o}{*}\PYG{n}{v}
  \PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th2}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Input/output for a mesh}
\label{\detokenize{documentation/mesh-generation:input-output-for-a-mesh}}\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{readmesh}

\end{itemize}
\begin{description}
\item[{The function \sphinxcode{\sphinxupquote{readmesh}} allows to build a \sphinxcode{\sphinxupquote{mesh}} from a data file}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n}{readmeshS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thff} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thff.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// FreeFEM format}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savemesh}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{savemesh}} allows to export a \sphinxcode{\sphinxupquote{mesh}}}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Thff}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Thff.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{// FreeFEM format}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format freefem  savemesh(th, \PYGZdq{}toto.am\PYGZus{}fmt\PYGZdq{}); // format \PYGZdq{}formated Marrocco\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// format database db mesh \PYGZdq{}bamg\PYGZdq{}}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.nopo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// modulef format}
\PYG{c+c1}{// allows to save the 2d mesh with the 3rd space coordinate as a scalar solution for visualise}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{n}{u}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//  save surface mesh for medit, see for example minimal\PYGZhy{}surf.edp}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{medit mm;rm mm.bb mm.faces mm.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{vtkloadS}

\end{itemize}

\end{description}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{vtkload}} allows to build a \sphinxcode{\sphinxupquote{mesh}} from a data mesh at vtk format mesh
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n}{vtkloadS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymesh.vtk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savevtk}

\end{itemize}
\begin{description}
\item[{The function \sphinxcode{\sphinxupquote{savevtk}} allows to export a \sphinxcode{\sphinxupquote{mesh}} to a data mesh at vtk format mesh}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
 \PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.vtk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{gmshload}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{gmshloadS}} allows to build a \sphinxcode{\sphinxupquote{mesh}} from a data mesh file at formatmsh (GMSH)}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{gmshload}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savegmsh}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{savegmsh}} allows to export a \sphinxcode{\sphinxupquote{mesh}} to a data mesh msh (GMSH)}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{savegmsh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{description}


\subsubsection{3d case}
\label{\detokenize{documentation/mesh-generation:id27}}

\paragraph{format of  mesh data}
\label{\detokenize{documentation/mesh-generation:id28}}
\sphinxAtStartPar
In three dimensions, the file mesh format supported for input and output files by \sphinxstylestrong{FreeFEM} are the extension .msh and .mesh.
These formats are described in the {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.

\sphinxAtStartPar
\sphinxstylestrong{Extension file .msh} The structure of the files with extension .msh in 3D is given by:
\begin{equation*}
\begin{split}\begin{array}{cccccc}
    n_v & n_{tet} & n_{tri} & & \\
    q^1_x & q^1_y & q^1_z & Vertex label & \\
    q^2_x & q^2_y & q^2_z & Vertex label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    q^{n_v}_x & q^{n_v}_y & q^{n_v}_z & Vertex label & \\
    1_1 & 1_2 & 1_3 & 1_4 & region label \\
    2_1 & 2_2 & 2_3 & 2_4 & region label \\
    \vdots & \vdots & \vdots & \vdots & \vdots \\
    (n_{tet})_1 & (n_{tet})_2 & (n_{tet})_3 & (n_{tet})_4 & region label \\
    1_1 & 1_2 & 1_3 & boundary label & \\
    2_1 & 2_2 & 2_3 & boundary label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    (n_tri)_{1} & (n_{tri})_2 & (n_{tri})_3 & boundary label & \\
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
In this structure, \(n_v\) denotes the number of vertices, \(n_{tet}\) the number of tetrahedra and \(n_{tri}\) the number of triangles.

\sphinxAtStartPar
For each vertex \(q^i,\, i=1,\cdots,n_v\), we denote by \((q^i_x,q^i_y,q^i_z)\) the \(x\)\sphinxhyphen{}coordinate, the \(y\)\sphinxhyphen{}coordinate and the \(z\)\sphinxhyphen{}coordinate.

\sphinxAtStartPar
Each tetrahedra \(T_k, k=1,\cdots,n_{tet}\) has four vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}\).

\sphinxAtStartPar
The boundary consists of a union of triangles.
Each triangle \(tri_j, j=1,\cdots,n_{tri}\) has three vertices \(q^{j_1},\, q^{j_2},\,q^{j_3}\).

\sphinxAtStartPar
\sphinxstylestrong{extension file .mesh} The data structure for a three dimensional mesh is composed of the data structure presented in {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}} and a data structure for the tetrahedra. The tetrahedra of a three dimensional mesh are referred using the following field:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Tetrahedra
NbTetrahedra
Vertex1 Vertex2 Vertex3 Vertex4 Label
...
Vertex1 Vertex2 Vertex3 Vertex4 Label
Triangles
NbTriangles
Vertex1 Vertex2 Vertex3 Label
...
Vertex1 Vertex2 Vertex3 Label
\end{sphinxVerbatim}

\sphinxAtStartPar
This field is express with the notation of {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.


\paragraph{Input/output for a mesh3}
\label{\detokenize{documentation/mesh-generation:input-output-for-a-mesh3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{readmesh3}

\end{itemize}
\begin{description}
\item[{The function \sphinxcode{\sphinxupquote{readmesh3}} allows to build a \sphinxcode{\sphinxupquote{mesh3}} from a data file}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th3}\PYG{o}{=}\PYG{n+nf}{readmesh3}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3ff} \PYG{o}{=} \PYG{n+nf}{readmesh3}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3ff.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// FreeFEM format}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savemesh}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{savemesh}} allows to export a \sphinxcode{\sphinxupquote{mesh3}}}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th3ff}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3ff.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{// FreeFEM format}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{vtkload3}

\end{itemize}

\end{description}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{vtkload3}} allows to build a \sphinxcode{\sphinxupquote{mesh3}} from a data mesh at vtk format mesh
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh3} \PYG{n}{Th3}\PYG{o}{=}\PYG{n}{vtkloadS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymesh.vtk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savevtk}

\end{itemize}
\begin{description}
\item[{The function \sphinxcode{\sphinxupquote{savevtk}} allows to export a \sphinxcode{\sphinxupquote{mesh3}} to a data mesh at vtk format mesh}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
 \PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3.vtk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{gmshload3}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{gmshload3}} allows to build a \sphinxcode{\sphinxupquote{mesh3}} from a data mesh file at formatmsh (GMSH)}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh3} \PYG{n}{Th3}\PYG{o}{=}\PYG{n+nf}{gmshload3}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savegmsh}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{savegmsh}} allows to export a \sphinxcode{\sphinxupquote{mesh3}} to a data mesh msh (GMSH)}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{savegmsh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{description}


\subsubsection{Surface 3d case}
\label{\detokenize{documentation/mesh-generation:surface-3d-case}}

\paragraph{format of  mesh data}
\label{\detokenize{documentation/mesh-generation:id29}}
\sphinxAtStartPar
Like 2d and 3d, the input and output format files supported by \sphinxstylestrong{FreeFEM} are the extension .msh and .mesh.
These formats are described in the {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.

\sphinxAtStartPar
\sphinxstylestrong{Extension file .msh} The structure of the files with extension .msh in surface 3D is given by:
\begin{equation*}
\begin{split}\begin{array}{cccccc}
    n_v & n_{tri} & n_{edges} & & \\
    q^1_x & q^1_y & q^1_z & Vertex label & \\
    q^2_x & q^2_y & q^2_z & Vertex label & \\
    \vdots & \vdots & \vdots & \vdots & \\
    q^{n_v}_x & q^{n_v}_y & q^{n_v}_z & Vertex label & \\
    1_1 & 1_2 & 1_3  & region label \\
    2_1 & 2_2 & 2_3  & region label \\
    \vdots & \vdots & \vdots  & \vdots \\
    (n_{tri})_1 & (n_{tri})_2 & (n_{tri})_3 & region label \\
    1_1 & 1_2 & boundary label & \\
    2_1 & 2_2 & boundary label & \\
    \vdots &  \vdots & \vdots & \\
    (n_edge)_{1} & (n_{edge})_2 & boundary label & \\
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
In this structure, \(n_v\) denotes the number of vertices, \(n_{tet}\) the number of tetrahedra and \(n_{tri}\) the number of triangles.

\sphinxAtStartPar
For each vertex \(q^i,\, i=1,\cdots,n_v\), we denote by \((q^i_x,q^i_y,q^i_z)\) the \(x\)\sphinxhyphen{}coordinate, the \(y\)\sphinxhyphen{}coordinate and the \(z\)\sphinxhyphen{}coordinate.

\sphinxAtStartPar
Each tetrahedra \(T_k, k=1,\cdots,n_{tet}\) has four vertices \(q^{k_1},\, q^{k_2},\,q^{k_3}, \,q^{k_4}\).

\sphinxAtStartPar
The boundary consists of a union of triangles.
Each triangle \(be_j, j=1,\cdots,n_{tri}\) has three vertices \(q^{j_1},\, q^{j_2},\,q^{j_3}\).

\sphinxAtStartPar
\sphinxstylestrong{extension file .mesh} The data structure for a three dimensional mesh is composed of the data structure presented in {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}} and a data structure for the tetrahedra. The tetrahedra of a three dimensional mesh are referred using the following field:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
MeshVersionFormatted \PYG{l+m}{2}
Dimension \PYG{l+m}{3}

Vertices
NbVertices
\PYG{o}{(}v0\PYG{o}{)}x \PYG{o}{(}v0\PYG{o}{)}y \PYG{o}{(}v0\PYG{o}{)}z
...
\PYG{o}{(}vn\PYG{o}{)}x \PYG{o}{(}vn\PYG{o}{)}y \PYG{o}{(}vn\PYG{o}{)}z

Triangles
NbTriangles
Vertex1 Vertex2 Vertex3 Label
...
Vertex1 Vertex2 Vertex3 Label

Edges
NbEdges
Vertex1 Vertex2 Label
...
Vertex1 Vertex2 Label

End
\end{sphinxVerbatim}

\sphinxAtStartPar
This field is express with the notation of {\hyperref[\detokenize{documentation/developers:meshfiledatastructure}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Format section}}}}.


\paragraph{Input/output for a meshS}
\label{\detokenize{documentation/mesh-generation:input-output-for-a-meshs}}\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{readmesh3}

\end{itemize}
\begin{description}
\item[{The function \sphinxcode{\sphinxupquote{readmeshS}} allows to build a \sphinxcode{\sphinxupquote{meshS}} from a data file}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n}{readmeshS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThS.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{Th3ff} \PYG{o}{=} \PYG{n}{readmeshS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThSff.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// FreeFEM format}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savemesh}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{savemesh}} allows to export a \sphinxcode{\sphinxupquote{meshS}}}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThS.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{ThSff}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThSff.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{// FreeFEM format}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{vtkloadS}

\end{itemize}

\end{description}

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{vtkloadS}} allows to build a \sphinxcode{\sphinxupquote{meshS}} from a data mesh at vtk format mesh
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n}{vtkloadS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymesh.vtk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savevtk}

\end{itemize}
\begin{description}
\item[{The function \sphinxcode{\sphinxupquote{savevtk}} allows to export a \sphinxcode{\sphinxupquote{meshS}} to a data mesh at vtk format mesh}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
 \PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThS.vtk}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ThS}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{gmshloadS}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{gmshloadS}} allows to build a \sphinxcode{\sphinxupquote{meshS}} from a data mesh file at formatmsh (GMSH)}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{meshS} \PYG{n}{ThS}\PYG{o}{=}\PYG{n}{gmshloadS}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mymesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
the command \sphinxstyleemphasis{savegmsh}

\end{itemize}

\item[{The function \sphinxcode{\sphinxupquote{savegmsh}} allows to export a \sphinxcode{\sphinxupquote{meshS}} to a data mesh msh (GMSH)}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
    \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{savegmsh}\PYG{p}{(}\PYG{n}{ThS}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{description}


\subsection{Medit}
\label{\detokenize{documentation/mesh-generation:medit}}
\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{medit}} allows to display a mesh alone or a mesh and one or several functions defined on the mesh using the Pascal Frey’s freeware \sphinxcode{\sphinxupquote{medit}}.
\sphinxcode{\sphinxupquote{medit}} opens its own window and uses OpenGL extensively.
Naturally to use this command \sphinxcode{\sphinxupquote{medit}} must be installed.

\sphinxAtStartPar
A vizualisation with \sphinxcode{\sphinxupquote{medit}} of scalar solutions \(f1\) and \(f2\) continuous, piecewise linear and known at the vertices of the mesh Th is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol1 sol2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first plot named \sphinxcode{\sphinxupquote{sol1}} display f1.
The second plot names \sphinxcode{\sphinxupquote{sol2}} display f2.

\sphinxAtStartPar
The arguments of the function \sphinxcode{\sphinxupquote{medit}} are the name of the differents scenes (separated by a space) of \sphinxcode{\sphinxupquote{medit}}, a mesh and solutions.

\sphinxAtStartPar
Each solution is associated with one scene.
The scalar, vector and symmetric tensor solutions are specified in the format described in the section dealing with the keyword \sphinxcode{\sphinxupquote{savesol}}.

\sphinxAtStartPar
The parameters of this command line are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{order=}} 0 if the solution is given at the center of gravity of elements.}] \leavevmode
\sphinxAtStartPar
1 is the solution is given at the vertices of elements.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{meditff=}} set the name of execute command of medit.}] \leavevmode
\sphinxAtStartPar
By default, this string is medit.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{save=}} set the name of a file \sphinxcode{\sphinxupquote{.sol}} or \sphinxcode{\sphinxupquote{.solb}} to save solutions.

\end{itemize}

\sphinxAtStartPar
This command line allows also to represent two differents meshes and solutions on them in the same windows.
The nature of solutions must be the same.
Hence, we can vizualize in the same window the different domains in a domain decomposition method for instance.
A vizualisation with medit of scalar solutions \(h1\) and \(h2\) at vertices of the mesh Th1 and Th2 respectively are obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol2domain}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th1}\PYG{p}{,} \PYG{n}{h1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{,} \PYG{n}{h2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Medit

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Initial Problem:}
\PYG{c+c1}{// Resolution of the following EDP:}
\PYG{c+c1}{// \PYGZhy{}Delta u\PYGZus{}s = f on \PYGZbs{}Omega = \PYGZob{} (x,y) | 1 \PYGZlt{}= sqrt(x\PYGZca{}2+y\PYGZca{}2) \PYGZlt{}= 2 \PYGZcb{}}
\PYG{c+c1}{// \PYGZhy{}Delta u\PYGZus{}1 = f1 on \PYGZbs{}Omega\PYGZus{}1 = \PYGZob{} (x,y) | 0.5 \PYGZlt{}= sqrt(x\PYGZca{}2+y\PYGZca{}2) \PYGZlt{}= 1. \PYGZcb{}}
\PYG{c+c1}{// u = 1 on Gamma}
\PYG{c+c1}{// Null Neumman condition on Gamma\PYGZus{}1 and on Gamma\PYGZus{}2}
\PYG{c+c1}{// We find the solution u by solving two EDP defined on domain Omega and Omega\PYGZus{}1}
\PYG{c+c1}{// This solution is visualize with medit}

\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{Gamma}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Omega}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n+nf}{Gamma}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Omega\PYGZus{}1}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{us}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad2}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap2dOmega} \PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{us}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Lap2dOmega1} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad2}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f1}\PYG{o}{*}\PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Lap2dOmega}\PYG{p}{;}
\PYG{n}{Lap2dOmega1}\PYG{p}{;}

\PYG{c+c1}{// Plot with medit}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{us}\PYG{p}{,} \PYG{n}{Th1}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{save}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{testsavemedit.solb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Mshmet}
\label{\detokenize{documentation/mesh-generation:mshmet}}\label{\detokenize{documentation/mesh-generation:meshgenerationmshmet}}
\sphinxAtStartPar
Mshmet is a software developed by P. Frey that allows to compute an anisotropic metric based on solutions (i.e. Hessian\sphinxhyphen{}based).
This software can return also an isotropic metric.
Moreover, \sphinxcode{\sphinxupquote{mshmet}} can also construct a metric suitable for levelset interface capturing.
The solution can be defined on 2D or 3D structured/unstructured meshes.
For example, the solution can be an error estimate of a FE solution.

\sphinxAtStartPar
Solutions for \sphinxcode{\sphinxupquote{mshmet}} are given as an argument.
The solution can be a \sphinxcode{\sphinxupquote{func}}, a vector \sphinxcode{\sphinxupquote{func}}, a symmetric tensor, a \sphinxcode{\sphinxupquote{fespace}} function, a \sphinxcode{\sphinxupquote{fespace}} vector function and a \sphinxcode{\sphinxupquote{fespace}} symmetric tensor.
The symmetric tensor argument is defined as this type of data for datasol argument.
This software accepts more than one solution.

\sphinxAtStartPar
For example, the metric \(M\) computed with \sphinxcode{\sphinxupquote{mshmet}} for the solution \(u\) defined on the mesh \(Th\) is obtained by writing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//a scalar fespace function}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{M} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parameters of the keyword \sphinxcode{\sphinxupquote{mshmet}} are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{normalization =}} (b) do a normalization of all solution in \([0,1]\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{aniso =}} (b) build anisotropic metric if 1 (default 0: isotropic)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{levelset =}} (b) build metric for levelset method (default: \sphinxcode{\sphinxupquote{false}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{verbosity =}} (l) level of verbosity

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbregul =}} (l) number of regularization’s iteration of solutions given (default 0).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmin =}} (d)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmax =}} (d)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{err =}} (d) level of error.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{width =}} (d) the width

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric =}} a vector of double.}] \leavevmode
\sphinxAtStartPar
This vector contains an initial metric given to \sphinxcode{\sphinxupquote{mshmet}}.
The structure of the metric vector is described in the next paragraph.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{loptions =}} a vector of integer of size 7.}] \leavevmode
\sphinxAtStartPar
This vector contains the integer parameters of \sphinxcode{\sphinxupquote{mshmet}} (for expert only).
\begin{itemize}
\item {} 
\sphinxAtStartPar
loptions(0): normalization (default 1).

\item {} \begin{description}
\item[{loptions(1): isotropic parameters (default 0).}] \leavevmode
\sphinxAtStartPar
1 for isotropic metric results otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(2): level set parameters (default 0).}] \leavevmode
\sphinxAtStartPar
1 for building level set metric otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(3): debug parameters (default 0).}] \leavevmode
\sphinxAtStartPar
1 for turning on debug mode otherwise 0.

\end{description}

\item {} 
\sphinxAtStartPar
loptions(4): level of verbosity (default 10).

\item {} 
\sphinxAtStartPar
loptions(5): number of regularization’s iteration of solutions given (default 0).

\item {} \begin{description}
\item[{loptions(6): previously metric parameter (default 0).}] \leavevmode
\sphinxAtStartPar
1 for using previous metric otherwise 0.

\end{description}

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{doptions=}} a vector of double of size 4.}] \leavevmode
\sphinxAtStartPar
This vector contains the real parameters of \sphinxcode{\sphinxupquote{mshmet}} (for expert only).
\begin{itemize}
\item {} 
\sphinxAtStartPar
doptions(0): hmin : min size parameters (default 0.01).

\item {} 
\sphinxAtStartPar
doptions(1): hmax : max size parameters (default 1.0).

\item {} 
\sphinxAtStartPar
doptions(2): eps : tolerance parameters (default 0.01).

\item {} 
\sphinxAtStartPar
doptions(2): width : relative width for Level Set (\(0<w<1\)) (default 0.05).

\end{itemize}

\end{description}

\end{itemize}

\sphinxAtStartPar
The result of the keyword \sphinxcode{\sphinxupquote{mshmet}} is a \sphinxcode{\sphinxupquote{real{[}int{]}}} which contains the metric computed by \sphinxcode{\sphinxupquote{mshmet}} at the different vertices \(V_{i}\) of the mesh.

\sphinxAtStartPar
With \(nv\) is the number of vertices, the structure of this vector is:
\begin{equation*}
\begin{split}M_{iso}= (m(V_0), m(V_1), \ldots, m(V_{nv}))^t\end{split}
\end{equation*}
\sphinxAtStartPar
for a isotropic metric \(m\).
For a symmetric tensor metric \(h=\left(\begin{array}{ccc} m_{1 1} & m_{1 2} & m_{1 3}\\ m_{2 1} & m_{2 2} & m_{2 3} \\ m_{3 1} & m_{3 2} & m_{3 3} \end{array}\right)\) , the parameters \sphinxcode{\sphinxupquote{metric}} is:
\begin{equation*}
\begin{split}M_{aniso}= (H(V_{0}), \ldots, H(V_{nv}) )^t\end{split}
\end{equation*}
\sphinxAtStartPar
where \(H(V_{i})\) is the vector of size 6 defined by \([m11,m21,m22,m31,m32,m33]\)

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
mshmet

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mshmet}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh3}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh3} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh3P1}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh3P1} \PYG{n}{usol}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Problem2}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u3}\PYG{o}{*}\PYG{n}{v3}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v3}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Problem2}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u3}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u3}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Sol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metric:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{usol}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Metric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{usol}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{FreeYams}
\label{\detokenize{documentation/mesh-generation:freeyams}}
\sphinxAtStartPar
FreeYams is a surface mesh adaptation software which is developed by P. Frey.
This software is a new version of yams.
The adapted surface mesh is constructed with a geometric metric tensor field.
This field is based on the intrinsic properties of the discrete surface.

\sphinxAtStartPar
Also, this software allows to construct a simplification of a mesh.
This decimation is based on the Hausdorff distance between the initial and the current triangulation.
Compared to the software yams, FreeYams can be used also to produce anisotropic triangulations adapted to levelset simulations.
A technical report on freeYams documentation is available \sphinxhref{https://www.ljll.math.upmc.fr/frey/publications/RT-0252.pdf}{here}.

\sphinxAtStartPar
To call FreeYams in \sphinxstylestrong{FreeFEM}, we used the keyword \sphinxcode{\sphinxupquote{freeyams}}.
The arguments of this function are the initial mesh and/or metric.
The metric with \sphinxcode{\sphinxupquote{freeyams}} are a \sphinxcode{\sphinxupquote{func}}, a \sphinxcode{\sphinxupquote{fespace}} function, a symmetric tensor function, a symmetric tensor \sphinxcode{\sphinxupquote{fespace}} function or a vector of double (\sphinxcode{\sphinxupquote{real{[}int{]}}}).
If the metric is a vector of double, this data must be given in \sphinxcode{\sphinxupquote{metric}} parameter.
Otherwise, the metric is given in the argument.

\sphinxAtStartPar
For example, the adapted mesh of \sphinxcode{\sphinxupquote{Thinit}} defined by the metric \(u\) defined as \sphinxcode{\sphinxupquote{fespace}} function is obtained by writing:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Thinit}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{freeyams}\PYG{p}{(}\PYG{n}{Thinit}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The symmetric tensor argument for \sphinxcode{\sphinxupquote{freeyams}} keyword is defined as this type of data for datasol argument.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{aniso=}} (b) aniso or iso metric (default 0, iso)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mem=}} (l) memory of for freeyams in Mb (default \sphinxhyphen{}1,
freeyams choose)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmin=}} (d)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmax=}} (d)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gradation=}} (d)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{option=}} (l)
\begin{itemize}
\item {} 
\sphinxAtStartPar
0 : mesh optimization (smoothing+swapping)

\item {} 
\sphinxAtStartPar
1 : decimation+enrichment adaptated to a metric map. (default)

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}1 : decimation adaptated to a metric map.

\item {} 
\sphinxAtStartPar
2 : decimation+enrichment with a Hausdorff\sphinxhyphen{}like method

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}2 : decimation with a Hausdorff\sphinxhyphen{}like method

\item {} 
\sphinxAtStartPar
4 : split triangles recursively.

\item {} 
\sphinxAtStartPar
9 : No\sphinxhyphen{}Shrinkage Vertex Smoothing

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ridgeangle=}} (d)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{absolute=}} (b)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{verbosity=}} (i)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} vector expression.}] \leavevmode
\sphinxAtStartPar
This parameters contains the metric at the different vertices on the initial mesh.
With \(nv\) is the number of vertices, this vector is:

\end{description}
\begin{equation*}
\begin{split}M_{iso}= ( m(V_0), m(V_1), \ldots, m(V_{nv}) )^t\end{split}
\end{equation*}
\sphinxAtStartPar
for a scalar metric \(m\).
For a symmetric tensor metric
\(h=\left(\begin{array}{ccc} m_{1 1} & m_{1 2} & m_{1 3}\\ m_{2 1} & m_{2 2} & m_{2 3} \\ m_{3 1} & m_{3 2} & m_{3 3} \end{array}\right)\), the parameters \sphinxcode{\sphinxupquote{metric}} is:
\begin{equation*}
\begin{split}M_{aniso}= ( H(V_{0}), \ldots, H(V_{nv}) )^t\end{split}
\end{equation*}
\sphinxAtStartPar
where \(H(V_{i})\) is the vector of size 6 defined by \([m11,m21,m22,m31,m32,m33]\)

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{loptions=}} a vector of integer of size 13.}] \leavevmode
\sphinxAtStartPar
This vectors contains the integer options of FreeYams. (just for the expert)
\begin{itemize}
\item {} \begin{description}
\item[{loptions(0): anisotropic parameter (default 0).}] \leavevmode
\sphinxAtStartPar
If you give an anisotropic metric 1 otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(1): Finite Element correction parameter (default 0).}] \leavevmode
\sphinxAtStartPar
1 for \sphinxstyleemphasis{no} Finite Element correction otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(2): Split multiple connected points parameter (default 1).}] \leavevmode
\sphinxAtStartPar
1 for splitting multiple connected points otherwise 0.

\end{description}

\item {} 
\sphinxAtStartPar
loptions(3): maximum value of memory size in Mbytes (default \sphinxhyphen{}1: the size is given by freeyams).

\item {} \begin{description}
\item[{loptions(4): set the value of the connected component which we want to obtain.}] \leavevmode
\sphinxAtStartPar
(Remark: freeyams give an automatic value at each connected component).

\end{description}

\item {} 
\sphinxAtStartPar
loptions(5): level of verbosity

\item {} \begin{description}
\item[{loptions(6): Create point on straight edge (no mapping) parameter (default 0).}] \leavevmode
\sphinxAtStartPar
1 for creating point on straight edge otherwise 0.

\end{description}

\item {} \begin{description}
\item[{loptions(7): validity check during smoothing parameter.}] \leavevmode
\sphinxAtStartPar
This parameter is only used with No\sphinxhyphen{}Shrinkage Vertex Smoothing optimization (optimization option parameter 9).
1 for No validity checking during smoothing otherwise 0.

\end{description}

\item {} 
\sphinxAtStartPar
loptions(8): number of desired’s vertices (default \sphinxhyphen{}1).

\item {} 
\sphinxAtStartPar
loptions(9): number of iteration of optimizations (default 30).

\item {} \begin{description}
\item[{loptions(10): no detection parameter (default 0).}] \leavevmode
\sphinxAtStartPar
1 for detecting the ridge on the mesh otherwise 0.
The ridge definition is given in the parameter doptions(12).

\end{description}

\item {} \begin{description}
\item[{loptions(11): no vertex smoothing parameter (default 0).}] \leavevmode
\sphinxAtStartPar
1 for smoothing the vertices otherwise 0.

\end{description}

\item {} 
\sphinxAtStartPar
loptions(12): Optimization level parameter (default 0).

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
0 : mesh optimization (smoothing+swapping)

\item {} 
\sphinxAtStartPar
1 : decimation+enrichment adaptated to a metric map.

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}1: decimation adaptated to a metric map.

\item {} 
\sphinxAtStartPar
2 : decimation+enrichment with a Hausdorff\sphinxhyphen{}like method

\item {} 
\sphinxAtStartPar
\sphinxhyphen{}2: decimation with a Hausdorff\sphinxhyphen{}like method

\item {} 
\sphinxAtStartPar
4 : split triangles recursively.

\item {} 
\sphinxAtStartPar
9 : No\sphinxhyphen{}Shrinkage Vertex Smoothing

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{doptions=}} a vector of double of size 11.}] \leavevmode
\sphinxAtStartPar
This vectors contains the real options of freeyams.

\end{description}
\begin{itemize}
\item {} 
\sphinxAtStartPar
doptions(0): Set the geometric approximation (Tangent plane deviation) (default 0.01).

\item {} 
\sphinxAtStartPar
doptions(1): Set the lamda parameter (default \sphinxhyphen{}1).

\item {} 
\sphinxAtStartPar
doptions(2): Set the mu parmeter (default \sphinxhyphen{}1).

\item {} 
\sphinxAtStartPar
doptions(3): Set the gradation value (Mesh density control) (default 1.3).

\item {} 
\sphinxAtStartPar
doptions(4): Set the minimal size(hmin) (default \sphinxhyphen{}2.0: the size is automatically computed).

\item {} 
\sphinxAtStartPar
doptions(5): Set the maximal size(hmax) (default \sphinxhyphen{}2.0: the size is automatically computed).

\item {} 
\sphinxAtStartPar
doptions(6): Set the tolerance of the control of Chordal deviation (default \sphinxhyphen{}2.0).

\item {} 
\sphinxAtStartPar
doptions(7): Set the quality of degradation (default 0.599).

\item {} 
\sphinxAtStartPar
doptions(8): Set the declic parameter (default 2.0).

\item {} 
\sphinxAtStartPar
doptions(9): Set the angular walton limitation parameter (default 45 degree).

\item {} 
\sphinxAtStartPar
doptions(10): Set the angular ridge detection (default 45 degree).

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
freeyams

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{freeyams}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{freeyams}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{SurfaceMesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{mmg3d}
\label{\detokenize{documentation/mesh-generation:mmg3d}}
\begin{sphinxadmonition}{note}{\label{\detokenize{documentation/mesh-generation:id30}}Todo:}
\sphinxAtStartPar
mmg3d\sphinxhyphen{}v4.0
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxhref{http://www.mmgtools.org}{Mmg3d} is a 3D remeshing software developed by C. Dobrzynski and P. Frey.

\sphinxAtStartPar
This software allows to remesh an initial mesh made of tetrahedra.
This initial mesh is adapted to a geometric metric tensor field or to a displacement vector (moving rigid body).
The metric can be obtained with {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationmshmet}]{\sphinxcrossref{\DUrole{std,std-ref}{mshmet}}}}.

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
If no metric is given, an isotropic metric is computed by analyzing the size of the edges in the initial mesh.

\item {} 
\sphinxAtStartPar
If a displacement is given, the vertices of the surface triangles are moved without verifying the geometrical structure of the new surface mesh.

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
The parameters of \sphinxcode{\sphinxupquote{mmg3d}} are :
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{options=}} vector expression.}] \leavevmode
\sphinxAtStartPar
This vector contains the option parameters of \sphinxcode{\sphinxupquote{mmg3d}}.
It is a vector of 6 values, with the following meaning:

\end{description}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Optimization parameters : (default 1)

\sphinxAtStartPar
0 : mesh optimization.

\sphinxAtStartPar
1 : adaptation with metric (deletion and insertion vertices) and optimization.

\sphinxAtStartPar
\sphinxhyphen{}1 : adaptation with metric (deletion and insertion vertices) without optimization.

\sphinxAtStartPar
4 : split tetrahedra (be careful modify the surface).

\sphinxAtStartPar
9 : moving mesh with optimization.

\sphinxAtStartPar
\sphinxhyphen{}9 : moving mesh without optimization.

\item {} 
\sphinxAtStartPar
Debug mode : (default 0)

\sphinxAtStartPar
1 : turn on debug mode.

\sphinxAtStartPar
0 : otherwise.

\item {} 
\sphinxAtStartPar
Specify the size of bucket per dimension (default 64)

\item {} 
\sphinxAtStartPar
Swapping mode : (default 0)

\sphinxAtStartPar
1 : no edge or face flipping.

\sphinxAtStartPar
0 : otherwise.

\item {} 
\sphinxAtStartPar
Insert points mode : (default 0)

\sphinxAtStartPar
1 : no edge splitting or collapsing and no insert points.

\sphinxAtStartPar
0 : otherwise.

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Verbosity level (default 3)

\end{enumerate}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{memory=}} integer expression.}] \leavevmode
\sphinxAtStartPar
Set the maximum memory size of new mesh in Mbytes.
By default the number of maximum vertices, tetrahedra and triangles are respectively 500 000, 3000 000, 100000 which represent approximately a memory of 100 Mo.

\end{description}

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{metric=}} vector expression.}] \leavevmode
\sphinxAtStartPar
This vector contains the metric given at \sphinxcode{\sphinxupquote{mmg3d}}.
It is a vector of size \(nv\) or 6 \(nv\) respectively for an isotropic and anisotropic metric where \(nv\) is the number of vertices in the initial mesh.
The structure of \sphinxcode{\sphinxupquote{metric}} vector is described in the {\hyperref[\detokenize{documentation/mesh-generation:meshgenerationmshmet}]{\sphinxcrossref{\DUrole{std,std-ref}{mshmet}}}}.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{displacement=}} \([\Phi1, \Phi2, \Phi3]\) set the displacement vector of the initial mesh \(\mathbf{\Phi(x,y)} = [\Phi1(x,y), \Phi2(x,y), \Phi3(x,y)]\).

\item {} \begin{description}
\item[{\sphinxcode{\sphinxupquote{displVect=}} sets the vector displacement in a vector expression.}] \leavevmode
\sphinxAtStartPar
This vector contains the displacement at each point of the initial mesh.
It is a vector of size 3 \(nv\).

\end{description}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
mmg3d

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mmg3d}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Nxyz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{Nxyz}\PYG{p}{,} \PYG{n}{Bxyz}\PYG{p}{,} \PYG{n}{Lxyz}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{isometric}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{isometric}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{mmg3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{memory}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kp}{metric}\PYG{o}{=}\PYG{n}{isometric}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initial}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Isometric}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Falling spheres

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mmg3d}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mf}{11.5}\PYG{o}{/}\PYG{n}{hs}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{l+m+mi}{311}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{opt} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vit}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zero} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{dep} \PYG{o}{=} \PYG{n}{vit}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Meshes}
\PYG{k+kt}{meshS} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{ThSg} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{ThSd} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{310}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ThSd} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{ThSd}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{meshS} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThSg} \PYG{o}{+} \PYG{n}{ThSd}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ThHS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ThHS}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{holes} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domaine}\PYG{p}{,} \PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{holes}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Box\PYGZhy{}With\PYGZhy{}two\PYGZhy{}Ball}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{310}\PYG{p}{,} \PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{n}{dep}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{311}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Falling loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{it} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{29}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ITERATION }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Lap}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Sphere falling}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{mmg3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{options}\PYG{o}{=}\PYG{n}{opt}\PYG{p}{,} \PYG{k+kp}{displacement}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zero}\PYG{p}{,} \PYG{n}{zero}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{memory}\PYG{o}{=}\PYG{l+m+mi}{1000}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{A first 3d isotrope mesh adaptation process}
\label{\detokenize{documentation/mesh-generation:a-first-3d-isotrope-mesh-adaptation-process}}\label{\detokenize{documentation/mesh-generation:meshfirstisotropemeshadaptation}}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Adaptation 3D

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TetGen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{mshmet}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l1111} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//labels}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{errm} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{;} \PYG{c+c1}{//level of error}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l1111}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{l11}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{l01}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{l01}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{y} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{|} \PYG{p}{(}\PYG{k+kr}{z} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//remove the ]0.5,1[\PYGZca{}3 cube}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{usol}\PYG{p}{,} \PYG{n}{h}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
        \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u min, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//for resizing h[] because the mesh change}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{mshmet}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{normalization}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{aniso}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbregul}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{,} \PYG{k+kp}{hmax}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{errm}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{h min, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{errm} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;} \PYG{c+c1}{//change the level of error}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nv} \PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{nt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{tetgreconstruction}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{raAQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{sizeofvolume}\PYG{o}{=}\PYG{n}{h}\PYG{o}{*}\PYG{n}{h}\PYG{o}{*}\PYG{n}{h}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//rebuild mesh}
    \PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{U\PYGZhy{}adap\PYGZhy{}iso\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{ii}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Build a 2d mesh from an isoline}
\label{\detokenize{documentation/mesh-generation:build-a-2d-mesh-from-an-isoline}}
\sphinxAtStartPar
The idea is to get the discretization of an isoline of fluid meshes, this tool can be useful to construct meshes from image.
First, we give an example of the isovalue meshes \(0.2\) of analytical function \(\sqrt{(x-1/2)^2 +(y-1/2)^2}\), on unit square.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the isoline points}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the begin, end couple of lines}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{iso} \PYG{o}{=} \PYG{l+m+mf}{0.2} \PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso} \PYG{o}{=} \PYG{p}{[}\PYG{k+kp}{iso}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//to see the iso line}

    \PYG{k+kt}{int} \PYG{n}{nbc} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{k+kp}{iso}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{isoline}} parameters are \sphinxcode{\sphinxupquote{Th}} the mesh, the expression \(u\), the bidimentionnal array \sphinxcode{\sphinxupquote{xy}} to store the list coordinate of the points.
The list of named parameter are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iso=}} value of the isoline to compute (0 is the default value)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{close=}} close the isoline with the border (default \sphinxcode{\sphinxupquote{true}}), we add the part of the mesh border such the value is less than the isovalue

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{smoothing=}} number of smoothing process is the \({l} ^{r} {s}\) where \(l\) is the length of the current line component, \(r\) the ratio, \(s\) is smoothing value. The smoothing default value is 0.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratio=}} the ratio (1 by default).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eps=}} relative \(\varepsilon\) (default 1e\sphinxhyphen{}10)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{beginend=}} array to get begin, end couple of each of sub line (resize automatically)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{file=}} to save the data curve in data file for gnuplot

\end{itemize}

\sphinxAtStartPar
In the array \sphinxcode{\sphinxupquote{xy}} you get the list of vertices of the isoline, each connex line go from \(i= i_0^c ,\dots, i_1^c-1\) with \(i_0^c =be(2*c)\) \(i_1^c =be(2*c+1)\), and where \(x_i= xy(0,i), y_i=yx( 1,i), l_i=xy(2,i)\).

\sphinxAtStartPar
Here \(l_i\) is the length of the line (the origin of the line is point \(i_0^c\)).

\sphinxAtStartPar
The sense of the isoline is such that the upper part is at the left size of the isoline.
So here : the minimum is a point \(0.5,05\) so the curve 1 turn in the clockwise sense, the order of each component are sort such that the number of point by component is decreasing.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of the line component = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nbc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of points = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{.}\PYG{k+kr}{m} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{be = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{be} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

      \PYG{c+c1}{// shows the lines component}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{c} \PYG{o}{\PYGZlt{}} \PYG{n}{nbc}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{i0} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
         \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Curve }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
         \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{i0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{i1}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ y= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
         \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{i0}\PYG{o}{:}\PYG{n}{i1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{i0}\PYG{o}{:}\PYG{n}{i1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ curve }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{length of last curve = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xy}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{.}\PYG{k+kr}{m}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We also have a new function to easily parametrize a discrete curve defined by the couple \(be, xy\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{Curve0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//component 0}
    \PYG{k+kt}{int} \PYG{n}{i0}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{xy}\PYG{p}{,} \PYG{n}{i0}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Curve 0}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{Curve1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//component 1}
    \PYG{k+kt}{int} \PYG{n}{i0}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{]}\PYG{p}{,} \PYG{n}{i1}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{xy}\PYG{p}{,} \PYG{n}{i0}\PYG{p}{,} \PYG{n}{i1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Curve 1}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Curve1}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//show curve}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Curve1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Secondly, we use this idea to build meshes from an image, we use the plugins \sphinxcode{\sphinxupquote{ppm2rnm}} to read \sphinxcode{\sphinxupquote{pgm}} a gray scale image and then we extract the gray contour at level 0.25.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Leman lake

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ppm2rnm}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{string} \PYG{n}{leman} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LemanLake.pgm}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{AreaLac} \PYG{o}{=} \PYG{l+m+mf}{580.03}\PYG{p}{;} \PYG{c+c1}{//in km\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{hsize} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nc}\PYG{p}{;} \PYG{c+c1}{//nb of curve}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ff1}\PYG{p}{(}\PYG{n}{leman}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//read image}
    \PYG{c+c1}{//and set it in a rect. array}
    \PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{ny} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
    \PYG{c+c1}{//build a Cartesian mesh such that the origin is in the right place.}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//warning the numbering of the vertices (x,y) is}
    \PYG{c+c1}{//given by \PYGZdl{}i = x/nx + nx* y/ny \PYGZdl{}}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{f1}\PYG{p}{;}
    \PYG{n}{f1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ff1}\PYG{p}{;} \PYG{c+c1}{//transform array in finite element functions.}
    \PYG{n}{nc} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Curves}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{k+kr}{be}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{l+m+mf}{.1}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//The longest isoline: the lake}
\PYG{k+kt}{int} \PYG{n}{ic0} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ic1} \PYG{o}{=} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{NC} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ic1}\PYG{p}{)}\PYG{o}{/}\PYG{n}{hsize}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{xl} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{yl} \PYG{o}{=} \PYG{n}{Curves}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nl}{ic0}\PYG{o}{:}\PYG{n}{ic1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{P}\PYG{o}{=}\PYG{n}{Curve}\PYG{p}{(}\PYG{n}{Curves}\PYG{p}{,} \PYG{n}{ic0}\PYG{p}{,} \PYG{n}{ic1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZgt{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{n}{yl}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{G}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{NC}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{scale} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{AreaLac}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{scale}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th.area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Km\PYGZca{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{AreaLac} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Km\PYGZca{}2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{leman.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Isoline1}.jpg}
\caption{The image of the Leman lake meshes}\label{\detokenize{documentation/mesh-generation:id52}}\label{\detokenize{documentation/mesh-generation:meshgenerationisoline1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshGeneration_Isoline2}.png}
\caption{The mesh of the lake}\label{\detokenize{documentation/mesh-generation:id53}}\label{\detokenize{documentation/mesh-generation:meshgenerationisoline2}}\end{subfigure}
\caption{Isoline}\phantomsection\label{\detokenize{documentation/mesh-generation:Isoline}}

\end{figure}

\end{sphinxadmonition}


\section{Finite element}
\label{\detokenize{documentation/finite-element:finite-element}}\label{\detokenize{documentation/finite-element:finiteelement}}\label{\detokenize{documentation/finite-element::doc}}
\sphinxAtStartPar
As stated in {\hyperref[\detokenize{tutorials/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorials}}}}, FEM approximates all functions \(w\) as:
\begin{equation*}
\begin{split}w(x,y)\simeq w_0\phi_0(x,y)+w_1\phi_1(x,y)+\cdots+w_{M-1}\phi_{M-1}(x,y)\end{split}
\end{equation*}
\sphinxAtStartPar
with finite element basis functions \(\phi_k(x,y)\) and numbers \(w_k\) (\(k=0,\cdots,M-1\)).
The functions \(\phi_k(x,y)\) are constructed from the triangle \(T_{i_k}\), and called \sphinxstyleemphasis{shape functions}.

\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM}, the finite element space:
\begin{equation*}
\begin{split}V_h=\left\{w\left|\; w_0\phi_0+w_1\phi_1+\cdots+w_{M-1}\phi_{M-1},\, w_i\in \R\right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
is easily created by
\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
in 2d

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or with \(\ell\) pairs of periodic boundary conditions in 2D:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
in 3D:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmesh3}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{,} \PYG{n}{ta1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{,} \PYG{n}{tb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{,} \PYG{n}{tak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{,} \PYG{n}{tbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
in surface 3D:

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{IDspace}\PYG{p}{(}\PYG{n}{IDmeshS}\PYG{p}{,}\PYG{o}{\PYGZlt{}}\PYG{n}{IDFE}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{la1}\PYG{p}{,} \PYG{n}{sa1}\PYG{p}{,} \PYG{n}{ta1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{sb1}\PYG{p}{,} \PYG{n}{tb1}\PYG{p}{]}\PYG{p}{,}
              \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
              \PYG{p}{[}\PYG{n}{lak}\PYG{p}{,} \PYG{n}{sak}\PYG{p}{,} \PYG{n}{tak}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lbk}\PYG{p}{,} \PYG{n}{sbl}\PYG{p}{,} \PYG{n}{tbl}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{IDspace}} is the name of the space (e.g. \sphinxcode{\sphinxupquote{Vh}}), \sphinxcode{\sphinxupquote{IDmesh}} \sphinxcode{\sphinxupquote{IDmesh3}} \sphinxcode{\sphinxupquote{IDmeshS \textasciigrave{}is respectly the name of the associated :freefem:\textasciigrave{}mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{meshS}} and \sphinxcode{\sphinxupquote{\textless{}IDFE\textgreater{}}} is an identifier of finite element type.

\sphinxAtStartPar
In 2D we have a pair of periodic boundary conditions, if \([la_i, sa_i]\), \([lb_i, sb_i]\) is a pair of \sphinxcode{\sphinxupquote{int}}, and the 2 labels \(la_i\) and \(lb_i\) refer to 2 pieces of boundary to be in equivalence.

\sphinxAtStartPar
If \([la_i, sa_i]\), \([lb_i, sb_i]\) is a pair of \sphinxcode{\sphinxupquote{real}}, then \(sa_i\) and \(sb_i\) give two common abscissa on the two boundary curves, and two points are identified as one if the two abscissa are equal.

\sphinxAtStartPar
In 2D, we have a pair of periodic boundary conditions, if \([la_i, sa_i, ta_i]\), \([lb_i, sb_i, tb_i]\) is a pair of \sphinxcode{\sphinxupquote{int}}, the 2 labels \(la_i\) and \(lb_i\) define the 2 pieces of boundary to be in equivalence.

\sphinxAtStartPar
If \([la_i, sa_i, ta_i]\), \([lb_i, sb_i, tb_i]\) is a pair of \sphinxcode{\sphinxupquote{real}}, then \(sa_i\), \(ta_i\) and \(sb_i\), \(tb_i\) give two common parameters on the two boundary surfaces, and two points are identified as one if the two parameters are equal.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The 2D mesh of the two identified borders must be the same, so to be sure, use the parameter \sphinxcode{\sphinxupquote{fixedborder=true}} in \sphinxcode{\sphinxupquote{buildmesh}} command (see {\hyperref[\detokenize{documentation/mesh-generation:meshborder}]{\sphinxcrossref{\DUrole{std,std-ref}{fixedborder}}}}).
\end{sphinxadmonition}


\subsection{List of the types of finite elements}
\label{\detokenize{documentation/finite-element:list-of-the-types-of-finite-elements}}
\sphinxAtStartPar
As of today, the known types of finite elements are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P0{]}}} piecewise constant discontinuous finite element (2d, 3d, surface 3d), the degrees of freedom are the barycenter element value.
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:P0}
\begin{split}\P^0_{h} = \left\{ v \in L^2(\Omega) \left|\; \textrm{for all }K \in \mathcal{T}_{h}\;\;\textrm{there is }\alpha_{K}\in \R : \;\; v_{|K} = \alpha_{K } \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P1{]}}} piecewise linear continuous finite element (2d, 3d, surface 3d), the degrees of freedom are the vertices values.
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:P1}
\begin{split}\P^1_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h},\ v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P1dc{]}}} piecewise linear discontinuous finite element (2d, 3d with load”Element\_P1dc1”)
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:P1dc}
\begin{split}\P^1_{dc|h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Due to an interpolation problem, the degree of freedom is not the vertices but three vertices which move inside \(T(X)= G + .99 (X-G)\) where \(G\) is the barycenter.
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P1b{]}}} piecewise linear continuous finite element plus bubble (2d, 3d)

\sphinxAtStartPar
\sphinxstylestrong{The 2D Case:}
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:P1b}
\begin{split}\P^1_{b|h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}\end{split}
\end{equation}\end{quote}

\sphinxAtStartPar
\sphinxstylestrong{The 3D Case:}
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:P1b-3d}
\begin{split}\P^1_{b|h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{1} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \lambda^{K}_{3} \} \right.\right\}\end{split}
\end{equation}
\sphinxAtStartPar
where \(\lambda^{K}_{i}, i=0,..,d\) are the \(d+1\) barycentric coordinate functions of the element \(K\) (triangle or tetrahedron).
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1bl,P1bl3d}} piecewise linear continuous finite element plus linear bubble (with load”Element\_P1bl” 2d, 3d).

\sphinxAtStartPar
The bubble is built by splitting the \(K\), a barycenter in \(d+1\) sub element. (need \sphinxcode{\sphinxupquote{load "Element\_P1bl"}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2, P2{]}}} piecewise \(P_{2}\) continuous finite element (2d, 3d, surface 3d)
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{2}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 2\).
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2b, P2b3d{]}}} piecewise \(P_{2}\) continuous finite element plus bubble (2d, 3d with load”Element\_P2bulle3”)

\sphinxAtStartPar
\sphinxstylestrong{The 2D Case:}
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{The 3D Case:}
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \oplus \mathrm{Span}\{ \lambda^{K}_{0} \lambda^{K}_{1} \lambda^{K}_{2} \lambda^{K}_{3} \} \right.\right\}\end{split}
\end{equation*}\end{quote}
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2dc{]}}} piecewise \(P_{2}\) discontinuous finite element (2d)
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{dc|h} = \left\{ v \in L^{2}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{2} \right.\right\}\end{split}
\end{equation*}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Due to an interpolation problem, the degree of freedom is not the six P2 nodes but six nodes which move inside \(T(X)= G + .99 (X-G)\) where \(G\) is the barycenter.
\end{sphinxadmonition}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2h{]}}} quadratic homogeneous continuous (without \sphinxcode{\sphinxupquote{P1}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P3{]}}} piecewise \(P_{3}\) continuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P3"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^3_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P3dc{]}}} piecewise \(P_{3}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P3dc"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^3_{dc|h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P4{]}}} piecewise \(P_{4}\) continuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P4"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^4_{h} = \left\{ v \in H^{1}(\Omega) \left|\; \forall K \in \mathcal{T}_{h},\ v_{|K} \in P_{4} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{4}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 4\).
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P4dc{]}}} piecewise \(P_{4}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_P4dc"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^4_{dc|h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{4}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P0Edge{]}}} piecewise \(P_{0}\) discontinuous finite element (2d) contained on each edge of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P1Edge{]}}} piecewise \(P_{1}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_1\) on each edge of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2Edge{]}}} piecewise \(P_{2}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_2\) on each edge of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P3Edge{]}}} piecewise \(P_{3}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_3\) on each edge of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P4Edge{]}}} piecewise \(P_{4}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_4\) on each edge of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P5Edge{]}}} piecewise \(P_{5}\) discontinuous finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_PkEdge"}}) \(P_5\) on each edge of the mesh.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2Morley{]}}} piecewise \(P_{2}\) non conform finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Morley"}})
\begin{quote}
\begin{equation*}
\begin{split}\P^2_{h} = \left\{ v \in L^2(\Omega) \left|\; \forall K \in \mathcal{T}_{h}, \ v_{|K} \in P_{3},
\left\{\begin{array}{c}
    v \mbox{ continuous at vertices,}\\
    \p_n{v} \mbox{ continuous at middle of edge,}
\end{array}\right.
\right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{2}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 2\).

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
To build the interplant of a function \(u\) (scalar) for this finite element, we need the function and 2 partial derivatives \((u,u_x, u_y)\), creating this vectorial finite element with 3 components \((u,u_x,u_y)\).
\end{sphinxadmonition}

\sphinxAtStartPar
See our example for solving the BiLaplacien problem:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Morley}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2Morley}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//The Morley finite element space}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{bilaplacien}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n}{bilap} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{bilaplacien}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}HCT{]}}} \(P_3\) \(C^1\) conforms finite element (2d) (needs \sphinxcode{\sphinxupquote{load "Element\_HCT"}}) one 3 sub triangles.
\begin{quote}

\sphinxAtStartPar
Lets call \(\mathcal{T}^\triangle_{h}\) the sub mesh of \(\mathcal{T}_{h}\) where all triangles are split in 3 at the barycenter.
\begin{equation*}
\begin{split}\P^{HCT}_{h} = \left\{ v \in C^1(\Omega) \left|\; \forall K \in \mathcal{T}^\triangle_{h}, \ v_{|K} \in P_{3} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_{3}\) is the set of polynomials of \(\R^{2}\) of degrees \(\le 3\).

\sphinxAtStartPar
The degrees of freedom are the values of the normal derivative at the mid\sphinxhyphen{}point of each edge \sphinxcite{bibliography:bernadou1980}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
To build the interplant of a function \(u\) (scalar) for this finite element, we need the function and 2 partial derivatives \((u,u_x, u_y)\), creating this vectorial finite element with 3 components \((u,u_x,u_y)\) like in previous finite element.
\end{sphinxadmonition}
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2BR{]}}} (needs \sphinxcode{\sphinxupquote{load "BernadiRaugel"}}) the Bernadi Raugel Finite Element is a Vectorial element (2d) with 2 components, see \sphinxcite{bibliography:bernardi1985}.
\begin{quote}

\sphinxAtStartPar
It is a 2D coupled Finite Element, where the Polynomial space is \(P_1^2\) with 3 normal bubble edge functions \((P_2)\).
There are 9 degrees of freedom:
\begin{itemize}
\item {} 
\sphinxAtStartPar
2 components at each of the 3 vertices and

\item {} 
\sphinxAtStartPar
the 3 flux on the 3 edges.

\end{itemize}
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}RT0, RT03d{]}}} Raviart\sphinxhyphen{}Thomas finite element of degree \(0\).
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{The 2D Case:}
\begin{equation}\label{equation:documentation/finite-element:eq:RT0}
\begin{split}RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in \mathcal{T}_{h} ,\ \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}
\sphinxAtStartPar
\sphinxstylestrong{The 3D Case:}
\begin{equation}\label{equation:documentation/finite-element:eq:RT03d}
\begin{split}RT0_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in \mathcal{T}_{h},\ \mathbf{v}_{|K}(x,y,z) =
\vectthree{\alpha^1_{K}}{\alpha^2_{K}}{\alpha^3_{K}} + \beta_{K}\vectthree{x}{y}{z} \right.\right\}\end{split}
\end{equation}
\sphinxAtStartPar
where by writing \(\textrm{div }\mathbf{w}=\sum_{i=1}^d\p w_i/\p x_i\) with \(\mathbf{w}=(w_i)_{i=1}^d\):
\begin{equation*}
\begin{split}H(\textrm{div})=\left\{\mathbf{w}\in L^{2}(\Omega)^d\left|\textrm{div } \mathbf{w}\in L^{2}(\Omega)\right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
and where \(\alpha^1_{K}\), \(\alpha^2_{K}\), \(\alpha^3_{K}\), \(\beta_{K}\) are real numbers.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}RT0Ortho{]}}} Raviart\sphinxhyphen{}Thomas Orthogonal, or Nedelec finite element type I of degree \(0\) in dimension 2
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:RT0Ortho}
\begin{split}RT0Ortho{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in \mathcal{T}_{h},\ \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}Edge03d{]}}} 3d Nedelec finite element or Edge Element of degree \(0\).
\begin{quote}
\begin{equation*}
\begin{split}Edge0_{h} = \left\{ \mathbf{v} \in H(\textrm{Curl}) \left|\; \forall K \in\mathcal{T}_{h}, \ \mathbf{v}_{|K}(x,y,z) =
    \vectthree{\alpha^1_{K}}{\alpha^2_{K}}{\alpha^3_{K}} + \vectthree{\beta^1_{K}}{\beta^2_{K}}{\beta^3_{K}}\times\vectthree{x}{y}{z} \right.\right\}
:label:eq:Edge03d\end{split}
\end{equation*}
\sphinxAtStartPar
where by writing \(\textrm{curl}\mathbf{w}=\vectthree{\p w_2/\p x_3-\p w_3/\p x_2}{\p w_3/\p x_1-\p w_1/\p x_3}{\p w_1/\p x_2-\p w_2/\p x_1}\) with \(\mathbf{w}=(w_i)_{i=1}^d\):
\begin{equation*}
\begin{split}H(\textrm{curl})=\left\{\mathbf{w}\in L^{2}(\Omega)^d\left|\textrm{curl } \mathbf{w}\in L^{2}(\Omega)^d\right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
and \(\alpha^1_{K},\alpha^2_{K},\alpha^3_{K},\beta^1_{K},\beta^2_{K},\beta^3_{K}\) are real numbers.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}Edge13d{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte3d"}}) 3d Nedelec finite element or Edge Element of degree \(1\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}Edge23d{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte3d"}}) 3d Nedelec finite element or Edge Element of degree \(2\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P1nc{]}}} piecewise linear element continuous at the mid\sphinxhyphen{}point of the edge only in 2D (Crouzeix\sphinxhyphen{}Raviart Finite Element 2D).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}P2pnc{]}}} piecewise quadratic plus a P3 bubble element with the continuity of the 2 moments on each edge (needs \sphinxcode{\sphinxupquote{load "Element\_P2pnc"}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}RT1{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:RT1}
\begin{split}RT1_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h}, \ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_1^2,P_0, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}RT1Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:RT1Ortho}
\begin{split}RT1_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h},\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_1^2,P_0, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}RT2{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:RT2}
\begin{split}RT2_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h},\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_2^2, P_1, \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{x}{y} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}RT2Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}})
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:RT2Ortho}
\begin{split}RT2_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h} ,\ \alpha^1_{K}, \alpha^2_{K}, \beta_{K} \in P_2^2, P_1,\ \mathbf{v}_{|K}(x,y) =
    \vecttwo{\alpha^1_{K}}{\alpha^2_{K}} + \beta_{K}\vecttwo{-y}{x} \right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}BDM1{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}}) the Brezzi\sphinxhyphen{}Douglas\sphinxhyphen{}Marini finite element:
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:BDM1}
\begin{split}BDM1_{h} = \left\{ \mathbf{v} \in H(\textrm{div}) \left|\; \forall K \in\mathcal{T}_{h},\ \mathbf{v}_{|K} \in P_1^2\right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}BDM1Ortho{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_Mixte"}}) the Brezzi\sphinxhyphen{}Douglas\sphinxhyphen{}Marini Orthogonal also call Nedelec of type II , finite element
\begin{quote}
\begin{equation}\label{equation:documentation/finite-element:eq:BDM1Ortho}
\begin{split}BDM1Ortho_{h} = \left\{ \mathbf{v} \in H(\textrm{curl}) \left|\; \forall K \in\mathcal{T}_{h},\ \mathbf{v}_{|K} \in P_1^2\right.\right\}\end{split}
\end{equation}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}FEQF{]}}} (needs \sphinxcode{\sphinxupquote{load "Element\_QF"}}) the finite element to store functions at default quadrature points (so the quadrature is \sphinxcode{\sphinxupquote{qf5pT}} in 2D and is \sphinxcode{\sphinxupquote{qfV5}} in 3d).
\begin{quote}

\sphinxAtStartPar
For over quadrature you have the following corresponding finite element’s quadrature formula.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF1}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf1pT}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF2}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf2pT}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF5}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf5pT}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF7}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf7pT}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF9}} \(\mapsto\) \sphinxcode{\sphinxupquote{qf9pT}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF13d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV1}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF23d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV2}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF53d}} \(\mapsto\) \sphinxcode{\sphinxupquote{qfV5}}

\end{itemize}
\end{quote}

\end{itemize}

\sphinxAtStartPar
You can use this element to optimize the storage and reuse of functions with a long formula inside an integral for non linear processes.


\subsection{Use of fespace in 2D}
\label{\detokenize{documentation/finite-element:use-of-fespace-in-2d}}
\sphinxAtStartPar
With the 2D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \left\{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X_{ph} = \left\{ v \in X_{h} |\; v\left(\vecttwo{0}{.}\right) = v\left(\vecttwo{1}{.}\right) , v\left(\vecttwo{.}{0}\right) = v\left(\vecttwo{.}{1}\right) \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}M_{h} = \left\{ v \in H^{1}(]0,1[^2) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2} \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}R_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2)^{2} |\; \forall K \in \mathcal{T}_{h}\quad \mathbf{v}_{|K}(x,y) = \vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \right\}\end{split}
\end{equation*}
\sphinxAtStartPar
when \(\mathcal{T}_h\) is a mesh \(10\times 10\) of the unit square \(]0,1[^2\), we only write in \sphinxstylestrong{FreeFEM}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{,}
    \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//bi\PYGZhy{}periodic FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Rh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//vectorial FE}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Xh, Mh, Rh}} expresses finite element spaces (called FE spaces) \(X_h,\, M_h,\, R_h\), respectively.

\sphinxAtStartPar
To use FE\sphinxhyphen{}functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xph} \PYG{n}{uph}\PYG{p}{,} \PYG{n}{vph}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ph}\PYG{p}{,} \PYG{n}{qh}\PYG{p}{;}
\PYG{n}{Rh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vxh}\PYG{p}{,} \PYG{n}{Vyh}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{//array of 10 functions in Xh}
\PYG{n}{Rh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Wxh}\PYG{p}{,} \PYG{n}{Wyh}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//array of 10 functions in Rh}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{//the 6th function at point (0.5, 0.5)}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}               \PYG{c+c1}{//the array of the degree of freedom of the 6th function}
\end{sphinxVerbatim}

\sphinxAtStartPar
The functions \(U_{h}, V_{h}\) have two components so we have
\begin{equation*}
\begin{split}U_{h}=\vecttwo{Uxh}{Uyh} \quad \mbox{and}\quad V_{h}=\vecttwo{Vxh}{Vyh}\end{split}
\end{equation*}

\subsection{Use of fespace in 3D}
\label{\detokenize{documentation/finite-element:use-of-fespace-in-3d}}
\sphinxAtStartPar
With the 3D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \{ v \in H^{1}(]0,1[^3) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \}\end{split}
\end{equation*}\begin{equation*}
\begin{split}X_{ph} = \left\{ v \in X_{h} |\; v\left(\vectthree{0}{.}{.}\right) = v\left(\vectthree{1}{.}{.}\right) , v\left(\vectthree{.}{0}{.}\right) = v\left(\vectthree{.}{1}{.}\right) , v\left(\vectthree{.}{.}{0}\right) = v\left(\vectthree{.}{.}{1}\right) \right\}\end{split}
\end{equation*}\begin{equation*}
\begin{split}M_{h} = \{ v \in H^{1}(]0,1[^3) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2} \}\end{split}
\end{equation*}\begin{equation*}
\begin{split}R_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^3)^{2} |\; \forall K \in \mathcal{T}_{h}\quad \mathbf{v}_{|K}(x,y,z) = \vectthree{\alpha_{K}}{\beta_{K}}{\gamma_{K}} + \delta_{K}\vectthree{x}{y}{z} \right\}\end{split}
\end{equation*}
\sphinxAtStartPar
when \(\mathcal{T}_h\) is a mesh \(10\times 10\times 10\) of the unit cubic \(]0,1[^2\), we write in \sphinxstylestrong{FreeFEM}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//label: 0 up, 1 down, 2 front, 3 left, 4 back, 5 right}
    \PYG{k+kt}{int} \PYG{n}{nn}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,}\PYG{n}{nn}\PYG{p}{,}\PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{n}{nn}\PYG{p}{,}
      \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,}
      \PYG{k+kp}{reffacelow} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
    \PYG{c+c1}{// a FE space with full periodic condition in 3 axes}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Xph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{,}\PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,}
                     \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\PYG{k+kt}{fespace} \PYG{n+nf}{Rh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT03d}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//vectorial FE}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Xh, Mh, Rh}} expresses finite element spaces (called FE spaces) \(X_h,\, M_h,\, R_h\), respectively.

\sphinxAtStartPar
The functions \(U_{h}, V_{h}\) have two components so we have


\subsection{Use of fespace in surface 3D}
\label{\detokenize{documentation/finite-element:use-of-fespace-in-surface-3d}}
\sphinxAtStartPar
With the 3D finite element spaces
\begin{equation*}
\begin{split}X_{h} = \{ v \in H^{1}(]0,1[^3) |\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{meshS} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square3}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//scalar FE}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Xh}} expresses finite element spaces (called FE spaces) \(X_h\), respectively.

\sphinxAtStartPar
To use FE\sphinxhyphen{}functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{//array of 10 functions in Xh}
\end{sphinxVerbatim}


\subsection{Finite Element functions}
\label{\detokenize{documentation/finite-element:finite-element-functions}}
\sphinxAtStartPar
To define and use FE\sphinxhyphen{}functions \(u_{h},v_{h} \in X_{h}\), \(p_{h},q_{h} \in M_{h}\) and \(U_{h},V_{h} \in R_{h}\), we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}
\PYG{n}{Xph} \PYG{n}{uph}\PYG{p}{,} \PYG{n}{vph}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ph}\PYG{p}{,} \PYG{n}{qh}\PYG{p}{;}
\PYG{n}{Rh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{,} \PYG{n}{Uyzh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Vxh}\PYG{p}{,} \PYG{n}{Vyh}\PYG{p}{,} \PYG{n}{Vyzh}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Xh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uh}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}             \PYG{c+c1}{//array of 10 functions in Xh}
\PYG{n}{Rh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{Wxh}\PYG{p}{,}\PYG{n}{Wyh}\PYG{p}{,}\PYG{n}{Wzh}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// array of 10 functions in Rh}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{//the 6th function at point (0.5, 0.5, 0.5)}
\PYG{n}{Wxh}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}                   \PYG{c+c1}{//the array of the degree of freedom of the 6th function}
\end{sphinxVerbatim}

\sphinxAtStartPar
The functions \(U_{h}, V_{h}\) have three components, so we have:
\begin{equation*}
\begin{split}U_{h}=\vectthree{(U_h)_x}{(U_h)_y}{(U_h)_z} \quad \mbox{and}\quad V_{h}=\vectthree{(V_h)_x}{(V_h)_y}{(V_h)_z}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
One challenge of the periodic boundary condition is that the mesh must have equivalent faces.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{buildlayers}} mesh generator splits each quadrilateral face with the diagonal passing through the vertex with maximum number, so to be sure to have the same mesh one both face periodic the 2D numbering in corresponding edges must be compatible (for example the same variation).

\sphinxAtStartPar
By Default, the numbering of square vertex is correct.

\sphinxAtStartPar
To change the mesh numbering you can use the \sphinxcode{\sphinxupquote{change}} function like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{old2new}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//array set on 0, 1, .., nv\PYGZhy{}1}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{sorder} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{;} \PYG{c+c1}{//choose an order increasing on 4 square borders with x or y}
    \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{old2new}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build the inverse permutation}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{new2old} \PYG{o}{=} \PYG{n}{old2new}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//inverse the permutation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{renumv}\PYG{o}{=}\PYG{n}{new2old}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The full example is in {\hyperref[\detokenize{examples/finite-element:exampleperiodic3d}]{\sphinxcrossref{\DUrole{std,std-ref}{examples}}}}.
\end{sphinxadmonition}


\subsection{Lagrangian Finite Elements}
\label{\detokenize{documentation/finite-element:lagrangian-finite-elements}}

\subsubsection{P0\sphinxhyphen{}element}
\label{\detokenize{documentation/finite-element:p0-element}}
\sphinxAtStartPar
For each triangle (d=2) or tetrahedron (d=3) \(T_k\), the basis function \(\phi_k\) in \sphinxcode{\sphinxupquote{Vh(Th, P0)}} is given by:
\begin{equation*}
\begin{split}\phi_k(\mathbf{x})=
\left\{
\begin{array}{cl}
    1 & \textrm{ if }(\mathbf{x})\in T_k\\
    0 & \textrm{ if }(\mathbf{x})\not\in T_k
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then for vertices \(q^{k_i},\, i=1,2,.. d+1\) in \hyperref[\detokenize{documentation/finite-element:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementp1p2}}}, \(f_h\) is built as \sphinxcode{\sphinxupquote{fh=}} \(\displaystyle f_h(x,y)=\sum_k f(\frac{\sum_i q^{k_i}}{d+1}) \phi_k\)

\sphinxAtStartPar
See \hyperref[\detokenize{documentation/finite-element:finiteelementprojp0}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementprojp0}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) on \sphinxcode{\sphinxupquote{Vh(Th, P0)}} when the mesh \sphinxcode{\sphinxupquote{Th}} is a \(4\times 4\)\sphinxhyphen{}grid of \([-1,1]^2\) as in \hyperref[\detokenize{documentation/finite-element:finiteelementp0p1p2p1nc}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementp0p1p2p1nc}}}.


\subsubsection{P1\sphinxhyphen{}element}
\label{\detokenize{documentation/finite-element:p1-element}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{FiniteElement_P1P2}.png}
\caption{\(P_1\) and \(P_2\) degrees of freedom on triangle \(T_k\)}\label{\detokenize{documentation/finite-element:finiteelementp1p2}}\end{figure}

\sphinxAtStartPar
For each vertex \(q^i\), the basis function \(\phi_i\) in \sphinxcode{\sphinxupquote{Vh(Th, P1)}} is given by:
\begin{equation*}
\begin{split}\phi_i(x,y)&=a^k_i+b^k_ix+c^k_iy \textrm{ for }(x,y)\in T_k,\\
\phi_i(q^i)&=1,\quad \phi_i(q^j)=0 \textrm{ if }i\neq j\end{split}
\end{equation*}
\sphinxAtStartPar
The basis function \(\phi_{k_1}(x,y)\) with the vertex \(q^{k_1}\) in \hyperref[\detokenize{documentation/finite-element:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementp1p2}}} at point \(p=(x,y)\) in triangle \(T_k\) simply coincide with the \sphinxstyleemphasis{barycentric coordinates} \(\lambda^k_1\) \sphinxstyleemphasis{(area coordinates)}:
\begin{equation*}
\begin{split}\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)=
\frac{\textrm{area of triangle} (p, q^{k_2},q^{k_3})}
{\textrm{area of triangle}(q^{k_1},q^{k_2},q^{k_3})}\end{split}
\end{equation*}
\sphinxAtStartPar
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{g}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)\)

\sphinxAtStartPar
See \hyperref[\detokenize{documentation/finite-element:finiteelementprojp1}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementprojp1}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_P0P1P2P1nc}.png}
\caption{Test mesh \sphinxcode{\sphinxupquote{Th}} for projection}\label{\detokenize{documentation/finite-element:id8}}\label{\detokenize{documentation/finite-element:finiteelementp0p1p2p1nc}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP0}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P0)}}}\label{\detokenize{documentation/finite-element:id9}}\label{\detokenize{documentation/finite-element:finiteelementprojp0}}\end{subfigure}
\caption{Finite element \sphinxcode{\sphinxupquote{P0}}}

\end{figure}



\subsubsection{P2\sphinxhyphen{}element}
\label{\detokenize{documentation/finite-element:p2-element}}\label{\detokenize{documentation/finite-element:FiniteElement}}
\sphinxAtStartPar
For each vertex or mid\sphinxhyphen{}point \(q^i\).
The basis function \(\phi_i\) in \sphinxcode{\sphinxupquote{Vh(Th, P2)}} is given by:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \phi_i(x,y)&=&a^k_i+b^k_ix+c^k_iy+d^k_ix^2+e^k_ixy+f^f_jy^2\textrm{ for }(x,y)\in T_k,\\
    \phi_i(q^i)&=&1,\quad \phi_i(q^j)=0\textrm{ if }i\neq j
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The basis function \(\phi_{k_1}(x,y)\) with the vertex \(q^{k_1}\) in \hyperref[\detokenize{documentation/finite-element:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementp1p2}}} is defined by the \sphinxstyleemphasis{barycentric coordinates}:
\begin{equation*}
\begin{split}\phi_{k_1}(x,y) = \lambda^k_{1}(x,y)(2\lambda^k_1(x,y)-1)\end{split}
\end{equation*}
\sphinxAtStartPar
and for the mid\sphinxhyphen{}point \(q^{k_2}\):
\begin{equation*}
\begin{split}\phi_{k_2}(x,y) = 4\lambda^k_1(x,y)\lambda^k_4(x,y)\end{split}
\end{equation*}
\sphinxAtStartPar
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{M}f(q^i)\phi_i(x,y)\quad (\textrm{summation over all vertex or mid-point})\)

\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/finite-element:finiteelementprojp2}]{\sphinxcrossref{\DUrole{std,std-ref}{Projection to Vh(Th, P2)}}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P2)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1)}}}\label{\detokenize{documentation/finite-element:id10}}\label{\detokenize{documentation/finite-element:finiteelementprojp1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP2}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P2)}}}\label{\detokenize{documentation/finite-element:id11}}\label{\detokenize{documentation/finite-element:finiteelementprojp2}}\end{subfigure}
\caption{Finite elements \sphinxcode{\sphinxupquote{P1, P2}}}

\end{figure}



\subsection{Surface Lagrangian Finite Elements}
\label{\detokenize{documentation/finite-element:surface-lagrangian-finite-elements}}\label{\detokenize{documentation/finite-element:surfacepklagrange}}\label{\detokenize{documentation/finite-element:FiniteElement}}

\subsubsection{Definition of the surface P1 Lagragian element}
\label{\detokenize{documentation/finite-element:definition-of-the-surface-p1-lagragian-element}}
\sphinxAtStartPar
To build the surface Pk\sphinxhyphen{}Lagrange, the main idea is to consider the usual 2d Lagrangian Finite Elements ; and its writing in barycentric coordinates ; apply a space transformation and barycentric properties.
The FreeFEM finite elements for surface problem are: \sphinxcode{\sphinxupquote{P0}} \sphinxcode{\sphinxupquote{P1}} \sphinxcode{\sphinxupquote{P2}} \sphinxcode{\sphinxupquote{P1b}}.

\sphinxAtStartPar
\sphinxstyleemphasis{0) Notation}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Let \(\hat K\) be the shape triangle in the space \(\mathbb{R}^2\) of vertice \((i_0,i_1,i_2)\)

\item {} 
\sphinxAtStartPar
Let \(K\) be a triangle of the space \(\mathbb{R}^3\) of vertice \((A_0,A_1,A_2)\)

\item {} 
\sphinxAtStartPar
\(x_q\) a quadrature point on K

\item {} 
\sphinxAtStartPar
\(X_q\) a quadrature point on A

\item {} 
\sphinxAtStartPar
\(P1_{2d}\) designates 2d P1 Lagrangian Finite Elements

\item {} 
\sphinxAtStartPar
\(P1_{S}\) designates surface 3d P1 Lagrangian Finite Elements

\item {} 
\sphinxAtStartPar
\((\lambda_i)_{i=0}^2\) shape fonction of \(\hat K\) (\(P1_{2d}\))

\item {} 
\sphinxAtStartPar
\((\psi_i)_{i=0}^2\) shape fonction of of \(K\) (\(P1_S\) )

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{1) Geometric transformation: from the current FE to the reference FE}

\sphinxAtStartPar
Let be \(\hat x= \begin{pmatrix}   \hat x \\ \hat y  \end{pmatrix}\) a point of the triangle \(\hat K \subset \mathbb{R}^2\) and \(X= \begin{pmatrix}   x \\  y  \\ z \end{pmatrix}\) a point of the triangle \(K \subset \mathbb{R}^3\), where \(\hat x\) and \(\hat X\) are expressed in baricentric coordinates.

\sphinxAtStartPar
The motivation here is to parameterize the 3d surface mesh to the reference 2d triangle, thus to be reduced to a finite element 2d P1.
Let’s define a geometric transformation F, such as \(F: \mathbb{R}^2 \rightarrow \mathbb{R}^3\)

\sphinxAtStartPar
However, thus defines transformation F as not bijective.

\sphinxAtStartPar
So, consider the following approximation
\begin{equation*}
\begin{split}\tilde F: \mathbb{R}^2 &\rightarrow \mathbb{R}^3  \\
\hat{x}   &\rightarrow  X  \\
\begin{pmatrix} x \\ y \\ 0 \end{pmatrix} &\rightarrow  \begin{pmatrix} \overrightarrow {A_0 A_1} \\ \overrightarrow {A_0A_2} \\ \overrightarrow {A_0A_1} \wedge  \overrightarrow     {A_0A_2} \end{pmatrix} ( \hat{x} -A_0)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\wedge\) denote the usual vector product.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.600\linewidth]{{geotransfo_P1s}.png}
\caption{F, a parameterization from the reference 2d triangle to a 3d surface triangle}\label{\detokenize{documentation/finite-element:id12}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\(\overrightarrow {A0A1} \wedge  \overrightarrow {A_0A_2} = \begin{pmatrix} n_x \\ n_y \\ n_z \end{pmatrix}\)  defines the normal to the tangent plane generated by \(( A_0,\overrightarrow {A_0A_1}, \overrightarrow {A_0A_2} )\)
\end{sphinxadmonition}

\sphinxAtStartPar
The affine transformation \(\tilde F\) allows you to pass from the 2d reference triangle, which we project in \(\mathbb{R}^3\) to the 3d current triangle, discretizing the surface we note \(\Gamma\).

\sphinxAtStartPar
Then \(\tilde F^{-1}\) is well defined and allows to return to the reference triangle \(\hat K\), to the usual coordinates of \(\mathbb{R}^2\) completed by the coordinate \(z=0\).

\sphinxAtStartPar
\sphinxstyleemphasis{2) Interpolation element fini}

\sphinxAtStartPar
Remember that the reference geometric element for the finite element \(P1s\) that we are building is the reference triangle \(\hat K\) in the vertex plane \((i_0, i_1, i_2\)), which we project into space by posing \(z=0\) by the membrane hypothesis.

\sphinxAtStartPar
Hence \(i_0 = \begin{pmatrix} 0 \\ 0 \\ 0 \end{pmatrix}\), \(i_1 = \begin{pmatrix} 1 \\ 0 \\ 0  \end{pmatrix}\), \(i_1 = \begin{pmatrix} 0 \\ 1 \\ 0 \end{pmatrix}\).

\sphinxAtStartPar
Let X be a point of the current triangle K, we have X= \(\tilde F(\hat{x})\).
The barycentric coordinates of X in K are given by:
\(X = \sum_{i=0} ^2  A_i \hat \lambda(\hat{x})\) où
\begin{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(A_i\) the points of the current triangle K

\item {} 
\sphinxAtStartPar
\(\hat \lambda_i\) basic functions \(P1_{2d}\)

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\hat \lambda_0(x,y) = 1-x-y\)

\item {} 
\sphinxAtStartPar
\(\hat \lambda_1(x,y) = x\)

\item {} 
\sphinxAtStartPar
\(\hat \lambda_2(x,y) = y\)

\end{itemize}
\end{quote}

\sphinxAtStartPar
We need to define a quadrature formula for the finite element approximation. The usual formulation for a 2d triangle will be used by redefining the quadrature points
\(X_q = x_q = \begin{pmatrix} \hat x_q \\ \hat y_q \\ 0 \end{pmatrix}\).

\sphinxAtStartPar
\sphinxstyleemphasis{3) The Lagragian P1 functions and theirs 1st order derivatives}

\sphinxAtStartPar
The finite element interpolation gives us the following relationship:
\(\psi_i(X) = F^{-1} (\psi_i)( F^{-1} (X))\).
To find the expression of the basic functions \(\psi\) on the current triangle K, it is sufficient to use the inverse of the transformation \(\tilde F\) to get back to the reference triangle \(\hat K\).
However in FreeFEM, the definition of the reference finite element, the current geometry is based on barycentric coordinates in order not to use geometric transformation. \(\tilde F\).
The method used here is  geometric and based on the properties of the vector product and the area of the current triangle K.

\sphinxAtStartPar
\sphinxstyleemphasis{i) The shape functions}

\sphinxAtStartPar
Let be the triangle K of vertices \(i_0, i_1, i_2 \subset  \mathbb{R}^3\) and \((\lambda_i)_{i=0} ^2\) the local barycentric coordinates at K.
The normal is defined as the tangent plane generated by \((A_0,  \overrightarrow {A_0A_1},  \overrightarrow {A_0A_2})\), \textbackslash{}
\(\vec n =  \overrightarrow {A_0A_1} \wedge  \overrightarrow {A_0A_2}\) avec \(\mid \mid \vec n \mid \mid  = 2 \text{ mes }(\hat K)\).

\sphinxAtStartPar
Le denotes the operator V, defines the usual vector product of  \(\mathbb{R}^3\) such as \(V(A,B,C) =  (B-A) \wedge (C-A)\)

\sphinxAtStartPar
The mixed product of three vectors u, v, w, noté \([u, v, w]\), is the determinant of these three vectors in any direct orthonormal basis, thus
\((A \wedge V,C)= \text{ det }(A,B,C)\)

\sphinxAtStartPar
with \((.,.)\) is the usual scalar product of \(\mathbb{R}^3\). \textbackslash{}
Let Ph :math:\textasciigrave{} in mathbb\{R\}\textasciicircum{}3\textasciigrave{} and P his projected in the triangle K such as:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=0.400\linewidth]{{subtriangle_P1s}.png}
\end{figure}

\sphinxAtStartPar
Let’s lay the sub\sphinxhyphen{}triangles as follows :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(K_0 = (P,A1,A2)\)

\item {} 
\sphinxAtStartPar
\(K_1 = (A0,P,A2)\)

\item {} 
\sphinxAtStartPar
\(K_2 = (A0,A1,P)\)

\end{itemize}

\sphinxAtStartPar
with  \(K = K_0 \cup K_1 \cup K_2\).
\begin{quote}

\begin{sphinxadmonition}{note}{Note:}\begin{description}
\item[{Properties in \(\mathbb{R}^3\)}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Let \(\vec n\) be the normal to the tangent plane generated by \((A_0, \overrightarrow {A_0A_1}, \overrightarrow {A_0A_2})\)

\item {} 
\sphinxAtStartPar
\(\vec n =\overrightarrow {A_0 A_1} \wedge \overrightarrow {A_0 A_2}\)

\item {} 
\sphinxAtStartPar
By definition,  \(\mathcal{A}= \frac{1}{2} \mid < \vec n,\vec n> \mid\) and the vectorial area by \(\mathcal{A^S}= \frac{1}{2} < \vec n,\vec n>\) hence  \(\mathcal{A^S} (PBC)= \frac{1}{2} < \vec n_0,\vec n>\), with \(\vec n_0\) the normal vector to the plane (PBC)

\end{itemize}

\end{description}
\end{sphinxadmonition}
\end{quote}

\sphinxAtStartPar
Let’s define the respective vector areas
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\vec N_0(P) =  V(P,A1,A2)\) the vectorial area of K0

\item {} 
\sphinxAtStartPar
\(\vec N_1(P) =  V(A0,P,A2)\) the vectorial area of K1

\item {} 
\sphinxAtStartPar
\(\vec N_2(P) =  V(A0,A1,P)\) the vectorial area of K2

\end{itemize}

\sphinxAtStartPar
By definition, in 3d, the barycentric coordinates are given by algebraic area ratio: :math:\textasciigrave{} lambda\_i(P) = frac \{(vec N\_i(P),vec N)\}\{(vec N,vec N)\}label\{basisfunc\}\textasciigrave{}

\sphinxAtStartPar
Note that \((\vec N_i(P) ,\vec N) = 2 \text{ sign } \text{ mes } (K_i) \mid \mid \vec N \mid \mid\)
and \((\vec N,\vec N) = 2 \text{ sign } \text{ mes } (K)  \mid \mid \vec N \mid \mid\), avec \(sign\) the orientation of the current triangle compared to the reference triangle.

\sphinxAtStartPar
We find the finite element interpolation,  \(P = \sum_{i=0}^2  \lambda_i(P) A_i\).

\sphinxAtStartPar
\sphinxstyleemphasis{ii) 1st order derivatives of Lagrangian P1 FE}

\sphinxAtStartPar
Let \(\vec Y\) be any vector of \(\in \mathbb{R}^3\).
\begin{equation*}
\begin{split}\begin{aligned}
(\vec N_2(P) ,\vec Y) &= ( (A_1-A_0) \wedge (P-A_0),Y) \\
&=\text{det}(A_1-A_0,P-A_0,Y)  \\
&= \text{det}(A_1-A_0,P,Y)- \text{det}(A_1-A_0,A_0,Y)
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
Let’s calculate the differential of \((\vec N_2(P),Y), \forall Y\)
\begin{equation*}
\begin{split}D_P (\vec N_2(P) ,\vec Y)  =  \text{det} (A_1-A_0,P',Y) dP \\
\begin{aligned}
\nabla_P (\vec N_2(P) ,\vec Y) &= \text{ det } (A_1-A_0, P' ,\vec Y) \\
&= - det (A_1-A_0, \vec Y, P') \\
&= - (A_1-A_0) \wedge \vec Y . P' \\
&=  \vec Y \wedge (A_1-A_0)
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
Consider in particular \(\vec Y = \vec N\), then
\begin{equation*}
\begin{split}\begin{aligned}
\nabla_P (\vec N_2(P) ,\vec N) &=  \vec N \wedge (A_1-A_0) \\
&=  \vec N \wedge E_2
&= - \text{det} (A_1-A_0, \vec Y, P')
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
This leads to
:math:\textasciigrave{} nabla\_P lambda\_2(P) = frac \{(vec N wedge E\_2)\}\{(vec N,vec N)\} \textasciigrave{}

\sphinxAtStartPar
By similar calculations for \(\vec N_0(P)$ et $\vec N_1(P)\)

\sphinxAtStartPar
\(\nabla_P \lambda_i(P) = \frac {(\vec N \wedge E_i)}{(\vec N,\vec N)}\label{derivbasisfunc}\)

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
With the definition of the surface gradient and the 2d Pk\sphinxhyphen{}Lagrange FE used barycentric coordinates, surface Pk\sphinxhyphen{}Langrange FE are trivial.
\end{sphinxadmonition}


\subsection{P1 Nonconforming Element}
\label{\detokenize{documentation/finite-element:p1-nonconforming-element}}
\sphinxAtStartPar
Refer to \sphinxcite{bibliography:thomasset2012} for details; briefly, we now consider non\sphinxhyphen{}continuous approximations so we will lose the property:
\begin{equation*}
\begin{split}w_h\in V_h\subset H^1(\Omega)\end{split}
\end{equation*}
\sphinxAtStartPar
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1nc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(m^i)\phi_i(x,y)\quad (\textrm{summation over all midpoint})\)

\sphinxAtStartPar
Here the basis function \(\phi_i\) associated with the mid\sphinxhyphen{}point \(m^i=(q^{k_i}+q^{k_{i+1}})/2\) where \(q^{k_i}\) is the \(i\)\sphinxhyphen{}th point in \(T_k\), and we assume that \(j+1=0\) if \(j=3\):
\begin{equation*}
\begin{split}\phi_i(x,y) &= a^k_i+b^k_ix+c^k_iy~\textrm{for }(x,y)\in T_k,\\
\phi_i(m^i) &= 1,\quad \phi_i(m^j)=0\textrm{ if }i\neq j\end{split}
\end{equation*}
\sphinxAtStartPar
Strictly speaking \(\p \phi_i/\p x,\, \p \phi_i/\p y\) contain Dirac distribution \(\rho \delta_{\p T_k}\).

\sphinxAtStartPar
The numerical calculations will automatically \sphinxstyleemphasis{ignore} them.
In \sphinxcite{bibliography:thomasset2012}, there is a proof of the estimation
\begin{equation*}
\begin{split}\left(\sum_{k=1}^{n_v}\int_{T_k}|\nabla w-\nabla w_h|^2\d x\d y\right)^{1/2} =O(h)\end{split}
\end{equation*}
\sphinxAtStartPar
The basis functions \(\phi_k\) have the following properties.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
For the bilinear form \(a\) defined in \hyperref[\detokenize{documentation/finite-element:finiteelementprojp1nc}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementprojp1nc}}} satisfy:
\begin{quote}
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\phi_i,\phi_i)>0,\qquad a(\phi_i,\phi_j)&\le& 0\quad\textrm{if }i\neq j\\
    \sum_{k=1}^{n_v}a(\phi_i,\phi_k)&\ge& 0
\end{array}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxAtStartPar
\(f\ge 0 \Rightarrow u_h\ge 0\)

\item {} 
\sphinxAtStartPar
If \(i\neq j\), the basis function \(\phi_i\) and \(\phi_j\) are \(L^2\)\sphinxhyphen{}orthogonal:
\begin{quote}
\begin{equation*}
\begin{split}\int_{\Omega}\phi_i\phi_j\, \d x\d y=0\qquad \textrm{if }i\neq j\end{split}
\end{equation*}
\sphinxAtStartPar
which is false for \(P_1\)\sphinxhyphen{}element.
\end{quote}

\end{enumerate}

\sphinxAtStartPar
See \hyperref[\detokenize{documentation/finite-element:finiteelementprojp1nc}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementprojp1nc}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1nc)}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1nc}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1nc)}}}\label{\detokenize{documentation/finite-element:id13}}\label{\detokenize{documentation/finite-element:finiteelementprojp1nc}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_projP1b}.png}
\caption{Projection to \sphinxcode{\sphinxupquote{Vh(Th, P1b)}}}\label{\detokenize{documentation/finite-element:id14}}\label{\detokenize{documentation/finite-element:finiteelementprojp1b}}\end{subfigure}
\caption{Finite elements \sphinxcode{\sphinxupquote{P1nc, P1b}}}

\end{figure}



\subsection{Other FE\sphinxhyphen{}space}
\label{\detokenize{documentation/finite-element:other-fe-space}}\label{\detokenize{documentation/finite-element:FiniteElement}}
\sphinxAtStartPar
For each triangle \(T_k\in \mathcal{T}_h\), let \(\lambda_{k_1}(x,y),\, \lambda_{k_2}(x,y),\, \lambda_{k_3}(x,y)\) be the area cordinate of the triangle (see \hyperref[\detokenize{documentation/finite-element:finiteelementp1p2}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementp1p2}}}), and put:
\begin{equation*}
\begin{split}\beta_k(x,y)=27\lambda_{k_1}(x,y)\lambda_{k_2}(x,y)\lambda_{k_3}(x,y)\end{split}
\end{equation*}
\sphinxAtStartPar
called \sphinxstyleemphasis{bubble} function on \(T_k\).
The bubble function has the feature: 1. \(\beta_k(x,y)=0\quad \textrm{if }(x,y)\in \p T_k\).
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
\(\beta_k(q^{k_b})=1\) where \(q^{k_b}\) is the barycenter \(\frac{q^{k_1}+q^{k_2}+q^{k_3}}{3}\).

\end{enumerate}

\sphinxAtStartPar
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1b}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle f_h(x,y)=\sum_{i=1}^{n_v}f(q^i)\phi_i(x,y)+\sum_{k=1}^{n_t}f(q^{k_b})\beta_k(x,y)\)

\sphinxAtStartPar
See \hyperref[\detokenize{documentation/finite-element:finiteelementprojp1b}]{Fig.\@ \ref{\detokenize{documentation/finite-element:finiteelementprojp1b}}} for the projection of \(f(x,y)=\sin(\pi x)\cos(\pi y)\) into \sphinxcode{\sphinxupquote{Vh(Th, P1b)}}.


\subsection{Vector Valued FE\sphinxhyphen{}function}
\label{\detokenize{documentation/finite-element:vector-valued-fe-function}}
\sphinxAtStartPar
Functions from \(\R^{2}\) to \(\R^{N}\) with \(N=1\) are called scalar functions and called \sphinxstyleemphasis{vector valued} when \(N>1\).
When \(N=2\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P0}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
makes the space
\begin{equation*}
\begin{split}V_h=\{\mathbf{w}=(w_1,w_2)|\; w_1\in V_h(\mathcal{T}_h,P_0),\,
w_2\in V_h(\mathcal{T}_h,P_1)\}\end{split}
\end{equation*}

\subsubsection{Raviart\sphinxhyphen{}Thomas Element}
\label{\detokenize{documentation/finite-element:raviart-thomas-element}}
\sphinxAtStartPar
In the Raviart\sphinxhyphen{}Thomas finite element \(RT0_{h}\), the degrees of freedom are the fluxes across edges \(e\) of the mesh, where the flux of the function \(\mathbf{f} : \R^2 \longrightarrow \R^2\) is \(\int_{e} \mathbf{f}.n_{e}\), \(n_{e}\) is the unit normal of edge \(e\).

\sphinxAtStartPar
This implies an orientation of all the edges of the mesh, for example we can use the global numbering of the edge vertices and we just go from small to large numbers.

\sphinxAtStartPar
To compute the flux, we use a quadrature with one Gauss point, the mid\sphinxhyphen{}point of the edge.

\sphinxAtStartPar
Consider a triangle \(T_k\) with three vertices \((\mathbf{a},\mathbf{b},\mathbf{c})\).

\sphinxAtStartPar
Lets denote the vertices numbers by \(i_{a},i_{b},i_{c}\), and define the three edge vectors \(\mathbf{e}^{1},\mathbf{e}^{2},\mathbf{e}^{3}\) by \(sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})\), \(sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})\), \(sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})\).

\sphinxAtStartPar
We get three basis functions:
\begin{equation*}
\begin{split}\boldsymbol{\phi}^{k}_{1}= \frac{sgn(i_{b}-i_{c})}{2|T_k|}(\mathbf{x}-\mathbf{a}),\quad
\boldsymbol{\phi}^{k}_{2}= \frac{sgn(i_{c}-i_{a})}{2|T_k|}(\mathbf{x}-\mathbf{b}),\quad
\boldsymbol{\phi}^{k}_{3}= \frac{sgn(i_{a}-i_{b})}{2|T_k|}(\mathbf{x}-\mathbf{c}),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(|T_k|\) is the area of the triangle \(T_k\).
If we write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{f1h}\PYG{p}{,} \PYG{n}{f2h}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{f1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
then:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fh =}} \(\displaystyle \mathbf{f}_h(x,y)=\sum_{k=1}^{n_t}\sum_{l=1}^6 n_{i_lj_l}|\mathbf{e^{i_l}}|f_{j_l}(m^{i_l})\phi_{i_lj_l}\)

\sphinxAtStartPar
where \(n_{i_lj_l}\) is the \(j_l\)\sphinxhyphen{}th component of the normal vector \(\mathbf{n}_{i_l}\),
\begin{equation*}
\begin{split}\{m_1,m_2,m_3\} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2},
\frac{\mathbf{a}+\mathbf{c}}{2},
\frac{\mathbf{b}+\mathbf{a}}{2} \right\}\end{split}
\end{equation*}
\sphinxAtStartPar
and \(i_l=\{1,1,2,2,3,3\},\, j_l=\{1,2,1,2,1,2\}\) with the order of \(l\).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FiniteElement_RT0}.png}
\caption{Normal vectors of each edge}\label{\detokenize{documentation/finite-element:finiteelementrt0}}\end{figure}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{uh} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{Uxh}\PYG{p}{,} \PYG{n}{Uyh}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//vectorial FE function}

\PYG{c+c1}{// Change the mesh}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Xh is unchanged}
\PYG{c+c1}{//Uxh = x; //error: impossible to set only 1 component}
          \PYG{c+c1}{//of a vector FE function}
\PYG{n}{vh} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{;}\PYG{c+c1}{//ok}
\PYG{c+c1}{//and now vh use the 5x5 mesh}
\PYG{c+c1}{//but the fespace of vh is always the 2x2 mesh}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{uh} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//do a interpolation of uh (old) of 5x5 mesh}
        \PYG{c+c1}{//to get the new uh on 10x10 mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vh}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//interpolate vh = ((x\PYGZhy{}1/2)\PYGZca{}2 + y\PYGZca{}2)}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_onoldmesh}.png}
\caption{\sphinxcode{\sphinxupquote{vh}} Iso on mesh \(2\times 2\)}\label{\detokenize{documentation/finite-element:id15}}\label{\detokenize{documentation/finite-element:finiteelementonoldmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_onnewmesh}.png}
\caption{\sphinxcode{\sphinxupquote{vh}} Iso on  mesh \(5\times 5\)}\label{\detokenize{documentation/finite-element:id16}}\label{\detokenize{documentation/finite-element:finiteelementonnewmesh}}\end{subfigure}
\phantomsection\label{\detokenize{documentation/finite-element:FiniteElement}}

\end{figure}


\sphinxAtStartPar
To get the value at a point \(x=1,y=2\) of the FE function \sphinxcode{\sphinxupquote{uh}}, or \sphinxcode{\sphinxupquote{{[}Uxh, Uyh{]}}}, one writes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{value}\PYG{p}{;}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get value = uh(2, 4)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get value = Uxh(2, 4)}
\PYG{c+c1}{//OR}
\PYG{k+kr}{x} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//get value = uh(1, 2)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uxh}\PYG{p}{;} \PYG{c+c1}{//get value = Uxh(1, 2)}
\PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{Uyh}\PYG{p}{;} \PYG{c+c1}{//get value = Uyh(1, 2)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To get the value of the array associated to the FE function \sphinxcode{\sphinxupquote{uh}}, one writes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{value} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//get the value of degree of freedom 0}
\PYG{k+kt}{real} \PYG{n}{maxdf} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;} \PYG{c+c1}{//maximum value of degree of freedom}
\PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{c+c1}{//the number of degree of freedom}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{array}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//copy the array of the function uh}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
For a non\sphinxhyphen{}scalar finite element function \sphinxcode{\sphinxupquote{{[}Uxh, Uyh{]}}} the two arrays \sphinxcode{\sphinxupquote{Uxh{[}{]}}} and \sphinxcode{\sphinxupquote{Uyh{[}{]}}} are the same array, because the degree of freedom can touch more than one component.
\end{sphinxadmonition}


\subsection{A Fast Finite Element Interpolator}
\label{\detokenize{documentation/finite-element:a-fast-finite-element-interpolator}}
\sphinxAtStartPar
In practice, one may discretize the variational equations by the Finite Element method.
Then there will be one mesh for \(\Omega_1\) and another one for \(\Omega_2\).
The computation of integrals of products of functions defined on different meshes is difficult.

\sphinxAtStartPar
Quadrature formula and interpolations from one mesh to another at quadrature points are needed.
We present below the interpolation operator which we have used and which is new, to the best of our knowledge.

\sphinxAtStartPar
Let \({\cal T}_{h}^0=\cup_k T^0_k,{\cal T}_{h}^1=\cup_k T^1_k\) be two triangulations of a domain \(\Omega\).
Let:
\begin{equation*}
\begin{split}V({\hbox{{\cal T}}_{h}^i}) =\{ C^0(\Omega_h^i)~:~f|_{T^i_k}\in P_0\},~~~i=0,1\end{split}
\end{equation*}
\sphinxAtStartPar
be the spaces of continuous piecewise affine functions on each triangulation.

\sphinxAtStartPar
Let \(f\in V({\cal T}_{h}^0)\).
The problem is to find \(g\in V({\cal T}_{h}^1)\) such that:
\begin{equation*}
\begin{split}g(q) = f(q) \quad \forall q\hbox{~vertex of ~} {\cal T}_{h}^1\end{split}
\end{equation*}
\sphinxAtStartPar
Although this is a seemingly simple problem, it is difficult to find an efficient algorithm in practice.

\sphinxAtStartPar
We propose an algorithm which is of complexity \(N^1\log N^0\), where \(N^i\) is the number of vertices of \(\cal T_{h}^i\), and which is very fast for most practical 2D applications.

\sphinxAtStartPar
\sphinxstylestrong{Algorithm}

\sphinxAtStartPar
The method has 5 steps.

\sphinxAtStartPar
First a quadtree is built containing all the vertices of the mesh \({\cal T}_{h}^0\) such that in each terminal cell there are at least one, and at most 4, vertices of \({\cal T}_{h}^0\).

\sphinxAtStartPar
For each \(q^1\), vertex of \({\cal T}_{h}^1\) do:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Find the terminal cell of the quadtree containing \(q^1\).

\item {} 
\sphinxAtStartPar
Find the the nearest vertex \(q^0_j\) to \(q^1\) in that cell.

\item {} 
\sphinxAtStartPar
Choose one triangle \(T_k^0\in{\cal T}_{h}^0\) which has \(q^0_j\) for vertex.

\item {} 
\sphinxAtStartPar
Compute the barycentric coordinates \(\{\lambda_j\}_{j=1,2,3}\) of \(q^1\) in \(T^0_k\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
if all barycentric coordinates are positive, go to Step 5

\item {} 
\sphinxAtStartPar
otherwise, if one barycentric coordinate \(\lambda_i\) is negative, replace \(T^0_k\) by the adjacent triangle opposite \(q^0_i\) and go to Step 4.

\item {} 
\sphinxAtStartPar
otherwise, if two barycentric coordinates are negative, take one of the two randomly and replace \(T^0_k\) by the adjacent triangle as above.

\end{itemize}

\item {} 
\sphinxAtStartPar
Calculate \(g(q^1)\) on \(T^0_k\) by linear interpolation of \(f\):
\begin{quote}
\begin{equation*}
\begin{split}g(q^1) = \sum_{j=1,2,3} \lambda_j f(q^0_j)\end{split}
\end{equation*}\end{quote}

\end{enumerate}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FiniteElement_fastInterpolate}.png}
\caption{To interpolate a function at \(q^0\), the knowledge of the triangle which contains \(q^0\) is needed. The algorithm may start at \(q^1\in T_k^0\) and stall on the boundary (thick line) because the line \(q^0q^1\) is not inside \(\Omega\).
But if the holes are triangulated too (doted line) then the problem does not arise.}\label{\detokenize{documentation/finite-element:finiteelementfastinterpolate}}\end{figure}

\sphinxAtStartPar
Two problems need to be solved:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{What if :math:\textasciigrave{}q\textasciicircum{}1\textasciigrave{} is not in} \(\Omega^0_h\) \sphinxstyleemphasis{?} Then Step 5 will stop with a boundary triangle.
\begin{quote}

\sphinxAtStartPar
So we add a step which tests the distance of \(q^1\) with the two adjacent boundary edges and selects the nearest, and so on till the distance grows.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{What if} \(\Omega^0_h\) \sphinxstyleemphasis{is not convex and the marching process of Step 4 locks on a boundary?} By construction Delaunay\sphinxhyphen{}Voronoï’s mesh generators always triangulate the convex hull of the vertices of the domain.
\begin{quote}

\sphinxAtStartPar
Therefore, we make sure that this information is not lost when \({\cal T}_{h}^0,{\cal T}_{h}^1\) are constructed and we keep the triangles which are outside the domain on a special list.

\sphinxAtStartPar
That way, in step 5 we can use that list to step over holes if needed.
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Sometimes, in rare cases, the interpolation process misses some points, we can change the search algorithm through a global variable \sphinxcode{\sphinxupquote{searchMethod}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{// default value for fast search algorithm}
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// safe search algorithm, uses brute force in case of missing point}
\PYG{c+c1}{// (warning: can be very expensive in cases where a lot of points are outside of the domain)}
\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// always uses brute force. It is very computationally expensive.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Step 3 requires an array of pointers such that each vertex points to one triangle of the triangulation.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The operator \sphinxcode{\sphinxupquote{=}} is the interpolation operator of \sphinxstylestrong{FreeFEM}, the continuous finite functions are extended by continuity to the outside of the domain.

\sphinxAtStartPar
Try the following example :
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thg} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n}{Thg}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ch}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ch} \PYG{n}{us} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Dh}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{n+nc}{P2dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Dh} \PYG{n}{vs} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Fh}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P2dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Fh} \PYG{n}{ug}\PYG{o}{=}\PYG{n}{us}\PYG{p}{,} \PYG{n}{vg}\PYG{o}{=}\PYG{n}{vs}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,} \PYG{n}{ug}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{vs}\PYG{p}{,} \PYG{n}{vg}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_UsUg}.png}
\caption{Extension of a continuous FE\sphinxhyphen{}function}\label{\detokenize{documentation/finite-element:id17}}\label{\detokenize{documentation/finite-element:finiteelementusug}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FiniteElement_VsVg}.png}
\caption{Extension of discontinuous FE\sphinxhyphen{}function}\label{\detokenize{documentation/finite-element:id18}}\label{\detokenize{documentation/finite-element:finiteelementvsvg}}\end{subfigure}
\caption{Extension of FE\sphinxhyphen{}function}

\end{figure}

\end{quote}
\end{sphinxadmonition}


\subsection{Keywords: Problem and Solve}
\label{\detokenize{documentation/finite-element:keywords-problem-and-solve}}\label{\detokenize{documentation/finite-element:Extension}}
\sphinxAtStartPar
For \sphinxstylestrong{FreeFEM}, a problem must be given in variational form, so we need a bilinear form \(a(u,v)\), a linear form \(\ell(f,v)\), and possibly a boundary condition form must be added.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{k+kr}{P} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{l}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
    \PYG{o}{+} \PYG{p}{(}\PYG{k+kp}{boundary} \PYG{n}{condition}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
When you want to formulate the problem and solve it in the same time, you can use the keyword \sphinxcode{\sphinxupquote{solve}}.
\end{sphinxadmonition}


\subsubsection{Weak Form and Boundary Condition}
\label{\detokenize{documentation/finite-element:weak-form-and-boundary-condition}}
\sphinxAtStartPar
To present the principles of Variational Formulations, also called weak form, for the Partial Differential Equations, let’s take a model problem: a Poisson equation with Dirichlet and Robin Boundary condition.

\sphinxAtStartPar
The problem: Find \(u\) a real function defined on a domain \(\Omega\) of \(\R^d\) \((d=2,3)\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\nabla\cdot(\kappa \nabla u) &=& f & \mbox{ in }\Omega\\
    a u + \kappa \frac{\p u}{\p n} &=& b & \mbox{ on }\Gamma_r\\
    u &=& g & \mbox{ on }\Gamma_d
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
if \(d=2\) then \(\nabla.(\kappa \nabla u) = \p_x(\kappa \p_x u ) + \p_y(\kappa \p_y u )\) with \(\p_x u = \frac{\p u}{\p x}\) and \(\p_y u = \frac{\p u}{\p y}\)

\item {} 
\sphinxAtStartPar
if \(d=3\) then \(\nabla.(\kappa \nabla u) = \p_x(\kappa \p_x u) + \p_y(\kappa \p_y u) + \p_z(\kappa \p_z u)\) with \(\p_x u = \frac{\p u}{\p x}\), \(\p_y u = \frac{\p u}{\p y}\) and , \(\p_z u = \frac{\p u}{\p z}\)

\item {} 
\sphinxAtStartPar
The border \(\Gamma=\p \Omega\) is split in \(\Gamma_d\) and \(\Gamma_n\) such that \(\Gamma_d \cap \Gamma_n = \emptyset\) and \(\Gamma_d \cup \Gamma_n = \p \Omega\),

\item {} 
\sphinxAtStartPar
\(\kappa\) is a given positive function, such that \(\exists \kappa_0 \in \R ,\quad 0 < \kappa_0 \leq \kappa\).

\item {} 
\sphinxAtStartPar
\(a\) a given non negative function,

\item {} 
\sphinxAtStartPar
\(b\) a given function.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This is the well known Neumann boundary condition if \(a=0\), and if \(\Gamma_d\) is empty.

\sphinxAtStartPar
In this case the function appears in the problem just by its derivatives, so it is defined only up to a constant (if \(u\) is a solution then \(u+c\) is also a solution).
\end{sphinxadmonition}

\sphinxAtStartPar
Let \({v}\), a regular test function, null on \(\Gamma_d\), by integration by parts we get:
\begin{equation*}
\begin{split}- \int_{\Omega} \nabla\cdot(\kappa \nabla u) \, {v} \,d\omega
= \int_{\Omega} \kappa \nabla{ v} \cdot \nabla u \,d\omega
- \int_{\Gamma} {v}\kappa \frac{ \p u}{\p \mathbf{n}} \,d\gamma,= \int_{\Omega} f {v} \,d\omega\end{split}
\end{equation*}
\sphinxAtStartPar
where if \(d=2\) the \(\nabla{ v} . \nabla u = (\frac{\p u}{\p x}\frac{\p { v}}{\p x}+\frac{\p u}{\p y}\frac{\p { v}}{\p y})\),

\sphinxAtStartPar
where if \(d=3\) the \(\nabla{ v} . \nabla u = (\frac{\p u}{\p x}\frac{\p { v}}{\p x}+\frac{\p u}{\p y}\frac{\p { v}}{\p y} + \frac{\p u}{\p z}\frac{\p { v}}{\p z})\),

\sphinxAtStartPar
and where \(\mathbf{n}\) is the unitary outer\sphinxhyphen{}pointing normal of the \(\Gamma\).

\sphinxAtStartPar
Now we note that \(\kappa \frac{ \p u}{\p n} = - a u + b\) on \(\Gamma_r\) and \(v=0\) on \(\Gamma_d\) and \(\Gamma = \Gamma_d \cup \Gamma_n\) thus:
\begin{equation*}
\begin{split}- \int_{\Gamma} {v}
\kappa \frac{ \p u}{\p n} = \int_{\Gamma_r} a u v - \int_{\Gamma_r} b v\end{split}
\end{equation*}
\sphinxAtStartPar
The problem becomes:

\sphinxAtStartPar
Find \(u \in V_g = \{w \in H^1(\Omega) / w = g \mbox{ on } \Gamma_d \}\) such that:
\begin{equation}\label{equation:documentation/finite-element:eqn::v-poisson}
\begin{split}{\int_{\Omega} \kappa \nabla{ v} . \nabla u \,d\omega + \int_{\Gamma_r} a u v \,d\gamma = \int_{\Omega} f {v}} \,d\omega
+ \int_{\Gamma_r} b v \,d\gamma , \quad \forall v \in V_0\end{split}
\end{equation}
\sphinxAtStartPar
where \(V_0 = \{v \in H^1(\Omega) / v = 0 \mbox{ on } \Gamma_d \}\)

\sphinxAtStartPar
Except in the case of Neumann conditions everywhere, the problem \eqref{equation:documentation/finite-element:eqn::v-poisson} is well posed when \(\kappa\geq \kappa_0>0\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If we have only the Neumann boundary condition, linear algebra tells us that the right hand side must be orthogonal to the kernel of the operator for the solution to exist.
\begin{quote}

\sphinxAtStartPar
One way of writing the compatibility condition is:
\begin{equation*}
\begin{split}\int_{\Omega} f \,d\omega + \int_{\Gamma} b \,d\gamma=0\end{split}
\end{equation*}
\sphinxAtStartPar
and a way to fix the constant is to solve for \(u \in H^1(\Omega)\) such that:
\begin{equation*}
\begin{split}{\int_{\Omega} (\varepsilon u v \; + \; \kappa \nabla{ v} . \nabla u) \,d\omega
= \int_{\Omega} f {v}} \,d\omega + \int_{\Gamma_r} b v \,d\gamma , \quad \forall v \in H^1(\Omega)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\varepsilon\) is a small parameter (\(\sim \kappa\; 10^{-10} |\Omega|^{\frac2d}\)).
\end{quote}

\sphinxAtStartPar
Remark that if the solution is of order \(\frac{1}{\varepsilon}\) then the compatibility condition is unsatisfied, otherwise we get the solution such that \(\int_\Omega u = 0\), you can also add a Lagrange multiplier to solve the real mathematical problem like in the {\hyperref[\detokenize{examples/finite-element:examplelagrangemultipliers}]{\sphinxcrossref{\DUrole{std,std-ref}{Lagrange multipliers example}}}}.
\end{sphinxadmonition}

\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM}, the bidimensional problem \eqref{equation:documentation/finite-element:eqn::v-poisson} becomes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{Pw} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{o}{/}\PYG{o}{/}\PYG{n}{int\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{Omega}\PYG{p}{\PYGZcb{}} \PYG{n}{kappa} \PYG{n}{nabla} \PYG{n}{v} \PYG{p}{.} \PYG{n}{nabla} \PYG{n}{u}
        \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} a u v}
        \PYG{n}{a} \PYG{o}{*} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Omega\PYGZcb{} f v}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} b v}
        \PYG{n}{b} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{gd}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{//u = g on Gamma\PYGZus{}d}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Th}} is a mesh of the bi\sphinxhyphen{}dimensional domain \(\Omega\), and \sphinxcode{\sphinxupquote{gd}} and \sphinxcode{\sphinxupquote{gn}} are respectively the boundary labels of boundary \(\Gamma_d\) and \(\Gamma_n\).

\sphinxAtStartPar
And the three dimensional problem \eqref{equation:documentation/finite-element:eqn::v-poisson} becomes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{problem} \PYG{n}{Pw} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{o}{/}\PYG{o}{/}\PYG{n}{int\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{Omega}\PYG{p}{\PYGZcb{}} \PYG{n}{kappa} \PYG{n}{nabla} \PYG{n}{v} \PYG{p}{.} \PYG{n}{nabla} \PYG{n}{u}
        \PYG{n}{kappa}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} a u v}
        \PYG{n}{a} \PYG{o}{*} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Omega\PYGZcb{} f v}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{gn}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//int\PYGZus{}\PYGZob{}Gamma\PYGZus{}r\PYGZcb{} b v}
        \PYG{n}{b} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{gd}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{//u = g on Gamma\PYGZus{}d}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{Th}} is a mesh of the three dimensional domain \(\Omega\), and \sphinxcode{\sphinxupquote{gd}} and \sphinxcode{\sphinxupquote{gn}} are respectively the boundary labels of boundary \(\Gamma_d\) and \(\Gamma_n\).


\subsection{Parameters affecting solve and problem}
\label{\detokenize{documentation/finite-element:parameters-affecting-solve-and-problem}}
\sphinxAtStartPar
The parameters are FE functions real or complex, the number \(n\) of parameters is even (\(n=2*k\)), the \(k\) first function parameters are unknown, and the \(k\) last are test functions.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If the functions are a part of vectorial FE then you must give all the functions of the vectorial FE in the same order (see {\hyperref[\detokenize{models/static-problems:modelstaticpoissonwithmixedboundarycondition}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson problem with mixed finite element}}}} for example).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Don’t mix complex and real parameters FE function.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
\sphinxstylestrong{Bug:}

\sphinxAtStartPar
The mixing of multiple \sphinxcode{\sphinxupquote{fespace}} with different periodic boundary conditions are not implemented.

\sphinxAtStartPar
So all the finite element spaces used for tests or unknown functions in a problem, must have the same type of periodic boundary conditions or no periodic boundary conditions.

\sphinxAtStartPar
No clean message is given and the result is unpredictable.
\end{sphinxadmonition}

\sphinxAtStartPar
The parameters are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{solver=} \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{CG}}, \sphinxcode{\sphinxupquote{Crout}},  \sphinxcode{\sphinxupquote{Cholesky}}, \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}}, \sphinxcode{\sphinxupquote{UMFPACK}} …
\begin{quote}

\sphinxAtStartPar
The default solver is \sphinxcode{\sphinxupquote{sparsesolver}} (it is equal to \sphinxcode{\sphinxupquote{UMFPACK}} if no other sparse solver is defined) or is set to \sphinxcode{\sphinxupquote{LU}} if no direct sparse solver is available.

\sphinxAtStartPar
The storage mode of the matrix of the underlying linear system depends on the type of solver chosen; for \sphinxcode{\sphinxupquote{LU}} the matrix is sky\sphinxhyphen{}line non symmetric, for \sphinxcode{\sphinxupquote{Crout}} the matrix is sky\sphinxhyphen{}line symmetric, for \sphinxcode{\sphinxupquote{Cholesky}} the matrix is sky\sphinxhyphen{}line symmetric positive definite, for \sphinxcode{\sphinxupquote{CG}} the matrix is sparse symmetric positive, and for \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{UMFPACK}} the matrix is just sparse.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{eps=} a real expression.
\begin{quote}

\sphinxAtStartPar
\(\varepsilon\) sets the stopping test for the iterative methods like \sphinxcode{\sphinxupquote{CG}}.

\sphinxAtStartPar
Note that if \(\varepsilon\) is negative then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < |\varepsilon|\end{split}
\end{equation*}
\sphinxAtStartPar
if it is positive, then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{init=} boolean expression, if it is false or 0 the matrix is reconstructed.
\begin{quote}

\sphinxAtStartPar
Note that if the mesh changes the matrix is reconstructed too.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{precon=} name of a function (for example \sphinxcode{\sphinxupquote{P}}) to set the preconditioner.
\begin{quote}

\sphinxAtStartPar
The prototype for the function \sphinxcode{\sphinxupquote{P}} must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{xx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{tgv=} Huge value (\(10^{30}\)) used to implement Dirichlet boundary conditions.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{tolpivot=} sets the tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}} (\(10^{-1}\)) and, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorisation (\(10^{-20}\)).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{tolpivotsym=} sets the tolerance of the pivot sym in \sphinxcode{\sphinxupquote{UMFPACK}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{strategy=} sets the integer \sphinxcode{\sphinxupquote{UMFPACK}} strategy (\(0\) by default).

\end{itemize}


\subsection{Problem definition}
\label{\detokenize{documentation/finite-element:problem-definition}}\label{\detokenize{documentation/finite-element:problemdefinition}}
\sphinxAtStartPar
Below \sphinxcode{\sphinxupquote{v}} is the unknown function and \sphinxcode{\sphinxupquote{w}} is the test function.

\sphinxAtStartPar
After the “=” sign, one may find sums of:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identifier(s); this is the name given earlier to the variational form(s) (type \sphinxcode{\sphinxupquote{varf}} ) for possible reuse.
\begin{quote}

\sphinxAtStartPar
Remark, that the name in the \sphinxcode{\sphinxupquote{varf}} of the unknown test function is forgotten, we use the order in the argument list to recall names as in a \sphinxcode{\sphinxupquote{C++}} function,
\end{quote}

\item {} 
\sphinxAtStartPar
The terms of the bilinear form itself: if \(K\) is a given function,

\item {} 
\sphinxAtStartPar
Bilinear part for 3D meshes \sphinxcode{\sphinxupquote{Th}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap (\Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intallfaces(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intallfaces(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxAtStartPar
They contribute to the sparse matrix of type \sphinxcode{\sphinxupquote{matrix}} which, whether declared explicitly or not, is constructed by \sphinxstylestrong{FreeFEM}.

\end{itemize}

\item {} 
\sphinxAtStartPar
Bilinear part for 2D meshes \sphinxcode{\sphinxupquote{Th}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T } K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi<0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{1}}\int_{T} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5})} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, l, levelset=phi)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intalledges(Th)(K*v*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intalledges(Th, 1)(K*v*w) =}} \(\displaystyle\sum_{{T\in\mathtt{Th},T\subset \Omega_{1}}}\int_{\p T } K\,v\,w\)

\item {} 
\sphinxAtStartPar
They contribute to the sparse matrix of type \sphinxcode{\sphinxupquote{matrix}} which, whether declared explicitly or not, is constructed by \sphinxstylestrong{FreeFEM}.

\item {} 
\sphinxAtStartPar
The right hand\sphinxhyphen{}side of the Partial Differential Equation in 3D, the terms of the linear form: for given functions \(K,\, f\):

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th, l)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\in\Omega_l}\int_{T} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int3d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, 2, 5)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5}) } K \,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset \Omega_{l}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intallfaces(Th)(f*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } f\,w\)

\item {} 
\sphinxAtStartPar
A vector of type \sphinxcode{\sphinxupquote{real{[}int{]}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
The right hand\sphinxhyphen{}side of the Partial Differential Equation in 2D, the terms of the linear form: for given functions \(K,\, f\):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, l)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\in\Omega_l}\int_{T} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int2d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi<0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, 2, 5)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{(\p T\cup\Gamma) \cap ( \Gamma_2 \cup \Gamma_{5}) } K \,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int1d(Th, l, levelset=phi)(K*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th},T\subset\Omega_{l}}\int_{T,\phi=0} K\,w\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intalledges(Th)(f*w) =}} \(\displaystyle\sum_{T\in\mathtt{Th}}\int_{\p T } f\,w\)

\item {} 
\sphinxAtStartPar
a vector of type \sphinxcode{\sphinxupquote{real{[}int{]}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
The boundary condition terms:
\begin{itemize}
\item {} 
\sphinxAtStartPar
An “on” scalar form (for Dirichlet) : \sphinxcode{\sphinxupquote{on(1, u=g)}}
\begin{quote}

\sphinxAtStartPar
Used for all degrees of freedom \(i\) of the boundary referred by “1”, the diagonal term of the matrix \(a_{ii}= tgv\) with the \sphinxstyleemphasis{terrible giant value} \sphinxcode{\sphinxupquote{tgv}} (= \(10^{30}\) by default), and the right hand side \(b[i] = "(\Pi_h g)[i]" \times tgv\), where the \("(\Pi_h g)g[i]"\) is the boundary node value given by the interpolation of \(g\).
\end{quote}

\item {} 
\sphinxAtStartPar
A linear form on \(\Gamma\) (for Neumann in 2d) \sphinxcode{\sphinxupquote{\sphinxhyphen{}int1d(Th)(f*w)}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}int1d(Th, 3)(f*w)}}

\item {} 
\sphinxAtStartPar
A bilinear form on \(\Gamma\) or \(\Gamma_{2}\) (for Robin in 2d) \sphinxcode{\sphinxupquote{int1d(Th)(K*v*w)}} or \sphinxcode{\sphinxupquote{int1d(Th,2)(K*v*w)}}

\item {} 
\sphinxAtStartPar
A linear form on \(\Gamma\) (for Neumann in 3d) \sphinxcode{\sphinxupquote{\sphinxhyphen{}int2d(Th)(f*w)}} or \sphinxcode{\sphinxupquote{\sphinxhyphen{}int2d(Th, 3)(f*w)}}

\item {} 
\sphinxAtStartPar
A bilinear form on \(\Gamma\) or \(\Gamma_{2}\) (for Robin in 3d) \sphinxcode{\sphinxupquote{int2d(Th)(K*v*w)}} or \sphinxcode{\sphinxupquote{int2d(Th,2)(K*v*w)}}

\end{itemize}

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}\begin{itemize}
\item {} 
\sphinxAtStartPar
An “on” vectorial form (for Dirichlet): \sphinxcode{\sphinxupquote{on(1, u1=g1, u2=g2)}}

\end{itemize}

\sphinxAtStartPar
If you have vectorial finite element like \sphinxcode{\sphinxupquote{RT0}}, the 2 components are coupled, and so you have : \(b[i] = "(\Pi_h (g1,g2))[i]" \times tgv\), where \(\Pi_h\) is the vectorial finite element interpolant.
\begin{itemize}
\item {} 
\sphinxAtStartPar
An “on” vectorial form (for Dirichlet):   \sphinxcode{\sphinxupquote{on(u=g, tgv= none positive value  )}} ,

\end{itemize}
\begin{quote}

\sphinxAtStartPar
if the value is equal to \sphinxhyphen{}2 (i.e \sphinxcode{\sphinxupquote{tgv == \sphinxhyphen{}2 \textasciigrave{}) then   we put to :math:\textasciigrave{}0}} all term of the line and colomn  \(i\) in the matrix, except diagonal term \(a_{ii}=1\), and \(b[i] = "(\Pi_h g)[i]"\)
else if the value is equal to  \sphinxhyphen{}20 (i.e \sphinxcode{\sphinxupquote{tgv == \sphinxhyphen{}20 \textasciigrave{}) then   we put to :math:\textasciigrave{}0}} all term of the line and colomn  \(i\) in the matrix, and \(b[i] = "(\Pi_h g)[i]"\)

\sphinxAtStartPar
else if the value is equal to \sphinxhyphen{}10 (i.e \sphinxcode{\sphinxupquote{tgv == \sphinxhyphen{}10 \textasciigrave{}) then   we put to :math:\textasciigrave{}0}} all term of the line the matrix, and \(b[i] = "(\Pi_h g)[i]"\)

\sphinxAtStartPar
else  (i.e \sphinxcode{\sphinxupquote{tgv == \sphinxhyphen{}1 \textasciigrave{}) we put to :math:\textasciigrave{}0}} all term of the line \(i\) in the matrix, except diagonal term \(a_{ii}=1\), and \(b[i] = "(\Pi_h g)[i]"\).
\end{quote}
\begin{itemize}
\item {} 
\sphinxAtStartPar
If needed, the different kind of terms in the sum can appear more than once.

\item {} 
\sphinxAtStartPar
The integral mesh and the mesh associated to test functions or unknown functions can be different in the case of \sphinxcode{\sphinxupquote{varf}} form.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{N.x}}, \sphinxcode{\sphinxupquote{N.y}} and \sphinxcode{\sphinxupquote{N.z}} are the normal’s components.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Ns.x}}, \sphinxcode{\sphinxupquote{Ns.y}} and \sphinxcode{\sphinxupquote{Ns.z}} are the normal’s components of the suface in case of \sphinxcode{\sphinxupquote{meshS}} integral

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tl.x}}, \sphinxcode{\sphinxupquote{Tl.y}} and \sphinxcode{\sphinxupquote{Tl.z}} are the tangent’s components of the line  in case of \sphinxcode{\sphinxupquote{meshL}} integral

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
It is not possible to write in the same integral the linear part and the bilinear part such as in \sphinxcode{\sphinxupquote{int1d(Th)(K*v*w \sphinxhyphen{} f*w)}}.
\end{sphinxadmonition}


\subsection{Numerical Integration}
\label{\detokenize{documentation/finite-element:numerical-integration}}
\sphinxAtStartPar
Let \(D\) be a \(N\)\sphinxhyphen{}dimensional bounded domain.

\sphinxAtStartPar
For an arbitrary polynomial \(f\) of degree \(r\), if we can find particular (quadrature) points \(\mathbf{\xi}_j,\, j=1,\cdots,J\) in \(D\) and (quadrature) constants \(\omega_j\) such that
\begin{equation*}
\begin{split}\int_{D}f(\mathbf{x}) = \sum_{\ell =1}^L c_\ell f(\mathbf{\xi}_\ell)\end{split}
\end{equation*}
\sphinxAtStartPar
then we have an error estimate (see \sphinxcite{bibliography:crouzeix1984}), and then there exists a constant \(C>0\) such that
\begin{equation*}
\begin{split}\left|\int_{D}f(\mathbf{x}) - \sum_{\ell =1}^L \omega_\ell
f(\mathbf{\xi}_\ell )\right|
\le C|D|h^{r+1}\end{split}
\end{equation*}
\sphinxAtStartPar
for any function \(r + 1\) times continuously differentiable \(f\) in \(D\), where \(h\) is the diameter of \(D\) and \(|D|\) its measure (a point in the segment \([q^iq^j]\) is given as
\begin{equation*}
\begin{split}\{(x,y)|\; x=(1-t)q^i_x+tq^j_x,\, y=(1-t)q^i_y+tq^j_y,\, 0\le t\le 1\}\end{split}
\end{equation*}
\sphinxAtStartPar
For a domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Gamma_h=\p\Omega_h\) by:

\sphinxAtStartPar
\(\int_{\Gamma_h}f(\mathbf{x})ds\) =\sphinxcode{\sphinxupquote{int1d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, qfe=*)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, qforder=*)(f)}}

\sphinxAtStartPar
where * stands for the name of the quadrature formula or the precision (order) of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Quadrature formula on an edge
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\(L\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfe}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Point in \([q^i, q^j]\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(\omega_\ell\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact on \(P_k,\ k=\)
\\
\hline
\sphinxAtStartPar
\(1\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf1pE}}
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(1/2\)
&
\sphinxAtStartPar
\(||q^iq^j||\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf2pE}}
&
\sphinxAtStartPar
\(3\)
&
\sphinxAtStartPar
\((1\pm\sqrt{1/3})/2\)
&
\sphinxAtStartPar
\(||q^iq^j||/2\)
&
\sphinxAtStartPar
\(3\)
\\
\hline
\sphinxAtStartPar
\(3\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf3pE}}
&
\sphinxAtStartPar
\(6\)
&
\sphinxAtStartPar
\((1\pm\sqrt{3/5})/2\)

\sphinxAtStartPar
\(1/2\)
&
\sphinxAtStartPar
\((5/18)||q^iq^j||\)

\sphinxAtStartPar
\((8/18)||q^iq^j||\)
&
\sphinxAtStartPar
\(5\)
\\
\hline
\sphinxAtStartPar
\(4\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf4pE}}
&
\sphinxAtStartPar
\(8\)
&
\sphinxAtStartPar
\((1\pm\frac{525+70\sqrt{30}}{35})/2\)

\sphinxAtStartPar
\((1\pm\frac{525-70\sqrt{30}}{35})/2\)
&
\sphinxAtStartPar
\(\frac{18-\sqrt{30}}{72}||q^iq^j||\)

\sphinxAtStartPar
\(\frac{18+\sqrt{30}}{72}||q^iq^j||\)
&
\sphinxAtStartPar
\(7\)
\\
\hline
\sphinxAtStartPar
\(5\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf5pE}}
&
\sphinxAtStartPar
\(10\)
&
\sphinxAtStartPar
\((1\pm\frac{245+14\sqrt{70}}{21})/2\)

\sphinxAtStartPar
\(1/2\)

\sphinxAtStartPar
\((1\pm\frac{245-14\sqrt{70}}{21})/2\)
&
\sphinxAtStartPar
\(\frac{322-13\sqrt{70}}{1800}||q^iq^j||\)

\sphinxAtStartPar
\(\frac{64}{225}||q^iq^j||\)

\sphinxAtStartPar
\(\frac{322+13\sqrt{70}}{1800}||q^iq^j||\)
&
\sphinxAtStartPar
\(9\)
\\
\hline
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf1pElump}}
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(0\)

\sphinxAtStartPar
\(1\)
&
\sphinxAtStartPar
\(||q^iq^j||/2\)

\sphinxAtStartPar
\(||q^iq^j||/2\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
where \(|q^iq^j|\) is the length of segment \(\overline{q^iq^j}\).

\sphinxAtStartPar
For a part \(\Gamma_1\) of \(\Gamma_h\) with the label “1”, we can calculate the integral over \(\Gamma_1\) by:

\sphinxAtStartPar
\(\int_{\Gamma_1}f(x,y)ds\) =\sphinxcode{\sphinxupquote{int1d(Th, 1)(f)}}
=\sphinxcode{\sphinxupquote{int1d(Th, 1, qfe=qf2pE)(f)}}

\sphinxAtStartPar
The integrals over \(\Gamma_1,\, \Gamma_3\) are given by:

\sphinxAtStartPar
\(\int_{\Gamma_1\cup \Gamma_3}f(x,y)ds\)

\sphinxAtStartPar
For each triangle \(T_k=[q^{k_1}q^{k_2}q^{k_3}]\), the point \(P(x,y)\) in \(T_k\) is expressed by the \sphinxstyleemphasis{area coordinate} as \(P(\xi,\eta)\):
\begin{equation*}
\begin{split}&|T_k|=\frac12 \left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|\quad
D_1=\left|
\begin{array}{ccc}
    1&x&y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_2=\left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&x&y\\
    1&q^{k_3}_x&q^{k_3}_y
\end{array}
\right|
\quad
D_3=\left|
\begin{array}{ccc}
    1&q^{k_1}_x&q^{k_1}_y\\
    1&q^{k_2}_x&q^{k_2}_y\\
    1&x&y
\end{array}
\right|\\
&\xi=\frac12 D_1/|T_k|\qquad
\eta=\frac12 D_2/|T_k|\qquad \textrm{then }
1-\xi-\eta=\frac12 D_3/|T_k|\end{split}
\end{equation*}
\sphinxAtStartPar
For a two dimensional domain or a border of three dimensional domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Omega_h\) by:

\sphinxAtStartPar
\(\int_{\Omega_h}f(x,y)\) =\sphinxcode{\sphinxupquote{int2d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int2d(Th, qft=*)(f)}}
=\sphinxcode{\sphinxupquote{int2d(Th, qforder=*)(f)}}

\sphinxAtStartPar
where * stands for the name of quadrature formula or the order of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Quadrature formula on a triangle
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\(L\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qft}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Point in \(T_k\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(\omega_\ell\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact on \(P_k,\ k=\)
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf1pT}}
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
\(\left(\frac{1}{3},\frac{1}{3}\right)\)
&
\sphinxAtStartPar
\(|T_k|\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf2pT}}
&
\sphinxAtStartPar
3
&
\sphinxAtStartPar
\(\left(\frac{1}{2},\frac{1}{2}\right)\)

\sphinxAtStartPar
\(\left(\frac{1}{2},0\right)\)

\sphinxAtStartPar
\(\left(0,\frac{1}{2}\right)\)
&
\sphinxAtStartPar
\(|T_k|/3\)

\sphinxAtStartPar
\(|T_k|/3\)

\sphinxAtStartPar
\(|T_k|/3\)
&
\sphinxAtStartPar
\(2\)
\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf5pT}}
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
\(\left(\frac{1}{3},\frac{1}{3}\right)\)

\sphinxAtStartPar
\(\left(\frac{6-\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)\)

\sphinxAtStartPar
\(\left(\frac{6-\sqrt{15}}{21},\frac{9+2\sqrt{15}}{21}\right)\)

\sphinxAtStartPar
\(\left(\frac{9+2\sqrt{15}}{21},\frac{6-\sqrt{15}}{21}\right)\)

\sphinxAtStartPar
\(\left(\frac{6+\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)\)

\sphinxAtStartPar
\(\left(\frac{6+\sqrt{15}}{21},\frac{9-2\sqrt{15}}{21}\right)\)

\sphinxAtStartPar
\(\left(\frac{9-2\sqrt{15}}{21},\frac{6+\sqrt{15}}{21}\right)\)
&
\sphinxAtStartPar
\(0.225|T_k|\)

\sphinxAtStartPar
\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\sphinxAtStartPar
\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\sphinxAtStartPar
\(\frac{(155-\sqrt{15})|T_k|}{1200}\)

\sphinxAtStartPar
\(\frac{(155+\sqrt{15})|T_k|}{1200}\)

\sphinxAtStartPar
\(\frac{(155+\sqrt{15})|T_k|}{1200}\)

\sphinxAtStartPar
\(\frac{(155+\sqrt{15})|T_k|}{1200}\)
&
\sphinxAtStartPar
\(5\)
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf1pTlump}}
&&
\sphinxAtStartPar
\(\left(0,0\right)\)

\sphinxAtStartPar
\(\left(1,0\right)\)

\sphinxAtStartPar
\(\left(0,1\right)\)
&
\sphinxAtStartPar
\(|T_k|/3\)

\sphinxAtStartPar
\(|T_k|/3\)

\sphinxAtStartPar
\(|T_k|/3\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf2pT4P1}}
&&
\sphinxAtStartPar
\(\left(\frac{1}{4},\frac{3}{4}\right)\)

\sphinxAtStartPar
\(\left(\frac{3}{4},\frac{1}{4}\right)\)

\sphinxAtStartPar
\(\left(0,\frac{1}{4}\right)\)

\sphinxAtStartPar
\(\left(0,\frac{3}{4}\right)\)

\sphinxAtStartPar
\(\left(\frac{1}{4},0\right)\)

\sphinxAtStartPar
\(\left(\frac{3}{4},0\right)\)

\sphinxAtStartPar
\(\left(\frac{1}{4},\frac{1}{4}\right)\)

\sphinxAtStartPar
\(\left(\frac{1}{4},\frac{1}{2}\right)\)

\sphinxAtStartPar
\(\left(\frac{1}{2},\frac{1}{4}\right)\)
&
\sphinxAtStartPar
\(|T_k|/12\)

\sphinxAtStartPar
\(|T_k|/12\)

\sphinxAtStartPar
\(|T_k|/12\)

\sphinxAtStartPar
\(|T_k|/12\)

\sphinxAtStartPar
\(|T_k|/12\)

\sphinxAtStartPar
\(|T_k|/12\)

\sphinxAtStartPar
\(|T_k|/6\)

\sphinxAtStartPar
\(|T_k|/6\)

\sphinxAtStartPar
\(|T_k|/6\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\sphinxAtStartPar
15
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf7pT}}
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
See \sphinxcite{bibliography:taylor2005} for detail
&&
\sphinxAtStartPar
7
\\
\hline
\sphinxAtStartPar
21
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qf9pT}}
&
\sphinxAtStartPar
10
&
\sphinxAtStartPar
See \sphinxcite{bibliography:taylor2005} for detail
&&
\sphinxAtStartPar
9
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
For a three dimensional domain \(\Omega_h=\sum_{k=1}^{n_t}T_k,\, \mathcal{T}_h=\{T_k\}\), we can calculate the integral over \(\Omega_h\) by:

\sphinxAtStartPar
\(\int_{\Omega_h}f(x,y)\) =\sphinxcode{\sphinxupquote{int3d(Th)(f)}}
=\sphinxcode{\sphinxupquote{int3d(Th,qfV=*)(f)}}
=\sphinxcode{\sphinxupquote{int3D(Th,qforder=*)(f)}}

\sphinxAtStartPar
where * stands for the name of quadrature formula or the order of the Gauss formula.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{6}%
\begin{varwidth}[t]{\sphinxcolwidth{6}{6}}
\sphinxstyletheadfamily \sphinxAtStartPar
Quadrature formula on a tetrahedron
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\(L\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfV}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qforder}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Point in \(T_k\in\R^3\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(\omega_\ell\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Exact on \(P_k,\ k=\)
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfV1}}
&
\sphinxAtStartPar
\(2\)
&
\sphinxAtStartPar
\(\left(\frac{1}{4},\frac{1}{4},\frac{1}{4}\right)\)
&
\sphinxAtStartPar
\(|T_k|\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfV2}}
&
\sphinxAtStartPar
\(3\)
&
\sphinxAtStartPar
\(G4(0.58\ldots,0.13\ldots,0.13\ldots)\)
&
\sphinxAtStartPar
\(|T_k|/4\)
&
\sphinxAtStartPar
\(2\)
\\
\hline
\sphinxAtStartPar
14
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfV5}}
&
\sphinxAtStartPar
\(6\)
&
\sphinxAtStartPar
\(G4(0.72\ldots,0.092\ldots,0.092\ldots)\)

\sphinxAtStartPar
\(G4(0.067\ldots,0.31\ldots,0.31\ldots)\)

\sphinxAtStartPar
\(G6(0.45\ldots,0.045\ldots,0.45\ldots)\)
&
\sphinxAtStartPar
\(0.073\ldots|T_k|\)

\sphinxAtStartPar
\(0.11\ldots|T_k|\)

\sphinxAtStartPar
\(0.042\ldots|T_k|\)
&
\sphinxAtStartPar
\(5\)
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfV1lump}}
&&
\sphinxAtStartPar
\(G4(1,0,0)\)
&
\sphinxAtStartPar
\(|T_k|/4\)
&
\sphinxAtStartPar
\(1\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Where \(G4(a,b,b)\) such that \(a+3b=1\) is the set of the four point in barycentric coordinate:
\begin{equation*}
\begin{split}\{(a,b,b,b),(b,a,b,b),(b,b,a,b),(b,b,b,a)\}\end{split}
\end{equation*}
\sphinxAtStartPar
and where \(G6(a,b,b)\) such that \(2a+2b=1\) is the set of the six points in barycentric coordinate:
\begin{equation*}
\begin{split}\{(a,a,b,b),(a,b,a,b),(a,b,b,a),(b,b,a,a),(b,a,b,a),(b,a,a,b)\}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
These tetrahedral quadrature formulae come from \sphinxurl{http://nines.cs.kuleuven.be/research/ecf/mtables.html}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
By default, we use the formula which is exact for polynomials of degree \(5\) on triangles or edges (in bold in three tables).
\end{sphinxadmonition}

\sphinxAtStartPar
It is possible to add an own quadrature formulae with using plugin \sphinxcode{\sphinxupquote{qf11to25}} on segment, triangle or Tetrahedron.

\sphinxAtStartPar
The quadrature formulae in \(D\) dimension is a bidimentional array of size \(N_q\times (D+1)\) such that the \(D+1\) value of on row \(i=0,...,N_p-1\) are \(w^i,\hat{x}^i_1,...,\hat{x}^i_D\) where \(w^i\) is the weight of the quadrature point, and \(1-\sum_{k=1}^D \hat{x}^i_k ,\hat{x}^i_1,...,\hat{x}^i_D\) is the barycentric coordinate the quadrature point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{qf11to25}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Quadrature on segment}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq1} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF1} \PYG{n+nf}{qf1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf1 on segment}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1}

\PYG{c+c1}{//Quadrature on triangle}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq2} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF2} \PYG{n+nf}{qf2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf2 on triangle}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1}
\PYG{c+c1}{//so must have sum w\PYGZca{}i = 1}

\PYG{c+c1}{// Quadrature on tetrahedron}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{qq3} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
    \PYG{p}{[}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{;}

\PYG{n}{QF3} \PYG{n+nf}{qf3}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{qq3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def of quadrature formulae qf3 on get}
\PYG{c+c1}{//remark:}
\PYG{c+c1}{//1 is the order of the quadrature exact for polynome of degree \PYGZlt{} 1)}

\PYG{c+c1}{// Verification in 1d and 2d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{I1} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{qf1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{I1l} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pElump}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{I2} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{n}{qf2}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{I2l} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I1l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I2l} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{I1}\PYG{o}{\PYGZhy{}}\PYG{n}{I1l}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{I2}\PYG{o}{\PYGZhy{}}\PYG{n}{I2l}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{1}.67 \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{1}.67
\PYG{l+m}{0}.335 \PYG{o}{=}\PYG{o}{=} \PYG{l+m}{0}.335
\end{sphinxVerbatim}


\subsection{Variational Form, Sparse Matrix, PDE Data Vector}
\label{\detokenize{documentation/finite-element:variational-form-sparse-matrix-pde-data-vector}}\label{\detokenize{documentation/finite-element:variationalformsparsematrixpde}}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} it is possible to define variational forms, and use them to build matrices and vectors, and store them to speed\sphinxhyphen{}up the script (4 times faster here).

\sphinxAtStartPar
For example let us solve the {\hyperref[\detokenize{tutorials/thermalConduction:thermalconduction}]{\sphinxcrossref{\DUrole{std,std-ref}{Thermal Conduction problem}}}}.

\sphinxAtStartPar
The variational formulation is in \(L^2(0,T;H^1(\Omega))\); we shall seek \(u^n\) satisfying:
\begin{equation*}
\begin{split}\forall w \in V_{0}; \qquad \int_\Omega \frac{u^n-u^{n-1}}{\delta t} w + \kappa\n u^n\n w) +\int_\Gamma\alpha(u^n-u_{ue})w=0\end{split}
\end{equation*}
\sphinxAtStartPar
where \(V_0 = \{w\in H^1(\Omega)/ w_{|\Gamma_{24}}=0\}\).

\sphinxAtStartPar
So to code the method with the matrices \(A=(A_{ij})\), \(M=(M_{ij})\), and the vectors \(u^n, b^n, b',b", b_{cl}\) (notation if \(w\) is a vector then \(w_i\) is a component of the vector).
\begin{equation*}
\begin{split}u^n = A^{-1} b^n, \quad
\quad b' = b_0 + M u^{n-1},
\quad b"= \frac{1}{\varepsilon} \; b_{cl},
\quad b^n_i = \left\{
\begin{array}{cl} b"_i & \mbox{if }\ i \in \Gamma_{24} \\
b'_i & \mbox{else if } \not\in \Gamma_{24} \end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
Where with \(\frac{1}{\varepsilon} = \mathtt{tgv} = 10^{30}\):
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A_{ij} &=& \left\{\begin{array}{cl} \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and} j=i \\
    \displaystyle
        \int_{\Omega} w_j w_i / dt + k (\nabla w_j. \nabla w_i ) + \int_{\Gamma_{13}} \alpha w_j w_i & \mbox{else if } i \not\in \Gamma_{24}, \mbox{or} j\ne i
        \end{array}\right.\\
        M_{ij} &=& \left\{\begin{array}{cl} \frac{1}{\varepsilon} & \mbox{if } i \in \Gamma_{24}, \mbox{and} j=i\\
    \displaystyle
        \int_{\Omega} w_j w_i / dt
        & \mbox{else if }i \not\in \Gamma_{24}, \mbox{or} j\ne i \end{array}\right. \\
        b_{0,i} &=& \int_{\Gamma_{13}} \alpha u_{ue} w_i \\
        b_{cl} &=& u^{0} \quad \mbox{the initial data}
\end{array}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{fu0} \PYG{o}{=} \PYG{l+m+mi}{10} \PYG{o}{+} \PYG{l+m+mi}{90}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{25.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1} \PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u0} \PYG{o}{=} \PYG{n}{fu0}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{n}{u0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Create three variational formulation, and build the matrices \(A\),\(M\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vthermic} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
        \PYG{o}{+} \PYG{n}{k}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vthermic0} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{ue}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vMass} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{/}\PYG{n}{dt}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vMass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, to build the right hand size we need 4 vectors.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{vthermic0}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant part of the RHS}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcn} \PYG{o}{=} \PYG{n}{vthermic}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//tgv on Dirichlet boundary node ( !=0 )}
\PYG{c+c1}{//we have for the node i : i in Gamma\PYGZus{}24 \PYGZhy{}\PYGZgt{} bcn[i] != 0}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bcl} \PYG{o}{=} \PYG{k+kp}{tgv}\PYG{o}{*}\PYG{n}{u0}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//the Dirichlet boundary condition part}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The boundary condition is implemented by penalization and vector \sphinxcode{\sphinxupquote{bcn}} contains the contribution of the boundary condition \(u=1\), so to change the boundary condition, we have just to multiply the vector \sphinxcode{\sphinxupquote{bcn{[}{]}}} by the current value \sphinxcode{\sphinxupquote{f}} of the new boundary condition term by term with the operator \sphinxcode{\sphinxupquote{.*}}.

\sphinxAtStartPar
{\hyperref[\detokenize{models/navier-stokes-equations:navierstokesuzawaconjugategradients}]{\sphinxcrossref{\DUrole{std,std-ref}{Uzawa model}}}} gives a real example of using all this features.
\end{sphinxadmonition}

\sphinxAtStartPar
And the new version of the algorithm is now:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Time loop}
\PYG{k+kt}{ofstream} \PYG{n+nf}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{thermic.dat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{p}{;} \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b0}\PYG{p}{;} \PYG{c+c1}{//for the RHS}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add the the time dependent part}
    \PYG{c+c1}{//lock boundary part:}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{bcn} \PYG{o}{?} \PYG{n+nl}{bcl} \PYG{o}{:} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//do forall i: b[i] = bcn[i] ? bcl[i] : b[i]}

    \PYG{c+c1}{// Solve}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

    \PYG{c+c1}{// Save}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{6.0}\PYG{o}{*}\PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{20.0}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The functions appearing in the variational form are formal and local to the \sphinxcode{\sphinxupquote{varf}} definition, the only important thing is the order in the parameter list, like in:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vb1}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vb2}\PYG{p}{(}\PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
To build matrix \(A\) from the bilinear part the variational form \(a\) of type \sphinxcode{\sphinxupquote{varf}} simply write:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Wh} \PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// where}
\PYG{c+c1}{//Vh is \PYGZdq{}fespace\PYGZdq{} for the unknown fields with a correct number of component}
\PYG{c+c1}{//Wh is \PYGZdq{}fespace\PYGZdq{} for the test fields with a correct number of component}
\end{sphinxVerbatim}

\sphinxAtStartPar
Possible named parameters in \sphinxcode{\sphinxupquote{, {[}...{]}}} are
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solver=}} \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{CG}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}}, \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}}, \sphinxcode{\sphinxupquote{UMFPACK}} …
\begin{quote}

\sphinxAtStartPar
The default solver is \sphinxcode{\sphinxupquote{GMRES}}.

\sphinxAtStartPar
The storage mode of the matrix of the underlying linear system depends on the type of solver chosen; for \sphinxcode{\sphinxupquote{LU}} the matrix is sky\sphinxhyphen{}line non symmetric, for \sphinxcode{\sphinxupquote{Crout}} the matrix is sky\sphinxhyphen{}line symmetric, for \sphinxcode{\sphinxupquote{Cholesky}} the matrix is sky\sphinxhyphen{}line symmetric positive definite, for \sphinxcode{\sphinxupquote{CG}} the matrix is sparse symmetric positive, and for \sphinxcode{\sphinxupquote{GMRES}}, \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{UMFPACK}} the matrix is just sparse.
\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{factorize =}} If true then do the matrix factorization for \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Cholesky}} or \sphinxcode{\sphinxupquote{Crout}}, the default value is \sphinxcode{\sphinxupquote{false}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eps=}} A real expression.
\begin{quote}

\sphinxAtStartPar
\(\varepsilon\) sets the stopping test for the iterative methods like \sphinxcode{\sphinxupquote{CG}}.

\sphinxAtStartPar
Note that if \(\varepsilon\) is negative then the stopping test is:
\begin{equation*}
\begin{split}|| A x - b || < |\varepsilon|\end{split}
\end{equation*}
\sphinxAtStartPar
if it is positive then the stopping test is
\begin{equation*}
\begin{split}|| A x - b || < \frac{|\varepsilon|}{|| A x_{0} - b ||}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{precon=}} Name of a function (for example \sphinxcode{\sphinxupquote{P}}) to set the preconditioner.

\sphinxAtStartPar
The prototype for the function \sphinxcode{\sphinxupquote{P}} must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{xx}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tgv=}} Huge value (\(10^{30}\)) used to implement Dirichlet boundary conditions.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tolpivot=}} Set the tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}} (\(10^-1\)) and, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorization (\(10^{-20}\)).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tolpivotsym=}} Set the tolerance of the pivot sym in \sphinxcode{\sphinxupquote{UMFPACK}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{strategy=}} Set the integer UMFPACK strategy (\(0\) by default).

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The line of the matrix corresponding to the space \sphinxcode{\sphinxupquote{Wh}} and the column of the matrix corresponding to the space \sphinxcode{\sphinxupquote{Vh}}.
\end{sphinxadmonition}

\sphinxAtStartPar
To build the dual vector \sphinxcode{\sphinxupquote{b}} (of type \sphinxcode{\sphinxupquote{real{[}int{]}}}) from the linear part of the variational form \sphinxcode{\sphinxupquote{a}} do simply:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A first example to compute the area of each triangle \(K\) of mesh \(Th\), just do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the space function constant / triangle}
\PYG{n}{Nh} \PYG{n}{areaK}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{varea} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{chiK}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{etaK}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{varea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Effectively, the basic functions of space \(Nh\), are the characteristic function of the element of Th, and the numbering is the numeration of the element, so by construction:
\begin{equation*}
\begin{split}\mathtt{etaK}[i] = \int {1}_{|K_i} = \int_{K_i} 1;\end{split}
\end{equation*}
\sphinxAtStartPar
Now, we can use this to compute error indicators like in example {\hyperref[\detokenize{models/static-problems:modelstaticproblemadaptationusingresidualerrorindicator}]{\sphinxcrossref{\DUrole{std,std-ref}{Adaptation using residual error indicator}}}}.

\sphinxAtStartPar
First to compute a continuous approximation to the function \(h\) “density mesh size” of the mesh \(Th\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{h} \PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{count}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vmeshsizen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vedgecount} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Computation of the mesh size}
\PYG{n}{count} \PYG{o}{=} \PYG{n}{vedgecount}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//number of edge / vertex}
\PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vmeshsizen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sum length edge / vertex}
\PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{count}\PYG{p}{;} \PYG{c+c1}{//mean length edge / vertex}
\end{sphinxVerbatim}

\sphinxAtStartPar
To compute error indicator for Poisson equation:
\begin{equation*}
\begin{split}{\eta_K = \int_K h_K^2 |( f + \Delta u_h)|^2 + \int_{\partial K} h_e |[ \frac{\partial u_h}{\partial n} ]|^2 }\end{split}
\end{equation*}
\sphinxAtStartPar
where \(h_K\) is size of the longest edge (\sphinxcode{\sphinxupquote{hTriangle}}), \(h_e\) is the size of the current edge (\sphinxcode{\sphinxupquote{lenEdge}}), \(n\) the normal.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// the space function constant / triangle}
\PYG{n}{Nh} \PYG{n}{etak}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vetaK} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vetaK}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We add automatic expression optimization by default, if this optimization creates problems, it can be removed with the keyword \sphinxcode{\sphinxupquote{optimize}} as in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{optimize}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or you can also do optimization and remove the check by setting \sphinxcode{\sphinxupquote{optimize=2}}.

\sphinxAtStartPar
Remark, it is all possible to build interpolation matrix, like in the following example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{VH}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build interpolation matrix Vh\PYGZhy{}\PYGZgt{}VH}
\PYG{k+kt}{matrix} \PYG{n}{BB} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//build interpolation matrix Vh\PYGZhy{}\PYGZgt{}Wh}
\end{sphinxVerbatim}

\sphinxAtStartPar
and after some operations on sparse matrices are available for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//a full matrix}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{)} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{sparseA} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sparseA} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{sparseA} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{sparseA} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{o}{*}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{sparseB} \PYG{o}{=} \PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA} \PYG{o}{+} \PYG{n}{sparseA}\PYG{p}{;} \PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sparseB = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sparseB}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Interpolation matrix}
\label{\detokenize{documentation/finite-element:interpolation-matrix}}
\sphinxAtStartPar
It is also possible to store the matrix of a linear interpolation operator from a finite element space \(V_h\) to another \(W_h\) to \sphinxcode{\sphinxupquote{interpolate}}(\(W_h\),\(V_h\),…) a function.

\sphinxAtStartPar
Note that the continuous finite functions are extended by continuity outside of the domain.

\sphinxAtStartPar
The named parameters of function \sphinxcode{\sphinxupquote{interpolate}} are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inside=}} set true to create zero\sphinxhyphen{}extension.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{t=}} set true to get the transposed matrix

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{op=}} set an integer written below
\begin{itemize}
\item {} 
\sphinxAtStartPar
0 the default value and interpolate of the function

\item {} 
\sphinxAtStartPar
1 interpolate the \(\p_x\)

\item {} 
\sphinxAtStartPar
2 interpolate the \(\p_y\)

\item {} 
\sphinxAtStartPar
3 interpolate the \(\p_z\)

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{U2Vc=}} set the which is the component of \(W_h\) come in \(V_h\) in interpolate process in a int array so the size of the array is number of component of \(W_h\), if the put \(-1\) then component is set to \(0\), like in the following example: (by default the component number is unchanged).
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{V4h}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{V3h}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u2vc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}1 \PYGZhy{}\PYGZgt{} put zero on the component}
\PYG{k+kt}{matrix} \PYG{n}{IV34} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{V3h}\PYG{p}{,} \PYG{n}{V4h}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{u2vc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//V3h \PYGZlt{}\PYGZhy{} V4h}
\PYG{n}{V4h} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{,} \PYG{n}{a3}\PYG{p}{,} \PYG{n}{a4}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{V3h} \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{b1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{IV34}\PYG{o}{*}\PYG{n}{a1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
So here we have: \sphinxcode{\sphinxupquote{freefem   b1 == 2, b2 == 4, b3 == 0 ...}}
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Matrix interpolation

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Th4}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh4}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh4} \PYG{n}{v4}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh4}\PYG{p}{(}\PYG{n}{Th4}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Interpolation}
\PYG{k+kt}{matrix} \PYG{n}{IV} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//here the function is exended by continuity}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{v}\PYG{o}{=}\PYG{n}{v4}\PYG{p}{;}
\PYG{n}{vv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=} \PYG{n}{IV}\PYG{o}{*}\PYG{n}{v4}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//here v == vv}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diff}\PYG{o}{=} \PYG{n}{vv}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|| v \PYGZhy{} vv || = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{diff}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n}{diff}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IV0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//here the function is exended by zero}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4 (inside=1) }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IVt0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh4}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh\PYGZlt{}\PYGZhy{}Vh4\PYGZca{}t (inside=1) }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IVt0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IV4t0} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh4}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Vh4\PYGZlt{}\PYGZhy{}Vh\PYGZca{}t }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IV4t0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IW4} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh4}\PYG{p}{,} \PYG{n}{Wh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Wh4\PYGZlt{}\PYGZhy{}Wh }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IW4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{IW4V} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh4}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IV Wh4\PYGZlt{}\PYGZhy{}Vh }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{IW4} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Build interpolation matrix \(A\) at a array of points \((xx[j],yy[j]),\ i = 0,\ 2\) here:
\begin{equation*}
\begin{split}a_ij = dop(w^i_c (xx[j],yy[j]))\end{split}
\end{equation*}
\sphinxAtStartPar
where \(w_i\) is the basic finite element function, \(c\) the component number, \(dop\) the type of diff operator like in op def.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{.3}\PYG{p}{,} \PYG{l+m+mf}{.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{yy} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{.1}\PYG{p}{,} \PYG{l+m+mf}{.4}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{dop} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Ixx} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{,} \PYG{k+kp}{op}\PYG{o}{=}\PYG{n}{dop}\PYG{p}{,} \PYG{k+kp}{composante}\PYG{o}{=}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ixx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ww}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n+nf}{dd} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{ww}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ixx}\PYG{o}{*}\PYG{n+nf}{dd}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Schwarz

\sphinxAtStartPar
The following shows how to implement with an interpolation matrix a domain decomposition algorithm based on Schwarz method with Robin conditions.

\sphinxAtStartPar
Given a non\sphinxhyphen{}overlapping partition \(\bar\Omega=\bar\Omega_0\cup\bar\Omega_1\) with \(\Omega_0\cap\Omega_1=\emptyset\), \(\Sigma:=\bar\Omega_0\cap\bar\Omega_1\) the algorithm is:
\begin{equation*}
\begin{split}-\Delta u_i &= f \hbox{ in }\Omega_i,~i=0,1,\\
\frac{\partial(u_1-u_0)}{\partial n} + \alpha (u_1-u_0) &=0\hbox{ on }\Sigma.\end{split}
\end{equation*}
\sphinxAtStartPar
The same in variational form is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    &\int_{\Omega_i}\nabla u_i\cdot\nabla v &+ \int_\Sigma\alpha u_i v = \int_{\Omega_i}f v\\
    - \int_{\Omega_j}(\nabla u_j\cdot\nabla v-f v) + \int_\Sigma\alpha u_j v,~~
    \forall v\in H^1_0(\Omega), i,j=[0,1]\cup[1,0]
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
To discretized with the \(P^1\) triangular Lagrangian finite element space \(V_h\) simply replace \(H^1_0(\Omega)\) by \(V_h(\Omega_0)\cup V_h(\Omega_1)\).

\sphinxAtStartPar
Then difficulty is to compute \(\int_{\Omega_j} \nabla u_j\cdot\nabla v\) when \(v\) is a basis function of \(V_h(\Omega_i)\), \(i\ne j\).

\sphinxAtStartPar
It is done as follows (with \(\Gamma=\partial\Omega\)):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n+nf}{Gamma} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{Sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{Niter} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{a0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n+nf}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{a1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n+nf}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n+nf}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n+nf}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n+nf}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n+nf}{Gamma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b0}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{n}{TH}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{TH}\PYG{p}{(}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}

\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{reg}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{n}{u0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n+nf}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n+nf}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{du1dn} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n+nf}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{du0dn} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{u0}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n+nf}{Gamma}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{I01} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{I10} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kp}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kp}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solving loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{n}{Niter}\PYG{p}{;} \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve on Th[0]}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b0} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Du1dn} \PYG{o}{=} \PYG{n}{du1dn}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Tdu1dn}\PYG{p}{(}\PYG{n}{Vh0}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Tdu1dn} \PYG{o}{=} \PYG{n}{I01}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Du1dn}\PYG{p}{;}
        \PYG{n}{b0} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Tdu1dn}\PYG{p}{;}
        \PYG{n}{u0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// Solve on Th[1]}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Du0dn} \PYG{o}{=} \PYG{n}{du0dn}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Tdu0dn}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Tdu0dn} \PYG{o}{=} \PYG{n}{I10}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Du0dn}\PYG{p}{;}
        \PYG{n}{b1} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Tdu0dn}\PYG{p}{;}
        \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iter=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Finite elements connectivity}
\label{\detokenize{documentation/finite-element:finite-elements-connectivity}}
\sphinxAtStartPar
Here, we show how to get informations on a finite element space \(W_h({\cal T}_n,*)\), where “*” may be \sphinxcode{\sphinxupquote{P1, P2, P1nc}}, etc.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wh.nt}} gives the number of element of \(W_h\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wh.ndof}} gives the number of degrees of freedom or unknown

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wh.ndofK}} gives the number of degrees of freedom on one element

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wh(k,i)}} gives the number of \(i\)th degrees of freedom of element \(k\).

\end{itemize}

\sphinxAtStartPar
See the following example:

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Finite element connectivity

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of degree of freedom = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndof} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of degree of freedom / ELEMENT = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndofK} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{kdf} \PYG{o}{=} \PYG{n}{Wh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{c+c1}{//element 2}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Degree of freedom of element }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{k} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{kdf}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Wh}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Number of degree of \PYG{n+nv}{freedom} \PYG{o}{=} \PYG{l+m}{121}
Number of degree of freedom / \PYG{n+nv}{ELEMENT} \PYG{o}{=} \PYG{l+m}{6}
Degree of freedom of element \PYG{l+m}{2}:
\PYG{l+m}{78} \PYG{l+m}{95} \PYG{l+m}{83} \PYG{l+m}{87} \PYG{l+m}{79} \PYG{l+m}{92}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Visualization}
\label{\detokenize{documentation/visualization:visualization}}\label{\detokenize{documentation/visualization:id1}}\label{\detokenize{documentation/visualization::doc}}
\sphinxAtStartPar
Results created by the finite element method can be a huge set of data, so it is very important to render them easy to grasp.

\sphinxAtStartPar
There are two ways of visualization in \sphinxstylestrong{FreeFEM}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
One, the default view, which supports the drawing of meshes, isovalues of real FE\sphinxhyphen{}functions, and of vector fields, all by the command \sphinxcode{\sphinxupquote{plot}} (see {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot section}}}} below).
For publishing purpose, \sphinxstylestrong{FreeFEM} can store these plots as postscript files.

\item {} 
\sphinxAtStartPar
Another method is to use external tools, for example, gnuplot (see {\hyperref[\detokenize{documentation/visualization:gnuplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Gnuplot section}}}}, {\hyperref[\detokenize{documentation/visualization:medit}]{\sphinxcrossref{\DUrole{std,std-ref}{medit section}}}}, {\hyperref[\detokenize{documentation/visualization:paraview}]{\sphinxcrossref{\DUrole{std,std-ref}{Paraview section}}}}, {\hyperref[\detokenize{documentation/visualization:matlab}]{\sphinxcrossref{\DUrole{std,std-ref}{Matlab/Octave section}}}}) using the command \sphinxcode{\sphinxupquote{system}} to launch them and/or to save the data in text files.

\end{itemize}


\subsection{Plot}
\label{\detokenize{documentation/visualization:plot}}\label{\detokenize{documentation/visualization:id2}}
\sphinxAtStartPar
With the command \sphinxcode{\sphinxupquote{plot}}, meshes, isovalues of scalar functions, and vector fields can be displayed.

\sphinxAtStartPar
The parameters of the plot command can be meshes, real FE functions, arrays of 2 real FE functions, arrays of two double arrays, to plot respectively a mesh, a function, a vector field, or a curve defined by the two double arrays.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The length of an arrow is always bound to be in {[}5‰, 5\%{]} of the screen size in order to see something.
\end{sphinxadmonition}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{plot}} command parameters are listed in the {\hyperref[\detokenize{references/functions:referenceplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Reference part}}}}.

\sphinxAtStartPar
The keyboard shortcuts are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{enter} tries to show plot

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{p} previous plot (10 plots saved)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{?} shows this help

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{+,\sphinxhyphen{}} zooms in/out around the cursor 3/2 times

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{=} resets the view

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{r} refreshes plot

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{up, down, left, right} special keys to tanslate

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{3} switches 3d/2d plot keys :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{z,Z} focal zoom and zoom out

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{H,h} increases or decreases the Z scale of the plot

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{mouse motion}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{left button} rotates

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{right button} zooms (ctrl+button on mac)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{right button +alt} tanslates (alt+ctrl+button on mac)

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{a,A} increases or decreases the arrow size

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{B} switches between showing the border meshes or not

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{i,I} updates or not: the min/max bound of the functions to the window

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{n,N} decreases or increases the number of iso value arrays

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{b} switches between black and white or color plotting

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{g} switches between grey or color plotting

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{f} switches between filling iso or iso line

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{l} switches between lighting or not

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{v} switches between show or not showing the numerical value of colors

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{m} switches between show or not showing the meshes

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{w} window dump in file ffglutXXXX.ppm

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{*} keep/drop viewpoint for next plot

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{k} complex data / change view type

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ESC} closes the graphics process before version 3.22, after no way to close

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{otherwise} does nothing

\end{itemize}

\sphinxAtStartPar
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//plot scalar and vectorial FE function}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{three.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
   \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{grey}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{threeg.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//compute a cut}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
   \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
   \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
   \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{//value of uh at point (i/10., i/10.)}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{ps}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{likegnu.eps}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot}.png}
\caption{Mesh, isovalue and vector}\label{\detokenize{documentation/visualization:id3}}\label{\detokenize{documentation/visualization:figvisumesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot_Grey}.png}
\caption{Enlargement in grey of isovalue and vector}\label{\detokenize{documentation/visualization:id4}}\label{\detokenize{documentation/visualization:figvisugrey}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_Plot_Gnuplot}.png}
\caption{Plots a cut of \sphinxcode{\sphinxupquote{uh}}. Note that a refinement of the same can be obtained in combination with gnuplot}\label{\detokenize{documentation/visualization:id5}}\label{\detokenize{documentation/visualization:figvisucut}}\end{subfigure}
\caption{Plot}\phantomsection\label{\detokenize{documentation/visualization:Plot}}

\end{figure}


\sphinxAtStartPar
To change the color table and to choose the value of iso line you can do:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// from: \PYGZbs{}url\PYGZob{}http://en.wikipedia.org/wiki/HSV\PYGZus{}color\PYGZus{}space\PYGZcb{}}
\PYG{c+c1}{// The HSV (Hue, Saturation, Value) model defines a color space}
\PYG{c+c1}{// in terms of three constituent components:}
\PYG{c+c1}{// HSV color space as a color wheel}
\PYG{c+c1}{// Hue, the color type (such as red, blue, or yellow):}
\PYG{c+c1}{// Ranges from 0\PYGZhy{}360 (but normalized to 0\PYGZhy{}100\PYGZpc{} in some applications, like here)}
\PYG{c+c1}{// Saturation, the \PYGZdq{}vibrancy\PYGZdq{} of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}
\PYG{c+c1}{// The lower the saturation of a color, the more \PYGZdq{}grayness\PYGZdq{} is present}
\PYG{c+c1}{// and the more faded the color will appear.}
\PYG{c+c1}{// Value, the brightness of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{colorhsv}\PYG{o}{=}\PYG{p}{[} \PYG{c+c1}{// color hsv model}
   \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{// dark blue}
   \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// blue}
   \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// magenta}
   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// red}
   \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.5} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{// light red}
   \PYG{p}{]}\PYG{p}{;}
 \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}\PYG{p}{;}

 \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}

 \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{colorhsv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_HSV_Space}.png}
\caption{HSV color cylinder}\label{\detokenize{documentation/visualization:id6}}\label{\detokenize{documentation/visualization:figvisuhsv}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Visualization_HSV}.png}
\caption{Isovalue with an other color table}\label{\detokenize{documentation/visualization:id7}}\label{\detokenize{documentation/visualization:figvisuisocolortable}}\end{subfigure}
\caption{HSV}\phantomsection\label{\detokenize{documentation/visualization:HSV}}

\end{figure}


\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/visualization:examplehsv}]{\sphinxcrossref{\DUrole{std,std-ref}{HSV example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with gnuplot}
\label{\detokenize{documentation/visualization:link-with-gnuplot}}\label{\detokenize{documentation/visualization:gnuplot}}
\sphinxAtStartPar
Example {\hyperref[\detokenize{tutorials/membrane:tutorialmembrane}]{\sphinxcrossref{\DUrole{std,std-ref}{Membrane}}}} shows how to generate a gnuplot from a \sphinxstylestrong{FreeFEM} file.
Here is another technique which has the advantage of being online, i.e. one doesn’t need to quit \sphinxstylestrong{FreeFEM} to generate a gnuplot.

\sphinxAtStartPar
However, this works only if \sphinxhref{http://www.gnuplot.info}{gnuplot} is installed, and only on an Unix\sphinxhyphen{}like computer.

\sphinxAtStartPar
Add to the previous example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}\PYG{c+c1}{// file for gnuplot}
   \PYG{k+kt}{ofstream} \PYG{n}{gnu}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{gnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// to call gnuplot command and wait 5 second (due to the Unix command)}
\PYG{c+c1}{// and make postscript plot}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo \PYGZsq{}plot }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ w l }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ pause 5 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set term postscript }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set output }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{gnuplot.eps}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ replot }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ quit\PYGZsq{} | gnuplot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Gnuplot}.png}
\caption{Plots a cut of uh with gnuplot}\label{\detokenize{documentation/visualization:figvisugnuplot}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/visualization:exampleplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with medit}
\label{\detokenize{documentation/visualization:link-with-medit}}\label{\detokenize{documentation/visualization:medit}}
\sphinxAtStartPar
As said above, \sphinxcode{\sphinxupquote{medit}} is a freeware display package by Pascal Frey using OpenGL. Then you may run the following example.

\sphinxAtStartPar
Now \sphinxcode{\sphinxupquote{medit}} software is included in \sphinxstylestrong{FreeFEM} under \sphinxcode{\sphinxupquote{ffmedit}} name.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{medit}} command parameters are listed in the {\hyperref[\detokenize{references/external-libraries:referencemedit}]{\sphinxcrossref{\DUrole{std,std-ref}{Reference part}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Medit}.png}
\caption{:freefem:medit\textasciigrave{} plot}\label{\detokenize{documentation/visualization:figvisumedit}}\end{figure}

\sphinxAtStartPar
With version 3.2 or later

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Before:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//save u.points and u.faces file}
\PYG{c+c1}{// build a u.bb file for medit}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.bb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 1 1 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//call medit command}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmedit u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//clean files on unix\PYGZhy{}like OS}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rm u.bb u.faces u.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/visualization:examplemedit}]{\sphinxcrossref{\DUrole{std,std-ref}{Medit example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with Paraview}
\label{\detokenize{documentation/visualization:link-with-paraview}}\label{\detokenize{documentation/visualization:paraview}}
\sphinxAtStartPar
One can also export mesh or results in the \sphinxcode{\sphinxupquote{.vtk}} format in order to post\sphinxhyphen{}process data using \sphinxhref{https://www.paraview.org/}{Paraview}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Order} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{DataName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.vtu}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Paraview}.png}
\caption{Paraview plot}\label{\detokenize{documentation/visualization:figvisuparaview}}\end{figure}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Finite element variables saved using paraview \sphinxstylestrong{must be in P0 or P1}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/visualization:exampleparaview}]{\sphinxcrossref{\DUrole{std,std-ref}{Paraview example}}}} for the complete script.
\end{sphinxadmonition}


\subsection{Link with Matlab© and Octave}
\label{\detokenize{documentation/visualization:link-with-matlab-and-octave}}\label{\detokenize{documentation/visualization:matlab}}
\sphinxAtStartPar
In order to create a plot from a \sphinxstylestrong{FreeFEM} simulation in \sphinxhref{https://www.gnu.org/software/octave/}{Octave} and \sphinxhref{https://www.mathworks.com/}{Matlab} the mesh, the finite element space connectivity and the simulation data must be written to files:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmatlib.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}mesh.msh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffSaveVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}vh.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffSaveData}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{export\PYGZus{}data.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Within Matlab or Octave the files can be plot with the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib library}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{addpath}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{path to ffmatlib\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{]}\PYG{p}{=}\PYG{n}{ffreadmesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}mesh.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}vh.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{=}\PYG{n}{ffreaddata}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export\PYGZus{}data.txt\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffpdeplot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VhSeq\PYGZsq{}}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{XYData\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ZStyle\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{continuous\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{grid}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Visualization_Matlab_Octave}.png}
\caption{Matlab / Octave plot}\label{\detokenize{documentation/visualization:figvisumatlab}}\end{figure}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
For more Matlab / Octave plot examples have a look at the tutorial section {\hyperref[\detokenize{tutorials/matlabOctavePlot:tutorialmatlaboctaveplot}]{\sphinxcrossref{\DUrole{std,std-ref}{Matlab / Octave Examples}}}} or visit the \sphinxhref{https://github.com/samplemaker/freefem\_matlab\_octave\_plot}{ffmatlib library} on github.
\end{sphinxadmonition}


\section{Algorithms \& Optimization}
\label{\detokenize{documentation/algorithms-and-optimization:algorithms-optimization}}\label{\detokenize{documentation/algorithms-and-optimization::doc}}

\subsection{Conjugate Gradient/GMRES}
\label{\detokenize{documentation/algorithms-and-optimization:conjugate-gradient-gmres}}
\sphinxAtStartPar
Suppose we want to solve the Euler problem (here \(x\) has nothing to do with the reserved variable for the first coordinate in \sphinxstylestrong{FreeFEM}):

\sphinxAtStartPar
find \(x\in \mathbb{R}^n\) such that
\begin{equation}\label{equation:documentation/algorithms-and-optimization:eqndJ}
\begin{split}\nabla J(x) = \left(\frac{\partial J}{\partial x_i} (\mathbf{x})\right) = 0\end{split}
\end{equation}
\sphinxAtStartPar
where \(J\) is a function (to minimize for example) from \(\mathbb{R}^n\) to \(\mathbb{R}\).

\sphinxAtStartPar
If the function is convex we can use the conjugate gradient algorithm to solve the problem, and we just need the function (named \sphinxcode{\sphinxupquote{dJ}} for example) which computes \(\nabla J\), so the parameters are the name of that function with prototype \sphinxcode{\sphinxupquote{func real{[}int{]} dJ(real{[}int{]} \&xx);}} which computes \(\nabla J\), and a vector \sphinxcode{\sphinxupquote{x}} of type (of course the number 20 can be changed) \sphinxcode{\sphinxupquote{real{[}int{]} x(20);}} to initialize the process and get the result.

\sphinxAtStartPar
Given an initial value \(\mathbf{x}^{(0)}\), a maximum number \(i_{\max}\) of iterations, and an error tolerance \(0<\epsilon<1\):

\sphinxAtStartPar
Put \(\mathbf{x}=\mathbf{x}^{(0)}\) and write

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{stopfunc}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
will give the solution of \(\mathbf{x}\) of \(\nabla J(\mathbf{x})=0\).
We can omit parameters \sphinxcode{\sphinxupquote{precon, nbiter, eps, stop}}.
Here \(M\) is the preconditioner whose default is the identity matrix.

\sphinxAtStartPar
The stopping test is
\begin{equation*}
\begin{split}\|\nabla J(\mathbf{x})\|_P\le \epsilon\| \nabla J(\mathbf{x}^{(0)})\|_P\end{split}
\end{equation*}
\sphinxAtStartPar
Writing the minus value in \sphinxcode{\sphinxupquote{eps=}}, i.e.,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can use the stopping test:
\begin{equation*}
\begin{split}\| \nabla J(\mathbf{x})\|_P^2\le \epsilon\end{split}
\end{equation*}
\sphinxAtStartPar
The parameters of these three functions are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbiter=}} set the number of iteration (by default 100)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{precon=}} set the preconditioner function (\sphinxcode{\sphinxupquote{P}} for example) by default it is the identity, note the prototype is \sphinxcode{\sphinxupquote{func real{[}int{]} P(real{[}int{]} \&x)}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eps=}} set the value of the stop test \(\varepsilon\) (\(=10^{-6}\) by default) if positive then relative test \(||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P\), otherwise the absolute test is \(||\nabla J(x)||_P^2\leq |\varepsilon|\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{veps=}} set and return the value of the stop test, if positive, then relative test is \(||\nabla J(x)||_P\leq \varepsilon||\nabla J(x_0)||_P\), otherwise the absolute test is \(||\nabla J(x)||_P^2\leq |\varepsilon|\).
The return value is minus the real stop test (remark: it is useful in loop).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stop=}} \sphinxcode{\sphinxupquote{stopfunc}} add your test function to stop before the \sphinxcode{\sphinxupquote{eps}} criterion. The prototype for the function \sphinxcode{\sphinxupquote{stopfunc}} is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n}{stopfunc}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{u}} is the current solution, and \sphinxcode{\sphinxupquote{g}}, the current gradient, is not preconditioned.

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
{\hyperref[\detokenize{examples/algorithms-and-optimizations:examplealgorithms}]{\sphinxcrossref{\DUrole{std,std-ref}{Algorithms.edp}}}}

\sphinxAtStartPar
For a given function \(b\), let us find the minimizer \(u\) of the function
\begin{equation*}
\begin{split}\begin{array}{rcl}
   J(u) &=& \frac{1}{2}\int_{\Omega} f(|\nabla u|^2) - \int_{\Omega} u b \\
   f(x) &=& ax + x-\ln(1+x), \quad f'(x) = a+\frac{x}{1+x}, \quad f''(x) = \frac{1}{(1+x)^2}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
under the boundary condition \(u=0\) on \(\partial\Omega\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//store df(|nabla u|\PYGZca{}2)}

\PYG{c+c1}{// The function J}
\PYG{c+c1}{//J(u) = 1/2 int\PYGZus{}Omega f(|nabla u|\PYGZca{}2) \PYGZhy{} int\PYGZus{}Omega u b}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
   \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// The gradient of J}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
   \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{au} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
         \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
      \PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
      \PYG{p}{;}

   \PYG{n}{u} \PYG{o}{=} \PYG{n}{au}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
We also want to construct a preconditioner \(C\) with solving the problem:

\sphinxAtStartPar
find \(u_h \in V_{0h}\) such that:
\begin{equation*}
\begin{split}\forall v_h \in V_{0h}, \quad \int_\Omega \alpha \nabla u_h . \nabla v_h = \int_\Omega b v_h\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\alpha=f'(|\nabla u|^2)\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{alap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{amass}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Amass} \PYG{o}{=} \PYG{n}{amass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Alap}\PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Preconditionner}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{w} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{=} \PYG{n}{Alap}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array variable}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To solve the problem, we make 10 iterations of the conjugate gradient, recompute the preconditioner and restart the conjugate gradient:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{conv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{conv} \PYG{o}{=} \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{C}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Alap} \PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Restart with new preconditionner }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{conv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, eps =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution with NLCG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
For a given symmetric positive matrix \(A\), consider the quadratic form
\begin{equation*}
\begin{split}J(\mathbf{x})=\frac{1}{2}\mathbf{x}^TA\mathbf{x}-\mathbf{b}^T\mathbf{x}\end{split}
\end{equation*}
\sphinxAtStartPar
then \(J(\mathbf{x})\) is minimized by the solution \(\mathbf{x}\) of \(A\mathbf{x}=\mathbf{b}\).
In this case, we can use the function \sphinxcode{\sphinxupquote{AffineCG}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineCG}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{stp}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If \(A\) is not symmetric, we can use GMRES(Generalized Minimum Residual) algorithm by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Also, we can use the non\sphinxhyphen{}linear version of GMRES algorithm (the function \(J\) is just convex)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{M}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{k+kr}{imax}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
For the details of these algorithms, refer to \sphinxcite{bibliography:pironneau1998}, Chapter IV, 1.3.


\subsection{Algorithms for Unconstrained Optimization}
\label{\detokenize{documentation/algorithms-and-optimization:algorithms-for-unconstrained-optimization}}
\sphinxAtStartPar
Two algorithms of COOOL package are interfaced with the Newton Raphson method (called \sphinxcode{\sphinxupquote{Newton}}) and the \sphinxcode{\sphinxupquote{BFGS}} method.
These two are directly available in \sphinxstylestrong{FreeFEM} (no dynamical link to load).
Be careful with these algorithms, because their implementation uses full matrices.
We also provide several optimization algorithms from the \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt library} as well as an interface for Hansen’s implementation of CMAES (a MPI version of this one is also available).


\subsubsection{Example of usage for BFGS or CMAES}
\label{\detokenize{documentation/algorithms-and-optimization:example-of-usage-for-bfgs-or-cmaes}}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
BFGS

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//J}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//the gradient of J (this is a affine version (the RHS is in)}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
      \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{n}{u} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ\PYGZhy{}b: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
\PYG{p}{\PYGZcb{}}

\PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
It is almost the same a using the CMA evolution strategy except, that since it is a derivative free optimizer, the \sphinxcode{\sphinxupquote{dJ}} argument is omitted and there are some other named parameters to control the behavior of the algorithm.
With the same objective function as above, an example of utilization would be (see {\hyperref[\detokenize{examples/algorithms-and-optimizations:examplecmaesvariationalinequality}]{\sphinxcrossref{\DUrole{std,std-ref}{CMAES Variational inequality}}}} for a complete example):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//define J, u, ...}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n+nf}{cmaes}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{stopTolFun}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{stopMaxIter}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{minimum value is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ for u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This algorithm works with a normal multivariate distribution in the parameters space and tries to adapt its covariance matrix using the information provided by the successive function evaluations (see \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation} for more details).
Therefore, some specific parameters can be passed to control the starting distribution, size of the sample generations, etc…
Named parameters for this are the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seed=}} Seed for random number generator (\sphinxcode{\sphinxupquote{val}} is an integer).
No specified value will lead to a clock based seed initialization.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{initialStdDev=}} Value for the standard deviations of the initial covariance matrix ( \sphinxcode{\sphinxupquote{val}} is a real).
If the value \(\sigma\) is passed, the initial covariance matrix will be set to \(\sigma I\).
The expected initial distance between initial \(X\) and the \(argmin\) should be roughly initialStdDev. Default is 0.3.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{initialStdDevs=}} Same as above except that the argument is an array allowing to set a value of the initial standard deviation for each parameter.
Entries differing by several orders of magnitude should be avoided (if it can’t be, try rescaling the problem).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopTolFun=}} Stops the algorithm if function value differences are smaller than the passed one, default is \(10^{-12}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopTolFunHist=}} Stops the algorithm if function value differences from the best values are smaller than the passed one, default is 0 (unused).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopTolX=}} Stopping criteria is triggered if step sizes in the parameters space are smaller than this real value, default is 0.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopTolXFactor=}} Stopping criteria is triggered when the standard deviation increases more than this value. The default value is \(10^{3}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopMaxFunEval=}} Stops the algorithm when \sphinxcode{\sphinxupquote{stopMaxFunEval}} function evaluations have been done.
Set to \(900(n+3)^{2}\) by default, where \(n\) is the parameters space dimension.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopMaxIter=}} Integer stopping the search when \sphinxcode{\sphinxupquote{stopMaxIter}} generations have been sampled.
Unused by default.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{popsize=}} Integer value used to change the sample size.
The default value is \(4+ \lfloor 3\ln (n) \rfloor\).
Increasing the population size usually improves the global search capabilities at the cost of, at most, a linear reduction of the convergence speed with respect to \sphinxcode{\sphinxupquote{popsize}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{paramFile=}} This \sphinxcode{\sphinxupquote{string}} type parameter allows the user to pass all the parameters using an extern file, as in Hansen’s original code.
More parameters related to the CMA\sphinxhyphen{}ES algorithm can be changed with this file.
Note that the parameters passed to the CMAES function in the \sphinxstylestrong{FreeFEM} script will be ignored if an input parameters file is given.

\end{itemize}


\subsection{IPOPT}
\label{\detokenize{documentation/algorithms-and-optimization:ipopt}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ff\sphinxhyphen{}Ipopt}} package is an interface for the \sphinxhref{https://projects.coin-or.org/Ipopt}{IPOPT} \sphinxcite{bibliography:wachter2006} optimizer.
IPOPT is a software library for large scale, non\sphinxhyphen{}linear, constrained optimization.
It implements a primal\sphinxhyphen{}dual interior point method along with filter method based line searches.

\sphinxAtStartPar
IPOPT needs a direct sparse symmetric linear solver.
If your version of \sphinxstylestrong{FreeFEM} has been compiled with the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}downlad}} tag, it will automatically be linked with a sequential version of MUMPS.
An alternative to MUMPS would be to download the HSL subroutines (see \sphinxhref{https://projects.coin-or.org/Ipopt/wiki/JavaInterface}{Compiling and Installing the Java Interface JIPOPT}) and place them in the \sphinxcode{\sphinxupquote{/ipopt/Ipopt\sphinxhyphen{}3.10.2/ThirdParty/HSL}} directory of the \sphinxstylestrong{FreeFEM} downloads folder before compiling.


\subsubsection{Short description of the algorithm}
\label{\detokenize{documentation/algorithms-and-optimization:short-description-of-the-algorithm}}
\sphinxAtStartPar
In this section, we give a very brief glimpse at the underlying mathematics of IPOPT.
For a deeper introduction on interior methods for nonlinear smooth optimization, one may consult \sphinxcite{bibliography:forsgren2002}, or \sphinxcite{bibliography:wachter2006} for more IPOPT specific elements.
IPOPT is designed to perform optimization for both equality and inequality constrained problems.
However, nonlinear inequalities are rearranged before the beginning of the optimization process in order to restrict the panel of nonlinear constraints to those of the equality kind.
Each nonlinear inequality is transformed into a pair of simple bound inequalities and nonlinear equality constraints by the introduction of as many slack variables as is needed : \(c_{i}(x)\leq 0\) becomes \(c_{i}(x) + s_{i} = 0\) and \(s_{i}\leq 0\), where \(s_{i}\) is added to the initial variables of the problems \(x_{i}\).
Thus, for convenience, we will assume that the minimization problem does not contain any nonlinear inequality constraint.
It means that, given a function \(f:\mathbb{R}^{n}\mapsto\mathbb{R}\), we want to find:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:minimproblem}
\begin{split}x_{0} = \underset{x\in V}{\operatorname{argmin}} f(x) \\
\mathrm{with}\ V = \left\lbrace x\in\mathbb{R}^{n}\ \vert\ c(x)= 0 \ \text{and}\ x_{l}\leq x\leq x_{u}\right\rbrace\end{split}
\end{equation}
\sphinxAtStartPar
Where \(c:\mathbb{R}^{n}\rightarrow\mathbb{R}^{m}\) and \(x_{l},x_{u}\in\mathbb{R}^{n}\) and inequalities hold componentwise.
The \(f\) function as well as the constraints \(c\) should be twice\sphinxhyphen{}continuously differentiable.

\sphinxAtStartPar
As a barrier method, interior points algorithms try to find a Karush\sphinxhyphen{}Kuhn\sphinxhyphen{}Tucker point for \eqref{equation:documentation/algorithms-and-optimization:minimproblem} by solving a sequence of problems, unconstrained with respect to the inequality constraints, of the form:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:barrier}
\begin{split}\mathrm{for\ a\ given\ }\mu > 0,\ \mathrm{find}\ x_{\mu} = \underset{x\in\mathbb{R}^{n}\ \vert\ c(x)=0}{\operatorname{argmin}}\ B(x,\mu)\end{split}
\end{equation}
\sphinxAtStartPar
Where \(\mu\) is a positive real number and
\begin{equation*}
\begin{split}B(x,\mu) = f(x) - \displaystyle{\mu\sum_{i=1}^{n} \ln (x_{u,i}-x_{i})} - \displaystyle{\mu\sum_{i=1}^{m} \ln(x_{i}-x_{l,i})}\end{split}
\end{equation*}
\sphinxAtStartPar
The remaining equality constraints are handled with the usual Lagrange multipliers method.
If the sequence of barrier parameters \(\mu\) converge to 0, intuition suggests that the sequence of minimizers of \eqref{equation:documentation/algorithms-and-optimization:barrier} converge to a local constrained minimizer of \eqref{equation:documentation/algorithms-and-optimization:minimproblem}.
For a given \(\mu\), \eqref{equation:documentation/algorithms-and-optimization:barrier} is solved by finding \((x_{\mu},\lambda_{\mu})\in\mathbb{R}^{n}\times\mathbb{R}^{m}\) such that:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:muproblem}
\begin{split}\nabla B(x_{\mu},\mu) + \displaystyle{\sum_{i=1}^{m}\lambda_{\mu,i}\nabla c_{i}(x_{\mu})}= \nabla B(x_{\mu},\mu) + J_{c}(x_{\mu})^{T}\lambda_{\mu}&= 0\\
c(x_{\mu}) &= 0\end{split}
\end{equation}
\sphinxAtStartPar
The derivations for \(\nabla B\) only holds for the \(x\) variables, so that:
\begin{equation*}
\begin{split}\nabla B(x,\mu) = \nabla f(x) + \left(\begin{matrix}\mu/(x_{u,1}-x_{1}) \\ \vdots \\ \mu/(x_{u,n}-x_{n})\end{matrix}\right) - \left(\begin{matrix}\mu/(x_{1}-x_{l,1}) \\ \vdots \\ \mu/(x_{n}-x_{l,n})\end{matrix}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
If we respectively call \(z_{u}(x,\mu) = \left(\mu/(x_{u,1}-x_{1}),\dots, \mu/(x_{u,n}-x_{n})\right)\) and \(z_{l}(x,\mu)\) the other vector appearing in the above equation, then the optimum \((x_{\mu},\lambda_{\mu})\) satisfies:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:muproblemlambda}
\begin{split}\nabla f(x_{\mu}) + J_{c}(x_{\mu})^{T}\lambda_{\mu}+ z_{u}(x_{\mu},\mu) - z_{l}(x_{\mu},\mu) = 0 \quad \text{and} \quad c(x_{\mu}) = 0\end{split}
\end{equation}
\sphinxAtStartPar
In this equation, the \(z_l\) and \(z_u\) vectors seem to play the role of Lagrange multipliers for the simple bound inequalities, and indeed, when \(\mu\rightarrow 0\), they converge toward some suitable Lagrange multipliers for the KKT conditions, provided some technical assumptions are fulfilled (see \sphinxcite{bibliography:forsgren2002}).

\sphinxAtStartPar
Equation \eqref{equation:documentation/algorithms-and-optimization:muproblemlambda} is solved by performing a Newton method in order to find a solution of \eqref{equation:documentation/algorithms-and-optimization:muproblem} for each of the decreasing values of \(\mu\).
Some order 2 conditions are also taken into account to avoid convergence to local maximizers, see \sphinxcite{bibliography:forsgren2002} for details about them.
In the most classic IP algorithms, the Newton method is directly applied to \eqref{equation:documentation/algorithms-and-optimization:muproblem}.
This is in most case inefficient due to frequent computation of infeasible points.
These difficulties are avoided in Primal\sphinxhyphen{}Dual interior point methods where \eqref{equation:documentation/algorithms-and-optimization:muproblem} is transformed into an extended system where \(z_u\) and \(z_l\) are treated as unknowns and the barrier problems are finding \((x,\lambda,z_u,z_l)\in\mathbb{R}^n\times\mathbb{R}^m\times\mathbb{R}^n\times\mathbb{R}^n\) such that:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:PrimalDualIPBarrierProblem}
\begin{split}\left\lbrace
\begin{array}{rcl}
   \nabla f(x) + J_{c}(x)^{T}\lambda+ z_{u} - z_{l} & = & 0 \\
   c(x) & = & 0 \\
   (X_u - X) z_u - \mu e & = & 0 \\
   (X - X_l) z_l - \mu e & = & 0
\end{array}
\right.\end{split}
\end{equation}
\sphinxAtStartPar
Where if \(a\) is a vector of \(\mathbb{R}^n\), \(A\) denotes the diagonal matrix \(A=(a_i \delta_{ij})_{1\leq i,j\leq n}\) and \(e\in\mathbb{R}^{n} = (1,1,\dots,1)\).
Solving this nonlinear system by the Newton method is known as being the \sphinxstyleemphasis{primal\sphinxhyphen{}dual} interior point method.
Here again, more details are available in \sphinxcite{bibliography:forsgren2002}.
Most actual implementations introduce features in order to globalize the convergence capability of the method, essentially by adding some line\sphinxhyphen{}search steps to the Newton algorithm, or by using trust regions.
For the purpose of IPOPT, this is achieved by a \sphinxstyleemphasis{filter line search} methods, the details of which can be found in \sphinxcite{bibliography:wachter2006}.

\sphinxAtStartPar
More IPOPT specific features or implementation details can be found in \sphinxcite{bibliography:wachter2006}.
We will just retain that IPOPT is a smart Newton method for solving constrained optimization problems, with global convergence capabilities due to a robust line search method (in the sense that the algorithm will converge no matter the initializer).
Due to the underlying Newton method, the optimization process requires expressions of all derivatives up to the order 2 of the fitness function as well as those of the constraints.
For problems whose Hessian matrices are difficult to compute or lead to high dimensional dense matrices, it is possible to use a BFGS approximation of these objects at the cost of a much slower convergence rate.


\subsubsection{IPOPT in \sphinxstylestrong{FreeFEM}}
\label{\detokenize{documentation/algorithms-and-optimization:ipopt-in-freefem}}
\sphinxAtStartPar
Calling the IPOPT optimizer in a \sphinxstylestrong{FreeFEM} script is done with the \sphinxcode{\sphinxupquote{IPOPT}} function included in the \sphinxcode{\sphinxupquote{ff\sphinxhyphen{}Ipopt}} dynamic library.
IPOPT is designed to solve constrained minimization problems in the form:
\begin{equation*}
\begin{split}\mathrm{find} & x_{0} = \underset{x\in\mathbb{R}^{n}}{\operatorname{argmin}} f(x) \\
\mathrm{s.t.} & \left\lbrace
\begin{array}{l r}
   \forall i\leq n,\ x_{i}^{\mathrm{lb}}\leq x_{i}\leq x_{i}^{\mathrm{ub}} & \mathrm{\ (simple\ bounds)} \\
   \forall i\leq m,\ c_{i}^{\mathrm{lb}}\leq c_{i}(x)\leq c_{i}^{\mathrm{ub}} & \mathrm{(constraints\ functions)}
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\mathrm{ub}\) and \(\mathrm{lb}\) stand for “upper bound” and “lower bound”.
If for some \(i, 1\leq i\leq m\) we have \(c_{i}^{\mathrm{lb}} = c_{i}^{\mathrm{ub}}\), it means that \(c_{i}\) is an equality constraint, and an inequality one if \(c_{i}^{\mathrm{lb}} < c_{i}^{\mathrm{ub}}\).

\sphinxAtStartPar
There are different ways to pass the fitness function and constraints.
The more general one is to define the functions using the keyword \sphinxcode{\sphinxupquote{func}}.
Any returned matrix must be a sparse one (type \sphinxcode{\sphinxupquote{matrix}}, not a \sphinxcode{\sphinxupquote{real{[}int,int{]}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Fitness Function, returns a scalar}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gradJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Gradient is a vector}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Constraints}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n}{jacC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Constraints Jacobian}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In the current version of \sphinxstylestrong{FreeFEM}, returning a \sphinxcode{\sphinxupquote{matrix}} object that is local to a function block leads to undefined results.
For each sparse matrix returning function you define, an extern matrix object has to be declared, whose associated function will overwrite and return on each call.
Here is an example for \sphinxcode{\sphinxupquote{jacC}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{jacCBuffer}\PYG{p}{;} \PYG{c+c1}{//just declare, no need to define yet}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{jacC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{c+c1}{//fill jacCBuffer}
   \PYG{k}{return} \PYG{n}{jacCBuffer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
IPOPT requires the structure of each matrix at the initialization of the algorithm.
Some errors may occur if the matrices are not constant and are built with the \sphinxcode{\sphinxupquote{matrix A = {[}I,J,C{]}}} syntax, or with an intermediary full matrix (\sphinxcode{\sphinxupquote{real{[}int,int{]}}}), because any null coefficient is discarded during the construction of the sparse matrix.
It is also the case when making matrices linear combinations, for which any zero coefficient will result in the suppression of the matrix from the combination.
Some controls are available to avoid such problems.
Check the named parameter descriptions (\sphinxcode{\sphinxupquote{checkindex}}, \sphinxcode{\sphinxupquote{structhess}} and \sphinxcode{\sphinxupquote{structjac}} can help).
We strongly advice to use \sphinxcode{\sphinxupquote{varf}} as much as possible for the matrix forging.
\end{sphinxadmonition}

\sphinxAtStartPar
The Hessian returning function is somewhat different because it has to
be the Hessian of the Lagrangian function:
\begin{equation*}
\begin{split}(x,\sigma_{f},\lambda)\mapsto\sigma_{f}\nabla^{2}f(x)+\displaystyle{\sum_{i=1}^{m}\lambda_{i}\nabla^{2}c_{i}(x)}\ \mathrm{ where }\ \lambda\in\mathbb{R}^{m}\ \mathrm{ and }\ \sigma\in\mathbb{R}\end{split}
\end{equation*}
\sphinxAtStartPar
Your Hessian function should then have the following prototype:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianLBuffer}\PYG{p}{;} \PYG{c+c1}{//Just to keep it in mind}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{hessianL} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the constraints functions are all affine, or if there are only simple bound constraints, or no constraint at all, the Lagrangian Hessian is equal to the fitness function Hessian, one can then omit the \sphinxcode{\sphinxupquote{sigma}} and \sphinxcode{\sphinxupquote{lambda}} parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianJBuffer}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{hessianJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Hessian prototype when constraints are affine}
\end{sphinxVerbatim}

\sphinxAtStartPar
When these functions are defined, IPOPT is called this way:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Xi} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//starting point}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianL}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*some named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the Hessian is omitted, the interface will tell IPOPT to use the (L)BFGS approximation (it can also be enabled with a named parameter, see further).
Simple bound or unconstrained problems do not require the constraints part, so the following expressions are valid:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//IPOPT with BFGS}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianJ}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Newton IPOPT without constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//BFGS, no constraints}
\end{sphinxVerbatim}

\sphinxAtStartPar
Simple bounds are passed using the \sphinxcode{\sphinxupquote{lb}} and \sphinxcode{\sphinxupquote{ub}} named parameters, while constraint bounds are passed with the \sphinxcode{\sphinxupquote{clb}} and \sphinxcode{\sphinxupquote{cub}} ones.
Unboundedness in some directions can be achieved by using the \(1e^{19}\) and \(-1e^{19}\) values that IPOPT recognizes as \(+\infty\) and \(-\infty\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xlb}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xub}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{clb}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{,} \PYG{n}{cub}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//fill the arrays...}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianL}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{xlb}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{xub}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{c+cm}{/*some other named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{P2 fitness function and affine constraints function :} In the case where the fitness function or constraints function can be expressed respectively in the following forms:
\begin{equation*}
\begin{split}\begin{array}{c c}
    \forall x\in\mathbb{R}^{n},\ f(x) = \frac{1}{2}\left\langle Ax,x \right\rangle + \left\langle b,x\right\rangle & (A,b)\in\mathcal{M}_{n,n}(\mathbb{R})\times\mathbb{R}^{n} \\
    \mathrm{or} ,\ C(x) = Ax + b & (A,b)\in\mathcal{M}_{m,n}(\mathbb{R})\times\mathbb{R}^{m}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(A\) and \(b\) are constant, it is possible to directly pass the \((A,b)\) pair instead of defining 3 (or 2) functions.
It also indicates to IPOPT that some objects are constant and that they have to be evaluated only once, thus avoiding multiple copies of the same matrix.
The syntax is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Affine constraints with \PYGZdq{}standard\PYGZdq{} fitness function}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear part of the constraints}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//constant part of constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{gradJ}\PYG{p}{,} \PYG{n}{hessianJ}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//[b, A] would work as well.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that if you define the constraints in this way, they don’t contribute to the Hessian, so the Hessian should only take one \sphinxcode{\sphinxupquote{real{[}int{]}}} as an argument.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Affine constraints and P2 fitness func}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//bilinear form matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear contribution to f}
\PYG{k+kt}{matrix} \PYG{n}{Ac} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear part of the constraints}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bc} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//constant part of constraints}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Ac}\PYG{p}{,} \PYG{n}{bc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If both objective and constraint functions are given this way, it automatically activates the IPOPT \sphinxcode{\sphinxupquote{mehrotra\_algorithm}} option (better for linear and quadratic programming according to the documentation).
Otherwise, this option can only be set through the option file (see the named parameters section).

\sphinxAtStartPar
A false case is the one of defining \(f\) in this manner while using standard functions for the constraints:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//bilinear form matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{;} \PYG{c+c1}{//linear contribution to f}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//constraints}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n}{jacC}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//constraints Jacobian}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{C}\PYG{p}{,} \PYG{n}{jacC}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bounds and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Indeed, when passing \sphinxcode{\sphinxupquote{{[}A, b{]}}} in order to define \(f\), the Lagrangian Hessian is automatically built and has the constant \(x \mapsto A\) function, with no way to add possible constraint contributions, leading to incorrect second order derivatives.
So, a problem should be defined like that in only two cases:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
constraints are nonlinear but you want to use the BFGS mode (then add \sphinxcode{\sphinxupquote{bfgs=1}} to the named parameter),

\item {} 
\sphinxAtStartPar
constraints are affine, but in this case, compatible to pass in the same way

\end{enumerate}

\sphinxAtStartPar
Here are some other valid definitions of the problem (cases when \(f\) is a pure quadratic or linear form, or \(C\) a pure linear function, etc…):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Pure quadratic f \PYGZhy{} A is a matrix}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{c+cm}{/*constraints arguments*/}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Pure linear f \PYGZhy{} b is a real[int]}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{c+cm}{/*constraints arguments*/}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Linear constraints \PYGZhy{} Ac is a matrix}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{c+cm}{/*fitness function arguments*/}\PYG{p}{,} \PYG{n}{Ac}\PYG{p}{,} \PYG{n}{Xi}\PYG{p}{,} \PYG{c+cm}{/*bound and named parameters*/}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Returned Value :} The \sphinxcode{\sphinxupquote{IPOPT}} function returns an error code of type \sphinxcode{\sphinxupquote{int}}.
A zero value is obtained when the algorithm succeeds and positive values reflect the fact that IPOPT encounters minor troubles.
Negative values reveal more problematic cases.
The associated IPOPT return tags are listed in the table below.
The \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{IPOPT pdf documentation} provides a more accurate description of these return statuses:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Success
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Failures
\\
\hline
\sphinxAtStartPar
0 \sphinxcode{\sphinxupquote{Solve\_Succeeded}}
&\\
\hline
\sphinxAtStartPar
1 \sphinxcode{\sphinxupquote{Solved\_To\_Acceptable\_Level}}
&
\sphinxAtStartPar
\sphinxhyphen{}1 \sphinxcode{\sphinxupquote{Maximum\_Iterations\_Exceeded}}
\\
\hline
\sphinxAtStartPar
2 \sphinxcode{\sphinxupquote{Infeasible\_Problem\_Detected}}
&
\sphinxAtStartPar
\sphinxhyphen{}2 \sphinxcode{\sphinxupquote{Restoration\_Failed}}
\\
\hline
\sphinxAtStartPar
3 \sphinxcode{\sphinxupquote{Search\_Direction\_Becomes\_Too\_Small}}
&
\sphinxAtStartPar
\sphinxhyphen{}3 \sphinxcode{\sphinxupquote{Error\_In\_Step\_Computation}}
\\
\hline
\sphinxAtStartPar
4 \sphinxcode{\sphinxupquote{Diverging\_Iterates}}
&
\sphinxAtStartPar
\sphinxhyphen{}4 \sphinxcode{\sphinxupquote{Maximum\_CpuTime\_Exceeded}}
\\
\hline
\sphinxAtStartPar
5 \sphinxcode{\sphinxupquote{User\_Requested\_Stop}}
&\\
\hline
\sphinxAtStartPar
6 \sphinxcode{\sphinxupquote{Feasible\_Point\_Found}}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Problem definition issues
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Critical errors
\\
\hline
\sphinxAtStartPar
\sphinxhyphen{}10 \sphinxcode{\sphinxupquote{Not\_Enough\_Degrees\_Of\_Freedom}}
&
\sphinxAtStartPar
\sphinxhyphen{}100 \sphinxcode{\sphinxupquote{Unrecoverable\_Exception}}
\\
\hline
\sphinxAtStartPar
\sphinxhyphen{}11 \sphinxcode{\sphinxupquote{Invalid\_Problem\_Definition}}
&
\sphinxAtStartPar
\sphinxhyphen{}101 \sphinxcode{\sphinxupquote{NonIpopt\_Exception\_Thrown}}
\\
\hline
\sphinxAtStartPar
\sphinxhyphen{}12 \sphinxcode{\sphinxupquote{Invalid\_Option}}
&
\sphinxAtStartPar
\sphinxhyphen{}102 \sphinxcode{\sphinxupquote{Insufficient\_Memory}}
\\
\hline
\sphinxAtStartPar
\sphinxhyphen{}13 \sphinxcode{\sphinxupquote{Invalid\_Number\_Detected}}
&
\sphinxAtStartPar
\sphinxhyphen{}199 \sphinxcode{\sphinxupquote{Internal\_Error}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Named Parameters :} The available named parameters in this interface are those we thought to be the most subject to variations from one optimization to another, plus a few that are interface specific.
Though, as one could see at \sphinxhref{https://coin-or.github.io/Ipopt/OPTIONS.html\#OPT\_MA97\_Linear\_Solver}{IPOPT Linear solver}, there are many parameters that can be changed within IPOPT, affecting the algorithm behavior.
These parameters can still be controlled by placing an option file in the execution directory.
Note that \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{IPOPT’s pdf documentation} may provides more information than the previously mentioned online version for certain parameters.
The in\sphinxhyphen{}script available parameters are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lb}}, \sphinxcode{\sphinxupquote{ub}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} for lower and upper simple bounds upon the search variables must be of size \(n\) (search space dimension).
If two components of the same index in these arrays are equal then the corresponding search variable is fixed.
By default IPOPT will remove any fixed variable from the optimization process and always use the fixed value when calling functions.
It can be changed using the \sphinxcode{\sphinxupquote{fixedvar}} parameter.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{clb}}, \sphinxcode{\sphinxupquote{cub}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(m\) (number of constraints) for lower and upper constraints bounds.
Equality between two components of the same index \(i\) in \sphinxcode{\sphinxupquote{clb}} and \sphinxcode{\sphinxupquote{cub}} reflect an equality constraint.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{structjacc}} : To pass the greatest possible structure (indexes of non null coefficients) of the constraint Jacobians under the form \sphinxcode{\sphinxupquote{{[}I,J{]}}} where \sphinxcode{\sphinxupquote{I}} and \sphinxcode{\sphinxupquote{J}} are two integer arrays.
If not defined, the structure of the constraint Jacobians, evaluated in \sphinxcode{\sphinxupquote{Xi}}, is used (no issue if the Jacobian is constant or always defined with the same \sphinxcode{\sphinxupquote{varf}}, hazardous if it is with a triplet array or if a full matrix is involved).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{structhess}} : Same as above but for the Hessian function (unused if \(f\) is P2 or less and constraints are affine).
Here again, keep in mind that it is the Hessian of the Lagrangian function (which is equal to the Hessian of \(f\) only if constraints are affine).
If no structure is given with this parameter, the Lagrangian Hessian is evaluated on the starting point, with \(\sigma=1\) and \(\lambda = (1,1,\dots,1)\) (it is safe if all the constraints and fitness function Hessians are constant or build with \sphinxcode{\sphinxupquote{varf}}, and here again it is less reliable if built with a triplet array or a full matrix).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{checkindex}} : A \sphinxcode{\sphinxupquote{bool}} that triggers a dichotomic index search when matrices are copied from \sphinxstylestrong{FreeFEM} functions to IPOPT arrays.
It is used to avoid wrong index matching when some null coefficients are removed from the matrices by \sphinxstylestrong{FreeFEM}.
It will not solve the problems arising when a too small structure has been given at the initialization of the algorithm.
Enabled by default (except in cases where all matrices are obviously constant).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{warmstart}} : If set to \sphinxcode{\sphinxupquote{true}}, the constraints dual variables \(\lambda\), and simple bound dual variables are initialized with the values of the arrays passed to \sphinxcode{\sphinxupquote{lm}}, \sphinxcode{\sphinxupquote{lz}} and \sphinxcode{\sphinxupquote{uz}} named parameters (see below).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lm}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(m\), which is used to get the final values of the constraints dual variables \(\lambda\) and/or initialize them in case of a warm start (the passed array is also updated to the last dual variables values at the end of the algorithm).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lz}}, \sphinxcode{\sphinxupquote{uz}} : \sphinxcode{\sphinxupquote{real{[}int{]}}} of size \(n\) to get the final values and/or initialize (in case of a warm start) the dual variables associated to simple bounds.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tol}} : \sphinxcode{\sphinxupquote{real}}, convergence tolerance for the algorithm, the default value is \(10^{-8}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxiter}} : \sphinxcode{\sphinxupquote{int}}, maximum number of iterations with 3000 as default value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxcputime}} : \sphinxcode{\sphinxupquote{real}} value, maximum runtime duration. Default is \(10^{6}\) (almost 11 and a halfdays).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bfgs}} : \sphinxcode{\sphinxupquote{bool}} enabling or not the (low\sphinxhyphen{}storage) BFGS approximation of the Lagrangian Hessian.
It is set to false by default, unless there is no way to compute the Hessian with the functions that have been passed to IPOPT.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{derivativetest}} : Used to perform a comparison of the derivatives given to IPOPT with finite differences computation.
The possible \sphinxcode{\sphinxupquote{string}} values are : \sphinxcode{\sphinxupquote{"none"}} (default), \sphinxcode{\sphinxupquote{"first\sphinxhyphen{}order"}}, \sphinxcode{\sphinxupquote{"second\sphinxhyphen{}order"}} and \sphinxcode{\sphinxupquote{"only\sphinxhyphen{}second\sphinxhyphen{}order"}}.
The associated derivative error tolerance can be changed via the option file.
One should not care about any error given by it before having tried, and failed, to perform a first optimization.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dth}} : Perturbation parameter for the derivative test computations with finite differences.
Set by default to \(10^{-8}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dttol}} : Tolerance value for the derivative test error detection (default value unknown yet, maybe \(10^{-5}\)).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{optfile}} : \sphinxcode{\sphinxupquote{string}} parameter to specify the IPOPT option file name.
IPOPT will look for a \sphinxcode{\sphinxupquote{ipopt.opt}} file by default.
Options set in the file will overwrite those defined in the \sphinxstylestrong{FreeFEM} script.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{printlevel}} : An \sphinxcode{\sphinxupquote{int}} to control IPOPT output print level, set to 5 by default, the possible values are from 0 to 12.
A description of the output information is available in the \sphinxhref{https://projects.coin-or.org/Ipopt/browser/stable/3.10/Ipopt/doc/documentation.pdf?format=raw}{PDF documentation} of IPOPT.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fixedvar}} : \sphinxcode{\sphinxupquote{string}} for the definition of simple bound equality constraints treatment : use \sphinxcode{\sphinxupquote{"make\_parameter"}} (default value) to simply remove them from the optimization process (the functions will always be evaluated with the fixed value for those variables), \sphinxcode{\sphinxupquote{"make\_constraint"}} to treat them as any other constraint or \sphinxcode{\sphinxupquote{"relax\_bounds"}} to relax fixing bound constraints.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mustrategy}} : a \sphinxcode{\sphinxupquote{string}} to choose the update strategy for the barrier parameter \(\mu\).
The two possible tags are \sphinxcode{\sphinxupquote{"monotone"}}, to use the monotone (Fiacco\sphinxhyphen{}McCormick) strategy, or \sphinxcode{\sphinxupquote{"adaptive"}} (default setting).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{muinit}} : \sphinxcode{\sphinxupquote{real}} positive value for the barrier parameter initialization.
It is only relevant when \sphinxcode{\sphinxupquote{mustrategy}} has been set to \sphinxcode{\sphinxupquote{monotone}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pivtol}} : \sphinxcode{\sphinxupquote{real}} value to set the pivot tolerance for the linear solver. A smaller number pivots for sparsity, a larger number pivots for stability.
The value has to be in the \([0,1]\) interval and is set to \(10^{-6}\) by default.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{brf}} : Bound relax factor: before starting the optimization, the bounds given by the user are relaxed.
This option sets the factor for this relaxation.
If it is set to zero, then the bound relaxation is disabled.
This \sphinxcode{\sphinxupquote{real}} has to be positive and its default value is \(10^{-8}\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{objvalue}} : An identifier to a \sphinxcode{\sphinxupquote{real}} type variable to get the last value of the objective function (best value in case of success).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mumin}} : minimum value for the barrier parameter \(\mu\), a \sphinxcode{\sphinxupquote{real}} with \(10^{-11}\) as default value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{linesearch}} : A boolean which disables the line search when set to \sphinxcode{\sphinxupquote{false}}.
The line search is activated by default.
When disabled, the method becomes a standard Newton algorithm instead of a primal\sphinxhyphen{}dual system.
The global convergence is then no longer assured, meaning that many initializers could lead to diverging iterates.
But on the other hand, it can be useful when trying to catch a precise local minimum without having some out of control process making the iterate caught by some other near optimum.

\end{itemize}


\subsection{Some short examples using IPOPT}
\label{\detokenize{documentation/algorithms-and-optimization:some-short-examples-using-ipopt}}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Ipopt variational inequality
A very simple example consisting of, given two functions \(f\) and \(g\) (defined on \(\Omega\subset\mathbb{R}^{2}\)), minimizing \(J(u) = \displaystyle{\frac{1}{2}\int_{\Omega} \vert\nabla u\vert^{2} - \int_{\Omega}fu}\ \), with \(u\leq g\) almost everywhere:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{c+c1}{//\PYGZhy{} Delta u = f}
\PYG{c+c1}{//u \PYGZlt{} g}
\PYG{c+c1}{//u = 0 on Gamma}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//rhs function}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.03}\PYG{p}{,} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{r} \PYG{o}{\PYGZhy{}} \PYG{n}{r}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{lb} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.e19}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ub} \PYG{o}{=} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{vP} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here we build the matrix and second member associated to the function to fully and finally minimize it.
The \sphinxcode{\sphinxupquote{{[}A,b{]}}} syntax for the fitness function is then used to pass it to IPOPT.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We use simple bounds to impose the boundary condition \(u=0\) on \(\partial\Omega\), as well as the \(u\leq g\) condition.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{vGamma} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onGamma} \PYG{o}{=} \PYG{n}{vGamma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//warning: the boundary conditions are given with lb and ub on border}
\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{b}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Ipopt variational inequality 2

\sphinxAtStartPar
Let \(\Omega\) be a domain of \(\mathbb{R}^{2}\).
\(f_{1}, f_{2}\in L^{2}(\Omega)\) and \(g_{1}, g_{2} \in L^{2}(\partial\Omega)\) four given functions with \(g_{1}\leq g_{2}\) almost everywhere.
We define the space:
\begin{equation*}
\begin{split}V = \left\lbrace (v_{1},v_{2})\in H^{1}(\Omega)^{2} ; v_{1}\vert_{\partial\Omega}=g_{1}, v_{2}\vert_{\partial\Omega}=g_{2}, v_{1}\leq v_{2}\ \mathrm{a.e.}\ \right\rbrace\end{split}
\end{equation*}
\sphinxAtStartPar
as well as the function \(J:H^{1}(\Omega)^{2}\longrightarrow \mathbb{R}\):
\begin{equation*}
\begin{split}J(v_{1},v_{2}) = \displaystyle{\frac{1}{2}\int_{\Omega}\vert\nabla v_{1}\vert^{2} - \int_{\Omega} f_{1}v_{1} + \frac{1}{2}\int_{\Omega}\vert\nabla v_{2}\vert^{2} - \int_{\Omega} f_{2}v_{2}}\end{split}
\end{equation*}
\sphinxAtStartPar
The problem entails finding (numerically) two functions \((u_{1},u_{2}) = \underset{(v_{1},v_{2})\in V}{\operatorname{argmin}} J(v_{1},v_{2})\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}\PYG{c+c1}{//right hand side}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{;}\PYG{c+c1}{//Boundary condition functions}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//starting point}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{lm}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Problem}
   \PYG{k+kt}{varf} \PYG{n}{vP} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
         \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
      \PYG{p}{)}
      \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{n}{f1}\PYG{o}{*}\PYG{n}{v1}
         \PYG{o}{+} \PYG{n}{f2}\PYG{o}{*}\PYG{n}{v2}
      \PYG{p}{)}
      \PYG{p}{;}

   \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//fitness function matrix}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vP}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//and linear form}

   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{II1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{II2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{c+c1}{//Constraints matrix}
   \PYG{k+kt}{matrix} \PYG{n}{C1} \PYG{o}{=} \PYG{n+nf}{interpolate} \PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{II1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{C2} \PYG{o}{=} \PYG{n+nf}{interpolate} \PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{II2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{CC} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{C1} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{;} \PYG{c+c1}{// u2 \PYGZhy{} u1 \PYGZgt{} 0}
   \PYG{n}{Wh} \PYG{n}{cl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//constraints lower bounds (no upper bounds)}

   \PYG{c+c1}{//Boundary conditions}
   \PYG{k+kt}{varf} \PYG{n+nf}{vGamma} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onGamma} \PYG{o}{=} \PYG{n}{vGamma}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ub1}\PYG{p}{,} \PYG{n}{ub2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{lb1}\PYG{p}{,} \PYG{n}{lb2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{g2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{:} \PYG{l+m+mf}{1e19}\PYG{p}{;} \PYG{c+c1}{//Unbounded in interior}
   \PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{onGamma} \PYG{o}{?} \PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e19}\PYG{p}{;}

   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uzi}\PYG{p}{,} \PYG{n}{uzi2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{lzi}\PYG{p}{,} \PYG{n}{lzi2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{Wh} \PYG{n}{lmi} \PYG{o}{=} \PYG{n}{lm}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{;}

   \PYG{c+c1}{// Solve}
   \PYG{n}{IPOPT}\PYG{p}{(}\PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{]}\PYG{p}{,} \PYG{n}{CC}\PYG{p}{,} \PYG{n}{ui1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{cl}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{iter}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uzi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lzi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lmi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{iter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Mesh adpatation}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.004}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{100000}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{uz}\PYG{p}{,} \PYG{n}{uz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{uzi}\PYG{p}{,} \PYG{n}{uzi2}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{lz}\PYG{p}{,} \PYG{n}{lz2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{lzi}\PYG{p}{,} \PYG{n}{lzi2}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ui1}\PYG{p}{,} \PYG{n}{ui2}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{lm} \PYG{o}{=} \PYG{n}{lmi}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{VarIneqFill}.jpg}
\caption{Numerical Approximation of the Variational Inequality}\label{\detokenize{documentation/algorithms-and-optimization:id10}}\label{\detokenize{documentation/algorithms-and-optimization:figalgovarineqfill}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{VarIneqIso}.jpg}
\caption{Numerical Approximation of the Variational Inequality}\label{\detokenize{documentation/algorithms-and-optimization:id11}}\label{\detokenize{documentation/algorithms-and-optimization:figalgovarineqiso}}\end{subfigure}
\caption{Variational inequality}

\end{figure}

\end{sphinxadmonition}


\subsection{3D constrained minimum surface with IPOPT}
\label{\detokenize{documentation/algorithms-and-optimization:d-constrained-minimum-surface-with-ipopt}}\label{\detokenize{documentation/algorithms-and-optimization:VariationalInequality}}

\subsubsection{Area and volume expressions}
\label{\detokenize{documentation/algorithms-and-optimization:area-and-volume-expressions}}
\sphinxAtStartPar
This example is aimed at numerically solving some constrained minimum surface problems with the IPOPT algorithm.
We restrain to \(C^{k}\) (\(k\geq 1\)), closed, spherically parametrizable surfaces, i.e. surfaces \(S\) such that:
\begin{equation*}
\begin{split}\exists \rho \in C^{k}([0,2\pi ]\times[0,\pi] ) \vert
S = \left\lbrace
X = \left(
\begin{array} {c}
 \rho(\theta,\phi) \\
 0 \\
 0
\end{array}
\right)
, (\theta,\phi) \in [0,2\pi ]\times[0,\pi]
 \right\rbrace\end{split}
\end{equation*}
\sphinxAtStartPar
Where the components are expressed in the spherical coordinate system.
Let’s call \(\Omega\) the \([0,2\pi ]\times[0,\pi]\) angular parameters set.
In order to exclude self crossing and opened shapes, the following assumptions upon \(\rho\) are made:
\begin{equation*}
\begin{split}\rho \geq 0\ \ \mathrm{and}\ \ \forall \phi, \rho(0,\phi) = \rho(2\pi,\phi)\end{split}
\end{equation*}
\sphinxAtStartPar
For a given function \(\rho\) the first fundamental form (the metric) of the defined surface has the following matrix representation:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:msfff}
\begin{split}G =
\left(
\begin{array}{c c}
    \rho^{2}\sin^{2}(\phi) + (\partial_{\theta}\rho)^{2} &\partial_{\theta}\rho\partial_{\phi}\rho \\
    \partial_{\theta}\rho\partial_{\phi}\rho & \rho^{2} + (\partial_{\phi}\rho)^{2} \\
\end{array}
\right)\end{split}
\end{equation}
\sphinxAtStartPar
This metric is used to express the area of the surface.
Let \(g=\det(G)\), then we have:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:msarea}
\begin{split}\begin{array}{ll}
    \mathcal{A}(\rho) &= \int{\Omega}{\left\| \partial_{\theta} X \wedge \partial_{\phi} X \right\|} =\int{\Omega}{\sqrt{g}}\\
        &=\int{\Omega}{\sqrt{ \rho^{2}(\partial_{\theta}\rho)^{2} + \rho^{4}\sin^{2}(\phi) + \rho^{2}(\partial_{\phi}\rho)^{2}\sin^{2}(\phi)}d\theta d\phi}
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
The volume of the space enclosed within the shape is easier to express:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:msvolume}
\begin{split}\mathcal{V}(\rho)
= \int{\Omega}{\int_{0}^{\rho(\theta,\phi)} r^{2}\sin(\phi) dr d\theta d\phi}
= \frac{1}{3}\int{\Omega}{\rho^{3} \sin(\phi) d\theta d\phi}\end{split}
\end{equation}

\subsubsection{Derivatives}
\label{\detokenize{documentation/algorithms-and-optimization:derivatives}}
\sphinxAtStartPar
In order to use a Newton based interior point optimization algorithm, one must be able to evaluate the derivatives of \(\mathcal{A}\) and \(\mathcal{V}\) with respect to \(rho\).
Concerning the area, we have the following result:
\begin{equation*}
\begin{split}\forall v\in C^{1}(\Omega) \ , \ \langle d\mathcal{A}(\rho),v\rangle
= \int{\Omega}{\frac{1}{2} \frac{ d\bar{g}(\rho)(v)}{\sqrt{g}}d\theta d\phi }\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\bar{g}\) is the application mapping the \((\theta,\phi) \mapsto g(\theta,\phi)\) scalar field to \(\rho\).
This leads to the following expression, easy to transpose in a freefem script using:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:msdarea}
\begin{split}\begin{array}{r c l}
    \forall v\in C^{1}(\Omega)& &\\
    \langle d\mathcal{A}(\rho),v\rangle &=& \int{\Omega}{ \left(2\rho^{3}\sin^{2}(\phi) + \rho(\partial_{\theta}\rho)^{2} + \rho(\partial_{\phi}\rho)^{2}\sin^{2}(\phi) \right) v} \\
    & & +\int{\Omega}{\ \rho^{2}\partial_{\theta}\rho\partial_{\theta} v\ + \ \rho^{2}\partial_{\phi}\rho\sin^{2}(\phi)\partial_{\phi} v }
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
With a similar approach, one can derive an expression for second order derivatives.
However, comporting no specific difficulties, the detailed calculus are tedious, the result is that these derivatives can be written using a \(3\times 3\) matrix \(\mathbf{B}\) whose coefficients are expressed in term of \(\rho\) and its derivatives with respect to \(\theta\) and \(\phi\), such that:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:msd2area}
\begin{split}\forall (w,v)\in C^{1}(\Omega)\ ,\ d^{2}\mathcal{A}(\rho)(w,v) = \int{\Omega}
{
   \left(\begin{array}{c c c} w & \partial_{\theta} w & \partial_{\phi} w \end{array}\right)
   \mathbf{B}
} \left( \begin{array}{c} v \\ \partial_{\theta} v \\ \partial_{\phi} v \end{array} \right) d\theta d\phi\end{split}
\end{equation}
\sphinxAtStartPar
Deriving the volume function derivatives is again an easier task.
We immediately get the following expressions:
\begin{equation}\label{equation:documentation/algorithms-and-optimization:msdvolume}
\begin{split}\begin{array}{r c l}
   \forall v\ ,\ \langle d\mathcal{V}(\rho),v\rangle & = & \int{\Omega}{\rho^{2}\sin(\phi)v\ d\theta d\phi} \\
   \forall w,v\ , d^{2}\mathcal{V}(\rho)(w,v) & = & \int{\Omega}{2\rho\sin(\phi)wv\ d\theta d\phi}
\end{array}\end{split}
\end{equation}

\subsubsection{The problem and its script}
\label{\detokenize{documentation/algorithms-and-optimization:the-problem-and-its-script}}
\sphinxAtStartPar
The whole code is available in {\hyperref[\detokenize{examples/algorithms-and-optimizations:exampleipoptminimalsurfacevolume}]{\sphinxcrossref{\DUrole{std,std-ref}{IPOPT minimal surface \& volume example}}}}.
We propose to solve the following problem:

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Given a positive function \(\rho_{\mathrm{object}}\) piecewise continuous, and a scalar \(\mathcal{V}_{\mathrm{max}} > \mathcal{V}(\rho_{\mathrm{object}})\), find \(\rho_{0}\) such that:
\begin{equation*}
\begin{split}\rho_{0} = \underset{\rho\in C^{1}(\Omega)}{\operatorname{argmin}}\ \mathcal{A}(\rho)\ ,\ \mathrm{s.t.}\ \rho_{0}\geq\rho_{\mathrm{object}} \ \mathrm{and\ } \mathcal{V}(\rho_{0})\leq \mathcal{V}_{\mathrm{max}}\end{split}
\end{equation*}
\sphinxAtStartPar
If \(\rho_{\mathrm{object}}\) is the spherical parametrization of the surface of a 3\sphinxhyphen{}dimensional object (domain) \(\mathcal{O}\), it can be interpreted as finding the surface with minimum area enclosing the object with a given maximum volume. If \(\mathcal{V}_{\mathrm{max}}\) is close to \(\mathcal{V}(\rho_{\mathrm{object}})\), so should be \(\rho_{0}\) and \(\rho_{\mathrm{object}}\). With higher values of \(\mathcal{V}_{\mathrm{max}}\), \(\rho\) should be closer to the unconstrained minimum surface surrounding \(\mathcal{O}\) which is obtained as soon as \(\mathcal{V}_{\mathrm{max}} \geq \frac{4}{3}\pi \|\rho_{\mathrm{object}}\|_{\infty}^{3}\) (sufficient but not necessary).

\sphinxAtStartPar
It also could be interesting to solve the same problem with the constraint \(\mathcal{V}(\rho_{0})\geq \mathcal{V}_{\mathrm{min}}\) which leads to a sphere when \(\mathcal{V}_{\mathrm{min}} \geq \frac{1}{6}\pi \mathrm{diam}(\mathcal{O})^{3}\) and moves toward the solution of the unconstrained problem as \(\mathcal{V}_{\mathrm{min}}\) decreases.

\sphinxAtStartPar
We start by meshing the domain \([0,2\pi]\times\ [0,\pi]\), then a periodic P1 finite elements space is defined.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{regtest}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{shapeswitch} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{40.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{treshold} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r0} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{r0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{e}\PYG{o}{*}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{rr}\PYG{o}{*}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Initial shape definition}
\PYG{c+c1}{//outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations}
\PYG{n}{Vh} \PYG{n}{startshape} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We create some finite element functions whose underlying arrays will be used to store the values of dual variables associated to all the constraints in order to reinitialize the algorithm with it in the case where we use mesh adaptation. Doing so, the algorithm will almost restart at the accuracy level it reached before mesh adaptation, thus saving many iterations.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh} \PYG{n}{uz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{n}{rreal}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{lm} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, follows the mesh adaptation loop, and a rendering function, \sphinxcode{\sphinxupquote{Plot3D}}, using 3D mesh to display the shape it is passed with \sphinxcode{\sphinxupquote{medit}} (the \sphinxcode{\sphinxupquote{movemesh23}} procedure often crashes when called with ragged shapes).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{kkk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{k+kt}{func} \PYG{n}{sin2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// A function which transform Th in 3d mesh (r=rho)}
   \PYG{c+c1}{//a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )}
   \PYG{c+c1}{//then displays the resulting mesh with medit}
   \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{Plot3D} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kt}{string} \PYG{k+kp}{cmm}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{ffplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{rhoo}\PYG{p}{;}
      \PYG{n}{rhoo}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
      \PYG{c+c1}{//mesh sTh = square(np, np/2, [2*pi*x, pi*y]);}
      \PYG{c+c1}{//fespace sVh(sTh, P1);}
      \PYG{c+c1}{//Vh rhoplot = rhoo;}
      \PYG{k}{try}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{mesh3} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{ffplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{else}
            \PYG{n+nf}{medit}\PYG{p}{(}\PYG{k+kp}{cmm}\PYG{p}{,} \PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PLOT ERROR}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here are the functions related to the area computation and its shape derivative, according to equations \eqref{equation:documentation/algorithms-and-optimization:msarea} and \eqref{equation:documentation/algorithms-and-optimization:msdarea}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Surface computation}
\PYG{c+c1}{//Maybe is it possible to use movemesh23 to have the surface function less complicated}
\PYG{c+c1}{//However, it would not simplify the gradient and the hessian}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Area} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho4}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho(theta,phi) on [0,2pi]x[0,pi] \PYGZhy{} S=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{res}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else}
      \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape\PYGZus{}evolution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{rho2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{;}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{varf} \PYG{n}{dArea} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
      \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
      \PYG{p}{)}
      \PYG{p}{;}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dArea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function returning the hessian of the area for a given shape is a bit blurry, thus we won’t show here all of equation \eqref{equation:documentation/algorithms-and-optimization:msd2area} coefficients definition, they can be found in the \sphinxcode{\sphinxupquote{edp}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{hessianA}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{sqrtPsi3}\PYG{p}{,} \PYG{n}{C00}\PYG{p}{,} \PYG{n}{C01}\PYG{p}{,} \PYG{n}{C02}\PYG{p}{,} \PYG{n}{C11}\PYG{p}{,} \PYG{n}{C12}\PYG{p}{,} \PYG{n}{C22}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{;}
   \PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{C0}\PYG{p}{,} \PYG{n}{C1}\PYG{p}{,} \PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{sqrtPsi3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sqrtPsi}\PYG{p}{;}
      \PYG{n}{C0} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
      \PYG{n}{C1} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C2} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C00} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C01} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C1}\PYG{p}{;}
      \PYG{n}{C02} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{C11} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{C12} \PYG{o}{=} \PYG{n}{C1}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
      \PYG{n}{C22} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{varf} \PYG{n}{d2Area} \PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
      \PYG{o}{=}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
           \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}
              \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
         \PYG{p}{)}
         \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi3} \PYG{o}{*} \PYG{p}{(}
              \PYG{n}{C00}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
            \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C11}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{C22}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
         \PYG{p}{)}
      \PYG{p}{)}
      \PYG{p}{;}
   \PYG{n}{hessianA} \PYG{o}{=} \PYG{n}{d2Area}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{hessianA}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
And the volume related functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Volume computation}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Volume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{rho3} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{dVolume}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dVolume}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{matrix} \PYG{n}{hessianV}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianVolume}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
   \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{hessianV} \PYG{o}{=} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{hessianV}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we want to use the volume as a constraint function we must wrap it and its derivatives in some \sphinxstylestrong{FreeFEM} functions returning the appropriate types.
It is not done in the above functions in cases where one wants to use it as a fitness function.
The lagrangian hessian also has to be wrapped since the Volume is not linear with respect to \(\rho\), it has some non\sphinxhyphen{}null second order derivatives.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ipVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vol} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Volume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{k}{return} \PYG{n}{vol}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{matrix} \PYG{n}{mdV}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipGradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{GradVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mdV} \PYG{o}{=} \PYG{n}{dvol}\PYG{p}{;} \PYG{k}{return} \PYG{n}{mdV}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{matrix} \PYG{n}{HLagrangian}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipHessianLag} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{objfact}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{HLagrangian} \PYG{o}{=} \PYG{n}{objfact}\PYG{o}{*}\PYG{n}{HessianArea}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{HessianVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{HLagrangian}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ipGradVolume}} function could pose some troubles during the optimization process because the gradient vector is transformed in a sparse matrix, so any null coefficient will be discarded.
Here we create the IPOPT structure manually and use the \sphinxcode{\sphinxupquote{checkindex}} named\sphinxhyphen{}parameter to avoid bad indexing during copies.
This gradient is actually dense, there is no reason for some components to be constantly zero:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gvi}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gvj}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{gvi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
These two arrays will be passed to IPOPT with \sphinxcode{\sphinxupquote{structjacc={[}gvi,gvj{]}}}.
The last remaining things are the bound definitions.
The simple lower bound must be equal to the components of the P1 projection of \(\rho_{object}\).
And we choose \(\alpha\in [0,1]\) to set \(\mathcal{V}_{\mathrm{max}}\) to \((1-\alpha) \mathcal{V}(\rho_{object}) + \alpha\frac{4}{3}\pi \|\rho_{\mathrm{object}}\|_{\infty}^{3}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{disc1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{disc2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{lb} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{q} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{disc1}\PYG{p}{,} \PYG{n}{disc2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Vobj} \PYG{o}{=} \PYG{n}{Volume}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Vnvc} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
   \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object\PYGZus{}inside}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{clb} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{cub} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vobj} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{Vnvc}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Calling IPOPT:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{Area}\PYG{p}{,} \PYG{n}{GradArea}\PYG{p}{,} \PYG{n}{ipHessianLag}\PYG{p}{,} \PYG{n}{ipVolume}\PYG{p}{,} \PYG{n}{ipGradVolume}\PYG{p}{,}
   \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{n}{checkindex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{kkk}\PYG{o}{\PYGZlt{}}\PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{?} \PYG{l+m+mi}{40}\PYG{o}{:}\PYG{l+m+mi}{150}\PYG{p}{,}
   \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{kkk}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lm}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{,} \PYG{n}{structjacc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{gvi}\PYG{p}{,}\PYG{n}{gvj}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IPOPT: res =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shape\PYGZus{}at\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{GradArea}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ShapeGradient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, before closing the mesh adaptation loop, we have to perform the said adaptation.
The mesh is adaptated with respect to the \(X=(\rho, 0, 0)\) (in spherical coordinates) vector field, not directly with respect to \(\rho\), otherwise the true curvature of the 3D\sphinxhyphen{}shape would not be well taken into account.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}
      \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{startshape} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{;}
   \PYG{n}{uz} \PYG{o}{=} \PYG{n}{uz}\PYG{p}{;}
   \PYG{n}{lz} \PYG{o}{=} \PYG{n}{lz}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Here are some pictures of the resulting surfaces obtained for decreasing values of \(\alpha\) (and a slightly more complicated object than two orthogonal discs).
We return to the enclosed object when \(\alpha=0\):

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{minsurf3D}.jpg}
\end{figure}
\end{sphinxadmonition}


\subsection{The nlOpt optimizers}
\label{\detokenize{documentation/algorithms-and-optimization:the-nlopt-optimizers}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ff\sphinxhyphen{}NLopt}} package provides a \sphinxstylestrong{FreeFEM} interface to the free/open\sphinxhyphen{}source library for nonlinear optimization, easing the use of several different free optimization (constrained or not) routines available online along with the PDE solver.
All the algorithms are well documented in \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation}, therefore no exhaustive information concerning their mathematical specificities will be found here and we will focus on the way they are used in a \sphinxstylestrong{FreeFEM} script.
If needing detailed information about these algorithms, visit the website where a description of each of them is given, as well as many bibliographical links.

\sphinxAtStartPar
Most of the gradient based algorithms of NLopt uses a full matrix approximation of the Hessian, so if you’re planning to solve a large scale problem, use the IPOPT optimizer which definitely surpass them.

\sphinxAtStartPar
All the NLopt features are identified that way:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}NLopt}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//define J, u, and maybe grad(J), some constraints etc...}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n}{nloptXXXXXX}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{c+c1}{//Unavoidable part}
   \PYG{n}{grad}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{name} \PYG{n}{of} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{J}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{p}{,} \PYG{c+c1}{//if needed}
   \PYG{n}{lb}\PYG{o}{=} \PYG{c+c1}{//Lower bounds array}
   \PYG{n}{ub}\PYG{o}{=} \PYG{c+c1}{//Upper bounds array}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{//Some optional arguments:}
   \PYG{c+c1}{//Constraints functions names,}
   \PYG{c+c1}{//Stopping criteria,}
   \PYG{c+c1}{//Algorithm specific parameters,}
   \PYG{c+c1}{//Etc...}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{XXXXXX}} refers to the algorithm tag (not necessarily 6 characters long).
\sphinxcode{\sphinxupquote{u}} is the starting position (a \sphinxcode{\sphinxupquote{real{[}int{]}}} type array) which will be overwritten by the algorithm, the value at the end being the found \(argmin\).
And as usual, \sphinxcode{\sphinxupquote{J}} is a function taking a \sphinxcode{\sphinxupquote{real{[}int{]}}} type array as argument and returning a \sphinxcode{\sphinxupquote{real}}.
\sphinxcode{\sphinxupquote{grad}}, \sphinxcode{\sphinxupquote{lb}} and \sphinxcode{\sphinxupquote{ub}} are “half\sphinxhyphen{}optional” arguments, in the sense that they are obligatory for some routines but not all.

\sphinxAtStartPar
The possible optionally named parameters are the following, note that they are not used by all algorithms (some do not support constraints, or a type of constraints, some are gradient\sphinxhyphen{}based and others are derivative free, etc…).
One can refer to the table after the parameters description to check which are the named parameters supported by a specific algorithm.
Using an unsupported parameter will not stop the compiler work, seldom breaks runtime, and will just be ignored.
When it is obvious you are missing a routine, you will get a warning message at runtime (for example if you pass a gradient to a derivative free algorithm, or set the population of a non\sphinxhyphen{}genetic one, etc…).
In the following description, \(n\) stands for the dimension of the search space.

\sphinxAtStartPar
\sphinxstylestrong{Half\sphinxhyphen{}optional parameters :}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{grad=}} The name of the function which computes the gradient of the cost function (prototype should be \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int{]}}}, both argument and result should have the size \(n\)).
This is needed as soon as a gradient\sphinxhyphen{}based method is involved, which is ignored if defined in a derivative free context.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lb}}/\sphinxcode{\sphinxupquote{ub}} = Lower and upper bounds arrays ( \sphinxcode{\sphinxupquote{real{[}int{]}}} type) of size \(n\).
Used to define the bounds within which the search variable is allowed to move.
Needed for some algorithms, optional, or unsupported for others.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{subOpt}} : Only enabled for the Augmented Lagrangian and MLSL methods who need a sub\sphinxhyphen{}optimizer in order to work.
Just pass the tag of the desired local algorithm with a \sphinxcode{\sphinxupquote{string}}.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Constraints related parameters (optional \sphinxhyphen{} unused if not specified):}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IConst}}/\sphinxcode{\sphinxupquote{EConst}} : Allows to pass the name of a function implementing some inequality (resp. equality) constraints on the search space.
The function type must be \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int{]}}} where the size of the returned array is equal to the number of constraints (of the same type \sphinxhyphen{} it means that all of the constraints are computed in one vectorial function).
In order to mix inequality and equality constraints in a same minimization attempt, two vectorial functions have to be defined and passed.
See example \eqref{equation:documentation/algorithms-and-optimization:varineqex} for more details about how these constraints have to be implemented.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gradIConst}}/\sphinxcode{\sphinxupquote{gradEConst}} : Use to provide the inequality (resp. equality) constraints gradient.
These are \sphinxcode{\sphinxupquote{real{[}int{]}}} \(\rightarrow\) \sphinxcode{\sphinxupquote{real{[}int,int{]}}} type functions.
Assuming we have defined a constraint function (either inequality or equality) with \(p\) constraints, the size of the matrix returned by its associated gradient must be \(p\times n\) (the \(i\)\sphinxhyphen{}th line of the matrix is the gradient of the \(i\)\sphinxhyphen{}th constraint).
It is needed in a gradient\sphinxhyphen{}based context as soon as an inequality or equality constraint function is passed to the optimizer and ignored in all other cases.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tolIConst}}/\sphinxcode{\sphinxupquote{tolEConst}} : Tolerance values for each constraint.
This is an array of size equal to the number of inequality (resp. equality) constraints.
Default value is set to \(10^{-12}\) for each constraint of any type.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Stopping criteria :}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopFuncValue}} : Makes the algorithm end when the objective function reaches this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopRelXTol}} : Stops the algorithm when the relative moves in each direction of the search space is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopAbsXTol}} : Stops the algorithm when the moves in each direction of the search space is smaller than the corresponding value in this \sphinxcode{\sphinxupquote{real{[}int{]}}} array.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopRelFTol}} : Stops the algorithm when the relative variation of the objective function is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopAbsFTol}} : Stops the algorithm when the variation of the objective function is smaller than this \sphinxcode{\sphinxupquote{real}} value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopMaxFEval}} : Stops the algorithm when the number of fitness evaluations reaches this \sphinxcode{\sphinxupquote{integer}} value.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stopTime}} : Stops the algorithm when the optimization time in seconds exceeds this \sphinxcode{\sphinxupquote{real}} value.
This is not a strict maximum: the time may exceed it slightly, depending upon the algorithm and on how slow your function evaluation is.

\sphinxAtStartPar
Note that when an AUGLAG or MLSL method is used, the meta\sphinxhyphen{}algorithm and the sub\sphinxhyphen{}algorithm may have different termination criteria.
Thus, for algorithms of this kind, the following named parameters has been defined (just adding the SO prefix \sphinxhyphen{} for Sub\sphinxhyphen{}Optimizer) to set the ending condition of the sub\sphinxhyphen{}algorithm (the meta one uses the ones above): \sphinxcode{\sphinxupquote{SOStopFuncValue}}, \sphinxcode{\sphinxupquote{SOStopRelXTol}}, and so on… If these are not used, the sub\sphinxhyphen{}optimizer will use those of the master routine.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Other named parameters :}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{popSize}} : \sphinxcode{\sphinxupquote{integer}} used to change the size of the sample for stochastic search methods.
Default value is a peculiar heuristic to the chosen algorithm.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SOPopSize}} : Same as above, but when the stochastic search is passed to a meta\sphinxhyphen{}algorithm.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nGradStored}} : The number (\sphinxcode{\sphinxupquote{integer}} type) of gradients to “remember” from previous optimization steps: increasing this increases the memory requirements but may speed convergence.
It is set to a heuristic value by default.
If used with AUGLAG or MLSL, it will only affect the given subsidiary algorithm.

\end{itemize}

\sphinxAtStartPar
The following table sums up the main characteristics of each algorithm, providing the more important information about which features are supported by which algorithm and what are the unavoidable arguments they need.
More details can be found in \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLopt documentation}.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[height=22cm]{{nlopttab}.png}
\end{figure}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Variational inequality

\sphinxAtStartPar
Let \(\Omega\) be a domain of \(\mathbb{R}^{2}\), \(f_{1}, f_{2}\in L^{2}(\Omega)\) and \(g_{1}, g_{2} \in L^{2}(\partial\Omega)\) four given functions with \(g_{1}\leq g_{2}\) almost everywhere.

\sphinxAtStartPar
We define the space:
\begin{equation*}
\begin{split}V = \left\lbrace (v_{1},v_{2})\in H^{1}(\Omega)^{2} ; v_{1}\vert_{\partial\Omega}=g_{1}, v_{2}\vert_{\partial\Omega}=g_{2}, v_{1}\leq v_{2}\ \mathrm{a.e.}\ \right\rbrace\end{split}
\end{equation*}
\sphinxAtStartPar
as well as the function \(J:H^{1}(\Omega)^{2}\longrightarrow \mathbb{R}\):
\begin{equation}\label{equation:documentation/algorithms-and-optimization:varineqex}
\begin{split}J(v_{1},v_{2}) = \displaystyle{\frac{1}{2}\int_{\Omega}\vert\nabla v_{1}\vert^{2} - \int_{\Omega} f_{1}v_{1} + \frac{1}{2}\int_{\Omega}\vert\nabla v_{2}\vert^{2} - \int_{\Omega} f_{2}v_{2}}\end{split}
\end{equation}
\sphinxAtStartPar
The problem consists in finding (numerically) two functions \((u_{1},u_{2}) = \underset{(v_{1},v_{2})\in V}{\operatorname{argmin}} J(v_{1},v_{2})\).

\sphinxAtStartPar
This can be interpreted as finding \(u_{1}, u_{2}\) as close as possible (in a certain sense) to the solutions of the Laplace equation with respectively \(f_{1}, f_{2}\) second members and \(g_{1}, g_{2}\) Dirichlet boundary conditions with the \(u_{1}\leq u_{2}\) almost everywhere constraint.

\sphinxAtStartPar
Here is the corresponding script to treat this variational inequality problem with one of the NLOpt algorithms.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//A brief script to demonstrate how to use the freefemm interfaced nlopt routines}
\PYG{c+c1}{//The problem consist in solving a simple variational inequality using one of the}
\PYG{c+c1}{//optimization algorithm of nlopt. We restart the algorithlm a few times after}
\PYG{c+c1}{//performing some mesh adaptation to get a more precise output}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}NLopt}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{kas} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//choose of the algorithm}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{oldu1}\PYG{p}{,} \PYG{n}{oldu2}\PYG{p}{;}

\PYG{c+c1}{// Adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
   \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

   \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
      \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
      \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
      \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{9}\PYG{p}{)}
         \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{val}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{varf} \PYG{n+nf}{dBFV} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{matrix} \PYG{n}{dA} \PYG{o}{=} \PYG{n}{dBFV}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
      \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad1} \PYG{o}{=} \PYG{n}{dA}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{grad2} \PYG{o}{=} \PYG{n}{dA}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{grad1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
      \PYG{n}{grad2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{X}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{Grad}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{grad1}\PYG{p}{;}
      \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{grad2}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{Grad}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]}\PYG{p}{;}
      \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dIneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{dconst} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
         \PYG{n}{dconst}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{dconst}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BordIndex}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Indexes of border d.f.}
   \PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Bord}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{k}{if} \PYG{p}{(}\PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{)}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{I} \PYG{o}{=} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{bc}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{bc}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{I}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{I}\PYG{p}{]}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{bc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dBC}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dbc}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{dbc} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
      \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{k+kt}{int} \PYG{n}{I} \PYG{o}{=} \PYG{n}{BordIndex}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
         \PYG{n}{dbc}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{I}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
         \PYG{n}{dbc}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nbe}\PYG{p}{,} \PYG{n}{I}\PYG{o}{+}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{return} \PYG{n}{dbc}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{up}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lo}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{al} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
      \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else}\PYG{p}{\PYGZob{}}
      \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oldu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
      \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{oldu2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{up} \PYG{o}{=} \PYG{l+m+mi}{1000000}\PYG{p}{;}
   \PYG{n}{lo} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1000000}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{up}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{lo}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{up}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+} \PYG{n}{bctol}\PYG{p}{;}
         \PYG{n}{lo}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{bctol}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
   \PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{l+m+mf}{1e100}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptAUGLAG}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lo}\PYG{p}{,}
         \PYG{n}{ub}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,} \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,}
         \PYG{n}{subOpt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LBFGS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptMMA}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lo}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{up}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptAUGLAG}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,}
         \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,} \PYG{n}{EConst}\PYG{o}{=}\PYG{n}{BC}\PYG{p}{,} \PYG{n}{gradEConst}\PYG{o}{=}\PYG{n}{dBC}\PYG{p}{,}
         \PYG{n}{subOpt}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LBFGS}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{,} \PYG{n}{stopRelXTol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}2}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{kas} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{)}
      \PYG{n}{mini} \PYG{o}{=} \PYG{n}{nloptSLSQP}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{grad}\PYG{o}{=}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{IConst}\PYG{o}{=}\PYG{n}{IneqC}\PYG{p}{,}
         \PYG{n}{gradIConst}\PYG{o}{=}\PYG{n}{dIneqC}\PYG{p}{,} \PYG{n}{EConst}\PYG{o}{=}\PYG{n}{BC}\PYG{p}{,} \PYG{n}{gradEConst}\PYG{o}{=}\PYG{n}{dBC}\PYG{p}{,}
         \PYG{n}{stopMaxFEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{,} \PYG{n}{stopAbsFTol}\PYG{o}{=}\PYG{n}{starttol}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
   \PYG{n}{best1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{start}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{oldu1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
   \PYG{n}{oldu2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Optimization with MPI}
\label{\detokenize{documentation/algorithms-and-optimization:optimization-with-mpi}}
\sphinxAtStartPar
The only quick way to use the previously presented algorithms on a parallel architecture lies in parallelizing the used cost function (which is in most real life cases, the expensive part of the algorithm).
Somehow, we provide a parallel version of the CMA\sphinxhyphen{}ES algorithm.
The parallelization principle is the trivial one of evolving/genetic algorithms: at each iteration the cost function has to be evaluated \(N\) times without any dependence at all, these \(N\) calculus are then equally distributed to each process.
Calling the MPI version of CMA\sphinxhyphen{}ES is nearly the same as calling its sequential version (a complete example of use can be found in the {\hyperref[\detokenize{examples/algorithms-and-optimizations:examplecmaesmpivariationalinequality}]{\sphinxcrossref{\DUrole{std,std-ref}{CMAES MPI variational inequality example}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mpi\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// Define J, u and all here}
\PYG{k+kt}{real} \PYG{k+kr}{min} \PYG{o}{=} \PYG{n}{cmaesMPI}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{stopTolFun}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{n}{stopMaxIter}\PYG{o}{=}\PYG{l+m+mi}{3000}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{minimum value is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ for u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the population size is not changed using the \sphinxcode{\sphinxupquote{popsize}} parameter, it will use the heuristic value slightly changed to be equal to the closest greatest multiple of the size of the communicator used by the optimizer.
The \sphinxstylestrong{FreeFEM} \sphinxcode{\sphinxupquote{mpicommworld}} is used by default.
The user can specify his own MPI communicator with the named parameter \sphinxcode{\sphinxupquote{comm=}}, see the MPI section of this manual for more information about communicators in \sphinxstylestrong{FreeFEM}.


\section{Parallelization}
\label{\detokenize{documentation/parallelization:parallelization}}\label{\detokenize{documentation/parallelization::doc}}
\sphinxAtStartPar
A first attempt of parallelization of \sphinxstylestrong{FreeFEM} is made here with \sphinxstylestrong{MPI}.
An extended interface with MPI has been added to \sphinxstylestrong{FreeFEM} version 3.5, (see the \sphinxhref{https://www.mpi-forum.org/docs/}{MPI documentation} for the functionality of the language).


\subsection{MPI}
\label{\detokenize{documentation/parallelization:mpi}}

\subsubsection{MPI Keywords}
\label{\detokenize{documentation/parallelization:mpi-keywords}}
\sphinxAtStartPar
The following keywords and concepts are used:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiComm}} to defined a \sphinxstyleemphasis{communication world}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiGroup}} to defined a group of \sphinxstyleemphasis{processors} in the communication world

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiRequest}} to defined a request to wait for the end of the communication

\end{itemize}


\subsubsection{MPI Constants}
\label{\detokenize{documentation/parallelization:mpi-constants}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpisize}} The total number of \sphinxstyleemphasis{processes},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpirank}} the id\sphinxhyphen{}number of my current process in \sphinxcode{\sphinxupquote{\{0, ..., mpisize\sphinxhyphen{}1\}}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiUndefined}} The \sphinxcode{\sphinxupquote{MPI\_Undefined}} constant,

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiAnySource}} The \sphinxcode{\sphinxupquote{MPI\_ANY\_SOURCE}} constant,

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiCommWorld}} The \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}} constant,

\item {} 
\sphinxAtStartPar
{[} … {]} and all the keywords of \sphinxcode{\sphinxupquote{MPI\_Op}} for the \sphinxstyleemphasis{reduce} operator: \sphinxcode{\sphinxupquote{mpiMAX}}, \sphinxcode{\sphinxupquote{mpiMIN}}, \sphinxcode{\sphinxupquote{mpiSUM}}, \sphinxcode{\sphinxupquote{mpiPROD}}, \sphinxcode{\sphinxupquote{mpiLAND}}, \sphinxcode{\sphinxupquote{mpiLOR}}, \sphinxcode{\sphinxupquote{mpiLXOR}}, \sphinxcode{\sphinxupquote{mpiBAND}}, \sphinxcode{\sphinxupquote{mpiBXOR}}.

\end{itemize}


\subsubsection{MPI Constructor}
\label{\detokenize{documentation/parallelization:mpi-constructor}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{proc1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{proc2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{key} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// MPI ranks}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI rank = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// MPI}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set a MPI\PYGZus{}Comm to MPI\PYGZus{}COMM\PYGZus{}WORLD}

\PYG{k+kt}{mpiGroup} \PYG{n+nf}{grp}\PYG{p}{(}\PYG{n}{proc1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set MPI\PYGZus{}Group to proc 1,2 in MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{k+kt}{mpiGroup} \PYG{n+nf}{grp1}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{proc1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set MPI\PYGZus{}Group to proc 1,2 in comm}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{ncomm1}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{n}{grp}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set the MPI\PYGZus{}Comm form grp}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{ncomm2}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{n}{key}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//MPI\PYGZus{}Comm\PYGZus{}split(MPI\PYGZus{}Comm comm, int color, int key, MPI\PYGZus{}Comm *ncomm)}

\PYG{k+kt}{mpiRequest} \PYG{n}{rq}\PYG{p}{;} \PYG{c+c1}{//defined an MPI\PYGZus{}Request}
\PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{arq}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//defined an array of 10 MPI\PYGZus{}Request}
\end{sphinxVerbatim}


\subsubsection{MPI Functions}
\label{\detokenize{documentation/parallelization:mpi-functions}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n+nf}{Comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{MPICommSize} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MPIRank} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{MPIRank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI Comm size = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{MPICommSize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPI rank in Comm = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{mpiRequest} \PYG{n}{Req}\PYG{p}{;}
\PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ReqArray}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{MPICommSize}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
     \PYG{c+c1}{//return processor i with no Resquest in MPI\PYGZus{}COMM\PYGZus{}WORLD}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor any source with no Resquest in MPI\PYGZus{}COMM\PYGZus{}WORLD}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{k+kr}{mpiAnySource}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with no Resquest in Comm}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with no Resquest in Comm}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i with Resquest rq in Comm}
    \PYG{c+cm}{/* processor(i, Req, Comm);}
\PYG{c+cm}{    //return processor i with Resquest rq in MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{c+cm}{    processor(i, Req); */}
    \PYG{c+c1}{//return processor i in MPI\PYGZus{}COMM\PYGZus{}WORLD in block mode for synchronously communication}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor any source in MPI\PYGZus{}COMM\PYGZus{}WORLD in block mode for synchronously communication}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{k+kr}{mpiAnySource}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//return processor i in in Comm in block mode}
    \PYG{n+nf}{processorblock}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{mpiBarrier}\PYG{p}{(}\PYG{n}{Comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//do a MPI\PYGZus{}Barrier on communicator Comm}
\PYG{n+nf}{mpiWaitAny}\PYG{p}{(}\PYG{n}{ReqArray}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait add of Request array,}
\PYG{n+nf}{mpiWait}\PYG{p}{(}\PYG{n}{Req}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait on a Request}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n+nf}{mpiWtime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return MPIWtime in second}
\PYG{k+kt}{real} \PYG{n}{tick} \PYG{o}{=} \PYG{n+nf}{mpiWtick}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//return MPIWTick in second}
\end{sphinxVerbatim}

\sphinxAtStartPar
where a \sphinxcode{\sphinxupquote{processor}} is just a integer rank, pointer to a \sphinxcode{\sphinxupquote{MPI\_comm}} and pointer to a \sphinxcode{\sphinxupquote{MPI\_Request}}, and \sphinxcode{\sphinxupquote{processorblock}} with a special \sphinxcode{\sphinxupquote{MPI\_Request}}.


\subsubsection{MPI Communicator operator}
\label{\detokenize{documentation/parallelization:mpi-communicator-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{status}\PYG{p}{;} \PYG{c+c1}{//to get the MPI status of send / recv}
\PYG{k+kt}{real} \PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{;}

\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiRequest} \PYG{n}{req}\PYG{p}{;}

\PYG{c+c1}{//send a,b asynchronously to the process 1}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{;}
\PYG{c+c1}{//receive a,b synchronously from the process 10}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{;}

\PYG{c+c1}{//broadcast from processor of comm to other comm processor}
\PYG{c+c1}{// broadcast(processor(10, comm), a);}
\PYG{c+c1}{//send synchronously to the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n}{Send}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//receive synchronously from the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Recv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//send asynchronously to the process 10 the data a without request}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//send asynchronously to the process 10 the data a with request}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//receive asynchronously from the process 10 the data a}
\PYG{n}{status} \PYG{o}{=} \PYG{n+nf}{Irecv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Error asynchronously without request.}
\PYG{c+c1}{// status = Irecv(processor(10), a);}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the data type of \sphinxcode{\sphinxupquote{a}} can be of type of \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{int{[}int,int{]}}}, \sphinxcode{\sphinxupquote{double{[}int,int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int,int{]}}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{mesh{[}int{]}}}, \sphinxcode{\sphinxupquote{mesh3{[}int{]}}}, \sphinxcode{\sphinxupquote{matrix}}, \sphinxcode{\sphinxupquote{matrix\textless{}complex\textgreater{}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//send asynchronously to the process 10 the data a with request}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{p}{;}
\PYG{c+c1}{//receive asynchronously from the process 10 the data a with request}
\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{req}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{a} \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{a, b}} are arrays or full matrices of \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, or \sphinxcode{\sphinxupquote{complex}}, we can use the following MPI functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{mpiAlltoall}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{n}{comm}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiAllgather}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{p}{[}\PYG{n}{comm}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiGather}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiScatter}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Thank you to Guy\sphinxhyphen{}Antoine Atenekeng Kahou for his help to code this interface.


\subsubsection{Schwarz example in parallel}
\label{\detokenize{documentation/parallelization:schwarz-example-in-parallel}}
\sphinxAtStartPar
This example is a rewritting of example {\hyperref[\detokenize{models/domain-decomposition:domaindecompositionschwarzoverlapping}]{\sphinxcrossref{\DUrole{std,std-ref}{Schwarz overlapping}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} SchwarzParallel.edp
\PYG{c+c1}{\PYGZsh{} OR}
mpirun \PYGZhy{}np \PYG{l+m}{2} FreeFem++\PYGZhy{}mpi SchwarzParallel.edp
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpisize} \PYG{o}{!}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sorry, number of processors !=2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{exit}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{interior} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{exterior} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{interior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{interior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{exterior}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Th}\PYG{p}{(}\PYG{k+kr}{mpisize}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}
    \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vhother}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhother} \PYG{n}{U} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{//Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{interior}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{exterior}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{pb}\PYG{p}{;}
    \PYG{c+c1}{//send u to the other proc, receive in U}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{U}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{k+kt}{real} \PYG{n}{err0}\PYG{p}{,} \PYG{n}{err1}\PYG{p}{;}
    \PYG{n}{err0} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{,}\PYG{n}{interior}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{U} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// send err0 to the other proc, receive in err1}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err0}\PYG{p}{;}
    \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{mpirank}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{err1}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{err0} \PYG{o}{+} \PYG{n}{err1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} err0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err0} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} err1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{err1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{\detokenize{documentation/parallelization:id1}}Todo:}
\sphinxAtStartPar
script freeze in the loop
\end{sphinxadmonition}


\paragraph{True parallel Schwarz example}
\label{\detokenize{documentation/parallelization:true-parallel-schwarz-example}}
\sphinxAtStartPar
\sphinxstyleemphasis{Thank you to F. Nataf}

\sphinxAtStartPar
This is a explanation of the two examples {\hyperref[\detokenize{examples/parallelization:examplempigmres2d}]{\sphinxcrossref{\DUrole{std,std-ref}{MPI\sphinxhyphen{}GMRES 2D}}}} and {\hyperref[\detokenize{examples/parallelization:examplempigmres3d}]{\sphinxcrossref{\DUrole{std,std-ref}{MPI\sphinxhyphen{}GMRES 3D}}}}, a Schwarz parallel with a complexity almost independent of the number of process (with a coarse grid preconditioner).

\sphinxAtStartPar
To solve the following Poisson problem on domain \(\Omega\) with boundary \(\Gamma\) in \(L^2(\Omega)\) :
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta u &=& f & \mbox{ in } \Omega\\
    u &=& g & \mbox{ on } \Gamma
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(f\) and \(g\) are two given functions of \(L^2(\Omega)\) and of \(H^{\frac12}(\Gamma)\),

\sphinxAtStartPar
Lets introduce \((\pi_i)_{i=1,.., N_p}\) a regular partition of the unity of \(\Omega\), q\sphinxhyphen{}e\sphinxhyphen{}d:
\begin{equation*}
\begin{split}\pi_i \in \mathcal{C}^0(\Omega) : \quad \pi_i\ge 0 \mbox{ and } \sum_{i=1}^{N_p} \pi_i =1 .\end{split}
\end{equation*}
\sphinxAtStartPar
Denote \(\Omega_i\) the sub domain which is the support of \(\pi_i\) function and also denote \(\Gamma_i\) the boundary of \(\Omega_i\).

\sphinxAtStartPar
The parallel Schwarz method is:

\sphinxAtStartPar
Let \(\ell=0\) the iterator and a initial guest \(u^0\) respecting the boundary condition (i.e. \(u^0_{|\Gamma} = g\)).
\begin{equation}\label{equation:documentation/parallelization:eq:lapl}
\begin{split}\begin{array}{rcll}
    \forall i = 1 .., N_p:&\nonumber\\
    \displaystyle -\Delta u_i^\ell &=& f &\mbox{ in } \Omega_i\\
    u_i^\ell &=& u^\ell & \mbox{ on } \Gamma_i \setminus \Gamma\\
    u_i^\ell &=& g & \mbox{ on } \Gamma_i \cap \Gamma
\end{array}\end{split}
\end{equation}\begin{equation}\label{equation:documentation/parallelization:eq:pu1}
\begin{split}u^{\ell+1} = \sum_{i=1}^{N_p} \pi_i u_i^\ell\end{split}
\end{equation}
\sphinxAtStartPar
After discretization with the Lagrange finite element method, with a compatible mesh \({\mathcal{T}_h}_i\) of \(\Omega_i\), i. e., the exist a global mesh \({\mathcal{T}_h}\) such that \({\mathcal{T}_h}_i\) is include in \({\mathcal{T}_h}\).

\sphinxAtStartPar
Let us denote:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\({V_h}_i\) the finite element space corresponding to domain \(\Omega_i\),

\item {} 
\sphinxAtStartPar
\({\mathcal{N}_h}_i\) is the set of the degree of freedom \(\sigma_i^k\),

\item {} 
\sphinxAtStartPar
\({\mathcal{N}^{\Gamma_i}_{hi}}\) is the set of the degree of freedom of \({V_h}_i\) on the boundary \(\Gamma_i\) of \(\Omega_i\),

\item {} 
\sphinxAtStartPar
\(\sigma_i^k({v_h})\) is the value the degree of freedom \(k\),

\item {} 
\sphinxAtStartPar
\({V_{0h}}_i= \{ {v_h} \in {V_h}_i :\forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}, \quad \sigma_i^k({v_h})=0 \}\),

\item {} 
\sphinxAtStartPar
The conditional expression \(a\;?\;b:c\) is defined like in :c\textasciigrave{}C\textasciigrave{} of \sphinxcode{\sphinxupquote{C++}} language by
\begin{equation*}
\begin{split}a?b: c \equiv
\left\{
\begin{array}{l}
\mbox{if } a \mbox{ is true then return b}\\
\mbox{else return } c\\
\end{array}
\right..\end{split}
\end{equation*}
\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We never use finite element space associated to the full domain \(\Omega\) because it is too expensive.
\end{sphinxadmonition}

\sphinxAtStartPar
We have to defined to operator to build the previous algorithm:

\sphinxAtStartPar
We denote \({u_h^{\ell}}_{|i}\) the restriction of \(u_h^\ell\) on \({V_h}_i\), so the discrete problem on \(\Omega_i\) of problem \eqref{equation:documentation/parallelization:eq:lapl} is find \({u_h^{\ell}}_{i}\in {V_h}_i\) such that:
\begin{equation*}
\begin{split}\forall {v_h}_i\in V_{0i}:
\int_{\Omega_i} \nabla {v_h}_i \cdot \nabla {u_h}^{\ell}_{i}
= \int_{\Omega_i} f {v_h}_i ,\quad \forall k \in {\mathcal{N}^{\Gamma_i}_{hi}}\;:\; \sigma_i^k({u_h}^\ell_i) = (k\in \Gamma) \; ? \; g_i^k : \sigma_i^k({u_h}^{\ell}_{|i})\end{split}
\end{equation*}
\sphinxAtStartPar
where \(g_i^k\) is the value of \(g\) associated to the degree of freedom \(k\in {\mathcal{N}^{\Gamma_i}_{hi}}\).

\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM}, it can be written has with \sphinxcode{\sphinxupquote{U}} is the vector corresponding to \({u_h^{\ell}}_{|i}\) and the vector \sphinxcode{\sphinxupquote{U1}} is the vector corresponding to \({u_h^{\ell}}_{i}\) is the solution of:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{U1}\PYG{p}{(}\PYG{n}{Ui}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
\PYG{n}{U1} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \(\mathtt{onG}[i] =(i \in \Gamma_i\setminus\Gamma) ? 1 : 0\), and \(\mathtt{Bi}\) the right of side of the problem, are defined by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{F}\PYG{o}{*}\PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vPbon} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Ai} \PYG{o}{=} \PYG{n}{vPb} \PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG} \PYG{o}{=} \PYG{n}{vPbon}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bi}\PYG{o}{=}\PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the \sphinxstylestrong{FreeFEM} label of \(\Gamma\) is 1 and the label of \(\Gamma_i\setminus \Gamma\) is \(10\).

\sphinxAtStartPar
To build the transfer/update part corresponding to \eqref{equation:documentation/parallelization:eq:pu1} equation on process \(i\), let us call \sphinxcode{\sphinxupquote{njpart}} the number the neighborhood of domain of \(\Omega_i\) (i.e: \(\pi_j\) is none \(0\) of \(\Omega_i\)), we store in an array \sphinxcode{\sphinxupquote{jpart}} of size \sphinxcode{\sphinxupquote{njpart}} all this neighborhood.

\sphinxAtStartPar
Let us introduce two array of matrix, \sphinxcode{\sphinxupquote{Smj{[}j{]}}} to defined the vector to send from \(i\) to \(j\) a neighborhood process, and the matrix \(rMj[j]\) to after to reduce owith neighborhood \(j\) domain.

\sphinxAtStartPar
So the tranfert and update part compute \(v_i= \pi_i u_i + \sum_{j\in J_i} \pi_j u_j\) and can be write the \sphinxstylestrong{FreeFEM} function Update:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{Update} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ui}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{vi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{Usend}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{k+kt}{mpiRequest}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rq}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n+nf}{Irecv}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,}\PYG{n}{rq}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Ri}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n+nf}{Isend}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{rq}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{k+kr}{n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Si}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{mpiWaitAny}\PYG{p}{(}\PYG{n}{rq}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// apply the unity local partition}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n}{Pii}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;} \PYG{c+c1}{//set to pi\PYGZus{}i u\PYGZus{}i}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)} \PYG{n}{vi} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Vrecv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//add pi\PYGZus{}j u\PYGZus{}j}
    \PYG{k}{return} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the buffer are defined by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{)} \PYG{c+c1}{//defined the send buffer}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)} \PYG{c+c1}{//defined the revc buffer}
\end{sphinxVerbatim}

\sphinxAtStartPar
with the following macro definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{InitU}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{aTh}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)} \PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{U}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{n}{Th} \PYG{o}{=} \PYG{n}{aTh}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;} \PYG{n}{U}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{First GMRES algorithm:} you can easily accelerate the fixed point algorithm by using a parallel GMRES algorithm after the introduction the following affine \(\mathcal{A}_i\) operator sub domain \(\Omega_i\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{U}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Where the parallel \sphinxcode{\sphinxupquote{MPIGMRES}} or \sphinxcode{\sphinxupquote{MPICG}} algorithm is just a simple way to solve in parallel the following \(A_i x_i = b_i, i = 1, .., N_p\) by just changing the dot product by reduce the local dot product of all process with the following MPI code:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{R}\PYG{o}{\PYGZgt{}} \PYG{n}{R} \PYG{n}{ReduceSum1}\PYG{p}{(}\PYG{n}{R} \PYG{n}{s}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}Comm} \PYG{o}{*}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{R} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{MPI\PYGZus{}Allreduce}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{s}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{r}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}TYPE}\PYG{o}{\PYGZlt{}}\PYG{n}{R}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{TYPE}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{MPI\PYGZus{}SUM}\PYG{p}{,} \PYG{o}{*}\PYG{n}{comm} \PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is done in \sphinxcode{\sphinxupquote{MPIGC}} dynamics library tool.

\sphinxAtStartPar
\sphinxstyleemphasis{Second GMRES algorithm:} Use scharwz algorithm as a preconditioner of basic GMRES method to solving the parallel problem.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//the original problem}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{onGi} \PYG{o}{?} \PYG{l+m+mf}{0.}\PYG{o}{:} \PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//remove boundary term}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//the preconditioner}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Third GMRES algorithm:} Add a coarse solver to the previous algorithm

\sphinxAtStartPar
First build a coarse grid on processor 0, and the

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{AC}\PYG{p}{,} \PYG{n}{Rci}\PYG{p}{,} \PYG{n}{Pci}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{AC} \PYG{o}{=} \PYG{n}{vPbC}\PYG{p}{(}\PYG{n}{VhC}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the coarse problem}

\PYG{n}{Pci} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the projection on coarse grid}
\PYG{n}{Rci} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//the restriction on Process i grid with the partition pi\PYGZus{}i}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{CoarseSolve} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{V}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{,} \PYG{k+kt}{mpiComm}\PYG{o}{\PYGZam{}} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// solving the coarse problem}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uc}\PYG{p}{(}\PYG{n}{Rci}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{Rci}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiSUM}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{AC}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{Bc}\PYG{p}{;}
    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Uc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{*}\PYG{n}{Uc}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The New preconditionner

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Idea: F. Nataf.}
    \PYG{c+c1}{// 0 \PYGZti{} (I C1A)(I\PYGZhy{}C2A) =\PYGZgt{} I \PYGZti{} \PYGZhy{} C1AC2A +C1A +C2A}
    \PYG{c+c1}{// New Prec P= C1+C2 \PYGZhy{} C1AC2 = C1(I\PYGZhy{} A C2) +C2}
    \PYG{c+c1}{// ( C1(I\PYGZhy{} A C2) +C2 ) Uo}
    \PYG{c+c1}{// V = \PYGZhy{} C2*Uo}
    \PYG{c+c1}{// ....}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CoarseSolve}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}C2*Uo}
    \PYG{n}{U} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//U = (I\PYGZhy{}A C2) Uo}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{U} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//C1( I \PYGZhy{}A C2) Uo}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{U} \PYG{o}{\PYGZhy{}} \PYG{n}{V}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The code of the 4 algorithms:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{epss} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rgmres} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPIAffineGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,}
        \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,}
        \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJC}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,}
        \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart}\PYG{o}{?}\PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{c+c1}{//algo Shwarz for demo}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have all ingredient to solve in parallel if we have et the partitions of the unity.
To build this partition we do:

\sphinxAtStartPar
The initial step on process \(1\) to build a coarse mesh, \({\mathcal{T}_h}^*\) of the full domain, and build the partition \(\pi\) function constant equal to \(i\) on each sub domain \(\mathcal{O}_i, i =1 ,.., N_p\), of the grid with the \sphinxcode{\sphinxupquote{metis}} graph partitioner \sphinxcite{bibliography:karypis1995} and on each process \(i\) in \(1..,N_p\) do
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Broadcast from process \(1\), the mesh \({\mathcal{T}_h}^*\) (call \sphinxcode{\sphinxupquote{Thii}} in \sphinxstylestrong{FreeFEM} script), and \(\pi\) function,

\item {} 
\sphinxAtStartPar
remark that the characteristic function \(\mathrm{1\!\!I}_{\mathcal{O}_i}\) of domain \(\mathcal{O}_i\), is defined by \((\pi=i)?1:0\),

\item {} 
\sphinxAtStartPar
Let us call \(\Pi^2_P\) (resp. \(\Pi^2_V\)) the \(L^2\) on \(P_h^*\) the space of the constant finite element function per element on \({\mathcal{T}_h}^*\) (resp. \(V_h^*\) the space of the affine continuous finite element per element on \({\mathcal{T}_h}^*\)) and build in parallel the \(\pi_i\) and \(\Omega_i\), such that \(\mathcal{O}_i\ \subset \Omega_i\) where \(\mathcal{O}_i= supp ((\Pi^2_V \Pi^2_C)^m \mathrm{1\!\!I}_{O_i})\), and \(m\) is a the overlaps size on the coarse mesh (generally one), (this is done in function \sphinxcode{\sphinxupquote{AddLayers(Thii,suppii{[}{]},nlayer,phii{[}{]});}} We choose a function \(\pi^*_i = (\Pi^2_1 \Pi^2_0)^m \mathrm{1\!\!I}_{\mathcal{O}_i}\) so the partition of the unity is simply defined by
\begin{quote}
\begin{equation*}
\begin{split}\pi_i = \frac{\pi_i^*}{\sum_{j=1}^{N_p} \pi_j^*}\end{split}
\end{equation*}
\sphinxAtStartPar
The set \(J_i\) of neighborhood of the domain \(\Omega_i\), and the local version on \(V_{hi}\) can be defined the array \sphinxcode{\sphinxupquote{jpart}} and \sphinxcode{\sphinxupquote{njpart}} with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vhi} \PYG{n}{pii} \PYG{o}{=} \PYG{n}{piistar}\PYG{p}{;}
\PYG{n}{Vhi}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pij}\PYG{p}{(}\PYG{n}{npij}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local partition of 1 = pii + sum\PYGZus{}j pij[j]}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{jpart}\PYG{p}{(}\PYG{n}{npart}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vhi} \PYG{n}{sumphi} \PYG{o}{=} \PYG{n}{piistar}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{npart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ipart}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{pijstar}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pijstar}\PYG{p}{;}
            \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{njpart}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{jpart}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
We call \({\mathcal{T}_h}^*_{ij}\) the sub mesh part of \({\mathcal{T}_h}_i\) where \(\pi_j\) are none zero.
And thanks to the function \sphinxcode{\sphinxupquote{trunc}} to build this array,
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
At this step we have all on the coarse mesh, so we can build the fine final mesh by splitting all meshes: \sphinxcode{\sphinxupquote{Thi, Thij{[}j{]}, Thij{[}j{]}}} with \sphinxstylestrong{FreeFEM} \sphinxcode{\sphinxupquote{trunc}} mesh function which do restriction and slipping.

\item {} 
\sphinxAtStartPar
The construction of the send/recv matrices \sphinxcode{\sphinxupquote{sMj}} and \sphinxtitleref{freefem:\textasciigrave{}rMj}: can done with this code:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{Thi}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whij}\PYG{p}{(}\PYG{n}{Thij}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Pii}\PYG{p}{;} \PYG{n}{Whi} \PYG{n}{wpii} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{;} \PYG{n}{Pii} \PYG{o}{=} \PYG{n}{wpii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//Diagonal matrix corresponding X pi\PYGZus{}i}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M send/recive case}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//change mesh to change Whij, Whij}
    \PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whij \PYGZlt{}\PYGZhy{} Whi}
    \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n}{I}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//Whi \PYGZhy{}\PYGZgt{} s Whij}
    \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whij \PYGZhy{}\PYGZgt{} Whi}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

\end{enumerate}

\sphinxAtStartPar
To buil a not too bad application, all variables come from parameters value with the following code

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{vdebug} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ksplit} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nloc} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sff} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}p, }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{gmres} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}gmres}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{dplot} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nC} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}N}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nloc}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
And small include to make graphic in parallel of distribute solution of vector \(u\) on mesh \(T_h\) with the following interface:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIplot.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{k+kt}{mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{cm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{PLOTMPIALL}\PYG{p}{(}\PYG{k+kt}{mesh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{cm}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{cmm=cm, ...}} in the macro argument is a way to quote macro argument so the argument is \sphinxcode{\sphinxupquote{cmm=cm, ...}}.
\end{sphinxadmonition}


\subsection{Parallel sparse solvers}
\label{\detokenize{documentation/parallelization:parallel-sparse-solvers}}\label{\detokenize{documentation/parallelization:parallelsparsesolvers}}
\sphinxAtStartPar
Parallel sparse solvers use several processors to solve linear systems of equation. Like sequential, parallel linear solvers can be direct or iterative. In \sphinxstylestrong{FreeFEM} both are available.


\subsubsection{Using parallel sparse solvers in \sphinxstylestrong{FreeFEM}}
\label{\detokenize{documentation/parallelization:using-parallel-sparse-solvers-in-freefem}}
\sphinxAtStartPar
We recall that the \sphinxcode{\sphinxupquote{solver}} parameters are defined in the following commands: \sphinxcode{\sphinxupquote{solve}}, \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{set}} (setting parameter of a matrix) and in the construction of the matrix corresponding to a bilinear form.
In these commands, the parameter \sphinxcode{\sphinxupquote{solver}} must be set to \sphinxcode{\sphinxupquote{sparsesolver}} for parallel sparse solver.
We have added specify parameters to these command lines for parallel sparse solvers.
These are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lparams}} : vector of integer parameters (\sphinxcode{\sphinxupquote{l}} is for the \sphinxcode{\sphinxupquote{C++}} type \sphinxcode{\sphinxupquote{long}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparams}} : vector of real parameters

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sparams}} : string parameters

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{datafilename}} : name of the file which contains solver parameters

\end{itemize}

\sphinxAtStartPar
The following four parameters are only for direct solvers and are vectors.
These parameters allow the user to preprocess the matrix (see the section on {\hyperref[\detokenize{documentation/parallelization:sparse-direct-solver}]{\emph{sparse direct solver}}} for more information).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{permr}} : row permutation (integer vector)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{permc}} : column permutation or inverse row permutation (integer vector)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scaler}} : row scaling (real vector)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scalec}} : column scaling (real vector)

\end{itemize}

\sphinxAtStartPar
There are two possibilities to control solver parameters.
The first method defines parameters with \sphinxcode{\sphinxupquote{lparams}}, \sphinxcode{\sphinxupquote{dparams}} and \sphinxcode{\sphinxupquote{sparams}} in \sphinxcode{\sphinxupquote{.edp}} file.

\sphinxAtStartPar
The second one reads the solver parameters from a data file. The name of this file is specified by \sphinxcode{\sphinxupquote{datafilename}}.
If \sphinxcode{\sphinxupquote{lparams}}, \sphinxcode{\sphinxupquote{dparams}}, \sphinxcode{\sphinxupquote{sparams}} or \sphinxcode{\sphinxupquote{datafilename}} is not provided by the user, the solver’s default values are used.

\sphinxAtStartPar
To use parallel solver in \sphinxstylestrong{FreeFEM}, we need to load the dynamic library corresponding to this solver.
For example to use \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS} solver as parallel solver in \sphinxstylestrong{FreeFEM}, write in the \sphinxcode{\sphinxupquote{.edp}} file \sphinxcode{\sphinxupquote{load "MUMPS\_FreeFem"}}.

\sphinxAtStartPar
If the libraries are not loaded, the default sparse solver will be loaded (default sparse solver is \sphinxcode{\sphinxupquote{UMFPACK}}). The \hyperref[\detokenize{documentation/parallelization:tabparallelizationsparsesolver}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationsparsesolver}}} gives this new value for the different libraries.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Default sparse solver for real and complex arithmetics when we load a parallel sparse solver library}\label{\detokenize{documentation/parallelization:tabparallelizationsparsesolver}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Libraries
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily \sphinxAtStartPar
Default sparse solver
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
real
&\sphinxstyletheadfamily 
\sphinxAtStartPar
complex
\\
\hline
\sphinxAtStartPar
MUMPS\_FreeFem
&
\sphinxAtStartPar
mumps
&
\sphinxAtStartPar
mumps
\\
\hline
\sphinxAtStartPar
real\_SuperLU\_DIST\_FreeFem
&
\sphinxAtStartPar
SuperLU\_DIST
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
complex\_SuperLU\_DIST\_FreeFem
&
\sphinxAtStartPar
previous solver
&
\sphinxAtStartPar
SuperLU\_DIST
\\
\hline
\sphinxAtStartPar
real\_pastix\_FreeFem
&
\sphinxAtStartPar
PaStiX
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
complex\_pastix\_FreeFem
&
\sphinxAtStartPar
previous solver
&
\sphinxAtStartPar
PaStiX
\\
\hline
\sphinxAtStartPar
hips\_FreeFem
&
\sphinxAtStartPar
hips
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
hypre\_FreeFem
&
\sphinxAtStartPar
hypre
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
parms\_FreeFem
&
\sphinxAtStartPar
parms
&
\sphinxAtStartPar
previous solver
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
We also add functions (see \hyperref[\detokenize{documentation/parallelization:tabparallelizationfunction}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationfunction}}}) with no parameter to change the default sparse solver in the \sphinxcode{\sphinxupquote{.edp}} file.
To use these functions, we need to load the library corresponding to the solver.
An example of using different parallel sparse solvers for the same problem is given in {\hyperref[\detokenize{examples/parallelization:exampledirectsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Direct solvers example}}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Functions that allow to change the default sparse solver for real and complex arithmetics and the result of these functions}\label{\detokenize{documentation/parallelization:tabparallelizationfunction}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Function
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{3}}
\sphinxstyletheadfamily \sphinxAtStartPar
default sparse solver
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
real
&\sphinxstyletheadfamily 
\sphinxAtStartPar
complex
\\
\hline
\sphinxAtStartPar
defaulttoMUMPS()
&
\sphinxAtStartPar
mumps
&
\sphinxAtStartPar
mumps
\\
\hline
\sphinxAtStartPar
realdefaulttoSuperLUdist()
&
\sphinxAtStartPar
SuperLU\_DIST
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
complexdefaulttoSuperLUdist()
&
\sphinxAtStartPar
previous solver
&
\sphinxAtStartPar
SuperLU\_DIST
\\
\hline
\sphinxAtStartPar
realdefaultopastix()
&
\sphinxAtStartPar
pastix
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
complexdefaulttopastix()
&
\sphinxAtStartPar
previous solver
&
\sphinxAtStartPar
pastix
\\
\hline
\sphinxAtStartPar
defaulttohips()
&
\sphinxAtStartPar
hips
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
defaulttohypre()
&
\sphinxAtStartPar
hypre
&
\sphinxAtStartPar
previous solver
\\
\hline
\sphinxAtStartPar
defaulttoparms()
&
\sphinxAtStartPar
parms
&
\sphinxAtStartPar
previous solver
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Test direct solvers

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}SuperLU\PYGZus{}DIST\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST,}
\PYG{k+kt}{complex} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{MUMPS} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}pastix\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} pastix, complex \PYGZhy{}\PYGZgt{} MUMPS}

\PYG{c+c1}{// Solving with pastix}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffpastix\PYGZus{}iparm\PYGZus{}dparm.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with SuperLU\PYGZus{}DIST}
\PYG{n}{realdefaulttoSuperLUdist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffsuperlu\PYGZus{}dist\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with MUMPS}
\PYG{n}{defaulttoMUMPS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solving solution}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Sparse direct solver}
\label{\detokenize{documentation/parallelization:sparse-direct-solver}}
\sphinxAtStartPar
In this section, we present the sparse direct solvers interfaced with \sphinxstylestrong{FreeFEM}.


\paragraph{MUMPS solver}
\label{\detokenize{documentation/parallelization:mumps-solver}}
\sphinxAtStartPar
MUltifrontal Massively Parallel Solver (\sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}) is an open\sphinxhyphen{}source library.

\sphinxAtStartPar
This package solves linear system of the form \(A \: x = b\) where \(A\) is a square sparse matrix with a direct method.
The square matrix considered in MUMPS can be either unsymmetric, symmetric positive definite or general symmetric.

\sphinxAtStartPar
The method implemented in MUMPS is a direct method based on a multifrontal approach.
It constructs a direct factorization \(A \:= \: L\:U\), \(A\: = \: L^t \: D \: L\) depending of the symmetry of the matrix \(A\).
\begin{description}
\item[{MUMPS uses the following libraries :}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.netlib.org/blas/}{BLAS},

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.netlib.org/blacs/}{BLACS},

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.netlib.org/scalapack/}{ScaLAPACK}.

\end{itemize}

\end{description}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
MUMPS does not solve linear system with a rectangular matrix.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{MUMPS parameters:}

\sphinxAtStartPar
There are four input parameters in \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS}.
Two integers \sphinxcode{\sphinxupquote{SYM}} and \sphinxcode{\sphinxupquote{PAR}}, a vector of integer of size 40 \sphinxcode{\sphinxupquote{INCTL}} and a vector of real of size 15 \sphinxcode{\sphinxupquote{CNTL}}.

\sphinxAtStartPar
The first parameter gives the type of the matrix: 0 for unsymmetric matrix, 1 for symmetric positive matrix and 2 for general symmetric.

\sphinxAtStartPar
The second parameter defined if the host processor work during the factorization and solves steps : \sphinxcode{\sphinxupquote{PAR=1}} host processor working and \sphinxcode{\sphinxupquote{PAR=0}} host processor not working.

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{INCTL}} and \sphinxcode{\sphinxupquote{CNTL}} is the control parameter of MUMPS.
The vectors \sphinxcode{\sphinxupquote{ICNTL}} and \sphinxcode{\sphinxupquote{CNTL}} in MUMPS becomes with index 1 like vector in \sphinxcode{\sphinxupquote{Fortran}}.
For more details see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide}.

\sphinxAtStartPar
We describe now some elements of the main parameters of \sphinxcode{\sphinxupquote{ICNTL}} for MUMPS.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{Input matrix parameter} The input matrix is controlled by parameters \sphinxcode{\sphinxupquote{ICNTL(5)}} and \sphinxcode{\sphinxupquote{ICNTL(18)}}.}] \leavevmode
\sphinxAtStartPar
The matrix format (resp. matrix pattern and matrix entries) are controlled by \sphinxcode{\sphinxupquote{INCTL(5)}} (resp. \sphinxcode{\sphinxupquote{INCTL(18)}}).

\sphinxAtStartPar
The different values of \sphinxcode{\sphinxupquote{ICNTL(5)}} are 0 for assembled format and 1 for element format.
In the current release of \sphinxstylestrong{FreeFEM}, we consider that FE matrix or matrix is storage in assembled format.
Therefore, \sphinxcode{\sphinxupquote{INCTL(5)}} is treated as 0 value.

\sphinxAtStartPar
The main option for \sphinxcode{\sphinxupquote{ICNTL(18)}}: \sphinxcode{\sphinxupquote{INCLTL(18)=0}} centrally on the host processor, \sphinxcode{\sphinxupquote{ICNTL(18)=3}} distributed the input matrix pattern and the entries (recommended option for distributed matrix by developer of MUMPS).
For other values of \sphinxcode{\sphinxupquote{ICNTL(18)}} see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide}.
These values can be used also in \sphinxstylestrong{FreeFEM}.

\sphinxAtStartPar
The default option implemented in \sphinxstylestrong{FreeFEM} are \sphinxcode{\sphinxupquote{ICNTL(5)=0}} and \sphinxcode{\sphinxupquote{ICNTL(18)=0}}.

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Preprocessing parameter} The preprocessed matrix \(A_{p}\) that will be effectively factored is defined by
\begin{quote}
\begin{equation*}
\begin{split}A_{p} = P \: D_r \: A \: Q_c \ D_c P^t\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P\) is the permutation matrix, \(Q_c\) is the column permutation, \(D_r\) and \(D_c\) are diagonal matrix for respectively row and column scaling.

\sphinxAtStartPar
The ordering strategy to obtain \(P\) is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(7)}}.
The permutation of zero free diagonal \(Q_c\) is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(6)}}.
The row and column scaling is controlled by parameter \sphinxcode{\sphinxupquote{ICNTL(18)}}.
These option are connected and also strongly related with \sphinxcode{\sphinxupquote{ICNTL(12)}} (see the \sphinxhref{http://mumps.enseeiht.fr/index.php?page=doc}{MUMPS user’s guide} for more details).

\sphinxAtStartPar
The parameters \sphinxcode{\sphinxupquote{permr}}, \sphinxcode{\sphinxupquote{scaler}}, and \sphinxcode{\sphinxupquote{scalec}} in \sphinxstylestrong{FreeFEM} allow to give permutation matrix(\(P\)), row scaling (\(D_r\)) and column scaling (\(D_c\)) of the user respectively.
\end{quote}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Calling MUMPS in FreeFEM}

\sphinxAtStartPar
To call MUMPS in \sphinxstylestrong{FreeFEM}, we need to load the dynamic library \sphinxcode{\sphinxupquote{MUMPS\_freefem.dylib}} (MacOSX), \sphinxcode{\sphinxupquote{MUMPS\_freefem.so}} (Unix) or \sphinxcode{\sphinxupquote{MUMPS\_freefem.dll}} (Windows).

\sphinxAtStartPar
This is done in typing \sphinxcode{\sphinxupquote{load "MUMPS\_FreeFem"}} in the \sphinxcode{\sphinxupquote{.edp}} file. We give now the two methods to give the option of MUMPS solver in \sphinxstylestrong{FreeFEM}.
\begin{itemize}
\item {} \begin{description}
\item[{\sphinxstylestrong{Solver parameters is defined in .edp file:} In this method, we need to give the parameters \sphinxcode{\sphinxupquote{lparams}} and \sphinxcode{\sphinxupquote{dparams}}.}] \leavevmode
\sphinxAtStartPar
These parameters are defined for MUMPS by :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lparams{[}0{]} = SYM}}, \sphinxcode{\sphinxupquote{lparams{[}1{]} = PAR}},

\item {} 
\sphinxAtStartPar
\(\forall i\) = 1,…,40, \sphinxcode{\sphinxupquote{lparams{[}i+1{]} = ICNTL(i)}}

\item {} 
\sphinxAtStartPar
\(\forall i\) = 1,…,15, \sphinxcode{\sphinxupquote{dparams{[}i\sphinxhyphen{}1{]} = CNTL(i)}}

\end{itemize}

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Reading solver parameters on a file:}
\begin{quote}

\sphinxAtStartPar
The structure of data file for MUMPS in \sphinxstylestrong{FreeFEM} is : first line parameter \sphinxcode{\sphinxupquote{SYM}} and second line parameter \sphinxcode{\sphinxupquote{PAR}} and in the following line the different value of vectors \sphinxcode{\sphinxupquote{ICNTL}} and \sphinxcode{\sphinxupquote{CNTL}}.
An example of this parameter file is given in \sphinxcode{\sphinxupquote{ffmumpsfileparam.txt}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{0} \PYG{c+cm}{/* SYM :: 0 for non symmetric matrix, 1 for symmetric definite positive matrix and 2 general symmetric matrix*/}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* PAR :: 0 host not working during factorization and solves steps, 1 host working during factorization and solves steps*/}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(1) :: output stream for error message */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(2) :: output for diagnostic printing, statics and warning message */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(3) :: for global information */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(4) :: Level of printing for error, warning and diagnostic message */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(5) :: matrix format : 0 assembled format, 1 elemental format. */}
\PYG{l+m+mi}{7} \PYG{c+cm}{/* ICNTL(6) :: control option for permuting and/or scaling the matrix in analysis phase */}
\PYG{l+m+mi}{3} \PYG{c+cm}{/* ICNTL(7) :: pivot order strategy : AMD, AMF, metis, pord scotch*/}
\PYG{l+m+mi}{77} \PYG{c+cm}{/* ICNTL(8) :: Row and Column scaling strategy */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(9) :: 0 solve Ax = b, 1 solve the transposed system A\PYGZca{}t x = b : parameter is not considered in the current release of FreeFEM*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(10) :: number of steps of iterative refinement */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(11) :: statics related to linear system depending on ICNTL(9) */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(12) :: constrained ordering strategy for general symmetric matrix */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(13) :: method to control splitting of the root frontal matrix */}
\PYG{l+m+mi}{20} \PYG{c+cm}{/* ICNTL(14) :: percentage increase in the estimated working space (default 20\PYGZbs{}\PYGZpc{})*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(15) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(16) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(17) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{3} \PYG{c+cm}{/* ICNTL(18) :: method for given : matrix pattern and matrix entries : */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(19) :: method to return the Schur complement matrix */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(20) :: right hand side form ( 0 dense form, 1 sparse form) : parameter will be set to 0 for FreeFEM */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(21) :: 0, 1 kept distributed solution : parameter is not considered in the current release of FreeFEM */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(22) :: controls the in\PYGZhy{}core/out\PYGZhy{}of\PYGZhy{}core (OOC) facility */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(23) :: maximum size of the working memory in Megabyte than MUMPS can allocate per working processor */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(24) :: control the detection of null pivot */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(25) :: control the computation of a null space basis */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(26) :: This parameter is only significant with Schur option (ICNTL(19) not zero). : parameter is not considered in the current release of FreeFEM */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{c+cm}{/* ICNTL(27) (Experimental parameter subject to change in next release of MUMPS) :: control the blocking factor for multiple righthand side during the solution phase : parameter is not considered in the current release of FreeFEM */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(28) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(29) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(30) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(31) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(32) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(33) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(34) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(35) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(36) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(37) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(38) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* ICNTL(39) :: not used in this release of MUMPS*/}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* ICNTL(40) :: not used in this release of MUMPS*/}
\PYG{l+m+mf}{0.01} \PYG{c+cm}{/* CNTL(1) :: relative threshold for numerical pivoting */}
\PYG{l+m+mf}{1e\PYGZhy{}8} \PYG{c+cm}{/* CNTL(2) :: stopping criteria for iterative refinement */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* CNTL(3) :: threshold for null pivot detection */}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{c+cm}{/* CNTL(4) :: determine the threshold for partial pivoting */}
\PYG{l+m+mf}{0.0} \PYG{c+cm}{/* CNTL(5) :: fixation for null pivots */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(6) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(7) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(8) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(9) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(10) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(11) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(12) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(13) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(14) :: not used in this release of MUMPS */}
\PYG{l+m+mi}{0} \PYG{c+cm}{/* CNTL(15) :: not used in this release of MUMPS */}
\end{sphinxVerbatim}

\sphinxAtStartPar
If no solver parameter is given, we used default option of MUMPS solver.
\end{quote}

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
MUMPS example

\sphinxAtStartPar
A simple example of calling MUMPS in \sphinxstylestrong{FreeFEM} with this two methods is given in the {\hyperref[\detokenize{examples/parallelization:examplesolvermumps}]{\sphinxcrossref{\DUrole{std,std-ref}{Test solver MUMPS example}}}}.
\end{sphinxadmonition}


\paragraph{SuperLU distributed solver}
\label{\detokenize{documentation/parallelization:superlu-distributed-solver}}
\sphinxAtStartPar
The package \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU\_DIST} solves linear systems using LU factorization.
It is a free scientific library

\sphinxAtStartPar
This library provides functions to handle square or rectangular matrix in real and complex arithmetics.
The method implemented in SuperLU\_DIST is a supernodal method.
New release of this package includes a parallel symbolic factorization.
This scientific library is written in C and MPI for communications.

\sphinxAtStartPar
\sphinxstylestrong{SuperLU\_DIST parameters:}

\sphinxAtStartPar
We describe now some parameters of SuperLU\_DIST.
The SuperLU\_DIST library use a 2D\sphinxhyphen{}logical process group.
This process grid is specified by \(nprow\) (process row) and \(npcol\) (process column) such that \(N_{p} = nprow \: npcol\) where \(N_{p}\) is the number of all process allocated for SuperLU\_DIST.

\sphinxAtStartPar
The input matrix parameters is controlled by “matrix=” in \sphinxcode{\sphinxupquote{sparams}} for internal parameter or in the third line of parameters file.
The different value are
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix=assembled}} global matrix are available on all process

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix=distributedglobal}} The global matrix is distributed among all the process

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix=distributed}} The input matrix is distributed (not yet implemented)

\end{itemize}

\sphinxAtStartPar
The option arguments of SuperLU\_DIST are described in the section Users\sphinxhyphen{}callable routine of the \sphinxhref{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/ug.pdf}{SuperLU users’ guide}.

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{Fact}} and \sphinxcode{\sphinxupquote{TRANS}} are specified in \sphinxstylestrong{FreeFEM} interfaces to SuperLU\_DIST during the different steps.
For this reason, the value given by the user for this option is not considered.

\sphinxAtStartPar
The factorization LU is calculated in SuperLU\_DIST on the matrix \(A_p\).
\begin{equation*}
\begin{split}A_{p} = P_{c} \: P_r \: D_r \: A \: D_{c} \: P_{c}^{t}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(P_c\) and \(P_r\) is the row and column permutation matrix respectively, \(D_r\) and \(D_c\) are diagonal matrix for respectively row and column scaling.

\sphinxAtStartPar
The option argument \sphinxcode{\sphinxupquote{RowPerm}} (resp. \sphinxcode{\sphinxupquote{ColPerm}}) control the row (resp. column) permutation matrix.
\(D_r\) and \(D_c\) is controlled by the parameter \sphinxcode{\sphinxupquote{DiagScale}}.

\sphinxAtStartPar
The parameter \sphinxcode{\sphinxupquote{permr}}, \sphinxcode{\sphinxupquote{permc}}, \sphinxcode{\sphinxupquote{scaler}}, and \sphinxcode{\sphinxupquote{scalec}} in \sphinxstylestrong{FreeFEM} is provided to give row permutation, column permutation, row scaling and column scaling of the user respectively.

\sphinxAtStartPar
The other parameters for LU factorization are \sphinxcode{\sphinxupquote{ParSymFact}} and \sphinxcode{\sphinxupquote{ReplaceTinyPivot}}.
The parallel symbolic factorization works only on a power of two processes and need the \sphinxcode{\sphinxupquote{ParMetis}} ordering.
The default option argument of SuperLU\_DIST are given in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}}.

\sphinxAtStartPar
\sphinxstylestrong{Calling SuperLU\_DIST in FreeFEM}

\sphinxAtStartPar
To call SuperLU\_DIST in \sphinxstylestrong{FreeFEM}, we need to load the library dynamic correspond to interface.
This done by the following line \sphinxcode{\sphinxupquote{load "real\_superlu \_DIST\_FreeFem"}} (resp. \sphinxcode{\sphinxupquote{load "complex\_superlu\_DIST\_FreeFem"}}) for real (resp. complex) arithmetics in the file \sphinxcode{\sphinxupquote{.edp}}.

\sphinxAtStartPar
\sphinxstylestrong{Solver parameters is defined in .edp file:}

\sphinxAtStartPar
To call SuperLU\_DIST with internal parameter, we used the parameters \sphinxcode{\sphinxupquote{sparams}}.
The value of parameters of SuperLU\_DIST in \sphinxcode{\sphinxupquote{sparams}} are defined by :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nprow=1}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{npcol=1}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix= distributedgloba}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Fact= DOFACT}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Equil=NO}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ParSymbFact=NO}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ColPerm= MMD\_AT\_PLUS\_A}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RowPerm= LargeDiag}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagPivotThresh=1.0}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IterRefine=DOUBLE}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Trans=NOTRANS}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ReplaceTinyPivot=NO}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{SolveInitialized=NO}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{PrintStat=NO}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{DiagScale=NOEQUIL}}

\end{itemize}

\sphinxAtStartPar
This value correspond to the parameter in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}}.
If one parameter is not specified by the user, we take the default value of SuperLU\_DIST.

\sphinxAtStartPar
\sphinxstylestrong{Reading solver parameters on a file:} The structure of data file for SuperLU\_DIST in \sphinxstylestrong{FreeFEM} is given in the file \sphinxcode{\sphinxupquote{ffsuperlu\_dist\_fileparam.txt}} (default value of the \sphinxstylestrong{FreeFEM} interface).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{1} \PYG{c+cm}{/* nprow : integer value */}
\PYG{l+m+mi}{1} \PYG{c+cm}{/* npcol : integer value */}
\PYG{n}{distributedglobal} \PYG{c+cm}{/* matrix input : assembled, distributedglobal, distributed */}
\PYG{n}{DOFACT} \PYG{c+cm}{/* Fact : DOFACT, SamePattern, SamePattern\PYGZus{}SameRowPerm, FACTORED */}
\PYG{n}{NO} \PYG{c+cm}{/* Equil : NO, YES */}
\PYG{n}{NO} \PYG{c+cm}{/* ParSymbFact : NO, YES */}
\PYG{n}{MMD\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A} \PYG{c+cm}{/* ColPerm : NATURAL, MMD\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A, MMD\PYGZus{}ATA, METIS\PYGZus{}AT\PYGZus{}PLUS\PYGZus{}A, PARMETIS, MY\PYGZus{}PERMC */}
\PYG{n}{LargeDiag} \PYG{c+cm}{/* RowPerm : NOROWPERM, LargeDiag, MY\PYGZus{}PERMR */}
\PYG{l+m+mf}{1.0} \PYG{c+cm}{/* DiagPivotThresh : real value */}
\PYG{n}{DOUBLE} \PYG{c+cm}{/* IterRefine : NOREFINE, SINGLE, DOUBLE, EXTRA */}
\PYG{n}{NOTRANS} \PYG{c+cm}{/* Trans : NOTRANS, TRANS, CONJ*/}
\PYG{n}{NO} \PYG{c+cm}{/* ReplaceTinyPivot : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* SolveInitialized : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* RefineInitialized : NO, YES*/}
\PYG{n}{NO} \PYG{c+cm}{/* PrintStat : NO, YES*/}
\PYG{n}{NOEQUIL} \PYG{c+cm}{/* DiagScale : NOEQUIL, ROW, COL, BOTH*/}
\end{sphinxVerbatim}

\sphinxAtStartPar
If no solver parameter is given, we used default option of SuperLU\_DIST solver.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
A simple example of calling SuperLU\_DIST in \sphinxstylestrong{FreeFEM} with this two methods is given in the {\hyperref[\detokenize{examples/parallelization:examplesolversuperludist}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver superLU\_DIST example}}}}.
\end{sphinxadmonition}


\paragraph{PaStiX solver}
\label{\detokenize{documentation/parallelization:pastix-solver}}
\sphinxAtStartPar
\sphinxhref{http://pastix.gforge.inria.fr/files/README-txt.html}{PaStiX} (Parallel Sparse matrix package) is a free scientific library under CECILL\sphinxhyphen{}C license.
This package solves sparse linear system with a direct and block ILU(k) iterative methods.
his solver can be applied to a real or complex matrix with a symmetric pattern.

\sphinxAtStartPar
\sphinxstylestrong{PaStiX parameters:}

\sphinxAtStartPar
The input \sphinxcode{\sphinxupquote{matrix}} parameter of \sphinxstylestrong{FreeFEM} depend on PaStiX interface.
\sphinxcode{\sphinxupquote{matrix = assembled}} for non distributed matrix.
It is the same parameter for SuperLU\_DIST.

\sphinxAtStartPar
There are four parameters in PaStiX : \sphinxcode{\sphinxupquote{iparm}}, \sphinxcode{\sphinxupquote{dparm}}, \sphinxcode{\sphinxupquote{perm}} and \sphinxcode{\sphinxupquote{invp}}.
These parameters are respectively the integer parameters (vector of size 64), real parameters (vector of size 64), permutation matrix and inverse permutation matrix respectively.
\sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} vectors are described in \sphinxhref{https://gforge.inria.fr/docman/?group\_id=186\&view=listfile\&dirid=246}{PaStiX RefCard}.

\sphinxAtStartPar
The parameters \sphinxcode{\sphinxupquote{permr}} and \sphinxcode{\sphinxupquote{permc}} in \sphinxstylestrong{FreeFEM} are provided to give permutation matrix and inverse permutation matrix of the user respectively.

\sphinxAtStartPar
\sphinxstylestrong{Solver parameters defined in .edp file:}

\sphinxAtStartPar
To call PaStiX in \sphinxstylestrong{FreeFEM} in this case, we need to specify the parameters \sphinxcode{\sphinxupquote{lparams}} and \sphinxcode{\sphinxupquote{dparams}}.
These parameters are defined by :

\sphinxAtStartPar
\(\forall i\) = 0,… ,63, \sphinxcode{\sphinxupquote{lparams{[}i{]} = iparm{[}i{]}}}.

\sphinxAtStartPar
\(\forall i\) = 0,… ,63, \sphinxcode{\sphinxupquote{dparams{[}i{]} = dparm{[}i{]}}}.

\sphinxAtStartPar
\sphinxstylestrong{Reading solver parameters on a file:}

\sphinxAtStartPar
The structure of data file for PaStiX parameters in \sphinxstylestrong{FreeFEM} is: first line structure parameters of the matrix and in the following line the value of vectors \sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} in this order.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{assembled} \PYG{c+cm}{/* matrix input :: assembled, distributed global and distributed */}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{63}\PYG{p}{]}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{63}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
An example of this file parameter is given in \sphinxcode{\sphinxupquote{ffpastix\_iparm\_dparm.txt}} with a description of these parameters.
This file is obtained with the example file \sphinxcode{\sphinxupquote{iparm.txt}} and \sphinxcode{\sphinxupquote{dparm.txt}} including in the PaStiX package.

\sphinxAtStartPar
If no solver parameter is given, we use the default option of PaStiX solver.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
A simple example of calling PaStiX in \sphinxstylestrong{FreeFEM} with this two methods is given in the {\hyperref[\detokenize{examples/parallelization:examplesolverpastix}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver PaStiX example}}}}.
\end{sphinxadmonition}

\sphinxAtStartPar
In \hyperref[\detokenize{documentation/parallelization:tabparallelizationdirectsolver}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationdirectsolver}}}, we recall the different matrix considering in the different direct solvers.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Type of matrix used by the different direct sparse solver}\label{\detokenize{documentation/parallelization:tabparallelizationdirectsolver}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
direct solver
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{7}}
\sphinxstyletheadfamily \sphinxAtStartPar
square matrix
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{7}}
\sphinxstyletheadfamily \sphinxAtStartPar
rectangular matrix
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
sym
&\sphinxstyletheadfamily 
\sphinxAtStartPar
sym pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
unsym
&\sphinxstyletheadfamily 
\sphinxAtStartPar
sym
&\sphinxstyletheadfamily 
\sphinxAtStartPar
sym pattern
&\sphinxstyletheadfamily 
\sphinxAtStartPar
unsym
\\
\hline
\sphinxAtStartPar
SuperLU\_DIST
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
\\
\hline
\sphinxAtStartPar
MUMPS
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
\\
\hline
\sphinxAtStartPar
Pastix
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
no
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Parallel sparse iterative solver}
\label{\detokenize{documentation/parallelization:parallel-sparse-iterative-solver}}
\sphinxAtStartPar
Concerning iterative solvers, we have chosen \sphinxhref{https://www-users.cs.umn.edu/~saad/software/pARMS/}{pARMS}, \sphinxhref{http://hips.gforge.inria.fr/}{HIPS} and \sphinxhref{https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{Hypre}.

\sphinxAtStartPar
Each software implements a different type of parallel preconditioner.

\sphinxAtStartPar
So, pARMS implements algebraic domain decomposition preconditioner type such as additive Schwartz \sphinxcite{bibliography:cai1989} and interface method; while HIPS implement hierarchical incomplete factorization and finally HYPRE implements multilevel preconditioner are AMG(Algebraic MultiGrid) and parallel approximated inverse.

\sphinxAtStartPar
To use one of these programs in \sphinxstylestrong{FreeFEM}, you have to install it independently of \sphinxstylestrong{FreeFEM}.
It is also necessary to install the MPI communication library which is essential for communication between the processors and, in some cases, software partitioning graphs like \sphinxhref{http://glaros.dtc.umn.edu/gkhome/metis/metis/overview}{METIS} or \sphinxhref{http://www.labri.fr/perso/pelegrin/scotch/}{Scotch}.

\sphinxAtStartPar
All this preconditioners are used with Krylov subspace methods accelerators.

\sphinxAtStartPar
Krylov subspace methods are iterative methods which consist in finding a solution \(x\) of linear system \(Ax=b\) inside the affine space \(x_0+K_m\) by imposing that \(b-Ax \bot \mathcal{L}_m\), where \(K_m\) is Krylov subspace of dimension \(m\) defined by \(K_m=\{r_0, Ar_0, A^2r_0,...,A^{m-1}r_0\}\) and \(\mathcal{L}_m\) is another subspace of dimension \(m\) which depends on type of Krylov subspace. For example in GMRES, \(\mathcal{L}_m=AK_m\).

\sphinxAtStartPar
We realized an interface which is easy to use, so that the call of these different softwares in \sphinxstylestrong{FreeFEM} is done in the same way.
You just have to load the solver and then specify the parameters to apply to the specific solvers.
In the rest of this chapter, when we talk about Krylov subspace methods we mean one among GMRES, CG and BICGSTAB.


\paragraph{pARMS solver}
\label{\detokenize{documentation/parallelization:parms-solver}}
\sphinxAtStartPar
\sphinxhref{https://www-users.cs.umn.edu/~saad/software/pARMS/}{pARMS} (parallel Algebraic Multilevel Solver) is a software developed by Youssef Saad and al at University of Minnesota.

\sphinxAtStartPar
This software is specialized in the resolution of large sparse non symmetric linear systems of equation.
Solvers developed in pARMS are of type “Krylov’s subspace”.

\sphinxAtStartPar
It consists of variants of GMRES like FGMRES (Flexible GMRES), DGMRES (Deflated GMRES) \sphinxcite{bibliography:saad2003} and BICGSTAB.
pARMS also implements parallel preconditioner like RAS (Restricted Additive Schwarz) \sphinxcite{bibliography:cai1989} and Schur Complement type preconditioner.

\sphinxAtStartPar
All these parallel preconditioners are based on the principle of domain decomposition.
Thus, the matrix \(A\) is partitioned into sub matrices \(A_i\)(\(i=1,...,p\)) where p represents the number of partitions one needs.
The union of \(A_i\) forms the original matrix.
The solution of the overall system is obtained by solving the local systems on \(A_i\) (see \sphinxcite{bibliography:smith1996}).
Therefore, a distinction is made between iterations on \(A\) and the local iterations on \(A_i\).

\sphinxAtStartPar
To solve the local problem on \(A_i\) there are several preconditioners as \sphinxstylestrong{ilut} (Incomplete LU with threshold), \sphinxstylestrong{iluk} (Incomplete LU with level of fill in) and \sphinxstylestrong{ARMS} (Algebraic Recursive Multilevel Solver).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Default parameters

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parms\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//Tell FreeFem that you will use pARMS}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh} \PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real} \PYG{n}{cpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ CPU time = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
In line 1, the pARMS dynamic library is loaded with interface \sphinxstylestrong{FreeFEM}.
After this, in line 15 we specify that the bilinear form will be solved by the last sparse linear solver load in memory which, in this case, is pARMS.

\sphinxAtStartPar
The parameters used in pARMS in this case are the default one since the user does not have to provide any parameter.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In order to see the plot of a parallel script, run the command \sphinxcode{\sphinxupquote{FreeFem++\sphinxhyphen{}mpi \sphinxhyphen{}glut ffglut script.edp}}
\end{sphinxadmonition}
\end{sphinxadmonition}

\sphinxAtStartPar
Here are some default parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{solver=FGMRES}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Krylov dimension=30}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Maximum of Krylov=1000}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tolerance for convergence=1e\sphinxhyphen{}08}} (see book
\sphinxcite{bibliography:saad2003} to understand all this parameters),

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{preconditionner=Restricted Additif Schwarz}}
\sphinxcite{bibliography:cai1989},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inner Krylov dimension=5}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Maximum of inner Krylov dimension=5}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Inner preconditionner=ILUK}}.

\end{itemize}

\sphinxAtStartPar
To specify the parameters to apply to the solver, the user can either give an integer vector for \sphinxstylestrong{integer parameters} and real vectors for \sphinxstylestrong{real parameters} or provide a \sphinxstylestrong{file} which contains those parameters.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
User specifies parameters inside two vectors

\sphinxAtStartPar
Lets us consider Navier\sphinxhyphen{}Stokes example.
In this example we solve linear systems coming from discretization of Navier\sphinxhyphen{}Stokes equations with pARMS.
Parameters of solver is specified by user.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{parms\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{16}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{;} \PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{wall} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{inlet} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{uc} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{Stokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ush}\PYG{p}{,} \PYG{n}{vsh}\PYG{p}{,} \PYG{n}{psh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{psh}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{ush}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vsh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{psh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{wall}\PYG{p}{,} \PYG{n}{wall}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{inlet}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{uc}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{Stokes}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set pARMS as linear solver}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb} \PYG{o}{=} \PYG{n}{Stokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sol} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{k+kp}{bb}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We need two vectors to specify the parameters of the linear solver.
In line 5\sphinxhyphen{}6 of the example, we have declared these vectors(\sphinxcode{\sphinxupquote{int{[}int{]} iparm(16); real{[}int{]} dparm(6);}}).
In line 7\sphinxhyphen{}10 we have initialized these vectors by negative values.

\sphinxAtStartPar
We do this because all parameters values in pARMS are positive and if you do not change the negative values of one entry of this vector, the default value will be set.

\sphinxAtStartPar
In \hyperref[\detokenize{documentation/parallelization:tabparallelizationlparams}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationlparams}}} and \hyperref[\detokenize{documentation/parallelization:tabparallelizationdparams}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationdparams}}}, we have the meaning of different entries of these vectors.

\sphinxAtStartPar
We run this example on a cluster paradent of Grid5000 and report results in \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetime}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}}.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Convergence and time for solving linear system}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstartmulticolumn{5}%
\begin{varwidth}[t]{\sphinxcolwidth{5}{5}}
\sphinxstyletheadfamily \sphinxAtStartPar
\(n=471281\)
\(nnz=13\times10^6\)
\(Te=571.29\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
np
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{5}}
\sphinxstyletheadfamily \sphinxAtStartPar
add(iluk)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{5}}
\sphinxstyletheadfamily \sphinxAtStartPar
shur(iluk)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
nit
&\sphinxstyletheadfamily 
\sphinxAtStartPar
time
&\sphinxstyletheadfamily 
\sphinxAtStartPar
nit
&\sphinxstyletheadfamily 
\sphinxAtStartPar
time
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
230
&
\sphinxAtStartPar
637.57
&
\sphinxAtStartPar
21
&
\sphinxAtStartPar
557.8
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
240
&
\sphinxAtStartPar
364.12
&
\sphinxAtStartPar
22
&
\sphinxAtStartPar
302.25
\\
\hline
\sphinxAtStartPar
16
&
\sphinxAtStartPar
247
&
\sphinxAtStartPar
212.07
&
\sphinxAtStartPar
24
&
\sphinxAtStartPar
167.5
\\
\hline
\sphinxAtStartPar
32
&
\sphinxAtStartPar
261
&
\sphinxAtStartPar
111.16
&
\sphinxAtStartPar
25
&
\sphinxAtStartPar
81.5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Legend of \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetime}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetime}}}}\label{\detokenize{documentation/parallelization:tabparallelizationlegend}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
matrix size
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nnz}}
&
\sphinxAtStartPar
number of non null entries inside matrix
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nit}}
&
\sphinxAtStartPar
number of iteration for convergence
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{time}}
&
\sphinxAtStartPar
Time for convergence
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Te}}
&
\sphinxAtStartPar
Time for constructing finite element matrix
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{np}}
&
\sphinxAtStartPar
number of processor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
In this example, we fix the matrix size (in term of finite element, we fix the mesh) and increase the number of processors used to solve the linear system.
We saw that, when the number of processors increases, the time for solving the linear equation decreases, even if the number of iteration increases.
This proves that, using pARMS as solver of linear systems coming from discretization of partial differential equation in \sphinxstylestrong{FreeFEM} can decrease drastically the total time of simulation.
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Meaning of \sphinxstyleliteralintitle{\sphinxupquote{lparams}} corresponding variables}\label{\detokenize{documentation/parallelization:tabparallelizationlparams}}
\sphinxaftertopcaption
\begin{tabular}[t]{|*{2}{\X{1}{2}|}}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Entries of \sphinxcode{\sphinxupquote{iparm}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Significations of each entries
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&
\sphinxAtStartPar
Krylov subspace methods

\sphinxAtStartPar
Different values for this parameters are specify on \hyperref[\detokenize{documentation/parallelization:tabparallelizationparmskrylov}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationparmskrylov}}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&
\sphinxAtStartPar
Preconditionner

\sphinxAtStartPar
Different preconditionners for this parameters are  specify on \hyperref[\detokenize{documentation/parallelization:tabparallelizationparmsprecon}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationparmsprecon}}}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}2{]}}}
&
\sphinxAtStartPar
Krylov subspace dimension in outer iteration: default value 30
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}3{]}}}
&
\sphinxAtStartPar
Maximum of iterations in outer iteration: default value 1000
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}4{]}}}
&
\sphinxAtStartPar
Number of level in arms when used
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}5{]}}}
&
\sphinxAtStartPar
Krylov subspace dimension in inner iteration: default value 3
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}6{]}}}
&
\sphinxAtStartPar
Maximum of iterations in inner iteration: default value 3
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}7{]}}}
&
\sphinxAtStartPar
Symmetric(=1 for symmetric) or unsymmetric matrix:

\sphinxAtStartPar
default value 0(unsymmetric matrix)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}8{]}}}
&
\sphinxAtStartPar
Overlap size between different subdomain: default value 0(no overlap)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}9{]}}}
&
\sphinxAtStartPar
Scale the input matrix or not: Default value 1 (Matrix should be scaled)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}10{]}}}
&
\sphinxAtStartPar
Block size in arms when used: default value 20
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}11{]}}}
&
\sphinxAtStartPar
lfil0 (ilut, iluk, and arms) : default value 20
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}12{]}}}
&
\sphinxAtStartPar
lfil for Schur complement const : default value 20
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}13{]}}}
&
\sphinxAtStartPar
lfil for Schur complement const : default value 20
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}14{]}}}
&
\sphinxAtStartPar
Multicoloring or not in ILU when used : default value 1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}15{]}}}
&
\sphinxAtStartPar
Inner iteration : default value 0
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}16{]}}}
&
\sphinxAtStartPar
Print message when solving: default 0 (no message print)
\begin{itemize}
\item {} 
\sphinxAtStartPar
0: no message is print,

\item {} 
\sphinxAtStartPar
1: Convergence informations like number of iteration and residual,

\item {} 
\sphinxAtStartPar
2: Timing for a different step like preconditioner,

\item {} 
\sphinxAtStartPar
3 : Print all informations

\end{itemize}
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{dparams}} corresponding variables}\label{\detokenize{documentation/parallelization:tabparallelizationdparams}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Entries of \sphinxcode{\sphinxupquote{dparm}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Significations of each entries
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}0{]}}}
&
\sphinxAtStartPar
precision for outer iteration : default value 1e\sphinxhyphen{}08
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}1{]}}}
&
\sphinxAtStartPar
precision for inner iteration: default value 1e\sphinxhyphen{}2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}2{]}}}
&
\sphinxAtStartPar
tolerance used for diagonal domain: : default value 0.1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}3{]}}}
&
\sphinxAtStartPar
drop tolerance droptol0 (ilut, iluk, and arms) : default value 1e\sphinxhyphen{}2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}4{]}}}
&
\sphinxAtStartPar
droptol for Schur complement const: default value 1e\sphinxhyphen{}2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}5{]}}}
&
\sphinxAtStartPar
droptol for Schur complement const: default value 1e\sphinxhyphen{}2
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Krylov Solvers in pARMS}\label{\detokenize{documentation/parallelization:tabparallelizationparmskrylov}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Values of \sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Krylov subspace methods
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
FGMRES (Flexible GMRES)
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
DGMRES (Deflated GMRES)
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
BICGSTAB
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Preconditionners in pARMS}\label{\detokenize{documentation/parallelization:tabparallelizationparmsprecon}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Values of \sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Preconditionners type
\\
\hline
\sphinxAtStartPar
0
&
\sphinxAtStartPar
additive Schwartz preconditioner with ilu0 as local preconditioner
\\
\hline
\sphinxAtStartPar
1
&
\sphinxAtStartPar
additive Schwartz preconditioner with iluk as local preconditioner
\\
\hline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
additive Schwartz preconditioner with ilut as local preconditioner
\\
\hline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
additive Schwartz preconditioner with arms as local preconditioner
\\
\hline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
Left Schur complement preconditioner with ilu0 as local preconditioner
\\
\hline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
Left Schur complement preconditioner with ilut as local preconditioner
\\
\hline
\sphinxAtStartPar
6
&
\sphinxAtStartPar
Left Schur complement preconditioner with iluk as local preconditioner
\\
\hline
\sphinxAtStartPar
7
&
\sphinxAtStartPar
Left Schur complement preconditioner with arms as local preconditioner
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
Right Schur complement preconditioner with ilu0 as local preconditioner
\\
\hline
\sphinxAtStartPar
9
&
\sphinxAtStartPar
Right Schur complement preconditioner with ilut as local preconditioner
\\
\hline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
Right Schur complement preconditioner with iluk as local preconditioner
\\
\hline
\sphinxAtStartPar
11
&
\sphinxAtStartPar
Right Schur complement preconditioner with arms as local preconditioner
\\
\hline
\sphinxAtStartPar
12
&
\sphinxAtStartPar
sch\_gilu0, Schur complement preconditioner with global ilu0
\\
\hline
\sphinxAtStartPar
13
&
\sphinxAtStartPar
SchurSymmetric GS preconditioner
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Interfacing with HIPS}
\label{\detokenize{documentation/parallelization:interfacing-with-hips}}
\sphinxAtStartPar
\sphinxhref{http://hips.gforge.inria.fr/}{HIPS} (\sphinxstyleemphasis{Hierarchical Iterative Parallel Solver}) is a scientific library that provides an efficient parallel iterative solver for very large sparse linear systems.
HIPS is available as free software under the CeCILL\sphinxhyphen{}C licence.

\sphinxAtStartPar
HIPS implements two solver classes which are the iteratives class (GMRES, PCG) and the Direct class.
Concerning preconditionners, HIPS implements a type of multilevel ILU.
For further informations on those preconditionners see the \sphinxhref{http://hips.gforge.inria.fr/doc/hips\_user.pdf}{HIPS documentation}.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Laplacian 3D solved with HIPS

\sphinxAtStartPar
Let us consider the 3D Laplacian example inside \sphinxstylestrong{FreeFEM} package where after discretization we want to solve the linear equation with HIPS.

\sphinxAtStartPar
The following example is a Laplacian 3D using Hips as linear solver.
We first load Hips solver at line 2.
From line 7 to 18 we specify the parameters for the Hips solver and in line 82 we set these parameters in the linear solver.

\sphinxAtStartPar
In \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}}} results of running on Cluster Paradent of Grid5000 are reported.
We can see in this running example the efficiency of parallelism.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hips\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//load Hips library}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{14}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//use iterative solver}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//PCG as Krylov method}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Matrix are symmetric}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Pattern are also symmetric}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Scale matrix}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}13}\PYG{p}{;} \PYG{c+c1}{//Tolerance to convergence}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold in ILUT}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold for Schur preconditionner}

\PYG{c+c1}{// Functions}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uex} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{z}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uey} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{uez} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rdown}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,}
    \PYG{k+kp}{reffaceup} \PYG{o}{=} \PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow} \PYG{o}{=} \PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uhe} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uhe min =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{F}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{va} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{ue}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{p}{(}\PYG{n}{uex}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{uey}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{+} \PYG{n}{uez}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{l} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Aa} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{F}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Size of A =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Aa}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Non zero coefficients =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Aa}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CPU TIME FOR FORMING MATRIX =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{Aa}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Set hips as linear solver}

\PYG{c+c1}{// Solve}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Aa}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{F}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Legend of this table are give in \hyperref[\detokenize{documentation/parallelization:tabparallelizationlegend}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationlegend}}}}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehips}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{3}}
\sphinxstyletheadfamily \sphinxAtStartPar
\(n=4\times 10^6\)
\(nnz=118 \times 10^6\)
\(Te=221.34\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{np}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nit}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{time}}
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
190
&
\sphinxAtStartPar
120.34
\\
\hline
\sphinxAtStartPar
16
&
\sphinxAtStartPar
189
&
\sphinxAtStartPar
61.08
\\
\hline
\sphinxAtStartPar
32
&
\sphinxAtStartPar
186
&
\sphinxAtStartPar
31.70
\\
\hline
\sphinxAtStartPar
64
&
\sphinxAtStartPar
183
&
\sphinxAtStartPar
23.44
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}

\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{lparams}} corresponding to HIPS interface}\label{\detokenize{documentation/parallelization:tabparallelizationhipsinterface}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Entries of \sphinxcode{\sphinxupquote{iparm}}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Significations of each entries
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}0{]}}}
&
\sphinxAtStartPar
Strategy use for solving (Iterative=0 or Hybrid=1 or Direct=2).

\sphinxAtStartPar
Defaults values are : Iterative
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}1{]}}}
&
\sphinxAtStartPar
Krylov methods.

\sphinxAtStartPar
If iparm{[}0{]}=0, give type of Krylov methods: 0 for GMRES, 1 for PCG
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}2{]}}}
&
\sphinxAtStartPar
Maximum of iterations in outer iteration: default value 1000
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}3{]}}}
&
\sphinxAtStartPar
Krylov subspace dimension in outer iteration: default value 40
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}4{]}}}
&
\sphinxAtStartPar
Symmetric(=0 for symmetric) and 1 for unsymmetricmatrix:

\sphinxAtStartPar
default value 1 (unsymmetric matrix)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}5{]}}}
&
\sphinxAtStartPar
Pattern of matrix are symmetric or not: default value 0
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}6{]}}}
&
\sphinxAtStartPar
Partition type of input matrix: default value 0
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}7{]}}}
&
\sphinxAtStartPar
Number of level that use the HIPS locally consistentfill\sphinxhyphen{}in:

\sphinxAtStartPar
Default value 2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}8{]}}}
&
\sphinxAtStartPar
Numbering in indices array will start at 0 or 1: Default value 0
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}9{]}}}
&
\sphinxAtStartPar
Scale matrix. Default value 1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}10{]}}}
&
\sphinxAtStartPar
Reordering use inside subdomains for reducingfill\sphinxhyphen{}in:

\sphinxAtStartPar
Only use for iterative. Default value 1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}11{]}}}
&
\sphinxAtStartPar
Number of unknowns per node in the matrix non\sphinxhyphen{}zeropattern graph:

\sphinxAtStartPar
Default value 1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}12{]}}}
&
\sphinxAtStartPar
This value is used to set the number of time the

\sphinxAtStartPar
normalization is applied to the matrix: Default 2.
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}13{]}}}
&
\sphinxAtStartPar
Level of informations printed during solving: Default 5.
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparm{[}14{]}}}
&
\sphinxAtStartPar
HIPS\_DOMSIZE Subdomain size
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Significations of \sphinxstyleliteralintitle{\sphinxupquote{dparams}} corresponding to HIPS interface}\label{\detokenize{documentation/parallelization:tabparallelizationhipsdparms}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}0{]}}}
&
\sphinxAtStartPar
HIPS\_PREC: Relative residual norm: Default=1e\sphinxhyphen{}9
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}1{]}}}
&
\sphinxAtStartPar
HIPS\_DROPTOL0: Numerical threshold in ILUT for interior domain

\sphinxAtStartPar
(important : set 0.0 in HYBRID: Default=0.005)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}2{]}}}
&
\sphinxAtStartPar
HIPS\_DROPTOL1 : Numerical threshold in ILUT for Schur preconditioner:

\sphinxAtStartPar
Default=0.005
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}3{]}}}
&
\sphinxAtStartPar
HIPS\_DROPTOLE : Numerical threshold for coupling between the interior

\sphinxAtStartPar
level and Schur: Default 0.005
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}4{]}}}
&
\sphinxAtStartPar
HIPS\_AMALG : Numerical threshold for coupling between the interior level

\sphinxAtStartPar
and Schur: Default=0.005
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparm{[}5{]}}}
&
\sphinxAtStartPar
HIPS\_DROPSCHUR : Numerical threshold for coupling between the interior

\sphinxAtStartPar
level and Schur: Default=0.005
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\paragraph{Interfacing with HYPRE}
\label{\detokenize{documentation/parallelization:interfacing-with-hypre}}
\sphinxAtStartPar
\sphinxhref{https://computation.llnl.gov/projects/hypre-scalable-linear-solvers-multigrid-methods}{Hypre} (High Level Preconditioner) is a suite of parallel preconditioner developed at Lawrence Livermore National Lab.

\sphinxAtStartPar
There are two main classes of preconditioners developed in HYPRE: AMG (Algebraic MultiGrid) and Parasails (Parallel Sparse Approximate Inverse).

\sphinxAtStartPar
Now, suppose we want to solve \(Ax=b\).

\sphinxAtStartPar
At the heart of AMG there is a series of progressively coarser (smaller) representations of the matrix \(A\).
Given an approximation \(\hat{x}\) to the solution \(x\), consider solving the residual equation \(Ae=r\) to find the error \(e\), where \(r=b-A\hat{x}\).
A fundamental principle of AMG is that it is an algebraically smooth error.
To reduce the algebraically smooth errors further, they need to be represented by a smaller defect equation (coarse grid residual equation) \(A_ce_c=r_c\), which is cheaper to solve.
After solving this coarse equation, the solution is then interpolated in fine grid represented here by matrix \(A\).
The quality of AMG depends on the choice of coarsening and interpolating operators.

\sphinxAtStartPar
The \sphinxstyleemphasis{sparse approximate inverse} approximates the inverse of a matrix \(A\) by a sparse matrix \(M\).
A technical idea to construct matrix \(M\) is to minimize the Frobenuis norm of the residual matrix \(I-MA\).
For more details on this preconditioner technics see \sphinxcite{bibliography:chow1997}.

\sphinxAtStartPar
HYPRE implement three Krylov subspace solvers: GMRES, PCG and BiCGStab.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Laplacian 3D solved with HYPRE

\sphinxAtStartPar
Let us consider again the 3D Laplacian example inside \sphinxstylestrong{FreeFEM} package where after discretization we want to solve the linear equation with Hypre.
The following example is a Laplacian 3D using Hypre as linear solver.
This is the same example as Hips one, so we just show here the lines where we set some Hypre parameters.

\sphinxAtStartPar
We first load the Hypre solver at line 2.
From line 6 to 18 we specifies the parameters to set to Hypre solver and in line 22 we set parameters to Hypre solver.

\sphinxAtStartPar
It should be noted that the meaning of the entries of these vectors is different from those of Hips.
In the case of HYPRE, the meaning of differents entries of vectors \sphinxcode{\sphinxupquote{iparm}} and \sphinxcode{\sphinxupquote{dparm}} are given in \hyperref[\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}}} to \hyperref[\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}}}.

\sphinxAtStartPar
In \hyperref[\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}]{Table \ref{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}}} the results of running on Cluster Paradent of Grid5000 are reported.
We can see in this running example the efficiency of parallelism, in particular when AMG are use as preconditioner.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hipre\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{//Load Hipre librairy}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{iparm}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dparm}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{iparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{dparm}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//PCG as krylov method}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//AMG as preconditionner 2: if ParaSails}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;} \PYG{c+c1}{//Interpolation}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{c+c1}{//AMG Coarsen type}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//Measure type}
\PYG{n}{iparm}\PYG{p}{[}\PYG{l+m+mi}{16}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//Additive schwarz as smoother}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}13}\PYG{p}{;} \PYG{c+c1}{//Tolerance to convergence}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Threshold}
\PYG{n}{dparm}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{5e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Truncation factor}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{Aa}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{dparams}\PYG{o}{=}\PYG{n}{dparm}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{iparm}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of common entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} vectors for every preconditioner in HYPRE}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmshypre}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}0{]}}}
&
\sphinxAtStartPar
Solver identification:

\sphinxAtStartPar
0: BiCGStab, 1: GMRES, 2: PCG. Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}1{]}}}
&
\sphinxAtStartPar
Preconditioner identification:

\sphinxAtStartPar
0: BOOMER AMG, 1: PILUT, 2: Parasails, 3: Schwartz Default=0
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}2{]}}}
&
\sphinxAtStartPar
Maximum of iteration: Default=1000
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}3{]}}}
&
\sphinxAtStartPar
Krylov subspace dim: Default= 40
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}4{]}}}
&
\sphinxAtStartPar
Solver print info level: Default=2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}5{]}}}
&
\sphinxAtStartPar
Solver log: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}6{]}}}
&
\sphinxAtStartPar
Solver stopping criteria only for BiCGStab : Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}0{]}}}
&
\sphinxAtStartPar
Tolerance for convergence: Default=:math:\sphinxtitleref{1.0e\sphinxhyphen{}11}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is BOOMER AMG}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsboomer}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
\sphinxAtStartPar
AMG interpolation type: Default=6
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
\sphinxAtStartPar
Specifies the use of GSMG \sphinxhyphen{} geometrically smooth coarsening and

\sphinxAtStartPar
interpolation: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}9{]}}}
&
\sphinxAtStartPar
AMG coarsen type: Default=6
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}10{]}}}
&
\sphinxAtStartPar
Defines whether local or global measures are used: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}11{]}}}
&
\sphinxAtStartPar
AMG cycle type: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}12{]}}}
&
\sphinxAtStartPar
AMG Smoother type: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}13{]}}}
&
\sphinxAtStartPar
AMG number of levels for smoothers: Default=3
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}14{]}}}
&
\sphinxAtStartPar
AMG number of sweeps for smoothers: Default=2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}15{]}}}
&
\sphinxAtStartPar
Maximum number of multigrid levels: Default=25
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}16{]}}}
&
\sphinxAtStartPar
Defines which variant of the Schwartz method isused:

\sphinxAtStartPar
0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)

\sphinxAtStartPar
1: hybrid additive Schwartz method (no overlap across processor boundaries)

\sphinxAtStartPar
2: additive Schwartz method

\sphinxAtStartPar
3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)

\sphinxAtStartPar
Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}17{]}}}
&
\sphinxAtStartPar
Size of the system of PDEs: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}18{]}}}
&
\sphinxAtStartPar
Overlap for the Schwarz method: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}19{]}}}
&
\sphinxAtStartPar
Type of domain used for the Schwarz method

\sphinxAtStartPar
0: each point is a domain

\sphinxAtStartPar
1: each node is a domain (only of interest in “systems” AMG)

\sphinxAtStartPar
2: each domain is generated by agglomeration (default)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
\sphinxAtStartPar
AMG strength threshold: Default=0.25
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}2{]}}}
&
\sphinxAtStartPar
Truncation factor for the interpolation: Default=1e\sphinxhyphen{}2
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}3{]}}}
&
\sphinxAtStartPar
Sets a parameter to modify the definition of strength for

\sphinxAtStartPar
diagonal dominant portions of the matrix: Default=0.9
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}3{]}}}
&
\sphinxAtStartPar
Defines a smoothing parameter for the additive Schwartz method. Default=1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is PILUT}\label{\detokenize{documentation/parallelization:id10}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
\sphinxAtStartPar
Row size in Parallel ILUT: Default=1000
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
\sphinxAtStartPar
Set maximum number of iterations: Default=30
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
\sphinxAtStartPar
Drop tolerance in Parallel ILUT: Default=1e\sphinxhyphen{}5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditioner is ParaSails}\label{\detokenize{documentation/parallelization:id11}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
\sphinxAtStartPar
Number of levels in Parallel Sparse Approximate inverse: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
\sphinxAtStartPar
Symmetric parameter for the ParaSails preconditioner:

\sphinxAtStartPar
0: nonsymmetric and/or indefinite problem, and nonsymmetric preconditioner

\sphinxAtStartPar
1: SPD problem, and SPD (factored) preconditioner

\sphinxAtStartPar
2: nonsymmetric, definite problem, and SPD (factored) preconditioner

\sphinxAtStartPar
Default=0
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}1{]}}}
&
\sphinxAtStartPar
Filters parameters. The filter parameter is used to drop small nonzeros in the preconditioner,

\sphinxAtStartPar
to reduce the cost of applying the preconditioner: Default=0.1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparms{[}2{]}}}
&
\sphinxAtStartPar
Threshold parameter: Default=0.1
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Definitions of other entries of \sphinxstyleliteralintitle{\sphinxupquote{iparms}} and \sphinxstyleliteralintitle{\sphinxupquote{dparms}} if preconditionner is Schwartz}\label{\detokenize{documentation/parallelization:tabparallelizationiparmsdparmsschwartz}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}7{]}}}
&
\sphinxAtStartPar
Defines which variant of the Schwartz method isused:

\sphinxAtStartPar
0: hybrid multiplicative Schwartz method (no overlap across processor boundaries)

\sphinxAtStartPar
1: hybrid additive Schwartz method (no overlap across processor boundaries)

\sphinxAtStartPar
2: additive Schwartz method

\sphinxAtStartPar
3: hybrid multiplicative Schwartz method (with overlap across processor boundaries)

\sphinxAtStartPar
Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}8{]}}}
&
\sphinxAtStartPar
Overlap for the Schwartz method: Default=1
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iparms{[}9{]}}}
&
\sphinxAtStartPar
Type of domain used for the Schwartz method

\sphinxAtStartPar
0: each point is a domain

\sphinxAtStartPar
1: each node is a domain (only of interest in “systems” AMG)

\sphinxAtStartPar
2: each domain is generated by agglomeration (default)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Convergence and time for solving linear system}\label{\detokenize{documentation/parallelization:tabparallelizationconvergencetimehypre}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\(n=4\times10^6\)
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \sphinxAtStartPar
\(nnz=13\times10^6\)
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(Te = 571.29\)
\\
\hline\sphinxstyletheadfamily 
\sphinxAtStartPar
np
&\sphinxstartmulticolumn{3}%
\begin{varwidth}[t]{\sphinxcolwidth{3}{4}}
\sphinxstyletheadfamily \sphinxAtStartPar
AMG
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline\sphinxstyletheadfamily &\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxtitleref{nit}
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxstyletheadfamily \sphinxAtStartPar
\sphinxtitleref{time}
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxAtStartPar
8
&
\sphinxAtStartPar
6
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxAtStartPar
1491.83
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxAtStartPar
16
&
\sphinxAtStartPar
5
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxAtStartPar
708.49
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxAtStartPar
32
&
\sphinxAtStartPar
4
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxAtStartPar
296.22
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\sphinxAtStartPar
64
&
\sphinxAtStartPar
4
&\sphinxstartmulticolumn{2}%
\begin{varwidth}[t]{\sphinxcolwidth{2}{4}}
\sphinxAtStartPar
145.64
\par
\vskip-\baselineskip\vbox{\hbox{\strut}}\end{varwidth}%
\sphinxstopmulticolumn
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Conclusion}
\label{\detokenize{documentation/parallelization:conclusion}}
\sphinxAtStartPar
With the different runs presented here, we wanted to illustrate the gain in time when we increase the number of processors used for the simulations.
We saw that in every case the time for the construction of the finite element matrix is constant.
This is normal because until now this phase is sequential in \sphinxstylestrong{FreeFEM}.
In contrast, phases for solving the linear system are parallel.
We saw on several examples presented here that when we increase the number of processors, in general we decrease the time used for solving the linear systems.
But this is not true in every case.
In several case, when we increase the number of processors the time to convergence also increases.
There are two main reasons for this.
First, the increase of processors can lead to the increase of volume of exchanged data across processors consequently increasing the time for solving the linear systems.

\sphinxAtStartPar
Furthermore, in decomposition domain type preconditioners, the number of processors generally corresponds to the number of sub domains.
In subdomain methods, generally when we increase the number of subdomains we decrease convergence quality of the preconditioner.
This can increase the time used for solving linear equations.

\sphinxAtStartPar
To end this, we should note that good use of the preconditioners interfaced in \sphinxstylestrong{FreeFEM} is empiric, because it is difficult to know what is a good preconditioner for some type of problems.
Although, the efficiency of preconditioners sometimes depends on how its parameters are set.
For this reason we advise the user to pay attention to the meaning of the parameters in the user guide of the iterative solvers interfaced in \sphinxstylestrong{FreeFEM}.


\subsubsection{Domain decomposition}
\label{\detokenize{documentation/parallelization:domain-decomposition}}
\sphinxAtStartPar
In the previous section, we saw that the phases to construct a matrix are sequential.
One strategy to construct the matrix in parallel is to divide geometrically the domain into subdomains.
In every subdomain we construct a local submatrix and after that we assemble every submatrix to form the global matrix.

\sphinxAtStartPar
We can use this technique to solve PDE directly in domain \(\Omega\).
In this case, in every subdomains you have to define artificial boundary conditions to form consistent equations in every subdomains.
After this, you solve equation in every subdomains and define a strategy to obtain the global solution.

\sphinxAtStartPar
In terms of parallel programming for \sphinxstylestrong{FreeFEM}, with MPI, this means that the user must be able to divide processors avaible for computation into subgroups of processors and also must be able to realize different type of communications in \sphinxstylestrong{FreeFEM} script.
Here is a wrapper of some MPI functions.


\paragraph{Communicators and groups}
\label{\detokenize{documentation/parallelization:communicators-and-groups}}
\sphinxAtStartPar
\sphinxstylestrong{Groups}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiGroup grpe(mpiGroup gp, KN\_\textless{}long\textgreater{})}}: Create MPI\_Group from existing group \sphinxcode{\sphinxupquote{gp}} by given vector.

\sphinxAtStartPar
\sphinxstylestrong{Communicators}

\sphinxAtStartPar
Communicators is an abstract MPI object which allows MPI user to communicate across group of processors.
Communicators can be Intra\sphinxhyphen{}communicators(involves a single group) or Inter\sphinxhyphen{}communicators (involves two groups).
When we not specify type of communicator it will be Intra\sphinxhyphen{}communicators

\sphinxAtStartPar
\sphinxstylestrong{mpiComm cc(mpiComm comm, mpiGroup gp):} Creates a new communicator.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{comm}} communicator(handle), \sphinxcode{\sphinxupquote{gp}} group which is a subset of the group of \sphinxcode{\sphinxupquote{comm}} (handle).
Return new communicator

\sphinxAtStartPar
\sphinxstylestrong{mpiComm cc(mpiGroup gp)}: Same as previous constructor but default \sphinxcode{\sphinxupquote{comm}} here is \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxAtStartPar
\sphinxstylestrong{mpiComm cc(mpiComm comm, int color, int key):} Creates new communicators based on \sphinxcode{\sphinxupquote{colors}} and \sphinxcode{\sphinxupquote{key}}.
This constructor is based on MPI\_Comm\_split routine of MPI.

\sphinxAtStartPar
\sphinxstylestrong{mpiComm cc(MPIrank p, int key):} Same constructor than the last one.

\sphinxAtStartPar
Here \sphinxcode{\sphinxupquote{colors}} and \sphinxcode{\sphinxupquote{comm}} is defined in \sphinxcode{\sphinxupquote{MPIrank}}.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Comm\_split}} routine of MPI.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Split communicator

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{color}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{qpp}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{cp}\PYG{p}{(}\PYG{n}{ccc}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{mpiComm cc(mpiComm comm, int high):} Creates an intracommunicator from an intercommunicator. \sphinxcode{\sphinxupquote{comm}} intercommunicator, \sphinxcode{\sphinxupquote{high}}.

\sphinxAtStartPar
Used to order the groups within \sphinxcode{\sphinxupquote{comm}} (logical) when creating the new communicator.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Intercomm\_merge}} routine of MPI.

\sphinxAtStartPar
\sphinxstylestrong{mpiComm cc(MPIrank p1, MPIrank p2, int tag):} This constructor creates an intercommuncator from two intracommunicators.
\sphinxcode{\sphinxupquote{p1}} defined local (intra)communicator and rank in \sphinxcode{\sphinxupquote{local\_comm}} of leader (often 0) while \sphinxcode{\sphinxupquote{p2}} defined remote communicator and rank in \sphinxcode{\sphinxupquote{peer\_comm}} of remote leader (often 0).
\sphinxcode{\sphinxupquote{tag}} Message tag to use in constructing intercommunicator.
This constructor is based on \sphinxcode{\sphinxupquote{MPI\_Intercomm\_create}}.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Merge

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mpiComm} \PYG{n}{comm}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{color} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rk} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{size} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Color values: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{color} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{ccc}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{rk}\PYG{o}{\PYGZlt{}}\PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{cp}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{,} \PYG{n}{color}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rleader}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{rk} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{rk} \PYG{o}{=}\PYG{o}{=} \PYG{n}{size}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}} \PYG{n}{rleader} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mpiComm} \PYG{n}{qqp}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ccc}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{n}{rleader}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{12345}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{aaa} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{ccc}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Number of processor: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{aaa} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\paragraph{Process}
\label{\detokenize{documentation/parallelization:process}}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} we wrap MPI process by function call \sphinxcode{\sphinxupquote{processor}} which create internal \sphinxstylestrong{FreeFEM} object call \sphinxcode{\sphinxupquote{MPIrank}}.
This mean that do not use \sphinxcode{\sphinxupquote{MPIrank}} in \sphinxstylestrong{FreeFEM} script.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{processor(int rk)}}: Keep process rank inside object \sphinxcode{\sphinxupquote{MPIrank}}.
Rank is inside \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} and \sphinxcode{\sphinxupquote{processor(mpiComm cc, int rk)}} process rank inside communicator cc.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} and \sphinxcode{\sphinxupquote{processor(mpiComm cc, int rk)}} process rank inside communicator cc.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{processorblock(int rk)}}: This function is exactlly the same than \sphinxcode{\sphinxupquote{processor(int rk)}} but is use in case of blocking communication.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{processorblock(int rk, mpiComm cc)}}: This function is exactly the same as \sphinxcode{\sphinxupquote{processor(int rk, mpiComm cc)}} but uses a synchronization point.


\paragraph{Points to Points communicators}
\label{\detokenize{documentation/parallelization:points-to-points-communicators}}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} you can call MPI points to points communications functions.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Send(processor(int rk, mpiComm cc), Data D)}} : Blocking send of \sphinxcode{\sphinxupquote{Data D}} to processor of \sphinxcode{\sphinxupquote{rank rk}} inside communicator \sphinxcode{\sphinxupquote{cc}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Recv(processor(int rk, mpiComm cc), Data D)}}: Receive \sphinxcode{\sphinxupquote{Data D}} from process of rank \sphinxcode{\sphinxupquote{rk}} in communicator \sphinxcode{\sphinxupquote{cc}}.

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}} and should be the same type than corresponding send.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Isend(processor(int rk, mpiComm cc), Data D)}} : Non blocking send of \sphinxcode{\sphinxupquote{Data D}} to processor of \sphinxcode{\sphinxupquote{rank rk}} inside communicator \sphinxcode{\sphinxupquote{cc}}.

\sphinxAtStartPar
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, \sphinxcode{\sphinxupquote{matrix}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Recv(processor(int rk, mpiComm cc), Data D)}}: Receive corresponding to send.


\paragraph{Global operations}
\label{\detokenize{documentation/parallelization:global-operations}}
\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM} you can call MPI global communication functions.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{broadcast(processor(int rk, mpiComm cc), Data D)}}: Process \sphinxcode{\sphinxupquote{rk}} Broadcast \sphinxcode{\sphinxupquote{Data D}} to all process inside \sphinxcode{\sphinxupquote{communicator cc}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{broadcast(processor(int rk), Data D)}}: Process \sphinxcode{\sphinxupquote{rk}} Broadcast \sphinxcode{\sphinxupquote{Data D}} to all process inside \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.
Note that \sphinxcode{\sphinxupquote{Data D}} can be: \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{int{[}int{]}}}, \sphinxcode{\sphinxupquote{real{[}int{]}}}, \sphinxcode{\sphinxupquote{complex{[}int{]}}}, \sphinxcode{\sphinxupquote{Mesh}}, \sphinxcode{\sphinxupquote{Mesh3}}, \sphinxcode{\sphinxupquote{Matrix}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiAlltoall(Data a, Data b)}}: Sends \sphinxcode{\sphinxupquote{data a}} from all to all processes.
Receive buffer is \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiAlltoall(Data a, Data b, mpiComm cc)}}: Sends \sphinxcode{\sphinxupquote{data a}} from all to all processes. Receive buffer is \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{cc}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiGather(Data a, Data b, processor(mpiComm, int rk)}}: Gathers together values \sphinxcode{\sphinxupquote{Data a}} from a group of processes.
Process of rank \sphinxcode{\sphinxupquote{rk}} get data on communicator \sphinxcode{\sphinxupquote{rk}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Gather}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiAllgather(Data a, Data b)}}: Gathers \sphinxcode{\sphinxupquote{Data a}} from all processes and distribute it to all in \sphinxcode{\sphinxupquote{Data b}}.
This is done inside communicator \sphinxcode{\sphinxupquote{MPI\_COMM\_WORLD}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Allgather}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiAllgather(Data a, Data b, mpiComm cc)}}: Gathers \sphinxcode{\sphinxupquote{Data a}} from all processes and distribute it to all in \sphinxcode{\sphinxupquote{Data b}}.
This is done inside \sphinxcode{\sphinxupquote{communicator cc}}.
This function is like \sphinxcode{\sphinxupquote{MPI\_Allgather}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiScatter(Data a,Data b,processor(int rk, mpiComm cc))}}: Sends \sphinxcode{\sphinxupquote{Data a}} from one process whith rank \sphinxcode{\sphinxupquote{rk}} to all other processes in group represented by communicator \sphinxcode{\sphinxupquote{mpiComm cc}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiReduce(Data a, Data b, processor(int rk, mpiComm cc), MPI\_Op op)}} Reduces values \sphinxcode{\sphinxupquote{Data a}} on all processes to a single value \sphinxcode{\sphinxupquote{Data b}} on process of rank \sphinxcode{\sphinxupquote{rk}} and communicator \sphinxcode{\sphinxupquote{cc}}.

\sphinxAtStartPar
Operation use in reduce is: \sphinxcode{\sphinxupquote{MPI\_Op op}} which can be: \sphinxcode{\sphinxupquote{mpiMAX}}, \sphinxcode{\sphinxupquote{mpiMIN}}, \sphinxcode{\sphinxupquote{mpiSUM}}, \sphinxcode{\sphinxupquote{mpiPROD}}, \sphinxcode{\sphinxupquote{mpiLAND}}, \sphinxcode{\sphinxupquote{mpiLOR}}, \sphinxcode{\sphinxupquote{mpiLXOR}}, \sphinxcode{\sphinxupquote{mpiBAND}}, \sphinxcode{\sphinxupquote{mpiBXOR}}, \sphinxcode{\sphinxupquote{mpiMAXLOC}}, \sphinxcode{\sphinxupquote{mpiMINLOC}}.

\sphinxAtStartPar
Note that, for all global operations, only \sphinxcode{\sphinxupquote{int{[}int{]}}} and \sphinxcode{\sphinxupquote{real{[}int{]}}} are data type take in account in \sphinxstylestrong{FreeFEM}.


\section{PETSc and SLEPc}
\label{\detokenize{documentation/petsc/index:petsc-and-slepc}}\label{\detokenize{documentation/petsc/index::doc}}
\sphinxAtStartPar
FreeFEM is interfaced with \sphinxhref{https://www.mcs.anl.gov/petsc/}{PETSc} and \sphinxhref{http://slepc.upv.es/}{SLEPc} which offer a wide range of sequential or parallel linear or nonlinear solvers, time steppers, optimizers, and eigensolvers. In particular, it gives access transparently (without much changes to user code) to: distributed and multithreaded direct solvers (\sphinxhref{https://software.intel.com/en-us/mkl-developer-reference-fortran-intel-mkl-pardiso-parallel-direct-sparse-solver-interface}{PARDISO}, \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}, \sphinxhref{https://crd.lbl.gov/departments/applied-mathematics/scalable-solvers/research-areas/superlu-dist/}{SuperLU}), multigrid solvers (\sphinxhref{https://hypre.readthedocs.io/en/latest/}{hypre}, GAMG), domain decomposition methods (block Jacobi, ASM, \sphinxhref{https://github.com/hpddm/hpddm/}{HPDDM}). For a detailed introduction to these tools, interested readers are referred to the tutorial \sphinxhref{http://jolivet.perso.enseeiht.fr/FreeFem-tutorial/}{Introduction to FreeFEM with an emphasis on parallel computing}.
\begin{description}
\item[{In most of the scripts listed below, the following standard procedure is used.}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
Load an initial sequential mesh (in 2D or 3D).

\item {} 
\sphinxAtStartPar
Partition the mesh and generate connectivity information according to the number of processes.

\item {} 
\sphinxAtStartPar
Provide these information to PETSc so that subsequent computations may be done in a distributed fashion.

\end{itemize}

\end{description}

\sphinxAtStartPar
Combining the power and flexibility of PETSc with the ease\sphinxhyphen{}of\sphinxhyphen{}use of FreeFEM may help design multiphysics solvers, e.g., for \sphinxhref{https://www.sciencedirect.com/science/article/pii/S0045782519301914}{Navier\textendash{}Stokes equations}, advanced matrix\sphinxhyphen{}free discretizations, and such.


\subsection{Examples}
\label{\detokenize{documentation/petsc/examples:examples}}\label{\detokenize{documentation/petsc/examples:petscexamples}}\label{\detokenize{documentation/petsc/examples::doc}}

\subsubsection{Linear problems}
\label{\detokenize{documentation/petsc/examples:linear-problems}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{|l|l|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Filename
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comments (preconditioners, numerical schemes)
\\
\hline
\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Filename
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comments (preconditioners, numerical schemes)
\\
\hline
\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-2d-PETSc.edp}{diffusion\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Distributed LU/Cholesky, domain decomposition and multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-2d-PETSc-complex.edp}{diffusion\sphinxhyphen{}2d\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/heat-2d-PETSc.edp}{heat\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Transient diffusion equation, same as above
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-periodic-2d-PETSc.edp}{diffusion\sphinxhyphen{}periodic\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Periodic boundary conditions, multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-periodic-balanced-2d-PETSc.edp}{diffusion\sphinxhyphen{}periodic\sphinxhyphen{}balanced\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Better load balancing than above example
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-substructuring-2d-PETSc.edp}{diffusion\sphinxhyphen{}substructuring\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Balancing Domain Decomposition with Constraints
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-3d-PETSc.edp}{diffusion\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Three\sphinxhyphen{}dimensional problem, domain decomposition and multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-mg-2d-PETSc.edp}{diffusion\sphinxhyphen{}mg\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Geometric non\sphinxhyphen{}nested multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/diffusion-mg-3d-PETSc.edp}{diffusion\sphinxhyphen{}mg\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Geometric nested multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-2d-PETSc-complex.edp}{helmholtz\sphinxhyphen{}2d\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
Domain decomposition methods with optimized boundary conditions
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-mg-2d-PETSc-complex.edp}{helmholtz\sphinxhyphen{}mg\sphinxhyphen{}2d\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
Geometric multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-RT-2d-PETSc.edp}{laplace\sphinxhyphen{}RT\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Vectorial two\sphinxhyphen{}dimensional problem with a block preconditioner (fieldsplit)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-adapt-3d-PETSc.edp}{laplace\sphinxhyphen{}adapt\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Three\sphinxhyphen{}dimensional problem with \sphinxstyleemphasis{h} adaptivity, multigrid methods using Mmg
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-adapt-dist-3d-PETSc.edp}{laplace\sphinxhyphen{}adapt\sphinxhyphen{}dist\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Three\sphinxhyphen{}dimensional problem with fully\sphinxhyphen{}distributed \sphinxstyleemphasis{h} adaptivity using ParMmg
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-lagrange-PETSc.edp}{laplace\sphinxhyphen{}lagrange\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Laplace equation with constraints and a block preconditioner (fieldsplit)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-2d-PETSc.edp}{elasticity\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Vectorial problem, domain decomposition (GenEO) and multigrid methods
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-3d-PETSc.edp}{elasticity\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-2d-PETSc.edp}{stokes\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Distributed LU/Cholesky
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-3d-PETSc.edp}{stokes\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-block-2d-PETSc.edp}{stokes\sphinxhyphen{}block\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Stokes equation defined as a block system with four matrices (fieldsplit)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-fieldsplit-2d-PETSc.edp}{stokes\sphinxhyphen{}fieldsplit\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Block preconditioner (fieldsplit)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-fieldsplit-3d-PETSc.edp}{stokes\sphinxhyphen{}fieldsplit\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/oseen-2d-PETSc.edp}{oseen\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Oseen problem preconditioned by Pressure Convection\textendash{}Diffusion (PCD)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/maxwell-2d-PETSc.edp}{maxwell\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Direct LU/Cholesky
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/maxwell-3d-PETSc.edp}{maxwell\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Multigrid method
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/maxwell-mg-3d-PETSc-complex.edp}{maxwell\sphinxhyphen{}mg\sphinxhyphen{}3d\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
Two\sphinxhyphen{}grid preconditioner
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-3d-surf-PETSc-complex.edp}{helmholtz\sphinxhyphen{}3d\sphinxhyphen{}surf\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
BEM with hierarchical matrices from Htool on surfaces
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-3d-line-PETSc-complex.edp}{helmholtz\sphinxhyphen{}3d\sphinxhyphen{}line\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
BEM with hierarchical matrices from Htool on lines
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-coupled-2d-PETSc-complex.edp}{helmholtz\sphinxhyphen{}coupled\sphinxhyphen{}2d\sphinxhyphen{}PETSc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
FEM coupled with BEM in a MatNest using a block preconditioner (fieldsplit)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/PtAP-2d-PETSc.edp}{PtAP\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Parallel interpolation on non\sphinxhyphen{}matching grids + P’ A P operation
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/restriction-2d-PETSc.edp}{restriction\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Coupled problems with one being defined on a restriction of the mesh of the other
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/bilaplace-2d-PETSc.edp}{bilaplace\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Bilaplacian using Morley finite element
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{Nonlinear problems}
\label{\detokenize{documentation/petsc/examples:nonlinear-problems}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Filename
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comments (preconditioners, numerical schemes)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/bratu-2d-PETSc.edp}{bratu\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/bratu-hpddm-2d-PETSc.edp}{bratu\sphinxhyphen{}hpddm\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
GenEO with reused coarse spaces
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-2d-PETSc.edp}{newton\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-adaptmesh-2d-PETSc.edp}{newton\sphinxhyphen{}adaptmesh\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Newton method and \sphinxstyleemphasis{h} adaptivity
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-vi-2d-PETSc.edp}{newton\sphinxhyphen{}vi\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Newton method and a variational inequality
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/newton-vi-adaptmesh-2d-PETSc.edp}{newton\sphinxhyphen{}vi\sphinxhyphen{}adaptmesh\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Newton method, \sphinxstyleemphasis{h} adaptivity, and a variational inequality
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/elasticity-SNES-3d-PETSc.edp}{elasticity\sphinxhyphen{}SNES\sphinxhyphen{}3d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Linear elasiticty with a Newton method
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/neo-Hookean-2d-PETSc.edp}{neo\sphinxhyphen{}Hookean\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Nonlinear elasticity
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/navier-stokes-2d-PETSc.edp}{navier\sphinxhyphen{}stokes\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Steady\sphinxhyphen{}state Navier\textendash{}Stokes equation for linear stability analysis
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/natural-convection-fieldsplit-2d-PETSc.edp}{natural\sphinxhyphen{}convection\sphinxhyphen{}fieldsplit\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Newton method and \sphinxstyleemphasis{h} adaptivity
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/vi-2d-PETSc.edp}{vi\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Variational inequalities
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Time steppers and optimizers}
\label{\detokenize{documentation/petsc/examples:time-steppers-and-optimizers}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Filename
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comments (preconditioners, numerical schemes)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/advection-TS-2d-PETSc.edp}{advection\sphinxhyphen{}TS\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Implicit and explicit schemes
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/heat-TS-2d-PETSc.edp}{heat\sphinxhyphen{}TS\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/heat-TS-RHS-2d-PETSc.edp}{heat\sphinxhyphen{}TS\sphinxhyphen{}RHS\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/minimal-surface-Tao-2d-PETSc.edp}{minimal\sphinxhyphen{}surface\sphinxhyphen{}Tao\sphinxhyphen{}2d\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Minimal surface problem
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/orego-Tao-PETSc.edp}{orego\sphinxhyphen{}Tao\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/toy-Tao-PETSc.edp}{toy\sphinxhyphen{}Tao\sphinxhyphen{}PETSc.edp}
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Eigenvalue problems}
\label{\detokenize{documentation/petsc/examples:eigenvalue-problems}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Filename
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comments (preconditioners, numerical schemes)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-2d-SLEPc.edp}{laplace\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-spherical-harmonics-2d-SLEPc.edp}{laplace\sphinxhyphen{}spherical\sphinxhyphen{}harmonics\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-torus-2d-SLEPc.edp}{laplace\sphinxhyphen{}torus\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-axial-well-2d-SLEPc.edp}{schrodinger\sphinxhyphen{}axial\sphinxhyphen{}well\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-harmonic-oscillator-1d-SLEPc.edp}{schrodinger\sphinxhyphen{}harmonic\sphinxhyphen{}oscillator\sphinxhyphen{}1d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-harmonic-oscillator-2d-SLEPc.edp}{schrodinger\sphinxhyphen{}harmonic\sphinxhyphen{}oscillator\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/schrodinger-square-well-1d-SLEPc.edp}{schrodinger\sphinxhyphen{}square\sphinxhyphen{}well\sphinxhyphen{}1d\sphinxhyphen{}SLEPc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-2d-SLEPc-complex.edp}{laplace\sphinxhyphen{}2d\sphinxhyphen{}SLEPc\sphinxhyphen{}complex.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-beltrami-3d-surf-SLEPc.edp}{laplace\sphinxhyphen{}beltrami\sphinxhyphen{}3d\sphinxhyphen{}surf\sphinxhyphen{}SLEPc.edp}
&
\sphinxAtStartPar
Eigenvalue problem on a surface
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/laplace-beltrami-3d-line-SLEPc.edp}{laplace\sphinxhyphen{}beltrami\sphinxhyphen{}3d\sphinxhyphen{}line\sphinxhyphen{}SLEPc.edp}
&
\sphinxAtStartPar
Eigenvalue problem on a curve
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/navier-stokes-2d-SLEPc-complex.edp}{navier\sphinxhyphen{}stokes\sphinxhyphen{}2d\sphinxhyphen{}SLEPc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
Linear stability analysis of Navier\textendash{}Stokes equations
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/stokes-2d-SLEPc.edp}{stokes\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&
\sphinxAtStartPar
Inf\sphinxhyphen{}sup constant of Stokes equations
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/helmholtz-2d-SLEPc-complex.edp}{helmholtz\sphinxhyphen{}2d\sphinxhyphen{}SLEPc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
SVD of the discretized Helmholtz equation
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/mf-2d-SLEPc.edp}{mf\sphinxhyphen{}2d\sphinxhyphen{}SLEPc.edp}
&
\sphinxAtStartPar
Matrix\sphinxhyphen{}free SVD with user\sphinxhyphen{}provided matrix\textendash{}vector and matrix transpose\textendash{}vector multiplications
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/nonlinear-2d-SLEPc-complex.edp}{nonlinear\sphinxhyphen{}2d\sphinxhyphen{}SLEPc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
Nonlinear eigenvalue problem Ax = sqrt(lambda)x
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/blasius-stability-1d-SLEPc-complex.edp}{blasius\sphinxhyphen{}stability\sphinxhyphen{}1d\sphinxhyphen{}SLEPc\sphinxhyphen{}complex.edp}
&
\sphinxAtStartPar
Polynomial eigenvalue problem (A2 lambda\textasciicircum{}2 x + A1 lambda + A0)x = 0
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Miscellaneous}
\label{\detokenize{documentation/petsc/examples:miscellaneous}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Filename
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Comments (preconditioners, numerical schemes)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/transpose-solve-PETSc.edp}{transpose\sphinxhyphen{}solve\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Solving a transposed system
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/Schur-complement-PETSc.edp}{Schur\sphinxhyphen{}complement\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Computing an exact Schur complement
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/block-PETSc.edp}{block\sphinxhyphen{}PETSc.edp}
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/buildRecursive.edp}{buildRecursive.edp}
&
\sphinxAtStartPar
Recursive mesh partitioning (for geometric multigrid)
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/withPartitioning.edp}{withPartitioning.edp}
&
\sphinxAtStartPar
Connectivity construction with a user\sphinxhyphen{}supplied partitioning
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/createPartition.edp}{createPartition.edp}
&
\sphinxAtStartPar
Creation of different partitions of unity using the same DD
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/save-load-Dmesh.edp}{save\sphinxhyphen{}load\sphinxhyphen{}Dmesh.edp}
&
\sphinxAtStartPar
Saving and loading a distributed mesh for restarting a computation
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/transfer.edp}{transfer.edp}
&
\sphinxAtStartPar
Parallel interpolation of finite element functions
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/reconstructDmesh.edp}{reconstructDmesh.edp}
&
\sphinxAtStartPar
Construction of a distributed mesh from sequential nonoverlapping meshes
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/distributed-parmmg.edp}{distributed\sphinxhyphen{}parmmg.edp}
&
\sphinxAtStartPar
Distributed ParMmg interface for mesh adaptation
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/redistributeDmesh.edp}{redistributeDmesh.edp}
&
\sphinxAtStartPar
Gather and scatter a Dmesh on different MPI communicators
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/DMPlex-PETSc.edp}{DMPlex\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Load and partition a mesh using a DM in two and three dimensions
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/function-PETSc.edp}{function\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Custom plugin showing how to directly access PETSc in C++
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/convect.edp}{convect.edp}
&
\sphinxAtStartPar
Calling the convert FreeFEM function on a distributed mesh
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/hpddm/MatLoad-PETSc.edp}{MatLoad\sphinxhyphen{}PETSc.edp}
&
\sphinxAtStartPar
Loading a distributed matrix/vector with various formats
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsubsection{Reproducible science}
\label{\detokenize{documentation/petsc/examples:reproducible-science}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Article
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Source code
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://www.sciencedirect.com/science/article/pii/S0045782519301914}{Augmented Lagrangian preconditioner for large\sphinxhyphen{}scale hydrodynamic stability analysis}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/prj-/moulin2019al}{GitHub repository}
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://hal.archives-ouvertes.fr/hal-02151184/document}{A multilevel Schwarz preconditioner based on a hierarchy of robust coarse spaces}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/prj-/aldaas2019multi}{GitHub repository}
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://www.sciencedirect.com/science/article/pii/S0898122121000055}{KSPHPDDM and PCHPDDM: extending PETSc with advanced Krylov methods and robust multilevel overlapping Schwarz preconditioners}
&
\sphinxAtStartPar
\sphinxhref{https://github.com/prj-/jolivet2020petsc}{GitHub repository}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Plugins}
\label{\detokenize{documentation/plugins:plugins}}\label{\detokenize{documentation/plugins::doc}}

\subsection{gsl}
\label{\detokenize{documentation/plugins:gsl}}
\sphinxAtStartPar
The interface with \sphinxcode{\sphinxupquote{gsl}} spline is available in \sphinxstylestrong{FreeFEM}, the seven kind of spline are
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterpcspline}}: default type of spline

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterpakima}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterpsteffen}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterplinear}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterppolynomial}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterpcsplineperiodic}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gslinterpakimaperiodic}}

\end{enumerate}

\sphinxAtStartPar
A brief wing example given all the syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gsl}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//data points to define the spline}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//set data points}
   \PYG{k+kt}{real} \PYG{n}{xx} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{yy} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{xx}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{;}
   \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{yy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// GSL splines}
\PYG{k+kt}{gslspline} \PYG{n}{spline1}\PYG{p}{(}\PYG{n+nf}{gslinterpcspline}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline1}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline11}\PYG{p}{(}\PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline11}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline2}\PYG{p}{(}\PYG{n+nf}{gslinterpsteffen}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline2}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline3}\PYG{p}{(}\PYG{n+nf}{gslinterpcspline}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{gslspline} \PYG{n+nf}{spline33}\PYG{p}{(}\PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dspline}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//define the spline3}
\PYG{n}{spline1} \PYG{o}{=} \PYG{n}{spline2}\PYG{p}{;} \PYG{c+c1}{//copy spline2 in spline1}

\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{s1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ds1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{.}\PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the derivative of function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1.d(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ds1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dds1} \PYG{o}{=} \PYG{n}{spline1}\PYG{p}{.}\PYG{n+nf}{dd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//evaluate the second derivative of function spline1 at t}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{spline1.dd(t) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dds1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This can be usefull to build function from data value.

\sphinxAtStartPar
The list of all \sphinxcode{\sphinxupquote{gsl}} functions and the \sphinxstylestrong{FreeFEM} equivalent is available in the {\hyperref[\detokenize{references/external-libraries:referenceffgslawk}]{\sphinxcrossref{\DUrole{std,std-ref}{Language references}}}} (same names without \sphinxcode{\sphinxupquote{\_}}).


\subsection{ffrandom}
\label{\detokenize{documentation/plugins:ffrandom}}
\sphinxAtStartPar
Plugin to linux \sphinxcode{\sphinxupquote{random}} functions.

\sphinxAtStartPar
The range of the random generator is from \(0\) to \((2^{31})-1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffrandom}\PYG{l+s}{\PYGZdq{}}

\PYG{n+nf}{srandomdev}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set a true random seed}
\PYG{c+c1}{//warning: under window this command}
\PYG{c+c1}{//change the seed by randinit(random())) so all}
\PYG{c+c1}{//FreeFEM random function are changed}

\PYG{k+kt}{int} \PYG{n}{maxrang} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{31} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max range }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{maxrang} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{srandom}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{random}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{mmap / semaphore}
\label{\detokenize{documentation/plugins:mmap-semaphore}}
\sphinxAtStartPar
The idea is just try to use Interprocess communication using POSIX Shared Memory in Linux.

\sphinxAtStartPar
We build a small library \sphinxcode{\sphinxupquote{libff\sphinxhyphen{}mmap\sphinxhyphen{}semaphore.c}} and \sphinxcode{\sphinxupquote{libff\sphinxhyphen{}mmap\sphinxhyphen{}semaphore.h}} to easily interface.
\begin{itemize}
\item {} 
\sphinxAtStartPar
mmap \sphinxhyphen{} allocate memory, or map files or devices into memory

\item {} 
\sphinxAtStartPar
semaphore \sphinxhyphen{} allow processes and threads to synchronize their actions

\sphinxAtStartPar
A semaphore is an integer whose value is never allowed to fall below zero.
Two operations can be performed on semaphores: increment the semaphore value by one (\sphinxcode{\sphinxupquote{sem\_post}}); and decrement the semaphore value by one (\sphinxcode{\sphinxupquote{sem\_wait}}).

\sphinxAtStartPar
If the value of a semaphore is currently zero, then a \sphinxcode{\sphinxupquote{sem\_wait}} operation will block until the value becomes greater than zero.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{The functions of library}

\sphinxAtStartPar
First the \sphinxcode{\sphinxupquote{semaphore}} interface to make synchronization:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{typedef struct FF\_P\_sem *ff\_Psem;}} the pointer to data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ff\_Psem ffsem\_malloc();}} malloc an empty data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffsem\_del(ff\_Psem sem);}} clean and free the pointer

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffsem\_destroy(ff\_Psem sem);}} clean, close the data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffsem\_init0(ff\_Psem sem);}} make a correct empty of the data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffsem\_init(ff\_Psem sem,const char *nmm, int crea);}} create or use a new semaphore

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{long ffsem\_post(ff\_Psem sem);}} \sphinxcode{\sphinxupquote{nlocked}}, the value of the semaphore is incremented, and all threads which are waiting on the semaphore are awakened

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{long ffsem\_wait(ff\_Psem sem);}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is locked.
When calling \sphinxcode{\sphinxupquote{sem\_wait()}}, if the semaphore’s value is zero, the calling thread will block until the lock is acquired or until the call is interrupted by a signal.

\sphinxAtStartPar
Alternatively, the \sphinxcode{\sphinxupquote{sem\_trywait()}} function will fail if the semaphore is already locked, rather than blocking on the semaphore

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{long ffsem\_trywait(ff\_Psem p);}}

\end{itemize}

\sphinxAtStartPar
Secondly, the \sphinxcode{\sphinxupquote{mmap}} functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{typedef struct FF\_P\_mmap *ff\_Pmmap;}} the pointer to data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ff\_Psem ffmmap\_malloc();}} malloc an empty data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffmmap\_del(ff\_Pmmap p);}} clean and free the pointer

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffmmap\_destroy(ff\_Pmmap p);}} clean, close the data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffmmap\_init0(ff\_Pmmap p);}} make a correct empty of the data structure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{long ffmmap\_msync(ff\_Pmmap p, long off, long ln);}} call writes modified whole pages back to the filesystem and updates the file modification time.
Only those pages containing \sphinxcode{\sphinxupquote{addr}} and \sphinxcode{\sphinxupquote{len\sphinxhyphen{}1}} succeeding locations will be examined.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{void ffmmap\_init(ff\_Pmmap p, const char *nmm, long len);}} allocate memory, or map files or devices into memory.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{long ffmmap\_read(ff\_Pmmap p, void *t, size\_t n, size\_t off);}} read \sphinxcode{\sphinxupquote{n}} bytes from the \sphinxcode{\sphinxupquote{mmap}} at memory \sphinxcode{\sphinxupquote{off}} in pointer \sphinxcode{\sphinxupquote{t}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{long ffmmap\_write(ff\_Pmmap p, void *t, size\_t n, size\_t off);}} write \sphinxcode{\sphinxupquote{n}} bytes to the \sphinxcode{\sphinxupquote{mmap}} at memory \sphinxcode{\sphinxupquote{off}} in pointer \sphinxcode{\sphinxupquote{t}}.

\end{itemize}

\sphinxAtStartPar
The \sphinxstylestrong{FreeFEM} corresponding functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Pmmap sharedata(filename, 1024);}} new type to store the \sphinxcode{\sphinxupquote{mmap}} informations of name store in string \sphinxcode{\sphinxupquote{filename}} with 1024 is the size the \sphinxcode{\sphinxupquote{sharedata}} zone and file.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Psemaphore smff("ff\sphinxhyphen{}slave", creat);}} new type to store the semaphore of name \sphinxcode{\sphinxupquote{ff\sphinxhyphen{}slave}} where \sphinxcode{\sphinxupquote{creat}} is a boolean to create or use a existing semaphore.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wait(sem)}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is locked.
When calling \sphinxcode{\sphinxupquote{Wait(sem)}}, if the semaphore’s value is zero, the calling thread will block until the lock is acquired or until the call is interrupted by a signal.
Alternatively, the \sphinxcode{\sphinxupquote{trywait(sem)}} function will fail if the semaphore is already locked, rather than blocking on the semaphore.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Post(sem)}} the semaphore referenced by \sphinxcode{\sphinxupquote{sem}} is unlocked, the value of the semaphore is incremented, and all threads which are waiting on the semaphore are awakened.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Read(sharedata ,offset, data);}} read the variable \sphinxcode{\sphinxupquote{data}} from the place \sphinxcode{\sphinxupquote{offset}} in \sphinxcode{\sphinxupquote{sharedata}} mmap.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Write(sharedata, offset, data);}} write the variable \sphinxcode{\sphinxupquote{data}} at the place \sphinxcode{\sphinxupquote{offset}} in \sphinxcode{\sphinxupquote{sharedata}} mmap.

\end{itemize}

\sphinxAtStartPar
The full example:

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{FFMaster.c}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}libff\PYGZhy{}mmap\PYGZhy{}semaphore.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}unistd.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdlib.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{n}{ff\PYGZus{}Psem} \PYG{n}{sem\PYGZus{}ff}\PYG{p}{,} \PYG{n}{sem\PYGZus{}c}\PYG{p}{;} \PYG{c+c1}{//the semaphore for mutex}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{debug} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
   \PYG{n}{ff\PYGZus{}Pmmap} \PYG{n}{shd}\PYG{p}{;}
   \PYG{k+kt}{double} \PYG{n}{cff}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{;}
   \PYG{k+kt}{long} \PYG{n}{status}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{debug} \PYG{o}{=} \PYG{n}{atoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ff\PYGZus{}mmap\PYGZus{}sem\PYGZus{}verb} \PYG{o}{=} \PYG{n}{debug}\PYG{p}{;}

   \PYG{n}{sem\PYGZus{}ff} \PYG{o}{=} \PYG{n}{ffsem\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{sem\PYGZus{}c} \PYG{o}{=} \PYG{n}{ffsem\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{shd} \PYG{o}{=} \PYG{n}{ffmmap\PYGZus{}malloc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ffsem\PYGZus{}init}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}slave1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}init}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}master1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}init}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shared\PYGZhy{}data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{status}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}msync}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{char} \PYG{n}{ff}\PYG{p}{[}\PYG{l+m+mi}{1024}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FreeFem++ FFSlave.edp \PYGZhy{}nw \PYGZhy{}ns \PYGZhy{}v \PYGZpc{}d\PYGZam{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{debug}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{system}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//lauch FF++ in batch no graphics}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cc: before wait}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cc: before wait 0 ff}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter : \PYGZpc{}d }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{cff} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
      \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{cff}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{cff}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffsem\PYGZus{}post}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{debug}\PYG{p}{)} \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ cc: before wait 2}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{ffmmap\PYGZus{}read}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{rff}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{rff}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
      \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ iter = \PYGZpc{}d rff= \PYGZpc{}f}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//end}
   \PYG{n}{ffmmap\PYGZus{}write}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{status}\PYG{p}{,} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{status}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}post}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End Master }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}wait}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}del}\PYG{p}{(}\PYG{n}{sem\PYGZus{}ff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffsem\PYGZus{}del}\PYG{p}{(}\PYG{n}{sem\PYGZus{}c}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{ffmmap\PYGZus{}del}\PYG{p}{(}\PYG{n}{shd}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{FFSlave.edp}} file:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}mmap\PYGZhy{}semaphore}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{Psemaphore} \PYG{n}{smff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}slave1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{Psemaphore} \PYG{n+nf}{smc}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}master1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{Pmmap} \PYG{n+nf}{sharedata}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shared\PYGZhy{}data}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1024}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lab} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{int} \PYG{n}{status} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF status = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cff}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{cff}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Lab}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF: before FF post}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unlock master end init}

\PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{verbosity} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{9}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ FF: before FF wait }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{n+nf}{Wait}\PYG{p}{(}\PYG{n}{smc}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait from cint write ok}
   \PYG{n+nf}{Read}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{Read}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ After wait .. FF }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k}{if}\PYG{p}{(}\PYG{n}{status} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

   \PYG{c+c1}{// Solve}
   \PYG{n}{Pb}\PYG{p}{;}
   \PYG{n}{rff} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u}\PYG{o}{*}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ** FF }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

   \PYG{c+c1}{// Write}
   \PYG{n+nf}{Write}\PYG{p}{(}\PYG{n}{sharedata}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{,} \PYG{n}{rff}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unlock cc}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{Post}\PYG{p}{(}\PYG{n}{smff}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//wait from cint}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ End FreeFEM }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To test this example of coupling \sphinxcode{\sphinxupquote{C}} program and \sphinxstylestrong{FreeFEM} script:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
cc \PYGZhy{}c libff\PYGZhy{}mmap\PYGZhy{}semaphore.c
cc FFMaster.c \PYGZhy{}o FFMaster libff\PYGZhy{}mmap\PYGZhy{}semaphore.o \PYGZhy{}g \PYGZhy{}pthread
ff\PYGZhy{}c++ \PYGZhy{}auto ff\PYGZhy{}mmap\PYGZhy{}semaphore.cpp
./FFMaster
\end{sphinxVerbatim}

\sphinxAtStartPar
The output:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
len \PYG{l+m}{1024} size \PYG{l+m}{0}
len \PYG{l+m}{1024} size \PYG{l+m}{1024}
FF \PYG{n+nv}{status} \PYG{o}{=} \PYG{l+m}{1}
iter : \PYG{l+m}{0}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{10} \PYG{l+m}{1}
** FF \PYG{l+m}{10} \PYG{l+m}{0}.161797
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{0} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.161797
iter : \PYG{l+m}{1}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{11} \PYG{l+m}{1}
** FF \PYG{l+m}{11} \PYG{l+m}{0}.195774
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{1} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.195774
iter : \PYG{l+m}{2}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{12} \PYG{l+m}{1}
** FF \PYG{l+m}{12} \PYG{l+m}{0}.232987
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{2} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.232987
iter : \PYG{l+m}{3}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{13} \PYG{l+m}{1}
** FF \PYG{l+m}{13} \PYG{l+m}{0}.273436
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{3} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.273436
iter : \PYG{l+m}{4}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{14} \PYG{l+m}{1}
** FF \PYG{l+m}{14} \PYG{l+m}{0}.317121
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{4} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.317121
iter : \PYG{l+m}{5}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{15} \PYG{l+m}{1}
** FF \PYG{l+m}{15} \PYG{l+m}{0}.364042
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{5} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.364042
iter : \PYG{l+m}{6}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{16} \PYG{l+m}{1}
** FF \PYG{l+m}{16} \PYG{l+m}{0}.414199
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{6} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.414199
iter : \PYG{l+m}{7}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{17} \PYG{l+m}{1}
** FF \PYG{l+m}{17} \PYG{l+m}{0}.467592
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{7} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.467592
iter : \PYG{l+m}{8}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{18} \PYG{l+m}{1}
** FF \PYG{l+m}{18} \PYG{l+m}{0}.524221
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{8} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.524221
iter : \PYG{l+m}{9}
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{19} \PYG{l+m}{1}
** FF \PYG{l+m}{19} \PYG{l+m}{0}.584086
\PYG{n+nv}{iter} \PYG{o}{=} \PYG{l+m}{9} \PYG{n+nv}{rff}\PYG{o}{=} \PYG{l+m}{0}.584086
End Master
After \PYG{n+nb}{wait} .. FF \PYG{l+m}{19} \PYG{l+m}{0}
\end{sphinxVerbatim}


\section{Developers}
\label{\detokenize{documentation/developers:developers}}\label{\detokenize{documentation/developers::doc}}

\subsection{File formats}
\label{\detokenize{documentation/developers:file-formats}}

\subsubsection{Mesh file data structure}
\label{\detokenize{documentation/developers:mesh-file-data-structure}}\label{\detokenize{documentation/developers:meshfiledatastructure}}
\sphinxAtStartPar
The mesh data structure, output of a mesh generation algorithm, refers to the geometric data structure and in some case to another mesh data structure.

\sphinxAtStartPar
In this case, the fields are

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{MeshVersionFormatted} \PYG{l+m+mi}{0}

\PYG{n}{Dimension} \PYG{p}{[}\PYG{n}{DIM}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{Vertices}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertices}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{n}{X\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{Y\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Z\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{X\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{Y\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Z\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{Edges}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{edges}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}ne}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}ne}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}ne}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{Triangles}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{triangles}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{Quadrilaterals}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{Quadrilaterals}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{n}{Vertex1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex4\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Vertex1\PYGZus{}nq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex2\PYGZus{}nq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex3\PYGZus{}nq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Vertex4\PYGZus{}nq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Ref\PYGZus{}nq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{Geometry}
\PYG{p}{[}\PYG{n}{File} \PYG{n}{name} \PYG{n}{of} \PYG{n}{geometric} \PYG{n}{support}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}

   \PYG{n}{VertexOnGeometricVertex}
   \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertex} \PYG{n}{on} \PYG{n}{geometric} \PYG{n}{vertex}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{VertexGeometry\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvg}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{VertexGeometry\PYGZus{}nvg}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

   \PYG{n}{EdgeOnGeometricEdge}
   \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{geometric} \PYG{n}{edge}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{n}{Edge\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{EdgeGeometry\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Edge\PYGZus{}neg}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{EdgeGeometry\PYGZus{}neg}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{CrackedEdges}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{cracked} \PYG{n}{edges}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{n}{Edge1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Edge2\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{Edge1\PYGZus{}nce}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{Edge2\PYGZus{}nce}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
When the current mesh refers to a previous mesh, we have in addition

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{MeshSupportOfVertices}
\PYG{p}{[}\PYG{n}{File} \PYG{n}{name} \PYG{n}{of} \PYG{n}{mesh} \PYG{n}{support}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)}

   \PYG{n}{VertexOnSupportVertex}
   \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertex} \PYG{n}{on} \PYG{n}{support} \PYG{n}{vertex}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{VertexSupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvsv}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{VertexSupport\PYGZus{}nvsv}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

   \PYG{n}{VertexOnSupportEdge}
   \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertex} \PYG{n}{on} \PYG{n}{support} \PYG{n}{edge}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{EdgeSupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvse}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{EdgeSupport\PYGZus{}nvse}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvse}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}

   \PYG{n}{VertexOnSupportTriangle}
   \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertex} \PYG{n}{on} \PYG{n}{support} \PYG{n}{triangle}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvst}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}nvst}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvst}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}nvst}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}

   \PYG{n}{VertexOnSupportQuadrilaterals}
   \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertex} \PYG{n}{on} \PYG{n}{support} \PYG{n}{quadrilaterals}\PYG{p}{]}
   \PYG{n}{Vertex\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
   \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{n}{Vertex\PYGZus{}nvsq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{TriangleSupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{USupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{VSupport\PYGZus{}nvsq}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nv}} means the number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ne}} means the number of edges

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nt}} means the number of triangles

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nq}} means the number of quadrilaterals

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nvg}} means the number of vertex on geometric vertex

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{neg}} means the number of edges on geometric edge

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nce}} means the number of cracked edges

\end{itemize}


\subsubsection{bb file type to Store Solutions}
\label{\detokenize{documentation/developers:bb-file-type-to-store-solutions}}
\sphinxAtStartPar
The file is formatted such that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{2} \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertices}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{l+m+mi}{2}

\PYG{n}{U\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}ns\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ns}} means the number of solutions

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nv}} means the number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{U\_i\_j}} is the solution component \sphinxcode{\sphinxupquote{i}} at the vertex \sphinxcode{\sphinxupquote{j}} on the associated mesh.

\end{itemize}


\subsubsection{BB file type to store solutions}
\label{\detokenize{documentation/developers:id1}}
\sphinxAtStartPar
The file is formatted such that:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{2} \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{[}\PYG{n}{Type} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{[}\PYG{n}{Type} \PYG{n}{ns}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertices}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{l+m+mi}{2}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}nbv\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}ns}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}1\PYGZus{}ns}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}nbv\PYGZus{}ns}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{type\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}nbv\PYGZus{}ns}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ns}} means the number of solutions

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{type\_k}} mean the type of solution \sphinxcode{\sphinxupquote{k}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
1: the solution is scalar (1 value per vertex)

\item {} 
\sphinxAtStartPar
2: the solution is vectorial (2 values per vertex)

\item {} 
\sphinxAtStartPar
3: the solution is a \(2\times 2\) symmetric matrix (3 values per vertex)

\item {} 
\sphinxAtStartPar
4: the solution is a \(2\times 2\) matrix (4 values per vertex)

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbv}} means the number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{U\_i\_j\_k}} is the value of the component \sphinxcode{\sphinxupquote{i}} of the solution
\sphinxcode{\sphinxupquote{k}} at vertex \sphinxcode{\sphinxupquote{j}} on the associated mesh

\end{itemize}


\subsubsection{Metric file}
\label{\detokenize{documentation/developers:metric-file}}
\sphinxAtStartPar
A metric file can be of two types, isotropic or anisotropic.

\sphinxAtStartPar
The isotropic file is such that

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertices}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{l+m+mi}{1}
\PYG{n}{h\PYGZus{}0}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{h\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nv}} is the number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{h\_i}} is the wanted mesh size near the vertex \sphinxcode{\sphinxupquote{i}} on associated mesh.

\end{itemize}

\sphinxAtStartPar
The metric is \(\mathcal{M}_i = h_i^{-2}I\) where \(I\) is the identity matrix.

\sphinxAtStartPar
The anisotropic file is such that

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{vertices}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{l+m+mi}{3}
\PYG{n}{a11\PYGZus{}0}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{a21\PYGZus{}0}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{a22\PYGZus{}0}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{a11\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{a21\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{n}{a22\PYGZus{}nv}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nv}} is the number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a11\_i}}, \sphinxcode{\sphinxupquote{a21\_i}} and \sphinxcode{\sphinxupquote{a22\_i}} represent metric \(\mathcal{M}_i = \left(\begin{array}{cc}a_{11,i} & a_{12,i}\\a{12}_i & a_{22,i}\end{array}\right)\) which define the wanted size in a vicinity of the vertex \sphinxcode{\sphinxupquote{i}} such that \(h\) in direction \(u \in \mathbb{R}^2\) is equal to \(|u|/\sqrt{u\cdot\mathcal{M}_i\, u}\), where \(\cdot\) is the dot product in \(\mathbb{R}^2\), and \(|\cdot|\) is the classical norm.

\end{itemize}


\subsubsection{List of AM\_FMT, AMDBA Meshes}
\label{\detokenize{documentation/developers:list-of-am-fmt-amdba-meshes}}
\sphinxAtStartPar
The mesh is only composed of triangles and can be defined with the help of the following two integers and four arrays:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbt}} the number of triangles

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbv}} the number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nu(1:3, 1:nbt)}} an integer array giving the three vertex numbers counterclockwise for each triangle

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c(1:2, 1:nbv)}} a real array giving tje two coordinates of each vertex

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refs(1:nbv)}} an integer array giving the reference numbers of the vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reft(1:nbt)}} an integer array giving the reference numbers of the triangles

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{AM\_FMT Files}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{am\_fmt}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.am\PYGZus{}fmt\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{AM Files}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{am}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.am\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}unformatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{n}{reft}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{n}{refs}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{AMDBA Files}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{amdba}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.amdba\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{msh Files}

\sphinxAtStartPar
First, we add the notions of boundary edges
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbbe}} the number of boundary edge

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nube(1:2, 1:nbbe)}} an integer array giving the two vertex numbers of boundary edges

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{refbe(1:nbbe)}} an integer array giving the reference numbers of boundary edges

\end{itemize}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{msh}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.msh\PYGZsq{}}\PYG{p}{,} \PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,} \PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{,} \PYG{n}{nbbe}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{reft}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbt}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{ne}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{refbe}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nbbe}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{ftq Files}

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{Fortran}} the \sphinxcode{\sphinxupquote{ftq}} files are read as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{open}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{k}{file}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}xxx.ftq\PYGZsq{}}\PYG{p}{,}\PYG{n}{form}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}formatted\PYGZsq{}}\PYG{p}{,}\PYG{n}{status}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}old\PYGZsq{}}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{n}{nbv}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{,}\PYG{n}{nbt}\PYG{p}{,}\PYG{n}{nbq}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{n}{k}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{k}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{reft}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbe}\PYG{p}{)}
\PYG{k}{read} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{refs}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbv}\PYG{p}{)}
\PYG{k}{close}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where if \sphinxcode{\sphinxupquote{k(j) = 3}} when the element \sphinxcode{\sphinxupquote{j}} is a triangle and \sphinxcode{\sphinxupquote{k(j) = 4}} when the the element \sphinxcode{\sphinxupquote{j}} is a quadrilateral.


\subsubsection{sol and solb files}
\label{\detokenize{documentation/developers:sol-and-solb-files}}
\sphinxAtStartPar
With the keyword \sphinxcode{\sphinxupquote{savesol}}, we can store a scalar functions, a scalar finite element functions, a vector fields, a vector finite element fields, a symmetric tensor and a symmetric finite element tensor.

\sphinxAtStartPar
Such format is used in \sphinxcode{\sphinxupquote{medit}}.

\sphinxAtStartPar
\sphinxstylestrong{Extension file .sol}

\sphinxAtStartPar
The first two lines of the file are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MeshVersionFormatted 0}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dimension {[}DIM{]}(int)}}

\end{itemize}

\sphinxAtStartPar
The following fields begin with one of the following keyword:
\sphinxcode{\sphinxupquote{SolAtVertices}}, \sphinxcode{\sphinxupquote{SolAtEdges}},
\sphinxcode{\sphinxupquote{SolAtTriangles}}, \sphinxcode{\sphinxupquote{SolAtQuadrilaterals}},
\sphinxcode{\sphinxupquote{SolAtTetrahedra}}, \sphinxcode{\sphinxupquote{SolAtPentahedra}},
\sphinxcode{\sphinxupquote{SolAtHexahedra}}.

\sphinxAtStartPar
In each field, we give then in the next line the number of elements in the solutions (\sphinxcode{\sphinxupquote{SolAtVertices}}: number of vertices, \sphinxcode{\sphinxupquote{SolAtTriangles}}: number of triangles, …).
In other lines, we give the number of solutions, the type of solution (1: scalar, 2: vector, 3: symmetric tensor).
And finally, we give the values of the solutions on the elements.

\sphinxAtStartPar
The file must be ended with the keyword End.

\sphinxAtStartPar
The real element of symmetric tensor :
\begin{equation}\label{equation:documentation/developers:savesol.def.symtensor}
\begin{split}ST^{3d}=\left(
\begin{array}{ccc}
   ST_{xx}^{3d} & ST_{xy}^{3d} & ST_{xz}^{3d}\\
   ST_{yx}^{3d} & ST_{yy}^{3d} & ST_{yz}^{3d} \\
   ST_{zx}^{3d} & ST_{zy}^{3d} & ST_{zz}^{3d}
\end{array}
\right)
\quad
ST^{2d}= \left(
\begin{array}{cc}
   ST_{xx}^{2d} & ST_{xy}^{2d} \\
   ST_{yx}^{2d} & ST_{yy}^{2d}
\end{array}
\right)\end{split}
\end{equation}
\sphinxAtStartPar
stored in the extension \sphinxcode{\sphinxupquote{.sol}} are respectively \(ST_{xx}^{3d}, ST_{yx}^{3d}, ST_{yy}^{3d}, ST_{zx}^{3d}, ST_{zy}^{3d}, ST_{zz}^{3d}\) and \(ST_{xx}^{2d}, ST_{yx}^{2d}, ST_{yy}^{2d}\)

\sphinxAtStartPar
An example of field with the keyword \sphinxcode{\sphinxupquote{SolAtTetrahedra}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{SolAtTetrahedra}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{tetrahedra}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{[}\PYG{n}{Type} \PYG{n}{of} \PYG{n}{solution} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{[}\PYG{n}{Type} \PYG{n}{of} \PYG{n}{soution} \PYG{n}{nt}\PYG{p}{]}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}nrs\PYGZus{}1\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{nrs\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}ns\PYGZus{}1}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}

\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{n}{U\PYGZus{}1\PYGZus{}1\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}nrs\PYGZus{}1\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{n}{U\PYGZus{}1\PYGZus{}ns\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{U\PYGZus{}}\PYG{p}{(}\PYG{n}{nrs\PYGZus{}k}\PYG{p}{)}\PYG{n}{\PYGZus{}ns\PYGZus{}nt}\PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ns}} is the number of solutions

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{typesol\_k}}, type of the solution number \sphinxcode{\sphinxupquote{k}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{typesol\_k = 1}} the solution \sphinxcode{\sphinxupquote{k}} is scalar

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{typesol\_k = 2}} the solution \sphinxcode{\sphinxupquote{k}} is vectorial

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{typesol\_k = 3}} the solution \sphinxcode{\sphinxupquote{k}} is a symmetric tensor or symmetric matrix

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrs\_k}} is the number of real to describe solution \sphinxcode{\sphinxupquote{k}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrs\_k = 1}} if the solution \sphinxcode{\sphinxupquote{k}} is scalar

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrs\_k = dim}} if the solution \sphinxcode{\sphinxupquote{k}} is vectorial (\sphinxcode{\sphinxupquote{dim}} is the dimension of the solution)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nrs\_k = dim*(dim+1)/2}} if the solution k is a symmetric tensor or symmetric matrix

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{U\_i\_j\_\textasciicircum{}k}} is a real equal to the value of the component \sphinxcode{\sphinxupquote{i}} of the solution \sphinxcode{\sphinxupquote{k}} at tetrahedron \sphinxcode{\sphinxupquote{j}} on the associated mesh

\end{itemize}

\sphinxAtStartPar
The format \sphinxcode{\sphinxupquote{.solb}} is the same as format \sphinxcode{\sphinxupquote{.sol}} but in binary (read/write is faster, storage is less).

\sphinxAtStartPar
A real scalar functions \(f1\), a vector fields \(\mathbf{\Phi} = [\Phi1, \Phi2, \Phi3]\) and a symmetric tensor \(ST^{3d}\) \eqref{equation:documentation/developers:savesol.def.symtensor} at the vertices of the three dimensional mesh \sphinxcode{\sphinxupquote{Th3}} is stored in the file \sphinxcode{\sphinxupquote{f1PhiTh3.sol}} using :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savesol}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f1PhiST3dTh3.sol}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Phi}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{VV3}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \(VV3 = [ST_{xx}^{3d}, ST_{yx}^{3d}, ST_{yy}^{3d}, ST_{zx}^{3d}, ST_{zy}^{3d}, ST_{zz}^{3d}]\).

\sphinxAtStartPar
For a two dimensional mesh \sphinxcode{\sphinxupquote{Th}}, A real scalar functions \(f2\), a vector fields \(\mathbf{\Psi} = [\Psi1, \Psi2]\) and a symmetric tensor \(ST^{2d}\) \eqref{equation:documentation/developers:savesol.def.symtensor} at triangles is stored in the file \sphinxcode{\sphinxupquote{f2PsiST2dTh3.solb}} using :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savesol}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f2PsiST2dTh3.solb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Psi}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Psi}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{VV2}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \(VV2 = [ST_{xx}^{2d}, ST_{yx}^{2d}, ST_{yy}^{2d}]\)

\sphinxAtStartPar
The arguments of \sphinxcode{\sphinxupquote{savesol}} functions are the name of a file, a mesh and solutions.
These arguments must be given in this order.

\sphinxAtStartPar
The parameters of this keyword are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{order =}} 0 is the solution is given at the center of gravity of elements.
1 is the solution is given at the vertices of elements.

\end{itemize}

\sphinxAtStartPar
In the file, solutions are stored in this order : scalar solutions, vector solutions and finally symmetric tensor solutions.


\subsection{Adding a new finite element}
\label{\detokenize{documentation/developers:adding-a-new-finite-element}}\label{\detokenize{documentation/developers:developersaddingfiniteelement}}

\subsubsection{Some notations}
\label{\detokenize{documentation/developers:some-notations}}
\sphinxAtStartPar
For a function \(\boldsymbol{f}\) taking value in \(\mathbb{R}^{N},\, N=1,2,\cdots\), we define the finite element approximation \(\Pi_h\boldsymbol{f}\) of \(\boldsymbol{f}\).

\sphinxAtStartPar
Let us denote the number of the degrees of freedom of the finite element by \(NbDoF\).
Then the \(i\)\sphinxhyphen{}th base \(\boldsymbol{\omega}^{K}_{i}\) (\(i=0,\cdots,NbDoF-1\)) of the finite element space has the \(j\)\sphinxhyphen{}th component \(\mathbf{\omega}^{K}_{ij}\) for \(j=0,\cdots,N-1\).

\sphinxAtStartPar
The operator \(\Pi_{h}\) is called the interpolator of the finite element.

\sphinxAtStartPar
We have the identity \(\boldsymbol{\omega}^{K}_{i} = \Pi_{h} \boldsymbol{\omega}^{K}_{i}\).

\sphinxAtStartPar
Formally, the interpolator \(\Pi_{h}\) is constructed by the following formula:
\begin{equation}\label{equation:documentation/developers:eq-interpo}
\begin{split}\Pi_{h} \boldsymbol{f} = \sum_{k=0}^{\mathtt{kPi}-1} \alpha_k \boldsymbol{f}_{j_{k}}(P_{p_{k}}) \boldsymbol{\omega}^{K}_{i_{k}}\end{split}
\end{equation}
\sphinxAtStartPar
where \(P_{p}\) is a set of \(npPi\) points,

\sphinxAtStartPar
In the formula \eqref{equation:documentation/developers:eq-interpo}, the list \(p_{k},\, j_{k},\, i_{k}\) depend just on the type of finite element (not on the element), but the coefficient \(\alpha_{k}\) can be depending on the element.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Classical scalar Lagrange finite element

\sphinxAtStartPar
With the classical scalar Lagrange finite element, we have \(\mathtt{kPi}=\mathtt{npPi}=\mathtt{NbOfNode}\) and
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(P_{p}\) is the point of the nodal points.

\item {} 
\sphinxAtStartPar
the \(\alpha_k=1\), because we take the value of the function at the point \(P_{k}\).

\item {} 
\sphinxAtStartPar
\(p_{k}=k\) , \(j_{k}=k\) because we have one node per function.

\item {} 
\sphinxAtStartPar
\(j_{k}=0\) because \(N=1\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
The Raviart\sphinxhyphen{}Thomas finite element
\begin{equation}\label{equation:documentation/developers:eq:RT0-fe}
\begin{split}RT0_{h} = \{ \mathbf{v} \in H(div) / \forall K \in
\mathcal{T}_{h} \quad \mathbf{v}_{|K}(x,y) =
\vecttwo{\alpha_{K}}{\beta_{K}} + \gamma_{K}\vecttwo{x}{y} \}\end{split}
\end{equation}
\sphinxAtStartPar
The degrees of freedom are the flux through an edge \(e\) of the mesh, where the flux of the function \(\mathbf{f} : \mathbb{R}^2 \longrightarrow \mathbb{R}^2\) is \(\int_{e} \mathbf{f}.n_{e}\), \(n_{e}\) is the unit normal of edge \(e\) (this implies a orientation of all the edges of the mesh, for example we can use the global numbering of the edge vertices and we just go to small to large number).

\sphinxAtStartPar
To compute this flux, we use a quadrature formula with one point, the middle point of the edge.
Consider a triangle \(T\) with three vertices \((\mathbf{a},\mathbf{b},\mathbf{c})\).

\sphinxAtStartPar
Let denote the vertices numbers by \(i_{a},i_{b},i_{c}\), and define the three edge vectors \(\mathbf{e}^{0},\mathbf{e}^{1},\mathbf{e}^{2}\) by \(sgn(i_{b}-i_{c})(\mathbf{b}-\mathbf{c})\), \(sgn(i_{c}-i_{a})(\mathbf{c}-\mathbf{a})\), \(sgn(i_{a}-i_{b})(\mathbf{a}-\mathbf{b})\).

\sphinxAtStartPar
The three basis functions are:
\begin{equation*}
\begin{split}\boldsymbol{\omega}^{K}_{0}= \frac{sgn(i_{b}-i_{c})}{2|T|}(x-a),\quad \boldsymbol{\omega}^{K}_{1}= \frac{sgn(i_{c}-i_{a})}{2|T|}(x-b),\quad \boldsymbol{\omega}^{K}_{2}= \frac{sgn(i_{a}-i_{b})}{2|T|}(x-c),\end{split}
\end{equation*}
\sphinxAtStartPar
where \(|T|\) is the area of the triangle \(T\).

\sphinxAtStartPar
So we have \(N=2\), \(\mathtt{kPi}=6; \mathtt{npPi}=3;\) and:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(P_{p} = \left\{\frac{\mathbf{b}+\mathbf{c}}{2}, \frac{\mathbf{a}+\mathbf{c}}{2}, \frac{\mathbf{b}+\mathbf{a}}{2} \right\}\)

\item {} \begin{description}
\item[{\(\alpha_{0}= - \mathbf{e}^{0}_{2}, \alpha_{1}= \mathbf{e}^{0}_{1}\),}] \leavevmode
\sphinxAtStartPar
\(\alpha_{2}= - \mathbf{e}^{1}_{2}, \alpha_{3}= \mathbf{e}^{1}_{1}\),
\(\alpha_{4}= - \mathbf{e}^{2}_{2}, \alpha_{5}= \mathbf{e}^{2}_{1}\) (effectively, the vector
\((-\mathbf{e}^{m}_{2}, \mathbf{e}^{m}_{1})\) is orthogonal to the edge \(\mathbf{e}^{m}= (e^m_{1},e^m_{2})\) with
a length equal to the side of the edge or equal to \(\int_{e^m} 1\)).

\end{description}

\item {} 
\sphinxAtStartPar
\(i_{k}=\{0,0,1,1,2,2\}\),

\item {} 
\sphinxAtStartPar
\(p_{k}=\{0,0,1,1,2,2\}\) , \(j_{k}=\{0,1,0,1,0,1,0,1\}\).

\end{itemize}
\end{sphinxadmonition}


\subsubsection{Which class to add?}
\label{\detokenize{documentation/developers:which-class-to-add}}
\sphinxAtStartPar
Add file \sphinxcode{\sphinxupquote{FE\_ADD.cpp}} in directory \sphinxcode{\sphinxupquote{FreeFem\sphinxhyphen{}sources/src/femlib}} for
example first to initialize :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}error.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}rgraph.hpp\PYGZdq{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}RNM.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}fem.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}FESpace.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}AddNewFE.h\PYGZdq{}}

\PYG{k}{namespace} \PYG{n}{Fem2D} \PYG{p}{\PYGZob{}} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then add a class which derive for \sphinxcode{\sphinxupquote{public TypeOfFE}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{TypeOfFE\PYGZus{}RTortho} \PYG{o}{:} \PYG{k}{public} \PYG{n}{TypeOfFE} \PYG{p}{\PYGZob{}} \PYG{k}{public}\PYG{o}{:}
    \PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{Data}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//some numbers}
    \PYG{n}{TypeOfFE\PYGZus{}RTortho}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}
    \PYG{n}{TypeOfFE}\PYG{p}{(}
        \PYG{l+m+mi}{0}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{p}{,}  \PYG{c+c1}{//nb degree of freedom on element}
        \PYG{l+m+mi}{2}\PYG{p}{,}      \PYG{c+c1}{//dimension N of vectorial FE (1 if scalar FE)}
        \PYG{n}{Data}\PYG{p}{,}   \PYG{c+c1}{//the array data}
        \PYG{l+m+mi}{1}\PYG{p}{,}      \PYG{c+c1}{//nb of subdivision for plotting}
        \PYG{l+m+mi}{1}\PYG{p}{,}      \PYG{c+c1}{//nb of sub finite element (generaly 1)}
        \PYG{l+m+mi}{6}\PYG{p}{,}      \PYG{c+c1}{//number kPi of coef to build the interpolator}
        \PYG{l+m+mi}{3}\PYG{p}{,}      \PYG{c+c1}{//number npPi of integration point to build interpolator}
        \PYG{l+m+mi}{0}       \PYG{c+c1}{//an array to store the coef \PYGZbs{}alpha\PYGZus{}k to build interpolator}
        \PYG{c+c1}{//here this array is no constant so we have}
        \PYG{c+c1}{//to rebuilt for each element}
    \PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{const} \PYG{n}{R2} \PYG{n}{Pt}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{R2}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{R2}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{R2}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
        \PYG{c+c1}{// the set of Point in hat\PYGZob{}K\PYGZcb{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{kk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{p} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{p}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{P\PYGZus{}Pi\PYGZus{}h}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Pt}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{n}{pij\PYGZus{}alpha}\PYG{p}{[}\PYG{n}{kk}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{IPJ}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}} \PYG{c+c1}{//definition of i\PYGZus{}k, p\PYGZus{}k, j\PYGZus{}k in interpolator}

    \PYG{k+kt}{void} \PYG{n}{FB}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{*}\PYG{n}{watdd}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Triangle} \PYG{o}{\PYGZam{}}\PYG{n}{K}\PYG{p}{,}
        \PYG{k}{const} \PYG{n}{R2} \PYG{o}{\PYGZam{}}\PYG{n}{PHat}\PYG{p}{,} \PYG{n}{RNMK\PYGZus{}} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

    \PYG{k+kt}{void} \PYG{n+nf}{Pi\PYGZus{}h\PYGZus{}alpha}\PYG{p}{(}\PYG{k}{const} \PYG{n}{baseFElement} \PYG{o}{\PYGZam{}}\PYG{n}{K}\PYG{p}{,} \PYG{n}{KN\PYGZus{}}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the array data is formed with the concatenation of five array of
size \sphinxcode{\sphinxupquote{NbDoF}} and one array of size \sphinxcode{\sphinxupquote{N}}.

\sphinxAtStartPar
This array is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{TypeOfFE\PYGZus{}RTortho}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Data}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//for each df 0, 1, 3:}
    \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{c+c1}{//the support of the node of the df}
    \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{c+c1}{//the number of the df on the node}
    \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{c+c1}{//the node of the df}
    \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{c+c1}{//the df come from which FE (generally 0)}
    \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{c+c1}{//which are the df on sub FE}
    \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}
\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//for each component j=0, N\PYGZhy{}1 it give the sub FE associated}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the support is a number \(0,1,2\) for vertex support, \(3,4,5\) for edge support, and finally \(6\) for element support.

\sphinxAtStartPar
The function to defined the function
\(\boldsymbol{\omega}^{K}_{i}\), this function return the value of all the basics function or this derivatives in array \sphinxcode{\sphinxupquote{val}}, computed at point \sphinxcode{\sphinxupquote{Phat}} on the reference triangle corresponding to point \sphinxcode{\sphinxupquote{R2 P=K(Phat);}} on the current triangle \sphinxcode{\sphinxupquote{K}}.

\sphinxAtStartPar
The index \(i,j,k\) of the array \(val(i,j,k)\) correspond to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(i\) is the basic function number on finite element
\(i \in [0,NoF[\)

\item {} 
\sphinxAtStartPar
\(j\) is the value of component \(j \in [0,N[\)

\item {} 
\sphinxAtStartPar
\(k\) is the type of computed value
\(f(P),dx(f)(P), dy(f)(P), ...\ i \in [0,\mathtt{last\_operatortype}[\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
For optimization, this value is computed only if \sphinxcode{\sphinxupquote{whatd{[}k{]}}} is true, and the numbering is defined with

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{enum} \PYG{n}{operatortype} \PYG{p}{\PYGZob{}}
\PYG{n}{op\PYGZus{}id} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{op\PYGZus{}dy} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dxx} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{op\PYGZus{}dyy} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dyx} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{op\PYGZus{}dxy} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dz} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzz} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzx} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{n}{op\PYGZus{}dxz} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{,}
\PYG{n}{op\PYGZus{}dzy} \PYG{o}{=} \PYG{l+m+mi}{9}\PYG{p}{,} \PYG{n}{op\PYGZus{}dyz} \PYG{o}{=} \PYG{l+m+mi}{9}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}operatortype} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\end{itemize}

\sphinxAtStartPar
The shape function:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n}{TypeOfFE\PYGZus{}RTortho}\PYG{o}{:}\PYG{o}{:}\PYG{n}{FB}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{bool} \PYG{o}{*}\PYG{n}{whatd}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Triangle} \PYG{o}{\PYGZam{}} \PYG{n}{K}\PYG{p}{,}
    \PYG{k}{const} \PYG{n}{R2} \PYG{o}{\PYGZam{}}\PYG{n}{PHat}\PYG{p}{,}\PYG{n}{RNMK\PYGZus{}} \PYG{o}{\PYGZam{}}\PYG{n}{val}\PYG{p}{)} \PYG{k}{const}
\PYG{p}{\PYGZob{}}
    \PYG{n}{R2} \PYG{n}{P}\PYG{p}{(}\PYG{n}{K}\PYG{p}{(}\PYG{n}{PHat}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{R2} \PYG{n+nf}{A}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{B}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{C}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{R} \PYG{n}{l0} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}} \PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n}{R} \PYG{n}{l1} \PYG{o}{=} \PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{p}{,} \PYG{n}{l2} \PYG{o}{=} \PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
    \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{N}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{M}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{val} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{R} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{K}\PYG{p}{.}\PYG{n}{area}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{R} \PYG{n}{a0} \PYG{o}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{*} \PYG{n}{a}\PYG{p}{;}
    \PYG{n}{R} \PYG{n}{a1} \PYG{o}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{*} \PYG{n}{a}\PYG{p}{;}
    \PYG{n}{R} \PYG{n}{a2} \PYG{o}{=} \PYG{n}{K}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{a}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{p}{[}\PYG{n}{op\PYGZus{}id}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//value of the function}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{op\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{RN\PYGZus{}} \PYG{n+nf}{f0}\PYG{p}{(}\PYG{n}{val}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//value first component}
        \PYG{n}{RN\PYGZus{}} \PYG{n+nf}{f1}\PYG{p}{(}\PYG{n}{val}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//value second component}
        \PYG{n}{f1}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{A}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a0}\PYG{p}{;}

        \PYG{n}{f1}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{B}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{B}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a1}\PYG{p}{;}

        \PYG{n}{f1}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a2}\PYG{p}{;}
        \PYG{n}{f0}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y} \PYG{o}{\PYGZhy{}} \PYG{n}{C}\PYG{p}{.}\PYG{n}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{p}{[}\PYG{n}{op\PYGZus{}dx}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//value of the dx of function}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{op\PYGZus{}dx}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{o}{=} \PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{op\PYGZus{}dx}\PYG{p}{)} \PYG{o}{=} \PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{p}{[}\PYG{n}{op\PYGZus{}dy}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{assert}\PYG{p}{(}\PYG{n}{val}\PYG{p}{.}\PYG{n}{K}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{op\PYGZus{}dy}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a0}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a1}\PYG{p}{;}
        \PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{op\PYGZus{}dy}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{last\PYGZus{}operatortype}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{whatd}\PYG{p}{[}\PYG{n}{op\PYGZus{}dx}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{assert}\PYG{p}{(}\PYG{n}{op\PYGZus{}dy}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function to defined the coefficient \(\alpha_{k}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{void} \PYG{n}{TypeOfFE\PYGZus{}RT}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Pi\PYGZus{}h\PYGZus{}alpha}\PYG{p}{(}\PYG{k}{const} \PYG{n}{baseFElement} \PYG{o}{\PYGZam{}}\PYG{n}{K}\PYG{p}{,} \PYG{n}{KN\PYGZus{}}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{v}\PYG{p}{)} \PYG{k}{const}
\PYG{p}{\PYGZob{}}
    \PYG{k}{const} \PYG{n}{Triangle} \PYG{o}{\PYGZam{}}\PYG{n}{T}\PYG{p}{(}\PYG{n}{K}\PYG{p}{.}\PYG{n}{T}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{R2} \PYG{n}{E}\PYG{p}{(}\PYG{n}{T}\PYG{p}{.}\PYG{n}{Edge}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{R} \PYG{n}{signe} \PYG{o}{=} \PYG{n}{T}\PYG{p}{.}\PYG{n}{EdgeOrientation}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{signe}\PYG{o}{*}\PYG{n}{E}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{signe}\PYG{o}{*}\PYG{n}{E}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now , we just need to add a new key work in \sphinxstylestrong{FreeFEM}.

\sphinxAtStartPar
Two way, with static or dynamic link so at the end of the file, we add:

\sphinxAtStartPar
\sphinxstylestrong{With dynamic link} it is very simple (see section {\hyperref[\detokenize{documentation/developers:developersdynamicallink}]{\sphinxcrossref{\DUrole{std,std-ref}{Dynamical link}}}}), just add before the end of \sphinxcode{\sphinxupquote{FEM2d namespace}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
   \PYG{k}{static} \PYG{n}{TypeOfFE\PYGZus{}RTortho} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{;}
   \PYG{k}{static} \PYG{n+nf}{AddNewFE}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RT0Ortho}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//FEM2d namespace}
\end{sphinxVerbatim}

\sphinxAtStartPar
Try with \sphinxcode{\sphinxupquote{./load.link}} command in \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{examples++\sphinxhyphen{}load/} and see \sphinxcode{\sphinxupquote{BernardiRaugel.cpp}} or \sphinxcode{\sphinxupquote{Morley.cpp}} new finite element examples.

\sphinxAtStartPar
\sphinxstylestrong{Otherwise with static link} (for expert only), add

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//let the 2 globals variables}
\PYG{k}{static} \PYG{n}{TypeOfFE\PYGZus{}RTortho} \PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{;}
\PYG{c+c1}{//the name in freefem}
\PYG{k}{static} \PYG{n}{ListOfTFE} \PYG{n+nf}{typefemRTOrtho}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{RT0Ortho}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{The\PYGZus{}TypeOfFE\PYGZus{}RTortho}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//link with FreeFEM do not work with static library .a}
\PYG{c+c1}{//so add a extern name to call in init\PYGZus{}static\PYGZus{}FE}
\PYG{c+c1}{//(see end of FESpace.cpp)}
\PYG{k+kt}{void} \PYG{n+nf}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{//end}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//FEM2d namespace}
\end{sphinxVerbatim}

\sphinxAtStartPar
To inforce in loading of this new finite element, we have to add the two new lines close to the end of files \sphinxcode{\sphinxupquote{src/femlib/FESpace.cpp}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//correct problem of static library link with new make file}
\PYG{k+kt}{void} \PYG{n+nf}{init\PYGZus{}static\PYGZus{}FE}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//list of other FE file.o}
    \PYG{k}{extern} \PYG{k+kt}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}P2h}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{init\PYGZus{}FE\PYGZus{}P2h}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
    \PYG{k}{extern} \PYG{k+kt}{void} \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//new line 1}
    \PYG{n}{init\PYGZus{}FE\PYGZus{}ADD}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//new line 2}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and now you have to change the makefile.

\sphinxAtStartPar
First, create a file \sphinxcode{\sphinxupquote{FE\_ADD.cpp}} contening all this code, like in file \sphinxcode{\sphinxupquote{src/femlib/Element\_P2h.cpp}}, after modify the \sphinxcode{\sphinxupquote{Makefile.am}} by adding the name of your file to the variable \sphinxcode{\sphinxupquote{EXTRA\_DIST}} like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ Makefile using Automake + Autoconf}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ Id}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ This is not compiled as a separate library because its}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ interconnections with other libraries have not been solved.}

\PYG{n}{EXTRA\PYGZus{}DIST}\PYG{o}{=}\PYG{n}{BamgFreeFem}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{BamgFreeFem}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{CGNL}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{CheckPtr}\PYG{p}{.}\PYG{n}{cpp}        \PYGZbs{}
\PYG{n}{ConjuguedGradrientNL}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{DOperator}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{Drawing}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{Element\PYGZus{}P2h}\PYG{p}{.}\PYG{n}{cpp}      \PYGZbs{}
\PYG{n}{Element\PYGZus{}P3}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{Element\PYGZus{}RT}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{fem3}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{fem}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{fem}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{FESpace}\PYG{p}{.}\PYG{n}{cpp}      \PYGZbs{}
\PYG{n}{FESpace}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{FESpace}\PYG{o}{\PYGZhy{}}\PYG{n}{v0}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{FQuadTree}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{FQuadTree}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{gibbs}\PYG{p}{.}\PYG{n}{cpp}        \PYGZbs{}
\PYG{n}{glutdraw}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{gmres}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{MatriceCreuse}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{MatriceCreuse\PYGZus{}tpl}\PYG{p}{.}\PYG{n}{hpp}          \PYGZbs{}
\PYG{n}{MeshPoint}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{mortar}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{mshptg}\PYG{p}{.}\PYG{n}{cpp} \PYG{n}{QuadratureFormular}\PYG{p}{.}\PYG{n}{cpp}              \PYGZbs{}
\PYG{n}{QuadratureFormular}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RefCounter}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM\PYGZus{}opc}\PYG{p}{.}\PYG{n}{hpp} \PYG{n}{RNM\PYGZus{}op}\PYG{p}{.}\PYG{n}{hpp}    \PYGZbs{}
\PYG{n}{RNM\PYGZus{}tpl}\PYG{p}{.}\PYG{n}{hpp}     \PYG{n}{FE\PYGZus{}ADD}\PYG{p}{.}\PYG{n}{cpp}
\end{sphinxVerbatim}

\sphinxAtStartPar
and do in the \sphinxstylestrong{FreeFEM} root directory

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
autoreconf
./reconfigure
make
\end{sphinxVerbatim}

\sphinxAtStartPar
For codewarrior compilation add the file in the project an remove the flag in panal PPC linker FreeFm++ Setting Dead\sphinxhyphen{}strip Static Initializition Code Flag.


\subsection{Dynamical link}
\label{\detokenize{documentation/developers:dynamical-link}}\label{\detokenize{documentation/developers:developersdynamicallink}}
\sphinxAtStartPar
Now, it’s possible to add built\sphinxhyphen{}in functionnalites in \sphinxstylestrong{FreeFEM} under the three environnents Linux, Windows and MacOS X 10.3 or newer.

\sphinxAtStartPar
It is agood idea to first try the example \sphinxcode{\sphinxupquote{load.edp}} in directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{example++\sphinxhyphen{}load}.

\sphinxAtStartPar
You will need to install a \sphinxcode{\sphinxupquote{compiler}} (generally \sphinxcode{\sphinxupquote{g++/gcc}} compiler) to compile your function.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Windows Install the \sphinxcode{\sphinxupquote{cygwin}} environnent or the \sphinxcode{\sphinxupquote{mingw}} one

\item {} 
\sphinxAtStartPar
MacOs Install the developer tools \sphinxcode{\sphinxupquote{Xcode}} on the apple DVD

\item {} 
\sphinxAtStartPar
Linux/Unix Install the correct compiler (\sphinxcode{\sphinxupquote{gcc}} for instance)

\end{itemize}

\sphinxAtStartPar
Now, assume that you are in a shell window (a \sphinxcode{\sphinxupquote{cygwin}} window under Windows) in the directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{example++\sphinxhyphen{}load}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the sub directory \sphinxcode{\sphinxupquote{include}}, they are all the \sphinxstylestrong{FreeFEM} include file to make the link with \sphinxstylestrong{FreeFEM}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If you try to load dynamically a file with command \sphinxcode{\sphinxupquote{load "xxx"}}
\sphinxhyphen{} Under Unix (Linux or MacOs), the file \sphinxcode{\sphinxupquote{xxx.so}} will be loaded so it must be either in the search directory of routine \sphinxcode{\sphinxupquote{dlopen}} (see the environment variable \sphinxtitleref{\$LD\_LIBRARY\_PATH}) or in the current directory, and the suffix \sphinxcode{\sphinxupquote{".so"}} or the prefix \sphinxcode{\sphinxupquote{"./"}} is automatically added.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Under Windows, the file \sphinxtitleref{xxx.dll} will be loaded so it must be in the \sphinxtitleref{loadLibary} search directory which includes the directory of the application,

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Compilation of your module:}

\sphinxAtStartPar
The script \sphinxcode{\sphinxupquote{ff\sphinxhyphen{}c++}} compiles and makes the link with \sphinxstylestrong{FreeFEM}, but be careful, the script has no way to known if you try to compile for a pure Windows environment or for a cygwin environment so to build the load module under cygwin you must add the \sphinxcode{\sphinxupquote{\sphinxhyphen{}cygwin}} parameter.


\subsubsection{A first example myfunction.cpp}
\label{\detokenize{documentation/developers:a-first-example-myfunction-cpp}}
\sphinxAtStartPar
The following defines a new function call \sphinxcode{\sphinxupquote{myfunction}} with no parameter, but using the \(x,y\) current value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cfloat\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}error.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}AFunction.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}rgraph.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}RNM.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}fem.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}FESpace.hpp\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}MeshPoint.hpp\PYGZdq{}}

\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{Fem2D}\PYG{p}{;}
\PYG{k+kt}{double} \PYG{n+nf}{myfunction}\PYG{p}{(}\PYG{n}{Stack} \PYG{n}{stack}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//to get FreeFEM data}
    \PYG{n}{MeshPoint} \PYG{o}{\PYGZam{}}\PYG{n}{mp} \PYG{o}{=} \PYG{o}{*}\PYG{n}{MeshPointStack}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the struct to get x, y, normal, value}
    \PYG{k+kt}{double} \PYG{n}{x} \PYG{o}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{P}\PYG{p}{.}\PYG{n}{x}\PYG{p}{;} \PYG{c+c1}{//get the current x value}
    \PYG{k+kt}{double} \PYG{n}{y} \PYG{o}{=} \PYG{n}{mp}\PYG{p}{.}\PYG{n}{P}\PYG{p}{.}\PYG{n}{y}\PYG{p}{;} \PYG{c+c1}{//get the current y value}
    \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}x = \PYGZdq{} \PYGZlt{}\PYGZlt{} x \PYGZlt{}\PYGZlt{} \PYGZdq{} y=\PYGZdq{} \PYGZlt{}\PYGZlt{} y \PYGZlt{}\PYGZlt{} endl;}
    \PYG{k}{return} \PYG{n}{sin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the Problem is to build the link with \sphinxstylestrong{FreeFEM}, to do that we need two classes, one to call the function \sphinxcode{\sphinxupquote{myfunction}}.

\sphinxAtStartPar
All \sphinxstylestrong{FreeFEM} evaluable expression must be a \sphinxcode{\sphinxupquote{C++}} \sphinxcode{\sphinxupquote{struct}}/\sphinxcode{\sphinxupquote{class}} which derivate from \sphinxcode{\sphinxupquote{E\_F0}}.
By default this expression does not depend of the mesh position, but if they derivate from \sphinxcode{\sphinxupquote{E\_F0mps}} the expression depends of the mesh position, and for more details see \sphinxcite{bibliography:hecht2002}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//A class build the link with FreeFEM}
\PYG{c+c1}{//generaly this class are already in AFunction.hpp}
\PYG{c+c1}{//but unfortunatly, I have no simple function with no parameter}
\PYG{c+c1}{//in FreeFEM depending of the mesh}
\PYG{k}{template}\PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{R}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{OneOperator0s} \PYG{o}{:} \PYG{k}{public} \PYG{n}{OneOperator} \PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//the class to define and evaluate a new function}
    \PYG{c+c1}{//It must devive from E\PYGZus{}F0 if it is mesh independent}
    \PYG{c+c1}{//or from E\PYGZus{}F0mps if it is mesh dependent}
    \PYG{k}{class} \PYG{n+nc}{E\PYGZus{}F0\PYGZus{}F} \PYG{o}{:}\PYG{k}{public} \PYG{n}{E\PYGZus{}F0mps} \PYG{p}{\PYGZob{}}
    \PYG{k}{public}\PYG{o}{:}
        \PYG{k}{typedef} \PYG{n}{R} \PYG{p}{(}\PYG{o}{*}\PYG{n}{func}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Stack} \PYG{n}{stack}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{func} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//the pointeur to the fnction myfunction}
        \PYG{n}{E\PYGZus{}F0\PYGZus{}F}\PYG{p}{(}\PYG{n}{func} \PYG{n}{ff}\PYG{p}{)} \PYG{o}{:} \PYG{n}{f}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//the operator evaluation in FreeFEM}
        \PYG{n}{AnyType} \PYG{k}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Stack} \PYG{n}{stack}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}\PYG{k}{return} \PYG{n}{SetAny}\PYG{o}{\PYGZlt{}}\PYG{n}{R}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{stack}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}\PYG{p}{;}
    \PYG{k}{typedef} \PYG{n+nf}{R} \PYG{p}{(}\PYG{o}{*}\PYG{n}{func}\PYG{p}{)}\PYG{p}{(}\PYG{n}{Stack}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{func} \PYG{n}{f}\PYG{p}{;}
    \PYG{k}{public}\PYG{o}{:}
        \PYG{c+c1}{//the function which build the FreeFEM byte code}
        \PYG{n}{E\PYGZus{}F0} \PYG{o}{*}\PYG{n}{code}\PYG{p}{(}\PYG{k}{const} \PYG{n}{basicAC\PYGZus{}F0} \PYG{o}{\PYGZam{}}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{k}{new} \PYG{n}{E\PYGZus{}F0\PYGZus{}F}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
        \PYG{c+c1}{//the constructor to say ff is a function without parameter}
        \PYG{c+c1}{//and returning a R}
        \PYG{n}{OneOperator0s}\PYG{p}{(}\PYG{n}{func} \PYG{n}{ff}\PYG{p}{)} \PYG{o}{:} \PYG{n}{OneOperator}\PYG{p}{(}\PYG{n}{map\PYGZus{}type}\PYG{p}{[}\PYG{k}{typeid}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}\PYG{p}{.}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{f}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To finish we must add this new function in \sphinxstylestrong{FreeFEM} table, to do that include :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kt}{void} \PYG{n+nf}{init}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
     \PYG{n}{Global}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{myfunction}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{new} \PYG{n}{OneOperator0s}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{double}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{myfunction}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 \PYG{p}{\PYGZcb{}}
 \PYG{n}{LOADFUNC}\PYG{p}{(}\PYG{n}{init}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It will be called automatically at load module time.

\sphinxAtStartPar
To compile and link, use the \sphinxcode{\sphinxupquote{ff\sphinxhyphen{}c++}} script :

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ff}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{o}{+} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{cpp}
\PYG{n}{g}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{o}{\PYGZhy{}}\PYG{n}{Iinclude} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{cpp}
\PYG{n}{g}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZhy{}}\PYG{n}{bundle} \PYG{o}{\PYGZhy{}}\PYG{n}{undefined} \PYG{n}{dynamic\PYGZus{}lookup} \PYG{o}{\PYGZhy{}}\PYG{n}{g} \PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{o} \PYG{o}{\PYGZhy{}}\PYG{n}{o} \PYG{p}{.}\PYG{o}{/}\PYG{n}{myfunction}\PYG{p}{.}\PYG{n}{dylib}
\end{sphinxVerbatim}

\sphinxAtStartPar
To try the simple example under Linux or MacOS, do \sphinxcode{\sphinxupquote{FreeFem++\sphinxhyphen{}nw load.edp}}

\sphinxAtStartPar
The output must be:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} FreeFem++ v  *.****** \PYG{o}{(}date *** ** *** ****, **:**:** \PYG{o}{(}UTC+0*00\PYG{o}{)}\PYG{o}{)}
 Load: lg\PYGZus{}fem lg\PYGZus{}mesh lg\PYGZus{}mesh3 eigenvalue
    \PYG{l+m}{1} : // Example of dynamic \PYG{k}{function} load
    \PYG{l+m}{2} : // \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
    \PYG{l+m}{3} : // \PYG{n+nv}{\PYGZdl{}Id}\PYGZdl{}
    \PYG{l+m}{4} :
    \PYG{l+m}{5} :  load \PYG{l+s+s2}{\PYGZdq{}myfunction\PYGZdq{}}
    \PYG{l+m}{6} : // dumptable\PYG{o}{(}cout\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{7} :  mesh \PYG{n+nv}{Th}\PYG{o}{=}square\PYG{o}{(}\PYG{l+m}{5},5\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{8} :  fespace Vh\PYG{o}{(}Th,P1\PYG{o}{)}\PYG{p}{;}
    \PYG{l+m}{9} :  Vh \PYG{n+nv}{uh}\PYG{o}{=} myfunction\PYG{o}{(}\PYG{o}{)}\PYG{p}{;} // warning \PYG{k}{do} not forget \PYG{o}{(}\PYG{o}{)}
   \PYG{l+m}{10} :  cout \PYG{l+s}{\PYGZlt{}\PYGZlt{} uh[].min \PYGZlt{}\PYGZlt{} \PYGZdq{} \PYGZdq{} \PYGZlt{}\PYGZlt{} uh}\PYG{o}{[}\PYG{o}{]}.max \PYG{l+s}{\PYGZlt{}\PYGZlt{} endl;}
\PYG{l+s}{   11 :  cout \PYGZlt{}\PYGZlt{} \PYGZdq{} test io ( \PYGZdq{} \PYGZlt{}\PYGZlt{} endl}\PYG{p}{;}
   \PYG{l+m}{12} :  testio\PYG{o}{(}\PYG{o}{)}\PYG{p}{;}
   \PYG{l+m}{13} :  cout \PYGZlt{}\PYGZlt{} \PYG{l+s+s2}{\PYGZdq{} ) end test io .. \PYGZdq{}} \PYG{l+s}{\PYGZlt{}\PYGZlt{} endl; sizestack + 1024 =1416  ( 392 )}

\PYG{l+s}{  \PYGZhy{}\PYGZhy{} Square mesh : nb vertices  =36 ,  nb triangles = 50 ,  nb boundary edges 20}
\PYG{l+s}{0 0.841471}
\PYG{l+s}{ test io (}
\PYG{l+s}{ test cout 3.14159}
\PYG{l+s}{ test cout 512}
\PYG{l+s}{ test cerr 3.14159}
\PYG{l+s}{ test cerr 512}
\PYG{l+s}{ ) end} \PYG{n+nb}{test} io ..
times: compile \PYG{l+m}{0}.012854s, execution \PYG{l+m}{0}.000313s,  mpirank:0
 CodeAlloc : nb ptr  \PYG{l+m}{2715},  size :371104 mpirank: \PYG{l+m}{0}
Ok: Normal End
\end{sphinxVerbatim}

\sphinxAtStartPar
Under Windows, launch \sphinxstylestrong{FreeFEM} with the mouse (or ctrl O) on the example.


\subsubsection{Example: Discrete Fast Fourier Transform}
\label{\detokenize{documentation/developers:example-discrete-fast-fourier-transform}}
\sphinxAtStartPar
This will add FFT to \sphinxstylestrong{FreeFEM}, taken from \sphinxhref{http://www.fftw.org/}{FFTW}. To download and install under \sphinxcode{\sphinxupquote{download/include}} just go in \sphinxcode{\sphinxupquote{download/fftw}} and try \sphinxcode{\sphinxupquote{make}}.

\sphinxAtStartPar
The 1D dfft (fast discret fourier transform) for a simple array \(f\) of size \(n\) is defined by the following formula:
\begin{equation*}
\begin{split}\mathtt{dfft}(f,\varepsilon)_{k} = \sum_{j=0}^{n-1} f_i e^{\varepsilon 2\pi i kj/n}\end{split}
\end{equation*}
\sphinxAtStartPar
The 2D DFFT for an array of size \(N=n\times m\) is:
\begin{equation*}
\begin{split}\mathtt{dfft}(f,m,\varepsilon)_{k+nl} = \sum_{j'=0}^{m-1} \sum_{j=0}^{n-1} f_{i+nj} e^{\varepsilon 2\pi i (kj/n+lj'/m) }\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The value \(n\) is given by \(size(f)/m\), and the numbering is row\sphinxhyphen{}major order.
\end{sphinxadmonition}

\sphinxAtStartPar
So the classical discrete DFFT is \(\hat{f}=\mathtt{dfft}(f,-1)/\sqrt{n}\) and the reverse dFFT \(f=\mathtt{dfft}(\hat{f},1)/\sqrt{n}\)

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The 2D Laplace operator is
\begin{quote}
\begin{equation*}
\begin{split}f(x,y) = 1/\sqrt{N} \sum_{j'=0}^{m-1} \sum_{j=0}^{n-1} \hat{f}_{i+nj} e^{\varepsilon 2\pi i (x j+ yj') }\end{split}
\end{equation*}
\sphinxAtStartPar
and we have
\begin{equation*}
\begin{split}f_{k+nl} = f(k/n,l/m)\end{split}
\end{equation*}
\sphinxAtStartPar
So
\begin{equation*}
\begin{split}\widehat{\Delta f_{kl}} = -( (2\pi)^2 ( (\tilde{k})^2+(\tilde{l})^2)) \widehat{ f_{kl}} \\\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\tilde{k} = k\) if \(k \leq n/2\) else \(\tilde{k} = k-n\) and \(\tilde{l} = l\) if \(l \leq m/2\) else \(\tilde{l} = l-m\).
\end{quote}

\sphinxAtStartPar
And to have a real function we need all modes to be symmetric around zero, so \(n\) and \(m\) must be odd.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Compile to build a new library}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}c++ dfft.cpp ../download/install/lib/libfftw3.a \PYGZhy{}I../download/install/include
\PYG{n+nb}{export} \PYG{n+nv}{MACOSX\PYGZus{}DEPLOYMENT\PYGZus{}TARGET}\PYG{o}{=}\PYG{l+m}{10}.3
g++ \PYGZhy{}c \PYGZhy{}Iinclude \PYGZhy{}I../download/install/include dfft.cpp
g++ \PYGZhy{}bundle \PYGZhy{}undefined dynamic\PYGZus{}lookup dfft.o \PYGZhy{}o ./dfft.dylib ../download/install/lib/libfftw3.a
\end{sphinxVerbatim}

\sphinxAtStartPar
To test, try {\hyperref[\detokenize{examples/developers:examplefft}]{\sphinxcrossref{\DUrole{std,std-ref}{FFT example}}}}.


\subsubsection{Load Module for Dervieux P0\sphinxhyphen{}P1 Finite Volume Method}
\label{\detokenize{documentation/developers:load-module-for-dervieux-p0-p1-finite-volume-method}}
\sphinxAtStartPar
The associed edp file is
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/convect\_dervieux.edp}{examples++\sphinxhyphen{}load/convect\_dervieux.edp}.

\sphinxAtStartPar
See
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/mat\_dervieux.cpp}{mat\_dervieux.cpp}.


\subsubsection{More on Adding a new finite element}
\label{\detokenize{documentation/developers:more-on-adding-a-new-finite-element}}
\sphinxAtStartPar
First read the {\hyperref[\detokenize{documentation/developers:developersaddingfiniteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Adding a new finite element section}}}}, we add two new finite elements examples in the directory \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/master/examples\%2B\%2B-load}{examples++\sphinxhyphen{}load}.


\paragraph{The Bernardi\sphinxhyphen{}Raugel Element}
\label{\detokenize{documentation/developers:the-bernardi-raugel-element}}
\sphinxAtStartPar
The Bernardi\sphinxhyphen{}Raugel finite element is meant to solve the Navier Stokes equations in \(u,p\) formulation; the velocity space \(P^{br}_K\) is minimal to prove the inf\sphinxhyphen{}sup condition with piecewise constant pressure by triangle.

\sphinxAtStartPar
The finite element space \(V_h\) is
\begin{equation*}
\begin{split}V_h= \{u\in H^1(\Omega)^2 ; \quad \forall K \in T_h, u_{|K} \in P^{br}_K \}\end{split}
\end{equation*}
\sphinxAtStartPar
where
\begin{equation*}
\begin{split}P^{br}_K = span \{ \lambda^K_i e_k \}_{i=1,2,3, k= 1,2} \cup \{ \lambda^K_i\lambda^K_{i+1} n^K_{i+2}\}_{i=1,2,3}\end{split}
\end{equation*}
\sphinxAtStartPar
with notation \(4=1, 5=2\) and where \(\lambda^K_i\) are the barycentric coordinates of the triangle \(K\), \((e_k)_{k=1,2}\) the canonical basis of \(\mathbb{R}^2\) and \(n^K_k\) the outer normal of triangle \(K\) opposite to vertex \(k\).

\sphinxAtStartPar
See
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/BernardiRaugel.cpp}{BernardiRaugel.cpp}.

\sphinxAtStartPar
A way to check the finite element

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BernardiRaugel}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Macro}
\PYG{c+c1}{//a macro the compute numerical derivative}
\PYG{k+kt}{macro} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,} \PYG{n}{hx}\PYG{p}{,} \PYG{n}{hy}\PYG{p}{)} \PYG{p}{(} \PYG{p}{(}\PYG{n}{f}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{+}\PYG{n}{hx}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{o}{+}\PYG{n}{hy}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{hx}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n}{hy}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hx}\PYG{o}{+}\PYG{n}{hy}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}7}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{it1} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{nuTriangle}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2BR}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{c1}\PYG{p}{,} \PYG{n}{c2}\PYG{p}{]}\PYG{p}{;}


\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndofK}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{it1}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{[}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//do the interpolation}

    \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}9} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{c1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//check if the interpolation is correct}

    \PYG{c+c1}{// check the derivative and numerical derivative}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ dx(a1)(x1, y1) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,} \PYG{n+nf}{y1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{DD}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A real example using this finite element, just a small modification of the Navier\sphinxhyphen{}Stokes P2\sphinxhyphen{}P1 example, just the begenning is change to

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BernardiRaugel}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{real} \PYG{n}{s0} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2BR}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{up1}\PYG{p}{,} \PYG{n}{up2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
And the plot instruction is also changed because the pressure is constant, and we cannot plot isovalues of peacewise constant functions.


\paragraph{The Morley Element}
\label{\detokenize{documentation/developers:the-morley-element}}
\sphinxAtStartPar
See the example
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/master/examples\%2B\%2B-load/bilapMorley.edp}{bilapMorley.edp}.


\section{ffddm}
\label{\detokenize{documentation/ffddm/index:ffddm}}\label{\detokenize{documentation/ffddm/index::doc}}
\sphinxAtStartPar
In the acronym \sphinxcode{\sphinxupquote{ffddm}}, \sphinxcode{\sphinxupquote{ff}} stands for FreeFEM and \sphinxcode{\sphinxupquote{ddm}} for domain decomposition methods.
The idea behind ffddm is to simplify the use of parallel solvers in FreeFEM: distributed direct methods and domain decomposition methods.

\sphinxAtStartPar
Parallelism is an important issue because, since about 2004, the clock speed of cores stagnates at 2\sphinxhyphen{}3 GHz.
The increase in performance is almost entirely due to the increase in the number of cores per processor.
All major processor vendors are producing multicore chips and now every machine is a parallel machine.
Waiting for the next generation machine does not guarantee anymore a better performance of a software.
To keep doubling performance parallelism must double.
It implies a huge effort in algorithmic development.

\sphinxAtStartPar
Thanks to \sphinxcode{\sphinxupquote{ffddm}}, FreeFEM users have access to high\sphinxhyphen{}level functionalities for specifying and solving their finite element problems in parallel.
The first task handled by \sphinxcode{\sphinxupquote{ffddm}} is the data distribution among the processors.
This is done via an overlapping domain decomposition and a related distributed linear algebra.
Then, solving a linear system is possible either via an interface to the parallel \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS} solver or by using domain decomposition methods as preconditioners to the GMRES Krylov method.
The \sphinxcode{\sphinxupquote{ffddm}} framework makes it easy to use scalable Schwarz methods enhanced by a coarse space correction built either from a coarse mesh or a \sphinxhref{https://link.springer.com/article/10.1007\%2Fs00211-013-0576-y}{GenEO} (Generalized Eigenvalue in the Overlap) coarse space, see also the book \sphinxhref{http://bookstore.siam.org/ot144/}{An Introduction to Domain Decomposition Methods: algorithms, theory, and parallel implementation}.
State\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}art three level methods are also implemented in \sphinxcode{\sphinxupquote{ffddm}}.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{ffddm}} framework is entirely written in the FreeFEM language and the ‘idp’ scripts can be found \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/idp}{here} (‘ffddm*.idp’ files).
It makes it also a very good tool for learning and prototyping domain decomposition methods without compromising efficiency.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddm}} can also act as a wrapper for the \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} library.
HPDDM is an efficient implementation of various domain decomposition methods and a variety of Krylov subspace algorithms, with advanced block and recycling methods for solving sequences of linear systems with multiple right\sphinxhyphen{}hand sides: GMRES and Block GMRES, CG, Block CG, and Breakdown\sphinxhyphen{}Free Block CG, GCRO\sphinxhyphen{}DR and Block GCRO\sphinxhyphen{}DR.
For more details on how to use HPDDM within \sphinxcode{\sphinxupquote{ffddm}}, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{the ffddm documentation}}}}.

\sphinxAtStartPar
Getting Started

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{Th} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}
\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{c+c1}{// Step 5: Define the two\PYGZhy{}level GenEO Coarse Space}
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{c+c1}{// Step 6: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{PBwritesummary}
\end{sphinxVerbatim}

\sphinxAtStartPar
This example solves a Laplace problem in 2D in parallel with a two\sphinxhyphen{}level GenEO domain decomposition method.
To try this example, just copy and paste the script above in a file ‘test.edp’ and run it on 2 cores with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} test.edp \PYGZhy{}wg
\end{sphinxVerbatim}


\subsection{Domain Decomposition (DD)}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:domain-decomposition-dd}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroduction}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method::doc}}
\sphinxAtStartPar
When the size of a three dimensional problem is large (whatever it means), it is necessary to distribute data among several processors especially for solving linear systems.
A natural way is to do it via domain decomposition.


\subsubsection{Mesh Decomposition}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:mesh-decomposition}}


\sphinxAtStartPar
The starting point is a collection of \(N\) sub\sphinxhyphen{}meshes \((Th_i)_{i=1}^N\) that together form a global mesh
\begin{equation*}
\begin{split}Th:= \cup_{i=1}^N Th_i\,.\end{split}
\end{equation*}
\sphinxAtStartPar
These meshes may be overlapping or not. This decomposition induces a natural decomposition of the global finite element space \(Vh\) on \(Th\) into \(N\) local finite element spaces \((Vh_i)_{i=1}^N\) each of them defined on \(Th_i\).

\sphinxAtStartPar
\sphinxstylestrong{Note} By global, we mean that the corresponding structure can be refered to in the code (most often only) by its local values.
In computer science term, it corresponds to a distributed data where each piece of data is stored by a MPI process.


\subsubsection{Distributed Linear Algebra}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:distributed-linear-algebra}}
\sphinxAtStartPar
For a given finite element space \(Vh\), the domain decomposition induces a natural decomposition of the set of the global degrees of freedom (d.o.f.) of \(Vh\) into the \(N\) subsets of d.o.f.’s \(({\mathcal N}_i)_{i=1}^N\) each associated with the local finite element space \(Vh_i\).
We have thus
\begin{equation*}
\begin{split}{\mathcal N} = \cup_{i=1}^N {\mathcal N}_i\,,\end{split}
\end{equation*}
\sphinxAtStartPar
but with duplications of some of the d.o.f.’s.

\sphinxAtStartPar
Associated with this decomposition of the set of d.o.f.’s \({\mathcal N}\), a \sphinxstyleemphasis{distributed vector} is a collection of local vectors \(({\mathbf V_i})_{1\le i\le N}\) so that the values on the duplicated d.o.f.’s are the same.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In mathematical terms, it can be described as follows for a real valued problem.
Let \(R_i\) be the restriction operator from \(\R^{\#{\mathcal N}}\) to \(\R^{\#{\mathcal N}_i}\), where \(\#{\mathcal N}_i\) denotes the number of elements of \({\mathcal N}_i\).
A collection of local vectors \(({\mathbf V}_i)_{1\le i\le N}\in \Pi_{i=1}^N \R^{\#{\mathcal N}_i}\) is a distributed vector iff there exists a global vector \({\mathbf V}\in\R^{\#{\mathcal N}}\) such that for all subset \(1\le i\le N\), we have:
\begin{equation*}
\begin{split}{\mathbf V}_i = R_i\,{\mathbf V}\,.\end{split}
\end{equation*}
\sphinxAtStartPar
We will also say that the collection of local vectors \(({\mathbf V}_i)_{1\le i\le N}\) is consistent. For a complex valued problem, simply replace \(\R\) with \(\C\).
\end{sphinxadmonition}


\subsubsection{Partition of Unity Matrices (POUM)}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:partition-of-unity-matrices-poum}}
\sphinxAtStartPar
Let \((D_i)_{1\le i \le N}\) be square diagonal matrices of size \(\#{\mathcal N}_i\) which form a partition of unity in the sense that:
\begin{equation*}
\begin{split}Id_{} = \sum_{i=1}^N R_i^T\,D_i\,R_i\text{ in }\R^{\#{\mathcal N}\times \#{\mathcal N}} \,.\end{split}
\end{equation*}
\sphinxAtStartPar
For instance if a degree of freedom is shared by \(k\) subdomains defining the corresponding entry of the diagonal matrix \(D\) to be \(1/k\) yields partition of unity matrices.
The matrices \(R_i\) and \(D_i\) are the heart of distributed linear algebra.


\paragraph{Distributed scalar product}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:distributed-scalar-product}}
\sphinxAtStartPar
For two global vectors \({\mathbf U}\) and \({\mathbf V}\) of size \(\#{\mathcal N}\), the formula for the scalar product \({\mathbf V}^T\,{\mathbf U}=({\mathbf U},\,{\mathbf V})\) in terms of their distributed vector counterparts makes use of the partition of unity matrices \((D_i)_{1\le i \le N}\) introduced above:
\begin{equation*}
\begin{split}({\mathbf U}, {\mathbf V}) = \left({\mathbf U}, \sum_{i=1}^N R_i^T D_i R_i {\mathbf V}\right) = \sum_{i=1}^N(R_i {\mathbf U}, D_i R_i {\mathbf V})
=\sum_{i=1}^N\left({\mathbf U}_i, D_i {\mathbf V}_i\right)\,.\end{split}
\end{equation*}
\sphinxAtStartPar
Local scalar products are performed concurrently.
Thus, the implementation is parallel except for the sum which corresponds to a MPI\_Reduce call across the \(N\) MPI processes.
Note also that the implementation relies on the knowledge of a partition of unity so that the FreeFEM syntax is \sphinxcode{\sphinxupquote{dscalprod(Di,u,v)}} or equivalently \sphinxcode{\sphinxupquote{myFEprefix\#scalprod(u,v)}} where \sphinxcode{\sphinxupquote{myFEprefix}} is a user defined prefix for the finite element space decomposition, see the {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddm documentation}}}}.


\paragraph{Update}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:update}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmdocumentationupdate}}
\sphinxAtStartPar
From a collection of local vectors \(({\mathbf U}_i)_{1\le i \le N}\), it is possible ensure consistency of the duplicated data by modifying the distributed vector \(({\mathbf U}_i)_{1\le i \le N}\) by calling the function \sphinxcode{\sphinxupquote{myFEprefix\#update(Ui, TRUE)}} where \sphinxcode{\sphinxupquote{myFEprefix}} is the user defined prefix that refers to the finite element space decomposition.
This function performs the following operation for all \(1\le i \le N\):
\begin{equation*}
\begin{split}{\mathbf U}_i \leftarrow R_i\, \sum_{j=1}^N R_j^T D_j {\mathbf U}_j\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The implementation corresponds to
\begin{equation*}
\begin{split}{\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j {\mathbf U}_j = D_i {\mathbf U}_i + \sum_{j\in \mathcal{O}(i)} R_i\,R_j^T\,D_j {\mathbf U}_j\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathcal{O}(i)\) is the set of neighbors of subdomain \(i\).
Therefore, the matrix vector product is computed in three steps:
\begin{itemize}
\item {} 
\sphinxAtStartPar
concurrent computing of \(D_j {\mathbf U}_j\) for all \(1\le j\le N\);

\item {} 
\sphinxAtStartPar
neighbor to neighbor MPI\sphinxhyphen{}communications from subdomain \(j\) to subdomain \(i\)  (\(R_i\,R_j^T\)) ;

\item {} 
\sphinxAtStartPar
concurrent sum of neighbor contributions.

\end{itemize}
\end{sphinxadmonition}


\subsubsection{Distributed Matrix and Vector resulting from a variational formulation}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:distributed-matrix-and-vector-resulting-from-a-variational-formulation}}
\sphinxAtStartPar
The discretization of a variational formulation on the global mesh \(Th\) yields a global matrix \(A\) and a global right hand side \(\mathbf{RHS}\).
Thanks to the sparsity of finite element matrices for partial differential equations and thanks to the overlap between subdomains, the knowledge of the local matrix \(R_i A R_i^T\) on each subdomain \(1\le i\le N\) is sufficient to perform the matrix\sphinxhyphen{}vector product \(A\times \mathbf{U}\) for any global vector \(\mathbf{U}\).
Once the problem has been set up by a call to \sphinxcode{\sphinxupquote{ffddmsetupOperator(myprefix, myFEprefix, myVarf)}}, the matrix\sphinxhyphen{}vector product is performed by calling the function \sphinxcode{\sphinxupquote{myprefix\#A(Ui)}} where \sphinxcode{\sphinxupquote{myprefix}} is a user defined prefix that refers to the problem at hand which itself implicitly refers to the triplet (domain decomposition, finite element, variational formulation).
See more on problem definition in this {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}} and more on distributed linear algebra in chapter 8 of \sphinxhref{http://bookstore.siam.org/ot144/}{“An Introduction to Domain Decomposition Methods: algorithms, theory and parallel implementation” SIAM 2015}.


\subsubsection{Distributed Linear Solvers}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:distributed-linear-solvers}}
\sphinxAtStartPar
In many cases, we are interested in the solution of the problem in terms of the vector of d.o.f.’s \(\mathbf{X}\) that satisfies:
\begin{equation*}
\begin{split}A\, \mathbf{X} = \mathbf{RHS}\,.\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddm}} offers two parallel solvers: {\hyperref[\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductiondisitributeddirectsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{direct factorization}}}} and iterative preconditioned solvers via {\hyperref[\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductionschwarzmethods}]{\sphinxcrossref{\DUrole{std,std-ref}{Schwarz}}}} domain decomposition methods.


\paragraph{Distributed Direct Solvers}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:distributed-direct-solvers}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductiondisitributeddirectsolvers}}
\sphinxAtStartPar
In order to benefit from the sparsity of the matrix arising from a finite element discretization of a partial differential equation, a variant of Gauss elimination, the frontal method, that automatically avoids a large number of operations involving zero terms was developed.
A frontal solver builds a \(LU\) or Cholesky decomposition of a sparse matrix given as the assembly of element matrices by eliminating equations only on a subset of elements at a time.
This subset is called the \sphinxstyleemphasis{front} and it is essentially the transition region between the part of the system already finished and the part not touched yet.
These methods are basically sequential since the unknowns are processed the one after another or one front after another.
In order to benefit from multicore processors, a \sphinxhref{https://en.wikipedia.org/wiki/Multifrontal\_method}{multifrontal solver} is an improvement of the frontal solver that uses several independent fronts at the same time.
The fronts can be worked on by different processors, which enables parallel computing. \sphinxcode{\sphinxupquote{ffddm}} provides an interface to the parallel sparse direct solver \sphinxhref{http://mumps.enseeiht.fr/}{MUMPS}. These methods have the advantage to be very robust and to have a predictable cost. The main drawback is the memory requirement which can be prohibitive especially for three\sphinxhyphen{}dimensional problems.


\paragraph{Schwarz methods}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:schwarz-methods}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductionschwarzmethods}}
\sphinxAtStartPar
These methods are part of the large family of preconditioned iterative solvers. When considering the solve of the equation \(A\, \mathbf{X} = \mathbf{RHS}\), a preconditioner is a linear operator that approximates the inverse of \(A\) and whose cost of the associated matrix\sphinxhyphen{}vector product is much cheaper than solving the original linear system. It enables to accelerate the solution of the latter with Krylov type methods such as the conjugate gradient (in the symmetric positive definite case), GMRES or BiCGSTAB in the general case. Two options are possible.

\sphinxAtStartPar
Left preconditioning: the preconditioner is applied to the left of the equation
\begin{equation*}
\begin{split}M^{-1}  A\, \mathbf{X} =  M^{-1} \mathbf{RHS}\,.\end{split}
\end{equation*}
\sphinxAtStartPar
and the Krylov method is applied to the left preconditioned system with a residual that is preconditioner dependent.

\sphinxAtStartPar
Right preconditioning: the preconditioner is inserted on the right of the operator:
\begin{equation*}
\begin{split}A\, M^{-1}  \mathbf{Y} =  \mathbf{RHS}\, \text{ where } \mathbf{X} =  M^{-1}  \mathbf{Y}.\end{split}
\end{equation*}
\sphinxAtStartPar
and the Krylov method is applied to the right preconditioned system with a residual that is preconditioner independent.

\sphinxAtStartPar
In both cases, if the preconditioner is efficient the number of iterations to get a converged solution is much smaller than the number of iterations of the Krylov method applied to the original equation \(A\, \mathbf{X} = \mathbf{RHS}\).  Although right preconditioning seems more intricate, it is much safer to use since the convergence is checked on a residual that does not depend on the preconditioner.

\sphinxAtStartPar
In the sequel, we consider the solution of the equation \(A\, \mathbf{X} = \mathbf{RHS}\) preconditioned by domain decomposition methods and with a \sphinxstylestrong{flexible GMRES} Krylov method which is thus necessarily right preconditioned.


\subparagraph{Restricted Additive Schwarz (RAS)}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:restricted-additive-schwarz-ras}}
\sphinxAtStartPar
The RAS preconditioner reads:
\begin{equation*}
\begin{split}M^{-1}_{RAS} := \sum_{j=1}^N R_j^T D_j (R_j\, A\,R_j^T)^{-1} R_j\,,\end{split}
\end{equation*}
\sphinxAtStartPar
where for each subdomain \(j\) the restriction matrix \(R_j\) and  the partition of unity matrix \(D_j\) to a global right hand side \(\mathbf{RHS}\) is detailed below. Recall that this global vector is distributed among processes via the local vectors \((\mathbf{RHS}_i)_{i=1}^N\). Let \(A_{j}\) denote the local matrix \((R_j\, A\,R_j^T)\). The local vector in subdomain \(i\) resulting from the matrix vector product \(M^{-1}_{RAS}\, \mathbf{RHS}\) consists in computing:
\begin{equation*}
\begin{split}R_i\, \sum_{j=1}^N R_j^T\,D_j\, A_{j}^{-1}\,\, \mathbf{ RHS}_j
= D_i\, A_{i}^{-1}\, \mathbf{ RHS}_i + \sum_{j\in \mathcal{O}(i)} (R_i\,R_j^T)\,D_j\, A_{j}^{-1}\, \mathbf{ RHS}_j\,.\end{split}
\end{equation*}
\sphinxAtStartPar
This task is performed by first solving concurrently on all subdomains a linear system for \({\mathbf Y}_j\) for all \(1\le j \le N\):
\begin{equation*}
\begin{split}A_{j}\, {\mathbf Y}_j = \mathbf{RHS}_j\,.\end{split}
\end{equation*}
\sphinxAtStartPar
Each local vector \({\mathbf Y}_j\) is weighted by the partition of unity matrix \(D_j\).
Then data transfers between neighboring subdomains implement the \(R_i\,R_j^T\,D_j\,{\mathbf Y}_j\) formula.
The contribution from neighboring subdomains are summed locally. This
pattern is very similar to that of the {\hyperref[\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmdocumentationupdate}]{\sphinxcrossref{\DUrole{std,std-ref}{update}}}} procedure.


\subparagraph{Optimized Restricted Additive Schwarz (ORAS)}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:optimized-restricted-additive-schwarz-oras}}
\sphinxAtStartPar
The ORAS preconditioner may be seen as a variant of the RAS preconditioner.
It reads:
\begin{equation*}
\begin{split}M^{-1}_{RAS} := \sum_{j=1}^N R_j^T D_j\, B_j^{-1}\, R_j\,\end{split}
\end{equation*}
\sphinxAtStartPar
where \(B_j\) are local matrices of size \(\#{\mathcal N}_j \times \#{\mathcal N}_j\) for \(1\le j \le N\).
This variant is very useful when dealing with wave propagation phenomena such as Helmholtz problems in acoustics or Maxwell system in the frequency domain for electromagnetism.
Defining \(B_j\) as the discretization of the physical equation with impedance conditions on the boundary of the subdomain has been proved to be a good choice.


\subparagraph{Two level methods}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:two-level-methods}}
\sphinxAtStartPar
The RAS and ORAS methods are called a one\sphinxhyphen{}level method in the sense that sub\sphinxhyphen{}domains only interact with their direct neighbors. For some problems such as Darcy problems or static elasticity problems and when the number of subdomains is large, such one\sphinxhyphen{}level methods may suffer from a slow convergence.
The fix is to add to the preconditioner an auxiliary coarse problem that couples all subdomains at each iteration and is inexpensive to calculate.

\sphinxAtStartPar
In mathematical terms, we first choose  a full rank rectangular matrix  \(Z\in\R^{\#{\mathcal N}\times NC}\) where \(NC \ll \#{\mathcal N}\) denotes the dimension of the coarse space spanned by the columns of \(Z\). We also pick a coarse matrix \(A_C\in \R^{N_C\times N_C}\). A generic one\sphinxhyphen{}level method preconditioner \(M_1^{-1}\) is enriched by a solve on the coarse space. The simplest correction formula is additive:
\begin{equation*}
\begin{split}M_2^{-1} := Z \,A_C^{-1}\,Z^T + M_1^{-1}\end{split}
\end{equation*}
\sphinxAtStartPar
Other correction formulas are given in {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}.

\sphinxAtStartPar
We consider two ways to build \(Z\) and thus the coarse space and the coarse problem \(A_C\), see below {\hyperref[\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductioncoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{Coarse Mesh}}}} and {\hyperref[\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductiongeneo}]{\sphinxcrossref{\DUrole{std,std-ref}{GenEO}}}}


\subparagraph{Coarse Mesh}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:coarse-mesh}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductioncoarsemesh}}
\sphinxAtStartPar
A first possibility is to discretize the problem on a coarse mesh, following the same principle as multi\sphinxhyphen{}grid methods.
For 3\sphinxhyphen{}D problems, a coarsening of the mesh size by a factor 2, reduces by a factor \(2^3=8\) the size of the coarse problem which is then easier to solve by a direct method. Then, \(Z\) is the interpolation matrix from the coarse finite element space to the fine one.


\subparagraph{GenEO}
\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:geneo}}\label{\detokenize{documentation/ffddm/introduction-to-the-domain-decomposition-method:ffddmintroductiongeneo}}
\sphinxAtStartPar
For highly heterogeneous or anisotropic problems, two level methods based on coarse meshes might fail and a more sophisticated construction must be used.
A provable robust coarse space called GenEO is built by first solving the following local generalized eigenvalue problem in parallel for each subdomain \(1\le i\le N\), where \(A_i^{\text{Neu}}\) denotes the local matrix resulting from the variational formulation:
\begin{equation*}
\begin{split}D_i A_i D_i\, V_{i,k} = \lambda_{i,k}\, A_i^{\text{Neu}} \,V_{i,k}\end{split}
\end{equation*}
\sphinxAtStartPar
The eigenvectors selected to enter the coarse space correspond to eigenvalues \(\lambda_{i,k} \ge \tau\), where the threshold parameter \(\tau\) is user\sphinxhyphen{}defined.
The precise formulas are given in this {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}.
From a mathematical point of view, it has been proved that for a symmetric positive definite matrix \(A\), the spectrum of the preconditioned by the two\sphinxhyphen{}level method with a GenEO coarse space lies in the interval \([\displaystyle \frac{1}{1+k_1\,\tau} , k_0 ]\).

\sphinxAtStartPar
\sphinxstylestrong{Note} A heuristic that justifies this construction is as follows.
We first introduce the Additive Schwarz method (ASM) which can be seen as a symmetrized variant of the RAS preconditioner:
\begin{equation*}
\begin{split}M_{ASM}^{-1} := \sum_{j=1}^N R_j^T A_j^{-1} R_j\,.\end{split}
\end{equation*}
\sphinxAtStartPar
It can be proved that the lower bound for the eigenvalue of \(M_{ASM}^{-1}\,A\) is close to zero (which is bad for convergence) whereas the upper bound depends only on the number of neigbors of a subdomain (which is good for convergence).

\sphinxAtStartPar
Second, we also introduce the following preconditioner \(M^{-1}_{NN}\):
\begin{equation*}
\begin{split}M^{-1}_{NN} := \sum_{1\le j\le N} D_i\,(A_j^{\text{Neu}})^{-1} D_j\,.\end{split}
\end{equation*}
\sphinxAtStartPar
We have a very good lower bound for the preconditioned operator \(M^{-1}_{NN}\,A\) that does not depend on the number of subdomains but only on the maximum multiplicity of intersections \(k_1\) (which is good for convergence).
But the upper bound for this preconditioner is very large (which is bad for convergence).

\sphinxAtStartPar
Now, if we compare formulas for \(M^{-1}_{NN}\) and \(M^{-1}_{ASM}\), we may suspect that vectors \(\mathbf{V}_{ik}\) for which \(D_i\, (A_i^{\text{Neu}})^{-1}\,D_i\,\mathbf{V}_{ik}\) and \(A_{i}^{-1}\,\mathbf{V}_{ik}\) have very different values are responsible for the slow convergence and should contribute to the coarse space.
This is a way to interpret the above generalized eigenvalue problem which controls the lower bound of the two\sphinxhyphen{}level preconditioned system.


\subsection{ffddm documentation}
\label{\detokenize{documentation/ffddm/documentation:ffddm-documentation}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentation}}\label{\detokenize{documentation/ffddm/documentation::doc}}

\subsubsection{Minimal example}
\label{\detokenize{documentation/ffddm/documentation:minimal-example}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{3}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{LL} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label} \PYG{o}{=} \PYG{n}{LL}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// global mesh}

\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{// EOM    // three\PYGZhy{}dimensional gradient}

\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{c+c1}{// Domain decomposition}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{LapMesh} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i}\PYG{c+c1}{// EOM                         // scalar field definition}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{n}{i}\PYG{c+c1}{// EOM                        // scalar field initialization}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{LapFE} \PYG{p}{,} \PYG{n}{LapMesh} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P1} \PYG{p}{)}

\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{LapFE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{Lap} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{rhsi} \PYG{p}{)}

\PYG{n}{LapFEVhi} \PYG{n}{def}\PYG{p}{(}\PYG{n}{ui}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Direct solve}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Lapdirectsolve}\PYG{p}{(}\PYG{n}{rhsi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Lapwritesummary}

\PYG{n+nf}{ffddmplot}\PYG{p}{(}\PYG{n}{LapFE}\PYG{p}{,}\PYG{n}{ui}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Overlapping mesh decomposition}
\label{\detokenize{documentation/ffddm/documentation:overlapping-mesh-decomposition}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{prmesh}\PYG{p}{,}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{comm}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
decomposes the mesh \sphinxstylestrong{Th} into overlapping submeshes.
The mesh will be distributed over the mpi ranks of communicator \sphinxstylestrong{comm}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{prmesh}, see below (\# is the concatenation operator).
The way the initial mesh \sphinxstylestrong{Th} is partitioned depends on the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpartitioner}}}}.

\sphinxAtStartPar
The size of the overlap between subdomains (its width in terms of number of mesh elements) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}}.

\sphinxAtStartPar
The level of refinement of the resulting submeshes with respect to the input mesh \sphinxstylestrong{Th} is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}}.

\sphinxAtStartPar
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} \(\neq 0\), the first {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} mpi ranks of \sphinxstylestrong{comm} will be excluded from the spatial domain decomposition, in order to dedicate them later to the coarse problem (for two\sphinxhyphen{}level preconditioners).

\sphinxAtStartPar
The label of the new border of the submeshes (the interface between the subdomains) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminterfacelabel}}}}.

\sphinxAtStartPar
\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int prmesh\#npart}} number of subdomains for this decomposition; should be equal to mpiSize(\sphinxstylestrong{comm}) \sphinxhyphen{} {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} * {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int prmesh\#pCS}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int prmesh\#exclude}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int prmesh\#excluded}} \sphinxstyleemphasis{true} if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} is \sphinxstyleemphasis{true} (\(\neq 0\)) and mpiRank(\sphinxstylestrong{comm}) \textless{} \sphinxcode{\sphinxupquote{prmesh\#pCS}}.
In this case, this mpi rank will be excluded from the spatial domain decomposition and will only work on the coarse problem.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiComm prmesh\#commddm}} mpi communicator for ranks participating in the spatial domain decomposition (ranks 0 to \sphinxcode{\sphinxupquote{prmesh\#npart}}\sphinxhyphen{}1 in \sphinxstylestrong{comm} if \sphinxcode{\sphinxupquote{prmesh\#exclude}} is \sphinxstyleemphasis{false}, ranks \sphinxcode{\sphinxupquote{prmesh\#pCS}} to \sphinxcode{\sphinxupquote{prmesh\#pCS}}+\sphinxcode{\sphinxupquote{prmesh\#npart}}\sphinxhyphen{}1 otherwise)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiComm prmesh\#commCS}} mpi communicator for ranks participating in the assembly and resolution of the coarse problem for two\sphinxhyphen{}level preconditioners (ranks 0 to \sphinxcode{\sphinxupquote{prmesh\#pCS}} \sphinxhyphen{} 1 in \sphinxstylestrong{comm})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mpiComm prmesh\#commself}} self mpi communicator (this mpi rank only), used for factorizing local matrices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meshN{[}int{]} prmesh\#aTh}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of local meshes of the subdomains.
In the standard parallel case, only the local mesh for this mpi rank \sphinxcode{\sphinxupquote{prmesh\#aTh{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i.e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1, see below).
In the sequential case, all local meshes are defined.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meshN prmesh\#Thi}} the local mesh of the subdomain for this mpi rank, i. e. \sphinxcode{\sphinxupquote{prmesh\#aTh{[}mpiRank(prmesh\#commddm){]}}} in the parallel case

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int prmesh\#numberIntersection}} the number of neighbors for this mpi rank

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int{[}int{]} prmesh\#arrayIntersection}} the list of neighbor ranks in \sphinxcode{\sphinxupquote{prmesh\#commddm}} for this mpi rank

\end{itemize}


\begin{description}
\item[{\sphinxstylestrong{Remark for sequential use} (see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxhyphen{}seqddm}}}}):}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meshN{[}int{]} prmesh\#aTh}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of local meshes of the subdomains

\end{itemize}

\end{description}




\subsubsection{Local finite element spaces}
\label{\detokenize{documentation/ffddm/documentation:local-finite-element-spaces}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{prfe}\PYG{p}{,}\PYG{n}{prmesh}\PYG{p}{,}\PYG{n}{scalar}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the local finite element spaces and associated distributed operators on top of the mesh decomposition \sphinxstylestrong{prmesh}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{prfe}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} has already been called with prefix \sphinxstylestrong{prmesh} in order to build the mesh decomposition.

\sphinxAtStartPar
The local finite element spaces of type \sphinxstylestrong{Pk} (where \sphinxstylestrong{Pk} is the type of finite element: P1, {[}P2,P2,P1{]}, …) are defined on the local meshes of the subdomains based on the mesh decomposition previously created with prefix \sphinxstylestrong{prmesh}.

\sphinxAtStartPar
\sphinxstylestrong{scalar} determines the type of data for this finite element: \sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex}.

\sphinxAtStartPar
Two macros, \sphinxstylestrong{def} and \sphinxstylestrong{init}, are needed: \sphinxstylestrong{def} specifies how to define a finite element function in the finite element space \sphinxstylestrong{Pk}, and \sphinxstylestrong{init} specifies how to interpolate a scalar function onto the (possibly multiple) components of \sphinxstylestrong{Pk}. Two examples are given below:

\sphinxAtStartPar
For scalar P2 finite elements and complex\sphinxhyphen{}valued problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u}\PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u}\PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{mymeshprefix}\PYG{p}{,}\PYG{k+kt}{complex}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For vectorial {[}P2,P2,P1{]} finite elements and real\sphinxhyphen{}valued problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]}\PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{]}\PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{mymeshprefix}\PYG{p}{,}\PYG{k+kt}{real}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In practice, this builds the necessary distributed operators associated to the finite element space: the local partition of unity functions \((D_i)_{i=1,...,N}\) (see \sphinxcode{\sphinxupquote{prfe\#Dk}} and \sphinxcode{\sphinxupquote{prfe\#Dih}} below) as well as the function \sphinxcode{\sphinxupquote{prfe\#update}} (see below) which synchronizes local vectors \((u_i)_{i=1,...,N}\) between neighboring subdomains, performing the equivalent of \(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\) or \(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\) in a distributed parallel environment.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prfe\#scalprod}} (see below) performs the parallel scalar product for vectors defined on this finite element.

\sphinxAtStartPar
\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prfe\#prmesh}} macro, saves the parent prefix \sphinxstylestrong{prmesh} of the mesh decomposition

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prfe\#K}} macro, saves the type of data \sphinxstylestrong{scalar} for this finite element space (\sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func prfe\#fPk}} saves the type of finite element \sphinxstylestrong{Pk}, e.g. \sphinxstyleemphasis{P1, {[}P2,P2,P1{]}, …}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fespace prfe\#Vhi}} the local finite element space for this mpi rank, defined on the local mesh \sphinxcode{\sphinxupquote{prmesh\#Thi}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int prfe\#Ndofglobal}} the total number of degrees of freedom \(n\) for this finite element discretization

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prfe\#mdef}} macro, saves the macro \sphinxstylestrong{def} giving the definition of a finite element function in the finite element space \sphinxstylestrong{Pk}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prfe\#minit}} macro, saves the macro \sphinxstylestrong{init} specifying how to interpolate a scalar function onto the (possibly multiple) components of a finite element function of \sphinxstylestrong{Pk}.
This is used to create the local partition of unity function in \sphinxcode{\sphinxupquote{prfe\#Vhi}}, by interpolating the local P1 partition of unity function onto the components of \sphinxcode{\sphinxupquote{prfe\#Vhi}}.
For non Lagrange finite element spaces (e.g. \sphinxstyleemphasis{RT0}, \sphinxstyleemphasis{Edge03d}, …), see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationpartitionunityedge}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespaceEdge}}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prfe\#K{[}int{]}{[}int{]} prfe\#Dk}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of local partition of unity vectors in the subdomains, equivalent to \((D_i)_{i=1,...,N}\).
In the standard parallel case, only the local partition of unity vector for this mpi rank \sphinxcode{\sphinxupquote{prfe\#Dk{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all local partition of unity vectors are defined.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{}{[}int{]} prfe\#Dih}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) similar to \sphinxcode{\sphinxupquote{prfe\#Dk}} but in \sphinxstyleemphasis{matrix} form, allowing for easier \sphinxstyleemphasis{matrix}\sphinxhyphen{}\sphinxstyleemphasis{matrix} multiplications.
\sphinxcode{\sphinxupquote{prfe\#Dih{[}i{]}}} is a diagonal matrix, with the diagonal equal to \sphinxcode{\sphinxupquote{prfe\#Dk{[}i{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fespace prfe\#Vhglob}} the global finite element space defined on the global mesh \sphinxcode{\sphinxupquote{prmesh\#Thglob}}.
Defined only if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxhyphen{}noGlob}}}} is not used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{}{[}int{]} prfe\#Rih}} array (size \sphinxcode{\sphinxupquote{prmesh\#npart}}) of restriction matrices from the global finite element space to the local finite element spaces on the local submeshes of the subdomains.
In the standard parallel case, only the restriction matrix for this mpi rank \sphinxcode{\sphinxupquote{prfe\#Rih{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all restriction matrices are defined. The restriction matrices \sphinxcode{\sphinxupquote{prfe\#Rih}} are defined only if {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}]{\sphinxcrossref{\DUrole{std,std-ref}{\sphinxhyphen{}noGlob}}}} is not used.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func int prfe\#update(scalar{[}int{]} ui, bool scale)}} The function \sphinxcode{\sphinxupquote{prfe\#update}} synchronizes the local vector \sphinxstyleemphasis{ui} between subdomains by exchanging the values of \sphinxstyleemphasis{ui} shared with neighboring subdomains (in the overlap region) using point\sphinxhyphen{}to\sphinxhyphen{}point MPI communications.
If \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{true}, \sphinxstyleemphasis{ui} is multiplied by the local partition of unity beforehand.
This is equivalent to \(u_i = R_i (\sum_{j=1}^N R_j^T u_j)\) when \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{false} and \(u_i = R_i (\sum_{j=1}^N R_j^T D_j u_j)\) when \sphinxstyleemphasis{scale} is \sphinxstyleemphasis{true}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func scalar prfe\#scalprod(scalar{[}int{]} ai, scalar{[}int{]} bi)}} The function \sphinxcode{\sphinxupquote{prfe\#scalprod}} computes the global scalar product of two vectors whose local restriction to the subdomain of this mpi rank are \sphinxstyleemphasis{ai} and \sphinxstyleemphasis{bi}.
The result is computed as \(\sum_{j=1}^N (D_j a_j, b_j)\).

\end{itemize}




\subsubsection{Define the problem to solve}
\label{\detokenize{documentation/ffddm/documentation:define-the-problem-to-solve}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{prfe}\PYG{p}{,}\PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the distributed operator associated to the variational problem given by \sphinxstylestrong{Varf}, on top of the distributed finite element space \sphinxstylestrong{prfe}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespace}}}} has already been called with prefix \sphinxstylestrong{prfe} in order to define the distributed finite element space.

\sphinxAtStartPar
In practice, this builds the so\sphinxhyphen{}called local ‘Dirichlet’ matrices \(A_i = R_i A R_i^T\), the restrictions of the global operator \(A\) to the subdomains (see \sphinxcode{\sphinxupquote{pr\#aRd}}below).
The matrices correspond to the discretization of the bilinear form given by the macro \sphinxstylestrong{Varf}, which represents the abstract variational form of the problem.
These matrices are then used to implement the action of the global operator \(A\) on a local vector (the parallel matrix\sphinxhyphen{}vector product with \(A\)), see \sphinxcode{\sphinxupquote{pr\#A}} below.

\sphinxAtStartPar
At this point, we already have the necessary data to be able to solve the problem with a parallel direct solver (\sphinxstyleemphasis{MUMPS}), which is the purpose of the function \sphinxcode{\sphinxupquote{pr\#directsolve}} (see below).
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}} for building the right\sphinxhyphen{}hand side.

\sphinxAtStartPar
The macro \sphinxstylestrong{Varf} is required to have three parameters: the name of the variational form, the mesh, and the finite element space.
The variational form given in this ‘abstract’ format will then be used by \sphinxstyleemphasis{ffddm} to assemble the discrete operators by setting the appropriate mesh and finite element space as parameters.
An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myFEprefix}\PYG{p}{,}\PYG{n}{myVarf}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Remark} In this simple example, the third parameter \sphinxstyleemphasis{VhName} is not used.
However, for more complex cases such as non\sphinxhyphen{}linear or time dependent problems where the problem depends on a solution computed at a previous step, it is useful to know for which discrete finite element space the variational form is being used.
See for example TODO

\sphinxAtStartPar
\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pr\#prfe}} macro, saves the parent prefix \sphinxstylestrong{prfe} of the finite element space

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int pr\#verbosity}} the level of verbosity for this problem, initialized with the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmverbosity}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pr\#writesummary}} macro, prints a summary of timings for this problem, such as the time spent to assemble local matrices or solve the linear system.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{} pr\#Aglobal}} the global matrix \(A\) corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{Varf} on the global finite element space \sphinxcode{\sphinxupquote{prfe\#Vhglob}}.
Defined only in the sequential case.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}prfe\#K\textgreater{}{[}int{]} pr\#aRd}} array (size \sphinxcode{\sphinxupquote{prfe\#prmesh\#npart}}) of so\sphinxhyphen{}called local ‘Dirichlet’ matrices in the subdomains; these are the restrictions of the global operator to the subdomains, equivalent to \(A_i = R_i A R_i^T\) with \(A\) the global matrix corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{Varf} on the global finite element space.
In the standard parallel case, only the local matrix for this mpi rank \sphinxcode{\sphinxupquote{pr\#aRd{[}mpiRank(prmesh\#commddm){]}}} is defined (unless this mpi rank is excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 1).
In the sequential case, all local matrices are defined.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#A(prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#A}} computes the parallel matrix\sphinxhyphen{}vector product, i.e. the action of the global operator \(A\) on the local vector \(u_i\).
The computation is equivalent to \(R_i (\sum_{j=1}^N R_j^T D_j A_j u_j)\) and is performed in parallel using local matrices \sphinxcode{\sphinxupquote{pr\#aRd}} and the function \sphinxcode{\sphinxupquote{prfe\#update}}.
In the sequential case, the global matrix \sphinxcode{\sphinxupquote{pr\#Aglobal}} is used instead.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#AT(prfe\#K{[}int{]} \&ui)}} Similarly to \sphinxcode{\sphinxupquote{pr\#A}}, The function \sphinxcode{\sphinxupquote{pr\#AT}} computes the action of \(A^T\), the transpose of the global operator \(A\), on \(u_i\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func prfe\#K{[}int{]} pr\#directsolve(prfe\#K{[}int{]}\& rhsi)}} The function \sphinxcode{\sphinxupquote{pr\#directsolve}} allows to solve the linear system \(A x = b\) in parallel using the parallel direct solver \sphinxstyleemphasis{MUMPS}.
The matrix is given to \sphinxstyleemphasis{MUMPS} in distributed form through the local matrices \sphinxcode{\sphinxupquote{pr\#aRd}}.
The input \sphinxstyleemphasis{rhsi} is given as a distributed vector (\sphinxstyleemphasis{rhsi} is the restriction of the global right\sphinxhyphen{}hand side \(b\) to the subdomain of this mpi rank, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}}) and the returned vector is local as well.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Remark: rectangular operators}

\sphinxAtStartPar
It is possible to define a non\sphinxhyphen{}square distributed operator where the variational form takes two different finite element spaces of unknown and test functions. This is done through macro \sphinxstylestrong{ffddmsetupOperatorRect} which takes two FE prefixes (which must be defined on the same mesh prefix), see below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uB}\PYG{p}{,} \PYG{n}{uC}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{q}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{n}{ffddmsetupOperatorRect}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myFEprefixV}\PYG{p}{,}\PYG{n}{myFEprefixP}\PYG{p}{,}\PYG{n}{myVarf}\PYG{p}{)}
\end{sphinxVerbatim}




\bigskip\hrule\bigskip


\def\sphinxLiteralBlockLabel{\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildrhs}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Varfrhs}\PYG{p}{,}\PYG{n}{rhs}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the right\sphinxhyphen{}hand side associated to the variational form given by \sphinxstylestrong{Varfrhs} for the problem corresponding to prefix \sphinxstylestrong{pr}.
The resulting right\sphinxhyphen{}hand side vector \sphinxstylestrong{rhs} corresponds to the discretization of the abstract linear form given by the macro \sphinxstylestrong{Varfrhs} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).

\sphinxAtStartPar
The input vector \sphinxstylestrong{rhs} is resized and contains the resulting local right\sphinxhyphen{}hand side \(R_i b\), the restriction of the global right\sphinxhyphen{}hand side \(b\) to the subdomain of this mpi rank.
In the sequential case, the global right\sphinxhyphen{}hand side vector \(b\) is assembled instead.

\sphinxAtStartPar
An example is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{myVarfrhs}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n}{intN}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// EOM}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhsi}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(}\PYG{n}{myprefix}\PYG{p}{,}\PYG{n}{myVarfrhs}\PYG{p}{,}\PYG{n}{rhsi}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{One level preconditioners}
\label{\detokenize{documentation/ffddm/documentation:one-level-preconditioners}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{VarfPrec}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the one level preconditioner for problem \sphinxstylestrong{pr}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} has already been called with prefix \sphinxstylestrong{pr} in order to define the problem to solve.

\sphinxAtStartPar
In practice, this builds and performs the factorization of the local matrices used in the one level preconditioner.
The local matrices depend on the choice of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} and \sphinxstylestrong{VarfPrec}, see \sphinxcode{\sphinxupquote{pr\#aR}}below.

\sphinxAtStartPar
\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{string pr\#prec}} equal to {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}}.
Sets the type of one level preconditioner \(M^{-1}_1\) to be used: “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{}{[}int{]} pr\#aR}} array (size \sphinxcode{\sphinxupquote{prfe\#prmesh\#npart}}) of local matrices used for the one level preconditioner.
Each mpi rank of the spatial domain decomposition performs the \(LU\) (or \(LDL^T\)) factorization of the local matrix corresponding to its subdomain using the direct solver \sphinxstyleemphasis{MUMPS}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
If \sphinxstylestrong{VarfPrec} is not a previously defined macro (just put \sphinxstyleemphasis{null} for example), the matrices \sphinxcode{\sphinxupquote{pr\#aR}} are set to be equal to the so\sphinxhyphen{}called local ‘Dirichlet’ matrices \sphinxcode{\sphinxupquote{pr\#aRd}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}).
This is for the classical ASM preconditioner \(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T A_i^{-1} R_i\) or classical RAS preconditioner \(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i\) (it is assumed that {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “asm” or “ras”).

\item {} 
\sphinxAtStartPar
If \sphinxstylestrong{VarfPrec} is a macro, it is assumed that \sphinxstylestrong{VarfPrec} defines an abstract bilinear form (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
\begin{itemize}
\item {} 
\sphinxAtStartPar
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “asm” or “ras”, the matrices \sphinxcode{\sphinxupquote{pr\#aR}} will be assembled as local ‘Dirichlet’ matrices in the same manner as \sphinxcode{\sphinxupquote{pr\#aRd}}, but using the bilinear form defined by \sphinxstylestrong{VarfPrec} instead.
This defines the ASM preconditioner as \(M^{-1}_1 = M^{-1}_{\text{ASM}} = \sum_{i=1}^N R_i^T {(A_i^{\text{Prec}})}^{-1} R_i\) and the RAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i {(A_i^{\text{Prec}})}^{-1} R_i\), where \(A_i^{\text{Prec}} = R_i A^{\text{Prec}} R_i^T\).

\item {} 
\sphinxAtStartPar
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} is equal to “oras” or “soras”, the matrices \sphinxcode{\sphinxupquote{pr\#aR}} will correspond to the discretization of the variational form \sphinxstylestrong{VarfPrec} in the subdomains \(\Omega_i\).
In particular, various boundary conditions can be imposed at the interface between subdomains (corresponding to mesh boundary of label {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminterfacelabel}}}} set by the parent call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}), such as Optimized Robin boundary conditions.
We note the ORAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{ORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} R_i\) and the SORAS preconditioner as \(M^{-1}_1 = M^{-1}_{\text{SORAS}} = \sum_{i=1}^N R_i^T D_i {(B_i^{\text{Prec}})}^{-1} D_i R_i\).

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC1(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC1}} computes the parallel application of the one level preconditioner \(M^{-1}_1\), i.e. the action of \(M^{-1}_1\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(M^{-1}_1\) on a global vector.
The action of the inverse of local matrices \sphinxcode{\sphinxupquote{pr\#aRd}} is computed by forward\sphinxhyphen{}backward substitution using their \(LU\) (or \(LDL^T\)) decomposition.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC}} corresponds to the action of the preconditioner \(M^{-1}\) for problem \sphinxstylestrong{pr}.
It coincides with the one level preconditioner \sphinxcode{\sphinxupquote{pr\#PREC1}} after the call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}}.
If a second level is subsequently added (see the next section about {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners}}}}), it will then coincide with the two level preconditioner \(M^{-1}_2\) (see \sphinxcode{\sphinxupquote{pr\#PREC2level}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#fGMRES(pr\#prfe\#K{[}int{]}\& x0i, pr\#prfe\#K{[}int{]}\& bi, real eps, int nbiter, string sprec)}} The function \sphinxcode{\sphinxupquote{pr\#fGMRES}} allows to solve the linear system \(A x = b\) in parallel using the flexible GMRES method preconditioned by \(M^{-1}\).
The action of the global operator \(A\) is given by \sphinxcode{\sphinxupquote{pr\#A}}, the action of the preconditioner \(M^{-1}\) is given by \sphinxcode{\sphinxupquote{pr\#PREC}} and the scalar products are computed by \sphinxcode{\sphinxupquote{pr\#scalprod}}.
More details are given in the section {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}]{\sphinxcrossref{\DUrole{std,std-ref}{Solving the linear system}}}}.

\end{itemize}




\subsubsection{Two level preconditioners}
\label{\detokenize{documentation/ffddm/documentation:two-level-preconditioners}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}}
\sphinxAtStartPar
The main ingredient of a two level preconditioner is the so\sphinxhyphen{}called ‘coarse space’ matrix \(Z\).

\sphinxAtStartPar
\(Z\) is a rectangular matrix of size \(n \times n_c\), where usually \(n_c \ll n\).

\sphinxAtStartPar
\(Z\) is used to build the ‘coarse space operator’ \(E = Z^T A Z\), a square matrix of size \(n_c \times n_c\).
We can then define the ‘coarse space correction operator’ \(Q = Z E^{-1} Z^T = Z (Z^T A Z)^{-1} Z^T\), which can then be used to enrich the one level preconditioner through a correction formula.
The simplest one is the \sphinxstyleemphasis{additive} coarse correction: \(M^{-1}_2 = M^{-1}_1 + Q\).
See \sphinxcode{\sphinxupquote{pr\#corr}} below for all other available correction formulas.

\sphinxAtStartPar
There are multiple ways to define a relevant coarse space \(Z\) for different classes of problems.
{\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} defines a coarse space correction operator by building the GenEO coarse space, while {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcoarsemeshsetup}}}} builds the coarse space using a coarse mesh.

\sphinxAtStartPar
After a call to either {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} or {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcoarsemeshsetup}}}}, the following variables and functions are set up:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int pr\#ncoarsespace}} the size of the coarse space \(n_c\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{string pr\#corr}} initialized with the value of {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcorrection}}}}.
Specifies the type of coarse correction formula to use for the two level preconditioner.
The possible values are:

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{llllll}
\nonumber
    &&\text{"AD"}:&&\textit{Additive}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &&\text{"BNN"}:&&\textit{Balancing Neumann-Neumann}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q) + Q\\
    &&\text{"ADEF1"}:&&\textit{Adapted Deflation Variant 1}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1 (I - A Q) + Q\\
    &&\text{"ADEF2"}:&&\textit{Adapted Deflation Variant 2}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)} + Q\\
    &&\text{"RBNN1"}:&&\textit{Reduced Balancing Variant 1}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1 (I - A Q)\\
    &&\text{"RBNN2"}:&&\textit{Reduced Balancing Variant 2}, \quad &M^{-1} = M^{-1}_2 = (I - Q A) M^{-1}_1\phantom{ (I - A Q)}\\
    &&\text{"none"}:&&\textit{no coarse correction}, \quad &M^{-1} = M^{-1}_2 = \phantom{(I - Q A) }M^{-1}_1\phantom{ (I - A Q)}\\
\end{array}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Note that \sphinxstyleemphasis{AD}, \sphinxstyleemphasis{ADEF1} and \sphinxstyleemphasis{RBNN2} only require one application of \(Q\), while \sphinxstyleemphasis{BNN}, \sphinxstyleemphasis{ADEF2} and \sphinxstyleemphasis{RBNN1} require two.
The default coarse correction is \sphinxstyleemphasis{ADEF1}, which is cheaper and generally as robust as \sphinxstyleemphasis{BNN} or \sphinxstyleemphasis{ADEF2}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#Q(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#Q}} computes the parallel application of the coarse correction operator \(Q\), i.e. the action of \(Q = Z E^{-1} Z^T\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(Q\) on a global vector.
The implementation differs depending on the method used to build the coarse space (with GenEO or using a coarse mesh), but the idea is the same: the action of the transpose of the distributed operator \(Z\) on the distributed vector \(u_i\) is computed in parallel, with the contribution of all subdomains being gathered in a vector of size \(n_c\) in the mpi process of rank 0.
The action of the inverse of the coarse space operator \(E\) is then computed by forward\sphinxhyphen{}backward substitution using its \(LU\) (or \(LDL^T\)) decomposition previously computed by the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator.
The result is then sent back to all subdomains to perform the last application of \(Z\) and obtain the resulting local vector in each subdomain.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#PREC2level(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#PREC2level}} computes the parallel application of the two level preconditioner \(M^{-1}_2\), i.e. the action of \(M^{-1}_2\) on the local vector \(u_i\).
In the sequential case, it computes the action of \(M^{-1}_2\) on a global vector.
The two level preconditioner depends on the choice of the coarse correction formula which is determined by \sphinxcode{\sphinxupquote{pr\#corr}}, see above.

\end{itemize}




\paragraph{Building the GenEO coarse space}
\label{\detokenize{documentation/ffddm/documentation:building-the-geneo-coarse-space}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmgeneosetup}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This builds the GenEO coarse space for problem \sphinxstylestrong{pr}.
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} has already been called for prefix \sphinxstylestrong{pr} in order to define the one level preconditioner for problem \sphinxstylestrong{pr}.
The GenEO coarse space is \(Z = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \tau}\), where \(V_{i,k}\) are eigenvectors corresponding to eigenvalues \(\lambda_{i,k}\) of the following local generalized eigenvalue problem in subdomain \(i\):

\sphinxAtStartPar
\(D_i A_i D_i V_{i,k} = \lambda_{i,k} A_i^{\text{Neu}} V_{i,k}\),

\sphinxAtStartPar
where \(A_i^{\text{Neu}}\) is the local Neumann matrix of subdomain \(i\) (with Neumann boundary conditions at the subdomain interface).

\sphinxAtStartPar
In practice, this builds and factorizes the local Neumann matrices \(A_i^{\text{Neu}}\) corresponding to the abstract bilinear form given by the macro \sphinxstylestrong{Varf} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
In the GenEO method, the abstract bilinear form \sphinxstylestrong{Varf} is assumed to be the same as the one used to define the problem \sphinxstylestrong{pr} through the previous call to {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}.
The local generalized eigenvalue problem is then solved in each subdomain to find the eigenvectors \(V_{i,k}\) corresponding to the largest eigenvalues \(\lambda_{i,k}\) (see \sphinxcode{\sphinxupquote{pr\#Z}} below).
The number of computed eigenvectors \(\nu\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}}.
The eigenvectors selected to enter \(Z\) correspond to eigenvalues \(\lambda_{i,k}\) larger than \(\tau\), where the threshold parameter \(\tau\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}}.
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} \(= 0\), all {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} eigenvectors are selected.
Finally, the coarse space operator \(E = Z^T A Z\) is assembled and factorized (see \sphinxcode{\sphinxupquote{pr\#E}} below).

\sphinxAtStartPar
\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pr\#prfe\#K{[}int{]}{[}int{]} pr\#Z}} array of local eigenvectors \(Z_{i,k} = D_i V_{i,k}\) obtained by solving the local generalized eigenvalue problem above in the subdomain of this mpi rank using \sphinxstyleemphasis{Arpack}.
The number of computed eigenvectors \(\nu\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}}.
The eigenvectors selected to enter \(Z\) correspond to eigenvalues \(\lambda_{i,k}\) larger than \(\tau\), where the threshold parameter \(\tau\) is given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}}.
If {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} \(= 0\), all {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} eigenvectors are selected.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#E}} the coarse space operator \(E = Z^T A Z\).
The matrix \sphinxcode{\sphinxupquote{pr\#E}} is assembled in parallel and is factorized by the parallel direct solver \sphinxstyleemphasis{MUMPS} using the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem \sphinxstylestrong{pr}, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} and {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} for more details).

\end{itemize}




\paragraph{Building the coarse space from a coarse mesh}
\label{\detokenize{documentation/ffddm/documentation:building-the-coarse-space-from-a-coarse-mesh}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(}\PYG{n}{pr}\PYG{p}{,}\PYG{n}{Thc}\PYG{p}{,}\PYG{n}{VarfEprec}\PYG{p}{,}\PYG{n}{VarfAprec}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the coarse space for problem \sphinxstylestrong{pr} from a coarse problem which corresponds to the discretization of a variational form on a coarser mesh \sphinxstylestrong{Thc} of \(\Omega\).
This will create and expose variables whose names will be prefixed by \sphinxstylestrong{pr}, see below.
It is assumed that {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} has already been called for prefix \sphinxstylestrong{pr} in order to define the one level preconditioner for problem \sphinxstylestrong{pr}.
The abstract variational form for the coarse problem can differ from the original problem \sphinxstylestrong{pr} and is given by macro \sphinxstylestrong{VarfEprec} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}} for more details on how to define the abstract variational form as a macro).
For example, absorption can be added in the preconditioner for wave propagation problems, see examples for Helmholtz and Maxwell equations in the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.

\sphinxAtStartPar
The coarse space \(Z\) corresponds to the interpolation operator from the coarse finite element space to the original finite element space of the problem.
Thus, the coarse space operator \(E = Z^T A^{\text{Eprec}} Z\) corresponds to the matrix of the problem given by \sphinxstylestrong{VarfEprec} discretized on the coarse mesh \sphinxstylestrong{Thc} and is assembled as such.

\sphinxAtStartPar
Similarly, \sphinxstylestrong{VarfAprec} specifies the global operator involved in multiplicative coarse correction formulas.
For example, \(M^{-1}_{2,\text{ADEF1}} = M^{-1}_1 (I - A^{\text{Aprec}} Q) + Q\) (where \(Q = Z E^{-1} Z^T\)).
\(A^{\text{Aprec}}\) defaults to \(A\) if \sphinxstylestrong{VarfAprec} is not a valid macro (you can put \sphinxstyleemphasis{null} for example).

\sphinxAtStartPar
\sphinxstylestrong{defines}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{meshN pr\#ThCoarse}} the coarse mesh \sphinxstylestrong{Thc}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fespace pr\#VhCoarse}} the coarse finite element space of type \sphinxcode{\sphinxupquote{pr\#prfe\#fPk}} defined on the coarse mesh \sphinxcode{\sphinxupquote{pr\#ThCoarse}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#AglobEprec}} the global matrix \(A^{\text{Aprec}}\) corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{VarfAprec} on the global finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhglob}}.
Defined only in the sequential case.
\sphinxcode{\sphinxupquote{pr\#AglobEprec}} is equal to \sphinxcode{\sphinxupquote{pr\#Aglobal}} if \sphinxstylestrong{VarfAprec} is not a valid macro.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#aRdEprec}} the local ‘Dirichlet’ matrix corresponding to \sphinxstylestrong{VarfAprec}; it is the local restriction of the global operator \(A^{\text{Aprec}}\) to the subdomain, equivalent to \(A^{\text{Aprec}}_i = R_i A^{\text{Aprec}} R_i^T\) with \(A^{\text{Aprec}}\) the global matrix corresponding to the discretization of the variational form given by the macro \sphinxstylestrong{VarfAprec} on the global finite element space.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 0.
\sphinxcode{\sphinxupquote{pr\#aRdEprec}} is equal to \sphinxcode{\sphinxupquote{pr\#aRd{[}mpiRank(prmesh\#commddm){]}}} if \sphinxstylestrong{VarfAprec} is not a valid macro.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{func pr\#prfe\#K{[}int{]} pr\#AEprec(pr\#prfe\#K{[}int{]} \&ui)}} The function \sphinxcode{\sphinxupquote{pr\#AEprec}} computes the parallel matrix\sphinxhyphen{}vector product, i.e. the action of the global operator \(A^{\text{Aprec}}\) on the local vector \(u_i\).
The computation is equivalent to \(R_i (\sum_{j=1}^N R_j^T D_j A^{\text{Aprec}}_j u_j)\) and is performed in parallel using local matrices \sphinxcode{\sphinxupquote{pr\#aRdEprec}} and the function \sphinxcode{\sphinxupquote{pr\#prfe\#update}}.
In the sequential case, the global matrix \sphinxcode{\sphinxupquote{pr\#AglobEprec}} is used instead.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ZCM}} the interpolation operator \(Z\) from the coarse finite element space \sphinxcode{\sphinxupquote{pr\#VhCoarse}} to the global finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhglob}}.
Defined only in the sequential case.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ZCMi}} the local interpolation operator \(Z_i\) from the coarse finite element space \sphinxcode{\sphinxupquote{pr\#VhCoarse}} to the local finite element space \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}}.
Defined only if this mpi rank is not excluded from the spatial domain decomposition, i. e. \sphinxcode{\sphinxupquote{prmesh\#excluded}} = 0.
\sphinxcode{\sphinxupquote{pr\#ZCMi}} is used for the parallel application of \(Z\) and \(Z^T\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{matrix\textless{}pr\#prfe\#K\textgreater{} pr\#ECM}} the coarse space operator \(E = Z^T A^{\text{Eprec}} Z\).
The matrix \sphinxcode{\sphinxupquote{pr\#ECM}} is assembled by discretizing the variational form given by \sphinxstylestrong{VarfEprec} on the coarse mesh and factorized by the parallel direct solver \sphinxstyleemphasis{MUMPS} using the first \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#pCS}} ranks of the mpi communicator, with mpi rank 0 as the master process.
The number of mpi processes dedicated to the coarse problem is set by the underlying mesh decomposition of problem \sphinxstylestrong{pr}, which also specifies if these mpi ranks are excluded from the spatial decomposition or not.
These parameters are set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} and {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} for more details).

\end{itemize}


\subsubsection{Solving the linear system}
\label{\detokenize{documentation/ffddm/documentation:solving-the-linear-system}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{fGMRES}\PYG{p}{(}\PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{x0i}\PYG{p}{,} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{itmax}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{sp}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
solves the linear system for problem \sphinxstylestrong{pr} using the flexible GMRES algorithm with preconditioner \(M^{-1}\) (corresponding to \sphinxcode{\sphinxupquote{pr\#PREC}}).
Returns the local vector corresponding to the restriction of the solution to \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}}.
\sphinxstylestrong{x0i} and \sphinxstylestrong{bi} are local distributed vectors corresponding respectively to the initial guess and the right\sphinxhyphen{}hand side (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildrhs}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildrhs}}}}).
\sphinxstylestrong{eps} is the stopping criterion in terms of the relative decrease in residual norm.
If \sphinxstylestrong{eps} \(< 0\), the residual norm itself is used instead.
\sphinxstylestrong{itmax} sets the maximum number of iterations.
\sphinxstylestrong{sp} selects between the \sphinxcode{\sphinxupquote{"left"}} or \sphinxcode{\sphinxupquote{"right"}} preconditioning variants: \sphinxstyleemphasis{left} preconditioned GMRES solves \(M^{-1} A x = M^{-1} b\), while \sphinxstyleemphasis{right} preconditioned GMRES solves \(A M^{-1} y = b\) for \(y\), with \(x = M^{-1} y\).


\subsubsection{Using \sphinxstyleemphasis{HPDDM} within \sphinxstyleemphasis{ffddm}}
\label{\detokenize{documentation/ffddm/documentation:using-hpddm-within-ffddm}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}}
\sphinxAtStartPar
\sphinxstylestrong{ffddm} allows you to use \sphinxstylestrong{HPDDM} to solve your problem, effectively replacing the \sphinxstylestrong{ffddm} implementation of all parallel linear algebra computations.
\sphinxstylestrong{ffddm} can then be viewed as a finite element interface for \sphinxstylestrong{HPDDM}.

\sphinxAtStartPar
You can use \sphinxstylestrong{HPDDM} features unavailable in \sphinxstylestrong{ffddm} such as advanced Krylov subspace methods implementing block and recycling techniques.

\sphinxAtStartPar
To switch to \sphinxstylestrong{HPDDM}, simply define the macro \sphinxcode{\sphinxupquote{pr\#withhpddm}} before using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}. You can then pass \sphinxstylestrong{HPDDM} options
with command\sphinxhyphen{}line arguments or directly to the underlying \sphinxstylestrong{HPDDM} operator \sphinxcode{\sphinxupquote{pr\#hpddmOP}}. Options need to be prefixed by the operator prefix:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{PBwithhpddm}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{PBhpddmOP}\PYG{p}{,}\PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}PB\PYGZus{}krylov\PYGZus{}method gcrodr \PYGZhy{}hpddm\PYGZus{}PB\PYGZus{}recycle 10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can also choose to replace only the Krylov solver, by defining the macro \sphinxcode{\sphinxupquote{pr\#withhpddmkrylov}} before using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupOperator}}}}.
Doing so, a call to \sphinxcode{\sphinxupquote{pr\#fGMRES}} will call the \sphinxstylestrong{HPDDM} Krylov solver, with \sphinxstylestrong{ffddm} providing the operator and preconditioner through \sphinxcode{\sphinxupquote{pr\#A}} and \sphinxcode{\sphinxupquote{pr\#PREC}}. You can then pass \sphinxstylestrong{HPDDM} options to the Krylov solver through command\sphinxhyphen{}line arguments:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{PBwithhpddmkrylov}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For example, using restarted GCRO\sphinxhyphen{}DR(40) and recycling 10 Ritz vectors at each restart:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{4} test.edp \PYGZhy{}wg \PYGZhy{}hpddm\PYGZus{}krylov\PYGZus{}method gcrodr \PYGZhy{}hpddm\PYGZus{}recycle \PYG{l+m}{10} \PYGZhy{}ffddm\PYGZus{}gmres\PYGZus{}restart \PYG{l+m}{40}
\end{sphinxVerbatim}

\sphinxAtStartPar
An example can be found in \sphinxstylestrong{Helmholtz\sphinxhyphen{}2d\sphinxhyphen{}HPDDM\sphinxhyphen{}BGMRES.edp}, see the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.


\subsubsection{Advanced use}
\label{\detokenize{documentation/ffddm/documentation:advanced-use}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationadvanced}}



\paragraph{Interpolation between two distributed finite element spaces}
\label{\detokenize{documentation/ffddm/documentation:interpolation-between-two-distributed-finite-element-spaces}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationinterpolation}}
\sphinxAtStartPar
The parallel interpolation of a distributed finite element function to another distributed finite element space can be computed using the \sphinxcode{\sphinxupquote{prfe\#transferfromVhi}} macro. Internally, it uses the \sphinxcode{\sphinxupquote{transfer}} macro from the \sphinxcode{\sphinxupquote{macro\_ddm.idp}} script. The macro is prefixed by the source finite element prefix \sphinxstylestrong{prfe} and is used a follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{transferfromVhi}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,}\PYG{n}{Vht}\PYG{p}{,}\PYG{n}{Pkt}\PYG{p}{,}\PYG{n}{rest}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxstylestrong{us} is distributed source FE function defined on \sphinxcode{\sphinxupquote{prfe\#Vhi}}, \sphinxstylestrong{Vht} is the target local finite element space, \sphinxstylestrong{Pkt} is the approximation space corresponding to \sphinxstylestrong{Vht} and \sphinxstylestrong{rest} is the target local FE function defined on \sphinxstylestrong{Vht}. You can find an example below:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{dimension}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{2}\PYG{c+c1}{//}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Tht} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{Ms}\PYG{p}{,}\PYG{n}{Ths}\PYG{p}{,}\PYG{k+kr}{mpiCommWorld}\PYG{p}{)}

\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{Mt}\PYG{p}{,}\PYG{n}{Tht}\PYG{p}{,}\PYG{k+kr}{mpiCommWorld}\PYG{p}{)}

\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,}\PYG{n}{u}\PYG{p}{]}\PYG{c+c1}{//}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FEs}\PYG{p}{,}\PYG{n}{Ms}\PYG{p}{,}\PYG{k+kt}{real}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{)}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FEt}\PYG{p}{,}\PYG{n}{Mt}\PYG{p}{,}\PYG{k+kt}{real}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{)}

\PYG{n}{FEsVhi} \PYG{n}{def}\PYG{p}{(}\PYG{n}{us}\PYG{p}{)} \PYG{o}{=} \PYG{p}{[}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

\PYG{n}{FEtVhi} \PYG{n+nf}{def}\PYG{p}{(}\PYG{n}{ut}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{FEstransferfromVhi}\PYG{p}{(}\PYG{n}{us}\PYG{p}{,}\PYG{n}{FEtVhi}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{,}\PYG{n}{ut}\PYG{p}{)}

\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FEs}\PYG{p}{,}\PYG{n}{us}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u source}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FEt}\PYG{p}{,}\PYG{n}{ut}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u target}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Local finite element spaces for non Lagrange finite elements}
\label{\detokenize{documentation/ffddm/documentation:local-finite-element-spaces-for-non-lagrange-finite-elements}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationpartitionunityedge}}
\sphinxAtStartPar
For Lagrange finite elements, the partition of unity \((D_i)_{i=1,...,N}\) (see \sphinxcode{\sphinxupquote{prfe\#Dk}} and \sphinxcode{\sphinxupquote{prfe\#Dih}}) is built by interpolating the local P1 partition of unity function onto the components of the \sphinxstylestrong{Pk} finite element space \sphinxcode{\sphinxupquote{prfe\#Vhi}}.
For non Lagrange finite element spaces, such as Raviart\textendash{}Thomas or Nédélec edge elements, the definition of the degrees of freedom can be more involved, and interpolating the P1 partition of unity functions directly is inappropriate.
The idea is then to use a “pseudo” finite element \sphinxstylestrong{Pkpart} derived from \sphinxstylestrong{Pk} which is suitable for interpolating the P1 partition of unity, in the sense that it will produce a partition of unity for \sphinxstylestrong{Pk}.

\sphinxAtStartPar
For example, for first\sphinxhyphen{}order Nédélec edge elements (\sphinxstyleemphasis{Edge03d}), whose degrees of freedom are the circulations along the edges, we define the “pseudo” finite element \sphinxstyleemphasis{Edge03ds0} which can be seen as a scalar Lagrange counterpart: the numbering of the degrees of freedom is the same, but they correspond to the value at the edge midpoints.

\sphinxAtStartPar
For Lagrange finite elements, the distributed finite element spaces are built using {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDfespace}}}}. Here you must use \sphinxstylestrong{ffddmbuildDfespaceEdge}, which builds the distributed finite element space using a “pseudo” finite element to build the partition of unity:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespaceEdge}\PYG{p}{(}\PYG{n}{prfe}\PYG{p}{,}\PYG{n}{prmesh}\PYG{p}{,}\PYG{n}{scalar}\PYG{p}{,}\PYG{n}{def}\PYG{p}{,}\PYG{k+kp}{init}\PYG{p}{,}\PYG{n}{Pk}\PYG{p}{,}\PYG{n}{defpart}\PYG{p}{,}\PYG{n}{initpart}\PYG{p}{,}\PYG{n}{Pkpart}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
where macros \sphinxstylestrong{defpart} and \sphinxstylestrong{initpart} specify how to define and interpolate a function in the ‘pseudo’ finite element space \sphinxstylestrong{Pkpart}, similar to \sphinxstylestrong{def} and \sphinxstylestrong{init} for \sphinxstylestrong{Pk}.

\sphinxAtStartPar
An example with first\sphinxhyphen{}order Nédélec edge elements (\sphinxstyleemphasis{Edge03d} + \sphinxstyleemphasis{Edge03ds0}) for Maxwell equations can be found in \sphinxstylestrong{Maxwell\sphinxhyphen{}3d\sphinxhyphen{}simple.edp}, see the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section.


\paragraph{Inexact coarse solves for two level methods}
\label{\detokenize{documentation/ffddm/documentation:inexact-coarse-solves-for-two-level-methods}}\label{\detokenize{documentation/ffddm/documentation:ffddmdocumentationinexactcoarsesolve}}
\sphinxAtStartPar
We have seen in the {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners section}}}} that two level methods produce a ‘coarse space operator’ \(E\) that needs to be inverted at each iteration.
By default the coarse space operator matrix is factorized by the direct solver \sphinxstyleemphasis{MUMPS}. This can become a bottleneck and hinder scalability for large problems, where \(E\) can become too large to be factorized efficiently.
To remedy this, we can instead opt to use an iterative method to solve the coarse problem at each iteration.  Moreover, in order to retain robustness, a DD preconditioner can be used to solve the inner coarse problem more efficiently.




\subparagraph{Coarse mesh and inexact coarse solve}
\label{\detokenize{documentation/ffddm/documentation:coarse-mesh-and-inexact-coarse-solve}}
\sphinxAtStartPar
When the coarse problem comes from a coarse mesh discretization, a natural way to do inexact coarse solve is to use a one level domain decomposition method on the coarse problem, with the same subdomain partitioning for the coarse and fine meshes.
This means that each processor is associated to one spatial subdomain and hosts the two local (nested) coarse and fine submeshes corresponding to this subdomain, as well as the corresponding local matrices for the two discretizations.
This natural choice offers interesting benefits:
\begin{itemize}
\item {} 
\sphinxAtStartPar
We naturally recover a load\sphinxhyphen{}balanced parallel implementation, provided that the initial partitioning is balanced.

\item {} 
\sphinxAtStartPar
The communication pattern between neighboring subdomains is the same for the coarse and fine discretizations.

\item {} 
\sphinxAtStartPar
The assembly and the application of the interpolation operator \(Z\) (and \(Z^T\)) between the fine and the coarse spaces can be computed locally in each subdomain and require no communication.

\end{itemize}

\sphinxAtStartPar
In \sphinxstylestrong{ffddm}, the first step is to build the two nested mesh decompositions using \sphinxstylestrong{ffddmbuildDmeshNested}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmeshNested}\PYG{p}{(}\PYG{n}{prmesh}\PYG{p}{,}\PYG{n}{Thc}\PYG{p}{,}\PYG{n}{s}\PYG{p}{,}\PYG{n}{comm}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
decomposes the coarse mesh \sphinxstylestrong{Thc} into overlapping submeshes and creates the fine decomposition by locally refining submeshes by a factor of \sphinxstylestrong{s}, i.e. splitting each mesh element into \(s^d\) elements, \(s \geq 1\).
This will create and expose variables corresponding to both decompositions, prefixed by \sphinxstylestrong{prmesh} for the fine mesh and by \sphinxstylestrong{prmesh\#Coarse} for the coarse mesh (see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}).
It also sets the integer variable \sphinxcode{\sphinxupquote{prmesh\#binexactCS}} to 1, which specifies that any two level method defined on mesh prefix \sphinxstylestrong{prmesh} will use inexact coarse solves.

\sphinxAtStartPar
The distributed finite element spaces, operators and preconditioners can then be defined for both decompositions. Here is an example where the coarse problem is solved using a one level method:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmeshNested}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{Thc}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{mpiCommWorld}\PYG{p}{)}

\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FECoarse}\PYG{p}{,} \PYG{n}{MCoarse}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}

\PYG{c+c1}{// coarse operator (Varf of E):}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{PBCoarse}\PYG{p}{,} \PYG{n}{FECoarse}\PYG{p}{,} \PYG{n}{VarfEprec}\PYG{p}{)}
\PYG{c+c1}{// one level preconditioner for the coarse problem:}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(}\PYG{n}{PBCoarse}\PYG{p}{,} \PYG{n}{VarfPrecC}\PYG{p}{)}

\PYG{c+c1}{// operator for the fine problem:}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{Varf}\PYG{p}{)}
\PYG{c+c1}{// one level preconditioner for the fine problem:}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{VarfPrec}\PYG{p}{)}

\PYG{c+c1}{// add the second level:}
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{Thc}\PYG{p}{,} \PYG{n}{VarfEprec}\PYG{p}{,} \PYG{n}{null}\PYG{p}{)}

\PYG{p}{[}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0}\PYG{p}{,} \PYG{n}{rhs}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Remarks}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Note that the different prefixes need to match: prefixes for the coarse decomposition have to be those of the fine decomposition, appended with \sphinxcode{\sphinxupquote{Coarse}}.

\item {} 
\sphinxAtStartPar
The operator and preconditioner for the coarse problem have to be defined before those of the fine problem, because the \sphinxcode{\sphinxupquote{pr\#Q}} function is actually defined by \sphinxcode{\sphinxupquote{ffddmsetupPrecond}} and involves a call to \sphinxcode{\sphinxupquote{pr\#CoarsefGMRES}} (which is defined by \sphinxcode{\sphinxupquote{ffddmsetupPrecond}} for the coarse problem) for the iterative solution of the coarse problem if \sphinxcode{\sphinxupquote{pr\#prfe\#prmesh\#binexactCS}} \(\neq 0\).

\item {} 
\sphinxAtStartPar
In this case, \sphinxcode{\sphinxupquote{ffddmcoarsemeshsetup}} does not use \sphinxstylestrong{Thc} or \sphinxstylestrong{VarfEprec} and only builds the local interpolation matrices between fine and coarse local finite element spaces \sphinxcode{\sphinxupquote{pr\#prfe\#Vhi}} and \sphinxcode{\sphinxupquote{pr\#prfe\#CoarseVhi}} to be able to apply \(Z\) and \(Z^T\).

\item {} 
\sphinxAtStartPar
The GMRES tolerance for the inner solution of the coarse problem is set by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminexactCStol}}}} and is equal to 0.1 by default.

\end{itemize}

\sphinxAtStartPar
In practice, these methods can give good results for wave propagation problems, where the addition of artificial absorption in the preconditioner helps with the convergence of the one level method for the inner solution of the coarse problem.
You can find an example for Maxwell equations in \sphinxstylestrong{Maxwell\_Cobracavity.edp}, see the {\hyperref[\detokenize{documentation/ffddm/examples:ffddmexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{Examples}}}} section. More details can be found \sphinxhref{../../\_static/html/tutorial-slides.html\#26}{here} and in
\begin{quote}

\sphinxAtStartPar
M. Bonazzoli, V. Dolean, I. G. Graham, E. A. Spence, P.\sphinxhyphen{}H. Tournier. Domain decomposition preconditioning for the high\sphinxhyphen{}frequency time\sphinxhyphen{}harmonic Maxwell equations with absorption. Mathematics of Computation, 2019. DOI: \sphinxurl{https://doi.org/10.1090/mcom/3447}
\end{quote}




\subsection{Parameters}
\label{\detokenize{documentation/ffddm/parameters:parameters}}\label{\detokenize{documentation/ffddm/parameters::doc}}

\subsubsection{Command\sphinxhyphen{}line arguments}
\label{\detokenize{documentation/ffddm/parameters:command-line-arguments}}\label{\detokenize{documentation/ffddm/parameters:ffddmparameterscommandline}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_verbosity N}}, the level of verbosity of \sphinxstylestrong{ffddm}, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmverbosity}}}} (default 3).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}seqddm N}} use \sphinxstylestrong{ffddm} in sequential mode, with N the number of subdomains.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}noGlob}} if present, do not define any global quantity (such as saving the global mesh for plotting or building the global restriction matrices).
Cannot be used in sequential mode or with plotting.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_partitioner N}} specifies how to partition the initial domain, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpartitioner}}}} (default 1, \sphinxstyleemphasis{metis}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_overlap N}} specifies the width of the overlap region between subdomains, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}} (default 1).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_master\_p N}}, number of master processes for the coarse problem (for two level preconditioners), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmpCS}}}} (default 1).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_master\_exclude 0|1}} exclude master processes from the domain decomposition, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmexclude}}}} (default 0).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_split N}}, level of refinement of the local submeshes with respect to the initial global mesh, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}} (default 1).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_schwarz\_method S}}, specifies the type of one level preconditioner \(M^{-1}_1\): “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmprecond}}}} (default “ras”).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_geneo\_nu N}}, number of local eigenvectors to compute in each subdomain when solving the local generalized eigenvalue problem for the GenEO method, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmnu}}}} (default 20).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_geneo\_threshold R}}, threshold parameter for selecting local eigenvectors when solving the local generalized eigenvalue problems for the GenEO method, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} (default 0.5).
If the command\sphinxhyphen{}line parameter \sphinxstylestrong{\sphinxhyphen{}ffddm\_geneo\_nu N} is used, then {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} is initialized to 0.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_schwarz\_coarse\_correction S}}, specifies the coarse correction formula to use for the two level preconditioner: “AD” (\sphinxstyleemphasis{Additive}), “BNN” (\sphinxstyleemphasis{Balancing Neumann\sphinxhyphen{}Neumann}), “ADEF1” (\sphinxstyleemphasis{Adapted Deflation Variant 1}), “ADEF2” (\sphinxstyleemphasis{Adapted Deflation Variant 2}), “RBNN1” (\sphinxstyleemphasis{Reduced Balancing Variant 1}), “RBNN2” (\sphinxstyleemphasis{Reduced Balancing Variant 2}) or “none” (no coarse correction), see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmcorrection}}}} (default “ADEF1”).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}ffddm\_inexactCS\_tol R}}, specifies the GMRES tolerance for the inner solution of the coarse problem when using a two level method with approximate coarse solves, see {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddminexactCStol}}}} (default 0.1).

\end{itemize}


\subsubsection{Global parameters}
\label{\detokenize{documentation/ffddm/parameters:global-parameters}}\label{\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmverbosity}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_verbosity N}, specifies the level of verbosity of \sphinxstylestrong{ffddm} (default 3).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmpartitioner}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_partitioner N}, specifies how to partition the initial domain:
\begin{itemize}
\item {} 
\sphinxAtStartPar
N=0: user\sphinxhyphen{}defined partition through the definition of a macro, see {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}}

\item {} 
\sphinxAtStartPar
N=1: use the automatic graph partitioner \sphinxstyleemphasis{metis} (default)

\item {} 
\sphinxAtStartPar
N=2: use the automatic graph partitioner \sphinxstyleemphasis{scotch}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmoverlap}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_overlap N}, specifies the number of layers of mesh elements in the overlap region between subdomains N \textgreater{}= 1 (default 1).
\sphinxstylestrong{Remark} The actual width of the overlap region between subdomains is 2N, since each subdomain is extended by N layers of elements in a symmetric way.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddminterfacelabel}} the label of the new border of the subdomain meshes (the interface between the subdomains) (default 10).
Used for imposing problem\sphinxhyphen{}dependent boundary conditions at the interface between subdomains for the preconditioner, for example optimized Robin boundary conditions (see ORAS).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmpCS}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_master\_p N}, number of mpi processes used for the assembly and resolution of the coarse problem for two level preconditioners (default 1).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmexclude}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_master\_exclude}, 0 or 1 (default 0).
If true, mpi ranks participating in the assembly and resolution of the coarse problem for two level preconditioners will be excluded from the spatial domain decomposition and will only work on the coarse problem.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmsplit}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{ffddm\_split N}, level of refinement of the local submeshes with respect to the initial global mesh (default 1).
This is useful for large problems, where we want to avoid working with a very large global mesh.
The idea is to start from a coarser global mesh, and generate finer local meshes in parallel during the mesh decomposition step in order to reach the desired level of refinement for the subdomains.
For example, calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmbuildDmesh}}}} with {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsplit}}}} = 3 will generate local submeshes where each mesh element of the initial mesh is split into \(3^d\) elements.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmprecond}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_schwarz\_method S}, specifies the type of one level preconditioner \(M^{-1}_1\) to build when calling {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}}: “asm” (\sphinxstyleemphasis{Additive Schwarz}), “ras” (\sphinxstyleemphasis{Restricted Additive Schwarz}), “oras” (\sphinxstyleemphasis{Optimized Restricted Additive Schwarz}), “soras” (\sphinxstyleemphasis{Symmetric Optimized Restricted Additive Schwarz}) or “none” (no preconditioner).
Default is “ras”.
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmsetupPrecond}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmnu}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_geneo\_nu N}, number of local eigenvectors to compute in each subdomain when solving the local generalized eigenvalue problem for the GenEO method (default 20).
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmtau}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_geneo\_threshold R}, threshold parameter for selecting local eigenvectors when solving the local generalized eigenvalue problems for the GenEO method (default 0.5).
If the command\sphinxhyphen{}line parameter \sphinxstylestrong{\sphinxhyphen{}ffddm\_geneo\_nu N} is used, then {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmtau}}}} is initialized to 0.
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmgeneosetup}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddmcorrection}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_schwarz\_coarse\_correction S}, specifies the coarse correction formula to use for the two level preconditioner: “AD” (\sphinxstyleemphasis{Additive}), “BNN” (\sphinxstyleemphasis{Balancing Neumann\sphinxhyphen{}Neumann}), “ADEF1” (\sphinxstyleemphasis{Adapted Deflation Variant 1}), “ADEF2” (\sphinxstyleemphasis{Adapted Deflation Variant 2}), “RBNN1” (\sphinxstyleemphasis{Reduced Balancing Variant 1}), “RBNN2” (\sphinxstyleemphasis{Reduced Balancing Variant 2}) or “none” (no coarse correction).
Default is “ADEF1”.
See the section about {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{Two level preconditioners}}}} for more details.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ffddminexactCStol}} initialized by command\sphinxhyphen{}line argument \sphinxstylestrong{\sphinxhyphen{}ffddm\_inexactCS\_tol R}, GMRES tolerance for the inner solution of the coarse problem when using a two level method with approximate coarse solves (default 0.1).
See the section about \DUrole{xref,std,std-ref}{Approximate coarse solves for two level methods} for more details.

\end{itemize}


\subsection{Tutorial}
\label{\detokenize{documentation/ffddm/tutorial:tutorial}}\label{\detokenize{documentation/ffddm/tutorial:ffddmtutorial}}\label{\detokenize{documentation/ffddm/tutorial::doc}}
\sphinxAtStartPar
Authors: Pierre\sphinxhyphen{}Henri Tournier \sphinxhyphen{} Frédéric Nataf \sphinxhyphen{} Pierre Jolivet


\subsubsection{What is \sphinxstylestrong{ffddm} ?}
\label{\detokenize{documentation/ffddm/tutorial:what-is-ffddm}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ffddm} implements a class of parallel solvers in \sphinxstyleemphasis{FreeFEM}: \sphinxstyleemphasis{overlapping Schwarz domain decomposition methods}

\item {} \begin{description}
\item[{The entire \sphinxstylestrong{ffddm} framework is written in the \sphinxstyleemphasis{FreeFEM} language \sphinxstylestrong{ffddm} aims at simplifying the use of parallel solvers in \sphinxstyleemphasis{FreeFEM}}] \leavevmode
\sphinxAtStartPar
You can find the \sphinxstylestrong{ffddm} scripts \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/idp}{here} (‘ffddm*.idp’ files) and examples \sphinxhref{https://github.com/FreeFem/FreeFem-sources/tree/develop/examples/ffddm}{here}

\end{description}

\item {} \begin{description}
\item[{\sphinxstylestrong{ffddm} provides a set of high\sphinxhyphen{}level macros and functions to}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
handle data distribution: distributed meshes and linear algebra

\item {} 
\sphinxAtStartPar
build DD preconditioners for your variational problems

\item {} 
\sphinxAtStartPar
solve your problem using preconditioned Krylov methods

\end{itemize}

\end{description}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ffddm} implements scalable two level Schwarz methods, with a coarse space correction built either from a coarse mesh or a \sphinxhref{https://link.springer.com/article/10.1007\%2Fs00211-013-0576-y}{GenEO} coarse space \sphinxstyleemphasis{Ongoing research}: approximate coarse solves and three level methods

\item {} \begin{description}
\item[{\sphinxstylestrong{ffddm} can also act as a wrapper for the \sphinxhref{https://github.com/hpddm/hpddm}{HPDDM} library.}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{HPDDM} is an efficient C++11 implementation of various domain decomposition methods and Krylov subspace algorithms with advanced block and recycling techniques More details on how to use \sphinxstylestrong{HPDDM} within \sphinxstylestrong{ffddm} {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{here}}}}

\end{description}

\end{itemize}


\subsubsection{Why Domain Decomposition Methods ?}
\label{\detokenize{documentation/ffddm/tutorial:why-domain-decomposition-methods}}
\sphinxAtStartPar
How can we solve a large sparse linear system \(A u = b \in \mathbb{R}^n\) ?

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Methods_Solves_1}.png}


\paragraph{Step 1: Decompose the mesh}
\label{\detokenize{documentation/ffddm/tutorial:step-1-decompose-the-mesh}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxAtStartPar
Build a collection of \(N\) overlapping sub\sphinxhyphen{}meshes \((Th_{i})_{i=1}^N\) from the global mesh \(Th\)


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{domain1}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{domain2}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{prmesh} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{n}{comm} \PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
mesh distributed over the MPI processes of communicator \sphinxstylestrong{comm}

\item {} 
\sphinxAtStartPar
initial mesh \sphinxstylestrong{ThGlobal} partitioned with \sphinxstyleemphasis{metis} by default

\item {} 
\sphinxAtStartPar
size of the overlap given by {\hyperref[\detokenize{documentation/ffddm/parameters:ffddmparametersglobal}]{\sphinxcrossref{\DUrole{std,std-ref}{ffddmoverlap}}}} (default 1)

\end{itemize}

\sphinxAtStartPar
\sphinxtitleref{prmesh\#Thi} is the local mesh of the subdomain for each mpi process

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Copy and paste this to a file ‘test.edp’ and run it:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{2} test.edp \PYGZhy{}wg
\end{sphinxVerbatim}


\paragraph{Step 2: Define your finite element}
\label{\detokenize{documentation/ffddm/tutorial:step-2-define-your-finite-element}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{prfe} \PYG{p}{,} \PYG{n}{prmesh} \PYG{p}{,} \PYG{n}{scalar} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n}{Pk} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the local finite element spaces and associated distributed operators on top of the mesh decomposition \sphinxstylestrong{prmesh}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scalar}: type of data for this finite element: \sphinxstyleemphasis{real} or \sphinxstyleemphasis{complex}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pk}: your type of finite element: P1, {[}P2,P2,P1{]}, …

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{def}, \sphinxstylestrong{init}: macros specifying how to define and initialize a \sphinxstylestrong{Pk} FE function

\end{itemize}

\sphinxAtStartPar
\sphinxtitleref{prfe\#Vhi} is the local FE space defined on \sphinxtitleref{prmesh\#Thi} for each mpi process

\sphinxAtStartPar
Example for P2 \sphinxstyleemphasis{complex}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{complex}\PYG{p}{,}
                    \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Example for {[}P2,P2,P1{]} \sphinxstyleemphasis{real}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{n}{C}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{u}\PYG{p}{]}     \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,}
                    \PYG{k+kp}{init}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]} \PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{Distributed vectors and restriction operators}
\label{\detokenize{documentation/ffddm/tutorial:distributed-vectors-and-restriction-operators}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{domain2}.png}\hspace*{\fill}}

\sphinxAtStartPar
Natural decomposition of the set of d.o.f.’s \({\mathcal N}\) of \(Vh\) into the \(N\) subsets of d.o.f.’s \(({\mathcal N}_i)_{i=1}^N\) each associated with the local FE space \(Vh_i\)
\begin{equation*}
\begin{split}{\mathcal N} = \cup_{i=1}^N {\mathcal N}_i\,,\end{split}
\end{equation*}
\sphinxAtStartPar
but with duplications of the d.o.f.’s in the overlap

\sphinxAtStartPar
\sphinxstylestrong{\_Definition\_} a \sphinxstyleemphasis{distributed vector} is a collection of local vectors \(({\mathbf V_i})_{1\le i\le N}\) so that the values on the duplicated d.o.f.’s are the same:
\begin{equation*}
\begin{split}{\mathbf V}_i = R_i\,{\mathbf V}, \quad i = 1, ..., N\end{split}
\end{equation*}
\sphinxAtStartPar
where \({\mathbf V}\) is the corresponding global vector
and \(R_i\) is the \sphinxstyleemphasis{restriction operator} from \({\mathcal N}\) into \({\mathcal N}_i\)

\sphinxAtStartPar
\sphinxstylestrong{Remark} \(R_i^T\) is the \sphinxstyleemphasis{extension operator}: extension by \(0\) from \({\mathcal N}_i\) into \({\mathcal N}\)


\subparagraph{Partition of unity}
\label{\detokenize{documentation/ffddm/tutorial:partition-of-unity}}
\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{domain3}.png}\hspace*{\fill}}

\sphinxAtStartPar
Duplicated unknowns coupled via a \sphinxstyleemphasis{partition of unity}:
\begin{equation*}
\begin{split}I = \sum_{i = 1}^N R_i^T D_i R_i\end{split}
\end{equation*}
\sphinxAtStartPar
\((D_i)_{1\le i \le N}\) are square diagonal matrices of size \(\#{\mathcal N}_i\)
\begin{equation*}
\begin{split}{\mathbf V} = \sum_{i = 1}^N R_i^T D_i R_i {\mathbf V} = \sum_{i = 1}^N R_i^T D_i {\mathbf V_i}\end{split}
\end{equation*}

\subparagraph{Data exchange between neighbors}
\label{\detokenize{documentation/ffddm/tutorial:data-exchange-between-neighbors}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{prfe}\PYG{o}{\PYGZsh{}}\PYG{n}{update}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vi}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{scale}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
synchronizes local vectors \({\mathbf V}_i\) between subdomains \(\Rightarrow\) exchange the values of \(mathbf{V}_i\) shared with neighbors in the overlap region
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T D_j {\mathbf V}_j \right) = D_i {\mathbf V}_i + \sum_{j\in \mathcal{O}(i)} R_i\,R_j^T\,D_j {\mathbf V}_j\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathcal{O}(i)\) is the set of neighbors of subdomain \$i\$. Exchange operators \(R_i\,R_j^T\) correspond to neighbor\sphinxhyphen{}to\sphinxhyphen{}neighbor MPI communications

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T {\mathbf V}_j \right)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{,} \PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}{\mathbf V}_i \leftarrow R_i \left( \sum_{j=1}^N R_j^T D_j {\mathbf V}_j  \right)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{vi} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{FEDk}\PYG{p}{[}\PYG{k+kr}{mpirank}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kr}{mpirank}\PYG{p}{,} \PYG{n}{MThi}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{vi} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,}\PYG{n}{vi}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{FEupdate}\PYG{p}{(}\PYG{n}{vi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,}\PYG{n}{vi}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{multiplicity}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Step 3: Define your problem}
\label{\detokenize{documentation/ffddm/tutorial:step-3-define-your-problem}}\label{\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{prfe} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the distributed operator associated to your variational form on top of the distributed FE \sphinxstylestrong{prfe}

\sphinxAtStartPar
\sphinxstylestrong{Varf} is a macro defining your abstract variational form

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\end{sphinxVerbatim}

\sphinxAtStartPar
\(\Rightarrow\) assemble local ‘Dirichlet’ matrices \(A_i = R_i A R_i^T\)
\begin{equation*}
\begin{split}A = \sum_{i=1}^N R_i^T D_i A_i R_i\end{split}
\end{equation*}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
only true because \(D_i R_i A = D_i A_i R_i\) due to the fact that \(D_i\) vanishes at the interface \sphinxstylestrong{!!}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxtitleref{pr\#A} applies \(A\) to a distributed vector: \({\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j A_j {\mathbf V}_j\)

\sphinxAtStartPar
\(\Rightarrow\) multiply by \(A_i\) + \sphinxtitleref{prfe\#update}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}

\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}

\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}

\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}

\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBA}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A*b}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Summary so far: translating your sequential \sphinxstyleemphasis{FreeFEM} script}
\label{\detokenize{documentation/ffddm/tutorial:summary-so-far-translating-your-sequential-freefem-script}}

\paragraph{Step 1: Decompose the mesh}
\label{\detokenize{documentation/ffddm/tutorial:id1}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationoverlappingmeshdecomposition}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{mpiCommWorld}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Step 2: Define your finite element

\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationlocalfiniteelementspaces}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{,} \PYG{n}{def}\PYG{p}{,} \PYG{k+kp}{init}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Step 3: Define your problem

\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{Pb}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{Pb}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(}\PYG{n}{PB}\PYG{p}{,} \PYG{n}{FE}\PYG{p}{,} \PYG{n}{Varf}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Solve the linear system}
\label{\detokenize{documentation/ffddm/tutorial:solve-the-linear-system}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBdirectsolve}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\paragraph{Solve the linear system with the parallel direct solver \sphinxstyleemphasis{MUMPS}}
\label{\detokenize{documentation/ffddm/tutorial:solve-the-linear-system-with-the-parallel-direct-solver-mumps}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationdefineproblemtosolve}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{directsolve}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We have \(A\) and \(b\) in distributed form, we can solve the linear system \(A u = b\) using the parallel direct solver \sphinxstyleemphasis{MUMPS}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve the problem using the direct parallel solver MUMPS}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBdirectsolve}\PYG{p}{(}\PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Step 4: Define the one level DD preconditioner}
\label{\detokenize{documentation/ffddm/tutorial:step-4-define-the-one-level-dd-preconditioner}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationonelevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{VarfPrec} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
builds the one level preconditioner for problem \sphinxstylestrong{pr}.

\sphinxAtStartPar
By default it is the \sphinxstyleemphasis{Restricted Additive Schwarz (RAS)} preconditioner:
\begin{equation*}
\begin{split}M^{-1}_1 = M^{-1}_{\text{RAS}} = \sum_{i=1}^N R_i^T D_i A_i^{-1} R_i \quad \text{with}\; A_i = R_i A R_i^T\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{\_Setup step\_}: compute the \(LU\) (or \(L D L^T\)) factorization of local matrices \(A_i\)

\sphinxAtStartPar
\sphinxtitleref{pr\#PREC1} applies \(M^{-1}_1\) to a distributed vector: \({\mathbf U}_i \leftarrow R_i \sum_{j=1}^N R_j^T D_j A_j^{-1} {\mathbf V}_i\)

\sphinxAtStartPar
\(\Rightarrow\) apply \(A_i^{-1}\) (forward/backward substitutions) + \sphinxtitleref{prfe\#update}


\paragraph{Step 5: Solve the linear system with preconditioned GMRES}
\label{\detokenize{documentation/ffddm/tutorial:step-5-solve-the-linear-system-with-preconditioned-gmres}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationsolvinglinearsystem}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pr}\PYG{o}{\PYGZsh{}}\PYG{n}{fGMRES}\PYG{p}{(}\PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{x0i}\PYG{p}{,} \PYG{n}{K}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{o}{\PYGZam{}} \PYG{n}{bi}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{itmax}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{sp}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
solves the linear system with flexible GMRES with DD preconditioner \(M^{-1}\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{x0i}: initial guess

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{bi}: right\sphinxhyphen{}hand side

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{eps}: relative tolerance

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{itmax}: maximum number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sp}: \sphinxtitleref{“left”} or \sphinxtitleref{“right”} preconditioning

\end{itemize}

\sphinxAtStartPar
\sphinxstyleemphasis{left preconditioning}

\sphinxAtStartPar
solve \(M^{-1} A x = M^{-1} b\)

\sphinxAtStartPar
\sphinxstyleemphasis{right preconditioning}

\sphinxAtStartPar
solve \(A M^{-1} y = b\)

\sphinxAtStartPar
\(\Rightarrow x = M^{-1} y\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ffddmplot}\PYG{p}{(}\PYG{n}{FE}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{PBwritesummary}
\end{sphinxVerbatim}


\subsubsection{Define a two level DD preconditioner}
\label{\detokenize{documentation/ffddm/tutorial:define-a-two-level-dd-preconditioner}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationtwolevelpreconditioners}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxAtStartPar
\sphinxstylestrong{Goal} improve scalability of the one level method

\sphinxAtStartPar
\(\Rightarrow\) enrich the one level preconditioner with a \sphinxstyleemphasis{coarse problem} coupling all subdomains

\sphinxAtStartPar
Main ingredient is a rectangular matrix \(\color{red}{Z}\) of size \(n \times n_c,\,\) where \(n_c \ll n\)
\(\color{red}{Z}\) is the \sphinxstyleemphasis{coarse space} matrix

\sphinxAtStartPar
The \sphinxstyleemphasis{coarse space operator} \(E = \color{red}{Z}^T A \color{red}{Z}\) is a square matrix of size \(n_c \times n_c\)

\sphinxAtStartPar
The simplest way to enrich the one level preconditioner is through the \sphinxstyleemphasis{additive coarse correction} formula:
\begin{equation*}
\begin{split}M^{-1}_2 = M^{-1}_1 + \color{red}{Z} E^{-1} \color{red}{Z}^T\end{split}
\end{equation*}
\sphinxAtStartPar
How to choose \(\color{red}{Z}\) ?


\subsubsection{Build the GenEO coarse space}
\label{\detokenize{documentation/ffddm/tutorial:build-the-geneo-coarse-space}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildinggeneocoarsespace}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxstyleemphasis{GenEO} method builds a robust coarse space for highly heterogeneous or anisotropic \sphinxstylestrong{SPD} problems

\sphinxAtStartPar
\(\Rightarrow\) solve a local generalized eigenvalue problem in each subdomain
\begin{equation*}
\begin{split}D_i A_i D_i\, V_{i,k} = \lambda_{i,k}\, A_i^{\text{Neu}} \,V_{i,k}\end{split}
\end{equation*}
\sphinxAtStartPar
with \(A_i^{\text{Neu}}\) the local Neumann matrices built from \sphinxstylestrong{Varf} (same \sphinxstylestrong{Varf} as {\hyperref[\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3}}}})

\sphinxAtStartPar
The GenEO coarse space is \(\color{red}{Z} = (R_i^T D_i V_{i,k})^{i=1,...,N}_{\lambda_{i,k} \ge \color{blue}{\tau}}\)
The eigenvectors \(V_{i,k}\) selected to enter the coarse space correspond to eigenvalues \(\lambda_{i,k} \ge \color{blue}{\tau}\), where \(\color{blue}{\tau}\) is a threshold parameter
\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Theorem}
the spectrum of the preconditioned operator lies in the interval \([\displaystyle \frac{1}{1+k_1 \color{blue}{\tau}} , k_0 ]\)
where \(k_0 - 1\) is the \# of neighbors and \(k_1\) is the multiplicity of intersections
\(\Rightarrow\) \(k_0\) and \(k_1\) do not depend on \(N\) nor on the PDE
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Build the GenEO coarse space}
\PYG{n}{ffddmgeneosetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Build the coarse space from a coarse mesh}
\label{\detokenize{documentation/ffddm/tutorial:build-the-coarse-space-from-a-coarse-mesh}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationbuildingcoarsespacefromcoarsemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(} \PYG{n}{pr} \PYG{p}{,} \PYG{n}{Thc} \PYG{p}{,} \PYG{n}{VarfEprec} \PYG{p}{,} \PYG{n}{VarfAprec} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For \sphinxstylestrong{non SPD} problems, an alternative is to build the coarse space by discretizing the PDE on a coarser mesh \sphinxstylestrong{Thc}

\sphinxAtStartPar
\(Z\) will be the \sphinxstyleemphasis{interpolation matrix} from the coarse FE space \({Vh}_c\) to the original FE space \(Vh\)

\sphinxAtStartPar
\(\Rightarrow E=\color{red}{Z}^{T} A \color{red}{Z}\) is the matrix of the problem discretized on the coarse mesh

\sphinxAtStartPar
The variational problem to be discretized on \sphinxstylestrong{Thc} is given by macro \sphinxstylestrong{VarfEprec}

\sphinxAtStartPar
\sphinxstylestrong{VarfEprec} can differ from the original \sphinxstylestrong{Varf} of the problem

\sphinxAtStartPar
\sphinxstyleemphasis{Example}: added absorption for wave propagation problems

\sphinxAtStartPar
Similarly, \sphinxstylestrong{VarfAprec} specifies the global operator involved in multiplicative coarse correction formulas. It defaults to \(A\) if \sphinxstylestrong{VarfAprec} is not defined

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{dimension} \PYG{l+m+mi}{2}\PYG{c+c1}{// EOM            // 2D or 3D}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffddm.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{ThGlobal} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// global mesh}
\PYG{c+c1}{// Step 1: Decompose the mesh}
\PYG{n}{ffddmbuildDmesh}\PYG{p}{(} \PYG{n}{M} \PYG{p}{,} \PYG{n}{ThGlobal} \PYG{p}{,} \PYG{k+kr}{mpiCommWorld} \PYG{p}{)}
\PYG{c+c1}{// Step 2: Define your finite element}
\PYG{k+kt}{macro} \PYG{n}{def}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}  \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{k+kp}{init}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{n}{u} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmbuildDfespace}\PYG{p}{(} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{M} \PYG{p}{,} \PYG{k+kt}{real} \PYG{p}{,} \PYG{n}{def} \PYG{p}{,} \PYG{k+kp}{init} \PYG{p}{,} \PYG{n+nc}{P2} \PYG{p}{)}
\PYG{c+c1}{// Step 3: Define your problem}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}
\PYG{k+kt}{macro} \PYG{n}{Varf}\PYG{p}{(}\PYG{n}{varfName}\PYG{p}{,} \PYG{n}{meshName}\PYG{p}{,} \PYG{n}{VhName}\PYG{p}{)}
    \PYG{k+kt}{varf} \PYG{n}{varfName}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
                       \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{meshName}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{n}{FEVhi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{;}
\PYG{n}{ffddmbuildrhs}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]} \PYG{p}{)}

\PYG{c+c1}{// Step 4: Define the one level DD preconditioner}
\PYG{n}{ffddmsetupPrecond}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}

\PYG{c+c1}{// Build the coarse space from a coarse mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thc} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ffddmcoarsemeshsetup}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{Thc} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{,} \PYG{n}{null} \PYG{p}{)}

\PYG{c+c1}{// Step 5: Solve the linear system with GMRES}
\PYG{n}{FEVhi} \PYG{n}{x0i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{ui}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PBfGMRES}\PYG{p}{(}\PYG{n}{x0i}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{bi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{right}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Use \sphinxstylestrong{HPDDM} within \sphinxstylestrong{ffddm}}
\label{\detokenize{documentation/ffddm/tutorial:use-hpddm-within-ffddm}}
\sphinxAtStartPar
See {\hyperref[\detokenize{documentation/ffddm/documentation:ffddmdocumentationhpddmffddm}]{\sphinxcrossref{\DUrole{std,std-ref}{documentation}}}}

\sphinxAtStartPar
\sphinxstylestrong{ffddm} allows you to use \sphinxstylestrong{HPDDM} to solve your problem, effectively replacing the \sphinxstylestrong{ffddm} implementation of all parallel linear algebra computations

\sphinxAtStartPar
\(\Rightarrow\) define your problem with \sphinxstylestrong{ffddm}, solve it with \sphinxstylestrong{HPDDM}

\sphinxAtStartPar
\(\Rightarrow\) \sphinxstylestrong{ffddm} acts as a finite element interface for \sphinxstylestrong{HPDDM}

\sphinxAtStartPar
You can use \sphinxstylestrong{HPDDM} features unavailable in \sphinxstylestrong{ffddm} such as advanced Krylov subspace methods implementing block and recycling techniques

\sphinxAtStartPar
To switch to \sphinxstylestrong{HPDDM}, simply define the macro \sphinxtitleref{pr\#withhpddm} before using \sphinxtitleref{ffddmsetupOperator} ({\hyperref[\detokenize{documentation/ffddm/tutorial:ffddmtutorialdefineyourproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{Step 3}}}}). You can then pass \sphinxstylestrong{HPDDM} options
with command\sphinxhyphen{}line arguments or directly to the underlying \sphinxstylestrong{HPDDM} operator. Options need to be prefixed by the operator prefix:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n+nf}{PBwithhpddm}\PYG{p}{(}\PYG{p}{)}\PYG{l+m+mi}{1} \PYG{c+c1}{// EOM}
\PYG{n}{ffddmsetupOperator}\PYG{p}{(} \PYG{n}{PB} \PYG{p}{,} \PYG{n}{FE} \PYG{p}{,} \PYG{n}{Varf} \PYG{p}{)}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{PBhpddmOP}\PYG{p}{,}\PYG{k+kp}{sparams}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}hpddm\PYGZus{}PB\PYGZus{}krylov\PYGZus{}method gcrodr \PYGZhy{}hpddm\PYGZus{}PB\PYGZus{}recycle 10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or, define \sphinxtitleref{pr\#withhpddmkrylov} to use \sphinxstylestrong{HPDDM} only for the Krylov method

\sphinxAtStartPar
Example \sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-HPDDM-BGMRES.edp}{here}: Helmholtz problem with multiple rhs solved with Block GMRES


\subsubsection{Some results: Heterogeneous 3D elasticity with GenEO}
\label{\detokenize{documentation/ffddm/tutorial:some-results-heterogeneous-3d-elasticity-with-geneo}}
\sphinxAtStartPar
Heterogeneous 3D linear elasticity equation discretized with P2 FE solved on 4096 MPI processes \(n\approx\) 262 million

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{comparisonAMG}.png}


\subsubsection{Some results: 2\sphinxhyphen{}level DD for Maxwell equations, scattering from the COBRA cavity}
\label{\detokenize{documentation/ffddm/tutorial:some-results-2-level-dd-for-maxwell-equations-scattering-from-the-cobra-cavity}}
\sphinxAtStartPar
f = 10 GHz


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxAtStartPar
\sphinxincludegraphics[width=0.750\linewidth]{{10GHz_borders_new_v2}.png}
&
\sphinxAtStartPar
\sphinxincludegraphics[width=1.000\linewidth]{{10GHz_new}.png}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
f = 16 GHz

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.500\linewidth]{{16GHz_new}.png}\hspace*{\fill}}


\subsubsection{Some results: 2\sphinxhyphen{}level DD for Maxwell equations, scattering from the COBRA cavity}
\label{\detokenize{documentation/ffddm/tutorial:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
order 2 Nedelec edge FE

\item {} 
\sphinxAtStartPar
fine mesh: 10 points per wavelength

\item {} 
\sphinxAtStartPar
coarse mesh: 3.33 points per wavelength

\item {} 
\sphinxAtStartPar
two level ORAS preconditioner with added absorption

\item {} 
\sphinxAtStartPar
f = 10 GHz: \(n\approx\) 107 million, \(n_c \approx\) 4 million
\begin{quote}

\sphinxAtStartPar
f = 16 GHz: \(n\approx\) 198 million, \(n_c \approx\) 7.4 million
\end{quote}

\end{itemize}

\sphinxAtStartPar
\(\rightarrow\) coarse problem too large for a direct solver
\(\Rightarrow\) inexact coarse solve: GMRES + one level ORAS preconditioner

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=0.750\linewidth]{{table}.png}\hspace*{\fill}}

\sphinxAtStartPar
speedup of 1.81 from 1536 to 3072 cores at 10GHz

\sphinxAtStartPar
1.51 from 3072 to 6144 cores at 16GHz

\sphinxAtStartPar
You can find the script \sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell\_Cobracavity.edp}{here}


\subsection{Examples}
\label{\detokenize{documentation/ffddm/examples:examples}}\label{\detokenize{documentation/ffddm/examples:ffddmexamples}}\label{\detokenize{documentation/ffddm/examples::doc}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
File name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(M^{-1}_1\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\(M^{-1}_2\)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
inexact CS
&\sphinxstyletheadfamily 
\sphinxAtStartPar
comments
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-minimal-direct.edp}{diffusion\sphinxhyphen{}3d\sphinxhyphen{}minimal\sphinxhyphen{}direct.edp}
&&&&
\sphinxAtStartPar
direct solver MUMPS
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-minimal-ddm.edp}{diffusion\sphinxhyphen{}3d\sphinxhyphen{}minimal\sphinxhyphen{}ddm.edp}
&
\sphinxAtStartPar
RAS
&
\sphinxAtStartPar
GenEO
&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-3d-simple.edp}{diffusion\sphinxhyphen{}3d\sphinxhyphen{}simple.edp}
&
\sphinxAtStartPar
RAS
&
\sphinxAtStartPar
GenEO
&&
\sphinxAtStartPar
comparison with direct solver
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/diffusion-2d-thirdlevelgeneo.edp}{diffusion\sphinxhyphen{}2d\sphinxhyphen{}thirdlevelgeneo.edp}
&
\sphinxAtStartPar
RAS
&
\sphinxAtStartPar
GenEO
&
\sphinxAtStartPar
RAS + GenEO
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity-3d-simple.edp}{elasticity\sphinxhyphen{}3d\sphinxhyphen{}simple.edp}
&
\sphinxAtStartPar
RAS
&
\sphinxAtStartPar
GenEO
&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity-3d-thirdlevelgeneo.edp}{elasticity\sphinxhyphen{}3d\sphinxhyphen{}thirdlevelgeneo.edp}
&
\sphinxAtStartPar
RAS
&
\sphinxAtStartPar
GenEO
&
\sphinxAtStartPar
RAS + GenEO
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/elasticity\_saddlepoint.edp}{elasticity\_saddlepoint.edp}
&&
\sphinxAtStartPar
GenEO\sphinxhyphen{}SP
&&
\sphinxAtStartPar
saddle point GenEO solver from \sphinxhref{https://arxiv.org/abs/1911.01858}{here}
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-simple.edp}{Helmholtz\sphinxhyphen{}2d\sphinxhyphen{}simple.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh / DtN
&&
\sphinxAtStartPar
for the DtN coarse space see \sphinxhref{https://doi.org/10.1016/j.cam.2014.03.031}{this paper}
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-marmousi.edp}{Helmholtz\sphinxhyphen{}2d\sphinxhyphen{}marmousi.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-3d-simple.edp}{Helmholtz\sphinxhyphen{}3d\sphinxhyphen{}simple.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-3d-overthrust.edp}{Helmholtz\sphinxhyphen{}3d\sphinxhyphen{}overthrust.edp}
&
\sphinxAtStartPar
ORAS
&&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Helmholtz-2d-HPDDM-BGMRES.edp}{Helmholtz\sphinxhyphen{}2d\sphinxhyphen{}HPDDM\sphinxhyphen{}BGMRES.edp}
&
\sphinxAtStartPar
ORAS
&&&
\sphinxAtStartPar
multi\sphinxhyphen{}rhs Block GMRES with HPDDM
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Navier-2d-marmousi2.edp}{Navier\sphinxhyphen{}2d\sphinxhyphen{}marmousi2.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell-3d-simple.edp}{Maxwell\sphinxhyphen{}3d\sphinxhyphen{}simple.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Maxwell\_Cobracavity.edp}{Maxwell\_Cobracavity.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&
\sphinxAtStartPar
ORAS
&\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/natural\_convection.edp}{natural\_convection.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&&
\sphinxAtStartPar
nonlinear
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/natural\_convection\_3D\_obstacle.edp}{natural\_convection\_3D\_obstacle.edp}
&
\sphinxAtStartPar
ORAS
&
\sphinxAtStartPar
Coarse Mesh
&&
\sphinxAtStartPar
nonlinear
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/Richards-2d.edp}{Richards\sphinxhyphen{}2d.edp}
&
\sphinxAtStartPar
RAS
&&&
\sphinxAtStartPar
nonlinear time dependent mesh adaptation
\\
\hline
\sphinxAtStartPar
\sphinxhref{https://github.com/FreeFem/FreeFem-sources/blob/develop/examples/ffddm/heat-torus-3d-surf.edp}{heat\sphinxhyphen{}torus\sphinxhyphen{}3d\sphinxhyphen{}surf.edp}
&
\sphinxAtStartPar
RAS
&
\sphinxAtStartPar
GenEO
&&
\sphinxAtStartPar
3d surface time dependent
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\chapter{Language references}
\label{\detokenize{references/index:language-references}}\label{\detokenize{references/index::doc}}
\sphinxAtStartPar
In essence \sphinxstylestrong{FreeFEM} is a compiler: its language is typed, polymorphic, with exception and reentrant.
Every variable must be declared of a certain type, in a declarative statement; each statement are separated from the next by a semicolon \sphinxcode{\sphinxupquote{;}}.

\sphinxAtStartPar
The language allows the manipulation of basic types integers (\sphinxcode{\sphinxupquote{int}}), reals (\sphinxcode{\sphinxupquote{real}}), strings (\sphinxcode{\sphinxupquote{string}}), arrays (example: \sphinxcode{\sphinxupquote{real{[}int{]}}}), bi\sphinxhyphen{}dimensional (2D) finite element meshes (\sphinxcode{\sphinxupquote{mesh}}), 2D finite element spaces (\sphinxcode{\sphinxupquote{fespace}}), analytical functions (\sphinxcode{\sphinxupquote{func}}), arrays of finite element functions (\sphinxcode{\sphinxupquote{func{[}basic\_type{]}}}), linear and bilinear operators, sparse matrices, vectors , etc.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//i, n are integer}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//two array of size n}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//which can be used in statements such as}
    \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The life of a variable is the current block \sphinxcode{\sphinxupquote{\{...\}}}, except the \sphinxcode{\sphinxupquote{fespace}} variable, and the variables local to a block are destroyed at the end of the block as follows.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//unit square mesh}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//P1 Lagrange finite element space}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{k+kr}{x} \PYG{o}{+} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{log}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{// new block}
    \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//not the same r}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//error because Vh is a global name}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{// end of block}
\PYG{c+c1}{//here r back to 0.01}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
The type declarations are mandatory in \sphinxstylestrong{FreeFEM}; in the end this feature is an asset because it is easy to make bugs in a language with many implicit types.

\sphinxAtStartPar
The variable name is just an alphanumeric string, the underscore character \sphinxcode{\sphinxupquote{\_}} is not allowed, because it will be used as an operator in the future.


\section{Types}
\label{\detokenize{references/types:types}}\label{\detokenize{references/types:referencetypes}}\label{\detokenize{references/types::doc}}

\subsection{Standard types}
\label{\detokenize{references/types:standard-types}}

\subsubsection{int}
\label{\detokenize{references/types:int}}
\sphinxAtStartPar
Integer value (equivalent to \sphinxcode{\sphinxupquote{long}} in \sphinxcode{\sphinxupquote{C++}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{bool}
\label{\detokenize{references/types:bool}}
\sphinxAtStartPar
Boolean value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
The result of a comparison is a boolean

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bool b = (1 \textless{} 2);}}
\end{sphinxadmonition}


\subsubsection{real}
\label{\detokenize{references/types:real}}
\sphinxAtStartPar
Real value (equivalent to \sphinxcode{\sphinxupquote{double}} in \sphinxcode{\sphinxupquote{C++}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{complex}
\label{\detokenize{references/types:complex}}
\sphinxAtStartPar
Complex value (equivalent to two \sphinxcode{\sphinxupquote{double}} or \sphinxcode{\sphinxupquote{complex\textless{}double\textgreater{}}} in \sphinxcode{\sphinxupquote{C++}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The imaginary number \(i\) is defined as \sphinxcode{\sphinxupquote{1i}}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a + b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a \PYGZhy{} b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a*b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{o}{*}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a/b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{o}{/}\PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
a + \PYG{n+nv}{b} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2},4\PYG{o}{)}
a \PYGZhy{} \PYG{n+nv}{b} \PYG{o}{=} \PYG{o}{(}\PYGZhy{}2,\PYGZhy{}2\PYG{o}{)}
a*b \PYG{o}{=} \PYG{o}{(}\PYGZhy{}3,2\PYG{o}{)}
a/b \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{0}.230769,0.153846\PYG{o}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplecomplex}]{\sphinxcrossref{\DUrole{std,std-ref}{Complex example}}}} for a detailed example.
\end{sphinxadmonition}


\subsubsection{string}
\label{\detokenize{references/types:string}}
\sphinxAtStartPar
String value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{this is a string}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{string}} value is enclosed within double quotes.
\end{sphinxadmonition}

\sphinxAtStartPar
Other types can be concatenate to a string, like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{s} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{the int i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{i} \PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, the real r = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{r} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, the complex z = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To append a string in a string at position 4:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{s}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+++}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
To copy a substring in an other string:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{s2} \PYG{o}{=} \PYG{n}{s1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplestring}]{\sphinxcrossref{\DUrole{std,std-ref}{String Example}}}} for a complete example.


\subsection{Mesh design}
\label{\detokenize{references/types:mesh-design}}

\subsubsection{border}
\label{\detokenize{references/types:border}}
\sphinxAtStartPar
Border type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Define the 2D geometrical border in parametric coordinates.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Label

\sphinxAtStartPar
A label can be defined with the border:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Inner variable

\sphinxAtStartPar
An inner variable can be defined inside a border:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{n}{tt}\PYG{o}{=}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{tt}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{tt}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
From vector

\sphinxAtStartPar
A border can be defined from two vectors using \sphinxcode{\sphinxupquote{P.x}} and \sphinxcode{\sphinxupquote{P.y}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vectorX}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{vectorX}\PYG{p}{[}\PYG{k+kp}{t}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{vectorY}\PYG{p}{[}\PYG{k+kp}{t}\PYG{p}{]}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{mesh}
\label{\detokenize{references/types:mesh}}
\sphinxAtStartPar
2D Mesh type (see {\hyperref[\detokenize{documentation/mesh-generation:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{mesh3}
\label{\detokenize{references/types:mesh3}}
\sphinxAtStartPar
3D mesh type (see {\hyperref[\detokenize{documentation/mesh-generation:meshgeneration}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Finite element space design}
\label{\detokenize{references/types:finite-element-space-design}}

\subsubsection{fespace}
\label{\detokenize{references/types:fespace}}
\sphinxAtStartPar
Finite element space type (see {\hyperref[\detokenize{documentation/finite-element:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
A finite element space is based on a mesh (\sphinxcode{\sphinxupquote{Th}}) with an element definition, scalar (\sphinxcode{\sphinxupquote{P1}}) or vector (\sphinxcode{\sphinxupquote{{[}P2, P2, P1{]}}}).

\sphinxAtStartPar
\sphinxstylestrong{Available finite element space:}

\sphinxAtStartPar
Generic:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P0 / P03d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P0Edge}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1 / P13d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1dc}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1b / P1b3d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1bl / P1bl3d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1nc}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2 / P23d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2b}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2dc}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2h}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RT0 / RT03d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RT0Ortho}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Edge03d}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_P3}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P3}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_P3dc}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P3dc}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_P4}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P4}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_P4dc}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P4dc}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_PkEdge}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P1Edge}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2Edge}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P3Edge}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P4Edge}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P5Edge}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Morlay}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2Morley}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{HCT}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{HCT}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{BernardiRaugel}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{P2BR}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_Mixte}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RT1}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RT1Ortho}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RT2}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{RT2Ortho}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BDM1}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{BDM1Ortho}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_Mixte3d}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Edge13d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Edge23d}}

\end{itemize}

\sphinxAtStartPar
Using \sphinxstyleemphasis{Element\_QF}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FEQF}}

\end{itemize}

\sphinxAtStartPar
A finite element function is defined as follow:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh} \PYG{n}{u}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Macro design}
\label{\detokenize{references/types:macro-design}}\label{\detokenize{references/types:typemacrodesign}}

\subsubsection{macro}
\label{\detokenize{references/types:macro}}
\sphinxAtStartPar
Macro type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{vU}\PYG{p}{(}\PYG{p}{)} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\end{sphinxVerbatim}

\sphinxAtStartPar
Macro ends with \sphinxcode{\sphinxupquote{//}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Macro concatenation

\sphinxAtStartPar
You can use the C concatenation operator \sphinxcode{\sphinxupquote{\#\#}} inside a macro using \sphinxcode{\sphinxupquote{\#}}.

\sphinxAtStartPar
If \sphinxtitleref{Ux} and \sphinxtitleref{Uy} are defined as finite element function, you can define:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// End of macro}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplemacro}]{\sphinxcrossref{\DUrole{std,std-ref}{Macro example}}}}


\subsubsection{NewMacro / EndMacro}
\label{\detokenize{references/types:newmacro-endmacro}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In developement \sphinxhyphen{} Not tested
\end{sphinxadmonition}

\sphinxAtStartPar
Set and end a macro

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{NewMacro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{k+kt}{EndMacro}
\end{sphinxVerbatim}


\subsubsection{IFMACRO}
\label{\detokenize{references/types:ifmacro}}
\sphinxAtStartPar
Check if a macro exists and check its value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{)} \PYG{c+c1}{//check if macro AA exists}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{ENDIFMACRO}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{n}{tt}\PYG{p}{)} \PYG{c+c1}{//check if amcro exists and is equall to tt}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{c+cp}{ENDIFMACRO}
\end{sphinxVerbatim}


\subsubsection{ENDIFMACRO}
\label{\detokenize{references/types:endifmacro}}

\subsection{Functions design}
\label{\detokenize{references/types:functions-design}}

\subsubsection{func}
\label{\detokenize{references/types:func}}
\sphinxAtStartPar
Function type.

\sphinxAtStartPar
Function without parameters (\(x\), \(y\) and \(z\) are implicitly considered):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Function’s type is defined by the expression’s type.
\end{sphinxadmonition}

\sphinxAtStartPar
Function with parameters:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{var}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{var}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Elementary functions}
\label{\detokenize{references/types:elementary-functions}}\label{\detokenize{references/types:typeelementaryfunctions}}
\sphinxAtStartPar
Class of basic functions (polynomials, exponential, logarithmic, trigonometric, circular) and the functions obtained from those by the four arithmetic operations
\begin{equation*}
\begin{split}f(x) + g(x),\, f(x) - g(x),\, f(x)g(x),\, f(x)/g(x)\end{split}
\end{equation*}
\sphinxAtStartPar
and by composition \(f(g(x))\), each applied a finite number of times.

\sphinxAtStartPar
In \sphinxstylestrong{FreeFEM}, all elementary functions can thus be created.
The derivative of an elementary function is also an elementary function; however, the indefinite integral of an elementary function cannot always be expressed in terms of elementary functions.

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:exampleelementaryfunction}]{\sphinxcrossref{\DUrole{std,std-ref}{Elementary function example}}}} for a complete example.


\subsubsection{Random functions}
\label{\detokenize{references/types:random-functions}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} includes the \sphinxhref{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}{Mersenne Twister} random number generator.
It is a very fast and accurate random number generator of period \(2^{219937}-1\).

\sphinxAtStartPar
See {\hyperref[\detokenize{references/functions:referencerandint32}]{\sphinxcrossref{\DUrole{std,std-ref}{randint32()}}}}, {\hyperref[\detokenize{references/functions:referencerandint31}]{\sphinxcrossref{\DUrole{std,std-ref}{randint31()}}}}, {\hyperref[\detokenize{references/functions:referencerandreal1}]{\sphinxcrossref{\DUrole{std,std-ref}{randreal1()}}}}, {\hyperref[\detokenize{references/functions:referencerandreal2}]{\sphinxcrossref{\DUrole{std,std-ref}{randreal2()}}}}, {\hyperref[\detokenize{references/functions:referencerandreal3}]{\sphinxcrossref{\DUrole{std,std-ref}{randreal3()}}}}, {\hyperref[\detokenize{references/functions:referencerandres53}]{\sphinxcrossref{\DUrole{std,std-ref}{randres53()}}}}, {\hyperref[\detokenize{references/functions:referencerandinit}]{\sphinxcrossref{\DUrole{std,std-ref}{randinit(seed)}}}}.

\sphinxAtStartPar
In addition, the \sphinxcode{\sphinxupquote{ffrandom}} plugin interface \sphinxcode{\sphinxupquote{random}}, \sphinxcode{\sphinxupquote{srandom}} and \sphinxcode{\sphinxupquote{srandomdev}} functions of the Unix \sphinxcode{\sphinxupquote{libc}} library.
The range is \(0 -- 2^{31}-1\).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{srandomdev}} is not defined, a seed based on the current time is used.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{gsl}} plugin equally allows usage of all random functions of the \sphinxcode{\sphinxupquote{gsllib}}, see {\hyperref[\detokenize{references/external-libraries:referenceffgslawk}]{\sphinxcrossref{\DUrole{std,std-ref}{gsl external library}}}}.


\subsubsection{FE\sphinxhyphen{}functions}
\label{\detokenize{references/types:fe-functions}}
\sphinxAtStartPar
Finite element functions are also constructed like elementary functions by an arithmetic formula involving elementary functions.

\sphinxAtStartPar
The difference is that they are evaluated at declaration time and \sphinxstylestrong{FreeFEM} stores the array of its values at the places associated with he degree of freedom of the finite element type.
By opposition, elementary functions are evaluated only when needed.
Hence FE\sphinxhyphen{}functions are not defined only by their formula but also by the mesh and the finite element which enter in their definitions.

\sphinxAtStartPar
If the value of a FE\sphinxhyphen{}function is requested at a point which is not a degree of freedom, an interpolation is used, leading to an interpolation error, while by contrast, an elementary function can be evaluated at any point exactly.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}2, 2[\PYGZca{}2}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh}\PYG{o}{=}\PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//fh is the projection of f to Vh (real value)}
\PYG{k+kt}{func} \PYG{n}{zf} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{zh} \PYG{o}{=} \PYG{n}{zf}\PYG{p}{;} \PYG{c+c1}{//zh is the projection of zf to complex value Vh space}
\end{sphinxVerbatim}

\sphinxAtStartPar
The construction of \sphinxcode{\sphinxupquote{fh = f}} is explained in {\hyperref[\detokenize{documentation/finite-element:finiteelement}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{plot}} command only works for real or complex FE\sphinxhyphen{}functions, not for elementary functions.
\end{sphinxadmonition}


\subsection{Problem design}
\label{\detokenize{references/types:problem-design}}\label{\detokenize{references/types:typeproblemdesign}}

\subsubsection{problem}
\label{\detokenize{references/types:problem}}\label{\detokenize{references/types:typeproblem}}
\sphinxAtStartPar
Problem type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} needs the variational form in the problem definition.

\sphinxAtStartPar
In order to solve the problem, just call:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Laplacian}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Solver

\sphinxAtStartPar
A solver can be specified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The default solver is \sphinxcode{\sphinxupquote{sparsesolver}} or \sphinxcode{\sphinxupquote{LU}} if any direct sparse solver is available.

\sphinxAtStartPar
Solvers are listed in the {\hyperref[\detokenize{references/global-variables:globalvariables}]{\sphinxcrossref{\DUrole{std,std-ref}{Global variables}}}} section.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Stop test

\sphinxAtStartPar
A criterion \(\varepsilon\) can be defined for iterative methods, like CG for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
If \(\varepsilon>0\), the stop test is:
\begin{equation*}
\begin{split}||Ax-b|| < \varepsilon\end{split}
\end{equation*}
\sphinxAtStartPar
Else, the stop test is:
\begin{equation*}
\begin{split}||Ax-b|| < \frac{|\varepsilon|}{||Ax_0-b||}\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Reconstruction

\sphinxAtStartPar
The keyword \sphinxcode{\sphinxupquote{init}} controls the reconstruction of the internal problem matrix.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{init}} is set to \sphinxcode{\sphinxupquote{false}} or \sphinxcode{\sphinxupquote{0}}, the matrix is reconstructed et each problem calls (or after a mesh modification), else the previously constructed matrix is used.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Preconditioning

\sphinxAtStartPar
A preconditioner can be specified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{k+kr}{P}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
The preconditioning function must have a prototype like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{P}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{xx}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
“\sphinxstyleemphasis{Très grande valeur}”

\sphinxAtStartPar
The “\sphinxstyleemphasis{Très grand valeur}” \sphinxcode{\sphinxupquote{tgv}} (or \sphinxstyleemphasis{Terrible giant value}) used to implement the Dirichlet conditions can be modified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mf}{1e30}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Refere to {\hyperref[\detokenize{documentation/finite-element:problemdefinition}]{\sphinxcrossref{\DUrole{std,std-ref}{Problem definition}}}} for a description of the Dirichlet condition implementation.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Pivot tolerance

\sphinxAtStartPar
The tolerance of the pivot in \sphinxcode{\sphinxupquote{UMFPACK}}, \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Crout}}, \sphinxcode{\sphinxupquote{Cholesky}} factorization can be modified in the problem definition:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{tolpivot}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}20}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UMFPACK}}

\sphinxAtStartPar
Two specific parameters for the \sphinxcode{\sphinxupquote{UMFPACK}} can be modifed:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tolerance of the pivot sym

\item {} 
\sphinxAtStartPar
strategy

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{tolpivotsym}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}1}\PYG{p}{,} \PYG{k+kp}{strategy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Refer to the \sphinxhref{http://faculty.cse.tamu.edu/davis/research.html}{UMFPACK website} for more informations.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dimKrylov}}

\sphinxAtStartPar
Dimension of the Krylov space
\end{sphinxadmonition}

\sphinxAtStartPar
Usage of \sphinxcode{\sphinxupquote{problem}} is detailled in the {\hyperref[\detokenize{tutorials/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorials}}}}.


\subsubsection{solve}
\label{\detokenize{references/types:solve}}\label{\detokenize{references/types:typesolve}}
\sphinxAtStartPar
Solve type.

\sphinxAtStartPar
Identical to {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}} but automatically solved.

\sphinxAtStartPar
Usage of \sphinxcode{\sphinxupquote{solve}} is detailled in the {\hyperref[\detokenize{tutorials/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorials}}}}.


\subsubsection{varf}
\label{\detokenize{references/types:varf}}\label{\detokenize{references/types:typevarf}}
\sphinxAtStartPar
Variational form type.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n}{vLaplacian} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Directly define a variational form.

\sphinxAtStartPar
This is the other way to define a problem in order to directly manage matrix and right hang side.

\sphinxAtStartPar
Usage of \sphinxcode{\sphinxupquote{varf}} is detailed in the {\hyperref[\detokenize{tutorials/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{tutorial}}}}.


\subsection{Array}
\label{\detokenize{references/types:array}}
\sphinxAtStartPar
An array stores multiple objects, and there are 2 kinds of arrays:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the first is similar to vector, i.e. array with integer indices

\item {} 
\sphinxAtStartPar
the second is array with string indices

\end{itemize}

\sphinxAtStartPar
In the first case, the size of the array must be known at execution time, and implementation is done with the \sphinxcode{\sphinxupquote{KN\textless{}\textgreater{}}} class and all the vector operator of \sphinxcode{\sphinxupquote{KN\textless{}\textgreater{}}} are implemented.

\sphinxAtStartPar
Arrays can be set like in Matlab or Scilab with the operator \sphinxcode{\sphinxupquote{::}}, the array generator of \sphinxcode{\sphinxupquote{a:c}} is equivalent to \sphinxcode{\sphinxupquote{a:1:c}}, and the array set by \sphinxcode{\sphinxupquote{a:b:c}} is set to size \(\lfloor |(b-a)/c|+1 \rfloor\) and the value \(i\) is set by \(a + i (b-a)/c\).

\sphinxAtStartPar
There are \sphinxcode{\sphinxupquote{int,real, complex}} array with, in the third case, two operators (\sphinxcode{\sphinxupquote{.im}}, \sphinxcode{\sphinxupquote{.re}}) to generate the real and imaginary real array from the complex array (without copy).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Quantiles are points taken at regular intervals from the cumulative distribution function of a random variable.
Here the array values are random.

\sphinxAtStartPar
This statistical function \sphinxcode{\sphinxupquote{a.quantile(q)}} computes \(v\) from an array \(a\) of size \(n\) for a given number \(q\in ]0,1[\) such that:
\begin{equation*}
\begin{split}\#\{ i / a[i] < v \} \sim q*n\end{split}
\end{equation*}
\sphinxAtStartPar
it is equivalent to \(v = a[q*n]\) when the array \(a\) is sorted.
\end{sphinxadmonition}

\sphinxAtStartPar
For example, to declare, fill and display an array of \sphinxcode{\sphinxupquote{real}} of size \sphinxcode{\sphinxupquote{n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Ai}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{Ai}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{5}
      \PYG{l+m}{0}   \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}
\end{sphinxVerbatim}

\sphinxAtStartPar
See the {\hyperref[\detokenize{examples/developers:examplearray}]{\sphinxcrossref{\DUrole{std,std-ref}{Array example}}}} for a complete example.


\subsubsection{Array index}
\label{\detokenize{references/types:array-index}}
\sphinxAtStartPar
Array index can be int or string:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Ai} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{As} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Array size}
\label{\detokenize{references/types:array-size}}
\sphinxAtStartPar
The size of an array is obtained using the keyword \sphinxcode{\sphinxupquote{n}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{ArraySize} \PYG{o}{=} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Array sort}
\label{\detokenize{references/types:array-sort}}
\sphinxAtStartPar
To sort an array:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Ai}\PYG{p}{.}\PYG{n+nf}{sort}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Double array}
\label{\detokenize{references/types:double-array}}
\sphinxAtStartPar
A double array (matrix) can be defined using two indexes:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aii} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The two sizes are obtained using the keywords \sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{m}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{ArraySize1} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ArraySize2} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The minimum and maximum values of an array (simple or double) can be obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{ArrayMin} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ArrayMax} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Th minimum and maximum position of an array can be obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{mini} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{minj} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{n}{jmin}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{maxi} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{maxj} \PYG{o}{=} \PYG{n}{Aii}\PYG{p}{.}\PYG{n}{jmax}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
An array can be obtained from a finite element function using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aU} \PYG{o}{=} \PYG{n}{U}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{U}} is a finite element function.
\end{sphinxadmonition}


\subsubsection{Array of FE functions}
\label{\detokenize{references/types:array-of-fe-functions}}
\sphinxAtStartPar
It is also possible to make an array of FE functions, with the same syntax, and we can treat them as vector valued function if we need them.

\sphinxAtStartPar
The syntax for space or vector finite function is

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{c+c1}{//size of the array.}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{wh}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//real scalar case}
\PYG{n}{Wh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{]}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//real vectorial case}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{cwh}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//complex scalar case}
\PYG{n}{Wh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{cuh}\PYG{p}{,} \PYG{n}{cvh}\PYG{p}{]}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//complex vectorial case}
\PYG{p}{[}\PYG{n}{cuh}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cvh}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set interpolation of index 2}

\PYG{c+c1}{// Array of Array}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example

\sphinxAtStartPar
In the following example, Poisson’s equation is solved for 3 different given functions \(f=1,\, \sin(\pi x)\cos(\pi y),\, |x-1||y-1|\), whose solutions are stored in an array of FE function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{f}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
      \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{uu}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of FE function}
\PYG{c+c1}{// Solve problem 1}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 2}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 3}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplefearray}]{\sphinxcrossref{\DUrole{std,std-ref}{FE array example}}}}.
\end{sphinxadmonition}


\subsubsection{Map arrays}
\label{\detokenize{references/types:map-arrays}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{map}\PYG{p}{;} \PYG{c+c1}{//a dynamic array}

\PYG{n}{map}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{;}
\PYG{n}{map}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{3.0}\PYG{p}{;} \PYG{c+c1}{//2 is automatically cast to the string \PYGZdq{}2\PYGZdq{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{map[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{map}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{map[2] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{map}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
It is just a map of the standard template library so no operations on vector are allowed, except the selection of an item.


\subsection{matrix}
\label{\detokenize{references/types:matrix}}\label{\detokenize{references/types:typematrix}}
\sphinxAtStartPar
Defines a sparse matrix.

\sphinxAtStartPar
Matrices can be defined like vectors:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{9}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or using a variational form type (see {\hyperref[\detokenize{documentation/finite-element:variationalformsparsematrixpde}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite Element}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{Laplacian} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or from block of matrices:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{An}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{k+kp}{A1}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{p}{[}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{An}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or using sparse matrix set:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I}} and \sphinxcode{\sphinxupquote{J}} are \sphinxcode{\sphinxupquote{int{[}int{]}}} and \sphinxcode{\sphinxupquote{C}} is \sphinxcode{\sphinxupquote{real{[}int{]}}}. The matrix is defined as:
\begin{equation*}
\begin{split}A = \sum_k{C[k]M_{I[k], J[k]}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(M_{a, b} = \left(\delta_{ia}\delta_{jb}\right)_{ij}\)

\sphinxAtStartPar
\sphinxtitleref{I}, \sphinxtitleref{J} and \sphinxtitleref{C} can be retrieved using \sphinxtitleref{{[}I, J, C{]} = A} (arrays are automatically resized).

\sphinxAtStartPar
The size of the matrix is \sphinxcode{\sphinxupquote{n = I.max;}}, \sphinxcode{\sphinxupquote{m = J.max;}}.
\end{sphinxadmonition}

\sphinxAtStartPar
Matrices are designed using templates, so they can be real or complex:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{Ai} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Solver

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.

\sphinxAtStartPar
The default solver is {\hyperref[\detokenize{references/global-variables:globalvariablesgmres}]{\sphinxcrossref{\DUrole{std,std-ref}{GMRES}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A} \PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Factorize

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{true}}, the factorization is done for \sphinxcode{\sphinxupquote{LU}}, \sphinxcode{\sphinxupquote{Cholesky}} or \sphinxcode{\sphinxupquote{Crout}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A} \PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Stop test

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstyleemphasis{Très grande valeur}

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Preconditioning

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Pivot tolerance

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{UMFPACK}}

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dimKrylov}}

\sphinxAtStartPar
See {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
datafilename

\sphinxAtStartPar
Name of the file containing solver parameters, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lparams}}

\sphinxAtStartPar
Vector of integer parameters for the solver, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dparams}}

\sphinxAtStartPar
Vector of real parameters for the solver, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sparams}}

\sphinxAtStartPar
String parameters for the solver, see {\hyperref[\detokenize{documentation/parallelization:parallelsparsesolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Parallel sparse solvers}}}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
To modify the \sphinxcode{\sphinxupquote{solver}}, the stop test,… after the matrix construction, use the {\hyperref[\detokenize{references/functions:functionset}]{\sphinxcrossref{\DUrole{std,std-ref}{set keyword}}}}.
\end{sphinxadmonition}


\subsubsection{Matrix size}
\label{\detokenize{references/types:matrix-size}}
\sphinxAtStartPar
The size of a matrix is obtain using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{NRows} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{NColumns} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{m}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Matrix resize}
\label{\detokenize{references/types:matrix-resize}}
\sphinxAtStartPar
To resize a matrix, use:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
When resizing, all new terms are set to zero.
\end{sphinxadmonition}


\subsubsection{Matrix diagonal}
\label{\detokenize{references/types:matrix-diagonal}}
\sphinxAtStartPar
The diagonal of the matrix is obtained using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Matrix renumbering}
\label{\detokenize{references/types:matrix-renumbering}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{,} \PYG{n}{J}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
\PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Complex matrix}
\label{\detokenize{references/types:complex-matrix}}
\sphinxAtStartPar
Use \sphinxcode{\sphinxupquote{.im}} and \sphinxcode{\sphinxupquote{.re}} to get the imaginary and real part of a complex matrix, respectively:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{C} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{k+kt}{matrix} \PYG{n}{R} \PYG{o}{=} \PYG{n}{C}\PYG{p}{.}\PYG{k+kr}{re}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n}{C}\PYG{p}{.}\PYG{k+kr}{im}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Dot product / Outer product}
\label{\detokenize{references/types:dot-product-outer-product}}
\sphinxAtStartPar
The dot product of two matrices is realized using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{k+kp}{B}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The outer product of two matrices is realized using:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{C} \PYG{o}{=} \PYG{k+kp}{A} \PYG{o}{*} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplematrixoperations}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix operations example}}}} for a complete example.


\subsubsection{Matrix inversion}
\label{\detokenize{references/types:matrix-inversion}}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplematrixinversion}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix inversion example}}}}.


\section{Global variables}
\label{\detokenize{references/global-variables:global-variables}}\label{\detokenize{references/global-variables:globalvariables}}\label{\detokenize{references/global-variables::doc}}

\subsection{area}
\label{\detokenize{references/global-variables:area}}
\sphinxAtStartPar
Area of the current triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{k+kp}{A} \PYG{o}{=} \PYG{k+kr}{area}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{ARGV}
\label{\detokenize{references/global-variables:argv}}
\sphinxAtStartPar
Array that contains all the command line arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplecommandlinearguments}]{\sphinxcrossref{\DUrole{std,std-ref}{Command line arguments example}}}} for a complete example.


\subsection{BoundaryEdge}
\label{\detokenize{references/global-variables:boundaryedge}}
\sphinxAtStartPar
Return 1 if the current edge is on a boundary, 0 otherwise.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{BoundaryEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{CG}
\label{\detokenize{references/global-variables:cg}}
\sphinxAtStartPar
Conjugate gradient solver.

\sphinxAtStartPar
Usable in {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}} and {\hyperref[\detokenize{references/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} definition

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n}{Laplacian} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or in {\hyperref[\detokenize{references/types:typematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{matrix}}}} construction

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{vLaplacian}\PYG{p}{(}\PYG{n}{Uh}\PYG{p}{,} \PYG{n}{Uh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or in {\hyperref[\detokenize{references/functions:functionset}]{\sphinxcrossref{\DUrole{std,std-ref}{set function}}}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Cholesky}
\label{\detokenize{references/global-variables:cholesky}}
\sphinxAtStartPar
Cholesky solver.


\subsection{Crout}
\label{\detokenize{references/global-variables:crout}}
\sphinxAtStartPar
Crout solver.


\subsection{edgeOrientation}
\label{\detokenize{references/global-variables:edgeorientation}}
\sphinxAtStartPar
Sign of \(i-j\) if the current edge is \([q_i, q_j]\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{edgeOrientation}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{false}
\label{\detokenize{references/global-variables:false}}
\sphinxAtStartPar
False boolean value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{false}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{GMRES}
\label{\detokenize{references/global-variables:gmres}}\label{\detokenize{references/global-variables:globalvariablesgmres}}
\sphinxAtStartPar
GMRES solver (Generalized minimal residual method).


\subsection{hTriangle}
\label{\detokenize{references/global-variables:htriangle}}
\sphinxAtStartPar
Size of the current triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{include}
\label{\detokenize{references/global-variables:include}}
\sphinxAtStartPar
Include an {\hyperref[\detokenize{references/external-libraries:externallibraries}]{\sphinxcrossref{\DUrole{std,std-ref}{external library}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{InternalEdge}
\label{\detokenize{references/global-variables:internaledge}}
\sphinxAtStartPar
Return 0 if the current edge is on a boundary, 1 otherwise.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{InternalEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{label}
\label{\detokenize{references/global-variables:label}}
\sphinxAtStartPar
Label number of a boundary if the current point is on a boundary, 0 otherwise.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{L} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{xB}\PYG{p}{,} \PYG{n}{yB}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{label}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{lenEdge}
\label{\detokenize{references/global-variables:lenedge}}
\sphinxAtStartPar
Length of the current edge.

\sphinxAtStartPar
For an edge \([q_i, g_j]\), return \(|q_i-q_j|\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{load}
\label{\detokenize{references/global-variables:load}}
\sphinxAtStartPar
Load a script.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Element\PYGZus{}P3}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsection{LU}
\label{\detokenize{references/global-variables:lu}}
\sphinxAtStartPar
LU solver.


\subsection{N}
\label{\detokenize{references/global-variables:n}}
\sphinxAtStartPar
Outward unit normal at the current point if it is on a curve defined by a border.
\sphinxcode{\sphinxupquote{N.x, N.y, N.z}} are respectively the \(x\), \(y\) and \(z\) components of the normal.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{func} \PYG{n}{Nx} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Ny} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Nz} \PYG{o}{=} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{nTonEdge}
\label{\detokenize{references/global-variables:ntonedge}}
\sphinxAtStartPar
Number of adjacent triangles of the current edge.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{nTE} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{nTonEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{nuEdge}
\label{\detokenize{references/global-variables:nuedge}}
\sphinxAtStartPar
Index of the current edge in the triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{nE} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{nuEdge}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{nuTriangle}
\label{\detokenize{references/global-variables:nutriangle}}
\sphinxAtStartPar
Index of the current triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{k+kr}{n} \PYG{o}{=} \PYG{k+kr}{nuTriangle}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{P}
\label{\detokenize{references/global-variables:p}}
\sphinxAtStartPar
Current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{cx} \PYG{o}{=} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cy} \PYG{o}{=} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cz} \PYG{o}{=} \PYG{k+kr}{P}\PYG{p}{.}\PYG{k+kr}{z}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{pi}
\label{\detokenize{references/global-variables:pi}}
\sphinxAtStartPar
Pi = 3.14159.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Pi} \PYG{o}{=} \PYG{k+kr}{pi}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a real value.


\subsection{region}
\label{\detokenize{references/global-variables:region}}
\sphinxAtStartPar
Region number of the current point. If the point is outside, then \sphinxcode{\sphinxupquote{region == notaregion}} where \sphinxcode{\sphinxupquote{notaregion}} is a \sphinxstylestrong{FreeFEM} integer constant.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{R} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{(}\PYG{n}{xR}\PYG{p}{,} \PYG{n}{yR}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sparsesolver}
\label{\detokenize{references/global-variables:sparsesolver}}
\sphinxAtStartPar
Sparse matrix solver.


\subsection{true}
\label{\detokenize{references/global-variables:true}}
\sphinxAtStartPar
True boolean value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{true}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{verbosity}
\label{\detokenize{references/global-variables:verbosity}}
\sphinxAtStartPar
Verbosity level.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Verbosity} \PYG{o}{=} \PYG{k+kr}{verbosity}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
0 = nothing, 1 = little information, 10 = a lot of information, …

\sphinxAtStartPar
This is an integer value.


\subsection{version}
\label{\detokenize{references/global-variables:version}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} version.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{version} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{volume}
\label{\detokenize{references/global-variables:volume}}
\sphinxAtStartPar
Volume of the current tetrahedra.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh0}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh0} \PYG{n}{V} \PYG{o}{=} \PYG{k+kr}{volume}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{x}
\label{\detokenize{references/global-variables:x}}
\sphinxAtStartPar
The \(x\) coordinate at the current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{CurrentX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a real value.


\subsection{y}
\label{\detokenize{references/global-variables:y}}
\sphinxAtStartPar
The \(y\) coordinate at the current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{CurrentY} \PYG{o}{=} \PYG{k+kr}{y}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a real value.


\subsection{z}
\label{\detokenize{references/global-variables:z}}
\sphinxAtStartPar
The \(z\) coordinate at the current point.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{CurrentZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a real value.


\section{Quadrature formulae}
\label{\detokenize{references/quadrature-formulae:quadrature-formulae}}\label{\detokenize{references/quadrature-formulae:quadratureformulae}}\label{\detokenize{references/quadrature-formulae::doc}}
\sphinxAtStartPar
The quadrature formula is like the following:
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \sum_{\ell=1}^{L}{\omega_\ell f(\boldxi_\ell)}\end{split}
\end{equation*}

\subsection{int1d}
\label{\detokenize{references/quadrature-formulae:int1d}}\label{\detokenize{references/quadrature-formulae:quadratureformulaeint1d}}
\sphinxAtStartPar
Quadrature formula on an edge.


\subsubsection{Notations}
\label{\detokenize{references/quadrature-formulae:notations}}
\sphinxAtStartPar
\(|D|\) is the measure of the edge \(D\).

\sphinxAtStartPar
For a shake of simplicity, we denote:
\begin{equation*}
\begin{split}f(\boldx) = g(t)\end{split}
\end{equation*}
\sphinxAtStartPar
with \(0\leq t\leq 1\); \(\boldx=(1-t)\boldx_0+t\boldx_1\).


\subsubsection{qf1pE}
\label{\detokenize{references/quadrature-formulae:qf1pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_1\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx |D|g\left(\frac{1}{2}\right)\end{split}
\end{equation*}

\subsubsection{qf2pE}
\label{\detokenize{references/quadrature-formulae:qf2pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf2pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_3\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{2}\left(
      g\left( \frac{1+\sqrt{1/3}}{2} \right)
    + g\left( \frac{1-\sqrt{1/3}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf3pE   \sphinxstyleemphasis{(default)}}
\label{\detokenize{references/quadrature-formulae:qf3pe-default}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf3pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is the default one and be exact on \(\mathbb{P}_5\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{18}\left(
      5g\left( \frac{1+\sqrt{3/5}}{2} \right)
    + 8g\left( \frac{1}{2} \right)
    + 5g\left( \frac{1-\sqrt{3/5}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf4pE}
\label{\detokenize{references/quadrature-formulae:qf4pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf4pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_7\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{72}\left(
      (18-\sqrt{30})g\left( \frac{1-\frac{\sqrt{525+70\sqrt{30}}}{35}}{2} \right)
    + (18-\sqrt{30})g\left( \frac{1+\frac{\sqrt{525+70\sqrt{30}}}{35}}{2} \right)
    + (18+\sqrt{30})g\left( \frac{1-\frac{\sqrt{525-70\sqrt{30}}}{35}}{2} \right)
    + (18+\sqrt{30})g\left( \frac{1+\frac{\sqrt{525-70\sqrt{30}}}{35}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf5pE}
\label{\detokenize{references/quadrature-formulae:qf5pe}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf5pE}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_9\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx |D|\left(
      \frac{(332-13\sqrt{70})}{1800}g\left( \frac{1-\frac{\sqrt{245+14\sqrt{70}}}{21}}{2} \right)
    + \frac{(332-13\sqrt{70})}{1800}g\left( \frac{1+\frac{\sqrt{245+14\sqrt{70}}}{21}}{2} \right)
    + \frac{64}{225}g\left( \frac{1}{2} \right)
    + \frac{(332+13\sqrt{70})}{1800}g\left( \frac{1-\frac{\sqrt{245-14\sqrt{70}}}{21}}{2} \right)
    + \frac{(332+13\sqrt{70})}{1800}g\left( \frac{1+\frac{\sqrt{245-14\sqrt{70}}}{21}}{2} \right)
\right)\end{split}
\end{equation*}

\subsubsection{qf1pElump}
\label{\detokenize{references/quadrature-formulae:qf1pelump}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfe}\PYG{o}{=}\PYG{k+kr}{qf1pElump}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_2\).
\begin{equation*}
\begin{split}\int_{D}{f(\boldx)} \approx \frac{|D|}{2}\left(
      g\left( 0 \right)
    + g\left( 1 \right)
\right)\end{split}
\end{equation*}

\subsection{int2d}
\label{\detokenize{references/quadrature-formulae:int2d}}\label{\detokenize{references/quadrature-formulae:quadratureformulaeint2d}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Complete formulas are no longer detailed
\end{sphinxadmonition}


\subsubsection{qf1pT}
\label{\detokenize{references/quadrature-formulae:qf1pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qf2pT}
\label{\detokenize{references/quadrature-formulae:qf2pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf2pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_2\).


\subsubsection{qf5pT   \sphinxstyleemphasis{(default)}}
\label{\detokenize{references/quadrature-formulae:qf5pt-default}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf5pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is the default and be exact on \(\mathbb{P}_5\).


\subsubsection{qf1pTlump}
\label{\detokenize{references/quadrature-formulae:qf1ptlump}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf1pTlump}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qf2pT4P1}
\label{\detokenize{references/quadrature-formulae:qf2pt4p1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf2pT4P1}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qf7pT}
\label{\detokenize{references/quadrature-formulae:qf7pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf7pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_7\).


\subsubsection{qf9pT}
\label{\detokenize{references/quadrature-formulae:qf9pt}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf9pT}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_9\).


\subsection{int3d}
\label{\detokenize{references/quadrature-formulae:int3d}}\label{\detokenize{references/quadrature-formulae:quadratureformulaeint3d}}

\subsubsection{qfV1}
\label{\detokenize{references/quadrature-formulae:qfv1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfV}\PYG{o}{=}\PYG{k+kr}{qfV1}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_1\).


\subsubsection{qfV2}
\label{\detokenize{references/quadrature-formulae:qfv2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfV}\PYG{o}{=}\PYG{k+kr}{qfV2}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_2\).


\subsubsection{qfV5   \sphinxstyleemphasis{(default)}}
\label{\detokenize{references/quadrature-formulae:qfv5-default}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfV}\PYG{o}{=}\PYG{k+kr}{qfV5}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is the default one and be exact on \(\mathbb{P}_5\).


\subsubsection{qfV1lump}
\label{\detokenize{references/quadrature-formulae:qfv1lump}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qfV}\PYG{o}{=}\PYG{k+kr}{qfV1lump}\PYG{p}{)}\PYG{p}{(} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This quadrature formula is exact on \(\mathbb{P}_1\).


\section{Operators}
\label{\detokenize{references/operators:operators}}\label{\detokenize{references/operators::doc}}

\subsection{Addition operator +}
\label{\detokenize{references/operators:addition-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{string}}, \sphinxcode{\sphinxupquote{mesh}}, \sphinxcode{\sphinxupquote{mesh3}}, array.


\subsection{Increment operator ++}
\label{\detokenize{references/operators:increment-operator}}
\sphinxAtStartPar
Pre\sphinxhyphen{}increment:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Post\sphinxhyphen{}increment:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Substraction operator \sphinxhyphen{}}
\label{\detokenize{references/operators:substraction-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, array.


\subsection{Decrement operator \textendash{}}
\label{\detokenize{references/operators:decrement-operator}}
\sphinxAtStartPar
Pre\sphinxhyphen{}decrement:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Post\sphinxhyphen{}decrement:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Multiplication operator *}
\label{\detokenize{references/operators:multiplication-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{A}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, array, \sphinxcode{\sphinxupquote{matrix}}.


\subsection{Equal operator =}
\label{\detokenize{references/operators:equal-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Comparison operator ==}
\label{\detokenize{references/operators:comparison-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{=}\PYG{o}{=} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Comparison operator !=}
\label{\detokenize{references/operators:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{!}\PYG{o}{=} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Comparison operator \textless{}, \textless{}=}
\label{\detokenize{references/operators:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Comparison operator \textgreater{}, \textgreater{}=}
\label{\detokenize{references/operators:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Compound operator \sphinxtitleref{+=}, \sphinxtitleref{\sphinxhyphen{}=}, \sphinxtitleref{*=}, \sphinxtitleref{/=}}
\label{\detokenize{references/operators:compound-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Term by term multiplication .*}
\label{\detokenize{references/operators:term-by-term-multiplication}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{k+kp}{B} \PYG{p}{.}\PYG{o}{*} \PYG{n}{C}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Division operator /}
\label{\detokenize{references/operators:division-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{/} \PYG{l+m+mf}{2.}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}.


\subsection{Term by term division ./}
\label{\detokenize{references/operators:term-by-term-division}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{k+kp}{B} \PYG{p}{.}\PYG{o}{/} \PYG{n}{C}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Remainder from the division \%}
\label{\detokenize{references/operators:remainder-from-the-division}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}.


\subsection{Power operator \textasciicircum{}}
\label{\detokenize{references/operators:power-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for \sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{matrix}}.


\subsection{Inverse of a matrix \textasciicircum{}\sphinxhyphen{}1}
\label{\detokenize{references/operators:inverse-of-a-matrix-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Res} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This operator can not be used to directly create a matrix, see {\hyperref[\detokenize{examples/developers:examplematrixinversion}]{\sphinxcrossref{\DUrole{std,std-ref}{Matrix inversion}}}}.
\end{sphinxadmonition}


\subsection{Transpose operator ‘}
\label{\detokenize{references/operators:transpose-operator}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Works for array and \sphinxcode{\sphinxupquote{matrix}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{matrix\textless{}complex\textgreater{}}}, the ::freefem\textasciigrave{}’\textasciigrave{} operator return the Hermitian tranpose.
\end{sphinxadmonition}


\subsection{Tensor scalar product :}
\label{\detokenize{references/operators:tensor-scalar-product}}\begin{equation*}
\begin{split}A:B = \sum_{i,j}{A_{ij}B_{ij}}\end{split}
\end{equation*}

\subsection{C++ arithmetical if expression ? :}
\label{\detokenize{references/operators:c-arithmetical-if-expression}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a ? b : c}} is equal to \sphinxcode{\sphinxupquote{b}} if the \sphinxcode{\sphinxupquote{a}} is true, \sphinxcode{\sphinxupquote{c}} otherwise.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example with \sphinxcode{\sphinxupquote{int}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{12}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{( }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{o}{:} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{12} + \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{17}
\PYG{l+m}{12} \PYGZhy{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{7}
\PYG{l+m}{12} * \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{60}
\PYG{l+m}{12} / \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{2}
\PYG{l+m}{12} \PYGZpc{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{2}
\PYG{l+m}{12} \PYGZca{} \PYG{n+nv}{5} \PYG{o}{=} \PYG{l+m}{248832}
\PYG{o}{(} \PYG{l+m}{12} \PYGZlt{} \PYG{l+m}{5} ? \PYG{l+m}{12} : \PYG{l+m}{5}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example with \sphinxcode{\sphinxupquote{real}}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n}{qsrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{k+kr}{pi}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{*} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{/} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZpc{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZca{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{( }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZlt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{o}{:} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m}{1}.41421 + \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{4}.55581
\PYG{l+m}{1}.41421 \PYGZhy{} \PYG{l+m}{3}.14159 \PYG{o}{=} \PYGZhy{}1.72738
\PYG{l+m}{1}.41421 * \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{4}.44288
\PYG{l+m}{1}.41421 / \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{0}.450158
\PYG{l+m}{1}.41421 \PYGZpc{} \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{1}
\PYG{l+m}{1}.41421 \PYGZca{} \PYG{l+m}{3}.14159 \PYG{o}{=} \PYG{l+m}{2}.97069
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Loops}
\label{\detokenize{references/loops:loops}}\label{\detokenize{references/loops::doc}}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:exampleloop}]{\sphinxcrossref{\DUrole{std,std-ref}{Loop example}}}}.


\subsection{for}
\label{\detokenize{references/loops:for}}\label{\detokenize{references/loops:loopfor}}
\sphinxAtStartPar
For loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{if}
\label{\detokenize{references/loops:if}}\label{\detokenize{references/loops:loopif}}
\sphinxAtStartPar
If condition.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{else}
\label{\detokenize{references/loops:else}}
\sphinxAtStartPar
See {\hyperref[\detokenize{references/loops:loopif}]{\sphinxcrossref{\DUrole{std,std-ref}{if}}}}.


\subsection{while}
\label{\detokenize{references/loops:while}}
\sphinxAtStartPar
While loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{continue}
\label{\detokenize{references/loops:continue}}
\sphinxAtStartPar
Continue a loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{N}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{break}
\label{\detokenize{references/loops:break}}
\sphinxAtStartPar
Break a loop.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{while} \PYG{p}{(}\PYG{n}{condition1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{condition}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{try}
\label{\detokenize{references/loops:try}}\label{\detokenize{references/loops:looptry}}
\sphinxAtStartPar
Try a part of code.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplebasicerrorhandling}]{\sphinxcrossref{\DUrole{std,std-ref}{Basic error handling example}}}} and {\hyperref[\detokenize{examples/developers:exampleerrorhandling}]{\sphinxcrossref{\DUrole{std,std-ref}{Error handling example}}}}.


\subsection{catch}
\label{\detokenize{references/loops:catch}}
\sphinxAtStartPar
Catch an error, see {\hyperref[\detokenize{references/loops:looptry}]{\sphinxcrossref{\DUrole{std,std-ref}{try}}}}


\subsection{Implicit loop}
\label{\detokenize{references/loops:implicit-loop}}
\sphinxAtStartPar
Array with one index:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{ai} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{real{[}int{]} a(10)}}, then \sphinxcode{\sphinxupquote{i=0:9}} and \sphinxcode{\sphinxupquote{ai}} is a reference to \sphinxcode{\sphinxupquote{a{[}i{]}}}.

\sphinxAtStartPar
Array with two indices or matrix:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{real{[}int{]} a(10, 11)}}, then \sphinxcode{\sphinxupquote{i=0:9}}, \sphinxcode{\sphinxupquote{j=1:10}} and \sphinxcode{\sphinxupquote{aij}} is a reference to \sphinxcode{\sphinxupquote{a(i, j)}}.

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:exampleimplicitloop}]{\sphinxcrossref{\DUrole{std,std-ref}{Implicit loop example}}}}.


\section{I/O}
\label{\detokenize{references/IO:i-o}}\label{\detokenize{references/IO::doc}}
\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:exampleio}]{\sphinxcrossref{\DUrole{std,std-ref}{I/O example}}}}

\sphinxAtStartPar
See {\hyperref[\detokenize{examples/developers:examplefilestream}]{\sphinxcrossref{\DUrole{std,std-ref}{File stream example}}}}.


\subsection{cout}
\label{\detokenize{references/IO:cout}}
\sphinxAtStartPar
Standard C++ output device (default: console).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Some text}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{cin}
\label{\detokenize{references/IO:cin}}
\sphinxAtStartPar
Standard C++ input device (default: keyboard).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{var}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{endl}
\label{\detokenize{references/IO:endl}}
\sphinxAtStartPar
End of line.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Some text}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{ifstream}
\label{\detokenize{references/IO:ifstream}}
\sphinxAtStartPar
Open a file in read mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A file is closed at the end of a block.
\end{sphinxadmonition}


\subsection{ofstream}
\label{\detokenize{references/IO:ofstream}}
\sphinxAtStartPar
Open a file in write mode.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A file is closed at the end of a block.
\end{sphinxadmonition}


\subsection{append}
\label{\detokenize{references/IO:append}}
\sphinxAtStartPar
Append data to an existing file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{binary}
\label{\detokenize{references/IO:binary}}
\sphinxAtStartPar
Write a file in binary.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{file.btxt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{seekg}
\label{\detokenize{references/IO:seekg}}
\sphinxAtStartPar
Set the file position.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{Pos}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{tellg}
\label{\detokenize{references/IO:tellg}}
\sphinxAtStartPar
Get the file position.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Pos} \PYG{o}{=} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{flush}
\label{\detokenize{references/IO:flush}}
\sphinxAtStartPar
Flush the buffer of the file.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{flush}
\end{sphinxVerbatim}


\subsection{getline}
\label{\detokenize{references/IO:getline}}
\sphinxAtStartPar
Get the current line.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{s}\PYG{p}{;}
\PYG{n+nf}{getline}\PYG{p}{(}\PYG{k+kp}{file}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Output format}
\label{\detokenize{references/IO:output-format}}
\sphinxAtStartPar
In the descriptions below, \sphinxcode{\sphinxupquote{f}} is an output stream, for example \sphinxcode{\sphinxupquote{cout}} or a \sphinxcode{\sphinxupquote{ofstream}}.

\sphinxAtStartPar
All this methods, excepted the first, return a stream, so they can be chained:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{cout}\PYG{p}{.}\PYG{k+kr}{scientific}\PYG{p}{.}\PYG{k+kr}{showpos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{precision}
\label{\detokenize{references/IO:precision}}
\sphinxAtStartPar
Set the number of digits printed to the right of the decimal point.
This applies to all subsequent floating point numbers written to that output stream.
However, this won’t make floating\sphinxhyphen{}point “integers” print with a decimal point.
It’s necessary to use \sphinxcode{\sphinxupquote{fixed}} for that effect.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{scientific}
\label{\detokenize{references/IO:scientific}}
\sphinxAtStartPar
Formats floating\sphinxhyphen{}point numbers in scientific notation

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{scientific}
\end{sphinxVerbatim}


\subsubsection{fixed}
\label{\detokenize{references/IO:fixed}}
\sphinxAtStartPar
Used fixed point notation for floating\sphinxhyphen{}point numbers.
Opposite of scientific.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{fixed}
\end{sphinxVerbatim}


\subsubsection{showbase}
\label{\detokenize{references/IO:showbase}}
\sphinxAtStartPar
Converts insertions to an external form that can be read according to the \sphinxcode{\sphinxupquote{C++}} lexical conventions for integral constants.
By default, showbase is not set.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{showbase}
\end{sphinxVerbatim}


\subsubsection{noshowbase}
\label{\detokenize{references/IO:noshowbase}}
\sphinxAtStartPar
Unset \sphinxcode{\sphinxupquote{showbase}} flags.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{noshowbase}
\end{sphinxVerbatim}


\subsubsection{showpos}
\label{\detokenize{references/IO:showpos}}
\sphinxAtStartPar
Inserts a plus sign (+) into a decimal conversion of a positive integral value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{showpos}
\end{sphinxVerbatim}


\subsubsection{noshowpos}
\label{\detokenize{references/IO:noshowpos}}
\sphinxAtStartPar
Unset \sphinxcode{\sphinxupquote{showpos}} flags.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{noshowpos}
\end{sphinxVerbatim}


\subsubsection{default}
\label{\detokenize{references/IO:default}}
\sphinxAtStartPar
Reset all the previous flags to the default expect precision.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{default}
\end{sphinxVerbatim}


\subsubsection{setw}
\label{\detokenize{references/IO:setw}}
\sphinxAtStartPar
Behaves as if member width were called with \sphinxcode{\sphinxupquote{n}} as argument on the stream on which it is inserted as a manipulator (it can be inserted on output streams).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{setw}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Functions}
\label{\detokenize{references/functions:functions}}\label{\detokenize{references/functions::doc}}

\subsection{abs}
\label{\detokenize{references/functions:abs}}
\sphinxAtStartPar
Return the absolute value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{complex}}, \sphinxcode{\sphinxupquote{fespace}} function, \sphinxcode{\sphinxupquote{real{[}int{]}}} or \sphinxcode{\sphinxupquote{real{[}int, int{]}}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}}, \sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{real{[}int{]}}} or \sphinxcode{\sphinxupquote{real{[}int, int{]}}})

\end{itemize}


\subsection{acos}
\label{\detokenize{references/functions:acos}}
\sphinxAtStartPar
\(\arccos\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{acos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{real{[}int{]}}} or \sphinxcode{\sphinxupquote{real{[}int, int{]}}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{real{[}int{]}}} or \sphinxcode{\sphinxupquote{real{[}int, int{]}}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arccos}.png}
\caption{arccos function}\label{\detokenize{references/functions:id2}}\end{figure}


\subsection{acosh}
\label{\detokenize{references/functions:acosh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{acosh}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\arccosh(x) = \ln\left(x + \sqrt{x^2-1}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arccosh}.png}
\caption{arccosh function}\label{\detokenize{references/functions:id3}}\end{figure}


\subsection{adaptmesh}
\label{\detokenize{references/functions:adaptmesh}}\label{\detokenize{references/functions:referenceadaptmesh}}
\sphinxAtStartPar
Mesh adaptation function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{hmin}\PYG{o}{=}\PYG{n}{HMin}\PYG{p}{,} \PYG{k+kp}{hmax}\PYG{o}{=}\PYG{n}{HMax}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{Err}\PYG{p}{,} \PYG{k+kp}{errg}\PYG{o}{=}\PYG{n}{ErrG}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{n}{NbVx}\PYG{p}{,} \PYG{k+kp}{nbsmooth}\PYG{o}{=}\PYG{n}{NbSmooth}\PYG{p}{,} \PYG{k+kp}{nbjacoby}\PYG{o}{=}\PYG{n}{NbJacoby}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{n}{Ratio}\PYG{p}{,} \PYG{k+kp}{omega}\PYG{o}{=}\PYG{n}{Omega}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{n}{Iso}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{n}{AbsError}\PYG{p}{,} \PYG{k+kp}{cutoff}\PYG{o}{=}\PYG{n}{CutOff}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{Verbosity}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{n}{Inquire}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{n}{SplitPbEdge}\PYG{p}{,} \PYG{k+kp}{maxsubdiv}\PYG{o}{=}\PYG{n}{MaxSubdiv}\PYG{p}{,} \PYG{k+kp}{rescaling}\PYG{o}{=}\PYG{n}{Rescaling}\PYG{p}{,} \PYG{k+kp}{keepbackvertices}\PYG{o}{=}\PYG{n}{KeepBackVertices}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{n}{isMetric}\PYG{p}{,} \PYG{k+kp}{power}\PYG{o}{=}\PYG{n}{Power}\PYG{p}{,} \PYG{k+kp}{thetamax}\PYG{o}{=}\PYG{n}{ThetaMax}\PYG{p}{,} \PYG{k+kp}{splitin2}\PYG{o}{=}\PYG{n}{SplitIn2}\PYG{p}{,} \PYG{k+kp}{metric}\PYG{o}{=}\PYG{n}{Metric}\PYG{p}{,} \PYG{k+kp}{nomeshgeneration}\PYG{o}{=}\PYG{n}{NoMeshGeneration}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{Periodic}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh to refine

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}fx, fy{]}}} (\sphinxcode{\sphinxupquote{func}} or \sphinxcode{\sphinxupquote{fespace}} function), scalar or vectorial Function to follow for the mesh adaptation

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmin=}} (\sphinxcode{\sphinxupquote{real}}) Minimum edge size

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hmax=}} (\sphinxcode{\sphinxupquote{real}}) Maximum edge size

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{err=}} (\sphinxcode{\sphinxupquote{real}}) Error level (P1 interpolation)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{errg=}} (\sphinxcode{\sphinxupquote{real}}) Relative geometrical error

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbvx=}} (\sphinxcode{\sphinxupquote{int}}) Maximum number of vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbsmooth=}} (\sphinxcode{\sphinxupquote{int}}) Number of smoothing iterations

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbjacoby=}} (\sphinxcode{\sphinxupquote{int}}) Number of iterations for the smoothing procedure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ratio=}} (\sphinxcode{\sphinxupquote{real}}) Ratio of the triangles

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{omega=}} (\sphinxcode{\sphinxupquote{real}}) Relaxation parameter for the smoothing procedure

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{iso=}} (\sphinxcode{\sphinxupquote{bool}}) Isotropic adaptation (if true)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{abserror=}} (\sphinxcode{\sphinxupquote{bool}}) Error (if true) \sphinxhyphen{} Relative error (if false)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cutoff=}} (\sphinxcode{\sphinxupquote{real}}) Lower limit of the relative error evaluation

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{verbosity=}} (\sphinxcode{\sphinxupquote{real}}) Verbosity level

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inquire=}} (\sphinxcode{\sphinxupquote{bool}}) If true, inquire graphically

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{splitpbedge=}} (\sphinxcode{\sphinxupquote{bool}}) If true, split all internal edges in half

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxsubdiv=}} (\sphinxcode{\sphinxupquote{int}}) Bound the maximum subdivisions

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rescaling=}} (\sphinxcode{\sphinxupquote{bool}}) Rescale the function in {[}0, 1{]}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{keepbackvertices=}} (\sphinxcode{\sphinxupquote{bool}}) If true, try to keep vertices of the original mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IsMetric=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the metric is defined explicitly

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{power=}} (\sphinxcode{\sphinxupquote{int}}) Exponent of the Hessian

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{thetamax=}} (\sphinxcode{\sphinxupquote{int}}) Minimum corner angle (in degree)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{splitin2=}} (\sphinxcode{\sphinxupquote{bool}}) Split all triangles into 4 sub\sphinxhyphen{}triangles if true

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{metric=}} (\sphinxcode{\sphinxupquote{{[}real{[}int{]}, real{[}int{]}, real{[}int{]}{]}}}) Array of 3 real arrays defining the metric

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nomeshgeneration=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the mesh is not generated

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{periodic=}} (\sphinxcode{\sphinxupquote{real{[}int, int{]}}}) Build an adapted periodic mesh

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Thnew}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\end{itemize}


\subsection{adj}
\label{\detokenize{references/functions:adj}}
\sphinxAtStartPar
Adjacent triangle of the triangle \(k\) by the edge \(e\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{T} \PYG{o}{=} \PYG{n}{Th}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{adj}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{e}} (\sphinxcode{\sphinxupquote{int}}) Edge number

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{T}} (\sphinxcode{\sphinxupquote{int}}) Triangle number

\end{itemize}


\subsection{AffineCG}
\label{\detokenize{references/functions:affinecg}}\label{\detokenize{references/functions:functionaffinecg}}
\sphinxAtStartPar
Affine conjugate gradient solver

\sphinxAtStartPar
Used to solve a problem like \(Ax=b\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Conv} \PYG{o}{=} \PYG{n+nf}{AffineCG}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{Precon}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{n}{NbIter}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{Eps}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{VEps}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{n}{Stop}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}} (\sphinxcode{\sphinxupquote{matrix}}) Matrix of the problem \(Ax=b\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Solution vector

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{precon=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Preconditionning function

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbiter=}} (\sphinxcode{\sphinxupquote{int}}) Maximum number of iterations

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eps=}} (\sphinxcode{\sphinxupquote{real}})

\sphinxAtStartPar
Convergence criterion

\sphinxAtStartPar
If \(\varepsilon>0\): test \(||A(x)||_p \leq \epsilon||A(x_0)||_p\)

\sphinxAtStartPar
If \(\varepsilon<0\): test \(||A(x)||_p^2 \leq |\epsilon|\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{veps=}} (\sphinxcode{\sphinxupquote{real}}) Same as \sphinxcode{\sphinxupquote{eps}}, but return \sphinxcode{\sphinxupquote{\sphinxhyphen{}eps}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stop=}} (\sphinxcode{\sphinxupquote{func}}) Convergence criterion as a function

\sphinxAtStartPar
Prototype is \sphinxcode{\sphinxupquote{func bool StopFunc (int Iter, real{[}int{]} U, real{[}int{]} g)}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}}: current solution, \sphinxcode{\sphinxupquote{g}}: current gradient (not preconditionned)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Conv (int) 0: converged \sphinxhyphen{} !0: not converged

\end{itemize}


\subsection{AffineGMRES}
\label{\detokenize{references/functions:affinegmres}}
\sphinxAtStartPar
Affine GMRES solver

\sphinxAtStartPar
Parameters and output are the same as {\hyperref[\detokenize{references/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{arg}
\label{\detokenize{references/functions:arg}}
\sphinxAtStartPar
Return the argument of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{asin}
\label{\detokenize{references/functions:asin}}
\sphinxAtStartPar
\(\arcsin\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{asin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{real{[}int{]}}} or \sphinxcode{\sphinxupquote{real{[}int, int{]}}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}}, \sphinxcode{\sphinxupquote{real{[}int{]}}} or \sphinxcode{\sphinxupquote{real{[}int, int{]}}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arcsin}.png}
\caption{arcsin function}\label{\detokenize{references/functions:id4}}\end{figure}


\subsection{asinh}
\label{\detokenize{references/functions:asinh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{asinh}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\arcsinh(x) = \ln\left(x + \sqrt{x^2+1}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arcsinh}.png}
\caption{arcsinh function}\label{\detokenize{references/functions:id5}}\end{figure}


\subsection{assert}
\label{\detokenize{references/functions:assert}}
\sphinxAtStartPar
Verify if a condition is true (same as C), if not the program stops.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Boolean condition

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsection{atan}
\label{\detokenize{references/functions:atan}}
\sphinxAtStartPar
\(\arctan\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{atan}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arctan}.png}
\caption{arctan function}\label{\detokenize{references/functions:id6}}\end{figure}


\subsection{atan2}
\label{\detokenize{references/functions:atan2}}
\sphinxAtStartPar
\(\displaystyle{\arctan\left(\frac{y}{x}\right)}\) function, returning the correct sign for \(\theta\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{atanh}
\label{\detokenize{references/functions:atanh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{theta} \PYG{o}{=} \PYG{n+nf}{atanh}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{arctanh}.png}
\caption{arctanh function}\label{\detokenize{references/functions:id7}}\end{figure}


\subsection{atoi}
\label{\detokenize{references/functions:atoi}}
\sphinxAtStartPar
Convert a string to an interger.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{atoi}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{atof}
\label{\detokenize{references/functions:atof}}
\sphinxAtStartPar
Convert a string to a real.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{atof}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{BFGS}
\label{\detokenize{references/functions:bfgs}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/functions:id1}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{buildmesh}
\label{\detokenize{references/functions:buildmesh}}\label{\detokenize{references/functions:referencebuildmesh}}
\sphinxAtStartPar
Build a 2D mesh using border elements.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{n}{points}\PYG{o}{=}\PYG{n}{Points}\PYG{p}{]}\PYG{p}{,} \PYG{p}{]}\PYG{p}{[}\PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{n}{Nbvx}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{fixedborder}\PYG{o}{=}\PYG{n}{FixedBorder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b1}}, \sphinxcode{\sphinxupquote{b2}}, \sphinxcode{\sphinxupquote{b3}}, \sphinxcode{\sphinxupquote{b4}} (\sphinxcode{\sphinxupquote{border}})

\sphinxAtStartPar
Geometry border, \sphinxcode{\sphinxupquote{b1(nn)}} means \sphinxcode{\sphinxupquote{b1}} border discretized by \sphinxcode{\sphinxupquote{nn}} vertices

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{points}} (\sphinxcode{\sphinxupquote{real{[}int, int{]}}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Specify a set of points

\sphinxAtStartPar
The size of \sphinxcode{\sphinxupquote{Points}} array is \sphinxcode{\sphinxupquote{(nbp, 2)}}, containing a set of \sphinxcode{\sphinxupquote{nbp}} points with \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} coordinates

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbvx=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Maximum number of vertices Default: 9000

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fixedborder=}} (\sphinxcode{\sphinxupquote{bool}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
If true, mesh generator cannot change the boundary mesh

\sphinxAtStartPar
Default: \sphinxcode{\sphinxupquote{false}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Resulting mesh

\end{itemize}


\subsection{ceil}
\label{\detokenize{references/functions:ceil}}
\sphinxAtStartPar
Round fractions up of \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{n+nf}{ceil}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{change}
\label{\detokenize{references/functions:change}}
\sphinxAtStartPar
Change a property of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Thnew} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{L}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Original mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} L (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Pair of old and new label

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region=}} R (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Pair of old and new region

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flabel=}} l (\sphinxcode{\sphinxupquote{func int}}) Function of int given the new label

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fregion=}} r (\sphinxcode{\sphinxupquote{func int}}) Function of int given the new region

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Thnew}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh with changed
parameters

\end{itemize}


\subsection{checkmovemesh}
\label{\detokenize{references/functions:checkmovemesh}}
\sphinxAtStartPar
Check a {\hyperref[\detokenize{references/functions:functionmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{movemesh}}}} without mesh generation.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{minT} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Dx}\PYG{p}{,} \PYG{n}{Dy}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:

\sphinxAtStartPar
Same as {\hyperref[\detokenize{references/functions:functionmovemesh}]{\sphinxcrossref{\DUrole{std,std-ref}{movemesh}}}}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minT}} (\sphinxcode{\sphinxupquote{real}}) Minimum triangle area

\end{itemize}


\subsection{chi}
\label{\detokenize{references/functions:chi}}
\sphinxAtStartPar
Characteristic function of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{IsInMesh} \PYG{o}{=} \PYG{n+nf}{chi}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}}) Position \(x\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{y}} (\sphinxcode{\sphinxupquote{real}}) Position \(y\)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{IsInMesh}} (\sphinxcode{\sphinxupquote{int}}) 1 if \((x,y)\in\) \sphinxcode{\sphinxupquote{Th}} 0 if
\((x,y)\not\in\) \sphinxcode{\sphinxupquote{Th}}

\end{itemize}


\subsection{clock}
\label{\detokenize{references/functions:clock}}
\sphinxAtStartPar
Get the clock in second.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{t}} (\sphinxcode{\sphinxupquote{real}}) Current CPU time

\end{itemize}


\subsection{complexEigenValue}
\label{\detokenize{references/functions:complexeigenvalue}}
\sphinxAtStartPar
Same as {\hyperref[\detokenize{references/functions:functioneigenvalue}]{\sphinxcrossref{\DUrole{std,std-ref}{EigenValue}}}} for complex problems.


\subsection{conj}
\label{\detokenize{references/functions:conj}}
\sphinxAtStartPar
Caculate the conjuguate of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{complex} \PYG{n}{C2} \PYG{o}{=} \PYG{n+nf}{conj}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C1}} (\sphinxcode{\sphinxupquote{complex}}) Complex number

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C2}} (\sphinxcode{\sphinxupquote{complex}}) Conjuguate of C1

\end{itemize}


\subsection{convect}
\label{\detokenize{references/functions:convect}}
\sphinxAtStartPar
Characteristics Galerkin method.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{cgm} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cgm} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{Uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Compute \(c\circ \mathbf{X}\) with \(\mathbf{X}(\mathbf{x}) = \mathbf{x}_{\tau}\) and \(\mathbf{x}_{\tau}\) is the solution of:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \dot{\mathbf{x}}_{\tau} &=& \mathbf{u}(\mathbf{x}_{\tau})\\
    \mathbf{x}_{\tau} &=& \mathbf{x}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ux}} (\sphinxcode{\sphinxupquote{fespace}} function) Velocity: \(x\) component

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uy}} (\sphinxcode{\sphinxupquote{fespace}} function) Velocity: \(y\) component

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uz}} (\sphinxcode{\sphinxupquote{fespace}} function) \sphinxstylestrong{3D only}

\sphinxAtStartPar
Velocity: \(z\) component

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dt}} (\sphinxcode{\sphinxupquote{real}}) Time step

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{fespace}} function) Function to convect

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cgm}} (\sphinxcode{\sphinxupquote{real}}) Result

\end{itemize}


\subsection{copysign}
\label{\detokenize{references/functions:copysign}}
\sphinxAtStartPar
C++ \sphinxcode{\sphinxupquote{copysign}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{copysign}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{cos}
\label{\detokenize{references/functions:cos}}
\sphinxAtStartPar
\(\cos\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{cos}.png}
\caption{cos function}\label{\detokenize{references/functions:id8}}\end{figure}


\subsection{cosh}
\label{\detokenize{references/functions:cosh}}
\sphinxAtStartPar
\(\cosh\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{cosh}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\cosh(x) = \frac{e^x + e^{-x}}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{diffnp}
\label{\detokenize{references/functions:diffnp}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{diffnp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{?} \PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{diffpos}
\label{\detokenize{references/functions:diffpos}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{diffpos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{dist}
\label{\detokenize{references/functions:dist}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{b}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{c}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{dumptable}
\label{\detokenize{references/functions:dumptable}}
\sphinxAtStartPar
Show all types, operators and functions in \sphinxstylestrong{FreeFEM}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{dumptable}\PYG{p}{(}\PYG{n}{out}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{out}} (\sphinxcode{\sphinxupquote{ostream}}) \sphinxcode{\sphinxupquote{cout}} of \sphinxcode{\sphinxupquote{ofstream}} file.

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsection{dx}
\label{\detokenize{references/functions:dx}}
\sphinxAtStartPar
\(x\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{up} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial u}{\partial x}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{up}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dxx}
\label{\detokenize{references/functions:dxx}}
\sphinxAtStartPar
\(x\) double derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x^2}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dxy}
\label{\detokenize{references/functions:dxy}}
\sphinxAtStartPar
\(xy\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dxy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x\partial y}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dxz}
\label{\detokenize{references/functions:dxz}}
\sphinxAtStartPar
\(xz\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dxz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x\partial z}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dy}
\label{\detokenize{references/functions:dy}}
\sphinxAtStartPar
\(y\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{up} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial u}{\partial y}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dyx}
\label{\detokenize{references/functions:dyx}}
\sphinxAtStartPar
\(yx\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dyx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial y\partial x}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dyy}
\label{\detokenize{references/functions:dyy}}
\sphinxAtStartPar
\(y\) double derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial x^2}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dyz}
\label{\detokenize{references/functions:dyz}}
\sphinxAtStartPar
\(yz\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dyz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial y\partial z}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dz}
\label{\detokenize{references/functions:dz}}
\sphinxAtStartPar
\(z\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{up} \PYG{o}{=} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial u}{\partial z}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dzx}
\label{\detokenize{references/functions:dzx}}
\sphinxAtStartPar
\(zx\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dzx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial z\partial x}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dzy}
\label{\detokenize{references/functions:dzy}}
\sphinxAtStartPar
\(zy\) derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dzy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial z\partial y}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{dzz}
\label{\detokenize{references/functions:dzz}}
\sphinxAtStartPar
\(z\) double derivative.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Uh} \PYG{n}{upp} \PYG{o}{=} \PYG{n+nf}{dzz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\frac{\partial^2 u}{\partial z^2}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{upp}} (\sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}


\subsection{EigenValue}
\label{\detokenize{references/functions:eigenvalue}}\label{\detokenize{references/functions:functioneigenvalue}}
\sphinxAtStartPar
Compute the generalized eigenvalue of \(Au=\lambda Bu\).
The shifted\sphinxhyphen{}inverse method is used by default with \sphinxcode{\sphinxupquote{sigma=}}\(\sigma\), the shift of the method.
The function \sphinxcode{\sphinxupquote{EigenValue}} can be used for either matrices or functions returning a matrix vector product.
The use of the matrix version is shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,}\PYG{k+kp}{B}\PYG{p}{,}\PYG{k+kp}{nev}\PYG{o}{=} \PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=} \PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}}, \sphinxcode{\sphinxupquote{B}}: matrices of same size

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nev=n}}: number of desired eigenvalues given by an integer \sphinxcode{\sphinxupquote{n}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sym=}}: the problem is symmetric or not

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tol=}}: the relative accuracy to which eigenvalues are to be determined

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value=}}: an array to store the real part of the eigenvalues

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ivalue=}}: an array to store the imaginary part of the eigenvalues

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vector=}}: a Finite Element function array to store the eigenvectors

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sigma=}}: the shift value

\item {} 
\sphinxAtStartPar
Other parameters are available for more advanced use: see the ARPACK documentation.

\end{itemize}

\sphinxAtStartPar
Output: The output is the number of converged eigenvalues, which can be different than the number of requested eigenvalues given by \sphinxcode{\sphinxupquote{nev=}}.
Note that the eigenvalues and the eigenvectors are stored for further purposes using the parameters \sphinxcode{\sphinxupquote{value=}} and \sphinxcode{\sphinxupquote{vector=}}.


\subsection{emptymesh}
\label{\detokenize{references/functions:emptymesh}}
\sphinxAtStartPar
Build an empty mesh.

\sphinxAtStartPar
Useful to handle Lagrange multipliers in mixed and Mortar methods.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{eTh} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh to empty

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ssd}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Pseudo subregion label

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{eTh}} (\sphinxcode{\sphinxupquote{mesh}}) Empty mesh

\end{itemize}


\subsection{erf}
\label{\detokenize{references/functions:erf}}\label{\detokenize{references/functions:functionerf}}
\sphinxAtStartPar
The error function:
\begin{equation*}
\begin{split}erf(x) = \frac{2}{\sqrt{pi}}\int_{0}^{x}{\exp(-t^2)dt}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{erf}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{err}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{erfc}
\label{\detokenize{references/functions:erfc}}
\sphinxAtStartPar
Complementary of the {\hyperref[\detokenize{references/functions:functionerf}]{\sphinxcrossref{\DUrole{std,std-ref}{error function}}}}:
\begin{equation*}
\begin{split}erfc(x) = 1-erf(x)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{errc} \PYG{o}{=} \PYG{n+nf}{erfc}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{err}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{exec}
\label{\detokenize{references/functions:exec}}
\sphinxAtStartPar
Execute an external command.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{v} \PYG{o}{=} \PYG{n+nf}{exec}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{command}} (\sphinxcode{\sphinxupquote{string}}) Command to execute

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{v}} (\sphinxcode{\sphinxupquote{int}}) Value returned by the command

\end{itemize}


\subsection{exit}
\label{\detokenize{references/functions:exit}}
\sphinxAtStartPar
Exit function, equivalent to \sphinxcode{\sphinxupquote{return}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{exit}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{N}} (\sphinxcode{\sphinxupquote{int}}) Return value

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsection{exp}
\label{\detokenize{references/functions:exp}}
\sphinxAtStartPar
Exponential function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}


\subsection{fdim}
\label{\detokenize{references/functions:fdim}}
\sphinxAtStartPar
Positive difference (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{fd} \PYG{o}{=} \PYG{n+nf}{fdim}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fd}} (\sphinxcode{\sphinxupquote{real}}) If \(x > y\), return \(x-y\)If \(x \leq y\), return \(0\)

\end{itemize}


\subsection{floor}
\label{\detokenize{references/functions:floor}}
\sphinxAtStartPar
Floor function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{floor}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Return the largest integer value not greater than \sphinxcode{\sphinxupquote{b}}.

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{fmax}
\label{\detokenize{references/functions:fmax}}
\sphinxAtStartPar
Maximum (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Max} \PYG{o}{=} \PYG{n+nf}{fmax}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Max}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{fmin}
\label{\detokenize{references/functions:fmin}}
\sphinxAtStartPar
Minimum (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Min} \PYG{o}{=} \PYG{n+nf}{fmin}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Min}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{fmod}
\label{\detokenize{references/functions:fmod}}
\sphinxAtStartPar
Remainder of \(a/b\) (\sphinxcode{\sphinxupquote{cmath}} function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{Mod} \PYG{o}{=} \PYG{n+nf}{fmod}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Mod}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{imag}
\label{\detokenize{references/functions:imag}}
\sphinxAtStartPar
Imaginary part of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{1.} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Im} \PYG{o}{=} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{int1d}
\label{\detokenize{references/functions:int1d}}
\sphinxAtStartPar
1D integral.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qfe}\PYG{o}{=}\PYG{n}{Qfe}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Used in {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}, {\hyperref[\detokenize{references/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} or {\hyperref[\detokenize{references/types:typevarf}]{\sphinxcrossref{\DUrole{std,std-ref}{varf}}}} definition to impose a boundary condition only (\sphinxstylestrong{FreeFEM} does not support 1D simulation), or outside to calculate a quantity.

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh where the integral is calculated

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Label of the 1D border Default: all borders of the mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfe=}} ({\hyperref[\detokenize{references/quadrature-formulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}  \sphinxstyleemphasis{(\textasciigrave{}qf3E\textasciigrave{} by default)}

\sphinxAtStartPar
Quadrature formula, see {\hyperref[\detokenize{references/quadrature-formulae:quadratureformulaeint1d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qforder=}} ({\hyperref[\detokenize{references/quadrature-formulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Quadrature order, see {\hyperref[\detokenize{references/quadrature-formulae:quadratureformulaeint1d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Depending on the situation: In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition: Non relevant.

\sphinxAtStartPar
Outside: \sphinxcode{\sphinxupquote{real}} (example: \sphinxcode{\sphinxupquote{real l = int1d(Th, 1)(1.);}}).

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition, the content of \sphinxcode{\sphinxupquote{int1d}} must be a linear or bilinear form.
\end{sphinxadmonition}


\subsection{int2d}
\label{\detokenize{references/functions:int2d}}
\sphinxAtStartPar
2D integral.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qft}\PYG{o}{=}\PYG{n}{Qft}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Or

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qft}\PYG{o}{=}\PYG{n}{Qft}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Used in {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}, {\hyperref[\detokenize{references/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} or {\hyperref[\detokenize{references/types:typevarf}]{\sphinxcrossref{\DUrole{std,std-ref}{varf}}}} definition to: \sphinxhyphen{} Calculate integral in 2D simulation \sphinxhyphen{} Impose a boundary condition in 3D simulation Or outside to calculate a quantity.

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}}) Mesh where the integral is calculated

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Region}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} Label of the 2D region (2D simulation) Default: all regions of the mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} Label of the 2D border (3D simulation) Default: all borders of the mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qft=}} ({\hyperref[\detokenize{references/quadrature-formulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}  \sphinxstyleemphasis{(\textasciigrave{}qf5T\textasciigrave{} by default)}

\sphinxAtStartPar
Quadrature formula, see {\hyperref[\detokenize{references/quadrature-formulae:quadratureformulaeint2d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qforder=}} ({\hyperref[\detokenize{references/quadrature-formulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Quadrature order, see {\hyperref[\detokenize{references/quadrature-formulae:quadratureformulaeint2d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Depending on the situation: In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition: Non relevant. Outside: \sphinxcode{\sphinxupquote{real}} (example: \sphinxcode{\sphinxupquote{real s = int2d(Th, 1)(1.);}}).

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition, the content of the \sphinxcode{\sphinxupquote{int2d}} must be a linear or bilinear form.
\end{sphinxadmonition}


\subsection{int3d}
\label{\detokenize{references/functions:int3d}}
\sphinxAtStartPar
3D integral.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qfV}\PYG{o}{=}\PYG{n}{QfV}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{qforder}\PYG{o}{=}\PYG{n}{Qforder}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Used in {\hyperref[\detokenize{references/types:typeproblem}]{\sphinxcrossref{\DUrole{std,std-ref}{problem}}}}, {\hyperref[\detokenize{references/types:typesolve}]{\sphinxcrossref{\DUrole{std,std-ref}{solve}}}} or {\hyperref[\detokenize{references/types:typevarf}]{\sphinxcrossref{\DUrole{std,std-ref}{varf}}}} definition to calculate integral in 3D simulation, or outside to calculate a quantity.

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}}) Mesh where the integral is calculated

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Region}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Label of the 3D region

\sphinxAtStartPar
Default: all regions of the mesh

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qfV=}} ({\hyperref[\detokenize{references/quadrature-formulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}  \sphinxstyleemphasis{(\textasciigrave{}qf5V\textasciigrave{} by default)}

\sphinxAtStartPar
Quadrature formula, see {\hyperref[\detokenize{references/quadrature-formulae:quadratureformulaeint3d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{qforder=}} ({\hyperref[\detokenize{references/quadrature-formulae:quadratureformulae}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formula}}}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Quadrature order, see {\hyperref[\detokenize{references/quadrature-formulae:quadratureformulaeint3d}]{\sphinxcrossref{\DUrole{std,std-ref}{quadrature formulae}}}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Depending on the situation: In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition: Non relevant. Outside: \sphinxcode{\sphinxupquote{real}} (example: \sphinxcode{\sphinxupquote{real v = int3d(Th, 1)(1.);}}).

\end{itemize}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
In a \sphinxcode{\sphinxupquote{problem}}, \sphinxcode{\sphinxupquote{solve}} or \sphinxcode{\sphinxupquote{varf}} definition, the content of the \sphinxcode{\sphinxupquote{int3d}} must be a linear or bilinear form.
\end{sphinxadmonition}


\subsection{intalledges}
\label{\detokenize{references/functions:intalledges}}\label{\detokenize{references/functions:functionintalledges}}
\sphinxAtStartPar
Integral on all edges.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{)}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}}) Mesh where the integral is calculated

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Region}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Label of the region

\sphinxAtStartPar
Default: all regions of the mesh

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Non relevant

\end{itemize}


\subsection{intallfaces}
\label{\detokenize{references/functions:intallfaces}}
\sphinxAtStartPar
Intergal on all faces.

\sphinxAtStartPar
Same as {\hyperref[\detokenize{references/functions:functionintalledges}]{\sphinxcrossref{\DUrole{std,std-ref}{intalledges}}}} for \sphinxcode{\sphinxupquote{mesh3}}.


\subsection{interpolate}
\label{\detokenize{references/functions:interpolate}}
\sphinxAtStartPar
Interpolation operator from a finite element space to another.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Wh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{inside}\PYG{o}{=}\PYG{n}{Inside}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{T}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{op}\PYG{o}{=}\PYG{n}{Op}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{U2Vc}\PYG{o}{=}\PYG{n}{U2VC}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Wh}} (\sphinxcode{\sphinxupquote{fespace}}) Target finite element space

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Vh}} (\sphinxcode{\sphinxupquote{fespace}}) Original finite element space

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{inside=}} (\sphinxcode{\sphinxupquote{bool}}) If true, create a zero extension outside the \sphinxcode{\sphinxupquote{Vh}} domain

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{t=}} (\sphinxcode{\sphinxupquote{bool}}) If true, return the transposed matrix

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{op=}} (\sphinxcode{\sphinxupquote{int}}) 0: interpolate the function (default value) 1: interpolate \(\partial_x\) 2: interpolate \(\partial_y\) 3: interpolate \(\partial_z\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{U2Vc=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Array of the same size of \sphinxcode{\sphinxupquote{Wh}} describing which component of \sphinxcode{\sphinxupquote{Vh}}is interpolated in \sphinxcode{\sphinxupquote{Wh}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I}} (\sphinxcode{\sphinxupquote{matrix}}) Interpolation matrix operator

\end{itemize}


\subsection{invdiff}
\label{\detokenize{references/functions:invdiff}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{invdiff}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)} \PYG{o}{?} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)}
\PYG{n+nf}{invdiff}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n}{e}\PYG{p}{)} \PYG{o}{?} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{invdiffnp}
\label{\detokenize{references/functions:invdiffnp}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{invdiffnp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{\PYGZam{}}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsection{invdiffpos}
\label{\detokenize{references/functions:invdiffpos}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{invdiffpos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZlt{}}\PYG{n}{b}\PYG{p}{)} \PYG{o}{?} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}


\subsection{isInf}
\label{\detokenize{references/functions:isinf}}
\sphinxAtStartPar
The C++ \sphinxcode{\sphinxupquote{isInf}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{isInf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{isNaN}
\label{\detokenize{references/functions:isnan}}
\sphinxAtStartPar
The C++ \sphinxcode{\sphinxupquote{isNan}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{bool} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{isNaN}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{isNormal}
\label{\detokenize{references/functions:isnormal}}
\sphinxAtStartPar
The C++ \sphinxcode{\sphinxupquote{isNormal}} function.


\subsection{j0}
\label{\detokenize{references/functions:j0}}
\sphinxAtStartPar
Bessel function of first kind, order 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{j0}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{j1}
\label{\detokenize{references/functions:j1}}
\sphinxAtStartPar
Bessel function of first kind, order 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{j1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{jn}
\label{\detokenize{references/functions:jn}}
\sphinxAtStartPar
Bessel function of first kind, order n.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{n+nf}{jn}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}J_n(x) = \sum_{p=0}^{\infty}\frac{(1)^p}{p!(n+p)!}\left(\frac{x}{2}\right)^{2p+n}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n}} (\sphinxcode{\sphinxupquote{int}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{jump}
\label{\detokenize{references/functions:jump}}
\sphinxAtStartPar
Jump function across an edge.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{intalledges}\PYG{p}{(}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n+nf}{jump}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{fespace}} function) Discontinuous function

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Non relevant

\end{itemize}


\subsection{LinearCG}
\label{\detokenize{references/functions:linearcg}}
\sphinxAtStartPar
Linear CG solver

\sphinxAtStartPar
Parameters and output are the same as {\hyperref[\detokenize{references/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{LinearGMRES}
\label{\detokenize{references/functions:lineargmres}}
\sphinxAtStartPar
Linear GMRES solver

\sphinxAtStartPar
Parameters and output are the same as {\hyperref[\detokenize{references/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{lgamma}
\label{\detokenize{references/functions:lgamma}}
\sphinxAtStartPar
Natural logarithm of the absolute value of the \(\Gamma\) function of \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{lg} \PYG{o}{=} \PYG{n+nf}{lgamma}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lg}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{log}
\label{\detokenize{references/functions:log}}
\sphinxAtStartPar
Natural logarithm.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{log}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Complex value

\sphinxAtStartPar
For complex value, the \sphinxcode{\sphinxupquote{log}} function is defined as:
\begin{equation*}
\begin{split}\log(z) = \log(|z|) + i\arg(z)\end{split}
\end{equation*}\end{sphinxadmonition}


\subsection{log10}
\label{\detokenize{references/functions:log10}}
\sphinxAtStartPar
Common logarithm.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{log10}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{lrint}
\label{\detokenize{references/functions:lrint}}
\sphinxAtStartPar
Integer value nearest to \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{lrint}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{lround}
\label{\detokenize{references/functions:lround}}
\sphinxAtStartPar
Round a value, and return an integer value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n+nf}{lround}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{l}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{ltime}
\label{\detokenize{references/functions:ltime}}
\sphinxAtStartPar
Return the current time since \sphinxstyleemphasis{the Epcoh}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n}{ltime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{t}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{max}
\label{\detokenize{references/functions:max}}
\sphinxAtStartPar
Maximum value of two, three or four values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{min}
\label{\detokenize{references/functions:min}}
\sphinxAtStartPar
Minimum value of two, three or four values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{movemesh}
\label{\detokenize{references/functions:movemesh}}\label{\detokenize{references/functions:functionmovemesh}}
\sphinxAtStartPar
Move a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{MovedTh} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Dx}\PYG{p}{,} \PYG{n}{Dy}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{MovedTh} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Dx}\PYG{p}{,} \PYG{n}{Dy}\PYG{p}{,} \PYG{n}{Dz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{facemerge}\PYG{o}{=}\PYG{n}{FaceMerge}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{ptmerge}\PYG{o}{=}\PYG{n}{PtMerge}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{orientation}\PYG{o}{=}\PYG{n}{Orientation}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} of \sphinxcode{\sphinxupquote{mesh3}}) Mesh to move

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dx}} (\sphinxcode{\sphinxupquote{fespace}} function) Displacement along \(x\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dy}} (\sphinxcode{\sphinxupquote{fespace}} function) Displacement along \(y\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Dz}} (\sphinxcode{\sphinxupquote{fespace}} function) \sphinxstylestrong{3D only}

\sphinxAtStartPar
Displacement along \(z\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

\sphinxAtStartPar
Set label to tetrahedra

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

\sphinxAtStartPar
Set label of faces (see {\hyperref[\detokenize{references/functions:change}]{\emph{change}}} for more information)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{facemerge=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

\sphinxAtStartPar
If equal to 1, some faces can be merged during the mesh moving Default: 1

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ptmerge=}} (\sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

\sphinxAtStartPar
Criteria to define when two points merge

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{orientation=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}} \sphinxstylestrong{3D only}

\sphinxAtStartPar
If equal to 1, allow orientation reverse if tetrahedra is not positive Default: 1

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MovedTh}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}}) Moved mesh

\end{itemize}


\subsection{NaN}
\label{\detokenize{references/functions:nan}}
\sphinxAtStartPar
C++ \sphinxcode{\sphinxupquote{nan}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n+nf}{NaN}\PYG{p}{(}\PYG{p}{[}\PYG{n}{String}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{String}} (\sphinxcode{\sphinxupquote{string}}) Default: \sphinxcode{\sphinxupquote{""}}

\end{itemize}


\subsection{NLCG}
\label{\detokenize{references/functions:nlcg}}
\sphinxAtStartPar
Non\sphinxhyphen{}linear conjugate gradient.

\sphinxAtStartPar
Parameters and output are the same as {\hyperref[\detokenize{references/functions:functionaffinecg}]{\sphinxcrossref{\DUrole{std,std-ref}{AffineCG}}}}


\subsection{on}
\label{\detokenize{references/functions:on}}
\sphinxAtStartPar
Dirichlet condition function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{Label}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{uD}\PYG{p}{)}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Used only in problem, solve and varf
\end{sphinxadmonition}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}} or \sphinxcode{\sphinxupquote{border}} in 2D)

\sphinxAtStartPar
Boundary reference where to impose the Dirichlet condition

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uD}} (\sphinxcode{\sphinxupquote{fespace}} function, \sphinxcode{\sphinxupquote{func}} or \sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{int}})

\sphinxAtStartPar
Dirichlet condition (\sphinxcode{\sphinxupquote{u}} is an unknown of the problem)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Non relevant

\end{itemize}


\subsection{plot}
\label{\detokenize{references/functions:plot}}\label{\detokenize{references/functions:referenceplot}}
\sphinxAtStartPar
Plot meshes and results.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Th}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{Uz}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{n+nf}{Wait}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{ps}\PYG{o}{=}\PYG{n}{PS}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{coef}\PYG{o}{=}\PYG{n}{Coef}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{fill}\PYG{o}{=}\PYG{n}{Fill}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Cmm}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{Value}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{aspectratio}\PYG{o}{=}\PYG{n}{AspectRatio}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{bb}\PYG{o}{=}\PYG{n}{Bb}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{n}{NbIso}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbarrow}\PYG{o}{=}\PYG{n}{NbArrow}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{viso}\PYG{o}{=}\PYG{n}{VIso}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{varrow}\PYG{o}{=}\PYG{n}{VArrow}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{bw}\PYG{o}{=}\PYG{n}{Bw}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{grey}\PYG{o}{=}\PYG{n}{Grey}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{Hsv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{boundary}\PYG{o}{=}\PYG{n}{Boundary}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{dim}\PYG{o}{=}\PYG{n}{Dim}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{prev}\PYG{o}{=}\PYG{n}{Prev}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{n}{WI}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Only one of \sphinxcode{\sphinxupquote{Th}}, \sphinxcode{\sphinxupquote{u}} or \sphinxcode{\sphinxupquote{{[}Ux, Uy{]}}} / \sphinxcode{\sphinxupquote{{[}Ux, Uy, Uz{]}}} is needed for the \sphinxcode{\sphinxupquote{plot}} command.
\end{sphinxadmonition}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}}) Mesh to display

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{u}} (\sphinxcode{\sphinxupquote{fespace}} function) Scalar \sphinxcode{\sphinxupquote{fespace}} function to display

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}Ux, Uy{]}}} / \sphinxcode{\sphinxupquote{{[}Ux, Uy, Uz{]}}} (\sphinxcode{\sphinxupquote{fespace}} function array) Vectorial \sphinxcode{\sphinxupquote{fespace}} function to display

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}Ux, Uy{]}}} (\sphinxcode{\sphinxupquote{{[}real{[}int{]}, real{[}int{]}{]}}}) Couple a real array to display a curve

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{wait=}} (\sphinxcode{\sphinxupquote{bool}}) If true, wait before continue

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ps=}} (\sphinxcode{\sphinxupquote{string}}) Name of the file to save the plot (\sphinxcode{\sphinxupquote{.ps}} or \sphinxcode{\sphinxupquote{.eps format}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{coef=}} (\sphinxcode{\sphinxupquote{real}}) Arrow size

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fill=}} (\sphinxcode{\sphinxupquote{bool}}) If true, fill color between isovalue (usable with scalar \sphinxcode{\sphinxupquote{fespace}} function only)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cmm=}} (\sphinxcode{\sphinxupquote{string}}) Text comment in the graphic window

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value=}} (\sphinxcode{\sphinxupquote{bool}}) If true, show the value scale

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{aspectratio=}} (\sphinxcode{\sphinxupquote{bool}}) If true, preserve the aspect ratio

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bb=}} (\sphinxcode{\sphinxupquote{{[}real{[}int{]}, real{[}int{]}{]}}}) Specify a bounding box using two corner points

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbiso=}} (\sphinxcode{\sphinxupquote{int}}) Number of isovalues

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nbarrow=}} (\sphinxcode{\sphinxupquote{int}}) Number of colors of arrows values

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{viso=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Specify an array of isovalues

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{varrow=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Specify an array of arrows values color

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bw=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the plot is in black and white

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{grey=}} (\sphinxcode{\sphinxupquote{bool}}) If true, the plot is in grey scale

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hsv=}} (\sphinxcode{\sphinxupquote{real{[}int{]}}}) Array of \(3\times n\) values defining HSV color model \([h_1, s_1, v_1, ..., h_n, s_n, v_n]\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{boundary=}} (\sphinxcode{\sphinxupquote{bool}}) If true, display the boundary of the domain

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dim=}} (\sphinxcode{\sphinxupquote{int}}) Set the dimension of the plot: 2 or 3

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{prev=}} (\sphinxcode{\sphinxupquote{bool}}) Use the graphic state of the previous state

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WindowIndex=}} (\sphinxcode{\sphinxupquote{int}}) Specify window index for multiple windows graphics

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
See the {\hyperref[\detokenize{documentation/visualization:plot}]{\sphinxcrossref{\DUrole{std,std-ref}{plot}}}} section for in\sphinxhyphen{}graphic commands.


\subsection{polar}
\label{\detokenize{references/functions:polar}}
\sphinxAtStartPar
Polar coordinates.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{complex} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{polar}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{p}} (\sphinxcode{\sphinxupquote{complex}})

\end{itemize}


\subsection{pow}
\label{\detokenize{references/functions:pow}}
\sphinxAtStartPar
Power function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\(p=a^b\)

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{p}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{projection}
\label{\detokenize{references/functions:projection}}
\sphinxAtStartPar
Arithmetic useful function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{p} \PYG{o}{=} \PYG{n+nf}{projection}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Projection is equivalent to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{projection}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{min}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{p}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randinit}
\label{\detokenize{references/functions:randinit}}\label{\detokenize{references/functions:referencerandinit}}
\sphinxAtStartPar
Initialize the state vector by using a seed.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{randinit}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{seed}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsection{randint31}
\label{\detokenize{references/functions:randint31}}\label{\detokenize{references/functions:referencerandint31}}
\sphinxAtStartPar
Generate \sphinxcode{\sphinxupquote{unsigned int}} (31 bits) random number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randint31}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{randint32}
\label{\detokenize{references/functions:randint32}}\label{\detokenize{references/functions:referencerandint32}}
\sphinxAtStartPar
Generate \sphinxcode{\sphinxupquote{unsigned int}} (32 bits) random number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randint32}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{randreal1}
\label{\detokenize{references/functions:randreal1}}\label{\detokenize{references/functions:referencerandreal1}}
\sphinxAtStartPar
Generate uniform \sphinxcode{\sphinxupquote{real}} in \([0, 1]\) (32 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randreal1}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randreal2}
\label{\detokenize{references/functions:randreal2}}\label{\detokenize{references/functions:referencerandreal2}}
\sphinxAtStartPar
Generate uniform \sphinxcode{\sphinxupquote{real}} in \([0, 1)\) (32 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randreal2}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randreal3}
\label{\detokenize{references/functions:randreal3}}\label{\detokenize{references/functions:referencerandreal3}}
\sphinxAtStartPar
Generate uniform \sphinxcode{\sphinxupquote{real}} in \((0, 1)\) (32 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randreal3}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{randres53}
\label{\detokenize{references/functions:randres53}}\label{\detokenize{references/functions:referencerandres53}}
\sphinxAtStartPar
Generate uniform \sphinxcode{\sphinxupquote{real}} in \([0, 1)\) (53 bits).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{randres53}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{readmesh}
\label{\detokenize{references/functions:readmesh}}
\sphinxAtStartPar
Read a 2D mesh file at different formats (see {\hyperref[\detokenize{documentation/mesh-generation:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh}\PYG{p}{(}\PYG{n}{MeshFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MeshFileName}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{readmesh3}
\label{\detokenize{references/functions:readmesh3}}
\sphinxAtStartPar
Read a 3D mesh file at different formats (see {\hyperref[\detokenize{documentation/mesh-generation:meshreadwrite3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh3}\PYG{p}{(}\PYG{n}{MeshFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MeshFileName}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}})

\end{itemize}


\subsection{real}
\label{\detokenize{references/functions:real}}
\sphinxAtStartPar
Return the real part of a complex number.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{c}} (\sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{rint}
\label{\detokenize{references/functions:rint}}
\sphinxAtStartPar
Integer value nearest to \(x\) (real value).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{rint}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{round}
\label{\detokenize{references/functions:round}}
\sphinxAtStartPar
Round a value (real value).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{round}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{r}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{savemesh}
\label{\detokenize{references/functions:savemesh}}
\sphinxAtStartPar
Save a 2D or 3D mesh in different formats (see {\hyperref[\detokenize{documentation/mesh-generation:meshdatastructurereadwrite}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation 2D}}}} and {\hyperref[\detokenize{documentation/mesh-generation:meshreadwrite3d}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation 3D}}}}).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MeshFileName}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MeshFileName}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsection{set}
\label{\detokenize{references/functions:set}}\label{\detokenize{references/functions:functionset}}
\sphinxAtStartPar
Set a property to a matrix. See {\hyperref[\detokenize{references/types:typematrix}]{\sphinxcrossref{\DUrole{std,std-ref}{matrix}}}}.


\subsection{sign}
\label{\detokenize{references/functions:sign}}
\sphinxAtStartPar
Sign of a value.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{sign}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{int}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{signbit}
\label{\detokenize{references/functions:signbit}}
\sphinxAtStartPar
C++ \sphinxcode{\sphinxupquote{signbit}} function

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{signbit}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{sin}
\label{\detokenize{references/functions:sin}}
\sphinxAtStartPar
\(\sin\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}} or \sphinxcode{\sphinxupquote{complex}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{sin}.png}
\caption{sin function}\label{\detokenize{references/functions:id9}}\end{figure}


\subsection{sinh}
\label{\detokenize{references/functions:sinh}}
\sphinxAtStartPar
\(\sinh\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{sinh}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\sinh(x) = \frac{e^{x} - e^{-x}}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{sinh}.png}
\caption{sinh function}\label{\detokenize{references/functions:id10}}\end{figure}


\subsection{sort}
\label{\detokenize{references/functions:sort}}
\sphinxAtStartPar
Sort two array in parallel

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{sort}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}} (\sphinxcode{\sphinxupquote{real{[}int{]}}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{B}} (\sphinxcode{\sphinxupquote{int{[}int{]}}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{A}} is sorted in ascending order, \sphinxcode{\sphinxupquote{B}} is sorted as \sphinxcode{\sphinxupquote{A}}.


\subsection{splitmesh}
\label{\detokenize{references/functions:splitmesh}}
\sphinxAtStartPar
Split mesh triangles according to a function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{splitmesh}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th0}} (\sphinxcode{\sphinxupquote{mesh}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{f}} (\sphinxcode{\sphinxupquote{func}} or \sphinxcode{\sphinxupquote{fespace}} function)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{sqrt}
\label{\detokenize{references/functions:sqrt}}
\sphinxAtStartPar
Square root

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{square}
\label{\detokenize{references/functions:square}}\label{\detokenize{references/functions:functionsquare}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Square of a number.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{S} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Build a structured square mesh.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nnX}\PYG{p}{,} \PYG{n}{nnY}\PYG{p}{,} \PYG{p}{[}\PYG{p}{[}\PYG{n}{L}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{H}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{Flags}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Labels}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nnX}} (\sphinxcode{\sphinxupquote{int}}) Discretization along \(x\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nnY}} (\sphinxcode{\sphinxupquote{int}}) Discretization along \(y\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{L}} (\sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}} Length along \(x\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{H}} (\sphinxcode{\sphinxupquote{real}}) \sphinxstyleemphasis{{[}Optional{]}} Height along \(y\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flags=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) \sphinxstyleemphasis{{[}Optional{]}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}
\begin{quote}

\sphinxAtStartPar
Structured mesh type, see {\hyperref[\detokenize{documentation/mesh-generation:meshsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{Mesh Generation chapter}}}} for more information
\end{quote}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{storagetotal}
\label{\detokenize{references/functions:storagetotal}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{total} \PYG{o}{=} \PYG{n}{storagetotal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{storageused}
\label{\detokenize{references/functions:storageused}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{used} \PYG{o}{=} \PYG{n}{storageused}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{strtod}
\label{\detokenize{references/functions:strtod}}
\sphinxAtStartPar
C++ \sphinxtitleref{strtod} function

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{text} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10.5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{number} \PYG{o}{=} \PYG{n}{strtod}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{text}} (\sphinxcode{\sphinxupquote{string}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{number}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{strtol}
\label{\detokenize{references/functions:strtol}}
\sphinxAtStartPar
C++ \sphinxtitleref{strtol} function

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{string} \PYG{n}{text} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{10}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{number} \PYG{o}{=} \PYG{n}{strtol}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{base} \PYG{o}{=} \PYG{l+m+mi}{16}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{number} \PYG{o}{=} \PYG{n}{strtol}\PYG{p}{(}\PYG{n}{text}\PYG{p}{,} \PYG{n}{base}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{text}} (\sphinxcode{\sphinxupquote{string}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{base}} (\sphinxcode{\sphinxupquote{int}}) Base \sphinxstyleemphasis{{[}Optional{]}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{number}} (\sphinxcode{\sphinxupquote{int}})

\end{itemize}


\subsection{swap}
\label{\detokenize{references/functions:swap}}
\sphinxAtStartPar
Swap values.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{swap}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{a}} (\sphinxcode{\sphinxupquote{real}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsection{system}
\label{\detokenize{references/functions:system}}
\sphinxAtStartPar
Execute a system command.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Res} \PYG{o}{=} \PYG{n+nf}{system}\PYG{p}{(}\PYG{n}{Command}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Command}} (\sphinxcode{\sphinxupquote{string}}) System command

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Res}} (\sphinxcode{\sphinxupquote{int}}) Value returned by the system command

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
On Windows, the full path of the command is needed. For example, to execute \sphinxcode{\sphinxupquote{ls.exe}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Res} \PYG{o}{=} \PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{cygwin}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{k+kp}{bin}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s}{ls.exe}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{tan}
\label{\detokenize{references/functions:tan}}
\sphinxAtStartPar
\(\tan\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{tan}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{tan}.png}
\caption{tan function}\label{\detokenize{references/functions:id11}}\end{figure}


\subsection{tanh}
\label{\detokenize{references/functions:tanh}}
\sphinxAtStartPar
\(\tanh\) function.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n+nf}{tanh}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{theta}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{tanh}.png}
\caption{tanh function}\label{\detokenize{references/functions:id12}}\end{figure}


\subsection{tgamma}
\label{\detokenize{references/functions:tgamma}}
\sphinxAtStartPar
Calculate the \(\Gamma\) function of \(x\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{tg} \PYG{o}{=} \PYG{n+nf}{tgamma}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tg}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{time}
\label{\detokenize{references/functions:time}}
\sphinxAtStartPar
Return the current time (C++ function).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{n}{time}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameter:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{t}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{trace}
\label{\detokenize{references/functions:trace}}
\sphinxAtStartPar
Matrix trace

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{tr} \PYG{o}{=} \PYG{n}{trace}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Matrix

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Trace of the matrix (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{trunc}
\label{\detokenize{references/functions:trunc}}
\sphinxAtStartPar
Split triangle of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{Split}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th0}} (\sphinxcode{\sphinxupquote{mesh}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{R}} (\sphinxcode{\sphinxupquote{bool}} or \sphinxcode{\sphinxupquote{int}}) Split triangles where \sphinxcode{\sphinxupquote{R}} is true or different from 0

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{split=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Level of splitting Default: 1

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Label number of new boundary item Default: 1

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsection{y0}
\label{\detokenize{references/functions:y0}}
\sphinxAtStartPar
Bessel function of second kind, order 0.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{y0}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{y1}
\label{\detokenize{references/functions:y1}}
\sphinxAtStartPar
Bessel function of second kind, order 1.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{y1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\subsection{yn}
\label{\detokenize{references/functions:yn}}
\sphinxAtStartPar
Bessel function of second kind, order n.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n+nf}{yn}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}Y_n(x) = \lim_{\lambda\rightarrow n}{\frac{J_{\lambda}(x)\cos(\lambda\pi)-J_{-\lambda}(x)}{\sin(\lambda\pi)}}\end{split}
\end{equation*}
\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n}} (\sphinxcode{\sphinxupquote{int}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{x}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{b}} (\sphinxcode{\sphinxupquote{real}})

\end{itemize}


\section{External libraries}
\label{\detokenize{references/external-libraries:external-libraries}}\label{\detokenize{references/external-libraries:externallibraries}}\label{\detokenize{references/external-libraries::doc}}

\subsection{aniso}
\label{\detokenize{references/external-libraries:aniso}}

\subsubsection{boundaniso}
\label{\detokenize{references/external-libraries:boundaniso}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id1}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{BEC}
\label{\detokenize{references/external-libraries:bec}}

\subsubsection{BECtrap}
\label{\detokenize{references/external-libraries:bectrap}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id2}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{GPvortex}
\label{\detokenize{references/external-libraries:gpvortex}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id3}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dxGPVortex}
\label{\detokenize{references/external-libraries:dxgpvortex}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id4}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dyGPVortex}
\label{\detokenize{references/external-libraries:dygpvortex}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id5}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{Binary I/O}
\label{\detokenize{references/external-libraries:binary-i-o}}

\subsubsection{LoadVec}
\label{\detokenize{references/external-libraries:loadvec}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id6}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{LoadFlag}
\label{\detokenize{references/external-libraries:loadflag}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id7}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{SaveVec}
\label{\detokenize{references/external-libraries:savevec}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id8}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{flag}
\label{\detokenize{references/external-libraries:flag}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id9}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{buildlayer}
\label{\detokenize{references/external-libraries:buildlayer}}

\subsubsection{buildlayers}
\label{\detokenize{references/external-libraries:buildlayers}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id10}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ClosePoints}
\label{\detokenize{references/external-libraries:closepoints}}

\subsubsection{radiusSearch}
\label{\detokenize{references/external-libraries:radiussearch}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id11}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Voisinage}
\label{\detokenize{references/external-libraries:voisinage}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id12}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{neighborhood}
\label{\detokenize{references/external-libraries:neighborhood}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id13}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{ClosePoints2}
\label{\detokenize{references/external-libraries:closepoints2}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id14}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{ClosePoint}
\label{\detokenize{references/external-libraries:closepoint}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id15}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{ClosePoints1}
\label{\detokenize{references/external-libraries:closepoints1}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id16}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{Curvature}
\label{\detokenize{references/external-libraries:curvature}}

\subsubsection{extractborder}
\label{\detokenize{references/external-libraries:extractborder}}
\sphinxAtStartPar
Extract a border of a mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{Res} \PYG{o}{=} \PYG{n}{extractborder}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Label}\PYG{p}{,} \PYG{n}{Points}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Label}} (\sphinxcode{\sphinxupquote{int}}) Label of the border to extract

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Points}} (\sphinxcode{\sphinxupquote{real{[}int, int{]}}}) Extracted points Must be allocated as \sphinxcode{\sphinxupquote{real{[}int, int{]} Points(3, 1);}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Res}} (\sphinxcode{\sphinxupquote{real}}) Length of the extracted border

\end{itemize}


\subsubsection{curvature}
\label{\detokenize{references/external-libraries:id17}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id18}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{raxicurvature}
\label{\detokenize{references/external-libraries:raxicurvature}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id19}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{curves}
\label{\detokenize{references/external-libraries:curves}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id20}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{setecurveabcisse}
\label{\detokenize{references/external-libraries:setecurveabcisse}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id21}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{equiparameter}
\label{\detokenize{references/external-libraries:equiparameter}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id22}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Tresca}
\label{\detokenize{references/external-libraries:tresca}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id23}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{VonMises}
\label{\detokenize{references/external-libraries:vonmises}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id24}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{dfft}
\label{\detokenize{references/external-libraries:dfft}}
\sphinxAtStartPar
Refer to the \sphinxhref{http://www.fftw.org/}{FFTW documentation} for more informations.


\subsubsection{plandfft}
\label{\detokenize{references/external-libraries:plandfft}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id25}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{execute}
\label{\detokenize{references/external-libraries:execute}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id26}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{delete}
\label{\detokenize{references/external-libraries:delete}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id27}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dfft}
\label{\detokenize{references/external-libraries:id28}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id29}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{map}
\label{\detokenize{references/external-libraries:map}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id30}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{distance}
\label{\detokenize{references/external-libraries:distance}}
\sphinxAtStartPar
Need

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{distance}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{distance}
\label{\detokenize{references/external-libraries:id31}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{distance}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{,} \PYG{n+nf}{dist}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{distmax}\PYG{o}{=}\PYG{n}{DistMax}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{d}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dist}} (\sphinxcode{\sphinxupquote{real{[}int{]}}})

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\end{itemize}

\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id32}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{checkdist}
\label{\detokenize{references/external-libraries:checkdist}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id33}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{DxWriter}
\label{\detokenize{references/external-libraries:dxwriter}}

\subsubsection{Dxaddmesh}
\label{\detokenize{references/external-libraries:dxaddmesh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id34}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Dxaddtimeseries}
\label{\detokenize{references/external-libraries:dxaddtimeseries}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id35}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Dxaddsol2ts}
\label{\detokenize{references/external-libraries:dxaddsol2ts}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id36}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{Element\_P1bl}
\label{\detokenize{references/external-libraries:element-p1bl}}

\subsubsection{expert}
\label{\detokenize{references/external-libraries:expert}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id37}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{exactpartition}
\label{\detokenize{references/external-libraries:exactpartition}}

\subsubsection{exactpartition}
\label{\detokenize{references/external-libraries:id38}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id39}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ff\sphinxhyphen{}AiryBiry}
\label{\detokenize{references/external-libraries:ff-airybiry}}

\subsubsection{airy}
\label{\detokenize{references/external-libraries:airy}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id40}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{biry}
\label{\detokenize{references/external-libraries:biry}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id41}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ff\sphinxhyphen{}cmaes}
\label{\detokenize{references/external-libraries:ff-cmaes}}

\subsubsection{cmaes}
\label{\detokenize{references/external-libraries:cmaes}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id42}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ff\_gsl\_awk}
\label{\detokenize{references/external-libraries:ff-gsl-awk}}\label{\detokenize{references/external-libraries:referenceffgslawk}}
\sphinxAtStartPar
Refer to the \sphinxhref{https://www.gnu.org/software/gsl/doc/html/index.html}{GSL documentation} for more informations


\subsubsection{gslcdfugaussianP}
\label{\detokenize{references/external-libraries:gslcdfugaussianp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfugaussianQ}
\label{\detokenize{references/external-libraries:gslcdfugaussianq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfugaussianPinv}
\label{\detokenize{references/external-libraries:gslcdfugaussianpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfugaussianQinv}
\label{\detokenize{references/external-libraries:gslcdfugaussianqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}ugaussian\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianP}
\label{\detokenize{references/external-libraries:gslcdfgaussianp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianQ}
\label{\detokenize{references/external-libraries:gslcdfgaussianq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianPinv}
\label{\detokenize{references/external-libraries:gslcdfgaussianpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgaussianQinv}
\label{\detokenize{references/external-libraries:gslcdfgaussianqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gaussian\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaP}
\label{\detokenize{references/external-libraries:gslcdfgammap}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaQ}
\label{\detokenize{references/external-libraries:gslcdfgammaq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaPinv}
\label{\detokenize{references/external-libraries:gslcdfgammapinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgammaQinv}
\label{\detokenize{references/external-libraries:gslcdfgammaqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gamma\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyP}
\label{\detokenize{references/external-libraries:gslcdfcauchyp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyQ}
\label{\detokenize{references/external-libraries:gslcdfcauchyq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyPinv}
\label{\detokenize{references/external-libraries:gslcdfcauchypinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfcauchyQinv}
\label{\detokenize{references/external-libraries:gslcdfcauchyqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}cauchy\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplaceP}
\label{\detokenize{references/external-libraries:gslcdflaplacep}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplaceQ}
\label{\detokenize{references/external-libraries:gslcdflaplaceq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplacePinv}
\label{\detokenize{references/external-libraries:gslcdflaplacepinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflaplaceQinv}
\label{\detokenize{references/external-libraries:gslcdflaplaceqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lapalce\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighP}
\label{\detokenize{references/external-libraries:gslcdfrayleighp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighQ}
\label{\detokenize{references/external-libraries:gslcdfrayleighq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighPinv}
\label{\detokenize{references/external-libraries:gslcdfrayleighpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfrayleighQinv}
\label{\detokenize{references/external-libraries:gslcdfrayleighqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}rayleigh\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqP}
\label{\detokenize{references/external-libraries:gslcdfchisqp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqQ}
\label{\detokenize{references/external-libraries:gslcdfchisqq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqPinv}
\label{\detokenize{references/external-libraries:gslcdfchisqpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfchisqQinv}
\label{\detokenize{references/external-libraries:gslcdfchisqqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}chisq\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialP}
\label{\detokenize{references/external-libraries:gslcdfexponentialp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialQ}
\label{\detokenize{references/external-libraries:gslcdfexponentialq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialPinv}
\label{\detokenize{references/external-libraries:gslcdfexponentialpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexponentialQinv}
\label{\detokenize{references/external-libraries:gslcdfexponentialqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exponential\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexppowP}
\label{\detokenize{references/external-libraries:gslcdfexppowp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exppow\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfexppowQ}
\label{\detokenize{references/external-libraries:gslcdfexppowq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}exppow\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistP}
\label{\detokenize{references/external-libraries:gslcdftdistp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistQ}
\label{\detokenize{references/external-libraries:gslcdftdistq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistPinv}
\label{\detokenize{references/external-libraries:gslcdftdistpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdftdistQinv}
\label{\detokenize{references/external-libraries:gslcdftdistqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}t\PYGZus{}dist\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistP}
\label{\detokenize{references/external-libraries:gslcdffdistp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistQ}
\label{\detokenize{references/external-libraries:gslcdffdistq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistPinv}
\label{\detokenize{references/external-libraries:gslcdffdistpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdffdistQinv}
\label{\detokenize{references/external-libraries:gslcdffdistqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}fdist\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaP}
\label{\detokenize{references/external-libraries:gslcdfbetap}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaQ}
\label{\detokenize{references/external-libraries:gslcdfbetaq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaPinv}
\label{\detokenize{references/external-libraries:gslcdfbetapinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbetaQinv}
\label{\detokenize{references/external-libraries:gslcdfbetaqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}beta\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatP}
\label{\detokenize{references/external-libraries:gslcdfflatp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatQ}
\label{\detokenize{references/external-libraries:gslcdfflatq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatPinv}
\label{\detokenize{references/external-libraries:gslcdfflatpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfflatQinv}
\label{\detokenize{references/external-libraries:gslcdfflatqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}flat\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalP}
\label{\detokenize{references/external-libraries:gslcdflognormalp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalQ}
\label{\detokenize{references/external-libraries:gslcdflognormalq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalPinv}
\label{\detokenize{references/external-libraries:gslcdflognormalpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflognormalQinv}
\label{\detokenize{references/external-libraries:gslcdflognormalqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}lognormal\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1P}
\label{\detokenize{references/external-libraries:gslcdfgumbel1p}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1Q}
\label{\detokenize{references/external-libraries:gslcdfgumbel1q}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1Pinv}
\label{\detokenize{references/external-libraries:gslcdfgumbel1pinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel1Qinv}
\label{\detokenize{references/external-libraries:gslcdfgumbel1qinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel1\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2P}
\label{\detokenize{references/external-libraries:gslcdfgumbel2p}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2Q}
\label{\detokenize{references/external-libraries:gslcdfgumbel2q}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2Pinv}
\label{\detokenize{references/external-libraries:gslcdfgumbel2pinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgumbel2Qinv}
\label{\detokenize{references/external-libraries:gslcdfgumbel2qinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}gumbel2\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullP}
\label{\detokenize{references/external-libraries:gslcdfweibullp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullQ}
\label{\detokenize{references/external-libraries:gslcdfweibullq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullPinv}
\label{\detokenize{references/external-libraries:gslcdfweibullpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfweibullQinv}
\label{\detokenize{references/external-libraries:gslcdfweibullqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}weibull\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoP}
\label{\detokenize{references/external-libraries:gslcdfparetop}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoQ}
\label{\detokenize{references/external-libraries:gslcdfparetoq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoPinv}
\label{\detokenize{references/external-libraries:gslcdfparetopinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfparetoQinv}
\label{\detokenize{references/external-libraries:gslcdfparetoqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pareto\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticP}
\label{\detokenize{references/external-libraries:gslcdflogisticp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticQ}
\label{\detokenize{references/external-libraries:gslcdflogisticq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticPinv}
\label{\detokenize{references/external-libraries:gslcdflogisticpinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}Pinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdflogisticQinv}
\label{\detokenize{references/external-libraries:gslcdflogisticqinv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}logistic\PYGZus{}Qinv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbinomialP}
\label{\detokenize{references/external-libraries:gslcdfbinomialp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}binomial\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfbinomialQ}
\label{\detokenize{references/external-libraries:gslcdfbinomialq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}binomial\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpoissonP}
\label{\detokenize{references/external-libraries:gslcdfpoissonp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}poisson\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpoissonQ}
\label{\detokenize{references/external-libraries:gslcdfpoissonq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}poisson\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgeometricP}
\label{\detokenize{references/external-libraries:gslcdfgeometricp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}geometric\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfgeometricQ}
\label{\detokenize{references/external-libraries:gslcdfgeometricq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}geometric\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfnegativebinomialP}
\label{\detokenize{references/external-libraries:gslcdfnegativebinomialp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}negative\PYGZus{}binomial\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfnegativebinomialQ}
\label{\detokenize{references/external-libraries:gslcdfnegativebinomialq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}negative\PYGZus{}binomial\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpascalP}
\label{\detokenize{references/external-libraries:gslcdfpascalp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pascal\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslcdfpascalQ}
\label{\detokenize{references/external-libraries:gslcdfpascalq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}cdf\PYGZus{}pascal\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbernoullipdf}
\label{\detokenize{references/external-libraries:gslranbernoullipdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}bernoulli\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbeta}
\label{\detokenize{references/external-libraries:gslranbeta}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}beta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbetapdf}
\label{\detokenize{references/external-libraries:gslranbetapdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}beta\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranbinomialpdf}
\label{\detokenize{references/external-libraries:gslranbinomialpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}binomial\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexponential}
\label{\detokenize{references/external-libraries:gslranexponential}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exponential}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexponentialpdf}
\label{\detokenize{references/external-libraries:gslranexponentialpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exponential\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexppow}
\label{\detokenize{references/external-libraries:gslranexppow}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exppow}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranexppowpdf}
\label{\detokenize{references/external-libraries:gslranexppowpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}exppow\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrancauchy}
\label{\detokenize{references/external-libraries:gslrancauchy}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}cauchy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrancauchypdf}
\label{\detokenize{references/external-libraries:gslrancauchypdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}cauchy\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranchisq}
\label{\detokenize{references/external-libraries:gslranchisq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}chisq}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranchisqpdf}
\label{\detokenize{references/external-libraries:gslranchisqpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}chisq\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranerlang}
\label{\detokenize{references/external-libraries:gslranerlang}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}erlang}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranerlangpdf}
\label{\detokenize{references/external-libraries:gslranerlangpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}erlang\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranfdist}
\label{\detokenize{references/external-libraries:gslranfdist}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}fdist}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranfdistpdf}
\label{\detokenize{references/external-libraries:gslranfdistpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}fdist\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranflat}
\label{\detokenize{references/external-libraries:gslranflat}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}flat}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranflatpdf}
\label{\detokenize{references/external-libraries:gslranflatpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}flat\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangamma}
\label{\detokenize{references/external-libraries:gslrangamma}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammaint}
\label{\detokenize{references/external-libraries:gslrangammaint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammapdf}
\label{\detokenize{references/external-libraries:gslrangammapdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammamt}
\label{\detokenize{references/external-libraries:gslrangammamt}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}mt}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangammaknuth}
\label{\detokenize{references/external-libraries:gslrangammaknuth}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gamma\PYGZus{}knuth}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussian}
\label{\detokenize{references/external-libraries:gslrangaussian}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussianratiomethod}
\label{\detokenize{references/external-libraries:gslrangaussianratiomethod}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}ratio\PYGZus{}method}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussianziggurat}
\label{\detokenize{references/external-libraries:gslrangaussianziggurat}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}ziggurat}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussianpdf}
\label{\detokenize{references/external-libraries:gslrangaussianpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussian}
\label{\detokenize{references/external-libraries:gslranugaussian}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussianratiomethod}
\label{\detokenize{references/external-libraries:gslranugaussianratiomethod}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}ratio\PYGZus{}method}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussianpdf}
\label{\detokenize{references/external-libraries:gslranugaussianpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussiantail}
\label{\detokenize{references/external-libraries:gslrangaussiantail}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}tail}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangaussiantailpdf}
\label{\detokenize{references/external-libraries:gslrangaussiantailpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gaussian\PYGZus{}tail\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussiantail}
\label{\detokenize{references/external-libraries:gslranugaussiantail}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}tail}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranugaussiantailpdf}
\label{\detokenize{references/external-libraries:gslranugaussiantailpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}ugaussian\PYGZus{}tail\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlandau}
\label{\detokenize{references/external-libraries:gslranlandau}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}landau}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlandaupdf}
\label{\detokenize{references/external-libraries:gslranlandaupdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}landau\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangeometricpdf}
\label{\detokenize{references/external-libraries:gslrangeometricpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}geometric\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel1}
\label{\detokenize{references/external-libraries:gslrangumbel1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel1pdf}
\label{\detokenize{references/external-libraries:gslrangumbel1pdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel1\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel2}
\label{\detokenize{references/external-libraries:gslrangumbel2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrangumbel2pdf}
\label{\detokenize{references/external-libraries:gslrangumbel2pdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}gumbel2\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlogistic}
\label{\detokenize{references/external-libraries:gslranlogistic}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}logistic}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlogisticpdf}
\label{\detokenize{references/external-libraries:gslranlogisticpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}logistic\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlognormal}
\label{\detokenize{references/external-libraries:gslranlognormal}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}lognormal}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlognormalpdf}
\label{\detokenize{references/external-libraries:gslranlognormalpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}lognormal\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlogarithmicpdf}
\label{\detokenize{references/external-libraries:gslranlogarithmicpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}logarithmic\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrannegativebinomialpdf}
\label{\detokenize{references/external-libraries:gslrannegativebinomialpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}negative\PYGZus{}binomial\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranpascalpdf}
\label{\detokenize{references/external-libraries:gslranpascalpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}pascal\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranpareto}
\label{\detokenize{references/external-libraries:gslranpareto}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}pareto}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranparetopdf}
\label{\detokenize{references/external-libraries:gslranparetopdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}pareto\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranpoissonpdf}
\label{\detokenize{references/external-libraries:gslranpoissonpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}poisson\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleigh}
\label{\detokenize{references/external-libraries:gslranrayleigh}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleighpdf}
\label{\detokenize{references/external-libraries:gslranrayleighpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleightail}
\label{\detokenize{references/external-libraries:gslranrayleightail}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh\PYGZus{}tail}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranrayleightailpdf}
\label{\detokenize{references/external-libraries:gslranrayleightailpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}rayleigh\PYGZus{}tail\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrantdist}
\label{\detokenize{references/external-libraries:gslrantdist}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}tdsit}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslrantdistpdf}
\label{\detokenize{references/external-libraries:gslrantdistpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}tdsit\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlaplace}
\label{\detokenize{references/external-libraries:gslranlaplace}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}laplace}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlaplacepdf}
\label{\detokenize{references/external-libraries:gslranlaplacepdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}laplace\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranlevy}
\label{\detokenize{references/external-libraries:gslranlevy}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}levy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranweibull}
\label{\detokenize{references/external-libraries:gslranweibull}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}weibull}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslranweibullpdf}
\label{\detokenize{references/external-libraries:gslranweibullpdf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}ran\PYGZus{}weibull\PYGZus{}pdf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAi}
\label{\detokenize{references/external-libraries:gslsfairyai}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBi}
\label{\detokenize{references/external-libraries:gslsfairybi}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAiscaled}
\label{\detokenize{references/external-libraries:gslsfairyaiscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBiscaled}
\label{\detokenize{references/external-libraries:gslsfairybiscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAideriv}
\label{\detokenize{references/external-libraries:gslsfairyaideriv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBideriv}
\label{\detokenize{references/external-libraries:gslsfairybideriv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyAiderivscaled}
\label{\detokenize{references/external-libraries:gslsfairyaiderivscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai\PYGZus{}deriv\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyBiderivscaled}
\label{\detokenize{references/external-libraries:gslsfairybiderivscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Bi\PYGZus{}deriv\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroAi}
\label{\detokenize{references/external-libraries:gslsfairyzeroai}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}Ai}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroBi}
\label{\detokenize{references/external-libraries:gslsfairyzerobi}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}aero\PYGZus{}Bi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroAideriv}
\label{\detokenize{references/external-libraries:gslsfairyzeroaideriv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}aero\PYGZus{}Ai\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfairyzeroBideriv}
\label{\detokenize{references/external-libraries:gslsfairyzerobideriv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}airy\PYGZus{}aero\PYGZus{}Bi\PYGZus{}deriv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJ0}
\label{\detokenize{references/external-libraries:gslsfbesselj0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}J0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJ1}
\label{\detokenize{references/external-libraries:gslsfbesselj1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}J1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJn}
\label{\detokenize{references/external-libraries:gslsfbesseljn}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Jn}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselY0}
\label{\detokenize{references/external-libraries:gslsfbessely0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselY1}
\label{\detokenize{references/external-libraries:gslsfbessely1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Y1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselYn}
\label{\detokenize{references/external-libraries:gslsfbesselyn}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Yn}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI0}
\label{\detokenize{references/external-libraries:gslsfbesseli0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI1}
\label{\detokenize{references/external-libraries:gslsfbesseli1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselIn}
\label{\detokenize{references/external-libraries:gslsfbesselin}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}In}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI0scaled}
\label{\detokenize{references/external-libraries:gslsfbesseli0scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselI1scaled}
\label{\detokenize{references/external-libraries:gslsfbesseli1scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}I1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselInscaled}
\label{\detokenize{references/external-libraries:gslsfbesselinscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}In\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK0}
\label{\detokenize{references/external-libraries:gslsfbesselk0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK1}
\label{\detokenize{references/external-libraries:gslsfbesselk1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKn}
\label{\detokenize{references/external-libraries:gslsfbesselkn}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Kn}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK0scaled}
\label{\detokenize{references/external-libraries:gslsfbesselk0scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselK1scaled}
\label{\detokenize{references/external-libraries:gslsfbesselk1scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}K1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKnscaled}
\label{\detokenize{references/external-libraries:gslsfbesselknscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Kn\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselj0}
\label{\detokenize{references/external-libraries:id43}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}j0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselj1}
\label{\detokenize{references/external-libraries:id44}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}j1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselj2}
\label{\detokenize{references/external-libraries:gslsfbesselj2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}j2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseljl}
\label{\detokenize{references/external-libraries:gslsfbesseljl}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}jl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessely0}
\label{\detokenize{references/external-libraries:id45}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessely1}
\label{\detokenize{references/external-libraries:id46}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessely2}
\label{\detokenize{references/external-libraries:gslsfbessely2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}y0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselyl}
\label{\detokenize{references/external-libraries:gslsfbesselyl}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}jl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseli0scaled}
\label{\detokenize{references/external-libraries:id47}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}i0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseli1scaled}
\label{\detokenize{references/external-libraries:id48}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}i1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesseli2scaled}
\label{\detokenize{references/external-libraries:gslsfbesseli2scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}i2\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselilscaled}
\label{\detokenize{references/external-libraries:gslsfbesselilscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}il\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselk0scaled}
\label{\detokenize{references/external-libraries:id49}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}k0\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselk1scaled}
\label{\detokenize{references/external-libraries:id50}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}k1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselk2scaled}
\label{\detokenize{references/external-libraries:gslsfbesselk2scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}k2\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselklscaled}
\label{\detokenize{references/external-libraries:gslsfbesselklscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}kl\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselJnu}
\label{\detokenize{references/external-libraries:gslsfbesseljnu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Jnu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselYnu}
\label{\detokenize{references/external-libraries:gslsfbesselynu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Ynu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselInuscaled}
\label{\detokenize{references/external-libraries:gslsfbesselinuscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Inu\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselInu}
\label{\detokenize{references/external-libraries:gslsfbesselinu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Inu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKnuscaled}
\label{\detokenize{references/external-libraries:gslsfbesselknuscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Knu\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselKnu}
\label{\detokenize{references/external-libraries:gslsfbesselknu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}Knu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbessellnKnu}
\label{\detokenize{references/external-libraries:gslsfbessellnknu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}lnKnu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselzeroJ0}
\label{\detokenize{references/external-libraries:gslsfbesselzeroj0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}zero\PYGZus{}J0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselzeroJ1}
\label{\detokenize{references/external-libraries:gslsfbesselzeroj1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}zero\PYGZus{}J1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbesselzeroJnu}
\label{\detokenize{references/external-libraries:gslsfbesselzerojnu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}bessel\PYGZus{}zero\PYGZus{}Jnu}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfclausen}
\label{\detokenize{references/external-libraries:gslsfclausen}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}clausen}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhydrogenicR1}
\label{\detokenize{references/external-libraries:gslsfhydrogenicr1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hydrogenicR\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdawson}
\label{\detokenize{references/external-libraries:gslsfdawson}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}dawnson}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye1}
\label{\detokenize{references/external-libraries:gslsfdebye1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye2}
\label{\detokenize{references/external-libraries:gslsfdebye2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye3}
\label{\detokenize{references/external-libraries:gslsfdebye3}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye4}
\label{\detokenize{references/external-libraries:gslsfdebye4}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}4}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye5}
\label{\detokenize{references/external-libraries:gslsfdebye5}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}5}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdebye6}
\label{\detokenize{references/external-libraries:gslsfdebye6}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}debye\PYGZus{}6}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdilog}
\label{\detokenize{references/external-libraries:gslsfdilog}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}dilog}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfmultiply}
\label{\detokenize{references/external-libraries:gslsfmultiply}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintKcomp}
\label{\detokenize{references/external-libraries:gslsfellintkcomp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Kcomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintEcomp}
\label{\detokenize{references/external-libraries:gslsfellintecomp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Ecomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintPcomp}
\label{\detokenize{references/external-libraries:gslsfellintpcomp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Pcomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintDcomp}
\label{\detokenize{references/external-libraries:gslsfellintdcomp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}Dcomp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintF}
\label{\detokenize{references/external-libraries:gslsfellintf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}F}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintE}
\label{\detokenize{references/external-libraries:gslsfellinte}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}E}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfellintRC}
\label{\detokenize{references/external-libraries:gslsfellintrc}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}ellint\PYGZus{}RC}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferfc}
\label{\detokenize{references/external-libraries:gslsferfc}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erfc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflogerfc}
\label{\detokenize{references/external-libraries:gslsflogerfc}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}erfc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferf}
\label{\detokenize{references/external-libraries:gslsferf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferfZ}
\label{\detokenize{references/external-libraries:gslsferfz}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erf\PYGZus{}Z}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsferfQ}
\label{\detokenize{references/external-libraries:gslsferfq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}erf\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhazard}
\label{\detokenize{references/external-libraries:gslsfhazard}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hazard}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexp}
\label{\detokenize{references/external-libraries:gslsfexp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exp}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpmult}
\label{\detokenize{references/external-libraries:gslsfexpmult}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exp\PYGZus{}mult}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpm1}
\label{\detokenize{references/external-libraries:gslsfexpm1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expm1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexprel}
\label{\detokenize{references/external-libraries:gslsfexprel}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exprel}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexprel2}
\label{\detokenize{references/external-libraries:gslsfexprel2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exprel\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpreln}
\label{\detokenize{references/external-libraries:gslsfexpreln}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}exprel\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE1}
\label{\detokenize{references/external-libraries:gslsfexpinte1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE2}
\label{\detokenize{references/external-libraries:gslsfexpinte2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEn}
\label{\detokenize{references/external-libraries:gslsfexpinten}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}En}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE1scaled}
\label{\detokenize{references/external-libraries:gslsfexpinte1scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintE2scaled}
\label{\detokenize{references/external-libraries:gslsfexpinte2scaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}E1\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEnscaled}
\label{\detokenize{references/external-libraries:gslsfexpintenscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}En\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEi}
\label{\detokenize{references/external-libraries:gslsfexpintei}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}Ei}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpintEiscaled}
\label{\detokenize{references/external-libraries:gslsfexpinteiscaled}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}Ei\PYGZus{}scaled}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfShi}
\label{\detokenize{references/external-libraries:gslsfshi}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Shi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfChi}
\label{\detokenize{references/external-libraries:gslsfchi}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Chi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfexpint3}
\label{\detokenize{references/external-libraries:gslsfexpint3}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}expint\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfSi}
\label{\detokenize{references/external-libraries:gslsfsi}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Si}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfCi}
\label{\detokenize{references/external-libraries:gslsfci}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}Ci}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfatanint}
\label{\detokenize{references/external-libraries:gslsfatanint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}atanint}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracm1}
\label{\detokenize{references/external-libraries:gslsffermidiracm1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}m1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac0}
\label{\detokenize{references/external-libraries:gslsffermidirac0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac1}
\label{\detokenize{references/external-libraries:gslsffermidirac1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac2}
\label{\detokenize{references/external-libraries:gslsffermidirac2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracint}
\label{\detokenize{references/external-libraries:gslsffermidiracint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracmhalf}
\label{\detokenize{references/external-libraries:gslsffermidiracmhalf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}mhalf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirachalf}
\label{\detokenize{references/external-libraries:gslsffermidirachalf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}half}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidirac3half}
\label{\detokenize{references/external-libraries:gslsffermidirac3half}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}3half}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffermidiracinc0}
\label{\detokenize{references/external-libraries:gslsffermidiracinc0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fermi\PYGZus{}dirac\PYGZus{}inc\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflngamma}
\label{\detokenize{references/external-libraries:gslsflngamma}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lngamma}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgamma}
\label{\detokenize{references/external-libraries:gslsfgamma}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammastar}
\label{\detokenize{references/external-libraries:gslsfgammastar}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gammastar}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammainv}
\label{\detokenize{references/external-libraries:gslsfgammainv}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gammainv}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftaylorcoeff}
\label{\detokenize{references/external-libraries:gslsftaylorcoeff}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}taylorcoeff}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsffact}
\label{\detokenize{references/external-libraries:gslsffact}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}fact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfdoublefact}
\label{\detokenize{references/external-libraries:gslsfdoublefact}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}doublefact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnfact}
\label{\detokenize{references/external-libraries:gslsflnfact}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnfact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflndoublefact}
\label{\detokenize{references/external-libraries:gslsflndoublefact}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lndoublefact}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnchoose}
\label{\detokenize{references/external-libraries:gslsflnchoose}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnchoose}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfchoose}
\label{\detokenize{references/external-libraries:gslsfchoose}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}choose}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnpoch}
\label{\detokenize{references/external-libraries:gslsflnpoch}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnpoch}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpoch}
\label{\detokenize{references/external-libraries:gslsfpoch}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}poch}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpochrel}
\label{\detokenize{references/external-libraries:gslsfpochrel}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}pochrel}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammaincQ}
\label{\detokenize{references/external-libraries:gslsfgammaincq}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma\PYGZus{}inc\PYGZus{}Q}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammaincP}
\label{\detokenize{references/external-libraries:gslsfgammaincp}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma\PYGZus{}inc\PYGZus{}P}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgammainc}
\label{\detokenize{references/external-libraries:gslsfgammainc}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gamma\PYGZus{}inc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnbeta}
\label{\detokenize{references/external-libraries:gslsflnbeta}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnbeta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbeta}
\label{\detokenize{references/external-libraries:gslsfbeta}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}beta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfbetainc}
\label{\detokenize{references/external-libraries:gslsfbetainc}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}betaçinc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpoly1}
\label{\detokenize{references/external-libraries:gslsfgegenpoly1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpoly2}
\label{\detokenize{references/external-libraries:gslsfgegenpoly2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpoly3}
\label{\detokenize{references/external-libraries:gslsfgegenpoly3}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfgegenpolyn}
\label{\detokenize{references/external-libraries:gslsfgegenpolyn}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}gegenpoly\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg0F1}
\label{\detokenize{references/external-libraries:gslsfhyperg0f1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}0F1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg1F1int}
\label{\detokenize{references/external-libraries:gslsfhyperg1f1int}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}1F1\PYGZus{}inc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg1F1}
\label{\detokenize{references/external-libraries:gslsfhyperg1f1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}1F1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhypergUint}
\label{\detokenize{references/external-libraries:gslsfhyperguint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}U\PYGZus{}inc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhypergU}
\label{\detokenize{references/external-libraries:gslsfhypergu}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}U}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhyperg2F0}
\label{\detokenize{references/external-libraries:gslsfhyperg2f0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hyperg\PYGZus{}U\PYGZus{}2F0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerre1}
\label{\detokenize{references/external-libraries:gslsflaguerre1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerre2}
\label{\detokenize{references/external-libraries:gslsflaguerre2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerre3}
\label{\detokenize{references/external-libraries:gslsflaguerre3}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflaguerren}
\label{\detokenize{references/external-libraries:gslsflaguerren}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}laguerre\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflambertW0}
\label{\detokenize{references/external-libraries:gslsflambertw0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lambert\PYGZus{}W0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflambertWm1}
\label{\detokenize{references/external-libraries:gslsflambertwm1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lambert\PYGZus{}Wm1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendrePl}
\label{\detokenize{references/external-libraries:gslsflegendrepl}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Pl}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreP1}
\label{\detokenize{references/external-libraries:gslsflegendrep1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}P1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreP2}
\label{\detokenize{references/external-libraries:gslsflegendrep2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}P2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreP3}
\label{\detokenize{references/external-libraries:gslsflegendrep3}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}P3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreQ0}
\label{\detokenize{references/external-libraries:gslsflegendreq0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Q0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreQ1}
\label{\detokenize{references/external-libraries:gslsflegendreq1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Q1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreQl}
\label{\detokenize{references/external-libraries:gslsflegendreql}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Ql}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendrePlm}
\label{\detokenize{references/external-libraries:gslsflegendreplm}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}Plm}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendresphPlm}
\label{\detokenize{references/external-libraries:gslsflegendresphplm}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}sphP1m}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendrearraysize}
\label{\detokenize{references/external-libraries:gslsflegendrearraysize}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}array\PYGZus{}size}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPhalf}
\label{\detokenize{references/external-libraries:gslsfconicalphalf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}half}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPmhalf}
\label{\detokenize{references/external-libraries:gslsfconicalpmhalf}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}mhalf}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalP0}
\label{\detokenize{references/external-libraries:gslsfconicalp0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalP1}
\label{\detokenize{references/external-libraries:gslsfconicalp1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPsphreg}
\label{\detokenize{references/external-libraries:gslsfconicalpsphreg}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}sph\PYGZus{}reg}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfconicalPcylreg}
\label{\detokenize{references/external-libraries:gslsfconicalpcylreg}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}conicalP\PYGZus{}cyl\PYGZus{}reg}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreH3d0}
\label{\detokenize{references/external-libraries:gslsflegendreh3d0}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}H3d\PYGZus{}0}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreH3d1}
\label{\detokenize{references/external-libraries:gslsflegendreh3d1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}H3d\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflegendreH3d}
\label{\detokenize{references/external-libraries:gslsflegendreh3d}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}legendre\PYGZus{}H3d}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflog}
\label{\detokenize{references/external-libraries:gslsflog}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflogabs}
\label{\detokenize{references/external-libraries:gslsflogabs}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}abs}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflog1plusx}
\label{\detokenize{references/external-libraries:gslsflog1plusx}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}1plusx}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflog1plusxmx}
\label{\detokenize{references/external-libraries:gslsflog1plusxmx}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}log\PYGZus{}1plusx\PYGZus{}mx}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpowint}
\label{\detokenize{references/external-libraries:gslsfpowint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}pow\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsiint}
\label{\detokenize{references/external-libraries:gslsfpsiint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi}
\label{\detokenize{references/external-libraries:gslsfpsi}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi1piy}
\label{\detokenize{references/external-libraries:gslsfpsi1piy}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}1piy}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi1int}
\label{\detokenize{references/external-libraries:gslsfpsi1int}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}1\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsi1}
\label{\detokenize{references/external-libraries:gslsfpsi1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfpsin}
\label{\detokenize{references/external-libraries:gslsfpsin}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}psi\PYGZus{}n}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsynchrotron1}
\label{\detokenize{references/external-libraries:gslsfsynchrotron1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}synchrotron\PYGZus{}1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsynchrotron2}
\label{\detokenize{references/external-libraries:gslsfsynchrotron2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}synchrotron\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport2}
\label{\detokenize{references/external-libraries:gslsftransport2}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}2}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport3}
\label{\detokenize{references/external-libraries:gslsftransport3}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}3}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport4}
\label{\detokenize{references/external-libraries:gslsftransport4}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}4}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsftransport5}
\label{\detokenize{references/external-libraries:gslsftransport5}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}transport\PYGZus{}5}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsin}
\label{\detokenize{references/external-libraries:gslsfsin}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}sin}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfcos}
\label{\detokenize{references/external-libraries:gslsfcos}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}cos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhypot}
\label{\detokenize{references/external-libraries:gslsfhypot}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hypot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfsinc}
\label{\detokenize{references/external-libraries:gslsfsinc}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}sinc}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflnsinh}
\label{\detokenize{references/external-libraries:gslsflnsinh}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lnsinh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsflncosh}
\label{\detokenize{references/external-libraries:gslsflncosh}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}lncosh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfanglerestrictsymm}
\label{\detokenize{references/external-libraries:gslsfanglerestrictsymm}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}andle\PYGZus{}restrict\PYGZus{}symm}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfanglerestrictpos}
\label{\detokenize{references/external-libraries:gslsfanglerestrictpos}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}angle\PYGZus{}restrict\PYGZus{}pos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzetaint}
\label{\detokenize{references/external-libraries:gslsfzetaint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zeta\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzeta}
\label{\detokenize{references/external-libraries:gslsfzeta}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zeta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzetam1}
\label{\detokenize{references/external-libraries:gslsfzetam1}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zetam1}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfzetam1int}
\label{\detokenize{references/external-libraries:gslsfzetam1int}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}zetam1\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfhzeta}
\label{\detokenize{references/external-libraries:gslsfhzeta}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}hzeta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfetaint}
\label{\detokenize{references/external-libraries:gslsfetaint}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}eta\PYGZus{}int}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{gslsfeta}
\label{\detokenize{references/external-libraries:gslsfeta}}
\sphinxAtStartPar
Link to:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{gsl\PYGZus{}sf\PYGZus{}eta}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{ff\sphinxhyphen{}Ipopt}
\label{\detokenize{references/external-libraries:ff-ipopt}}
\sphinxAtStartPar
Refer to the \sphinxhref{https://projects.coin-or.org/Ipopt}{Ipopt documentation} for more informations.


\subsubsection{IPOPT}
\label{\detokenize{references/external-libraries:ipopt}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id51}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{fflapack}
\label{\detokenize{references/external-libraries:fflapack}}
\sphinxAtStartPar
Refer to the \sphinxhref{http://www.netlib.org/lapack/}{LAPACK documentation} for more informations.


\subsubsection{inv}
\label{\detokenize{references/external-libraries:inv}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id52}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dgeev}
\label{\detokenize{references/external-libraries:dgeev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id53}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zgeev}
\label{\detokenize{references/external-libraries:zgeev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id54}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{geev}
\label{\detokenize{references/external-libraries:geev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id55}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{geev}
\label{\detokenize{references/external-libraries:id56}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id57}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dggev}
\label{\detokenize{references/external-libraries:dggev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id58}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zggev}
\label{\detokenize{references/external-libraries:zggev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id59}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dsygvd}
\label{\detokenize{references/external-libraries:dsygvd}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id60}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dgesdd}
\label{\detokenize{references/external-libraries:dgesdd}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id61}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zhegv}
\label{\detokenize{references/external-libraries:zhegv}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id62}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dsyev}
\label{\detokenize{references/external-libraries:dsyev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id63}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zheev}
\label{\detokenize{references/external-libraries:zheev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id64}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ff\sphinxhyphen{}mmap\sphinxhyphen{}semaphore}
\label{\detokenize{references/external-libraries:ff-mmap-semaphore}}

\subsubsection{Wait}
\label{\detokenize{references/external-libraries:wait}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id65}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{trywait}
\label{\detokenize{references/external-libraries:trywait}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id66}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Post}
\label{\detokenize{references/external-libraries:post}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id67}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{msync}
\label{\detokenize{references/external-libraries:msync}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id68}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Read}
\label{\detokenize{references/external-libraries:read}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id69}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Write}
\label{\detokenize{references/external-libraries:write}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id70}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ffnewuoa}
\label{\detokenize{references/external-libraries:ffnewuoa}}

\subsubsection{newuoa}
\label{\detokenize{references/external-libraries:newuoa}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id71}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ff\sphinxhyphen{}NLopt}
\label{\detokenize{references/external-libraries:ff-nlopt}}
\sphinxAtStartPar
Refer to the \sphinxhref{https://nlopt.readthedocs.io/en/latest/}{NLOPT documentation} for more informations.


\subsubsection{nloptDIRECT}
\label{\detokenize{references/external-libraries:nloptdirect}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id72}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTL}
\label{\detokenize{references/external-libraries:nloptdirectl}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id73}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTLRand}
\label{\detokenize{references/external-libraries:nloptdirectlrand}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id74}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTScal}
\label{\detokenize{references/external-libraries:nloptdirectscal}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id75}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTNoScal}
\label{\detokenize{references/external-libraries:nloptdirectnoscal}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id76}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTLNoScal}
\label{\detokenize{references/external-libraries:nloptdirectlnoscal}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id77}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptDIRECTLRandNoScal}
\label{\detokenize{references/external-libraries:nloptdirectlrandnoscal}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id78}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptOrigDIRECT}
\label{\detokenize{references/external-libraries:nloptorigdirect}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id79}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptOrigDIRECTL}
\label{\detokenize{references/external-libraries:nloptorigdirectl}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id80}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptStoGO}
\label{\detokenize{references/external-libraries:nloptstogo}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id81}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptStoGORand}
\label{\detokenize{references/external-libraries:nloptstogorand}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id82}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptLBFGS}
\label{\detokenize{references/external-libraries:nloptlbfgs}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id83}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptPRAXIS}
\label{\detokenize{references/external-libraries:nloptpraxis}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id84}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptVar1}
\label{\detokenize{references/external-libraries:nloptvar1}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id85}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptVar2}
\label{\detokenize{references/external-libraries:nloptvar2}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id86}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewton}
\label{\detokenize{references/external-libraries:nlopttnewton}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id87}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewtonRestart}
\label{\detokenize{references/external-libraries:nlopttnewtonrestart}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id88}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewtonPrecond}
\label{\detokenize{references/external-libraries:nlopttnewtonprecond}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id89}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptTNewtonPrecondRestart}
\label{\detokenize{references/external-libraries:nlopttnewtonprecondrestart}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id90}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptCRS2}
\label{\detokenize{references/external-libraries:nloptcrs2}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id91}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptMMA}
\label{\detokenize{references/external-libraries:nloptmma}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id92}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptCOBYLA}
\label{\detokenize{references/external-libraries:nloptcobyla}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id93}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptNEWUOA}
\label{\detokenize{references/external-libraries:nloptnewuoa}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id94}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptNEWUOABound}
\label{\detokenize{references/external-libraries:nloptnewuoabound}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id95}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptNelderMead}
\label{\detokenize{references/external-libraries:nloptneldermead}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id96}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptSbplx}
\label{\detokenize{references/external-libraries:nloptsbplx}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id97}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptBOBYQA}
\label{\detokenize{references/external-libraries:nloptbobyqa}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id98}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptISRES}
\label{\detokenize{references/external-libraries:nloptisres}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id99}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptSLSQP}
\label{\detokenize{references/external-libraries:nloptslsqp}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id100}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptMLSL}
\label{\detokenize{references/external-libraries:nloptmlsl}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id101}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptMLSLLDS}
\label{\detokenize{references/external-libraries:nloptmlsllds}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id102}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptAUGLAG}
\label{\detokenize{references/external-libraries:nloptauglag}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id103}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{nloptAUGLAGEQ}
\label{\detokenize{references/external-libraries:nloptauglageq}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id104}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ffrandom}
\label{\detokenize{references/external-libraries:ffrandom}}

\subsubsection{srandomdev}
\label{\detokenize{references/external-libraries:srandomdev}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id105}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{srandom}
\label{\detokenize{references/external-libraries:srandom}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id106}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{random}
\label{\detokenize{references/external-libraries:random}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id107}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{FreeFemQA}
\label{\detokenize{references/external-libraries:freefemqa}}

\subsubsection{MeshGenQA}
\label{\detokenize{references/external-libraries:meshgenqa}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id108}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{freeyams}
\label{\detokenize{references/external-libraries:freeyams}}

\subsubsection{freeyams}
\label{\detokenize{references/external-libraries:id109}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id110}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{gmsh}
\label{\detokenize{references/external-libraries:gmsh}}
\sphinxAtStartPar
Need

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gmsh}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{gmsh}} software is available \sphinxhref{http://gmsh.info/}{here}


\subsubsection{gmshload}
\label{\detokenize{references/external-libraries:gmshload}}
\sphinxAtStartPar
Load a 2D mesh build with Gmsh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{gmshload}\PYG{p}{(}\PYG{n}{MeshFile}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{reftri}\PYG{o}{=}\PYG{n}{RefTri}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{renum}\PYG{o}{=}\PYG{n}{Renum}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MeshFile}} (\sphinxcode{\sphinxupquote{string}}) Mesh file name

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reftri=}} (.. todo:: todo)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{renum=}} (.. todo:: todo)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}})

\end{itemize}


\subsubsection{gmshload3}
\label{\detokenize{references/external-libraries:gmshload3}}
\sphinxAtStartPar
Load a 3D mesh build with Gmsh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{gmshload3}\PYG{p}{(}\PYG{n}{MeshFile}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{RefTet}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{renum}\PYG{o}{=}\PYG{n}{Renum}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MeshFile}} (\sphinxcode{\sphinxupquote{string}}) Mesh file name

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reftet=}} (.. todo:: todo)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{renum=}} (.. todo:: todo)

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}})

\end{itemize}


\subsubsection{savegmsh}
\label{\detokenize{references/external-libraries:savegmsh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id111}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{gsl}
\label{\detokenize{references/external-libraries:gsl}}

\subsubsection{gslpolysolvequadratic}
\label{\detokenize{references/external-libraries:gslpolysolvequadratic}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id112}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslpolysolvecubic}
\label{\detokenize{references/external-libraries:gslpolysolvecubic}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id113}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslpolycomplexsolve}
\label{\detokenize{references/external-libraries:gslpolycomplexsolve}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id114}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrnguniform}
\label{\detokenize{references/external-libraries:gslrnguniform}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id115}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrnguniformpos}
\label{\detokenize{references/external-libraries:gslrnguniformpos}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id116}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslname}
\label{\detokenize{references/external-libraries:gslname}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id117}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrngget}
\label{\detokenize{references/external-libraries:gslrngget}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id118}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrngmin}
\label{\detokenize{references/external-libraries:gslrngmin}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id119}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrngmax}
\label{\detokenize{references/external-libraries:gslrngmax}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id120}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrngset}
\label{\detokenize{references/external-libraries:gslrngset}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id121}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gslrngtype}
\label{\detokenize{references/external-libraries:gslrngtype}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id122}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{ilut}
\label{\detokenize{references/external-libraries:ilut}}

\subsubsection{applyIlutPrecond}
\label{\detokenize{references/external-libraries:applyilutprecond}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id123}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{makeIlutPrecond}
\label{\detokenize{references/external-libraries:makeilutprecond}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id124}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{iohdf5}
\label{\detokenize{references/external-libraries:iohdf5}}

\subsubsection{savehdf5sol}
\label{\detokenize{references/external-libraries:savehdf5sol}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id125}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{iovtk}
\label{\detokenize{references/external-libraries:iovtk}}

\subsubsection{savevtk}
\label{\detokenize{references/external-libraries:savevtk}}
\sphinxAtStartPar
Save mesh or solution in vtk/vtu format.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{n}{FileName}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Ux}\PYG{p}{,} \PYG{n}{Uy}\PYG{p}{,} \PYG{n}{Uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{withsurfacemesh}\PYG{o}{=}\PYG{n}{WithSurfaceMesh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{floatmesh}\PYG{o}{=}\PYG{n}{FloatMesh}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{floatsol}\PYG{o}{=}\PYG{n}{FloatSol}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{bin}\PYG{o}{=}\PYG{n}{Bin}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{swap}\PYG{o}{=}\PYG{n}{Swap}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{FileName}} (\sphinxcode{\sphinxupquote{string}}) File name: \sphinxcode{\sphinxupquote{*.vtk}} or
\sphinxcode{\sphinxupquote{*.vtu}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh}} or \sphinxcode{\sphinxupquote{mesh3}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}Ux, Uy, Uz{]}, p}} (\sphinxcode{\sphinxupquote{fespace}} function of vector of \sphinxcode{\sphinxupquote{fespace}} functions) Solutions to save, as much as wanted

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dataname=}} (\sphinxcode{\sphinxupquote{string}}) Name of solutions, seprated by a space

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{withsurfacemesh=}} (\sphinxcode{\sphinxupquote{bool}})
.. todo:: todo

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{order=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) Order of solutions.

\sphinxAtStartPar
Available: 0 or 1

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{floatmesh=}} (\sphinxcode{\sphinxupquote{bool}}) .. todo:: todo

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{floatsol=}} (\sphinxcode{\sphinxupquote{bool}}) .. todo:: todo

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{bin=}} (\sphinxcode{\sphinxupquote{bool}}) If true, save file in binary format

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{swap}} (\sphinxcode{\sphinxupquote{bool}}) .. todo:: todo

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
None

\end{itemize}


\subsubsection{vtkload}
\label{\detokenize{references/external-libraries:vtkload}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id126}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{vtkload3}
\label{\detokenize{references/external-libraries:vtkload3}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id127}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{isoline}
\label{\detokenize{references/external-libraries:isoline}}
\sphinxAtStartPar
Need

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{isoline}\PYG{l+s}{\PYGZdq{}}
\end{sphinxVerbatim}


\subsubsection{isoline}
\label{\detokenize{references/external-libraries:id128}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{n+nf}{isoline}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{xy}\PYG{p}{,} \PYG{k+kp}{iso}\PYG{o}{=}\PYG{n}{Iso}\PYG{p}{,} \PYG{k+kp}{close}\PYG{o}{=}\PYG{n}{Close}\PYG{p}{,} \PYG{k+kp}{smoothing}\PYG{o}{=}\PYG{n}{Smoothing}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{n}{Ratio}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{n}{Eps}\PYG{p}{,} \PYG{k+kp}{beginend}\PYG{o}{=}\PYG{n}{BeginEnd}\PYG{p}{,} \PYG{k+kp}{file}\PYG{o}{=}\PYG{n}{File}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id129}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Curve}
\label{\detokenize{references/external-libraries:curve}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id130}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Area}
\label{\detokenize{references/external-libraries:area}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id131}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{findallocalmin}
\label{\detokenize{references/external-libraries:findallocalmin}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id132}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{lapack}
\label{\detokenize{references/external-libraries:lapack}}

\subsubsection{inv}
\label{\detokenize{references/external-libraries:id133}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id134}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dgeev}
\label{\detokenize{references/external-libraries:id135}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id136}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zgeev}
\label{\detokenize{references/external-libraries:id137}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id138}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{geev}
\label{\detokenize{references/external-libraries:id139}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id140}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dggev}
\label{\detokenize{references/external-libraries:id141}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id142}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zggev}
\label{\detokenize{references/external-libraries:id143}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id144}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dsygvd}
\label{\detokenize{references/external-libraries:id145}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id146}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dgesdd}
\label{\detokenize{references/external-libraries:id147}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id148}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zhegv}
\label{\detokenize{references/external-libraries:id149}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id150}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dsyev}
\label{\detokenize{references/external-libraries:id151}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id152}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{zheev}
\label{\detokenize{references/external-libraries:id153}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id154}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dgelsy}
\label{\detokenize{references/external-libraries:dgelsy}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id155}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{lgbmo}
\label{\detokenize{references/external-libraries:lgbmo}}

\subsubsection{bmo}
\label{\detokenize{references/external-libraries:bmo}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id156}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{mat\_dervieux}
\label{\detokenize{references/external-libraries:mat-dervieux}}

\subsubsection{MatUpWind1}
\label{\detokenize{references/external-libraries:matupwind1}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id157}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{mat\_psi}
\label{\detokenize{references/external-libraries:mat-psi}}

\subsubsection{MatUpWind0}
\label{\detokenize{references/external-libraries:matupwind0}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id158}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{medit}
\label{\detokenize{references/external-libraries:medit}}\label{\detokenize{references/external-libraries:referencemedit}}

\subsubsection{medit}
\label{\detokenize{references/external-libraries:id159}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id160}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{savesol}
\label{\detokenize{references/external-libraries:savesol}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id161}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{readsol}
\label{\detokenize{references/external-libraries:readsol}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id162}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{metis}
\label{\detokenize{references/external-libraries:metis}}

\subsubsection{metisnodal}
\label{\detokenize{references/external-libraries:metisnodal}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id163}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{metisdual}
\label{\detokenize{references/external-libraries:metisdual}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id164}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{MetricKuate}
\label{\detokenize{references/external-libraries:metrickuate}}

\subsubsection{MetricKuate}
\label{\detokenize{references/external-libraries:id165}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id166}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{MetricPk}
\label{\detokenize{references/external-libraries:metricpk}}

\subsubsection{MetricPk}
\label{\detokenize{references/external-libraries:id167}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id168}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{mmg3d}
\label{\detokenize{references/external-libraries:mmg3d}}

\subsubsection{mmg3d}
\label{\detokenize{references/external-libraries:id169}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id170}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{mmg3d\sphinxhyphen{}v4.0}
\label{\detokenize{references/external-libraries:mmg3d-v4-0}}

\subsubsection{mmg3d}
\label{\detokenize{references/external-libraries:id171}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id172}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{msh3}
\label{\detokenize{references/external-libraries:msh3}}

\subsubsection{change}
\label{\detokenize{references/external-libraries:change}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id173}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{movemesh23}
\label{\detokenize{references/external-libraries:movemesh23}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id174}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{movemesh2D3Dsurf}
\label{\detokenize{references/external-libraries:movemesh2d3dsurf}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id175}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{movemesh3}
\label{\detokenize{references/external-libraries:movemesh3}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id176}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{movemesh}
\label{\detokenize{references/external-libraries:movemesh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id177}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{movemesh3D}
\label{\detokenize{references/external-libraries:movemesh3d}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id178}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{deplacement}
\label{\detokenize{references/external-libraries:deplacement}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id179}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{checkbemesh}
\label{\detokenize{references/external-libraries:checkbemesh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id180}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{buildlayers}
\label{\detokenize{references/external-libraries:id181}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id182}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{bcube}
\label{\detokenize{references/external-libraries:bcube}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id183}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{cube}
\label{\detokenize{references/external-libraries:cube}}
\sphinxAtStartPar
Construct a cubic mesh.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{n}{nnX}\PYG{p}{,} \PYG{n}{nnY}\PYG{p}{,} \PYG{n}{nnZ}\PYG{p}{,} \PYG{p}{[}\PYG{n}{X}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Y}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{Flags}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{Region}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Parameters:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nnX}} (\sphinxcode{\sphinxupquote{int}}) Number of discretization point along \(x\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nnY}} (\sphinxcode{\sphinxupquote{int}}) Number of discretization point along \(y\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nnZ}} (\sphinxcode{\sphinxupquote{int}}) Number of discretization point along \(z\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{X(x)}} (\sphinxcode{\sphinxupquote{func}}) \sphinxstyleemphasis{{[}Optional{]}} Affine function of \(x\) to define the length Default: \sphinxcode{\sphinxupquote{x}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Y(y)}} (\sphinxcode{\sphinxupquote{func}}) \sphinxstyleemphasis{{[}Optional{]}} Affine function of \(y\) to define the width Default: \sphinxcode{\sphinxupquote{y}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Z(z)}} (\sphinxcode{\sphinxupquote{func}}) \sphinxstyleemphasis{{[}Optional{]}} Affine function of \(z\) to define the height Default: \sphinxcode{\sphinxupquote{z}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{label=}} (\sphinxcode{\sphinxupquote{int{[}int{]}}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
List of surface labels Default: \sphinxcode{\sphinxupquote{{[}1, 2, 3, 4, 5, 6{]}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flags=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Refer to {\hyperref[\detokenize{references/functions:functionsquare}]{\sphinxcrossref{\DUrole{std,std-ref}{square}}}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region=}} (\sphinxcode{\sphinxupquote{int}}) \sphinxstyleemphasis{{[}Optional{]}}

\sphinxAtStartPar
Region number of the cube volume Default: \sphinxcode{\sphinxupquote{0}}

\end{itemize}

\sphinxAtStartPar
Output:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Th}} (\sphinxcode{\sphinxupquote{mesh3}}) Cube mesh

\end{itemize}


\subsubsection{trunc}
\label{\detokenize{references/external-libraries:trunc}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id184}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{gluemesh}
\label{\detokenize{references/external-libraries:gluemesh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id185}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{extract}
\label{\detokenize{references/external-libraries:extract}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id186}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{showborder}
\label{\detokenize{references/external-libraries:showborder}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id187}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{getborder}
\label{\detokenize{references/external-libraries:getborder}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id188}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{AddLayers}
\label{\detokenize{references/external-libraries:addlayers}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id189}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{mshmet}
\label{\detokenize{references/external-libraries:mshmet}}

\subsubsection{mshmet}
\label{\detokenize{references/external-libraries:id190}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id191}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{MUMPS}
\label{\detokenize{references/external-libraries:mumps}}

\subsubsection{defaulttoMUMPSseq}
\label{\detokenize{references/external-libraries:defaulttomumpsseq}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id192}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{MUMPS\_seq}
\label{\detokenize{references/external-libraries:mumps-seq}}

\subsubsection{defaulttoMUMPSseq}
\label{\detokenize{references/external-libraries:id193}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id194}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{netgen}
\label{\detokenize{references/external-libraries:netgen}}

\subsubsection{netg}
\label{\detokenize{references/external-libraries:netg}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id195}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{netgstl}
\label{\detokenize{references/external-libraries:netgstl}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id196}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{netgload}
\label{\detokenize{references/external-libraries:netgload}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id197}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{NewSolver}
\label{\detokenize{references/external-libraries:newsolver}}

\subsubsection{defaulttoUMFPACK}
\label{\detokenize{references/external-libraries:defaulttoumfpack}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id198}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{PARDISO}
\label{\detokenize{references/external-libraries:pardiso}}

\subsubsection{defaulttoPARDISO}
\label{\detokenize{references/external-libraries:defaulttopardiso}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id199}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{ompsetnumthreads}
\label{\detokenize{references/external-libraries:ompsetnumthreads}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id200}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{ompgetnumthreads}
\label{\detokenize{references/external-libraries:ompgetnumthreads}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id201}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{ompgetmaxthreads}
\label{\detokenize{references/external-libraries:ompgetmaxthreads}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id202}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{pcm2rnm}
\label{\detokenize{references/external-libraries:pcm2rnm}}

\subsubsection{readpcm}
\label{\detokenize{references/external-libraries:readpcm}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id203}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{pipe}
\label{\detokenize{references/external-libraries:pipe}}

\subsubsection{flush}
\label{\detokenize{references/external-libraries:flush}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id204}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{sleep}
\label{\detokenize{references/external-libraries:sleep}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id205}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{usleep}
\label{\detokenize{references/external-libraries:usleep}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id206}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{qf11to25}
\label{\detokenize{references/external-libraries:qf11to25}}

\subsubsection{QF1d}
\label{\detokenize{references/external-libraries:qf1d}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id207}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{QF2d}
\label{\detokenize{references/external-libraries:qf2d}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id208}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{QF3d}
\label{\detokenize{references/external-libraries:qf3d}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id209}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{tripleQF}
\label{\detokenize{references/external-libraries:tripleqf}}

\subsection{scotch}
\label{\detokenize{references/external-libraries:scotch}}

\subsubsection{scotch}
\label{\detokenize{references/external-libraries:id210}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id211}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{shell}
\label{\detokenize{references/external-libraries:shell}}

\subsubsection{readdir}
\label{\detokenize{references/external-libraries:readdir}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id212}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{unlink}
\label{\detokenize{references/external-libraries:unlink}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id213}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{rmdir}
\label{\detokenize{references/external-libraries:rmdir}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id214}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{cddir}
\label{\detokenize{references/external-libraries:cddir}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id215}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{chdir}
\label{\detokenize{references/external-libraries:chdir}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id216}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{basename}
\label{\detokenize{references/external-libraries:basename}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id217}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{dirname}
\label{\detokenize{references/external-libraries:dirname}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id218}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{mkdir}
\label{\detokenize{references/external-libraries:mkdir}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id219}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{chmod}
\label{\detokenize{references/external-libraries:chmod}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id220}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{cpfile}
\label{\detokenize{references/external-libraries:cpfile}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id221}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{stat}
\label{\detokenize{references/external-libraries:stat}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id222}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{isdir}
\label{\detokenize{references/external-libraries:isdir}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id223}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{getenv}
\label{\detokenize{references/external-libraries:getenv}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id224}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{setenv}
\label{\detokenize{references/external-libraries:setenv}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id225}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{unsetenv}
\label{\detokenize{references/external-libraries:unsetenv}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id226}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{splitedges}
\label{\detokenize{references/external-libraries:splitedges}}

\subsubsection{SplitedgeMesh}
\label{\detokenize{references/external-libraries:splitedgemesh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id227}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{splitmesh12}
\label{\detokenize{references/external-libraries:splitmesh12}}

\subsubsection{splitmesh12}
\label{\detokenize{references/external-libraries:id228}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id229}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{splitmesh3}
\label{\detokenize{references/external-libraries:splitmesh3}}

\subsubsection{splitmesh3}
\label{\detokenize{references/external-libraries:id230}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id231}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{splitmesh4}
\label{\detokenize{references/external-libraries:splitmesh4}}

\subsubsection{splimesh4}
\label{\detokenize{references/external-libraries:splimesh4}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id232}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{splitmesh6}
\label{\detokenize{references/external-libraries:splitmesh6}}

\subsubsection{splitmesh6}
\label{\detokenize{references/external-libraries:id233}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id234}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{SuperLu}
\label{\detokenize{references/external-libraries:superlu}}

\subsubsection{defaulttoSuperLu}
\label{\detokenize{references/external-libraries:defaulttosuperlu}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id235}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{symmetrizeCSR}
\label{\detokenize{references/external-libraries:symmetrizecsr}}

\subsubsection{symmetrizeCSR}
\label{\detokenize{references/external-libraries:id236}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id237}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{tetgen}
\label{\detokenize{references/external-libraries:tetgen}}
\sphinxAtStartPar
Refer to the \sphinxhref{http://wias-berlin.de/software/tetgen/}{Tetgen documentation} for more informations.


\subsubsection{tetgconvexhull}
\label{\detokenize{references/external-libraries:tetgconvexhull}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id238}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{tetgtransfo}
\label{\detokenize{references/external-libraries:tetgtransfo}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id239}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{tetg}
\label{\detokenize{references/external-libraries:tetg}}
\sphinxAtStartPar
Build a 3D mesh from a surface.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{RefTet}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{Label}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{Switch}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbofholes}\PYG{o}{=}\PYG{n}{NbOfHoles}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{holelist}\PYG{o}{=}\PYG{n}{HoleList}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{n}{NbOfRegions}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{RegionList}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{nboffacetcl}\PYG{o}{=}\PYG{n}{NbOfFaceTcl}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{k+kp}{facetcl}\PYG{o}{=}\PYG{n}{FaceTcl}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id240}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{tetgreconstruction}
\label{\detokenize{references/external-libraries:tetgreconstruction}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id241}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{UMFPACK64}
\label{\detokenize{references/external-libraries:umfpack64}}

\subsubsection{defaulttoUMFPACK64}
\label{\detokenize{references/external-libraries:defaulttoumfpack64}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id242}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{VTK\_writer\_3d}
\label{\detokenize{references/external-libraries:vtk-writer-3d}}

\subsubsection{Vtkaddmesh}
\label{\detokenize{references/external-libraries:vtkaddmesh}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id243}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Vtkaddscalar}
\label{\detokenize{references/external-libraries:vtkaddscalar}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id244}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{VTK\_writer}
\label{\detokenize{references/external-libraries:vtk-writer}}

\subsubsection{Vtkaddmesh}
\label{\detokenize{references/external-libraries:id245}}
\begin{sphinxadmonition}{note}{\label{\detokenize{references/external-libraries:id246}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsubsection{Vtkaddscalar}
\label{\detokenize{references/external-libraries:id247}}

\chapter{Mathematical Models}
\label{\detokenize{models/index:mathematical-models}}\label{\detokenize{models/index::doc}}
\sphinxAtStartPar
\sphinxstyleemphasis{Summary}:

\sphinxAtStartPar
This chapter goes deeper into a number of problems that \sphinxstylestrong{FreeFEM} can solve.
It is a complement to the {\hyperref[\detokenize{tutorials/index:tutorial}]{\sphinxcrossref{\DUrole{std,std-ref}{Tutorial part}}}} which was only an introduction.

\sphinxAtStartPar
\sphinxstylestrong{Users are invited to contribute to make this models database grow.}


\section{Static problems}
\label{\detokenize{models/static-problems:static-problems}}\label{\detokenize{models/static-problems::doc}}

\subsection{Soap Film}
\label{\detokenize{models/static-problems:soap-film}}\label{\detokenize{models/static-problems:modelstatissoap}}
\sphinxAtStartPar
Our starting point here will be the mathematical model to find the shape of \sphinxstylestrong{soap film} which is glued to the ring on the \(xy-\)plane:
\begin{equation*}
\begin{split}C=\{(x,y);\;x=\cos t,\,y=\sin t,\,0\leq t\leq 2\pi \}\end{split}
\end{equation*}
\sphinxAtStartPar
We assume the shape of the film is described by the graph \((x,y,u(x,y))\) of the vertical displacement \(u(x,y)\, (x^2+y^2<1)\) under a vertical pressure \(p\) in terms of force per unit area and an initial tension \(\mu\) in terms of force per unit length.

\sphinxAtStartPar
Consider the “small plane” ABCD, A:\((x,y,u(x,y))\), B:\((x,y,u(x+\delta x,y))\), C:\((x,y,u(x+\delta x,y+\delta y))\) and D:\((x,y,u(x,y+\delta y))\).

\sphinxAtStartPar
Denote by \(\vec{n}(x,y)=(n_x(x,y),n_y(x,y),n_z(x,y))\) the normal vector of the surface \(z=u(x,y)\).
We see that the vertical force due to the tension \(\mu\) acting along the edge AD is \(-\mu n_x(x,y)\delta y\) and the the vertical force acting along the edge AD is:
\begin{equation*}
\begin{split}\mu n_x(x+\delta x,y)\delta y\simeq \mu\left(n_x(x,y)+\frac{\p n_x}{\p x}\delta x\right)(x,y)\delta y\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=0.750\linewidth]{{StaticProblems_SoapFilm}.png}
\end{figure}

\sphinxAtStartPar
Similarly, for the edges AB and DC we have:
\begin{equation*}
\begin{split}-\mu n_y(x,y)\delta x,\quad\mu\left(n_y(x,y)+\p n_y/\p y\right)(x,y)\delta x\end{split}
\end{equation*}
\sphinxAtStartPar
The force in the vertical direction on the surface ABCD due to the tension \(\mu\) is given by:
\begin{equation*}
\begin{split}\mu\left(\p n_x/\p x\right)\delta x\delta y+T\left(\p n_y/\p y\right)\delta y\delta x\end{split}
\end{equation*}
\sphinxAtStartPar
Assuming small displacements, we have:
\begin{equation*}
\begin{split}\begin{array}{rcccl}
    \nu_x&=&(\p u/\p x)/\sqrt{1+(\p u/\p x)^2+(\p u/\p y)^2}&\simeq& \p u/\p x,\\
    \nu_y&=&(\p u/\p y)/\sqrt{1+(\p u/\p x)^2+(\p u/\p y)^2}&\simeq& \p u/\p y
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Letting \(\delta x\to dx,\, \delta y\to dy\), we have the equilibrium of the vertical displacement of soap film on ABCD by \(p\):
\begin{equation*}
\begin{split}\mu dx dy\p^2 u/\p x^2 +\mu dx dy\p^2 u/\p y^2 + p dx dy = 0\end{split}
\end{equation*}
\sphinxAtStartPar
Using the Laplace operator \(\Delta = \p^2 /\p x^2 + \p^2 /\p y^2\), we can find the virtual displacement write the following:
\begin{equation*}
\begin{split}-\Delta u = f\quad \mbox{in }\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
where \(f=p/\mu\), \(\Omega =\{(x,y);\;x^{2}+y^{2}<1\}\).

\sphinxAtStartPar
{\hyperref[\detokenize{tutorials/poisson:tutorialpoisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s equation}}}} appears also in \sphinxstylestrong{electrostatics} taking the form of \(f=\rho / \epsilon\) where \(\rho\) is the charge density, \(\epsilon\) the dielectric constant and \(u\) is named as electrostatic potential.

\sphinxAtStartPar
The soap film is glued to the ring \(\p \Omega =C\), then we have the boundary condition:
\begin{equation*}
\begin{split}u=0\quad \mbox{on }\p \Omega\end{split}
\end{equation*}
\sphinxAtStartPar
If the force is gravity, for simplify, we assume that \(f=-1\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{//ue: exact solution}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{disk} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{femp1}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{femp1} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//bilinear form}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//linear form}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//boundary condition}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{n}{femp1} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error H10 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{/// Re\PYGZhy{}run with a mesh adaptation ///}

\PYG{c+c1}{// Mesh adaptation}
\PYG{n}{disk} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;} \PYG{c+c1}{//become FE\PYGZhy{}function on adapted mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{error H10 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{disk}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_SoapFilmSol}.png}
\caption{Isovalue of \(u\)}\label{\detokenize{models/static-problems:examplestaticproblemssoapfilmsol}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{StaticProblems_SoapFilm3D}.png}
\caption{A side view of \(u\)}\label{\detokenize{models/static-problems:examplestaticproblemssoapfilm3d}}\end{figure}

\sphinxAtStartPar
In the 37th line, the \(L^2\)\sphinxhyphen{}error estimation between the exact solution \(u_e\),
\begin{equation*}
\begin{split}\|u_h - u_e\|_{0,\Omega}=\left(\int_{\Omega}|u_h-u_e|^2\, \d x\d y\right)^{1/2}\end{split}
\end{equation*}
\sphinxAtStartPar
and in the following line, the \(H^1\)\sphinxhyphen{}error seminorm estimation:
\begin{equation*}
\begin{split}|u_h - u_e|_{1,\Omega}=\left(\int_{\Omega}|\nabla u_h-\nabla u_e|^2\, \d x\d y\right)^{1/2}\end{split}
\end{equation*}
\sphinxAtStartPar
are done on the initial mesh.
The results are \(\|u_h - u_e\|_{0,\Omega}=0.000384045,\, |u_h - u_e|_{1,\Omega}=0.0375506\).

\sphinxAtStartPar
After the adaptation, we have \(\|u_h - u_e\|_{0,\Omega}=0.000109043,\, |u_h - u_e|_{1,\Omega}=0.0188411\).
So the numerical solution is improved by adaptation of mesh.


\subsection{Electrostatics}
\label{\detokenize{models/static-problems:electrostatics}}
\sphinxAtStartPar
We assume that there is no current and a time independent charge distribution.
Then the electric field \(\mathbf{E}\) satisfies:
\begin{equation}\label{equation:models/static-problems:eqn::Maxwell}
\begin{split}\begin{array}{rcl}
    \mathrm{div}\mathbf{E} &=& \rho/\epsilon\\
    \mathrm{curl}\mathbf{E} &=& 0
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
where \(\rho\) is the charge density and \(\epsilon\) is called the permittivity of free space.

\sphinxAtStartPar
From the equation \eqref{equation:models/static-problems:eqn::Maxwell} We can introduce the electrostatic potential such that \(\mathbf{E}=-\nabla \phi\).
Then we have Poisson’s equation \(-\Delta \phi=f\), \(f=-\rho/\epsilon\).

\sphinxAtStartPar
We now obtain the equipotential line which is the level curve of \(\phi\), when there are no charges except conductors \(\{C_i\}_{1,\cdots,K}\).
Let us assume \(K\) conductors \(C_1,\cdots,C_K\) within an enclosure \(C_0\).

\sphinxAtStartPar
Each one is held at an electrostatic potential \(\varphi_i\).
We assume that the enclosure \(C0\) is held at potential 0.
In order to know \(\varphi(x)\) at any point \(x\) of the domain \(\Omega\), we must solve:
\begin{equation*}
\begin{split}-\Delta \varphi =0\quad \textrm{ in }\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Omega\) is the interior of \(C_0\) minus the conductors \(C_i\), and \(\Gamma\) is the boundary of \(\Omega\), that is \(\sum_{i=0}^N C_i\).

\sphinxAtStartPar
Here \(g\) is any function of \(x\) equal to \(\varphi_i\) on \(C_i\) and to 0 on \(C_0\).
The boundary equation is a reduced form for:
\begin{equation*}
\begin{split}\varphi =\varphi_{i}\;\text{on }C_{i},\;i=1...N,\varphi =0\;\text{on }C_{0}.\end{split}
\end{equation*}
\sphinxAtStartPar
First we give the geometrical informations; \(C_0=\{(x,y);\; x^2+y^2=5^2\}\), \(C_1=\{(x,y):\;\frac{1}{0.3^2}(x-2)^2+\frac{1}{3^2}y^2=1\}\), \(C_2=\{(x,y):\; \frac{1}{0.3^2}(x+2)^2+\frac{1}{3^2}y^2=1\}\).

\sphinxAtStartPar
Let \(\Omega\) be the disk enclosed by \(C_0\) with the elliptical holes enclosed by \(C_1\) and \(C_2\).
Note that \(C_0\) is described counterclockwise, whereas the elliptical holes are described clockwise, because the boundary must be oriented so that the computational domain is to its left.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C0}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Electro} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//bilinear}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+c1}{//boundary condition on C\PYGZus{}0}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{//+1 volt on C\PYGZus{}1}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{//\PYGZhy{}1 volt on C\PYGZus{}2}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Electro}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_ElectrostaticsMesh}.png}
\caption{Disk with two elliptical holes}\label{\detokenize{models/static-problems:examplestaticproblemselectrostaticsmesh}}\label{\detokenize{models/static-problems:figdiskwithholes}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_Electrostatics}.png}
\caption{Equipotential lines where \(C_1\) is located in right hand side}\label{\detokenize{models/static-problems:examplestaticproblemselectrostatics}}\label{\detokenize{models/static-problems:figdiskwithlines}}\end{subfigure}


\end{figure}



\subsection{Aerodynamics}
\label{\detokenize{models/static-problems:aerodynamics}}\label{\detokenize{models/static-problems:DiskWithHoles}}
\sphinxAtStartPar
Let us consider a wing profile \(S\) in a uniform flow.
Infinity will be represented by a large circle \(\Gamma_{\infty}\).
As previously, we must solve:
\begin{equation}\label{equation:models/static-problems:eqn:NACA-5-5}
\begin{split}\Delta \varphi=0\quad\textrm{in }\Omega,
\quad \varphi|_S=c,\quad
\varphi|_{\Gamma_{\infty}}=u_{\infty 1x}-u_{\infty2x}\end{split}
\end{equation}
\sphinxAtStartPar
where \(\Omega\) is the area occupied by the fluid, \(u_{\infty}\) is the air speed at infinity, \(c\) is a constant to be determined so that \(\p_n\varphi\) is continuous at the trailing edge \(P\) of \(S\) (so\sphinxhyphen{}called Kutta\sphinxhyphen{}Joukowski condition).
Lift is proportional to \(c\).

\sphinxAtStartPar
To find \(c\) we use a superposition method.
As all equations in \eqref{equation:models/static-problems:eqn:NACA-5-5} are linear, the solution \(\varphi_c\) is a linear function of \(c\)
\begin{equation*}
\begin{split}\varphi_c = \varphi_0 + c\varphi_1\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\varphi_0\) is a solution of \eqref{equation:models/static-problems:eqn:NACA-5-5} with \(c = 0\) and \(\varphi_1\) is a solution with \(c = 1\) and zero speed at infinity.

\sphinxAtStartPar
With these two fields computed, we shall determine \(c\) by requiring the continuity of \(\p \varphi /\p n\) at the trailing edge.
An equation for the upper surface of a NACA0012 (this is a classical wing profile in aerodynamics; the rear of the wing is called the trailing edge) is:
\begin{equation*}
\begin{split}y = 0.17735\sqrt{x} - 0.075597x - 0.212836x^2 + 0.17363x^3 - 0.06254x^4\end{split}
\end{equation*}
\sphinxAtStartPar
Taking an incidence angle \(\alpha\) such that \(\tan \alpha = 0.1\), we must solve:
\begin{equation*}
\begin{split}-\Delta\varphi = 0\qquad \textrm{in }\Omega, \quad \varphi|_{\Gamma_1} = y - 0.1x,\quad \varphi |_{\Gamma_2} = c\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Gamma_2\) is the wing profile and \(\Gamma_1\) is an approximation of infinity.
One finds \(c\) by solving:
\begin{equation*}
\begin{split}\begin{array}{ccccccc}
    -\Delta\varphi_0 &= 0 &\textrm{in }\Omega&,\qquad \varphi_0|_{\Gamma_1} &= y - 0.1x&, \quad \varphi_0|_{\Gamma_2} &= 0,\\
    -\Delta\varphi_1 &= 0 &\textrm{in }\Omega&, \qquad \varphi_1|_{\Gamma_1} &= 0&, \quad \varphi_1|_{\Gamma_2} &= 1
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The solution \(\varphi = \varphi_0+c\varphi_1\) allows us to find \(c\) by writing that \(\p_n\varphi\) has no jump at the trailing edge \(P = (1, 0)\).

\sphinxAtStartPar
We have \(\p n\varphi -(\varphi (P^+)-\varphi (P))/\delta\) where \(P^+\) is the point just above \(P\) in the direction normal to the profile at a distance \(\delta\).
Thus the jump of \(\p_n\varphi\) is \((\varphi_0|_{P^+} +c(\varphi_1|_{P^+} -1))+(\varphi_0|_{P^-} +c(\varphi_1|_{P^-} -1))\) divided by \(\delta\) because the normal changes sign between the lower and upper surfaces. Thus
\begin{equation*}
\begin{split}c = -\frac{\varphi_0|_{P^+} + \varphi_0|_{P^-}}
{(\varphi_1|_{P^+} + \varphi_1|_{P^-} - 2)} ,\end{split}
\end{equation*}
\sphinxAtStartPar
which can be programmed as:
\begin{equation*}
\begin{split}c = -\frac{\varphi_0(0.99, 0.01) + \varphi_0(0.99,-0.01)}
{(\varphi_1(0.99, 0.01) + \varphi_1(0.99,-0.01) - 2)} .\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{upper}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{lower}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{l+m+mf}{0.17735}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.075597}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.212836}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.17363}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.06254}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Zoom} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{o}{+} \PYG{n}{upper}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lower}\PYG{p}{(}\PYG{l+m+mi}{35}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{psi0}\PYG{p}{,} \PYG{n}{psi1}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{ZVh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Joukowski0}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{psi0}\PYG{o}{=}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{upper}\PYG{p}{,} \PYG{n}{lower}\PYG{p}{,} \PYG{n}{psi0}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{Joukowski1}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{psi1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{upper}\PYG{p}{,} \PYG{n}{lower}\PYG{p}{,} \PYG{n}{psi1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//continuity of pressure at trailing edge}
\PYG{k+kt}{real} \PYG{n}{beta} \PYG{o}{=} \PYG{n}{psi0}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)} \PYG{o}{+} \PYG{n}{psi0}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{beta} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{beta} \PYG{o}{/} \PYG{p}{(}\PYG{n}{psi1}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{l+m+mf}{0.01}\PYG{p}{)} \PYG{o}{+} \PYG{n}{psi1}\PYG{p}{(}\PYG{l+m+mf}{0.99}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh} \PYG{n}{psi} \PYG{o}{=} \PYG{n}{beta}\PYG{o}{*}\PYG{n}{psi1} \PYG{o}{+} \PYG{n}{psi0}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ZVh} \PYG{n}{Zpsi} \PYG{o}{=} \PYG{n}{psi}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zpsi}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ZVh} \PYG{n}{cp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{cp}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ZVh} \PYG{n}{Zcp} \PYG{o}{=} \PYG{n}{cp}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zcp}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_Aerodynamics1}.png}
\caption{Isovalue of \(cp = -(\p_x\psi)^2 - (\p_y\psi)^2\)}\label{\detokenize{models/static-problems:examplestaticproblemsaerodynamics1}}\label{\detokenize{models/static-problems:figisovalueofcp}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_Aerodynamics2}.png}
\caption{Zooming of \(cp\)}\label{\detokenize{models/static-problems:examplestaticproblemsaerodynamics2}}\label{\detokenize{models/static-problems:figzoomingofcp}}\end{subfigure}


\end{figure}



\subsection{Error estimation}
\label{\detokenize{models/static-problems:error-estimation}}\label{\detokenize{models/static-problems:IsovalueOfCp}}
\sphinxAtStartPar
There are famous estimation between the numerical result \(u_h\) and the exact solution \(u\) of the {\hyperref[\detokenize{tutorials/poisson:tutorialpoisson}]{\sphinxcrossref{\DUrole{std,std-ref}{Poisson’s problem}}}}:

\sphinxAtStartPar
If triangulations \(\{\mathcal{T}_h\}_{h\downarrow 0}\) is regular (see {\hyperref[\detokenize{documentation/mesh-generation:meshregulartriangulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular Triangulation}}}}), then we have the estimates:
\begin{equation}\label{equation:models/static-problems:eqn::ErrorEstimatation}
\begin{split}\begin{array}{rcl}
    |\nabla u - \nabla u_h|_{0,\Omega} &\le& C_1h \\
    \|u - u_h\|_{0,\Omega} &\le& C_2h^2
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
with constants \(C_1,\, C_2\) independent of \(h\), if \(u\) is in \(H^2(\Omega)\).
It is known that \(u\in H^2(\Omega)\) if \(\Omega\) is convex.

\sphinxAtStartPar
In this section we check \eqref{equation:models/static-problems:eqn::ErrorEstimatation}.
We will pick up numericall error if we use the numerical derivative, so we will use the following for \eqref{equation:models/static-problems:eqn::ErrorEstimatation}.
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \int_{\Omega}|\nabla u - \nabla u_h|^2\, \d x\d y &=&\int_{\Omega}\nabla u\cdot \nabla(u - 2u_h)\, \d x\d y+ \int_{\Omega}\nabla u_h\cdot \nabla u_h\, \d x\d y\\
    &=&\int_{\Omega}f(u-2u_h)\, \d x\d y+\int_{\Omega}fu_h\, \d x\d y
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The constants \(C_1,\, C_2\) are depend on \(\mathcal{T}_h\) and \(f\), so we will find them by \sphinxstylestrong{FreeFEM}.

\sphinxAtStartPar
In general, we cannot get the solution \(u\) as a elementary functions even if spetical functions are added.
Instead of the exact solution, here we use the approximate solution \(u_0\) in \(V_h(\mathcal{T}_h,P_2),\, h\sim 0\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{//Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{V0h}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson0} \PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v0}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u0}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{errL2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{errH1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{o}{+}\PYG{n}{i}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;} \PYG{c+c1}{//get the size of all triangles}

    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{solve} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
            \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{V0h} \PYG{n}{uu} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//interpolate solution on first mesh}
    \PYG{n}{errL2}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uu} \PYG{o}{\PYGZhy{}} \PYG{n}{u0}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{errH1}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u0} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{uu} \PYG{o}{+} \PYG{n}{uu}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{errL2}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{errL2}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{errH1}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{errH1}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can guess that \(C_1=0.0179253(0.0173266)\) and \(C_2=0.0729566(0.0707543)\), where the numbers inside the parentheses are minimum in calculation.


\subsection{Periodic Boundary Conditions}
\label{\detokenize{models/static-problems:periodic-boundary-conditions}}
\sphinxAtStartPar
We now solve the Poisson equation:
\begin{equation*}
\begin{split}-\Delta u = sin(x+\pi/4.)*cos(y+\pi/4.)\end{split}
\end{equation*}
\sphinxAtStartPar
on the square \(]0,2\pi[^2\) under bi\sphinxhyphen{}periodic boundary condition \(u(0,y)=u(2\pi,y)\) for all \(y\) and \(u(x,0)=u(x,2\pi)\) for all \(x\).

\sphinxAtStartPar
These boundary conditions are achieved from the definition of the periodic finite element space.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//right hand side}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{c+c1}{//defined the fespace with periodic condition}
\PYG{c+c1}{//label: 2 and 4 are left and right side with y the curve abscissa}
\PYG{c+c1}{//       1 and 2 are bottom and upper side with x the curve abscissa}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_PeriodicBoundaryConditions}.png}
\caption{The isovalue of solution \(u\) with periodic boundary condition}\label{\detokenize{models/static-problems:examplestaticproblemsperiodicboundaryconditions}}\end{figure}

\sphinxAtStartPar
The periodic condition does not necessarily require parallel boundaries.
The following example give such example.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Periodic boundary conditions \sphinxhyphen{} non\sphinxhyphen{}parallel boundaries

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r2} \PYG{o}{=} \PYG{l+m+mf}{1.732}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{c+c1}{//warning for periodic condition:}
\PYG{c+c1}{//side a and c}
\PYG{c+c1}{//on side a (label 1) \PYGZdl{} x \PYGZbs{}in [0,1] \PYGZdl{} or \PYGZdl{} x\PYGZhy{}y\PYGZbs{}in [\PYGZhy{}1,1] \PYGZdl{}}
\PYG{c+c1}{//on side c (label 3) \PYGZdl{} x \PYGZbs{}in [\PYGZhy{}1,0]\PYGZdl{} or \PYGZdl{} x\PYGZhy{}y\PYGZbs{}in[\PYGZhy{}1,1] \PYGZdl{}}
\PYG{c+c1}{//so the common abscissa can be respectively \PYGZdl{}x\PYGZdl{} and \PYGZdl{}x+1\PYGZdl{}}
\PYG{c+c1}{//or you can can try curviline abscissa \PYGZdl{}x\PYGZhy{}y\PYGZdl{} and \PYGZdl{}x\PYGZhy{}y\PYGZdl{}}
\PYG{c+c1}{//1 first way}
\PYG{c+c1}{//fespace Vh(Th, P2, periodic=[[2, 1+x], [4, x], [1, x], [3, 1+x]]);}
\PYG{c+c1}{//2 second way}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{intf} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mTh} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{k} \PYG{o}{=}  \PYG{n}{intf} \PYG{o}{/} \PYG{n}{mTh}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{n}{f}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplace}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_PeriodicBoundaryConditions2}.png}
\caption{The isovalue of solution \(u\) for \(\Delta u = ((y+x)^{2}+1)((y-x)^{2}+1) - k\), in \(\Omega\) and \(\p_{n} u =0\) on hole, and with two periodic boundary condition on external border}\label{\detokenize{models/static-problems:examplestaticproblemsperiodicboundaryconditions2}}\end{figure}
\end{sphinxadmonition}

\sphinxAtStartPar
An other example with no equal border, just to see if the code works.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Periodic boundary conditions \sphinxhyphen{} non\sphinxhyphen{}equal border

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro}
\PYG{c+c1}{//irregular boundary condition to build border AB}
\PYG{k+kt}{macro} \PYG{n+nf}{LINEBORDER}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{lab}\PYG{p}{)}
    \PYG{k+kt}{border} \PYG{k+kp}{A}\PYG{o}{\PYGZsh{}}\PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real} \PYG{n}{t1}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{A}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{t1}\PYG{o}{+}\PYG{k+kp}{B}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{A}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{t1}\PYG{o}{+}\PYG{k+kp}{B}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}
    \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{lab}\PYG{p}{;} \PYG{p}{\PYGZcb{}} \PYG{c+c1}{//EOM}
\PYG{c+c1}{// compute \PYGZbs{}||AB|\PYGZbs{}| A=(ax,ay) et B =(bx,by)}
\PYG{k+kt}{macro} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{,} \PYG{n}{ay}\PYG{p}{,} \PYG{n}{bx}\PYG{p}{,} \PYG{n}{by}\PYG{p}{)}
    \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ax}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{bx}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ay}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{by}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//EOM}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//EOM}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Ax} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{n}{Ay} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Bx} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{By} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Cx} \PYG{o}{=} \PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{n}{Cy} \PYG{o}{=} \PYG{l+m+mf}{2.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Dx} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{Dy} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gx} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Ax}\PYG{o}{+}\PYG{n}{Bx}\PYG{o}{+}\PYG{n}{Cx}\PYG{o}{+}\PYG{n}{Dx}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{Ay}\PYG{o}{+}\PYG{n}{By}\PYG{o}{+}\PYG{n}{Cy}\PYG{o}{+}\PYG{n}{Dy}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{4.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,}\PYG{k+kp}{B}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{k+kp}{B}\PYG{p}{,}\PYG{n}{C}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{n}{C}\PYG{p}{,}\PYG{n}{D}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{LINEBORDER}\PYG{p}{(}\PYG{n}{D}\PYG{p}{,}\PYG{k+kp}{A}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{k+kt}{mesh} \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{AB}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{BC}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{CD}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{o}{+}\PYG{n}{DA}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,}\PYG{k+kp}{fixedborder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{real} \PYG{k+kr}{l1} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Ax}\PYG{p}{,}\PYG{n}{Ay}\PYG{p}{,}\PYG{n}{Bx}\PYG{p}{,}\PYG{n}{By}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{l2} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Bx}\PYG{p}{,}\PYG{n}{By}\PYG{p}{,}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{Cy}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l3} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{Cy}\PYG{p}{,}\PYG{n}{Dx}\PYG{p}{,}\PYG{n}{Dy}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l4} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Dx}\PYG{p}{,}\PYG{n}{Dy}\PYG{p}{,}\PYG{n}{Ax}\PYG{p}{,}\PYG{n}{Ay}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{s1} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Ax}\PYG{p}{,}\PYG{n}{Ay}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{l1}\PYG{p}{;} \PYG{c+c1}{//absisse on AB = ||AX||/||AB||}
\PYG{k+kt}{func} \PYG{n}{s2} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Bx}\PYG{p}{,}\PYG{n}{By}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{l2}\PYG{p}{;} \PYG{c+c1}{//absisse on BC = ||BX||/||BC||}
\PYG{k+kt}{func} \PYG{n}{s3} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Cx}\PYG{p}{,}\PYG{n}{Cy}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{n}{l3}\PYG{p}{;} \PYG{c+c1}{//absisse on CD = ||CX||/||CD||}
\PYG{k+kt}{func} \PYG{n}{s4} \PYG{o}{=} \PYG{n+nf}{dist}\PYG{p}{(}\PYG{n}{Dx}\PYG{p}{,}\PYG{n}{Dy}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{n}{l4}\PYG{p}{;} \PYG{c+c1}{//absisse on DA = ||DX||/||DA||}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{c+c1}{//to see the abscisse value of the periodic condition}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{s4}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//reset verbosity}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{cc} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{cc} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{gx}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{gy}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cc}\PYG{p}{)}\PYG{o}{/}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{compatibility = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{gx}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{gy}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cc}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{gx}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{gy}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cc}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Periodic boundry conditions \sphinxhyphen{} Poisson cube\sphinxhyphen{}balloon

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}} \PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hs} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{c+c1}{//mesh size on sphere}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kr}{N} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{L} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{z0} \PYG{o}{=} \PYG{l+m+mo}{06}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{+}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{+}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{+}\PYG{n}{z0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{bool} \PYG{n}{buildTh} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th}\PYG{p}{;}
\PYG{k}{try} \PYG{p}{\PYGZob{}} \PYG{c+c1}{//a way to build one time the mesh or read it if the file exist}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{readmesh3}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZhy{}hex\PYGZhy{}sph.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{buildTh} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{buildTh}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MeshSurface.idp}\PYG{l+s}{\PYGZdq{}}

    \PYG{c+c1}{// Surface Mesh}
    \PYG{k+kt}{mesh3} \PYG{n}{ThH} \PYG{o}{=} \PYG{n}{SurfaceHex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{mesh3} \PYG{n}{ThS} \PYG{o}{=} \PYG{n}{Sphere}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{hs}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{mesh3} \PYG{n}{ThHS} \PYG{o}{=} \PYG{n}{ThH} \PYG{o}{+} \PYG{n}{ThS}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{voltet} \PYG{o}{=} \PYG{p}{(}\PYG{n}{hs}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{voltet}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{tetg}\PYG{p}{(}\PYG{n}{ThHS}\PYG{p}{,} \PYG{k+kp}{switch}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pqaAAYYQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th\PYGZhy{}hex\PYGZhy{}sph.mesh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{reg} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ centre = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ exterieur = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,}\PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// EOM}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{vh}\PYG{o}{*}\PYG{n}{f}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Poisson}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_PeriodicBoundaryConditionsPoisson1}.png}
\caption{View of the surface isovalue of periodic solution \(uh\)}\label{\detokenize{models/static-problems:examplestaticproblemsperiodicboundaryconditionspoisson1}}\label{\detokenize{models/static-problems:figcubeballoon}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_PeriodicBoundaryConditionsPoisson2}.png}
\caption{View a the cut of the solution \(uh\) with ffmedit}\label{\detokenize{models/static-problems:examplestaticproblemsperiodicboundaryconditionspoisson2}}\end{subfigure}


\end{figure}

\end{sphinxadmonition}


\subsection{Poisson Problems with mixed boundary condition}
\label{\detokenize{models/static-problems:poisson-problems-with-mixed-boundary-condition}}\label{\detokenize{models/static-problems:modelstaticpoissonwithmixedboundarycondition}}\label{\detokenize{models/static-problems:CubeBalloon}}
\sphinxAtStartPar
Here we consider the Poisson equation with mixed boundary conditions:

\sphinxAtStartPar
For given functions \(f\) and \(g\), find \(u\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta u &=& f & \textrm{ in }\Omega\\
    u &=& g &\textrm{ on }\Gamma_D\\
    \p u/\p n &=& 0 &\textrm{ on }\Gamma_N
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Gamma_D\) is a part of the boundary \(\Gamma\) and \(\Gamma_N=\Gamma\setminus \overline{\Gamma_D}\).

\sphinxAtStartPar
The solution \(u\) has the singularity at the points \(\{\gamma_1,\gamma_2\}=\overline{\Gamma_D}\cap\overline{\Gamma_N}\).

\sphinxAtStartPar
When \(\Omega=\{(x,y);\; -1<x<1,\, 0<y<1\}\), \(\Gamma_N=\{(x,y);\; -1\le x<0,\, y=0\}\), \(\Gamma_D=\p \Omega\setminus \Gamma_N\), the singularity will appear at \(\gamma_1=(0,0),\, \gamma_2(-1,0)\), and \(u\) has the expression:
\begin{equation*}
\begin{split}u=K_iu_S + u_R,\, u_R\in H^2(\textrm{near }\gamma_i),\, i=1,2\end{split}
\end{equation*}
\sphinxAtStartPar
with a constants \(K_i\).

\sphinxAtStartPar
Here \(u_S = r_j^{1/2}\sin(\theta_j/2)\) by the local polar coordinate \((r_j,\theta_j\) at \(\gamma_j\) such that \((r_1,\theta_1)=(r,\theta)\).

\sphinxAtStartPar
Instead of polar coordinate system \((r,\theta)\), we use that \(r\) = \sphinxcode{\sphinxupquote{sqrt}} (\(x^2+y^2\)) and \(\theta\) = \sphinxcode{\sphinxupquote{atan2}} (\(y,x\)) in \sphinxstylestrong{FreeFEM}.

\sphinxAtStartPar
Assume that \(f=-2\times 30(x^2+y^2)\) and \(g=u_e=10(x^2+y^2)^{1/4}\sin\left([\tan^{-1}(y/x)]/2\right)+30(x^2y^2)\), where \(u_e\)S is the exact solution.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{30}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//given function}
\PYG{c+c1}{//the singular term of the solution is K*us (K: constant)}
\PYG{k+kt}{func} \PYG{n}{us} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{,}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mf}{10.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{n}{K}\PYG{o}{*}\PYG{n}{us} \PYG{o}{+} \PYG{l+m+mi}{30}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{k+kr}{N}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{D4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{T0h} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D2}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D3}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{D4}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{V0h}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{V0h} \PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{;}

\PYG{c+c1}{//Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson0} \PYG{p}{(}\PYG{n}{u0}\PYG{p}{,} \PYG{n}{v0}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u0}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v0}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u0}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation by the singular term}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{T0h}\PYG{p}{,} \PYG{n}{us}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{us}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error in H1 norm}
\PYG{n}{Vh} \PYG{n}{uue} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H1e} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uue}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uue}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{uue}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{err0} \PYG{o}{=} \PYG{n}{u0} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;}
\PYG{n}{Vh} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{ue}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{H1err0} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{err0}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{err0}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{err0}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{H1err} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kp}{err}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Relative error in first mesh = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{H1err0}\PYG{p}{)}\PYG{o}{/}\PYG{n}{H1e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Relative error in adaptive mesh = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{H1err}\PYG{p}{)}\PYG{o}{/}\PYG{n}{H1e} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
From line 35 to 37, mesh adaptations are done using the base of singular term.

\sphinxAtStartPar
In line 61, \sphinxcode{\sphinxupquote{H1e}} = \(|u_e|_{1,\Omega}\) is calculated.

\sphinxAtStartPar
In lines 64 and 65, the relative errors are calculated, that is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \|u^0_h-u_e\|_{1,\Omega}/H1e&=&0.120421\\
    \|u^a_h-u_e\|_{1,\Omega}/H1e&=&0.0150581
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(u^0_h\) is the numerical solution in \sphinxcode{\sphinxupquote{T0h}} and \(u^a_h\) is \sphinxcode{\sphinxupquote{u}} in this program.


\subsection{Poisson with mixed finite element}
\label{\detokenize{models/static-problems:poisson-with-mixed-finite-element}}
\sphinxAtStartPar
Here we consider the Poisson equation with mixed boundary value problems:

\sphinxAtStartPar
For given functions \(f\) , \(g_d\), \(g_n\), find \(p\) such that
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta p &=& 1 & \textrm{ in }\Omega\\
    p &=& g_d & \textrm{ on }\Gamma_D\\
    \p p/\p n &=& g_n & \textrm{ on }\Gamma_N
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Gamma_D\) is a part of the boundary \(\Gamma\) and \(\Gamma_N=\Gamma\setminus \overline{\Gamma_D}\).

\sphinxAtStartPar
The mixed formulation is: find \(p\) and \(\mathbf{u}\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \nabla p + \mathbf{u} &=& \mathbf{0} & \textrm{ in }\Omega\\
    \nabla. \mathbf{u} &=& f & \textrm{ in }\Omega\\
    p &=& g_d & \textrm{ on }\Gamma_D\\
    \p u. n &=& \mathbf{g}_n.n & \textrm{ on }\Gamma_N
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathbf{g}_n\) is a vector such that \(\mathbf{g}_n.n = g_n\).

\sphinxAtStartPar
The variational formulation is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \forall \mathbf{v} \in \mathbb{V}_0: & \int_\Omega p \nabla.v + \mathbf{v} \mathbf{v} &= \int_{\Gamma_d} g_d \mathbf{v}.n\\
    \forall {q} \in \mathbb{P}: & \int_\Omega q \nabla.u &= \int_\Omega q f\nonumber\\
    & \p u. n &= \mathbf{g}_n.n \quad \textrm{on }\Gamma_N
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where the functional space are:
\begin{equation*}
\begin{split}\mathbb{P}= L^2(\Omega),
\qquad\mathbb{V}= H(div)=\{\mathbf{v}\in L^2(\Omega)^2,\nabla.\mathbf{v}\in L^2(\Omega)\}\end{split}
\end{equation*}
\sphinxAtStartPar
and:
\begin{equation*}
\begin{split}\mathbb{V}_0 = \{\mathbf{v}\in \mathbb{V};\quad\mathbf{v}. n = 0 \quad\mathrm{on }\;\;\Gamma_N\}\end{split}
\end{equation*}
\sphinxAtStartPar
To write the \sphinxstylestrong{FreeFEM} example, we have just to choose the finites elements spaces.

\sphinxAtStartPar
Here \(\mathbb{V}\) space is discretize with Raviart\sphinxhyphen{}Thomas finite element \sphinxcode{\sphinxupquote{RT0}} and \(\mathbb{P}\) is discretize by constant finite element \sphinxcode{\sphinxupquote{P0}}.

\sphinxAtStartPar
\sphinxstylestrong{Example 9.10} LaplaceRT.edp

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{gd} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1n} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2n} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{RT0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{laplaceMixte} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{GMRES}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.0e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mf}{1e30}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{150}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{l+m+mf}{1e\PYGZhy{}15} \PYG{c+c1}{//this term is here to be sure}
        \PYG{c+c1}{// that all sub matrix are inversible (LU requirement)}
        \PYG{o}{+} \PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1}
        \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}
        \PYG{o}{+} \PYG{n}{p}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)} \PYG{p}{(}
        \PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{gd}\PYG{o}{*}\PYG{p}{(}\PYG{n}{v1}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+}\PYG{n}{v2}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{g1n}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{n}{g2n}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{laplaceMixte}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Metric Adaptation and residual error indicator}
\label{\detokenize{models/static-problems:metric-adaptation-and-residual-error-indicator}}
\sphinxAtStartPar
We do metric mesh adaption and compute the classical residual error indicator \(\eta_{T}\) on the element \(T\) for the Poisson problem.

\sphinxAtStartPar
First, we solve the same problem as in a previous example.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
\PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{10.}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{o}{+}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{16.}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Nh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Nh} \PYG{n}{rho}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Probem1} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.0e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, the local error indicator \(\eta_{T}\) is:
\begin{equation*}
\begin{split}\eta_{T} =\left( h_{T}^{2} || f + \Delta u_{{h}} ||_{L^{2}(T)}^{2} +\sum_{e\in \mathcal{E}_{K}} h_{e} \,||\, [ \frac{\p u_{h}}{\p n_{k}}] \,||^{2}_{L^{2}(e)} \right)^{\frac{1}{2}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(h_{T}\) is the longest edge of \(T\), \({\cal E}_T\) is the set of \(T\) edge not on \(\Gamma=\p \Omega\), \(n_{T}\) is the outside unit normal to \(K\), \(h_{e}\) is the length of edge \(e\), \([ g ]\) is the jump of the function \(g\) across edge (left value minus right value).

\sphinxAtStartPar
Of course, we can use a variational form to compute \(\eta_{T}^{2}\), with test function constant function in each triangle.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Error}
\PYG{k+kt}{varf} \PYG{n+nf}{indicator2} \PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{Probem1}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{indicator2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Nh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{rho} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho = min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{indicator density}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh (before adaptation)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{,} \PYG{n}{anisomax}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mesh (after adaptation)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{n}{rho} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
    \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If the method is correct, we expect to look the graphics by an almost constant function \(\eta\) on your computer as in \hyperref[\detokenize{models/static-problems:examplestaticproblemsmetricadaptation}]{Fig.\@ \ref{\detokenize{models/static-problems:examplestaticproblemsmetricadaptation}}} and \hyperref[\detokenize{models/static-problems:examplestaticproblemsmetricadaptation2}]{Fig.\@ \ref{\detokenize{models/static-problems:examplestaticproblemsmetricadaptation2}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_MetricAdaptation}.png}
\caption{Density of the error indicator with isotropic \(P_{2}\) metric}\label{\detokenize{models/static-problems:examplestaticproblemsmetricadaptation}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{StaticProblems_MetricAdaptation2}.png}
\caption{Density of the error indicator with isotropic \(P_{2}\) metric}\label{\detokenize{models/static-problems:examplestaticproblemsmetricadaptation2}}\end{subfigure}


\end{figure}



\subsection{Adaptation using residual error indicator}
\label{\detokenize{models/static-problems:adaptation-using-residual-error-indicator}}\label{\detokenize{models/static-problems:modelstaticproblemadaptationusingresidualerrorindicator}}\label{\detokenize{models/static-problems:DensityError}}
\sphinxAtStartPar
In the previous example we compute the error indicator, now we use it, to adapt the mesh.
The new mesh size is given by the following formulae:
\begin{equation*}
\begin{split}h_{n+1}(x) = \frac{h_{n}(x)}{f_{n}(\eta_K(x))}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\eta_n(x)\) is the level of error at point \(x\) given by the local error indicator, \(h_n\) is the previous “mesh size” field, and \(f_n\) is a user function define by \(f_n = min(3,max(1/3,\eta_n / \eta_n^* ))\) where \(\eta_n^* = mean(\eta_n) c\), and \(c\) is an user coefficient generally close to one.

\sphinxAtStartPar
First a macro \sphinxcode{\sphinxupquote{MeshSizecomputation}} is defined to get a \(P_1\) mesh size as the average of edge length.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// macro the get the current mesh size parameter}
\PYG{c+c1}{// in:}
\PYG{c+c1}{// Th the mesh}
\PYG{c+c1}{// Vh P1 fespace on Th}
\PYG{c+c1}{// out :}
\PYG{c+c1}{// h: the Vh finite element finite set to the current mesh size}
\PYG{k+kt}{macro} \PYG{n+nf}{MeshSizecomputation} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{count}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*mesh size (lenEdge = integral(e) 1 ds)*/}
    \PYG{k+kt}{varf} \PYG{n}{vmeshsizen} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*number of edges per vertex*/}
    \PYG{k+kt}{varf} \PYG{n}{vedgecount} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kr}{qfnbpE}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+cm}{/*mesh size*/}
    \PYG{n}{count} \PYG{o}{=} \PYG{n}{vedgecount}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vmeshsizen}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{count min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{count}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{h}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{count}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{} bound meshsize = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//}
\end{sphinxVerbatim}

\sphinxAtStartPar
A second macro to re\sphinxhyphen{}mesh according to the new mesh size.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// macro to remesh according the de residual indicator}
\PYG{c+c1}{// in:}
\PYG{c+c1}{// Th the mesh}
\PYG{c+c1}{// Ph P0 fespace on Th}
\PYG{c+c1}{// Vh P1 fespace on Th}
\PYG{c+c1}{// vindicator the varf to evaluate the indicator}
\PYG{c+c1}{// coef on etameam}
\PYG{k+kt}{macro} \PYG{n+nf}{ReMeshIndicator} \PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{vindicator}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Vh} \PYG{n}{h}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{c+cm}{/*evaluate the mesh size*/}
    \PYG{n}{MeshSizecomputation}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{etak}\PYG{p}{;}
    \PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vindicator}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{etak}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{etastar}\PYG{o}{=} \PYG{k+kp}{coef}\PYG{o}{*}\PYG{p}{(}\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{/}\PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{etastar = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{etastar} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sum = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{etak}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+cm}{/*etaK is discontinous*/}
    \PYG{c+cm}{/*we use P1 L2 projection with mass lumping*/}
    \PYG{n}{Vh} \PYG{n}{fn}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{veta}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{etak}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n}{vun}\PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fn}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{veta}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{sigma}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vun}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{fn}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fn}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/} \PYG{k+kp}{sigma}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{fn} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{fn}\PYG{o}{/}\PYG{n}{etastar}\PYG{p}{,}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.3333}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+cm}{/*new mesh size*/}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{h} \PYG{o}{/} \PYG{n}{fn}\PYG{p}{;}
    \PYG{c+cm}{/*build the mesh*/}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hinit} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;} \PYG{c+c1}{//initial mesh size}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for the mesh size and solution}
\PYG{n}{Vh} \PYG{n}{h} \PYG{o}{=} \PYG{n}{hinit}\PYG{p}{;} \PYG{c+c1}{//the FE function for the mesh size}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for the error indicator}

\PYG{c+c1}{//Build a mesh with the given mesh size hinit}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{h}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{l+m+mf}{1.0e\PYGZhy{}10}
        \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{indicator2} \PYG{p}{(}\PYG{k+kr}{unused}\PYG{p}{,} \PYG{n}{chiK}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{intalledges}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{k+kr}{lenEdge}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{jump}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{chiK}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{hTriangle}\PYG{o}{*}\PYG{p}{(}\PYG{n}{f} \PYG{o}{+} \PYG{n+nf}{dxx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dyy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Poisson}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{cc} \PYG{o}{=} \PYG{l+m+mf}{0.8}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{5}\PYG{p}{)} \PYG{n}{cc}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{ReMeshIndicator}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Ph}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{n}{indicator2}\PYG{p}{,} \PYG{n}{cc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_AdaptationResidualError}.png}
\caption{The error indicator with isotropic \(P_{1}\)}\label{\detokenize{models/static-problems:examplestaticproblemsadaptationresidualerror}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{StaticProblems_AdaptationResidualError2}.png}
\caption{The mesh and isovalue of the solution}\label{\detokenize{models/static-problems:examplestaticproblemsadaptationresidualerror2}}\end{subfigure}
\phantomsection\label{\detokenize{models/static-problems:ErrorIndicator}}

\end{figure}



\section{Elasticity}
\label{\detokenize{models/elasticity:elasticity}}\label{\detokenize{models/elasticity::doc}}
\sphinxAtStartPar
Consider an elastic plate with undeformed shape \(\Omega\times ]-h,h[\) in \(\mathbb{R}^3\), \(\Omega\subset\mathbb{R}^2\).

\sphinxAtStartPar
By the deformation of the plate, we assume that a point \(P(x_1,x_2,x_3)\) moves to \({\cal P}(\xi_1,\xi_2,\xi_3)\).
The vector \(\mathbf{u}=(u_1,u_2,u_3)=(\xi_1-x_1,\xi_2-x_2,\xi_3-x_3)\) is called the \sphinxstyleemphasis{displacement vector}.

\sphinxAtStartPar
By the deformation, the line segment \(\overline{\mathbf{x},\mathbf{x}+\tau\Delta\mathbf{x}}\) moves approximately to \(\overline{\mathbf{x}+\mathbf{u}(\mathbf{x}),\mathbf{x}+\tau\Delta\mathbf{x} +\mathbf{u}(\mathbf{x}+\tau\Delta\mathbf{x})}\) for small \(\tau\), where \(\mathbf{x}=(x_1,x_2,x_3),\, \Delta\mathbf{x} =(\Delta x_1,\Delta x_2,\Delta x_3)\).

\sphinxAtStartPar
We now calculate the ratio between two segments:
\begin{equation*}
\begin{split}\eta(\tau)=\tau^{-1}|\Delta\mathbf{x}|^{-1}
\left(|\mathbf{u}(\mathbf{x}+\tau\Delta\mathbf{x})
-\mathbf{u}(\mathbf{x})+\tau\Delta\mathbf{x}|-\tau|\Delta\mathbf{x}|\right)\end{split}
\end{equation*}
\sphinxAtStartPar
then we have (see e.g. \sphinxcite{bibliography:necas2017}, p.32)
\begin{equation*}
\begin{split}\lim_{\tau\to 0}\eta(\tau)=(1+2e_{ij}\nu_i\nu_j)^{1/2}-1,
\quad 2e_{ij}=\frac{\partial u_k}{\partial x_i}\frac{\partial u_k}{\partial x_j}+\left(\frac{\partial u_i}{\partial x_j}+
\frac{\partial u_j}{\partial x_i}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\nu_i=\Delta x_i|\Delta\mathbf{x}|^{-1}\).
If the deformation is \sphinxstyleemphasis{small}, then we may consider that:
\begin{equation*}
\begin{split}(\partial u_k/\partial x_i)(\partial u_k/\partial x_i)\approx 0\end{split}
\end{equation*}
\sphinxAtStartPar
and the following is called \sphinxstyleemphasis{small strain tensor}:
\begin{equation*}
\begin{split}\varepsilon_{ij}(u)=\frac{1}{2}\left(\frac{\partial u_i}{\partial x_j}+
\frac{\partial u_j}{\partial x_i}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
The tensor \(e_{ij}\) is called \sphinxstyleemphasis{finite strain tensor}.

\sphinxAtStartPar
Consider the small plane \(\Delta \Pi(\mathbf{x})\) centered at \(\mathbf{x}\) with the unit normal direction \(\mathbf{n}=(n_1,n_2,n_3)\), then the surface on \(\Delta \Pi(\mathbf{x})\) at \(\mathbf{x}\) is:
\begin{equation*}
\begin{split}(\sigma_{1j}(\mathbf{x})n_j, \sigma_{2j}(\mathbf{x})n_j, \sigma_{3j}(\mathbf{x})n_j)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\sigma_{ij}(\mathbf{x})\) is called \sphinxstyleemphasis{stress tensor} at \(\mathbf{x}\).
Hooke’s law is the assumption of a linear relation between \(\sigma_{ij}\) and \(\varepsilon_{ij}\) such as:
\begin{equation*}
\begin{split}\sigma_{ij}(\mathbf{x})=c_{ijkl}(\mathbf{x})\varepsilon_{ij}(\mathbf{x})\end{split}
\end{equation*}
\sphinxAtStartPar
with the symmetry \(c_{ijkl}=c_{jikl}, c_{ijkl}=c_{ijlk}, c_{ijkl}=c_{klij}\).

\sphinxAtStartPar
If Hooke’s tensor \(c_{ijkl}(\mathbf{x})\) do not depend on the choice of coordinate system, the material is called \sphinxstyleemphasis{isotropic} at \(\mathbf{x}\).

\sphinxAtStartPar
If \(c_{ijkl}\) is constant, the material is called \sphinxstyleemphasis{homogeneous}.
In homogeneous isotropic case, there is \sphinxstyleemphasis{Lamé constants} \(\lambda, \mu\) (see e.g. \sphinxcite{bibliography:necas2017}, p.43) satisfying
\begin{equation*}
\begin{split}\sigma_{ij}=\lambda\delta_{ij}\textrm{div}\mathbf{u}+2\mu \varepsilon_{ij}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\delta_{ij}\) is Kronecker’s delta.

\sphinxAtStartPar
We assume that the elastic plate is fixed on \(\Gamma_D\times ]-h,h[,\, \Gamma_D\subset \partial\Omega\).
If the body force \(\mathbf{f}=(f_1,f_2,f_3)\) is given in \(\Omega\times]-h,h[\) and surface force \(\mathbf{g}\) is given in \(\Gamma_N\times]-h,h[, \Gamma_N=\partial\Omega\setminus\overline{\Gamma_D}\), then the equation of equilibrium is given as follows:
\begin{equation}\label{equation:models/elasticity:eqn::elasticity}
\begin{split}\begin{array}{rcl}
    -\partial_j \sigma_{ij}&=&f_i~~\textrm{in }\Omega\times ]-h,h[,\quad
    i=1,2,3\\
    \sigma_{ij}n_j&=&g_i~~\textrm{on }\Gamma_N\times ]-h,h[,\quad
    u_i=0~~\textrm{on }\Gamma_D\times ]-h,h[,\quad i=1,2,3
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
We now explain the plain elasticity.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Plain strain:}

\sphinxAtStartPar
On the end of plate, the contact condition \(u_3=0,\, g_3=\) is satisfied.

\sphinxAtStartPar
In this case, we can suppose that \(f_3=g_3=u_3=0\) and \(\mathbf{u}(x_1,x_2,x_3)=\overline{u}(x_1,x_2)\) for all \(-h<x_3<h\).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Plain stress:}

\sphinxAtStartPar
The cylinder is assumed to be very thin and subjected to no load on the ends \(x_3=\pm h\), that is,
\begin{equation*}
\begin{split}\sigma_{3i}=0,\quad x_3=\pm h,\quad i~1,2,3\end{split}
\end{equation*}
\sphinxAtStartPar
The assumption leads that \(\sigma_{3i}=0\) in \(\Omega\times ]-h,h[\) and \(\mathbf{u}(x_1,x_2,x_3)=\overline{u}(x_1,x_2)\) for all \(-h<x_3<h\).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generalized plain stress:}

\sphinxAtStartPar
The cylinder is subjected to no load at \(x_3=\pm h\).
Introducing the mean values with respect to thickness,
\begin{equation*}
\begin{split}\overline{u}_i(x_1,x_2)=\frac{1}{2h}\int_{-h}^h{u(x_1,x_2,x_3)dx_3}\end{split}
\end{equation*}
\sphinxAtStartPar
and we derive \(\overline{u}_3\equiv 0\).
Similarly we define the mean values \(\overline{f},\overline{g}\) of the body force and surface force as well as the mean values \(\overline{\varepsilon}_{ij}\) and \(\overline{\sigma}_{ij}\) of the components of stress and strain, respectively.

\end{itemize}

\sphinxAtStartPar
In what follows we omit the overlines of \(\overline{u}, \overline{f},\overline{g}, \overline{\varepsilon}_{ij}\) and \(\overline{\varepsilon}_{ij}\).
Then we obtain similar equation of equilibrium given in \eqref{equation:models/elasticity:eqn::elasticity} replacing \(\Omega\times ]-h,h[\) with \(\Omega\) and changing \(i=1,2\).
In the case of plane stress, \(\sigma_{ij}=\lambda^* \delta_{ij}\textrm{div}u+2\mu\varepsilon_{ij}, \lambda^*=(2\lambda \mu)/(\lambda+\mu)\).

\sphinxAtStartPar
The equations of elasticity are naturally written in variational form for the displacement vector \(\mathbf{u}(\mathbf{x})\in V\) as:
\begin{equation*}
\begin{split}\int_\Omega [2\mu\epsilon_{ij}(\mathbf{u})\epsilon_{ij}(\mathbf{v})
+\lambda \epsilon_{ii}(\mathbf{u})\epsilon_{jj}(\mathbf{v})]
=\int_\Omega \mathbf{f}\cdot \mathbf{v} +\int_\Gamma \mathbf{g}\cdot \mathbf{v},
\forall \mathbf{v}\in V\end{split}
\end{equation*}
\sphinxAtStartPar
where \(V\) is the linear closed subspace of \(H^1(\Omega)^2\).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Beam

\sphinxAtStartPar
Consider an elastic plate with the undeformed rectangle shape \(]0,10[\times ]0,2[\).
The body force is the gravity force \(\mathbf{f}\) and the boundary force \(\mathbf{g}\) is zero on lower and upper side.
On the two vertical sides of the beam are fixed.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Elasticity} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)} \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{2.5}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Beam 3D

\sphinxAtStartPar
Consider elastic box with the undeformed parallelepiped shape \(]0,5[\times ]0,1[\times]0,1[\).
The body force is the gravity force \(\mathbf{f}\) and the boundary force \(\mathbf{g}\) is zero on all face except one the one vertical left face where the beam is fixed.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cube.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Nxyz} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{5.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Lxyz} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5e4}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Cube}\PYG{p}{(}\PYG{n}{Nxyz}\PYG{p}{,} \PYG{n}{Bxyz}\PYG{p}{,} \PYG{n}{Lxyz}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{p}{[}
    \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{Lame} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(} \PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)} \PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{v3}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kt}{real} \PYG{n}{dmax} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max displacement = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dmax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{/}\PYG{n}{dmax}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ref2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Thm} \PYG{o}{=} \PYG{n}{movemesh3}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u1}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{u2}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{+}\PYG{n}{u3}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{ref2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Thm} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Thm}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{ref2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{Thm}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{coef amplification = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{coef}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Elasticity_Beam3D}.jpg}
\caption{3d Beam deformed and undeformed box}\label{\detokenize{models/elasticity:elasticity-beam3d}}\end{figure}
\end{sphinxadmonition}


\subsection{Fracture Mechanics}
\label{\detokenize{models/elasticity:fracture-mechanics}}
\sphinxAtStartPar
Consider the plate with the crack whose undeformed shape is a curve \(\Sigma\) with the two edges \(\gamma_1,\, \gamma_2\).

\sphinxAtStartPar
We assume the stress tensor \(\sigma_{ij}\) is the state of plate stress regarding \((x,y)\in \Omega_{\Sigma}=\Omega\setminus \Sigma\).
Here \(\Omega\) stands for the undeformed shape of elastic plate without crack.

\sphinxAtStartPar
If the part \(\Gamma_N\) of the boundary \(\partial\Omega\) is fixed and a load \({\cal L}=(\mathbf{f},\mathbf{g})\in L^2(\Omega)^2\times L^2(\Gamma_N)^2\) is given, then the displacement \(\mathbf{u}\) is the minimizer of the potential energy functional:
\begin{equation*}
\begin{split}{\cal E}(\mathbf{v};{\cal L},\Omega_{\Sigma})
=\int_{\Omega_{\Sigma}}
\{w(x,\mathbf{v})-\mathbf{f}\cdot \mathbf{v}\}
-\int_{\Gamma_N}\mathbf{g}\cdot \mathbf{v}\end{split}
\end{equation*}
\sphinxAtStartPar
over the functional space \(V(\Omega_{\Sigma})\),
\begin{equation*}
\begin{split}V(\Omega_{\Sigma})
=\left\{ \mathbf{v}\in H^1(\Omega_{\Sigma})^2;\;
\mathbf{v}=0\quad \hbox{ on }
\Gamma_D=\partial\Omega\setminus\overline{\Gamma_N}\right\},\end{split}
\end{equation*}
\sphinxAtStartPar
where \(w(x,\mathbf{v})=\sigma_{ij}(\mathbf{v})\varepsilon_{ij}(\mathbf{v})/2\),
\begin{equation*}
\begin{split}\sigma_{ij}(\mathbf{v})=C_{ijkl}(x)\varepsilon_{kl}(\mathbf{v}),\quad
\varepsilon_{ij}(\mathbf{v})=(\partial v_i/\partial x_j+
\partial v_j/\partial x_i)/2,
\qquad (C_{ijkl}:\quad \hbox{Hooke's tensor}).\end{split}
\end{equation*}
\sphinxAtStartPar
If the elasticity is homogeneous isotropic, then the displacement \(\mathbf{u}(x)\) is decomposed in an open neighborhood \(U_k\) of \(\gamma_k\) as in (see e.g. \sphinxcite{bibliography:ohtsuka2000})
\begin{equation}\label{equation:models/elasticity:eqn::SIF}
\begin{split}\mathbf{u}(x) =
\sum_{l=1}^2 K_l(\gamma_k) r_k^{1/2} S^C_{kl}(\theta_k)
+ \mathbf{u}_{k,R}(x)
\quad \mbox{for }x\in \Omega_{\Sigma}\cap U_k,\, k=1,2\end{split}
\end{equation}
\sphinxAtStartPar
with \(\mathbf{u}_{k,R} \in H^2(\Omega_\Sigma\cap U_k)^2\), where \(U_k,\, k=1,2\) are open neighborhoods of \(\gamma_k\) such that \(\partial L_1\cap U_1=\gamma_1,\, \partial L_m\cap U_2=\gamma_2\), and
\begin{equation*}
\begin{split}\begin{array}{rcl}
    S^C_{k1}(\theta_k) & = & \frac 1 {4\mu} \frac 1 {(2\pi)^{1/2}}
        \left[ \begin{array}{c}
        [2\kappa-1]\cos(\theta_k/2)-\cos(3\theta_k/2)\\
        -[2\kappa+1]\sin(\theta_k/2)+\sin(3\theta_k/2)
        \end{array}\right],\\
    S^C_{k2}(\theta_k) & = & \frac 1 {4\mu} \frac 1 {(2\pi)^{1/2}}
        \left[ \begin{array}{c}
        -[2\kappa-1]\sin(\theta_k/2)+3\sin(3\theta_k/2)\\
        -[2\kappa+1]\cos(\theta_k/2)+\cos(3\theta_k/2)
        \end{array}\right]. \nonumber
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mu\) is the shear modulus of elasticity, \(\kappa=3-4\nu\) (\(\nu\) is the Poisson’s ratio) for plane strain and \(\kappa=\frac {3-\nu} {1+\nu}\) for plane stress.

\sphinxAtStartPar
The coefficients \(K_1(\gamma_i)\) and \(K_2(\gamma_i),\) which are important parameters in fracture mechanics, are called stress intensity factors of the opening mode (mode I) and the sliding mode (mode II), respectively.

\sphinxAtStartPar
For simplicity, we consider the following simple crack
\begin{equation*}
\begin{split}\Omega=\{(x,y):\; -1<x<1, -1<y<1\},\qquad
\Sigma=\{(x,y):\; -1\le x\le 0, y=0\}\end{split}
\end{equation*}
\sphinxAtStartPar
with only one crack tip \(\gamma=(0,0)\).
Unfortunately, \sphinxstylestrong{FreeFEM} cannot treat crack, so we use the modification of the domain with U\sphinxhyphen{}shape channel (see {\hyperref[\detokenize{documentation/mesh-generation:meshexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{U\sphinxhyphen{}shape example}}}}, \hyperref[\detokenize{documentation/mesh-generation:ushape}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:ushape}}}) with \(d=0.0001\).
The undeformed crack \(\Sigma\) is approximated by
\begin{equation*}
\begin{split}\Sigma_d = \{(x,y):\; -1\le x\le -10*d, -d\le y\le d\} \cup\{(x,y):\; -10*d\le x\le 0, -d+0.1*x\le y\le d-0.1*x\}\end{split}
\end{equation*}
\sphinxAtStartPar
and \(\Gamma_D=\)\sphinxcode{\sphinxupquote{R}} in {\hyperref[\detokenize{documentation/mesh-generation:meshexamples}]{\sphinxcrossref{\DUrole{std,std-ref}{U\sphinxhyphen{}shape example}}}}, \hyperref[\detokenize{documentation/mesh-generation:ushape}]{Fig.\@ \ref{\detokenize{documentation/mesh-generation:ushape}}}.

\sphinxAtStartPar
In this example, we use three technique:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Fast Finite Element Interpolator from the mesh \sphinxcode{\sphinxupquote{Th}} to \sphinxcode{\sphinxupquote{Zoom}} for the scale\sphinxhyphen{}up of near \(\gamma\).

\item {} 
\sphinxAtStartPar
After obtaining the displacement vector \(\mathbf{u}=(u,v)\), we shall watch the deformation of the crack near \(\gamma\) as follows,

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Plate} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Adaptivity is an important technique here, because a large singularity occurs at \(\gamma\) as shown in \eqref{equation:models/elasticity:eqn::SIF}.

\end{itemize}

\sphinxAtStartPar
The first example creates mode I deformation by the opposed surface force on \sphinxcode{\sphinxupquote{B}} and \sphinxcode{\sphinxupquote{T}} in the vertical direction of \(\Sigma\), and the displacement is fixed on \sphinxcode{\sphinxupquote{R}}.

\sphinxAtStartPar
In a laboratory, fracture engineers use photoelasticity to make stress field visible, which shows the principal stress difference
\begin{equation*}
\begin{split}\sigma_1-\sigma_2=\sqrt{(\sigma_{11}-\sigma_{22})^2+4\sigma_{12}^2}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\sigma_1\) and \(\sigma_2\) are the principal stresses.

\sphinxAtStartPar
In opening mode, the photoelasticity make symmetric pattern concentrated at \(\gamma\).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Crack Opening, \(K_2(\gamma)=0\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Parameters}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{cb} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ca} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tip} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{cb}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{n}{ca}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Zoom} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{zVh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{zVh} \PYG{n}{Sx}\PYG{p}{,} \PYG{n}{Sy}\PYG{p}{,} \PYG{n}{Sxy}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{T}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Plate} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//deformation near gamma}
    \PYG{n}{Sx} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sy} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sxy} \PYG{o}{=} \PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Sx}\PYG{o}{\PYGZhy{}}\PYG{n}{Sy}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{Sxy}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//principal stress difference}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Adaptmesh}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Problem}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture1}.png}
\caption{Crack open displacement (COD) on the first mesh}\label{\detokenize{models/elasticity:id4}}\label{\detokenize{models/elasticity:figcodfirstmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture2}.png}
\caption{Principal stress difference on the first mesh}\label{\detokenize{models/elasticity:id5}}\label{\detokenize{models/elasticity:figstressfirstmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture3}.png}
\caption{COD on the last adaptive mesh}\label{\detokenize{models/elasticity:id6}}\label{\detokenize{models/elasticity:figcodlastmesh}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_Fracture4}.png}
\caption{Principal stress difference on the last adaptive mesh}\label{\detokenize{models/elasticity:id7}}\label{\detokenize{models/elasticity:figstresslastmesh}}\end{subfigure}
\phantomsection\label{\detokenize{models/elasticity:CrackAndPrincipalStress}}

\end{figure}

\end{sphinxadmonition}

\sphinxAtStartPar
It is difficult to create mode II deformation by the opposed shear force on \sphinxcode{\sphinxupquote{B}} and \sphinxcode{\sphinxupquote{T}} that is observed in a laboratory.
So we use the body shear force along \(\Sigma\), that is, the \(x\)\sphinxhyphen{}component \(f_1\) of the body force \(\mathbf{f}\) is given by
\begin{equation*}
\begin{split}f_1(x,y)=H(y-0.001)*H(0.1-y)-H(-y-0.001)*H(y+0.1)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(H(t)=1\) if \(t>0\); \(= 0\) if \(t<0\).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Crack Sliding, \(K_2(\gamma)=0\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{cb} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ca} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{tip} \PYG{o}{=} \PYG{l+m+mf}{0.0}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{L1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{L2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{+}\PYG{n}{tip}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{n}{tip}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{d}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{ca}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{R}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{T}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cb}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{ca}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{cb}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{n}{ca}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Zoom} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{L1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{L2}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{R}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{T}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{zVh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{zVh} \PYG{n}{Sx}\PYG{p}{,} \PYG{n}{Sy}\PYG{p}{,} \PYG{n}{Sxy}\PYG{p}{,} \PYG{k+kr}{N}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{fx} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.001}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Problem} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{fx}\PYG{o}{*}\PYG{n}{w}
    \PYG{p}{)}
    \PYG{o}{+}\PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{R}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{mesh} \PYG{n}{Plate} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Zoom}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//deformation near gamma}
    \PYG{n}{Sx} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sy} \PYG{o}{=} \PYG{n}{lambda}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Sxy} \PYG{o}{=} \PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Sx}\PYG{o}{\PYGZhy{}}\PYG{n}{Sy}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{Sxy}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//principal stress difference}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Plate}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Adaptmesh}
    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Problem}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding1}.png}
\caption{COD on the first mesh}\label{\detokenize{models/elasticity:id8}}\label{\detokenize{models/elasticity:figfracturesliding1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding2}.png}
\caption{Principal stress difference in the first mesh}\label{\detokenize{models/elasticity:id9}}\label{\detokenize{models/elasticity:figfracturesliding2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding3}.png}
\caption{COD on the last adaptive mesh}\label{\detokenize{models/elasticity:id10}}\label{\detokenize{models/elasticity:figfracturesliding3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Elasticity_FractureSliding4}.png}
\caption{Principal stress difference on the last adaptive mesh}\label{\detokenize{models/elasticity:id11}}\label{\detokenize{models/elasticity:figfracturesliding4}}\end{subfigure}
\phantomsection\label{\detokenize{models/elasticity:CrackAndPrincipalStress}}

\end{figure}

\end{sphinxadmonition}


\section{Non\sphinxhyphen{}linear static problems}
\label{\detokenize{models/non-linear-static-problems:non-linear-static-problems}}\label{\detokenize{models/non-linear-static-problems::doc}}
\sphinxAtStartPar
Here we propose to solve the following non\sphinxhyphen{}linear academic problem of minimization of a functional:
\begin{equation*}
\begin{split}J(u) = \int_\Omega \frac{1}{2} f(|\nabla u|^2) - u*b\end{split}
\end{equation*}
\sphinxAtStartPar
where \(u\) is function of \(H^1_0(\Omega)\) and \(f\) defined by:
\begin{equation*}
\begin{split}f(x) = a*x + x-ln(1+x),\ f'(x) = a+\frac{x}{1+x},\ f''(x) = \frac{1}{(1+x)^2}\end{split}
\end{equation*}

\subsection{Newton\sphinxhyphen{}Raphson algorithm}
\label{\detokenize{models/non-linear-static-problems:newton-raphson-algorithm}}
\sphinxAtStartPar
Now, we solve the Euler problem \(\nabla J (u) = 0\) with Newton\sphinxhyphen{}Raphson algorithm, that is:
\begin{equation*}
\begin{split}u^{n+1} = u^n - ( \nabla^2 J (u^{n}))^{-1}*\nabla J(u^n)\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{0.05}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//to store |nabla u|\PYGZca{}2}
\PYG{n}{Ph} \PYG{n}{dalpha} \PYG{p}{;} \PYG{c+c1}{//to store 2f\PYGZsq{}\PYGZsq{}(|nabla u|\PYGZca{}2)}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{u}\PYG{o}{*}\PYG{n}{a} \PYG{o}{+} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{df} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{a} \PYG{o}{+}\PYG{n}{u}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{ddf} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+m+mf}{1.} \PYG{o}{/} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{//the variational form of evaluate dJ = nabla J}
\PYG{c+c1}{//dJ = f\PYGZsq{}()*(dx(u)*dx(vh) + dy(u)*dy(vh))}
\PYG{k+kt}{varf} \PYG{n+nf}{vdJ} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//the variational form of evaluate ddJ = nabla\PYGZca{}2 J}
\PYG{c+c1}{//hJ(uh,vh) = f\PYGZsq{}()*(dx(uh)*dx(vh) + dy(uh)*dy(vh))}
\PYG{c+c1}{//  + 2*f\PYGZsq{}\PYGZsq{}()(dx(u)*dx(uh) + dy(u)*dy(uh)) * (dx(u)*dx(vh) + dy(u)*dy(vh))}
\PYG{k+kt}{varf} \PYG{n+nf}{vhJ} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{dalpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Newton algorithm}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Compute f\PYGZsq{} and f\PYGZsq{}\PYGZsq{}}
    \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dalpha} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{ddf}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// nabla J}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{o}{=} \PYG{n}{vdJ}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Residual}
    \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ residu\PYGZca{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(} \PYG{n}{res} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}12}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

    \PYG{c+c1}{// HJ}
    \PYG{k+kt}{matrix} \PYG{n}{H} \PYG{o}{=} \PYG{n}{vhJ}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Newton}
    \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{H}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solution with Newton\PYGZhy{}Raphson}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Eigen value problems}
\label{\detokenize{models/eigen-value-problems:eigen-value-problems}}\label{\detokenize{models/eigen-value-problems::doc}}
\sphinxAtStartPar
This section depends on your installation of \sphinxstylestrong{FreeFEM}; you need to have compiled \sphinxcode{\sphinxupquote{ARPACK}}.
This tool is available in \sphinxstylestrong{FreeFEM} if the word eigenvalue appears in line \sphinxcode{\sphinxupquote{Load:}}, like:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYGZhy{}\PYGZhy{} FreeFem++ v*.** \PYG{o}{(}date *** *** ** **:**:** CET ****\PYG{o}{)}
 file : ***.edp
 Load: lg\PYGZus{}fem lg\PYGZus{}mesh eigenvalue
\end{sphinxVerbatim}

\sphinxAtStartPar
This tool is based on \sphinxhref{http://www.caam.rice.edu/software/ARPACK/}{arpack++}, the object\sphinxhyphen{}oriented version of \sphinxcode{\sphinxupquote{ARPACK}} eigenvalue package \sphinxcite{bibliography:lehoucq1998}.

\sphinxAtStartPar
The function \sphinxcode{\sphinxupquote{EigenValue}} computes the generalized eigenvalue of \(A u = \lambda B u\).
The Shift\sphinxhyphen{}invert method is used by default, with sigma =\(\sigma\) the shift of the method.

\sphinxAtStartPar
The matrix \(OP\) is defined with \(A - \sigma B\).

\sphinxAtStartPar
The return value is the number of converged eigenvalues (can be greater than the number of requested eigenvalues nev=)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the matrix \(OP= A - \sigma B\) with a solver and boundary condition, and the matrix \(B\).

\sphinxAtStartPar
There is also a functional interface:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{n}{FOP1}\PYG{p}{,} \PYG{n}{FB}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \(n\) is the size of the problem, and the operators are now defined through functions, defining respectively the matrix product of \(OP^{-1}\) and \(B\), as in

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{OP1}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{FOP1}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au} \PYG{o}{=} \PYG{n}{OP}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{u}\PYG{p}{;} \PYG{k}{return} \PYG{n}{Au}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{FB}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{u}\PYG{p}{;} \PYG{k}{return} \PYG{n}{Au}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want finer control over the method employed in \sphinxcode{\sphinxupquote{ARPACK}}, you can specify which mode \sphinxcode{\sphinxupquote{ARPACK}} will work with (\sphinxcode{\sphinxupquote{mode=}} , see ARPACK documentation \sphinxcite{bibliography:lehoucq1998}). The operators necessary for the chosen mode can be passed through the optional parameters \sphinxcode{\sphinxupquote{A=}}, \sphinxcode{\sphinxupquote{A1=}}, \sphinxcode{\sphinxupquote{B=}}, \sphinxcode{\sphinxupquote{B1=}}, (see below).
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mode=1}}: Regular mode for solving \(A u = \lambda u\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{FOP}\PYG{p}{,} \PYG{k+kp}{mode}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the function FOP defines the matrix product of A

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mode=2}}: Regular inverse mode for solving \(A u = \lambda B u\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{FOP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{FB}\PYG{p}{,} \PYG{k+kp}{B1}\PYG{o}{=}\PYG{n}{FB1}\PYG{p}{,} \PYG{k+kp}{mode}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the functions FOP, FB and FB1 define respectively the matrix product of \(A\), \(B\) and \(B^{-1}\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mode=3}}: Shift\sphinxhyphen{}invert mode for solving \(A u = \lambda B u\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kp}{A1}\PYG{o}{=}\PYG{n}{FOP1}\PYG{p}{,} \PYG{k+kp}{B}\PYG{o}{=}\PYG{n}{FB}\PYG{p}{,} \PYG{k+kp}{mode}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{n}{Sigma}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{o}{=}\PYG{n}{Nev}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
where the functions FOP1 and FB define respectively the matrix product of \(OP^{-1} = (A - \sigma B)^{-1}\) and \(B\)

\end{itemize}

\sphinxAtStartPar
You can also specify which subset of eigenvalues you want to compute (\sphinxcode{\sphinxupquote{which=}}).
The default value is \sphinxcode{\sphinxupquote{which="LM"}}, for eigenvalues with largest magnitude.
\sphinxcode{\sphinxupquote{"SM"}} is for smallest magnitude, \sphinxcode{\sphinxupquote{"LA"}} for largest algebraic value, \sphinxcode{\sphinxupquote{"SA"}} for smallest algebraic value, and \sphinxcode{\sphinxupquote{"BE"}} for both ends of the spectrum.

\sphinxAtStartPar
Remark: For complex problems, you need to use the keyword \sphinxcode{\sphinxupquote{complexEigenValue}} instead of \sphinxcode{\sphinxupquote{EigenValue}} when passing operators through functions.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Boundary condition and Eigenvalue Problems

\sphinxAtStartPar
The locking (Dirichlet) boundary condition is make with exact penalization so we put \sphinxcode{\sphinxupquote{1e30=tgv}} on the diagonal term of the locked degree of freedom (see {\hyperref[\detokenize{documentation/finite-element:variationalformsparsematrixpde}]{\sphinxcrossref{\DUrole{std,std-ref}{Finite element chapter}}}}). So take Dirichlet boundary condition just on \(A\) and not on \(B\) because we solve \(w=OP^{-1}*B*v\).

\sphinxAtStartPar
If you put locking (Dirichlet) boundary condition on \(B\) matrix (with key work \sphinxcode{\sphinxupquote{on}}) you get small spurious modes \((10^{-30})\), due to boundary condition, but if you forget the locking boundary condition on \(B\) matrix (no keywork \sphinxcode{\sphinxupquote{on}}) you get huge spurious \((10^{30})\) modes associated to these boundary conditons. We compute only small mode, so we get the good one in this case.
\end{sphinxadmonition}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sym=}} The problem is symmetric (all the eigen value are real)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nev=}} The number desired eigenvalues (nev) close to the shift.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{value=}} The array to store the real part of the eigenvalues

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ivalue=}} The array to store the imaginary part of the eigenvalues

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{vector=}} The FE function array to store the eigenvectors

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rawvector=}} An array of type \sphinxcode{\sphinxupquote{real{[}int,int{]}}} to store eigenvectors by column.

\sphinxAtStartPar
For real non symmetric problems, complex eigenvectors are given as two consecutive vectors, so if eigenvalue \(k\) and \(k+1\) are complex conjugate eigenvalues, the \(k\)th vector will contain the real part and the \(k+1\)th vector the imaginary part of the corresponding complex conjugate eigenvectors.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{tol=}} The relative accuracy to which eigenvalues are to be determined;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sigma=}} The shift value;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{maxit=}} The maximum number of iterations allowed;

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ncv=}} The number of Arnoldi vectors generated at each iteration of \sphinxcode{\sphinxupquote{ARPACK}};

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mode=}} The computational mode used by \sphinxcode{\sphinxupquote{ARPACK}} (see above);

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{which=}} The requested subset of eigenvalues (see above).

\end{itemize}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Laplace eigenvalue

\sphinxAtStartPar
In the first example, we compute the eigenvalues and the eigenvectors of the Dirichlet problem on square \(\Omega=]0,\pi[^2\).

\sphinxAtStartPar
The problem is to find: \(\lambda\), and \(\nabla u_{\lambda}\) in \(\mathbb{R}{\times} H^1_0(\Omega)\)
\begin{equation*}
\begin{split}\int_\Omega \nabla u_{\lambda} \nabla v = \lambda \int_\Omega u v \quad \forall v \in H^1_0(\Omega)\end{split}
\end{equation*}
\sphinxAtStartPar
The exact eigenvalues are \(\lambda_{n,m} =(n^2+m^2), (n,m)\in {\mathbb{N}_*}^2\) with the associated eigenvectors are \(u_{{m,n}}=\sin(nx)*\sin(my)\).

\sphinxAtStartPar
We use the generalized inverse shift mode of the \sphinxtitleref{arpack++} library, to find 20 eigenvalues and eigenvectors close to the shift value \(\sigma=20\).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//value of the shift}
\PYG{k+kt}{int} \PYG{k+kp}{nev} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{c+c1}{//number of computed eigen value close to sigma}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{c+c1}{// OP = A \PYGZhy{} sigma B ; // the shifted matrix}
\PYG{k+kt}{varf} \PYG{k+kp}{op} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{k+kp}{sigma}\PYG{o}{*} \PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//no boundary condition}

\PYG{k+kt}{matrix} \PYG{n}{OP} \PYG{o}{=} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//crout solver because the matrix in not positive}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}20}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// important remark:}
\PYG{c+c1}{// the boundary condition is make with exact penalization:}
\PYG{c+c1}{// we put 1e30=tgv on the diagonal term of the lock degree of freedom.}
\PYG{c+c1}{// So take Dirichlet boundary condition just on \PYGZdl{}a\PYGZdl{} variational form}
\PYG{c+c1}{// and not on \PYGZdl{}b\PYGZdl{} variational form.}
\PYG{c+c1}{// because we solve \PYGZdl{} w=OP\PYGZca{}\PYGZhy{}1*B*v \PYGZdl{}}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ev}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvalue}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{eV}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvector}

\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{sym}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{,} \PYG{k+kp}{vector}\PYG{o}{=}\PYG{n}{eV}\PYG{p}{,}
    \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{maxit}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ncv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display \PYGZam{} Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{u1} \PYG{o}{=} \PYG{n}{eV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{gg} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{mm} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{)} \PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lambda[}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{eV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Eigen Vector }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ value =}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this example is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
lambda\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{5}.0002, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}1.46519e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{1}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{8}.00074, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.05158e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{2}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{10}.0011, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{2}.84925e\PYGZhy{}12
lambda\PYG{o}{[}\PYG{l+m}{3}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{10}.0011, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}7.25456e\PYGZhy{}12
lambda\PYG{o}{[}\PYG{l+m}{4}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{13}.002, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}1.74257e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{5}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{13}.0039, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.22554e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{6}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{17}.0046, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}1.06274e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{7}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{17}.0048, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.03883e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{8}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{18}.0083, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.05497e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{9}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{20}.0096, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}2.21678e\PYGZhy{}13
lambda\PYG{o}{[}\PYG{l+m}{10}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{20}.0096, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.16212e\PYGZhy{}14
lambda\PYG{o}{[}\PYG{l+m}{11}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{25}.014, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}7.42931e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{12}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{25}.0283, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{6}.77444e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{13}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{26}.0159, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{3}.19864e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{14}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{26}.0159, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}4.9652e\PYGZhy{}12
lambda\PYG{o}{[}\PYG{l+m}{15}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{29}.0258, \PYG{n+nv}{err}\PYG{o}{=} \PYGZhy{}9.99573e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{16}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{29}.0273, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.38242e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{17}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{32}.0449, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{1}.2522e\PYGZhy{}10
lambda\PYG{o}{[}\PYG{l+m}{18}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{34}.049, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{3}.40213e\PYGZhy{}11
lambda\PYG{o}{[}\PYG{l+m}{19}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{34}.0492, \PYG{n+nv}{err}\PYG{o}{=} \PYG{l+m}{2}.41751e\PYGZhy{}10
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EigenValueProblems1}.png}
\caption{Isovalue of 11th eigenvector \(u_{4,3}-u_{3,4}\)}\label{\detokenize{models/eigen-value-problems:id3}}\label{\detokenize{models/eigen-value-problems:figeigenvalueproblems1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EigenValueProblems2}.png}
\caption{Isovalue of 12th eigenvector \(u_{4,3}+u_{3,4}\)}\label{\detokenize{models/eigen-value-problems:id4}}\label{\detokenize{models/eigen-value-problems:figeigenvalueproblems2}}\end{subfigure}
\phantomsection\label{\detokenize{models/eigen-value-problems:EigenValueProblems}}

\end{figure}

\end{sphinxadmonition}


\section{Evolution problems}
\label{\detokenize{models/evolution-problems:evolution-problems}}\label{\detokenize{models/evolution-problems::doc}}
\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} also solves evolution problems such as the heat equation:
\begin{equation}\label{equation:models/evolution-problems:eqn::heatequation}
\begin{split}\begin{array}{rcll}
    \frac{\p u}{\p t}-\mu\Delta u &=& f & \textrm{ in }\Omega\times ]0,T[\\
    u(\mathbf{x},0) &=& u_0(\mathbf{x}) & \textrm{ in }\Omega\\
    \left(\p u/\p n\right)(\mathbf{x},t) &=& 0 & \textrm{ on }\p\Omega\times ]0,T[
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
with a positive viscosity coefficient \(\mu\) and homogeneous Neumann boundary conditions.

\sphinxAtStartPar
We solve \eqref{equation:models/evolution-problems:eqn::heatequation} by FEM in space and finite differences in time.

\sphinxAtStartPar
We use the definition of the partial derivative of the solution in the time derivative:
\begin{equation*}
\begin{split}\frac{\p u}{\p t}(x,y,t) = \lim_{\tau \to 0}\frac{u(x,y,t)-u(x,y,t-\tau )}{\tau }\end{split}
\end{equation*}
\sphinxAtStartPar
which indicates that \(u^m(x,y)=u(x,y,m\tau )\) will satisfy approximatively:
\begin{equation*}
\begin{split}\frac{\p u}{\p t}(x,y,m\tau )\simeq \frac{u^m(x,y)-u^{m-1}(x,y)}{\tau }\end{split}
\end{equation*}
\sphinxAtStartPar
The time discretization of heat equation \eqref{equation:models/evolution-problems:eqn::heatequation} is as follows, \(\forall m=0,\cdots,[T/\tau ]\):
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \frac{u^{m+1}-u^{m}}{\tau }-\mu\Delta u^{m+1} &=& f^{m+1} & \textrm{ in }\Omega\\
    u^0(\mathbf{x}) &=& u_0(\mathbf{x}) & \textrm{ in }\Omega\\
    \p u^{m+1}/\p n(\mathbf{x}) &=& 0 & \textrm{ on }\p\Omega
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
which is so\sphinxhyphen{}called \sphinxstyleemphasis{backward Euler method} for \eqref{equation:models/evolution-problems:eqn::heatequation}.

\sphinxAtStartPar
To obtain the variational formulation, multiply with the test function \(v\) both sides of the equation:
\begin{equation*}
\begin{split}\int_{\Omega}\{u^{m+1}v-\tau \Delta u^{m+1}v\}=\int_{\Omega}\{u^m+\tau f^{m+1}\}v\end{split}
\end{equation*}
\sphinxAtStartPar
By the divergence theorem, we have:
\begin{equation*}
\begin{split}\int_{\Omega}\{u^{m+1}v+\tau\nabla u^{m+1}\cdot \nabla v\}
-\int_{\p\Omega} \tau \left( \p u^{m+1}/\p n\right) v
=\int_{\Omega }\{u^mv+\tau f^{m+1}v\}\end{split}
\end{equation*}
\sphinxAtStartPar
By the boundary condition \(\p u^{m+1}/\p n=0\), it follows that:
\begin{equation}\label{equation:models/evolution-problems:eqn::heatequationBWE}
\begin{split}\int_{\Omega} \{u^{m+1}v+\tau \nabla u^{m+1}\cdot \nabla v\}
-\int_{\Omega }\{u^mv+\tau f^{m+1}v\}
=0\end{split}
\end{equation}
\sphinxAtStartPar
Using the identity just above, we can calculate the finite element approximation \(u_h^m\) of \(u^m\) in a step\sphinxhyphen{}by\sphinxhyphen{}step manner with respect to \(t\).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example

\sphinxAtStartPar
We now solve the following example with the exact solution \(u(x,y,t)=tx^4\), \(\Omega = ]0,1[^2\).
\begin{equation*}
\begin{split}\begin{array}{rcll}
    \frac{{\p u}}{{\p t}} - \mu \Delta u &=& x^4 - \mu 12tx^2 & \textrm{ in }\Omega\times ]0,3[\\
    u(x,y,0) &=& 0 & \textrm{ on }\Omega\\
    \left. u \right|_{\p\Omega} &=& t*x^4
\end{array}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{,} \PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{g}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{dHeat} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{+} \PYG{n}{dt}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{uu}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{\PYGZhy{}} \PYG{n}{dt}\PYG{o}{*}\PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{uu} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kp}{t} \PYG{o}{=} \PYG{k+kp}{t}\PYG{o}{+}\PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{*}\PYG{l+m+mi}{12}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{g} \PYG{o}{=} \PYG{k+kp}{t}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{n}{uu} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{dHeat}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} L\PYGZca{}2\PYGZhy{}Error=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the last statement, the \(L^2\)\sphinxhyphen{}error \(\left(\int_{\Omega}\left| u-tx^4\right|^2\right)^{1/2}\) is calculated at \(t=m\tau, \tau =0.1\). At \(t=0.1\), the error is 0.000213269. The errors increase with \(m\) and 0.00628589 at \(t=3\).

\sphinxAtStartPar
The iteration of the backward Euler \eqref{equation:models/evolution-problems:eqn::heatequationBWE} is made by {\hyperref[\detokenize{references/loops:loopfor}]{\sphinxcrossref{\DUrole{std,std-ref}{for loop}}}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The stiffness matrix in the loop is used over and over again.
\sphinxstylestrong{FreeFEM} support reuses of stiffness matrix.
\end{sphinxadmonition}
\end{sphinxadmonition}


\subsection{Mathematical Theory on Time Difference Approximations.}
\label{\detokenize{models/evolution-problems:mathematical-theory-on-time-difference-approximations}}
\sphinxAtStartPar
In this section, we show the advantage of implicit schemes.
Let \(V, H\) be separable Hilbert space and \(V\) is dense in \(H\).
Let \(a\) be a continuous bilinear form over \(V \times V\) with coercivity and symmetry.

\sphinxAtStartPar
Then \(\sqrt{a(v,v)}\) become equivalent to the norm \(\| v\|\) of \(V\).

\sphinxAtStartPar
\sphinxstylestrong{Problem Ev(f,Omega)}: For a given \(f\in L^2(0,T;V'),\, u^0\in H\)
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \frac{d}{dt}(u(t),v)+a(u(t),v)&=&( f(t),v)\qquad \forall v\in V,\quad a.e. \, t\in [0,T]\\
    u(0)&=&u^0\nonumber
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(V'\) is the dual space of \(V\).

\sphinxAtStartPar
Then, there is an unique solution \(u\in L^{\infty}(0,T;H)\cap L^2(0,T;V)\).

\sphinxAtStartPar
Let us denote the time step by \(\tau>0\), \(N_T=[T/\tau]\).
For the discretization, we put \(u^n = u(n\tau)\) and consider the time difference for each \(\theta\in [0,1]\)
\begin{equation}\label{equation:models/evolution-problems:eqn::t-method}
\begin{split}\begin{array}{rcl}
    \frac{1}{\tau}\left( u_h^{n+1}-u_h^n,\phi_i\right) +a\left( u_h^{n+\theta},\phi_i\right)&=&\langle f^{n+\theta},\phi_i\rangle\\
    i=1,&\cdots&, m,\quad n=0,\cdots, N_T\nonumber\\
    u_h^{n+\theta}&=&\theta u_h^{n+1}+(1-\theta)u_h^n,\\
    f^{n+\theta}&=&\theta f^{n+1}+(1-\theta)f^n\nonumber
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
Formula \eqref{equation:models/evolution-problems:eqn::t-method} is the \sphinxstyleemphasis{forward Euler scheme} if \(\theta=0\), \sphinxstyleemphasis{Crank\sphinxhyphen{}Nicolson scheme} if \(\theta=1/2\), the \sphinxstyleemphasis{backward Euler scheme} if \(\theta=1\).

\sphinxAtStartPar
Unknown vectors \(u^n=(u_h^1,\cdots,u_h^M)^T\) in
\begin{equation*}
\begin{split}u_h^n(x)=u^n_1\phi_1(x)+\cdots+u^n_m\phi_m(x),\quad u^n_1,\cdots,u^n_m\in \R\end{split}
\end{equation*}
\sphinxAtStartPar
are obtained from solving the matrix
\begin{equation}\label{equation:models/evolution-problems:eqn::Evolution-1}
\begin{split}(M+\theta\tau A)u^{n+1}=\{M-(1-\theta)\tau A\}u^n
+\tau\left\{\theta f^{n+1}+(1-\theta)f^n\right\}\\
M=(m_{ij}),\quad m_{ij}=(\phi_j,\phi_i),\qquad
A=(a_{ij}),\quad a_{ij}=a(\phi_j,\phi_i)\nonumber\end{split}
\end{equation}
\sphinxAtStartPar
Refer \sphinxcite{bibliography:tabata1994}, pp.70\textendash{}75 for solvability of \eqref{equation:models/evolution-problems:eqn::Evolution-1}. The stability of \eqref{equation:models/evolution-problems:eqn::Evolution-1} is in \sphinxcite{bibliography:tabata1994}, Theorem 2.13:

\sphinxAtStartPar
Let \(\{\mathcal{T}_h\}_{h\downarrow 0}\) be regular triangulations (see {\hyperref[\detokenize{documentation/mesh-generation:meshregulartriangulation}]{\sphinxcrossref{\DUrole{std,std-ref}{Regular Triangulation}}}}).
Then there is a number \(c_0>0\) independent of \(h\) such that,
\begin{equation*}
\begin{split}|u_h^n|^2\le
\left\{
\begin{array}{lr}
\frac{1}{\delta}\left\{
|u^0_h|^2+\tau \sum_{k=0}^{n-1}\|f^{k+\theta}\|^2_{V_h'}
\right\}&\theta\in [0,1/2)\\
|u^0_h|^2+\tau \sum_{k=0}^{n-1}\|f^{k+\theta}\|^2_{V_h'}&\theta\in [1/2,1]
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
if the following are satisfied:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
When \(\theta\in [0,1/2)\), then we can take a time step \(\tau\) in such a way that
\begin{quote}
\begin{equation*}
\begin{split}\tau <\frac{2(1-\delta)}{(1-2\theta)c_0^2}h^2\end{split}
\end{equation*}
\sphinxAtStartPar
for arbitrary \(\delta\in (0,1)\).
\end{quote}

\item {} 
\sphinxAtStartPar
When \(1/2\leq \theta\leq 1\), we can take \(\tau\) arbitrary.

\end{enumerate}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{tau} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;} \PYG{k+kt}{real}
\PYG{n}{theta} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{oldU}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{f0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{h} \PYG{o}{=} \PYG{k+kr}{hTriangle}\PYG{p}{;} \PYG{c+c1}{// mesh sizes for each triangle}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f} \PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{12}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{11}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// File}
\PYG{k+kt}{ofstream} \PYG{n+nf}{out}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{err02.csv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//file to store calculations}
\PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mesh size = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{h}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, time step = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{o}{/}\PYG{n}{tau}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{o}{*}\PYG{n}{tau} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{aTau} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{+} \PYG{n}{theta}\PYG{o}{*}\PYG{n}{tau}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{oldU}\PYG{o}{*}\PYG{n}{v}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{tau}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{oldU}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{oldU}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{oldU}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{tau}\PYG{o}{*}\PYG{p}{(}\PYG{n}{theta}\PYG{o}{*}\PYG{n}{f1} \PYG{o}{+} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n}{f0}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Theta loop}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{theta} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{oldU} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{theta} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{o}{/}\PYG{n}{tau}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Update}
        \PYG{k+kp}{t} \PYG{o}{=} \PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{tau}\PYG{p}{;}
        \PYG{n}{f0} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{*}\PYG{n}{tau}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{f1} \PYG{o}{=} \PYG{n}{f}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{tau}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Solve}
        \PYG{n}{aTau}\PYG{p}{;}
        \PYG{n}{oldU} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

        \PYG{c+c1}{// Plot}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+c1}{// Error}
        \PYG{n}{Vh} \PYG{n}{uex} \PYG{o}{=} \PYG{k+kp}{t}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//exact solution = tx\PYGZca{}2(1\PYGZhy{}x)\PYGZca{}2}
        \PYG{n}{Vh} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{u} \PYG{o}{\PYGZhy{}} \PYG{n}{uex}\PYG{p}{;} \PYG{c+c1}{// err = FE\PYGZhy{}sol \PYGZhy{} exact}
        \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kp}{err}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{o}{/}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{uex}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{out} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{theta} \PYG{o}{=} \PYG{n}{theta} \PYG{o}{+} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{EvolutionProblems_TimeDifference}.png}
\caption{\(\max_{x\in\Omega}\vert u_h^n(\theta)-u_{ex}(n\tau)\vert\max_{x\in\Omega}\vert u_{ex}(n\tau)\vert at n=0,1,\cdots,29\)}\label{\detokenize{models/evolution-problems:figevolutiontimediff}}\end{figure}

\sphinxAtStartPar
We can see in \hyperref[\detokenize{models/evolution-problems:figevolutiontimediff}]{Fig.\@ \ref{\detokenize{models/evolution-problems:figevolutiontimediff}}} that \(u_h^n(\theta)\) become unstable at \(\theta=0.4\), and figures are omitted in the case \(\theta<0.4\).
\end{sphinxadmonition}


\subsection{Convection}
\label{\detokenize{models/evolution-problems:convection}}
\sphinxAtStartPar
The hyperbolic equation
\begin{equation}\label{equation:models/evolution-problems:eqn::conv}
\begin{split}\p_t u +\mathbf{\alpha} \cdot \nabla u=f;\ \textrm{ for a vector-valued function }\mathbf{\alpha}\end{split}
\end{equation}
\sphinxAtStartPar
appears frequently in scientific problems, for example in the Navier\sphinxhyphen{}Stokes equations, in the Convection\sphinxhyphen{}Diffusion equation, etc.

\sphinxAtStartPar
In the case of 1\sphinxhyphen{}dimensional space, we can easily find the general solution \((x,t)\mapsto u(x,t)=u^0(x-\alpha t)\) of the following equation, if \(\alpha\) is constant,
\begin{equation}\label{equation:models/evolution-problems:eqn::conv0}
\begin{split}\begin{array}{rcl}
    \p_t u +\alpha\p_x u &=& 0\\
    u(x,0) &=& u^0(x),
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
because \(\p_t u +\alpha\p_x u=-\alpha\dot{u}^0+a\dot{u}^0=0\), where \(\dot{u}^0=du^0(x)/dx\).

\sphinxAtStartPar
Even if \(\alpha\) is not constant, the construction works on similar principles.
One begins with the ordinary differential equation (with the convention that \(\alpha\) is prolonged by zero apart from \((0,L)\times (0,T)\)):
\begin{equation*}
\begin{split}\dot{X}(\tau )=+\alpha(X(\tau ),\tau ),\ \tau \in (0,t)\quad X(t)=x\end{split}
\end{equation*}
\sphinxAtStartPar
In this equation \(\tau\) is the variable and \(x,t\) are parameters, and we denote the solution by \(X_{x,t}(\tau )\).
Then it is noticed that \((x,t)\rightarrow v(X(\tau),\tau)\) in \(\tau=t\) satisfies the equation
\begin{equation*}
\begin{split}\p _{t}v+\alpha\p _{x}v=\p _{t}X\dot{v}+a\p _{x}X\dot{v}%
=0\end{split}
\end{equation*}
\sphinxAtStartPar
and by the definition \(\p _{t}X=\dot{X}=+\alpha\) and \(\p_{x}X=\p _{x}x\) in \(\tau=t\), because if \(\tau =t\) we have \(X(\tau )=x\).

\sphinxAtStartPar
The general solution of \eqref{equation:models/evolution-problems:eqn::conv0} is thus the value of the boundary condition in \(X_{x, t}(0)\), that is to say \(u(x,t)=u^{0}(X_{x,t}(0))\) where \(X_{x,t}(0)\) is on the \(x\) axis, \(u(x,t)=u^{0}(X_{x,t}(0))\) if \(X_{x,t}(0)\) is on the axis of \(t\).

\sphinxAtStartPar
In higher dimension \(\Omega \subset R^{d},~d=2,3\), the equation for the convection is written
\begin{equation*}
\begin{split}\p _{t}u+\mathbf{\alpha}\cdot \nabla u=0\hbox{ in }\Omega \times (0,T)\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathbf{a}(x,t)\in \R^{d}\).

\sphinxAtStartPar
\sphinxstylestrong{FreeFEM} implements the Characteristic\sphinxhyphen{}Galerkin method for convection operators.
Recall that the equation \eqref{equation:models/evolution-problems:eqn::conv} can be discretized as
\begin{equation*}
\begin{split}\frac{Du}{Dt} = f\;\;\textrm{i.e. }\frac{du}{dt}\left( {X(t),t} \right) = f\left(X( t ),t \right)\textrm{ where }\frac{dX}{dt}( t ) = \mathbf{\alpha}( {X(t),t})\end{split}
\end{equation*}
\sphinxAtStartPar
where \(D\) is the total derivative operator.
So a good scheme is one step of backward convection by the method of Characteristics\sphinxhyphen{}Galerkin
\begin{equation}\label{equation:models/evolution-problems:eqn::Charac}
\begin{split}\frac{1}{{\tau }}\left(u^{m + 1}(x) - u^m(X^m(x))\right) = f^m (x)\end{split}
\end{equation}
\sphinxAtStartPar
where \(X^m (x)\) is an approximation of the solution at \(t = m\tau\) of the ordinary differential equation
\begin{equation*}
\begin{split}\frac{d\mathbf{X}}{dt}(t) = \mathbf{\alpha}^m(\mathbf{X}(t)), \mathbf{X}((m + 1)\tau) = x.\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mathbf{\alpha}^m(x)=(\alpha_1(x,m\tau ),\alpha_2(x,m\tau))\).
Because, by Taylor’s expansion, we have
\begin{equation}\label{equation:models/evolution-problems:eqn::conv1}
\begin{split}\begin{array}{rcl}
    u^m(\mathbf{X}(m\tau ))&=&
    u^m(\mathbf{X}((m+1)\tau )) -
    \tau \sum_{i=1}^d \frac{\p u^m}{\p x_i}(\mathbf{X}((m+1)\tau ))
    \frac{\p X_i}{\p t}((m+1)\tau )
    +o(\tau )\nonumber\\
    &=&u^m(x)-\tau \mathbf{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau )
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
where \(X_i(t)\) are the i\sphinxhyphen{}th component of \(\mathbf{X}(t)\), \(u^m(x)=u(x,m\tau )\) and we used the chain rule and \(x=\mathbf{X}((m+1)\tau )\).
From \eqref{equation:models/evolution-problems:eqn::conv1}, it follows that
\begin{equation*}
\begin{split}u^m(X^m(x))=u^m(x)-\tau \mathbf{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau )\end{split}
\end{equation*}
\sphinxAtStartPar
Also we apply Taylor’s expansion for \(t \rightarrow u^m(x-\mathbf{\alpha}^m(x)t),0\le t\le \tau\), then
\begin{equation*}
\begin{split}u^m(x-\mathbf{\alpha}\tau )=u^m(x)-\tau \mathbf{\alpha}^m(x)\cdot \nabla u^m(x)+o(\tau ).\end{split}
\end{equation*}
\sphinxAtStartPar
Putting

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{convect}}\(\left( {\mathbf{\alpha},-\tau ,u^m } \right)\approx u^m \left(x - \mathbf{\alpha}^m\tau \right)\)

\sphinxAtStartPar
we can get the approximation

\sphinxAtStartPar
\(u^m \left( {X^m( x )} \right) \approx\) \sphinxcode{\sphinxupquote{convect}} \(\left( {[a_1^m ,a_2^m],-\tau ,u^m } \right)\) by \(X^m \approx x \mapsto x- \tau [a_1^m(x) ,a_2^m(x)]\)

\sphinxAtStartPar
A classical convection problem is that of the “rotating bell” (quoted from \sphinxcite{bibliography:lucquin1998}, p.16).

\sphinxAtStartPar
Let \(\Omega\) be the unit disk centered at 0, with its center rotating with speed \(\alpha_1 = y,\, \alpha_2 = -x\).
We consider the problem \eqref{equation:models/evolution-problems:eqn::conv} with \(f=0\) and the initial condition \(u(x,0)=u^0(x)\), that is, from \eqref{equation:models/evolution-problems:eqn::Charac}

\sphinxAtStartPar
\(u^{m + 1}(x) = u^m(X^m(x))\approx\) \sphinxcode{\sphinxupquote{convect}}\((\mathbf{\alpha},-\tau ,u^m)\)

\sphinxAtStartPar
The exact solution is \(u(x, t) = u(\mathbf{X}(t))\) where \(\mathbf{X}\) equals \(x\) rotated around the origin by an angle \(\theta = -t\) (rotate in clockwise).
So, if \(u^0\) in a 3D perspective looks like a bell, then \(u\) will have exactly the same shape, but rotated by the same amount.
The program consists in solving the equation until \(T = 2\pi\), that is for a full revolution and to compare the final solution with the initial one; they should be equal.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Convect

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.17}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u0}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{a1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{a2} \PYG{o}{=} \PYG{k+kr}{x}\PYG{p}{;} \PYG{c+c1}{//rotation velocity}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Initialization}
\PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{m} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{k+kr}{m}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
    \PYG{n}{u0} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Convect}
    \PYG{n}{u} \PYG{o}{=} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a1}\PYG{p}{,} \PYG{n}{a2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{u0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//u\PYGZca{}\PYGZob{}m+1\PYGZcb{}=u\PYGZca{}m(X\PYGZca{}m(x))}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ t=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{k+kp}{t}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, max=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The scheme \sphinxcode{\sphinxupquote{convect}} is unconditionally stable, then the bell become lower and lower (the maximum of \(u^{37}\) is \(0.406\) as shown in \hyperref[\detokenize{models/evolution-problems:figevolutionconvect}]{Fig.\@ \ref{\detokenize{models/evolution-problems:figevolutionconvect}}}.
\end{sphinxadmonition}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblem_Convect}.png}
\caption{\(u^0=e^{-10((x-0.3)^2 +(y-0.3)^2)}\)}\label{\detokenize{models/evolution-problems:id6}}\label{\detokenize{models/evolution-problems:figevolutionconvect}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblem_Convect2}.png}
\caption{The bell at \(t=6.29\)}\label{\detokenize{models/evolution-problems:id7}}\label{\detokenize{models/evolution-problems:figevolutionconvect2}}\end{subfigure}


\end{figure}

\end{sphinxadmonition}


\subsection{2D Black\sphinxhyphen{}Scholes equation for an European Put option}
\label{\detokenize{models/evolution-problems:d-black-scholes-equation-for-an-european-put-option}}\label{\detokenize{models/evolution-problems:EvolutionProblem_Convect}}
\sphinxAtStartPar
In mathematical finance, an option on two assets is modeled by a Black\sphinxhyphen{}Scholes equations in two space variables, (see for example \sphinxcite{bibliography:wilmott1995} or \sphinxcite{bibliography:achdou2005}).
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \p _t u &+& \frac{{\left( {\sigma _1 x } \right)^2 }}{2}\frac{{\p ^2 u}}{{\p x^2 }} + \frac{{\left( {\sigma _2 y } \right)^2 }}{2}\frac{{\p ^2 u}}{{\p y^2 }} \\
    &&{\rm{ }} + \rho x y \frac{{\p ^2 u}}{{\p x \p y }} + rS_1 \frac{{\p u}}{{\p x }} + rS_2 \frac{{\p u}}{{\p y }} - rP = 0 \nonumber
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
which is to be integrated in \(\left( {0,T} \right) \times \R^ + \times \R^ +\) subject to, in the case of a put
\begin{equation*}
\begin{split}u\left( {x , y ,T} \right) = \left( {K - \max \left( {x ,y } \right)} \right)^+\end{split}
\end{equation*}
\sphinxAtStartPar
Boundary conditions for this problem may not be so easy to device.
As in the one dimensional case the PDE contains boundary conditions on the axis \(x_1 = 0\) and on the axis \(x_2 = 0\), namely two one dimensional Black\sphinxhyphen{}Scholes equations driven respectively by the data \(u\left( {0, + \infty ,T} \right)\) and \(u\left( { + \infty ,0,T} \right)\).
These will be automatically accounted for because they are embedded in the PDE.
So if we do nothing in the variational form (i.e. if we take a Neumann boundary condition at these two axis in the strong form) there will be no disturbance to these.
At infinity in one of the variable, as in 1D, it makes sense to impose \(u=0\).
We take
\begin{equation*}
\begin{split}\sigma _1  = 0.3,\;\;\sigma _2  = 0.3,\;\;\rho  = 0.3,\;\;r = 0.05,\;\;K = 40,\;\;T = 0.5\end{split}
\end{equation*}
\sphinxAtStartPar
An implicit Euler scheme is used and a mesh adaptation is done every 10 time steps.
To have an unconditionally stable scheme, the first order terms are treated by the Characteristic Galerkin method, which, roughly, approximates
\begin{equation*}
\begin{split}\frac{{\p u}}{{\p t}} + a_1 \frac{{\p u}}{{\p x}} + a_2 \frac{{\p u}}{{\p y}} \approx \frac{1}{{\tau }}\left( {u^{n + 1} \left( x \right) - u^n \left( {x - \mathbf{\alpha}\tau } \right)} \right)\end{split}
\end{equation*}
\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Black\sphinxhyphen{}Scholes

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{LL} \PYG{o}{=} \PYG{l+m+mi}{80}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{sigx} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{sigy} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{rho} \PYG{o}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{L}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{LL}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{K}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{xveloc}\PYG{p}{,} \PYG{n}{yveloc}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{*}\PYG{n}{dt} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;} \PYG{k+kr}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{abserror}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbjacoby}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
        \PYG{k+kp}{err}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{,} \PYG{k+kp}{omega}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{ratio}\PYG{o}{=}\PYG{l+m+mf}{1.8}\PYG{p}{,} \PYG{k+kp}{nbsmooth}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
        \PYG{k+kp}{splitpbedge}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{maxsubdiv}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kp}{rescaling}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{xveloc} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{r} \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{n}{yveloc} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{r} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Update}
    \PYG{n}{uold} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{solve} \PYG{n+nf}{eq1}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{j}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{u}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{p}{(}\PYG{n}{r}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{sigx}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{2}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{sigy}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{/}\PYG{l+m+mi}{2}
            \PYG{o}{+} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sigx}\PYG{o}{*}\PYG{n}{sigy}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{/}\PYG{l+m+mi}{2}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{v}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xveloc}\PYG{p}{,} \PYG{n}{yveloc}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{,} \PYG{n}{uold}\PYG{p}{)}\PYG{o}{/}\PYG{n}{dt}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{j} \PYG{o}{=} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Results are shown on \hyperref[\detokenize{models/evolution-problems:figevolutionblacksholes1}]{Fig.\@ \ref{\detokenize{models/evolution-problems:figevolutionblacksholes1}}} and \hyperref[\detokenize{models/evolution-problems:figevolutionblacksholes2}]{Fig.\@ \ref{\detokenize{models/evolution-problems:figevolutionblacksholes2}}}.

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblems_BlackSholes}.png}
\caption{The adapted triangulation}\label{\detokenize{models/evolution-problems:id8}}\label{\detokenize{models/evolution-problems:figevolutionblacksholes1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EvolutionProblems_BlackSholes2}.png}
\caption{The level line of the European basquet put option}\label{\detokenize{models/evolution-problems:id9}}\label{\detokenize{models/evolution-problems:figevolutionblacksholes2}}\end{subfigure}
\phantomsection\label{\detokenize{models/evolution-problems:EvolutionProblems_BlackSholes}}

\end{figure}

\end{sphinxadmonition}


\section{Navier\sphinxhyphen{}Stokes equations}
\label{\detokenize{models/navier-stokes-equations:navier-stokes-equations}}\label{\detokenize{models/navier-stokes-equations::doc}}
\sphinxAtStartPar
The Stokes equations are: for a given \(\mathbf{f}\in L^2(\Omega)^2\):
\begin{equation}\label{equation:models/navier-stokes-equations:eqn::Stokes}
\begin{split}\left.\begin{array}{cl}
    -\Delta \mathbf{u}+\nabla p & =\mathbf{f} \\
    \nabla\cdot \mathbf{u} &=0
\end{array}\right\}\quad \hbox{ in }\Omega\end{split}
\end{equation}
\sphinxAtStartPar
where \(\mathbf{u}=(u_1,u_2)\) is the velocity vector and \(p\) the pressure.
For simplicity, let us choose Dirichlet boundary conditions on the velocity, \(\mathbf{u}=\mathbf{u}_{\Gamma}\) on \(\Gamma\).

\sphinxAtStartPar
In \sphinxcite{bibliography:temam1977}, Theorem 2.2, there is a weak form of \eqref{equation:models/navier-stokes-equations:eqn::Stokes}:

\sphinxAtStartPar
Find \(\mathbf{v}=(v_1,v_2)\in \mathbf{V}(\Omega)\):
\begin{equation*}
\begin{split}\mathbf{V}(\Omega)=\{\mathbf{w}\in H^1_0(\Omega)^2|\; \textrm{div}\mathbf{w}=0\}\end{split}
\end{equation*}
\sphinxAtStartPar
which satisfy:
\begin{equation*}
\begin{split}\sum_{i=1}^2\int_{\Omega}\nabla u_i\cdot \nabla v_i=\int_{\Omega}\mathbf{f}\cdot \mathbf{w}
\quad \textrm{for all }v\in V\end{split}
\end{equation*}
\sphinxAtStartPar
Here it is used the existence \(p\in H^1(\Omega)\) such that \(\mathbf{u}=\nabla p\), if:
\begin{equation*}
\begin{split}\int_{\Omega}\mathbf{u}\cdot \mathbf{v}=0\quad \textrm{for all }\mathbf{v}\in V\end{split}
\end{equation*}
\sphinxAtStartPar
Another weak form is derived as follows: We put:
\begin{equation*}
\begin{split}\mathbf{V}=H^1_0(\Omega)^2;\quad
W=\left\{q\in L^2(\Omega)\left|\; \int_{\Omega}q=0\right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
By multiplying the first equation in \eqref{equation:models/navier-stokes-equations:eqn::Stokes} with \(v\in V\) and the second with \(q\in W\), subsequent integration over \(\Omega\), and an application of Green’s formula, we have:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    \int_{\Omega}\nabla\mathbf{u}\cdot \nabla\mathbf{v}-\int_{\Omega}\textrm{div}\mathbf{v}\, p
    &=&\int_{\Omega}\mathbf{f}\cdot\mathbf{v}\\
    \int_{\Omega}\textrm{div}\mathbf{u}\, q&=&0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
This yields the weak form of \eqref{equation:models/navier-stokes-equations:eqn::Stokes}:

\sphinxAtStartPar
Find \((\mathbf{u},p)\in \mathbf{V}\times W\) such that:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\mathbf{u},\mathbf{v})+b(\mathbf{v},p)&=&(\mathbf{f},\mathbf{v})\\
    b(\mathbf{u},q)&=&0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
for all \((\mathbf{v},q)\in V\times W\), where:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(\mathbf{u},\mathbf{v})&=&\int_{\Omega}\nabla \mathbf{u}\cdot \nabla\mathbf{v}
    =\sum_{i=1}^2\int_{\Omega}\nabla u_i\cdot \nabla v_i\\
    b(\mathbf{u},q)&=&-\int_{\Omega}\textrm{div}\mathbf{u}\, q
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
Now, we consider finite element spaces \(\mathbf{V}_h\subset \mathbf{V}\) and \(W_h\subset W\), and we assume the following basis functions:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    &&\mathbf{V}_h=V_h\times V_h,\quad
    V_h=\{v_h|\; v_h=v_1\phi_1+\cdots +v_{M_V}\phi_{M_V}\},\\
    &&W_h=\{q_h|\; q_h=q_1\varphi_1+\cdots +q_{M_W}\varphi_{M_W}\}
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The discrete weak form is: Find \((\mathbf{u}_{h},p_{h}) \in \mathbf{V}_{h} \times W_{h}\) such that:
\begin{equation}\label{equation:models/navier-stokes-equations:eqn::vfStokes}
\begin{split}\begin{array}{cll}
    a(\mathbf{u}_h,\mathbf{v}_h)+b(\mathbf{v}_h,p) &= (\mathbf{f},\mathbf{v}_h) ,
    &\forall \mathbf{v}_{h} \in \mathbf{V}_{h} \\
    b(\mathbf{u}_h,q_h)&= 0,
    &\forall q_{h} \in W_{h}
\end{array}\end{split}
\end{equation}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Assume that:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
There is a constant \(\alpha_h>0\) such that:
\begin{quote}
\begin{equation*}
\begin{split}a(\mathbf{v}_h,\mathbf{v}_h)\ge \alpha\| \mathbf{v}_h\|_{1,\Omega}^2\quad \textrm{for all }\mathbf{v}_h\in Z_h\end{split}
\end{equation*}
\sphinxAtStartPar
where:
\begin{equation*}
\begin{split}Z_h=\{\mathbf{v}_h\in \mathbf{V}_h|\; b(\mathbf{w}_h,q_h)=0\quad \textrm{for all }q_h\in W_h\}\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxAtStartPar
There is a constant \(\beta_h>0\) such that:
\begin{quote}
\begin{equation*}
\begin{split}\sup_{\mathbf{v}_h\in \mathbf{V}_h}\frac{b(\mathbf{v}_h,q_h)}{\| \mathbf{v}_h\|_{1,\Omega}}
\ge \beta_h\| q_h\|_{0,\Omega}\quad \textrm{for all }q_h\in W_h\end{split}
\end{equation*}
\sphinxAtStartPar
Then we have an unique solution \((\mathbf{u}_h,p_h)\) of \eqref{equation:models/navier-stokes-equations:eqn::vfStokes} satisfying:
\begin{equation*}
\begin{split}\| \mathbf{u}-\mathbf{u}_h\|_{1,\Omega}+\| p-p_h\|_{0,\Omega}
\le C\left(
\inf_{\mathbf{v}_h\in \mathbf{V}_h}\| u-v_h\|_{1,\Omega}
+\inf_{q_h\in W_h}\| p-q_h\|_{0,\Omega}\right)\end{split}
\end{equation*}
\sphinxAtStartPar
with a constant \(C>0\) (see e.g. \sphinxcite{bibliography:roberts1993}, Theorem 10.4).
\end{quote}

\end{enumerate}
\end{sphinxadmonition}

\sphinxAtStartPar
Let us denote that:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    A&=&(A_{ij}),\, A_{ij}=\int_{\Omega}\nabla \phi_j\cdot \nabla \phi_i\qquad
    i,j=1,\cdots,M_{\mathbf{V}}\\
    \mathbf{B}&=&(Bx_{ij},By_{ij}),\,
    Bx_{ij}=-\int_{\Omega}\p \phi_j/\p x\, \varphi_i\qquad
    By_{ij}=-\int_{\Omega}\p \phi_j/\p y\, \varphi_i\nonumber\\
    &&\qquad i=1,\cdots,M_W;j=1,\cdots,M_V\nonumber
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
then \eqref{equation:models/navier-stokes-equations:eqn::vfStokes} is written by:
\begin{equation*}
\begin{split}\left(
\begin{array}{cc}
    \mathbf{A}&\mathbf{\mathbf{B}}^*\\
    \mathbf{B}&0
\end{array}
\right)
\left(
\begin{array}{cc}
    \mathbf{U}_h\\
    \{p_h\}
\end{array}
\right)
=
\left(
\begin{array}{cc}
    \mathbf{F}_h\\
    0
\end{array}
\right)\end{split}
\end{equation*}
\sphinxAtStartPar
where:
\begin{equation*}
\begin{split}&\mathbf{A}=\left(
\begin{array}{cc}
A&0\\
0&A
\end{array}
\right)
\qquad
\mathbf{B}^*=\left\{
\begin{array}{c}
Bx^T\\
By^T
\end{array}
\right\}
\qquad
\mathbf{U}_h=\left\{
\begin{array}{c}
\{u_{1,h}\}\\
\{u_{2,h}\}
\end{array}
\right\}
\qquad
\mathbf{F}_h=\left\{
\begin{array}{c}
\{\textstyle{\int_{\Omega}f_1\phi_i}\}\\
\{\textstyle{\int_{\Omega}f_2\phi_i}\}
\end{array}
\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Penalty method:} This method consists of replacing \eqref{equation:models/navier-stokes-equations:eqn::vfStokes} by a more regular problem:

\sphinxAtStartPar
Find \((\mathbf{v}_h^{\epsilon},p_h^{\epsilon})\in \mathbf{V}_h\times \tilde{W}_{h}\) satisfying:
\begin{equation}\label{equation:models/navier-stokes-equations:eqn::PvfStokes}
\begin{split}\begin{array}{cll}
    a(\mathbf{u}_h^\epsilon,\mathbf{v}_h)+b(\mathbf{v}_h,p_h^{\epsilon}) &= (\mathbf{f},\mathbf{v}_h) ,
    &\forall \mathbf{v}_{h} \in \mathbf{V}_{h} \\
    b(\mathbf{u}_h^{\epsilon},q_h)-\epsilon(p_h^{\epsilon},q_h)&= 0,
    &\forall q_{h} \in \tilde{W}_{h}
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
where \(\tilde{W}_h\subset L^2(\Omega)\).
Formally, we have:
\begin{equation*}
\begin{split}\textrm{div}\mathbf{u}_h^{\epsilon}=\epsilon p_h^{\epsilon}\end{split}
\end{equation*}
\sphinxAtStartPar
and the corresponding algebraic problem:
\begin{equation*}
\begin{split}\left(
\begin{array}{cc}
\mathbf{A}&B^*\\
B&-\epsilon I
\end{array}
\right)
\left(
\begin{array}{cc}
\mathbf{U}_h^{\epsilon}\\
\{p_h^{\epsilon}\}
\end{array}
\right)
=
\left(
\begin{array}{cc}
\mathbf{F}_h\\
0
\end{array}
\right)\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
We can eliminate \(p_h^\epsilon=(1/\epsilon)BU_h^{\epsilon}\) to obtain:
\begin{equation}\label{equation:models/navier-stokes-equations:eqn::StiffPvfStokes}
\begin{split}(A+(1/\epsilon)B^*B)\mathbf{U}_h^{\epsilon}=\mathbf{F}_h^{\epsilon}\end{split}
\end{equation}
\sphinxAtStartPar
Since the matrix \(A+(1/\epsilon)B^*B\) is symmetric, positive\sphinxhyphen{}definite, and sparse, \eqref{equation:models/navier-stokes-equations:eqn::StiffPvfStokes} can be solved by known technique.
There is a constant \(C>0\) independent of \(\epsilon\) such that:
\begin{equation*}
\begin{split}\|\mathbf{u}_h-\mathbf{u}_h^\epsilon\|_{1,\Omega}+
\|p_h-p_h^{\epsilon}\|_{0,\Omega}\le C\epsilon\end{split}
\end{equation*}
\sphinxAtStartPar
(see e.g. \sphinxcite{bibliography:roberts1993}, 17.2)
\end{sphinxadmonition}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Cavity

\sphinxAtStartPar
The driven cavity flow problem is solved first at zero Reynolds number (Stokes flow) and then at Reynolds 100.
The velocity pressure formulation is used first and then the calculation is repeated with the stream function vorticity formulation.

\sphinxAtStartPar
We solve the driven cavity problem by the penalty method \eqref{equation:models/navier-stokes-equations:eqn::PvfStokes} where \(\mathbf{u}_{\Gamma}\cdot \mathbf{n}=0\) and \(\mathbf{u}_{\Gamma}\cdot \mathbf{s}=1\) on the top boundary and zero elsewhere (\(\mathbf{n}\) is the unit normal to \(\Gamma\), and \(\mathbf{s}\) the unit tangent to \(\Gamma\)).

\sphinxAtStartPar
The mesh is constructed by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We use a classical Taylor\sphinxhyphen{}Hood element technique to solve the problem:

\sphinxAtStartPar
The velocity is approximated with the \(P_{2}\) FE (\(X_{h}\) space), and the pressure is approximated with the \(P_{1}\) FE (\(M_{h}\) space), where:
\begin{equation*}
\begin{split}X_{h} = \left\{ \mathbf{v} \in H^{1}(]0,1[^2) \left|\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{2}\right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
and:
\begin{equation*}
\begin{split}M_{h} = \left\{ v \in H^{1}(]0,1[^2) \left|\; \forall K \in \mathcal{T}_{h}\quad v_{|K} \in P_{1} \right.\right\}\end{split}
\end{equation*}
\sphinxAtStartPar
The FE spaces and functions are constructed by:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//definition of the velocity component space}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//definition of the pressure space}
\PYG{n}{Xh} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The Stokes operator is implemented as a system\sphinxhyphen{}solve for the velocity \((u1,u2)\) and the pressure \(p\).
The test function for the velocity is \((v1,v2)\) and \(q\) for the pressure, so the variational form \eqref{equation:models/navier-stokes-equations:eqn::vfStokes} in freefem language is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{solve} \PYG{n+nf}{Stokes} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{p}{(}
            \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{0.000001}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each unknown has its own boundary conditions.

\sphinxAtStartPar
If the streamlines are required, they can be computed by finding \(\psi\) such that \(rot\psi=u\) or better:
\begin{equation*}
\begin{split}-\Delta\psi=\nabla\times u\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Xh} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{;}

\PYG{k+kt}{solve} \PYG{n+nf}{streamlines} \PYG{p}{(}\PYG{n}{psi}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{psi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{phi}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{psi}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the Navier\sphinxhyphen{}Stokes equations are solved:
\begin{equation*}
\begin{split}{\p {u}\over\p t} +u\cdot\nabla u-\nu \Delta u+\nabla p=0, \nabla\cdot u=0\end{split}
\end{equation*}
\sphinxAtStartPar
with the same boundary conditions and with initial conditions \(u=0\).

\sphinxAtStartPar
This is implemented by using the convection operator \sphinxcode{\sphinxupquote{convect}} for the term \({\p u\over\p t} +u\cdot\nabla u\), giving a discretization in time
\begin{equation*}
\begin{split}\begin{array}{cl}
    \frac{1}{\tau } (u^{n+1}-u^n\circ X^n) -\nu\Delta u^{n+1} + \nabla p^{n+1} &=0,\\
    \nabla\cdot u^{n+1} &= 0
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
The term \(u^n\circ X^n(x)\approx u^n(x-u^n(x)\tau )\) will be computed by the operator \sphinxcode{\sphinxupquote{convect}}, so we obtain:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{NS} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Crout}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{nu} \PYG{o}{*} \PYG{p}{(}
              \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{0.000001}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{up1}\PYG{p}{,}\PYG{n}{up2}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{up1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v1}
        \PYG{o}{\PYGZhy{}} \PYG{n}{alpha}\PYG{o}{*}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{up1}\PYG{p}{,}\PYG{n}{up2}\PYG{p}{]}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,}\PYG{n}{up2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{up1} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{;}
    \PYG{n}{up2} \PYG{o}{=} \PYG{n}{u2}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{NS}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[u1,u2] and p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that the stiffness matrices are reused (keyword \sphinxcode{\sphinxupquote{init=i}})

\sphinxAtStartPar
The complete script is available in {\hyperref[\detokenize{examples/misc:examplecavity}]{\sphinxcrossref{\DUrole{std,std-ref}{cavity example}}}}.
\end{sphinxadmonition}


\subsection{Uzawa Algorithm and Conjugate Gradients}
\label{\detokenize{models/navier-stokes-equations:uzawa-algorithm-and-conjugate-gradients}}\label{\detokenize{models/navier-stokes-equations:navierstokesuzawaconjugategradients}}
\sphinxAtStartPar
We solve Stokes problem without penalty.
The classical iterative method of Uzawa is described by the algorithm (see e.g. \sphinxcite{bibliography:roberts1993}, 17.3, \sphinxcite{bibliography:glowinski1979}, 13 or \sphinxcite{bibliography:glowinski1985}, 13):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Initialize:} Let \(p_h^0\) be an arbitrary chosen element of \(L^2(\Omega)\).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Calculate :math:\textasciigrave{}mathbf\{u\}\_h\textasciigrave{}:} Once \(p_h^n\) is known, \(\mathbf{v}_h^n\) is the solution of:
\begin{quote}
\begin{equation*}
\begin{split}\mathbf{u}_h^n = A^{-1}(\mathbf{f}_h-\mathbf{B}^*p_h^n)\end{split}
\end{equation*}\end{quote}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Advance :math:\textasciigrave{}p\_h\textasciigrave{}:} Let \(p_h^{n+1}\) be defined by;
\begin{quote}
\begin{equation*}
\begin{split}p_h^{n+1}=p_h^n+\rho_n\mathbf{B}\mathbf{u}_h^n\end{split}
\end{equation*}\end{quote}

\end{itemize}

\sphinxAtStartPar
There is a constant \(\alpha>0\) such that \(\alpha\le \rho_n\le 2\) for each \(n\), then \(\mathbf{u}_h^n\) converges to the solution \(\mathbf{u}_h\), and then \(B\mathbf{v}_h^n\to 0\) as \(n\to \infty\) from the \sphinxstyleemphasis{Advance} \(p_h\). This method in general converges quite slowly.

\sphinxAtStartPar
First we define mesh, and the Taylor\sphinxhyphen{}Hood approximation.
So \(X_{h}\) is the velocity space, and \(M_{h}\) is the pressure space.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Stokes Uzawa

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{bc1}\PYG{p}{,} \PYG{n}{bc2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{b}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{ppp}\PYG{p}{;} \PYG{c+c1}{//ppp is a working pressure}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{bx} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{by} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{;}
\PYG{c+c1}{//remark: put the on(3,u1=1) before on(1,2,4,u1=0)}
\PYG{c+c1}{//because we want zero on intersection}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Bx} \PYG{o}{=} \PYG{n}{bx}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B=(Bx, By)}
\PYG{k+kt}{matrix} \PYG{n}{By} \PYG{o}{=} \PYG{n}{by}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//boundary condition contribution on u1}
\PYG{n}{bc2} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//no boundary condition contribution on u2}

\PYG{c+c1}{//p\PYGZus{}h\PYGZca{}n \PYGZhy{}\PYGZgt{} B A\PYGZca{}\PYGZhy{}1 \PYGZhy{} B\PYGZca{}* p\PYGZus{}h\PYGZca{}n = \PYGZhy{}div u\PYGZus{}h}
\PYG{c+c1}{//is realized as the function divup}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{divup} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{pp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//compute u1(pp)}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{c+c1}{//compute u2(pp)}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{By}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{b}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{c+c1}{//u\PYGZca{}n = (A\PYGZca{}\PYGZhy{}1 Bx\PYGZca{}T p\PYGZca{}n, By\PYGZca{}T p\PYGZca{}n)\PYGZca{}T}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//ppp = Bx u\PYGZus{}1}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{By}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//+ By u\PYGZus{}2}

    \PYG{k}{return} \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Initialization}
\PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//p\PYGZus{}h\PYGZca{}0 = 0}
\PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{divup}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//p\PYGZus{}h\PYGZca{}\PYGZob{}n+1\PYGZcb{} = p\PYGZus{}h\PYGZca{}n + B u\PYGZus{}h\PYGZca{}n}
\PYG{c+c1}{// if n\PYGZgt{} 50 or |p\PYGZus{}h\PYGZca{}\PYGZob{}n+1\PYGZcb{} \PYGZhy{} p\PYGZus{}h\PYGZca{}n| \PYGZlt{}= 10\PYGZca{}\PYGZhy{}6, then the loop end}
\PYG{n}{divup}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//compute the final solution}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{coef}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{NSUzawaCahouetChabart.edp}
\label{\detokenize{models/navier-stokes-equations:nsuzawacahouetchabart-edp}}
\sphinxAtStartPar
In this example we solve the Navier\sphinxhyphen{}Stokes equation past a cylinder with the Uzawa algorithm preconditioned by the Cahouet\sphinxhyphen{}Chabart method (see \sphinxcite{bibliography:glowinski2003} for all the details).

\sphinxAtStartPar
The idea of the preconditioner is that in a periodic domain, all differential operators commute and the Uzawa algorithm comes to solving the linear operator \(\nabla. ( (\alpha Id + \nu \Delta)^{-1} \nabla\), where \(Id\) is the identity operator.
So the preconditioner suggested is \(\alpha \Delta^{-1} + \nu Id\).

\sphinxAtStartPar
To implement this, we do:

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
NS Uzawa Cahouet Chabart

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{D} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{0.41}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cx0} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{cy0} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;} \PYG{c+c1}{//center of cylinder}
\PYG{k+kt}{real} \PYG{n}{xa} \PYG{o}{=} \PYG{l+m+mf}{0.15}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ya} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{xe} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ye} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{15}\PYG{p}{;}

\PYG{c+c1}{//TODO}
\PYG{k+kt}{real} \PYG{n}{Um} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{c+c1}{//max velocity (Rey 100)}
\PYG{k+kt}{real} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{U1} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{n}{Um}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{H}\PYG{o}{*}\PYG{n}{H}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Boundary condition}
\PYG{k+kt}{func} \PYG{n}{U2} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{n}{D}\PYG{o}{/}\PYG{n}{nn}\PYG{o}{/}\PYG{n}{Um}\PYG{p}{;} \PYG{c+c1}{//CFL = 1}
\PYG{k+kt}{real} \PYG{n}{epspq} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}

\PYG{c+c1}{// Variables}
\PYG{k+kt}{func} \PYG{n}{Ub} \PYG{o}{=} \PYG{n}{Um}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{Rey} \PYG{o}{=} \PYG{n}{Ub}\PYG{o}{*}\PYG{n}{D}\PYG{o}{/}\PYG{n}{nu}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{fr1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{2.2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{fr5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{cx0}\PYG{o}{+}\PYG{n}{D}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{cy0}\PYG{o}{+}\PYG{n}{D}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{fr1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr2}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr3}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr4}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fr5}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nn}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1dc}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{w}\PYG{p}{;} \PYG{c+c1}{//vorticity}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{von1} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{U1}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{n}{U2}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//remark : the value 100 in next varf is manualy fitted, because free outlet.}
\PYG{k+kt}{varf} \PYG{n+nf}{vA} \PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=}
    \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{q}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{100}\PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vM} \PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qft}\PYG{o}{=}\PYG{k+kr}{qf2pT}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{p}\PYG{o}{*}\PYG{n}{q}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vu} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vu1} \PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vu2} \PYG{p}{(}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vonu1} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{U1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vonu2} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{n}{U2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{pAM} \PYG{o}{=} \PYG{n}{vM}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{pAA} \PYG{o}{=} \PYG{n}{vA}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{AU} \PYG{o}{=} \PYG{n}{vu}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B1} \PYG{o}{=} \PYG{n}{vu1}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{B2} \PYG{o}{=} \PYG{n}{vu2}\PYG{p}{(}\PYG{n}{Mh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{brhs1} \PYG{o}{=} \PYG{n}{vonu1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{brhs2} \PYG{o}{=} \PYG{n}{vonu2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vrhs1}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{vv}\PYG{o}{*}\PYG{n}{alpha}\PYG{p}{)} \PYG{o}{+} \PYG{n}{vonu1}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vrhs2}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v1}\PYG{o}{*}\PYG{n}{alpha}\PYG{p}{)} \PYG{o}{+} \PYG{n}{vonu2}\PYG{p}{;}

\PYG{c+c1}{// Uzawa function}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{JUzawa} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{pp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{brhs1}\PYG{p}{;} \PYG{n}{b1} \PYG{o}{+}\PYG{o}{=} \PYG{k+kp}{B1}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{brhs2}\PYG{p}{;} \PYG{n}{b2} \PYG{o}{+}\PYG{o}{=} \PYG{n}{B2}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AU}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b1}\PYG{p}{;}
    \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AU}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{b2}\PYG{p}{;}
    \PYG{n}{pp} \PYG{o}{=} \PYG{k+kp}{B1}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{pp} \PYG{o}{+}\PYG{o}{=} \PYG{n}{B2}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{pp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{pp}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{pp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Preconditioner function}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Precon} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pa} \PYG{o}{=} \PYG{n}{pAA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pm} \PYG{o}{=} \PYG{n}{pAM}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pp} \PYG{o}{=} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{pa} \PYG{o}{+} \PYG{n}{nu}\PYG{o}{*}\PYG{n}{pm}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{pp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Initialization}
\PYG{n}{p} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Time loop}
\PYG{k+kt}{int} \PYG{n}{ndt} \PYG{o}{=} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ndt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{brhs1} \PYG{o}{=} \PYG{n}{vrhs1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{brhs2} \PYG{o}{=} \PYG{n}{vrhs2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{JUzawa}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{Precon}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{res}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{eps} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Vorticity}
    \PYG{n}{w} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{dt} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{T}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{t} \PYG{o}{+}\PYG{o}{=} \PYG{n}{dt}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dt} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{T}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u1 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}
    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u2 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}
    \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, p max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Stop test of the conjugate gradient

\sphinxAtStartPar
Because we start from the previous solution and the end the previous solution is close to the final solution, don’t take a relative stop test to the first residual, take an absolute stop test (negative here).
\end{sphinxadmonition}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{NavierStokesEquations}.png}
\caption{The vorticity at Reynolds number 100 a time 2s with the Cahouet\sphinxhyphen{}Chabart method.}\label{\detokenize{models/navier-stokes-equations:id8}}\end{figure}
\end{sphinxadmonition}


\section{Variational Inequality}
\label{\detokenize{models/variational-inequality:variational-inequality}}\label{\detokenize{models/variational-inequality::doc}}
\sphinxAtStartPar
We present, a classical example of variational inequality.

\sphinxAtStartPar
Let us denote \(\mathcal{C} = \{ u\in H^1_0(\Omega), u \le g \}\)

\sphinxAtStartPar
The problem is:
\begin{equation*}
\begin{split}u = arg \min_{u\in \mathcal{C}} J(u) = \frac{1}{2} \int_\Omega \nabla u . \nabla u - \int_\Omega f u\end{split}
\end{equation*}
\sphinxAtStartPar
where \(f\) and \(g\) are given function.

\sphinxAtStartPar
The solution is a projection on the convex \(\mathcal{C}\) of \(f^\star\) for the scalar product \(((v,w)) = \int_\Omega \nabla v . \nabla w\) of \(H^1_0(\Omega)\) where \(f^\star\) is solution of:
\begin{equation*}
\begin{split}(f^\star, v ) = \int_{\Omega}{f v}, \forall v \in H^1_0(`\Omega)\end{split}
\end{equation*}
\sphinxAtStartPar
The projection on a convex satisfy clearly \(\forall v \in \mathcal{C}, \quad (( u -v , u - \tilde{f} )) \leq 0\), and after expanding, we get the classical inequality:
\begin{equation*}
\begin{split}\forall v \in \mathcal{C}, \quad \int_\Omega \nabla(u -v) \nabla u \leq \int_\Omega (u-v) f\end{split}
\end{equation*}
\sphinxAtStartPar
We can also rewrite the problem as a saddle point problem:

\sphinxAtStartPar
Find \(\lambda, u\) such that:
\begin{equation*}
\begin{split}\max_{\lambda\in L^2(\Omega), \lambda\geq 0} \min_{u\in H^1_0(\Omega)} \mathcal{L}(u,\lambda) = \frac{1}{2} \int_\Omega \nabla u . \nabla u - \int_\Omega f u + \int_{\Omega} \lambda (u-g)^+\end{split}
\end{equation*}
\sphinxAtStartPar
where \(((u-g)^+ = max(0,u-g)\).

\sphinxAtStartPar
This saddle point problem is equivalent to find \(u, \lambda\) such that:
\begin{equation*}
\begin{split}\left\{
\begin{array}{cc}
    \displaystyle \int_\Omega \nabla u . \nabla v + \lambda v^+ \,d\omega= \int_\Omega f u , &\forall v \in H^1_0(\Omega) \cr
    \displaystyle \int_\Omega \mu (u-g)^+ = 0 , & \forall \mu \in L^2(\Omega) , \mu \geq 0, \lambda \geq 0,
\end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
An algorithm to solve the previous problem is:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
k=0, and choose \(\lambda_0\) belong \(H^{-1}(\Omega)\)

\item {} 
\sphinxAtStartPar
Loop on \(k = 0, .....\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
set \(\mathcal{I}_{k} = \{ x \in \Omega / \lambda_{k} + c * ( u_{k+1} - g) \leq 0 \}\)

\item {} 
\sphinxAtStartPar
\(V_{g,k+1} = \{ v\in H^1_0(\Omega) / v = g\) on \({I}_{k} \}\),

\item {} 
\sphinxAtStartPar
\(V_{0,k+1} = \{ v\in H^1_0(\Omega) / v = 0\) on \({I}_{k} \}\),

\item {} 
\sphinxAtStartPar
Find \(u_{k+1} \in V_{g,k+1}\) and \(\lambda_{k+1} \in H^{-1}(\Omega)\) such that
\begin{equation*}
\begin{split}\left\{\begin{array}{cc}
   \displaystyle \int_\Omega \nabla u_{k+1}. \nabla v_{k+1} \,d\omega = \int_\Omega f v_{k+1} , &\forall v_{k+1} \in V_{0,k+1} \cr
   \displaystyle <\lambda_{k+1},v> = \int_\Omega \nabla u_{k+1}. \nabla v - f v \,d\omega &
\end{array}\right.\end{split}
\end{equation*}
\sphinxAtStartPar
where \(<,>\) is the duality bracket between \(H^{1}_0(\Omega)\) and \(H^{-1}(\Omega)\), and \(c\) is a penalty constant (large enough).

\end{itemize}

\end{enumerate}

\sphinxAtStartPar
You can find all the mathematics about this algorithm in \sphinxcite{bibliography:ito2003} \sphinxcite{bibliography:hintermuller2002}.

\sphinxAtStartPar
Now how to do that in \sphinxstylestrong{FreeFEM}? The full example is:

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Variational inequality

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;} \PYG{c+c1}{//penalty parameter of the algoritm}
\PYG{k+kt}{real} \PYG{k+kp}{tgv} \PYG{o}{=} \PYG{l+m+mf}{1e30}\PYG{p}{;} \PYG{c+c1}{//a huge value for exact penalization}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//right hand side function}
\PYG{k+kt}{func} \PYG{n}{fd} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Dirichlet boundary condition function}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{c+c1}{//number of degree of freedom}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{uhp}\PYG{p}{;} \PYG{c+c1}{//u\PYGZca{}n+1 and u\PYGZca{}n}
\PYG{n}{Vh} \PYG{n}{Ik}\PYG{p}{;} \PYG{c+c1}{//to define the set where the containt is reached.}
\PYG{n}{Vh} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;} \PYG{c+c1}{//discret function g}
\PYG{n}{Vh} \PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{a} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{n}{fd}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//the mass Matrix construction}
\PYG{k+kt}{varf} \PYG{n+nf}{vM} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//two versions of the matrix of the problem}
\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//one changing}
\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//one for computing residual}

\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vM}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to do a fast computing of L\PYGZca{}2 norm : sqrt(u\PYGZsq{}*(w=M*u))}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aiin}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Aii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;} \PYG{c+c1}{//get the diagonal of the matrix}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rhs} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{k+kp}{tgv}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Initialization}
\PYG{n}{Ik} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n}{uhp} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{k+kp}{tgv}\PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{//get a copy of the Right hand side}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Ak}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the complementary of Ik ( !Ik = (Ik\PYGZhy{}1))}
    \PYG{n}{Ak} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{n}{Ak} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{Ik}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{c+c1}{//adding new locking condition on b and on the diagonal if (Ik ==1 )}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{Ik}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{*} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{n}{b} \PYG{o}{*}\PYG{o}{=} \PYG{k+kp}{tgv}\PYG{p}{;} \PYG{n}{b} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{Ak} \PYG{p}{.}\PYG{o}{*} \PYG{n}{rhs}\PYG{p}{;}
    \PYG{n}{Aiin} \PYG{o}{=} \PYG{n}{Ik}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*} \PYG{k+kp}{tgv}\PYG{p}{;} \PYG{n}{Aiin} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ak} \PYG{p}{.}\PYG{o}{*} \PYG{n}{Aii}\PYG{p}{;} \PYG{c+c1}{//set Aii= tgv i in Ik}
    \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag} \PYG{o}{=} \PYG{n}{Aiin}\PYG{p}{;} \PYG{c+c1}{//set the matrix diagonal}
    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//important to change preconditioning for solving}

    \PYG{c+c1}{// Solve}
    \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*} \PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{//solve the problem with more locking condition}

    \PYG{c+c1}{// Residual}
    \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{AA} \PYG{o}{*} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//compute the residual (fast with matrix)}
    \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rhs}\PYG{p}{;} \PYG{c+c1}{//remark rhs = \PYGZhy{}\PYGZbs{}int f v}

    \PYG{n}{Ik} \PYG{o}{=} \PYG{p}{(}\PYG{n}{lambda} \PYG{o}{+} \PYG{n}{c}\PYG{o}{*}\PYG{p}{(} \PYG{n}{g}\PYG{o}{\PYGZhy{}} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//the new locking value}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Ik}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ lock set }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{c+c1}{//trick to compute L\PYGZca{}2 norm of the variation (fast method)}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diff}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Mdiff}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{diff} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{uhp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{Mdiff} \PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{diff}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{Mdiff}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{diff}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{|| u\PYGZus{}\PYGZob{}k=1\PYGZcb{} \PYGZhy{} u\PYGZus{}\PYGZob{}k\PYGZcb{} ||\PYGZus{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Stop test}
    \PYG{k}{if}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{uhp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uh}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
As you can see on this example, some vector, or matrix operator are not implemented so a way is to skip the expression and we use operator \sphinxcode{\sphinxupquote{+=}},  \sphinxcode{\sphinxupquote{\sphinxhyphen{}=}} to merge the result.
\end{sphinxadmonition}
\end{sphinxadmonition}


\section{Domain decomposition}
\label{\detokenize{models/domain-decomposition:domain-decomposition}}\label{\detokenize{models/domain-decomposition::doc}}
\sphinxAtStartPar
We present three classic examples of domain decomposition technique: first, Schwarz algorithm with overlapping, second Schwarz algorithm without overlapping (also call Shur complement), and last we show to use the conjugate gradient to solve the boundary problem of the Shur complement.


\subsection{Schwarz overlapping}
\label{\detokenize{models/domain-decomposition:schwarz-overlapping}}\label{\detokenize{models/domain-decomposition:domaindecompositionschwarzoverlapping}}
\sphinxAtStartPar
To solve:
\begin{equation*}
\begin{split}-\Delta u =f,\;\mbox{in}\;\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0\end{split}
\end{equation*}
\sphinxAtStartPar
the Schwarz algorithm runs like this:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    -\Delta u^{n+1}_1&=&f\;\mbox{in}\;\Omega_1\quad
    u^{n+1}_1|_{\Gamma_1}=u^n_2\\
    -\Delta u^{n+1}_2&=&f\;\mbox{in}\;\Omega_2\quad
    u^{n+1}_2|_{\Gamma_2}=u^n_1
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Gamma_i\) is the boundary of \(\Omega_i\) and on the condition that \(\Omega_1\cap\Omega_2\neq\emptyset\) and that \(u_i\) are zero at iteration 1.

\sphinxAtStartPar
Here we take \(\Omega_1\) to be a quadrangle, \(\Omega_2\) a disk and we apply the algorithm starting from zero.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{DomainDecomposition_Schwarz1}.png}
\caption{The 2 overlapping mesh \sphinxcode{\sphinxupquote{TH}} and \sphinxcode{\sphinxupquote{th}}}\label{\detokenize{models/domain-decomposition:id1}}\end{figure}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Schwarz overlapping

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kp}{inside} \PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//inside boundary}
\PYG{k+kt}{int} \PYG{n}{outside} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//outside boundary}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see the 2 meshes}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VH} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{PB} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
         \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
       \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
       \PYG{o}{\PYGZhy{}} \PYG{n}{V}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{k+kp}{inside}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{u}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
         \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
       \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
       \PYG{o}{\PYGZhy{}} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{k+kp}{inside}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{U}\PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Calculation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Solve}
   \PYG{n}{PB}\PYG{p}{;}
   \PYG{n}{pb}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz2}.png}
\caption{Isovalues of the solution at iteration 0}\label{\detokenize{models/domain-decomposition:id2}}\label{\detokenize{models/domain-decomposition:figdomaindecomposition-schwarz2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz3}.png}
\caption{Isovalues of the solution at iteration 0}\label{\detokenize{models/domain-decomposition:id3}}\label{\detokenize{models/domain-decomposition:figdomaindecomposition-schwarz3}}\end{subfigure}
\caption{Schwarz overlapping}

\end{figure}

\end{sphinxadmonition}


\subsection{Schwarz non overlapping Scheme}
\label{\detokenize{models/domain-decomposition:schwarz-non-overlapping-scheme}}\label{\detokenize{models/domain-decomposition:DomainDecomposition_Schwarz}}
\sphinxAtStartPar
To solve:
\begin{equation*}
\begin{split}-\Delta u =f\;\mbox{in}\;\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0\end{split}
\end{equation*}
\sphinxAtStartPar
the Schwarz algorithm for domain decomposition without overlapping runs like this

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{DomainDecomposition_Schwarz4}.png}
\caption{The two none overlapping mesh \sphinxcode{\sphinxupquote{TH}} and \sphinxcode{\sphinxupquote{th}}}\label{\detokenize{models/domain-decomposition:id4}}\end{figure}

\sphinxAtStartPar
Let introduce \(\Gamma_i\) is common the boundary of \(\Omega_1\) and \(\Omega_2\) and \(\Gamma_e^i= \partial \Omega_i \setminus \Gamma_i\).

\sphinxAtStartPar
The problem find \(\lambda\) such that \((u_1|_{\Gamma_i}=u_2|_{\Gamma_i})\) where \(u_i\) is solution of the following Laplace problem:
\begin{equation*}
\begin{split}-\Delta u_i=f\;\mbox{in}\;\Omega_i\quad
u_i|_{\Gamma_i}=\lambda \quad
u_i|_{\Gamma_e^i} = 0\end{split}
\end{equation*}
\sphinxAtStartPar
To solve this problem we just make a loop with upgrading \(\lambda\) with
\begin{equation*}
\begin{split}\lambda = \lambda {\pm} \frac{(u_1-u_2)}{2}\end{split}
\end{equation*}
\sphinxAtStartPar
where the sign \(+\) or \(-\) of \({\pm}\) is choose to have convergence.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Schwarz non\sphinxhyphen{}overlapping

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kp}{inside} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{outside} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{TH} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e1}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{vh} \PYG{n}{lambda}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VH}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VH} \PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{PB} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{TH}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{V}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{pb} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve}
    \PYG{n}{PB}\PYG{p}{;}
    \PYG{n}{pb}\PYG{p}{;}
    \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{lambda} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{U}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz5}.png}
\caption{Isovalues of the solution at iteration 0 without overlapping}\label{\detokenize{models/domain-decomposition:id5}}\label{\detokenize{models/domain-decomposition:figdomaindecomposition-schwarz5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{DomainDecomposition_Schwarz6}.png}
\caption{Isovalues of the solution at iteration 9 without overlapping}\label{\detokenize{models/domain-decomposition:id6}}\label{\detokenize{models/domain-decomposition:figdomaindecomposition-schwarz6}}\end{subfigure}


\end{figure}

\end{sphinxadmonition}


\subsection{Schwarz conjuguate gradient}
\label{\detokenize{models/domain-decomposition:schwarz-conjuguate-gradient}}\label{\detokenize{models/domain-decomposition:DomainDecomposition_Schwarz}}
\sphinxAtStartPar
To solve \(-\Delta u =f \;\mbox{in}\;\Omega=\Omega_1\cup\Omega_2\quad u|_\Gamma=0\) the Schwarz algorithm for domain decomposition without overlapping runs like this

\sphinxAtStartPar
Let introduce \(\Gamma_i\) is common the boundary of \(\Omega_1\) and \(\Omega_2\) and \(\Gamma_e^i= \partial \Omega_i \setminus \Gamma_i\).

\sphinxAtStartPar
The problem find \(\lambda\) such that \((u_1|_{\Gamma_i}=u_2|_{\Gamma_i})\) where \(u_i\) is solution of the following Laplace problem:
\begin{equation*}
\begin{split}-\Delta u_i=f\;\mbox{in}\;\Omega_i\quad
u_i|_{\Gamma_i}=\lambda \quad
u_i|_{\Gamma_e^i} = 0\end{split}
\end{equation*}
\sphinxAtStartPar
The version of this example uses the Shur complement.
The problem on the border is solved by a conjugate gradient method.

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Schwarz conjugate gradient

\sphinxAtStartPar
First, we construct the two domains:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{k+kp}{inside} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{outside} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Gamma3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{GammaInside}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{k+kp}{inside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{GammaArc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{outside}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Gamma1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{GammaInside}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Gamma3}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{GammaInside}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{GammaArc}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now, define the finite element spaces:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{lambda}\PYG{p}{;}
\PYG{n}{Vh1} \PYG{n}{p}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
It is impossible to define a function just on a part of boundary, so the \(\lambda\) function must be defined on the all domain \(\Omega_1\) such as:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{Vh1} \PYG{n}{lambda}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\sphinxAtStartPar
The two Poisson’s problems:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{problem} \PYG{n+nf}{Pb1} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{v1}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Pb2} \PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{v2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{v2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{outside}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
And, we define a border matrix, because the \(\lambda\) function is none zero inside the domain \(\Omega_1\):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{varf} \PYG{n+nf}{b}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{inside}\PYG{p}{)}\PYG{p}{(}\PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh1}\PYG{p}{,} \PYG{n}{Vh1}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The boundary problem function,
\begin{equation*}
\begin{split}\lambda \longrightarrow \int_{\Gamma_i }(u_1-u_2) v_{1}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Boundary problem function}
\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{BoundaryProblem} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{l}\PYG{p}{;} \PYG{c+c1}{//make FE function form l}
   \PYG{n}{Pb1}\PYG{p}{;}
   \PYG{n}{Pb2}\PYG{p}{;}
   \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;} \PYG{c+c1}{//no refactorization i != 0}
   \PYG{n}{v1} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{u1}\PYG{o}{\PYGZhy{}}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{B}\PYG{o}{*}\PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{lambda}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The difference between the two notations \sphinxcode{\sphinxupquote{v1}} and \sphinxcode{\sphinxupquote{v1{[}{]}}} is: \sphinxcode{\sphinxupquote{v1}} is the finite element function and \sphinxcode{\sphinxupquote{v1{[}{]}}} is the vector in the canonical basis of the finite element function \sphinxcode{\sphinxupquote{v1}}.
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{o}{=}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{BoundaryProblem}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//compute the final solution, because CG works with increment}
\PYG{n}{BoundaryProblem}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//solve again to have right u1, u2}

\PYG{c+c1}{// Display \PYGZam{} Plot}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} CPU time schwarz\PYGZhy{}gc:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\section{Fluid\sphinxhyphen{}structure coupled problem}
\label{\detokenize{models/fluid-structure-coupled-problem:fluid-structure-coupled-problem}}\label{\detokenize{models/fluid-structure-coupled-problem::doc}}
\sphinxAtStartPar
This problem involves the Lamé system of elasticity and the Stokes system for viscous fluids with velocity \(\mathbf{u}\) and pressure \(p\):
\begin{equation*}
\begin{split}\begin{array}{rcll}
    -\Delta\mathbf{u} + \mathbf{\nabla} p &=& 0 & \hbox{ in }\Omega\\
    \nabla\cdot\mathbf{u} &=& 0 & \hbox{ in }\Omega\\
    \mathbf{u} &=& \mathbf{u}_\Gamma & \hbox{ on }\Gamma=\partial\Omega
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(u_\Gamma\) is the velocity of the boundaries.
The force that the fluid applies to the boundaries is the normal stress
\begin{equation*}
\begin{split}\mathbf{h} =(\nabla\mathbf{u} +\nabla\mathbf{u}^T)\mathbf{n} -p\mathbf{n}\end{split}
\end{equation*}
\sphinxAtStartPar
Elastic solids subject to forces deform: a point in the solid at (x,y) goes to (X,Y) after.
When the displacement vector \(\mathbf{v}=(v_1,v_2) = (X-x, Y-y)\) is small, Hooke’s law relates the stress tensor \(\sigma\) inside the solid to the deformation tensor \(\epsilon\):
\begin{equation*}
\begin{split}\sigma_{ij} = \lambda \delta_{ij} \nabla.\mathbf{v} + 2\mu\epsilon_{ij},
\,
\epsilon_{ij} = {1\over 2}({\partial v_i\over\partial x_j} + {\partial v_j\over\partial x_i} )\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\delta\) is the Kronecker symbol and where \(\lambda\), \(\mu\) are two constants describing the material mechanical properties in terms of the modulus of elasticity, and Young’s modulus.

\sphinxAtStartPar
The equations of elasticity are naturally written in variational form for the displacement vector \(v(x)\in V\) as:
\begin{equation*}
\begin{split}\int_\Omega \left[2\mu\epsilon_{ij}(\mathbf{v})\epsilon_{ij}(\mathbf{w})
+\lambda \epsilon_{ii}(v)\epsilon_{jj}(\mathbf{w})\right]
=\int_\Omega \mathbf{g}\cdot \mathbf{w} +\int_\Gamma \mathbf{h}\cdot \mathbf{w},%\`{u}
\forall \mathbf{w}\in V\end{split}
\end{equation*}
\sphinxAtStartPar
The data are the gravity force \(\mathbf{g}\) and the boundary stress \(\mathbf{h}\).

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Fluide\sphinxhyphen{}structure
In our example, the Lamé system and the Stokes system are coupled by a common boundary on which the fluid stress creates a displacement of the boundary and hence changes the shape of the domain where the Stokes problem is integrated.
The geometry is that of a vertical driven cavity with an elastic lid.
The lid is a beam with weight so it will be deformed by its own weight and by the normal stress due to the fluid reaction.
The cavity is the \(10 \times 10\) square and the lid is a rectangle of height \(l=2\).

\sphinxAtStartPar
A beam sits on a box full of fluid rotating because the left vertical side has velocity one.
The beam is bent by its own weight, but the pressure of the fluid modifies the bending.

\sphinxAtStartPar
The bending displacement of the beam is given by \((uu, vv)\) whose solution is given as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{bottombeam} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//label of bottombeam}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{21.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mf}{0.29}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{gravity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{;}

\PYG{c+c1}{// Mesh (solid)}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{bottombeam}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace (solid)}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{s}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{real} \PYG{n}{sqrt2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n+nf}{epsilon}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{sqrt2}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem (solid)}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{solve} \PYG{n+nf}{Elasticity}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then Stokes equation for fluids at low speed are solved in the box below the beam, but the beam has deformed the box (see border h):

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh (fluid)}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{k+kp}{t} \PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{g}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{h}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{vv}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(} \PYG{k+kp}{t}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mf}{0.001} \PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mf}{9.999}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{sh} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{h}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
We use the Uzawa conjugate gradient to solve the Stokes problem like in {\hyperref[\detokenize{models/navier-stokes-equations:navierstokesuzawaconjugategradients}]{\sphinxcrossref{\DUrole{std,std-ref}{Navier\sphinxhyphen{}Stokes equations}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Fespace (fluid)}
\PYG{k+kt}{fespace} \PYG{n+nf}{Xh}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{bc1}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{brhs}\PYG{p}{;}
\PYG{n}{Xh} \PYG{n}{bcx}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{bcy}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Mh}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Mh} \PYG{n}{p}\PYG{p}{,} \PYG{n}{ppp}\PYG{p}{;}

\PYG{c+c1}{// Problem (fluid)}
\PYG{k+kt}{varf} \PYG{n+nf}{bx} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{by} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{)}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{Lap} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{sh}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Lap}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{Lap}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Xh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Bx} \PYG{o}{=} \PYG{n}{bx}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{By} \PYG{o}{=} \PYG{n}{by}\PYG{p}{(}\PYG{n}{Xh}\PYG{p}{,} \PYG{n}{Mh}\PYG{p}{)}\PYG{p}{;}


\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{divup} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{pp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{verb} \PYG{o}{=} \PYG{k+kr}{verbosity}\PYG{p}{;}
    \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{*}\PYG{n}{bcx}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{By}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{pp}\PYG{p}{;}
    \PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{bc1}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{*}\PYG{n}{bcy}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{brhs}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bx}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{By}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n}{verb}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
do a loop on the two problems

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Coupling loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{step} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{step} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{step}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Solve (fluid)}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{divup}\PYG{p}{,} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}3}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{divup}\PYG{p}{(}\PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now the beam will feel the stress constraint from the fluid:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Forces}
\PYG{n}{Vh} \PYG{n}{sigma11}\PYG{p}{,} \PYG{n}{sigma22}\PYG{p}{,} \PYG{n}{sigma12}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu1}\PYG{o}{=}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv1}\PYG{o}{=}\PYG{n}{vv}\PYG{p}{;}

\PYG{n}{sigma11}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sigma22}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{sigma12}\PYG{p}{(}\PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
which comes as a boundary condition to the PDE of the beam:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Solve (solid)}
\PYG{k+kt}{solve} \PYG{n+nf}{Elasticity2} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{init}\PYG{o}{=}\PYG{n}{step}\PYG{p}{)}
\PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{lambda}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{div}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}
    \PYG{o}{+} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{mu}\PYG{o}{*}\PYG{p}{(}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,}\PYG{n}{s}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{epsilon}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{gravity}\PYG{o}{*}\PYG{n}{s}
\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n}{bottombeam}\PYG{p}{)}\PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{k+kp}{coef}\PYG{o}{*}\PYG{p}{(}\PYG{n}{sigma11}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{w} \PYG{o}{+} \PYG{n}{sigma22}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{s} \PYG{o}{+} \PYG{n}{sigma12}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n}{w}\PYG{o}{+}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}
\PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{n}{uu}\PYG{o}{\PYGZhy{}}\PYG{n}{uu1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{p}{(}\PYG{n}{vv}\PYG{o}{\PYGZhy{}}\PYG{n}{vv1}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Erreur L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Notice that the matrix generated by \sphinxcode{\sphinxupquote{Elasticity2}} is reused (see {\hyperref[\detokenize{references/types:typeproblemdesign}]{\sphinxcrossref{\DUrole{std,std-ref}{init=i}}}}).
Finally we deform the beam:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Movemesh}
\PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mf}{0.2}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Fluid velocity and pressure, displacement vector of the structure and displaced geometry in the fluid\sphinxhyphen{}structure interaction of a soft side and a driven cavity are shown \hyperref[\detokenize{models/fluid-structure-coupled-problem:figfsi1}]{Fig.\@ \ref{\detokenize{models/fluid-structure-coupled-problem:figfsi1}}}, \hyperref[\detokenize{models/fluid-structure-coupled-problem:figfsi2}]{Fig.\@ \ref{\detokenize{models/fluid-structure-coupled-problem:figfsi2}}} and \hyperref[\detokenize{models/fluid-structure-coupled-problem:figfsi3}]{Fig.\@ \ref{\detokenize{models/fluid-structure-coupled-problem:figfsi3}}}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{FluidStructure1}.png}
\caption{Velocity and pressure}\label{\detokenize{models/fluid-structure-coupled-problem:figfsi1}}\end{figure}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FluidStructure2}.png}
\caption{Displacement}\label{\detokenize{models/fluid-structure-coupled-problem:id1}}\label{\detokenize{models/fluid-structure-coupled-problem:figfsi2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FluidStructure3}.png}
\caption{Moved mesh}\label{\detokenize{models/fluid-structure-coupled-problem:id2}}\label{\detokenize{models/fluid-structure-coupled-problem:figfsi3}}\end{subfigure}
\phantomsection\label{\detokenize{models/fluid-structure-coupled-problem:FluidStructure}}

\end{figure}

\end{sphinxadmonition}


\section{Transmission problem}
\label{\detokenize{models/transmission-problem:transmission-problem}}\label{\detokenize{models/transmission-problem::doc}}
\sphinxAtStartPar
Consider an elastic plate whose displacement change vertically, which is made up of three plates of different materials, welded on each other.

\sphinxAtStartPar
Let \(\Omega_i\), \(i=1,2,3\) be the domain occupied by \(i\)\sphinxhyphen{}th material with tension \(\mu_i\) (see {\hyperref[\detokenize{models/static-problems:modelstatissoap}]{\sphinxcrossref{\DUrole{std,std-ref}{Soap film}}}}).

\sphinxAtStartPar
The computational domain \(\Omega\) is the interior of \(\overline{\Omega_1}\cup \overline{\Omega_2}\cup \overline{\Omega_3}\).
The vertical displacement \(u(x,y)\) is obtained from:
\begin{equation}\label{equation:models/transmission-problem:eqn::transm}
\begin{split}\begin{array}{rcll}
    -\mu_i\Delta u &=& f & \textrm{ in }\Omega_i\\
    \mu_i\p_n u|_{\Gamma_{i}} &=& -\mu_j\p_n u|_{\Gamma_{j}} & \textrm{ on }\overline{\Omega_{i}}\cap\overline{\Omega_{j}} \textrm{ if }1\le i< j\le 3
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
where \(\p_n u|_{\Gamma_{i}}\) denotes the value of the normal derivative \(\p_n u\) on the boundary \(\Gamma_i\) of the domain \(\Omega_i\).

\sphinxAtStartPar
By introducing the characteristic function \(\chi_i\) of \(\Omega_i\), that is:
\begin{equation*}
\begin{split}\chi_i(x)=1\ \textrm{ if }x\in\Omega_i;\
\chi_i(x)=0\ \textrm{ if }x\not\in\Omega_i\end{split}
\end{equation*}
\sphinxAtStartPar
we can easily rewrite \eqref{equation:models/transmission-problem:eqn::transm} to the weak form.
Here we assume that \(u=0\) on \(\Gamma=\p\Omega\).

\sphinxAtStartPar
Transmission problem: For a given function \(f\), find \(u\) such that:
\begin{equation*}
\begin{split}a(u,v) = \ell(f,v) \textrm{ for all }v\in H^1_0(\Omega)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{rcl}
    a(u,v) &=& \int_{\Omega}\mu \nabla u\cdot \nabla v\nonumber\\
    \ell(f,v) &=& \int_{\Omega}fv\nonumber
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\mu=\mu_1\chi_1+\mu_2\chi_2+\mu_3\chi_3\).
Here we notice that \(\mu\) become the discontinuous function.

\sphinxAtStartPar
This example explains the definition and manipulation of \sphinxstyleemphasis{region}, i.e. sub\sphinxhyphen{}domains of the whole domain.
Consider this L\sphinxhyphen{}shaped domain with 3 diagonals as internal boundaries, defining 4 sub\sphinxhyphen{}domains:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{c}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{e}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{i3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+}\PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{e}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i1}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i2}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i3}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//constant discontinuous functions / element}
\PYG{n}{Ph} \PYG{n}{reg}\PYG{o}{=}\PYG{k+kr}{region}\PYG{p}{;} \PYG{c+c1}{//defined the P0 function associated to region number}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{reg}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{TransmissionProblem_Region}.png}
\caption{The function \sphinxcode{\sphinxupquote{reg}}}\label{\detokenize{models/transmission-problem:id1}}\end{figure}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{region}} is a keyword of \sphinxstylestrong{FreeFEM} which is in fact a variable depending of the current position (is not a function today, use \sphinxcode{\sphinxupquote{Ph reg=region;}} to set a function).
This variable value returned is the number of the sub\sphinxhyphen{}domain of the current position.
This number is defined by \sphinxcode{\sphinxupquote{buildmesh}} which scans while building the mesh all its connected component.

\sphinxAtStartPar
So to get the number of a region containing a particular point one does:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Characteristic function}
\PYG{k+kt}{int} \PYG{n}{nupper} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{l+m+mf}{0.9}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get the region number of point (0.4,0.9)}
\PYG{k+kt}{int} \PYG{n}{nlower} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{l+m+mf}{0.9}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//get the region number of point (0.4,0.1)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nlower = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}  \PYG{n}{nlower} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nupper = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nupper}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{nu} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mi}{5}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nlower}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nupper}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{TransmissionProblem_Nu}.png}
\caption{The function \sphinxcode{\sphinxupquote{nu}}}\label{\detokenize{models/transmission-problem:id2}}\end{figure}

\sphinxAtStartPar
This is particularly useful to define discontinuous functions such as might occur when one part of the domain is copper and the other one is iron, for example.

\sphinxAtStartPar
We this in mind we proceed to solve a Laplace equation with discontinuous coefficients (\(\nu\) is 1, 6 and 11 below).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Problem}
\PYG{k+kt}{solve} \PYG{n+nf}{lap} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{nu}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{c}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{,} \PYG{n}{e}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{TransmissionProblem_U}.png}
\caption{The isovalue of the solution \(u\)}\label{\detokenize{models/transmission-problem:id3}}\end{figure}


\section{Free boundary problems}
\label{\detokenize{models/free-boundary-problems:free-boundary-problems}}\label{\detokenize{models/free-boundary-problems::doc}}
\sphinxAtStartPar
The domain \(\Omega\) is defined with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{c+c1}{//length}
\PYG{k+kt}{real} \PYG{n}{hl} \PYG{o}{=} \PYG{l+m+mf}{2.1}\PYG{p}{;} \PYG{c+c1}{//left height}
\PYG{k+kt}{real} \PYG{n}{hr} \PYG{o}{=} \PYG{l+m+mf}{0.35}\PYG{p}{;} \PYG{c+c1}{//right height}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//bottom: Gamma\PYGZus{}a}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{hr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//right: Gamma\PYGZus{}b}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hr}\PYG{o}{\PYGZhy{}}\PYG{n}{hl}\PYG{p}{)}\PYG{o}{/}\PYG{n}{L}\PYG{o}{+}\PYG{n}{hl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//free surface: Gamma\PYGZus{}f}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{hl}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// left: Gamma\PYGZus{}d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{FreeBoundary_Mesh1}.png}
\caption{The mesh of the domain \(\Omega\)}\label{\detokenize{models/free-boundary-problems:id1}}\end{figure}

\sphinxAtStartPar
The free boundary problem is:

\sphinxAtStartPar
Find \(u\) and \(\Omega\) such that:
\begin{equation*}
\begin{split}\left\{
\begin{array}{rcll}
   -\Delta u &=& 0 & \mbox{ in }\Omega\\
   u &=& y & \mbox{ on }\Gamma_b\\
   \partial u \over \partial n &=& 0 & \mbox{ on }\Gamma_d\cup\Gamma_a\\
   \partial u \over \partial n &=& {q \over K} n_x & \mbox{ on }\Gamma_f\\
   u &=& y & \mbox{ on }\Gamma_f
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
We use a fixed point method;

\sphinxAtStartPar
\(\Omega^0 = \Omega\)

\sphinxAtStartPar
In two step, fist we solve the classical following problem:
\begin{equation*}
\begin{split}\left\{
\begin{array}{rcll}
    -\Delta u &=& 0 & \mbox{ in }\Omega^n\\
    u &=& y & \mbox{ on }\Gamma^n_b\\
    \partial u \over \partial n &=& 0 & \mbox{ on }\Gamma^n_d\cup\Gamma^n_a\\
    u &=& y & \mbox{ on }\Gamma^n_f
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
The variational formulation is:

\sphinxAtStartPar
Find \(u\) on \(V=H^1(\Omega^n)\), such than \(u=y\) on \(\Gamma^n_b\) and \(\Gamma^n_f\)
\begin{equation*}
\begin{split}\int_{\Omega^n}\nabla u \nabla u' = 0,\ \forall u' \in V \mbox{ with } u' =0 \mbox{ on }\Gamma^n_b \cup \Gamma^n_f\end{split}
\end{equation*}
\sphinxAtStartPar
And secondly to construct a domain deformation \(\mathcal{F}(x,y)=[x,y-v(x,y)]\) where \(v\) is solution of the following problem:
\begin{equation*}
\begin{split}\left\{
\begin{array}{rcll}
    -\Delta v &=& 0 & \mbox{ in }\Omega^n\\
    v &=& 0 & \mbox{ on }\Gamma^n_a\\
    \partial v \over \partial n &=& 0 & \mbox{ on }\Gamma^n_b\cup\Gamma^n_d\\
    \partial v \over \partial n &=& {\partial u \over \partial n} - {q\over K} n_x & \mbox{ on }\Gamma^n_f
\end{array}
\right.\end{split}
\end{equation*}
\sphinxAtStartPar
The variational formulation is:

\sphinxAtStartPar
Find \(v\) on \(V\), such than \(v=0\) on \(\Gamma^n_a\):
\begin{equation*}
\begin{split}\int_{\Omega^n} \nabla v \nabla v' = \int_{\Gamma_f^n}({\partial u \over \partial n} - { q\over K} n_x )v',\ \quad \forall v' \in V \mbox{ with } v' =0 \mbox{ on }\Gamma^n_a\end{split}
\end{equation*}
\sphinxAtStartPar
Finally the new domain \(\Omega^{n+1} = \mathcal{F}(\Omega^n)\)

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
Free boundary

\sphinxAtStartPar
The \sphinxstylestrong{FreeFEM} implementation is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{c+c1}{//length}
\PYG{k+kt}{real} \PYG{n}{hr} \PYG{o}{=} \PYG{l+m+mf}{2.1}\PYG{p}{;} \PYG{c+c1}{//left height}
\PYG{k+kt}{real} \PYG{n}{hl} \PYG{o}{=} \PYG{l+m+mf}{0.35}\PYG{p}{;} \PYG{c+c1}{//right height}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mf}{0.02}\PYG{p}{;} \PYG{c+c1}{//incoming flow}
\PYG{k+kt}{real} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{c+c1}{//permeability}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//bottom: Gamma\PYGZus{}a}
\PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{hr}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//right: Gamma\PYGZus{}b}
\PYG{k+kt}{border} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{hr}\PYG{o}{\PYGZhy{}}\PYG{n}{hl}\PYG{p}{)}\PYG{o}{/}\PYG{n}{L}\PYG{o}{+}\PYG{n}{hl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{//free surface: Gamma\PYGZus{}f}
\PYG{k+kt}{border} \PYG{n+nf}{d}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{hl}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;} \PYG{c+c1}{// left: Gamma\PYGZus{}d}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{f}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Pu} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b}\PYG{p}{,} \PYG{n}{f}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{Pv} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{vv}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n}{q}\PYG{o}{/}\PYG{n}{K}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Loop}
\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{errv} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{erradap} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{errv} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Update}
    \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{Pu}\PYG{p}{;}
    \PYG{n}{Pv}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Error}
    \PYG{n}{errv} \PYG{o}{=} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{(}\PYG{n}{v}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Movemesh}
    \PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{mintcc} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{mint} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{v}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{mint} \PYG{o}{\PYGZlt{}} \PYG{n}{mintcc} \PYG{o}{|}\PYG{o}{|} \PYG{n}{j}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{c+c1}{//mesh too bad =\PYGZgt{} remeshing}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{erradap}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{mintcc} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{while} \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{mint} \PYG{o}{=} \PYG{n+nf}{checkmovemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{n}{v}\PYG{o}{*}\PYG{k+kp}{coef}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{mint} \PYG{o}{\PYGZgt{}} \PYG{n}{mintcc}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min |T| = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{mint} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kp}{coef} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{Th}\PYG{o}{=}\PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{coef}\PYG{o}{*}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Display}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} errv = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{errv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FreeBoundary_Sol}.png}
\caption{The final solution on the new domain \(\Omega^{72}\)}\label{\detokenize{models/free-boundary-problems:id2}}\label{\detokenize{models/free-boundary-problems:figfreeboundary-sol}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{FreeBoundary_Mesh2}.png}
\caption{The adapted mesh of the domain \(\Omega^{72}\)}\label{\detokenize{models/free-boundary-problems:id3}}\label{\detokenize{models/free-boundary-problems:figfreeboundary-mesh2}}\end{subfigure}
\phantomsection\label{\detokenize{models/free-boundary-problems:FreeBoundary}}

\end{figure}

\end{sphinxadmonition}


\section{Non\sphinxhyphen{}linear elasticity}
\label{\detokenize{models/non-linear-elasticity:non-linear-elasticity}}\label{\detokenize{models/non-linear-elasticity::doc}}
\sphinxAtStartPar
The nonlinear elasticity problem is: find the displacement \((u_{1},u_{2})\) minimizing \(J\):
\begin{equation*}
\begin{split}\min J(u_{1},u_{2}) = \int_{\Omega} f(F2) - \int_{\Gamma_{p}} P_{a} \, u_{2}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(F2(u_{1},u_{2}) = A(E[u_{1},u_{2}],E[u_{1},u_{2}])\) and \(A(X,Y)\) is bilinear symmetric positive form with respect two matrix \(X,Y\).

\sphinxAtStartPar
where \(f\) is a given \(\mathcal{C}^2\) function, and \(E[u_{1},u_{2}] = (E_{ij})_{i=1,2,\,j=1,2}\) is the Green\sphinxhyphen{}Saint Venant deformation tensor defined with:
\begin{equation*}
\begin{split}E_{ij} = 0.5 \big( ( \p_i u_j + \p_j u_i ) + \sum_k \p_i u_k {\times} \p_j u_k \big)\end{split}
\end{equation*}
\sphinxAtStartPar
Denote \(\mathbf{u}=(u_{1},u_{2})\), \(\mathbf{v}=(v_{1},v_{2})\), \(\mathbf{w}=(w_{1},w_{2})\).
So, the differential of \(J\) is:
\begin{equation*}
\begin{split}DJ(\mathbf{u})(\mathbf{v}) = \int DF2(\mathbf{u})(\mathbf{v}) \;f'(F2(\mathbf{u}))) - \int_{\Gamma_{p}} P_{a} v_{2}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(DF2(\mathbf{u})(\mathbf{v}) = 2 \; A(DE[\mathbf{u}](\mathbf{v}),E[\mathbf{u}])\) and \(DE\) is the first differential of \(E\).

\sphinxAtStartPar
The second order differential is:
\begin{equation*}
\begin{split}\begin{array}{rcl}
    D^2 J(\mathbf{u})((\mathbf{v}),(\mathbf{w})) &=& \displaystyle\int DF2(\mathbf{u})(\mathbf{v}) \; DF2(\mathbf{u})(\mathbf{w}) \; f''(F2(\mathbf{u}))) \\
    &+& \displaystyle\int \; D^2F2(\mathbf{u})(\mathbf{v},\mathbf{w}) \; f'(F2(\mathbf{u})))
\end{array}\end{split}
\end{equation*}
\sphinxAtStartPar
where:
\begin{equation*}
\begin{split}D^2F2(\mathbf{u})(\mathbf{v},\mathbf{w}) = 2 \; A(\;D^2E[\mathbf{u}](\mathbf{v},\mathbf{w})\;,\;E[\mathbf{u}]\;) + 2 \; A(\;DE[\mathbf{u}](\mathbf{v})\;,DE[\mathbf{u}](\mathbf{w})\;) .\end{split}
\end{equation*}
\sphinxAtStartPar
and \(D^{2}E\) is the second differential of \(E\).

\sphinxAtStartPar
So all notations can be define with {\hyperref[\detokenize{references/types:typemacrodesign}]{\sphinxcrossref{\DUrole{std,std-ref}{macro}}}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
 \PYG{k+kt}{macro} \PYG{n}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//is [epsilon\PYGZus{}11, 2epsilon\PYGZus{}12, epsilon\PYGZus{}22]}

 \PYG{k+kt}{macro} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}
 \PYG{p}{]} \PYG{c+c1}{//}

 \PYG{k+kt}{macro} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
     \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
 \PYG{p}{]} \PYG{c+c1}{//}

 \PYG{k+kt}{macro} \PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//is [E\PYGZus{}11, 2E\PYGZus{}12, E\PYGZus{}22]}
 \PYG{k+kt}{macro} \PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{F2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{c+c1}{//}
 \PYG{k+kt}{macro} \PYG{n}{ddF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{p}{(}
     \PYG{p}{(}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
     \PYG{o}{+} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
 \PYG{p}{)} \PYG{c+c1}{//}
\end{sphinxVerbatim}

\sphinxAtStartPar
The Newton Method is:

\sphinxAtStartPar
choose \(n=0\),and \(u_0,v_0\) the initial displacement
\begin{itemize}
\item {} 
\sphinxAtStartPar
loop:
\begin{itemize}
\item {} 
\sphinxAtStartPar
find \((du,dv)\) : solution of
\begin{equation*}
\begin{split}D^2J(u_n,v_n)((w,s),(du,dv)) = DJ(u_n,v_n)(w,s) , \quad \forall w,s\end{split}
\end{equation*}
\item {} 
\sphinxAtStartPar
\(un = un - du,\quad vn =vn - dv\)

\item {} 
\sphinxAtStartPar
until \((du,dv)\) small is enough

\end{itemize}

\end{itemize}

\sphinxAtStartPar
The way to implement this algorithm in \sphinxstylestrong{FreeFEM} is use a macro tool to implement \(A\) and \(F2\), \(f\), \(f'\),\(f''\).

\sphinxAtStartPar
A macro is like in \sphinxcode{\sphinxupquote{ccp}} preprocessor of C++, but this begin by \sphinxcode{\sphinxupquote{macro}} and the end of the macro definition is before the comment \sphinxcode{\sphinxupquote{//}}.
In this case the macro is very useful because the type of parameter can be change.
And it is easy to make automatic differentiation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{NonLinearElasticity_Mesh1}.png}
\caption{The deformed domain}\label{\detokenize{models/non-linear-elasticity:id1}}\end{figure}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//is [epsilon\PYGZus{}11, 2epsilon\PYGZus{}12, epsilon\PYGZus{}22]}

\PYG{k+kt}{macro} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{[}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}
    \PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{ENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//is [E\PYGZus{}11, 2E\PYGZus{}12, E\PYGZus{}22]}
\PYG{k+kt}{macro} \PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{EL}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{o}{+} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{n}{dENL}\PYG{p}{(}\PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{ddF2}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)} \PYG{p}{(}
      \PYG{p}{(}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{dE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
    \PYG{o}{+} \PYG{p}{(}\PYG{n}{E}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{ddE}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{uuu}\PYG{p}{,} \PYG{n}{vvv}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{2.}
    \PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{f}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.25}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{df}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{ddf}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.012e5}\PYG{p}{;} \PYG{c+c1}{//kg/cm\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mf}{0.4e5}\PYG{p}{;} \PYG{c+c1}{//kg/cm\PYGZca{}2}
\PYG{k+kt}{real} \PYG{n}{Pa} \PYG{o}{=} \PYG{l+m+mf}{1e2}\PYG{p}{;}

\PYG{c+c1}{// sigma = 2 mu E + lambda tr(E) Id}
\PYG{c+c1}{// A(u,v) = sigma(u):E(v)}
\PYG{c+c1}{//}
\PYG{c+c1}{// ( a b )}
\PYG{c+c1}{// ( b c )}
\PYG{c+c1}{//}
\PYG{c+c1}{// tr*Id : (a,b,c) \PYGZhy{}\PYGZgt{} (a+c,0,a+c)}
\PYG{c+c1}{// so the associed matrix is:}
\PYG{c+c1}{// ( 1 0 1 )}
\PYG{c+c1}{// ( 0 0 0 )}
\PYG{c+c1}{// ( 1 0 1 )}

\PYG{k+kt}{real} \PYG{n}{a11} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a22} \PYG{o}{=} \PYG{n}{mu}\PYG{p}{;} \PYG{c+c1}{//because [0, 2*t12, 0]\PYGZsq{} A [0, 2*s12,0] = 2*mu*(t12*s12 + t21*s21) = 4*mu*t12*s12}
\PYG{k+kt}{real} \PYG{n}{a33} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{mu} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a12} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a13} \PYG{o}{=} \PYG{n}{lambda}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a23} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// symetric part}
\PYG{k+kt}{real} \PYG{n}{a21} \PYG{o}{=} \PYG{n}{a12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a31} \PYG{o}{=} \PYG{n}{a13}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a32} \PYG{o}{=} \PYG{n}{a23}\PYG{p}{;}

\PYG{c+c1}{//the matrix A}
\PYG{k+kt}{func} \PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{a11}\PYG{p}{,} \PYG{n}{a12}\PYG{p}{,} \PYG{n}{a13}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{a21}\PYG{p}{,} \PYG{n}{a22}\PYG{p}{,} \PYG{n}{a23}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{a31}\PYG{p}{,} \PYG{n}{a32}\PYG{p}{,} \PYG{n}{a33}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mf}{.3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//label: 1 bottom, 2 right, 3 up, 4 left;}
\PYG{k+kt}{int} \PYG{n}{bottom} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{right} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{left} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Wh} \PYG{n}{e2}\PYG{p}{,} \PYG{n}{fe2}\PYG{p}{,} \PYG{n}{dfe2}\PYG{p}{,} \PYG{n}{ddfe2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Sh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{v1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vmass} \PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{uu}\PYG{o}{*}\PYG{n}{w} \PYG{o}{+} \PYG{n}{vv}\PYG{o}{*}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{M} \PYG{o}{=} \PYG{n}{vmass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{NonLin}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//(D\PYGZca{}2 J(un))}
           \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ddfe2}
        \PYG{o}{+} \PYG{n}{ddF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ddfe2}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{upper}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Pa}\PYG{o}{*}\PYG{n}{s}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(} \PYG{c+c1}{//(D J(un))}
          \PYG{n}{dF2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{s}\PYG{p}{)}\PYG{o}{*}\PYG{n}{dfe2}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{right}\PYG{p}{,} \PYG{n}{left}\PYG{p}{,} \PYG{n}{uu}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Newton\PYGZsq{}s method}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{e2} \PYG{o}{=} \PYG{n}{F2}\PYG{p}{(}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{dfe2} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{)} \PYG{p}{;}
    \PYG{n}{ddfe2} \PYG{o}{=} \PYG{n}{ddf}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{e2 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{e2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{e2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{de2 max = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{dfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dde2 max = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ddfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ddfe2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{NonLin}\PYG{p}{;}
    \PYG{n}{w}\PYG{p}{[}\PYG{p}{]}  \PYG{o}{=} \PYG{n}{M}\PYG{o}{*}\PYG{n}{uu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Residual}
    \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{uu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//L\PYGZca{}2 norm of [uu, vv]}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ L\PYGZca{}2 residual = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{v1} \PYG{o}{=} \PYG{n}{vv}\PYG{p}{;}
    \PYG{n}{u1} \PYG{o}{=} \PYG{n}{uu}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u1 min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u1 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{v1 min = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, v2 max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{uu}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uu, vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{un}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{uu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{k+kp}{displacement}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{res} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{un}\PYG{p}{,} \PYG{n}{vn}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{mesh} \PYG{n}{th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{un}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{vn}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Compressible Neo\sphinxhyphen{}Hookean materials}
\label{\detokenize{models/compressible-neo-hookean-materials:compressible-neo-hookean-materials}}\label{\detokenize{models/compressible-neo-hookean-materials::doc}}
\sphinxAtStartPar
Author: \sphinxstyleemphasis{Alex Sadovsky}


\subsection{Notation}
\label{\detokenize{models/compressible-neo-hookean-materials:notation}}
\sphinxAtStartPar
In what follows, the symbols \(\mathbf{u}, \bF, \bB, \bC, \stress\) denote, respectively, the displacement field, the deformation gradient, the left Cauchy\sphinxhyphen{}Green strain tensor \(\bB = \bF \bF^T\), the right Cauchy\sphinxhyphen{}Green strain tensor \(\bC =\bF^T \bF\), and the Cauchy stress tensor.

\sphinxAtStartPar
We also introduce the symbols \(I_1 := \tr \bC\) and \(J := \det\bF\).
Use will be made of the identity:
\begin{equation*}
\begin{split}{\p J \over \p \bC} = J \bC^{-1}\end{split}
\end{equation*}
\sphinxAtStartPar
The symbol \(\Id\) denotes the identity tensor.
The symbol \(\Omega_{0}\) denotes the reference configuration of the body to be deformed.
The unit volume in the reference (resp., deformed) configuration is denoted \(dV\) (resp., \(dV_{0}\)); these two are related by:
\begin{equation*}
\begin{split}dV = J dV_{0},\end{split}
\end{equation*}
\sphinxAtStartPar
which allows an integral over \(\Omega\) involving the Cauchy stress \(\bT\) to be rewritten as an integral of the Kirchhoff stress \(\kappa = J \bT\) over \(\Omega_{0}\).


\subsection{Recommended References}
\label{\detokenize{models/compressible-neo-hookean-materials:recommended-references}}
\sphinxAtStartPar
For an exposition of nonlinear elasticity and of the underlying linear and tensor algebra, see \sphinxcite{bibliography:ogden1984}.
For an advanced mathematical analysis of the Finite Element Method, see \sphinxcite{bibliography:raviart1998}.


\subsection{A Neo\sphinxhyphen{}Hookean Compressible Material}
\label{\detokenize{models/compressible-neo-hookean-materials:a-neo-hookean-compressible-material}}
\sphinxAtStartPar
\sphinxstyleemphasis{Constitutive Theory and Tangent Stress Measures}

\sphinxAtStartPar
The strain energy density function is given by:
\begin{equation*}
\begin{split}W = {\mu \over 2}(I_1 - \tr \Id - 2 \ln J)\end{split}
\end{equation*}
\sphinxAtStartPar
(see \sphinxcite{bibliography:horgan2004}, formula (12)).

\sphinxAtStartPar
The corresponding 2nd Piola\sphinxhyphen{}Kirchoff stress tensor is given by:
\begin{equation*}
\begin{split}\bS_{n} := {\p W \over \p\bE} (\bF_{n})
=
\mu (\Id - \bC^{-1})\end{split}
\end{equation*}
\sphinxAtStartPar
The Kirchhoff stress, then, is:
\begin{equation*}
\begin{split}\kappa
= \bF \bS \bF^{T}
= \mu (\bB - \Id)\end{split}
\end{equation*}
\sphinxAtStartPar
The tangent Kirchhoff stress tensor at \(\bF_{n}\) acting on \(\delta \bF_{n+1}\) is, consequently:
\begin{equation*}
\begin{split}{\p \kappa \over \p \bF} (\bF_{n}) \delta \bF_{n+1}
=
\mu
\left[
\bF_{n} (\delta \bF_{n+1})^T
+
\delta \bF_{n+1} (\bF_{n})^T
\right]\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstyleemphasis{The Weak Form of the BVP in the Absence of Body (External) Forces}

\sphinxAtStartPar
The \(\Omega_0\) we are considering is an elliptical annulus, whose boundary consists of two concentric ellipses (each allowed to be a circle as a special case), with the major axes parallel.
Let \(P\) denote the dead stress load (traction) on a portion \(\partial \Omega_0^{t}\) (= the inner ellipse) of the boundary \(\partial \Omega_0\).
On the rest of the boundary, we prescribe zero displacement.

\sphinxAtStartPar
The weak formulation of the boundary value problem is:
\begin{equation*}
\begin{split}\arr{lll}
0
& = &
\int_{\Omega_0}
\kappa[\bF]
\:
:
\:
\left\{
(\Grad \otimes \mathbf{w}) (\bF)^{-1}
\right\}\\
& - & \int_{\p \Omega_0^{t}} P \cdot \hat{N}_0\\
\rra\end{split}
\end{equation*}
\sphinxAtStartPar
For brevity, in the rest of this section we assume \(P = 0\).
The provided \sphinxstylestrong{FreeFEM} code, however, does not rely on this assumption and allows for a general value and direction of \(P\).

\sphinxAtStartPar
Given a Newton approximation \(\mathbf{u}_n\) of the displacement field \(\mathbf{u}\) satisfying the BVP, we seek the correction \(\delta \mathbf{u}_{n+1}\) to obtain a better approximation:
\begin{equation*}
\begin{split}\mathbf{u}_{n+1} = \mathbf{u}_{n} + \delta \mathbf{u}_{n+1}\end{split}
\end{equation*}
\sphinxAtStartPar
by solving the weak formulation:
\begin{equation*}
\begin{split}\arr{lll}
    0 &=& \int_{\Omega_0}\kappa[\bF_{n} + \delta \bF_{n+1}]\: :\: \left\{(\Grad \otimes \mathbf{w}) (\bF_{n} + \delta\bF_{n+1})^{-1}\right\}- \int_{\p \Omega_0} P \cdot \hat{N}_0\\
    &=& \int_{\Omega_0}\left\{\kappa[\bF_{n}] + {\p \kappa \over \p \bF}[\bF_{n}]\delta \bF_{n+1}\right\}\: :\: \left\{(\Grad \otimes \mathbf{w})(\bF_{n} + \delta \bF_{n+1})^{-1}\right\}\\
    &=& \int_{\Omega_0}\left\{\kappa[\bF_{n}] + {\p \kappa \over \p \bF}[\bF_{n}]\delta \bF_{n+1}\right\}\: :\: \left\{(\Grad \otimes \mathbf{w}) (\bF_{n}^{-1} + \bF_{n}^{-2} \delta \bF_{n+1})\right\}\\
    \\
    &=& \int_{\Omega_0}\kappa[\bF_{n}]\: :\: \left\{(\Grad \otimes \mathbf{w})\bF_{n}^{-1}\right\}\\
    &-& \int_{\Omega_0}\kappa[\bF_{n}]\: :\: \left\{(\Grad \otimes \mathbf{w})(\bF_{n}^{-2} \delta \bF_{n+1})\right\}\\
    &+& \int_{\Omega_0}\left\{{\p \kappa \over \p \bF}[\bF_{n}]\delta \bF_{n+1}\right\}\: :\: \left\{(\Grad \otimes \mathbf{w})
\bF_{n}^{-1}
\right\}
\\
\rra
\quad
\mbox{for all test functions} \mathbf{w},\end{split}
\end{equation*}
\sphinxAtStartPar
where we have taken:
\begin{equation*}
\begin{split}\delta \bF_{n+1} = \Grad \otimes \delta \mathbf{u}_{n+1}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Contrary to standard notational use, the symbol \(\delta\) here bears no variational context.
By \(\delta\) we mean simply an increment in the sense of Newton’s Method.
The role of a variational virtual displacement here is played by \(\mathbf{w}\).
\end{sphinxadmonition}


\subsection{An Approach to Implementation in FreeFEM}
\label{\detokenize{models/compressible-neo-hookean-materials:an-approach-to-implementation-in-freefem}}
\sphinxAtStartPar
Introducing the code\sphinxhyphen{}like notation, where a string in \(< >\)’s is to be read as one symbol, the individual components of the tensor:
\begin{equation*}
\begin{split}<TanK>
 :=
{\p \kappa \over \p \bF}[\bF_{n}]
\delta \bF_{n+1}\end{split}
\end{equation*}
\sphinxAtStartPar
will be implemented as the macros \(<TanK11>\), \(<TanK12>\), …

\sphinxAtStartPar
The individual components of the tensor quantities:
\begin{equation*}
\begin{split}\bD_{1} :=
\bF_{n} (\delta \bF_{n+1})^T
+
\delta \bF_{n+1} (\bF_{n})^T,\end{split}
\end{equation*}\begin{equation*}
\begin{split}\bD_{2} :=
\bF_{n}^{-T} \delta \bF_{n+1},\end{split}
\end{equation*}\begin{equation*}
\begin{split}\bD_{3} :=
(\Grad \otimes \mathbf{w})
\bF_{n}^{-2} \delta \bF_{n+1},\end{split}
\end{equation*}
\sphinxAtStartPar
and
\begin{equation*}
\begin{split}\bD_{4} :=
(\Grad \otimes \mathbf{w})
\bF_{n}^{-1},\end{split}
\end{equation*}
\sphinxAtStartPar
will be implemented as the macros:
\begin{equation*}
\begin{split}\arr{l}
<d1Aux11>, <d1Aux12>, \quad \ldots \quad, <d1Aux22>,\\
<d2Aux11>, <d2Aux12>, \quad \ldots \quad, <d2Aux22>\\
<d3Aux11>, <d3Aux12>, \quad \ldots \quad, <d3Aux22>\\
<d4Aux11>, <d4Aux12>, \quad \ldots \quad, <d4Aux22>\\
\rra,\end{split}
\end{equation*}
\sphinxAtStartPar
respectively.

\sphinxAtStartPar
In the above notation, the tangent Kirchhoff stress term becomes
\begin{equation*}
\begin{split}{\p \kappa \over \p \bF} (\bF_{n})
\: \delta \bF_{n+1}
=
\mu
\: \bD_{1}\end{split}
\end{equation*}
\sphinxAtStartPar
while the weak BVP formulation acquires the form:
\begin{equation*}
\begin{split}\arr{lll}
0 & = &
\int_{\Omega_0}
\kappa[\bF_{n}]
\:
:
\:
\bD_{4}
\\
&-&
\int_{\Omega_0}
\kappa[\bF_{n}]
\:
:
\:
\bD_{3}
\\
&+&
\int_{\Omega_0}
\left\{
{\p \kappa \over \p \bF}[\bF_{n}]
\delta \bF_{n+1}
\right\}
\:
:
\:
\bD_{4}
\\
\rra
\quad
\mbox{for all test functions} \mathbf{w}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro}
\PYG{c+c1}{//Macros for the gradient of a vector field (u1, u2)}
\PYG{k+kt}{macro} \PYG{n+nf}{grad11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{0.0} \PYG{o}{+} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{0.0} \PYG{o}{+} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the incremental deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{grad22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macro for the determinant of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the inverse of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{Finv11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Finv22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Finv12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Finv21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
    \PYG{o}{\PYGZhy{}} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the square of the inverse of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{FFinv11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
    \PYG{o}{+} \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{FFinv12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{FFinv21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{FFinv22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//Macros for the inverse of the transpose of the deformation gradient}
\PYG{k+kt}{macro} \PYG{n}{FinvT11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{FinvT12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{FinvT21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{FinvT22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}\PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{//The left Cauchy\PYGZhy{}Green strain tensor}
\PYG{k+kt}{macro} \PYG{n}{B11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{B12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{B21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{B22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The macros for the auxiliary tensors (D0, D1, D2, ...): Begin}
\PYG{o}{/}\PYG{o}{/}\PYG{n}{The} \PYG{n}{tensor} \PYG{n}{quantity} \PYG{n}{D0} \PYG{o}{=} \PYG{n}{F}\PYG{p}{\PYGZob{}}\PYG{k+kr}{n}\PYG{p}{\PYGZcb{}} \PYG{p}{(}\PYG{n}{delta} \PYG{n}{F}\PYG{p}{\PYGZob{}}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{n}{T}
\PYG{k+kt}{macro} \PYG{n}{d0Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d0Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d0Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d0Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{F22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D1 = D0 + D0\PYGZca{}T}
\PYG{k+kt}{macro} \PYG{n}{d1Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{d0Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d1Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{d0Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{d0Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d1Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{d1Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d1Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}\PYG{p}{(}
      \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{d0Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D2 = F\PYGZca{}\PYGZob{}\PYGZhy{}T\PYGZcb{}\PYGZus{}\PYGZob{}n\PYGZcb{} dF\PYGZus{}\PYGZob{}n+1\PYGZcb{}}
\PYG{k+kt}{macro} \PYG{n}{d2Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d2Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d2Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d2Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FinvT22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D3 = F\PYGZca{}\PYGZob{}\PYGZhy{}2\PYGZcb{}\PYGZus{}\PYGZob{}n\PYGZcb{} dF\PYGZus{}\PYGZob{}n+1\PYGZcb{}}
\PYG{k+kt}{macro} \PYG{n}{d3Aux11} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d3Aux12} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d3Aux21} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF11}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF21}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d3Aux22} \PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF12}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{dF22}\PYG{p}{(}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{FFinv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{///The tensor quantity D4 = (grad w) * Finv}
\PYG{k+kt}{macro} \PYG{n}{d4Aux11} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d4Aux12} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d4Aux21} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{d4Aux22} \PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Finv12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
    \PYG{o}{+} \PYG{n}{Finv22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{grad22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}
\PYG{c+c1}{//The macros for the auxiliary tensors (D0, D1, D2, ...): End}

\PYG{c+c1}{//The macros for the various stress measures: BEGIN}
\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{B11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{B12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{B21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{StressK22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{p}{(}\PYG{n}{B22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1.0}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{c+c1}{//The tangent Kirchhoff stress tensor}
\PYG{k+kt}{macro} \PYG{n}{TanK11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux11}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{TanK12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux12}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{TanK21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux21}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}

\PYG{k+kt}{macro} \PYG{n}{TanK22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{mu} \PYG{o}{*} \PYG{n}{d1Aux22}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)}
\PYG{p}{)}\PYG{c+c1}{//}
\PYG{c+c1}{//The macros for the stress tensor components: END}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{5.e2}\PYG{p}{;} \PYG{c+c1}{//Elastic coefficients (kg/cm\PYGZca{}2)}
\PYG{k+kt}{real} \PYG{n}{D} \PYG{o}{=} \PYG{l+m+mf}{1.e3}\PYG{p}{;} \PYG{c+c1}{//(1 / compressibility)}
\PYG{k+kt}{real} \PYG{n}{Pa} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.e2}\PYG{p}{;} \PYG{c+c1}{//Stress loads}

\PYG{k+kt}{real} \PYG{n}{InnerRadius} \PYG{o}{=} \PYG{l+m+mf}{1.e0}\PYG{p}{;} \PYG{c+c1}{//The wound radius}
\PYG{k+kt}{real} \PYG{n}{OuterRadius} \PYG{o}{=} \PYG{l+m+mf}{4.e0}\PYG{p}{;} \PYG{c+c1}{//The outer (truncated) radius}
\PYG{k+kt}{real} \PYG{k+kp}{tol} \PYG{o}{=} \PYG{l+m+mf}{1.e\PYGZhy{}4}\PYG{p}{;} \PYG{c+c1}{//Tolerance (L\PYGZca{}2)}
\PYG{k+kt}{real} \PYG{n}{InnerEllipseExtension} \PYG{o}{=} \PYG{l+m+mf}{1.e0}\PYG{p}{;} \PYG{c+c1}{//Extension of the inner ellipse ((major axis) \PYGZhy{} (minor axis))}

\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{InnerEdge}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{n}{InnerEllipseExtension}\PYG{p}{)}\PYG{o}{*}\PYG{n}{InnerRadius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{InnerRadius}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{OuterEdge}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{1.0} \PYG{o}{+} \PYG{l+m+mf}{0.0}\PYG{o}{*}\PYG{n}{InnerEllipseExtension}\PYG{p}{)}\PYG{o}{*}\PYG{n}{OuterRadius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{OuterRadius}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{InnerEdge}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{OuterEdge}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{bottom} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{right} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{left} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Wh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1dc}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ehat1x}\PYG{p}{,} \PYG{n}{ehat1y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ehat2x}\PYG{p}{,} \PYG{n}{ehat2y}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{auxVec1}\PYG{p}{,} \PYG{n}{auxVec2}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//The individual elements of the total 1st Piola\PYGZhy{}Kirchoff stress}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{ef1}\PYG{p}{,} \PYG{n}{ef2}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Sh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{p}\PYG{p}{,} \PYG{n}{ppp}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{StrK11}\PYG{p}{,} \PYG{n}{StrK12}\PYG{p}{,} \PYG{n}{StrK21}\PYG{p}{,} \PYG{n}{StrK22}\PYG{p}{;}
\PYG{n}{Sh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{vfMass1D}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{n}{q}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{n}{q}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Mass1D} \PYG{o}{=} \PYG{n}{vfMass1D}\PYG{p}{(}\PYG{n}{Sh}\PYG{p}{,} \PYG{n}{Sh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{p}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Mass1D} \PYG{o}{*} \PYG{n}{p}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{DomainMass} \PYG{o}{=} \PYG{n}{ppp}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DomainMass = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{DomainMass} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vmass} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(} \PYG{p}{(}\PYG{n}{u1}\PYG{o}{*}\PYG{n}{v1} \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{n}{v2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{DomainMass} \PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Mass} \PYG{o}{=} \PYG{n}{vmass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{n}{Id} \PYG{o}{=} \PYG{n}{vmass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Define the standard Euclidean basis functions}
\PYG{p}{[}\PYG{n}{ehat1x}\PYG{p}{,} \PYG{n}{ehat1y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{ehat2x}\PYG{p}{,} \PYG{n}{ehat2y}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{ContParam}\PYG{p}{,} \PYG{n}{dContParam}\PYG{p}{;}

\PYG{k+kt}{problem} \PYG{n+nf}{neoHookeanInc} \PYG{p}{(}\PYG{p}{[}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{LU}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{p}{(}
              \PYG{n}{StressK11} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux11}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{StressK12} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux12}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{StressK21} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux21}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
            \PYG{o}{+} \PYG{n}{StressK22} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d3Aux22}\PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{,} \PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK11} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK12} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK21} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{TanK22} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{,} \PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{StressK11} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux11}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{StressK12} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux12}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{StressK21} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux21}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{StressK22} \PYG{p}{(}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)} \PYG{o}{*} \PYG{n}{d4Aux22}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{,} \PYG{n}{w2}\PYG{p}{,} \PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{//Choose one of the following two boundary conditions involving Pa:}
    \PYG{c+c1}{// Load vectors normal to the boundary:}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Pa} \PYG{o}{*} \PYG{p}{(}\PYG{n}{w1}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{w2}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{//Load vectors tangential to the boundary:}
    \PYG{c+c1}{//\PYGZhy{} int1d(Th, 1)(}
    \PYG{c+c1}{//    Pa * (w1*N.y \PYGZhy{} w2*N.x)}
    \PYG{c+c1}{//)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{varu1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{varu2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{//Auxiliary variables}
\PYG{k+kt}{matrix} \PYG{n}{auxMat}\PYG{p}{;}

\PYG{c+c1}{// Newton\PYGZsq{}s method}
\PYG{n}{ContParam} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{n}{dContParam} \PYG{o}{=} \PYG{l+m+mf}{0.01}\PYG{p}{;}

\PYG{c+c1}{//Initialization:}
\PYG{p}{[}\PYG{n}{varu1}\PYG{p}{,} \PYG{n}{varu2}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,} \PYG{n}{u2n}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{k+kp}{tol}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{eforceres}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{loopcount} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{loopmax} \PYG{o}{=} \PYG{l+m+mi}{45}\PYG{p}{;}

\PYG{c+c1}{// Iterations}
\PYG{k}{while} \PYG{p}{(}\PYG{n}{loopcount} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{loopmax} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{res} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{k+kp}{tol}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{loopcount} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Loop }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{loopcount} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{neoHookeanInc}\PYG{p}{;}

    \PYG{c+c1}{// Update}
    \PYG{n}{u1} \PYG{o}{=} \PYG{n}{varu1}\PYG{p}{;}
    \PYG{n}{u2} \PYG{o}{=} \PYG{n}{varu2}\PYG{p}{;}

    \PYG{c+c1}{// Residual}
    \PYG{n}{w1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Mass}\PYG{o}{*}\PYG{n}{varu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{w1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{varu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//L\PYGZca{}2 norm of [varu1, varu2]}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ L\PYGZca{}2 residual = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Newton}
    \PYG{n}{u1n}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{varu1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{k+kp}{displacement}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Movemesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{movemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{n}{u1n}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{+}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{u1n}\PYG{p}{,}\PYG{n}{u2n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Whispering gallery modes}
\label{\detokenize{models/whispering-gallery-modes:whispering-gallery-modes}}\label{\detokenize{models/whispering-gallery-modes::doc}}
\sphinxAtStartPar
Author: \sphinxhref{http://linkeding.com/in/grudinin}{I. S. Grudinin}

\sphinxAtStartPar
In whispering gallery mode (WGM) resonators, which are typically spheres or disks, electromagnetic field is trapped by total internal reflections from the boundary.
Modes of such resonators are distinguished by compact volume and record high quality factors (Q) in a broad range of frequencies.

\sphinxAtStartPar
Modern applications of such resonators include microwave and optical cavities for atomic clocks, cavity optomechanics, nonlinear and quantum optics.
Analytical solutions for WG modes are only available for a limited number of idealized geometries, such as sphere or ellipsoid.
Since resonator dimensions are typically much larger than optical wavelength, direct application of numerical 3D finite difference time domain (FDTD) or finite element methods (FEM) is not practical.
It’s possible to solve the vectorial wave equation by reducing it to a two dimensional case by taking axial symmetry into account.

\sphinxAtStartPar
Such reduction leads to a system of 3 equations to be solved in a 2D “\(\rho-z\)” section of a resonator.
Please refer to \sphinxcite{bibliography:oxborrow2007} for a detailed derivation and to \sphinxcite{bibliography:grudinin2012} for an example of using \sphinxstylestrong{FreeFEM} to compute WGMs.


\subsection{Wave equation for the WGMs}
\label{\detokenize{models/whispering-gallery-modes:wave-equation-for-the-wgms}}
\sphinxAtStartPar
Since electric field is discontinuous on the surface of a dielectric and magnetic field is typically not, we derive our equations for the magnetic field.
The electric field can be easily derived at a later stage from \(\vec{E}=\frac{i}{\omega\epsilon_0}\hat{\epsilon}^{-1}\nabla\times\vec{H}\).
Following a standard procedure starting with Maxwell equations we derive a wave equation in a single\sphinxhyphen{}axis anisotropic medium such as an optical crystal:
\begin{equation}\label{equation:models/whispering-gallery-modes:eqn::wave}
\begin{split}\nabla\times\left(\hat{\epsilon}^{-1}\nabla\times\vec{H}\right)-k_0^2\vec{H}-\alpha\nabla\left(\nabla\cdot\vec{H}\right)=0\end{split}
\end{equation}
\sphinxAtStartPar
Here \(k_0=\omega/c\) is the wavenumber, \(\alpha\) is the penalty term added to fight spurious FEM solutions.
For anisotropic single\sphinxhyphen{}axis medium with \(\partial\hat{\epsilon}/\partial\phi=0\) in cylindrical system of coordinates we have:
\begin{equation*}
\begin{split}\hat{\epsilon}=\begin{pmatrix} \epsilon_{\rho} & 0 & 0 \\ 0 & \epsilon_{\rho} & 0 \\ 0 & 0 & \epsilon_z \end{pmatrix}. \nonumber\end{split}
\end{equation*}
\sphinxAtStartPar
We now assume axial symmetry of our electromagnetic fields and insert an imaginary unity in front of the \(H_{\phi}\) to allow all field components to be real numbers and also to account for the phase shift of this component \(\vec{H}(\rho,\phi,z)=\left\{H_{\rho}(\rho,z),iH_{\phi}(\rho,z),H_z(\rho,z)\right\}\times e^{im\phi}\).

\sphinxAtStartPar
We write the wave equation \eqref{equation:models/whispering-gallery-modes:eqn::wave} explicitly in cylindrical coordinates, thus obtaining a set of three differential equations for the domain \(\Omega\) given by the resonator’s cross section and some space outside:
\begin{equation}\label{equation:models/whispering-gallery-modes:eqn::system}
\begin{split}\begin{array}{rcl}
    A_1\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}&=&0\\ \nonumber
    A_2\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}&=&0\\ \nonumber
    A_3\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}&=&0
\end{array}\end{split}
\end{equation}
\sphinxAtStartPar
The numerical solutions of these equations and boundary conditions can be found with \sphinxstylestrong{FreeFEM} if we write the system in the weak, or integral form.


\subsection{Weak formulation}
\label{\detokenize{models/whispering-gallery-modes:weak-formulation}}
\sphinxAtStartPar
In general, to obtain the integral or “weak” statements equivalent to system \eqref{equation:models/whispering-gallery-modes:eqn::system} and boundary conditions we form a scalar dot product between an arbitrary magnetic field test function \(\mathbf{H}^t=\{{H}_{\rho}^t,{H}_{\phi}^t,{H}_{z}^t\}\) and the components of our vectorial equation \(A_1,A_2,A_3\), and integrate over the resonator’s cross section domain \(\Omega\) (and its boundary for the boundary conditions):
\begin{equation*}
\begin{split}\int\limits_{\Omega}(H^t_{\rho}A_1+H^t_{\phi}A_2+H^t_{z}A_3)d\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
We can reduce the order of partial derivatives in this integral by using the Green’s formula for integration by parts.
For example:
\begin{equation*}
\begin{split}\int\limits_{\Omega}H_z^t \frac{\partial^2 H_z}{\partial \rho^2 }d\Omega=
-\int\limits_{\Omega}\frac{\partial H_z^t}{\partial \rho}\frac{\partial H_z}{\partial \rho }d\Omega+\oint H_z^t\frac{\partial H_z}{\partial \rho}n_{\rho}d\Gamma\end{split}
\end{equation*}
\sphinxAtStartPar
Thus converting equations \eqref{equation:models/whispering-gallery-modes:eqn::system} we obtain a large expression for the weak form.


\subsection{A dielectric sphere example with FreeFEM}
\label{\detokenize{models/whispering-gallery-modes:a-dielectric-sphere-example-with-freefem}}
\sphinxAtStartPar
We now compute the fundamental mode frequency for a fused silica sphere.
The sphere is 36 micrometer in diameter, the refractive index is 1.46, the boundary condition is the magnetic wall (which can actually be omitted as it holds automatically).

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{radius} \PYG{o}{=} \PYG{l+m+mi}{36}\PYG{p}{;} \PYG{c+c1}{//approximate radius of the cavity}
\PYG{k+kt}{real} \PYG{n}{yb} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{yt} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{yb}\PYG{p}{;} \PYG{c+c1}{//window yb=bottom and yt=top coordinates}
\PYG{k+kt}{real} \PYG{n}{xl} \PYG{o}{=} \PYG{n}{radius}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{xr} \PYG{o}{=} \PYG{n}{radius}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//window xl=left and xr=right coordinates}
\PYG{k+kt}{real} \PYG{n}{angle} \PYG{o}{=} \PYG{n+nf}{asin}\PYG{p}{(}\PYG{p}{(}\PYG{n}{yt}\PYG{p}{)}\PYG{o}{/}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//angle of the sphere segment to model in radians}
\PYG{k+kt}{int} \PYG{n}{Nm} \PYG{o}{=} \PYG{l+m+mi}{60}\PYG{p}{;} \PYG{c+c1}{//number of mesh vertices per border}
\PYG{k+kt}{real} \PYG{n}{ne} \PYG{o}{=} \PYG{l+m+mf}{1.46}\PYG{p}{;} \PYG{c+c1}{//n\PYGZus{}e\PYGZhy{}extraordinary refractive index (root of permittivity parallel to z\PYGZhy{}axis, epara)}
\PYG{k+kt}{real} \PYG{n}{no} \PYG{o}{=} \PYG{l+m+mf}{1.46}\PYG{p}{;} \PYG{c+c1}{//n\PYGZus{}o\PYGZhy{}ordinary refractive index (root of permittivity orthogonal to z\PYGZhy{}axis, eorto)}
\PYG{k+kt}{real} \PYG{n}{nm} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//refractive index of surrounding medium (air)}

\PYG{k+kt}{int} \PYG{k+kp}{nev} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{// number of eigen values to find}

\PYG{k+kt}{int} \PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{213}\PYG{p}{;} \PYG{c+c1}{//azimuthal mode order \PYGZti{} 2Pi*n*R/lambda}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//penalty term}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{W1l}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xl}\PYG{o}{+}\PYG{p}{(}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yt}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W1r}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yt}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xr}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yb}\PYG{o}{+}\PYG{p}{(}\PYG{n}{yt}\PYG{o}{\PYGZhy{}}\PYG{n}{yb}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W3l}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xl}\PYG{o}{+}\PYG{p}{(}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{xl}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yb}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W3r}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yb}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{W4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{xl}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{yt}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{yt}\PYG{o}{\PYGZhy{}}\PYG{n}{yb}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{S}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{radius}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{angle}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{W1r}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W1l}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W4}\PYG{p}{(}\PYG{n}{Nm}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W3l}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W3r}\PYG{p}{(}\PYG{n}{Nm}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{W2}\PYG{p}{(}\PYG{n}{Nm}\PYG{p}{)} \PYG{o}{+} \PYG{n}{S}\PYG{p}{(}\PYG{n}{Nm}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Ph} \PYG{n}{reg} \PYG{o}{=} \PYG{k+kr}{region}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{ncav} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{n}{xl}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// cavity}
\PYG{k+kt}{int} \PYG{n}{nair} \PYG{o}{=} \PYG{n}{reg}\PYG{p}{(}\PYG{n}{xr}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//air}
\PYG{n}{Ph} \PYG{n}{eorto} \PYG{o}{=} \PYG{n}{no}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{ncav}\PYG{p}{)} \PYG{o}{+} \PYG{n}{nm}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nair}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//subdomains for epsilon values inside and outside the resonators}
\PYG{n}{Ph} \PYG{n}{epara} \PYG{o}{=} \PYG{n}{ne}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{ncav}\PYG{p}{)} \PYG{o}{+} \PYG{n}{nm}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{region}\PYG{o}{=}\PYG{o}{=}\PYG{n}{nair}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//subdomains for epsilon values inside and outside the resonators}

\PYG{c+c1}{//supplementary variables to store eigenvectors, defined on mesh Th with P2 elements \PYGZhy{} Largange quadratic.}
\PYG{k+kt}{fespace} \PYG{n+nf}{Supp}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Supp} \PYG{n}{eHsqr}\PYG{p}{;}

\PYG{c+c1}{//3d vector FE space}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{p}{[}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//magnetic field components on Vh space and test functions vH}

\PYG{c+c1}{// Macro}
\PYG{c+c1}{//boundary condition macros}
\PYG{k+kt}{macro} \PYG{n+nf}{EWall}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{)} \PYG{p}{(}
      \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hr}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{+} \PYG{n}{Hz}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}
    \PYG{o}{\PYGZhy{}} \PYG{n}{epara}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hz}\PYG{o}{*}\PYG{n}{M} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}
    \PYG{o}{+} \PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{Hr}\PYG{o}{*}\PYG{n}{M}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{MWall}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{)} \PYG{p}{(}
      \PYG{n}{Hphi} \PYG{o}{+} \PYG{n}{Hz}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{Hr}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y}
    \PYG{o}{+} \PYG{n}{epara}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hz}\PYG{o}{*}\PYG{n}{M} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{x}
    \PYG{o}{+} \PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{Hr}\PYG{o}{*}\PYG{n}{M}\PYG{o}{+}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{N}\PYG{p}{.}\PYG{k+kr}{y} \PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=}\PYG{p}{(}\PYG{n}{M}\PYG{o}{/}\PYG{p}{(}\PYG{n}{ne}\PYG{o}{*}\PYG{n}{radius}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// value of the shift (k\PYGZca{}2), where the modes will be found}
\PYG{k+kt}{varf} \PYG{n+nf}{b} \PYG{p}{(}\PYG{p}{[}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hr}\PYG{o}{*}\PYG{n}{vHr}\PYG{o}{+}\PYG{n}{Hphi}\PYG{o}{*}\PYG{n}{vHphi}\PYG{o}{+}\PYG{n}{Hz}\PYG{o}{*}\PYG{n}{vHz}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}
\PYG{c+c1}{// OP = A \PYGZhy{} sigma B ; // the shifted matrix}
\PYG{k+kt}{varf} \PYG{k+kp}{op} \PYG{p}{(}\PYG{p}{[}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{=}
    \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{p}{(}
              \PYG{p}{(}\PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{+} \PYG{n}{Hphi}\PYG{o}{*}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n}{M}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{vHr}\PYG{o}{*}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n}{epara}\PYG{o}{*}\PYG{n}{M}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{vHz}\PYG{o}{*}\PYG{n}{Hz}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{x} \PYG{c+c1}{//A/r}
            \PYG{o}{+} \PYG{n}{eorto}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hphi} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{vHr}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{epara}\PYG{o}{*}\PYG{n}{M}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHz}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Hz}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//B}
            \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n}{eorto}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)} \PYG{o}{+} \PYG{n}{epara}\PYG{o}{*}\PYG{p}{(}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHz}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hphi}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//C}
        \PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{eorto}\PYG{o}{*}\PYG{n}{epara}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}
              \PYG{p}{(}\PYG{n}{vHr}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{+} \PYG{n}{Hphi}\PYG{o}{*}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n}{M}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hphi}\PYG{p}{)}\PYG{o}{/}\PYG{k+kr}{x} \PYG{c+c1}{//D/r}
            \PYG{o}{+} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHz}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Hr} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{Hphi}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{vHr} \PYG{o}{\PYGZhy{}} \PYG{n}{M}\PYG{o}{*}\PYG{n}{vHphi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//E}
            \PYG{o}{+} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vHz}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Hz}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//F}
        \PYG{p}{)}
        \PYG{o}{\PYGZhy{}}\PYG{k+kp}{sigma}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{n}{vHr}\PYG{o}{*}\PYG{n}{Hr} \PYG{o}{+} \PYG{n}{vHphi}\PYG{o}{*}\PYG{n}{Hphi} \PYG{o}{+} \PYG{n}{vHz}\PYG{o}{*}\PYG{n}{Hz}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{//electric wall boundary condition on the boundary of computation domain}
    \PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{EWall}\PYG{p}{(}\PYG{n}{Hr}\PYG{p}{,} \PYG{n}{Hphi}\PYG{p}{,} \PYG{n}{Hz}\PYG{p}{)}\PYG{o}{*}\PYG{n}{EWall}\PYG{p}{(}\PYG{n}{vHr}\PYG{p}{,} \PYG{n}{vHphi}\PYG{p}{,} \PYG{n}{vHz}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}
\PYG{c+c1}{//setting sparce matrices and assigning the solver UMFPACK to solve eigenvalue problem}
\PYG{k+kt}{matrix} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{OP} \PYG{o}{=} \PYG{k+kp}{op}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{UMFPACK}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ev}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvalue}
\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{p}{[}\PYG{n}{eHr}\PYG{p}{,} \PYG{n}{eHphi}\PYG{p}{,} \PYG{n}{eHz}\PYG{p}{]}\PYG{p}{(}\PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to store the nev eigenvector}
\PYG{c+c1}{//calling ARPACK on sparce matrices with the assigned solver UMFPACK:}
\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{n+nf}{EigenValue}\PYG{p}{(}\PYG{n}{OP}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{,} \PYG{k+kp}{sym}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{sigma}\PYG{o}{=}\PYG{k+kp}{sigma}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{n}{ev}\PYG{p}{,} \PYG{k+kp}{vector}\PYG{o}{=}\PYG{n}{eHr}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{,} \PYG{k+kp}{maxit}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{ncv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{k} \PYG{o}{=} \PYG{k+kr}{min}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,} \PYG{k+kp}{nev}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sometimes the number of converged eigen values}
                 \PYG{c+c1}{//can be greater than nev}

\PYG{c+c1}{//file to output mode values}
\PYG{k+kt}{ofstream} \PYG{n+nf}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{modes.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//setting number of digits in the file output}
\PYG{k+kt}{int} \PYG{n}{nold} \PYG{o}{=} \PYG{n}{f}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot \PYGZam{} Save}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{k}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{lambda} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{eHsqr} \PYG{o}{=} \PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{eHr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eHphi}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{eHz}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//intensity from magnetic field components}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{eHsqr}\PYG{p}{,} \PYG{k+kp}{WindowIndex}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{LabelColors}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{aspectratio}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mode }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, lambda=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{lambda}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, F=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{p}{(}\PYG{l+m+mf}{299792.458}\PYG{o}{/}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Mode }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, ka=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{ev}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{radius} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\chapter{Examples}
\label{\detokenize{examples/index:examples}}\label{\detokenize{examples/index:id1}}\label{\detokenize{examples/index::doc}}

\section{Misc}
\label{\detokenize{examples/misc:misc}}\label{\detokenize{examples/misc::doc}}

\subsection{Poisson’s Equation}
\label{\detokenize{examples/misc:poisson-s-equation}}\label{\detokenize{examples/misc:examplepoissonequation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{H} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{l} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{NAdapt} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{L}\PYG{p}{,} \PYG{n}{l}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{h}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{h}\PYG{p}{,} \PYG{n}{H}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{l}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b5}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{l}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{H}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{b6}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{n}{H}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{L}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{p}{(}\PYG{n}{H}\PYG{o}{\PYGZhy{}}\PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b5}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b6}\PYG{p}{(}\PYG{n}{nn}\PYG{o}{*}\PYG{n}{H}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change P1 to P2 to test P2 finite element}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f} \PYG{o}{*} \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{b3}\PYG{p}{,} \PYG{n}{b4}\PYG{p}{,} \PYG{n}{b5}\PYG{p}{,} \PYG{n}{b6}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{g}\PYG{p}{)}
   \PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation iterations}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{coef} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{NAdapt}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Solve}
   \PYG{n}{Poisson}\PYG{p}{;}

   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// Adaptmesh}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error} \PYG{o}{=} \PYG{n}{error} \PYG{o}{*} \PYG{k+kp}{coef}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{poisson_associated_mesh}.jpg}
\caption{Adapted mesh}\label{\detokenize{examples/misc:id1}}\label{\detokenize{examples/misc:figexamplepoisson}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{poisson_adapted_mesh}.jpg}
\caption{Solution on adapted mesh}\label{\detokenize{examples/misc:id2}}\label{\detokenize{examples/misc:figexamplepoissonadapt}}\end{subfigure}
\caption{Poisson}

\end{figure}



\subsection{Poisson’s equation 3D}
\label{\detokenize{examples/misc:poisson-s-equation-3d}}\label{\detokenize{examples/misc:examplepoissonequation3d}}\label{\detokenize{examples/misc:Poisson}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x} \PYG{o}{+} \PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mf}{4.}\PYG{o}{*}\PYG{k+kr}{z}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mf}{5.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y} \PYG{o}{+} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{z} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0,2pi[}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{n}{f3}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{border} \PYG{n+nf}{cc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{cc}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P23d}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uhe} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{uhe min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uhe}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u2e}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n}{Lap3d} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad3}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{n}{ue}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{Lap3d}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.} \PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th3}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n+nf}{d} \PYG{o}{=} \PYG{n}{ue} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} diff l\PYGZca{}intfy = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n}{u2} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{n}{u2e} \PYG{o}{=} \PYG{n}{ue}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{,} \PYG{n}{u2e}\PYG{p}{,}\PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{poisson_3d}.jpg}
\caption{Iso\sphinxhyphen{}surfaces of the solution}\label{\detokenize{examples/misc:id3}}\end{figure}


\subsection{Stokes Equation on a cube}
\label{\detokenize{examples/misc:stokes-equation-on-a-cube}}\label{\detokenize{examples/misc:examplestokesequationonacube}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}} \PYG{c+c1}{// Dynamically loaded tools for 3D}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rdown} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rdown}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c8x8x8}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 3D mesh visualization with medit}

\PYG{c+c1}{// Fespaces}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th0}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh2} \PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{VVh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VVh} \PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{VVh} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{u3}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dz}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem (directly solved)}
\PYG{k+kt}{solve} \PYG{n}{vStokes} \PYG{p}{(}\PYG{p}{[}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{,} \PYG{n}{q}\PYG{p}{]}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{qforder}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u2}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}
        \PYG{o}{+} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u3}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v3}\PYG{p}{)}
        \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{n}{u3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q}
        \PYG{o}{\PYGZhy{}} \PYG{n}{div}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,} \PYG{n}{v2}\PYG{p}{,} \PYG{n}{v3}\PYG{p}{)} \PYG{o}{*} \PYG{n}{p}
        \PYG{o}{+} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{*} \PYG{n}{q} \PYG{o}{*} \PYG{n}{p}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{u3}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// 3D visualization of pressure isolines}

\PYG{c+c1}{// See 10 plan of the velocity in 2D}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Cut plane}
    \PYG{k+kt}{real} \PYG{n}{yy} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mf}{10.}\PYG{p}{;}
    \PYG{c+c1}{// 3D to 2D interpolation}
    \PYG{n}{ux} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{uz} \PYG{o}{=} \PYG{n}{u3}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{p2} \PYG{o}{=} \PYG{n}{p}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{n}{yy}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uz}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cut y = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{yy}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Stokes3d}.jpg}
\caption{Solution}\label{\detokenize{examples/misc:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Stokes3d-Th}.jpg}
\caption{Associated mesh}\label{\detokenize{examples/misc:id5}}\end{subfigure}
\caption{Stokes}

\end{figure}



\subsection{Cavity}
\label{\detokenize{examples/misc:cavity}}\label{\detokenize{examples/misc:examplecavity}}\label{\detokenize{examples/misc:Stokes3d}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//Parameters}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{300}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{L} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rho} \PYG{o}{=} \PYG{l+m+mf}{500.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{mu} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{uin} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fx} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{fy} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{noslip} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{inflow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{T} \PYG{o}{=} \PYG{l+m+mi}{50}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{;}

\PYG{c+c1}{//Macros}
\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{,} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{c+c1}{//}

\PYG{c+c1}{//Time}
\PYG{k+kt}{real} \PYG{n}{cpu}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{tabcpu}\PYG{p}{;}

\PYG{c+c1}{//mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C1}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C2}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C3}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{L}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C4}\PYG{p}{(}\PYG{k+kp}{t} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{L}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{L}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(} \PYG{n}{C1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{UPh}\PYG{p}{(}\PYG{n}{th}\PYG{p}{,} \PYG{p}{[}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P2}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{,} \PYG{n}{ph}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{UPh} \PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{//Solve}
\PYG{k+kt}{varf} \PYG{n+nf}{navierstokes}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{,} \PYG{n}{ph}\PYG{p}{]}\PYG{p}{)}
  \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)}\PYG{p}{(}
      \PYG{n}{rho}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{o}{+} \PYG{n}{mu}\PYG{o}{*} \PYG{p}{(}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{:}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{p}\PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n}{ph}\PYG{o}{*} \PYG{n}{div}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{*}\PYG{n}{p}\PYG{o}{*}\PYG{n}{ph}
    \PYG{p}{)}

  \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{th}\PYG{p}{)} \PYG{p}{(}
      \PYG{p}{[}\PYG{n}{fx}\PYG{p}{,} \PYG{n}{fy}\PYG{p}{]}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{o}{+} \PYG{n}{rho}\PYG{o}{/}\PYG{n}{dt}\PYG{o}{*} \PYG{p}{[}\PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{upx}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{convect}\PYG{p}{(}\PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{]}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{)}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*} \PYG{p}{[}\PYG{n}{uhx}\PYG{p}{,} \PYG{n}{uhy}\PYG{p}{]}
    \PYG{p}{)}

  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{noslip}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{n}{inflow}\PYG{p}{,} \PYG{n}{ux}\PYG{o}{=}\PYG{n}{uin}\PYG{p}{,} \PYG{n}{uy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
  \PYG{p}{;}

\PYG{c+c1}{//Initialization}
\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{NS} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{n}{UPh}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{NSrhs} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//Time loop}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{T}\PYG{o}{/}\PYG{n}{dt}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{p}{[}\PYG{n}{upx}\PYG{p}{,} \PYG{n}{upy}\PYG{p}{,} \PYG{n}{pp}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{n}{ux}\PYG{p}{,} \PYG{n}{uy}\PYG{p}{,} \PYG{n}{p}\PYG{p}{]}\PYG{p}{;}

  \PYG{n}{NSrhs} \PYG{o}{=} \PYG{n}{navierstokes}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{UPh}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{ux}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{NS}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{NSrhs}\PYG{p}{;}

  \PYG{n+nf}{plot}\PYG{p}{(} \PYG{p}{[}\PYG{n}{ux}\PYG{p}{,}\PYG{n}{uy}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//CPU}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ CPU = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
\PYG{n}{tabcpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Mesh Generation}
\label{\detokenize{examples/mesh-generation:mesh-generation}}\label{\detokenize{examples/mesh-generation:examplemeshgeneration}}\label{\detokenize{examples/mesh-generation::doc}}

\subsection{Square mesh}
\label{\detokenize{examples/mesh-generation:square-mesh}}\label{\detokenize{examples/mesh-generation:examplemeshsquare}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th0} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{x0} \PYG{o}{=} \PYG{l+m+mf}{1.2}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{x1} \PYG{o}{=} \PYG{l+m+mf}{1.8}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y0} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{y1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{20}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{m}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x0}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x1}\PYG{o}{\PYGZhy{}}\PYG{n}{x0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n+nf}{y0}\PYG{o}{+}\PYG{p}{(}\PYG{n+nf}{y1}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{y0}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{labs} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{14}\PYG{p}{]}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{flags}\PYG{o}{=}\PYG{n}{i}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{labs}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{square flags = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{i} \PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Mesh adaptation}
\label{\detokenize{examples/mesh-generation:mesh-adaptation}}\label{\detokenize{examples/mesh-generation:examplemeshadaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{0.0001}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{hmin} \PYG{o}{=} \PYG{l+m+mf}{0.05}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mf}{10.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{h}\PYG{o}{*}\PYG{n+nf}{atan2}\PYG{p}{(}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{l+m+mf}{5.0}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.0}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{fh} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;} \PYG{c+c1}{//old mesh is deleted}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{fh}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptation1}.jpg}
\caption{Initial mesh}\label{\detokenize{examples/mesh-generation:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptation2}.jpg}
\caption{Adapted mesh}\label{\detokenize{examples/mesh-generation:id2}}\end{subfigure}
\caption{Mesh adaptation}

\end{figure}



\subsection{Mesh adaptation for the Poisson’s problem}
\label{\detokenize{examples/mesh-generation:mesh-adaptation-for-the-poisson-s-problem}}\label{\detokenize{examples/mesh-generation:examplemeshadaptationforthepoissonproblem}}\label{\detokenize{examples/mesh-generation:MeshAdaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{error} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{border} \PYG{n+nf}{ba}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bc}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bd}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{k+kr}{be}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{bf}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{ba}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{+} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bc}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bd}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{k+kr}{be}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{bf}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{c+c1}{// Function}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
      \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Adaptmesh loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{Poisson}\PYG{p}{;}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{err}\PYG{o}{=}\PYG{n}{error}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{error} \PYG{o}{=} \PYG{n}{error}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoisson1}.jpg}
\caption{Initial mesh}\label{\detokenize{examples/mesh-generation:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoisson2}.jpg}
\caption{Adapted mesh}\label{\detokenize{examples/mesh-generation:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{MeshAdaptationPoissonU}.jpg}
\caption{Solution on adapted mesh}\label{\detokenize{examples/mesh-generation:id5}}\end{subfigure}
\caption{Mesh adaptation (Poisson)}

\end{figure}



\subsection{Uniform mesh adaptation}
\label{\detokenize{examples/mesh-generation:uniform-mesh-adaptation}}\label{\detokenize{examples/mesh-generation:exampleuniformmeshadaptation}}\label{\detokenize{examples/mesh-generation:MeshAdaptationPoisson}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// The initial mesh}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// More than one time due to the}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{30.}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// adaptation bound `maxsubdiv=`}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{UniformMeshAdaptation1}.jpg}
\caption{Initial mesh}\label{\detokenize{examples/mesh-generation:id6}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{UniformMeshAdaptation2}.jpg}
\caption{Adapted mesh}\label{\detokenize{examples/mesh-generation:id7}}\end{subfigure}
\caption{Uniform mesh adaptation}

\end{figure}



\subsection{Borders}
\label{\detokenize{examples/mesh-generation:borders}}\label{\detokenize{examples/mesh-generation:exampleborders}}\label{\detokenize{examples/mesh-generation:UniformMeshAdaptation}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{upper} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{others} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
   \PYG{k+kt}{int} \PYG{n}{inner} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}

   \PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{upper}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C05}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C06}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{others}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{inner}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

   \PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C05}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)}
      \PYG{o}{+} \PYG{n}{C06}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 1 has region number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.75}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
   \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Part 2 has redion number }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{(}\PYG{l+m+mf}{0.25}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.25}\PYG{p}{)}\PYG{p}{.}\PYG{k+kr}{region} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{border} \PYG{n}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{+}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//to see a plot of the border mesh}
   \PYG{k+kt}{mesh} \PYG{n}{Thwithouthole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{mesh} \PYG{n}{Thwithhole} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithouthole}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thwithhole}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{k+kt}{border} \PYG{n+nf}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{n}{r}\PYG{o}{=}\PYG{l+m+mf}{0.3}\PYG{p}{;}
   \PYG{k+kt}{border} \PYG{n+nf}{b}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{r}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{c+c1}{//  mesh Thwithhole = buildmesh(a(50) + b(\PYGZhy{}30)); // do not do this because the two}
   \PYG{c+c1}{// circles have the same radius = \PYGZdl{}0.3\PYGZdl{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders1}.jpg}
\caption{Mesh with two regions}\label{\detokenize{examples/mesh-generation:id8}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders2}.jpg}
\caption{Mesh without a hole}\label{\detokenize{examples/mesh-generation:id9}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Borders3}.jpg}
\caption{Mesh with a hole}\label{\detokenize{examples/mesh-generation:id10}}\end{subfigure}
\caption{Borders}

\end{figure}



\subsection{Change}
\label{\detokenize{examples/mesh-generation:change}}\label{\detokenize{examples/mesh-generation:examplechange}}\label{\detokenize{examples/mesh-generation:Borders}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change edges\PYGZsq{} label from 2 to 0}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r2}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Change edges\PYGZsq{} label from 4 to 0}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n}{Th1} \PYG{o}{+} \PYG{n}{Th2}\PYG{p}{;} \PYG{c+c1}{// \PYGZsq{}gluing together\PYGZsq{} Th1 and Th2 meshes}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nb lab = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}\PYG{o}{+}\PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)}
   \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int1d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{lenEdge}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ == }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{// Definition of a macro}

\PYG{k+kt}{solve} \PYG{k+kr}{P}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
   \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{Grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
   \PYG{p}{)}
   \PYG{o}{\PYGZhy{}}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{n}{v}
   \PYG{p}{)}
   \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
   \PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Change}.jpg}
\caption{Result}\label{\detokenize{examples/mesh-generation:id11}}\end{figure}


\subsection{Cube}
\label{\detokenize{examples/mesh-generation:cube}}\label{\detokenize{examples/mesh-generation:examplecube}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l6} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{37}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{57}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{r11} \PYG{o}{=} \PYG{l+m+mi}{11}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{cube}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{z}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l6}\PYG{p}{,} \PYG{k+kp}{flags} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, border area = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{bordermeasure} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{k+kp}{err} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sx} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sy} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{real} \PYG{n}{sz} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{if}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sx}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sy}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iz} \PYG{o}{=} \PYG{p}{(}\PYG{n}{sz}\PYG{o}{/}\PYG{n}{s}\PYG{o}{+}\PYG{l+m+mf}{1.5}\PYG{p}{)}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ix} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iy}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{16}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iz}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{)}\PYG{p}{;}
      \PYG{c+c1}{//value of ix,iy,iz =\PYGZgt{} face min 0, face max 2, no face 1}
      \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Label = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, s = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ix} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iy} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
      \PYG{k}{if}\PYG{p}{(} \PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ii} \PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{real} \PYG{n}{volr11} \PYG{o}{=} \PYG{n+nf}{int3d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n}{r11}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Volume region = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{volr11} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{n}{volr11} \PYG{o}{\PYGZhy{}} \PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{measure} \PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{)} \PYG{k+kp}{err}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Nb err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Cube}.jpg}
\caption{Cube}\label{\detokenize{examples/mesh-generation:id12}}\end{figure}


\subsection{Empty mesh}
\label{\detokenize{examples/mesh-generation:empty-mesh}}\label{\detokenize{examples/mesh-generation:exampleemptymesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{border} \PYG{n}{a}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
   \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ssd}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// Builds the pseudo region numbering}
   \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ssd}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k+kt}{int} \PYG{n}{iq} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{// Because we have 2 triangles per quad}
      \PYG{k+kt}{int} \PYG{n}{ix} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{k+kt}{int} \PYG{n}{iy} \PYG{o}{=} \PYG{n}{iq}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{;}
      \PYG{n}{ssd}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{p}{(}\PYG{n}{ix}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{p}{(}\PYG{n}{iy}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
   \PYG{c+c1}{// Builds an emtpy mesh with all edges that satisfy e=T1 cap T2 and ssd[T1] != ssd[T2]}
   \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{emptymesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{ssd}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// Plot}
   \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EmptyMesh1}.jpg}
\caption{Empty square}\label{\detokenize{examples/mesh-generation:id13}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{EmptyMesh2}.jpg}
\caption{Empty diamond}\label{\detokenize{examples/mesh-generation:id14}}\end{subfigure}
\caption{Empty mesh}

\end{figure}



\subsection{3 points}
\label{\detokenize{examples/mesh-generation:points}}\label{\detokenize{examples/mesh-generation:example3points}}\label{\detokenize{examples/mesh-generation:EmptyMesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Square for Three\PYGZhy{}Point Bend Specimens fixed on Fix1, Fix2}
\PYG{c+c1}{// It will be loaded on Load}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{m} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{k+kr}{n}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{Left}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Fix2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Bot3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{c}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Right}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Load}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{Top2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{b}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{Left}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Fix1}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{Fix2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Bot3}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Right}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top1}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Load}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{Top2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{3Points}.jpg}
\caption{3 Points}\label{\detokenize{examples/mesh-generation:id15}}\end{figure}


\subsection{Bezier}
\label{\detokenize{examples/mesh-generation:bezier}}\label{\detokenize{examples/mesh-generation:examplebezier}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// A cubic Bezier curve connecting two points with two control points}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{bzi}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{p0}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{p1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q1}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{q2}\PYG{p}{,} \PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{n}{p0}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{n}{q1}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kp}{t} \PYG{o}{+} \PYG{n}{q2}\PYG{o}{*}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{p1}\PYG{o}{*}\PYG{k+kp}{t}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p00} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p11} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.9}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.95}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{p21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{q30} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{1.1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.5}\PYG{p}{,} \PYG{l+m+mf}{1.2}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{border} \PYG{n+nf}{G1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p01}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q10}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p11}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q20}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{G4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{bzi}\PYG{p}{(}\PYG{n}{p21}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{p00}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q30}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{q31}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int} \PYG{k+kr}{m} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{G1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G2}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G3}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{G4}\PYG{p}{(}\PYG{k+kr}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{bw}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Bezier}.jpg}
\caption{Bezier}\label{\detokenize{examples/mesh-generation:id16}}\end{figure}


\subsection{Build layer mesh}
\label{\detokenize{examples/mesh-generation:build-layer-mesh}}\label{\detokenize{examples/mesh-generation:examplebuildlayermesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tetgen}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{C1} \PYG{o}{=} \PYG{l+m+mi}{99}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{C2} \PYG{o}{=} \PYG{l+m+mi}{98}\PYG{p}{;}

\PYG{c+c1}{// 2D mesh}
\PYG{k+kt}{border} \PYG{n+nf}{C01}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C02}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C03}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C04}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C11}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C12}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C13}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C14}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C21}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C22}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{2.5}\PYG{o}{+}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C23}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.7}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{C24}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{l+m+mf}{4.5}\PYG{o}{\PYGZhy{}}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{C2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C21}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C22}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C23}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C24}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh} \PYG{n}{Ths} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C01}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C02}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C03}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C04}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
   \PYG{o}{+} \PYG{n}{C11}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C12}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C13}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{+} \PYG{n}{C14}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a box with one hole and two regions}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{MaxLayer} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{n}{XX} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ} \PYG{o}{=} \PYG{k+kr}{z}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{,} \PYG{n}{r2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{99}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r3} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Change upper surface mesh\PYGZsq{}s triangles labels}
\PYG{c+c1}{// generated by the 2D mesh\PYGZsq{}s triangles Th}
\PYG{c+c1}{// from label 4 to label 12}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{r4} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{// Change lower surface mesh\PYGZsq{}s triangles labels}
\PYG{c+c1}{// generated by the 2D mesh\PYGZsq{}s triangles Th}
\PYG{c+c1}{// from label 4 to label 45}

\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{MaxLayer}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{region}\PYG{o}{=}\PYG{n}{r1}\PYG{p}{,}
   \PYG{k+kp}{labelmid}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{,} \PYG{k+kp}{labelup}\PYG{o}{=}\PYG{n}{r3}\PYG{p}{,} \PYG{k+kp}{labeldown}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{box 2 regions 1 hole}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Construction of a sphere with TetGen}
\PYG{k+kt}{func} \PYG{n}{XX1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{YY1} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ZZ1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.001}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{test} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{paACQ}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{test} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3sph} \PYG{o}{=} \PYG{n+nf}{tetgtransfo}\PYG{p}{(}\PYG{n}{Ths}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{XX1}\PYG{p}{,} \PYG{n}{YY1}\PYG{p}{,} \PYG{n}{ZZ1}\PYG{p}{]}\PYG{p}{,}
   \PYG{k+kp}{switch}\PYG{o}{=}\PYG{n}{test}\PYG{p}{,} \PYG{k+kp}{nbofregions}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{regionlist}\PYG{o}{=}\PYG{n}{domain}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sphere 2 regions}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3sph}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{BuildLayerMesh1}.jpg}
\caption{Box with a hole}\label{\detokenize{examples/mesh-generation:id17}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{BuildLayerMesh2}.jpg}
\caption{Sphere}\label{\detokenize{examples/mesh-generation:id18}}\end{subfigure}
\caption{Build layer mesh}

\end{figure}



\subsection{Sphere}
\label{\detokenize{examples/mesh-generation:sphere}}\label{\detokenize{examples/mesh-generation:examplesphere}}\label{\detokenize{examples/mesh-generation:BuildLayerMesh}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameter}
\PYG{k+kt}{real} \PYG{n}{hh} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// ]\PYGZhy{}pi/2, pi/2[X]0, 2pi[}
\PYG{c+c1}{// A parametrization of a sphere}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Partial derivative of the parametrization DF}
\PYG{k+kt}{func} \PYG{n}{f1x} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1y} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2y} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3x} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f3y} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//M = DF\PYGZca{}t DF}
\PYG{k+kt}{func} \PYG{n}{m11} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m21} \PYG{o}{=} \PYG{n}{f1x}\PYG{o}{*}\PYG{n}{f1y} \PYG{o}{+} \PYG{n}{f2x}\PYG{o}{*}\PYG{n}{f2y} \PYG{o}{+} \PYG{n}{f3x}\PYG{o}{*}\PYG{n}{f3y}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{m22} \PYG{o}{=} \PYG{n}{f1y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f2y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{f3y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}

\PYG{c+c1}{// Periodic condition}
\PYG{k+kt}{func} \PYG{n}{perio} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation}
\PYG{k+kt}{real} \PYG{n}{vv} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{inquire}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{m11}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m21}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{n}{m22}\PYG{o}{*}\PYG{n}{vv}\PYG{p}{,} \PYG{k+kp}{IsMetric}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{n}{perio}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Sphere}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{f1}\PYG{p}{,} \PYG{n}{f2}\PYG{p}{,} \PYG{n}{f3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Sphere1}.jpg}
\caption{Initial mesh}\label{\detokenize{examples/mesh-generation:id19}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Sphere2}.jpg}
\caption{Sphere}\label{\detokenize{examples/mesh-generation:id20}}\end{subfigure}
\caption{Sphere}\phantomsection\label{\detokenize{examples/mesh-generation:Sphere}}

\end{figure}



\section{Finite Element}
\label{\detokenize{examples/finite-element:finite-element}}\label{\detokenize{examples/finite-element:examplefinteelement}}\label{\detokenize{examples/finite-element::doc}}

\subsection{Periodic 3D}
\label{\detokenize{examples/finite-element:periodic-3d}}\label{\detokenize{examples/finite-element:exampleperiodic3d}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kr}{searchMethod}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// More safe seach algo}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nf}{d} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{l+m+mf}{0.5}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nnb} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{nni} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nz} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmin} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{zmax} \PYG{o}{=} \PYG{n}{h}\PYG{p}{;}

\PYG{c+c1}{// Mesh 2D}
\PYG{k+kt}{border} \PYG{n+nf}{b1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b2}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b3}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{b4}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{a}\PYG{o}{*}\PYG{k+kp}{t}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{border} \PYG{n+nf}{i1}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n+nf}{d}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{d}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b3}\PYG{p}{(}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b2}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{b4}\PYG{p}{(}\PYG{n}{nnb}\PYG{p}{)} \PYG{o}{+} \PYG{n}{i1}\PYG{p}{(}\PYG{n}{nni}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// Cleaning the memory correctly}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{old2new}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{sorder} \PYG{o}{=} \PYG{k+kr}{x} \PYG{o}{+} \PYG{k+kr}{y}\PYG{p}{;}
    \PYG{n+nf}{sort}\PYG{p}{(}\PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{old2new}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{new2old} \PYG{o}{=} \PYG{n}{old2new}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{// Inverse permutation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{change}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{renumv}\PYG{o}{=}\PYG{n}{new2old}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sorder}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{fespace} \PYG{n}{Vh2}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh2} \PYG{n}{nu}\PYG{p}{;}
    \PYG{n}{nu}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Th}\PYG{p}{.}\PYG{k+kr}{nv}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{nu}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nu=}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Mesh 3D}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rup} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rlow} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rmid} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtet} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{41}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{mesh3} \PYG{n}{Th3} \PYG{o}{=} \PYG{n+nf}{buildlayers}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{nz}\PYG{p}{,} \PYG{k+kp}{zbound}\PYG{o}{=}\PYG{p}{[}\PYG{n}{zmin}\PYG{p}{,} \PYG{n}{zmax}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{reftet}\PYG{o}{=}\PYG{n}{rtet}\PYG{p}{,} \PYG{k+kp}{reffacemid}\PYG{o}{=}\PYG{n}{rmid}\PYG{p}{,} \PYG{k+kp}{reffaceup}\PYG{o}{=}\PYG{n}{rup}\PYG{p}{,} \PYG{k+kp}{reffacelow}\PYG{o}{=}\PYG{n}{rlow}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ int }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{area}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Th3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th3}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th3}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{k+kr}{z}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Periodic}.jpg}
\caption{Periodic mesh}\label{\detokenize{examples/finite-element:id1}}\end{figure}


\subsection{Lagrange multipliers}
\label{\detokenize{examples/finite-element:lagrange-multipliers}}\label{\detokenize{examples/finite-element:examplelagrangemultipliers}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{k+kr}{x} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{y}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{n1} \PYG{o}{=} \PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{va} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vL} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vb} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{*}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{va}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{vL}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{vb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Block matrix}
\PYG{k+kt}{matrix} \PYG{n}{AA} \PYG{o}{=} \PYG{p}{[} \PYG{p}{[} \PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{B} \PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{]} \PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{xx}\PYG{p}{(}\PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{b1} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{// Builds the right hand side block}
\PYG{k+kp}{bb} \PYG{o}{=} \PYG{p}{[}\PYG{n}{b}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{n}{xx} \PYG{o}{=} \PYG{n}{AA}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{k+kp}{bb}\PYG{p}{;}

\PYG{c+c1}{// Set values}
\PYG{p}{[}\PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{l}\PYG{p}{]} \PYG{o}{=} \PYG{n}{xx}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ l = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{l}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ , b(u, 1) =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{uh}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{LagrangeMultipliers}.jpg}
\caption{Result}\label{\detokenize{examples/finite-element:id2}}\end{figure}


\section{Visualization}
\label{\detokenize{examples/visualization:visualization}}\label{\detokenize{examples/visualization:examplevisualization}}\label{\detokenize{examples/visualization::doc}}

\subsection{Plot}
\label{\detokenize{examples/visualization:plot}}\label{\detokenize{examples/visualization:exampleplot}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot scalar and vectorial FE function}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{k+kr}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Zoom on box defined by the two corner points [0.1,0.2] and [0.5,0.6]}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{p}{[}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
    \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{grey}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Compute a cut}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{y} \PYG{o}{=} \PYG{n}{i}\PYG{o}{/}\PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
    \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{uh}\PYG{p}{;} \PYG{c+c1}{// Value of uh at point (i/10., i/10.)}
\PYG{p}{\PYGZcb{}}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{xx}\PYG{p}{,} \PYG{n}{yy}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// File for gnuplot}
    \PYG{k+kt}{ofstream} \PYG{n}{gnu}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{gnu} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{yy}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Calls the gnuplot command, waits 5 seconds and generates a postscript plot (UNIX ONLY)}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{echo \PYGZsq{}plot }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{plot.gp}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ w l }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ pause 5 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set term postscript }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ set output }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{gnuplot.eps}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ replot }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{ quit\PYGZsq{} | gnuplot}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot1}.jpg}
\caption{First plot}\label{\detokenize{examples/visualization:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot2}.jpg}
\caption{Second plot}\label{\detokenize{examples/visualization:id2}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Plot3}.png}
\caption{Gnuplot}\label{\detokenize{examples/visualization:id3}}\end{subfigure}
\caption{Plot}

\end{figure}



\subsection{HSV}
\label{\detokenize{examples/visualization:hsv}}\label{\detokenize{examples/visualization:examplehsv}}\label{\detokenize{examples/visualization:Plot}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// From: http://en.wikipedia.org/wiki/HSV\PYGZus{}color\PYGZus{}space}
\PYG{c+c1}{// The HSV (Hue, Saturation, Value) model defines a color space}
\PYG{c+c1}{// in terms of three constituent components:}
\PYG{c+c1}{// HSV color space as a color wheel}
\PYG{c+c1}{// Hue, the color type (such as red, blue, or yellow):}
\PYG{c+c1}{// Ranges from 0\PYGZhy{}360 (but normalized to 0\PYGZhy{}100\PYGZpc{} in some applications like here)}
\PYG{c+c1}{// Saturation, the \PYGZdq{}vibrancy\PYGZdq{} of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}
\PYG{c+c1}{// The lower the saturation of a color, the more \PYGZdq{}grayness\PYGZdq{} is present}
\PYG{c+c1}{// and the more faded the color will appear.}
\PYG{c+c1}{// Value, the brightness of the color: Ranges from 0\PYGZhy{}100\PYGZpc{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{colorhsv}\PYG{o}{=}\PYG{p}{[} \PYG{c+c1}{// Color hsv model}
    \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{c+c1}{// Dark blue}
    \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Blue}
    \PYG{l+m+mf}{5.}\PYG{o}{/}\PYG{l+m+mf}{6.}\PYG{p}{,} \PYG{l+m+mi}{1} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Magenta}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{1.} \PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{c+c1}{// Red}
    \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.5} \PYG{p}{,} \PYG{l+m+mi}{1} \PYG{c+c1}{// Light red}
    \PYG{p}{]}\PYG{p}{;}
 \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{31}\PYG{p}{)}\PYG{p}{;}

 \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kp}{viso}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}

 \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{k+kp}{viso}\PYG{o}{=}\PYG{k+kp}{viso}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kp}{viso}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{hsv}\PYG{o}{=}\PYG{n}{colorhsv}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{HSV}.jpg}
\caption{Result}\label{\detokenize{examples/visualization:id4}}\end{figure}


\subsection{Medit}
\label{\detokenize{examples/visualization:medit}}\label{\detokenize{examples/visualization:examplemedit}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{n+nf}{medit}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Old way}
\PYG{n+nf}{savemesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{p}{[}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{n}{u}\PYG{o}{*}\PYG{l+m+mf}{.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Saves u.points and u.faces file}
\PYG{c+c1}{// build a u.bb file for medit}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.bb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2 1 1 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 2 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// Calls medit command}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmedit u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// Cleans files on unix\PYGZhy{}like OS}
\PYG{n+nf}{exec}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rm u.bb u.faces u.points}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Medit1}.jpg}
\caption{2D plot}\label{\detokenize{examples/visualization:id5}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Medit2}.jpg}
\caption{Plot with elevation}\label{\detokenize{examples/visualization:id6}}\end{subfigure}
\caption{Medit}

\end{figure}



\subsection{Paraview}
\label{\detokenize{examples/visualization:paraview}}\label{\detokenize{examples/visualization:exampleparaview}}\label{\detokenize{examples/visualization:Medit}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{iovtk}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Order} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{DataName} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n+nf}{savevtk}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u.vtu}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{dataname}\PYG{o}{=}\PYG{n}{DataName}\PYG{p}{,} \PYG{k+kp}{order}\PYG{o}{=}\PYG{n}{Order}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{Paraview}.jpg}
\caption{Result}\label{\detokenize{examples/visualization:id7}}\end{figure}


\section{Algorithms \& Optimizations}
\label{\detokenize{examples/algorithms-and-optimizations:algorithms-optimizations}}\label{\detokenize{examples/algorithms-and-optimizations:examplealgorithmsoptimization}}\label{\detokenize{examples/algorithms-and-optimizations::doc}}

\subsection{Algorithms}
\label{\detokenize{examples/algorithms-and-optimizations:algorithms}}\label{\detokenize{examples/algorithms-and-optimizations:examplealgorithms}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nerr} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{debugJ} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{debugdJ} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Algorithms tests}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{k+kp}{stop} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ stop = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{iter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{g}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{g}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5} \PYG{o}{|}\PYG{o}{|} \PYG{n}{iter} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{15}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{c+c1}{// minimization of J(u) = 1./2 * sum (i+1) u\PYGZus{}i\PYGZca{}2 \PYGZhy{} b\PYGZus{}i}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{u}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{//J}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{s} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//the gradiant of J (this is a affine version (the RHS is in)}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ\PYGZhy{}b: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//the gradiant of the bilinear part of J (the RHS is remove)}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{debugdJ}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dJ0: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//return of global variable ok}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//erro calculation}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n}{error} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{b}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{s} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{s} \PYG{o}{+}\PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{u}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{s}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{matId} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{int} \PYG{n}{verb}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//verbosity}
    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;} \PYG{c+c1}{//set right hand side}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;} \PYG{c+c1}{//set initial gest}

    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Affine) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}15}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{,} \PYG{k+kp}{stop}\PYG{o}{=}\PYG{k+kp}{stop}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Affine with stop) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearCG}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGC (Linear) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{AffineGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AffineGMRES (Affine) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{LinearGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LinearGMRES (Linear) : J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{matId}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{verb}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{NLCG: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{nerr} \PYG{o}{+}\PYG{o}{=} \PYG{o}{!}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


    \PYG{c+c1}{//warning: BFGS use a full matrix of size nxn (where n=u.n)}
    \PYG{n}{b}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n+nf}{BFGS}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{DJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{eps}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{nbiterline}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{BFGS: J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{error}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{nerr}\PYG{p}{)} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sol: u =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{nerr}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}} \PYG{c+c1}{// A real non linear test}
    \PYG{c+c1}{// Parameters}
    \PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.001}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
    \PYG{c+c1}{//f(u) = a*u + u\PYGZhy{}ln(1+u), f\PYGZsq{}(u) = a+ u/(1+u), f\PYGZsq{}\PYGZsq{}(u) = 1/(1+u)\PYGZca{}2}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{f}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{u}\PYG{o}{*}\PYG{n}{a}\PYG{o}{+}\PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n+nf}{log}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{df}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{n}{a}\PYG{o}{+}\PYG{n}{u}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{ddf}\PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{u}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Mesh}
    \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Fespace}
    \PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{fespace} \PYG{n+nf}{Ph}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Ph} \PYG{n}{alpha}\PYG{p}{;} \PYG{c+c1}{//store df(|nabla u|\PYGZca{}2)}

    \PYG{c+c1}{// The functionnal J}
    \PYG{c+c1}{//J(u) = 1/2 int\PYGZus{}Omega f(|nabla u|\PYGZca{}2) \PYGZhy{} int\PYGZus{}Omega u b}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
        \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{r} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n}{f}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J(u) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{r}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// The gradiant of J}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{w}\PYG{p}{;}
        \PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{au} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                  \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
                \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n}{vh}
            \PYG{p}{)}
            \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{p}{;}

        \PYG{n}{u} \PYG{o}{=} \PYG{n}{au}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Problem}
    \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{alap} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{alpha}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{amass}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{n}{uh}\PYG{o}{*}\PYG{n}{vh}
        \PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{uh}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{;}

    \PYG{k+kt}{matrix} \PYG{n}{Amass} \PYG{o}{=} \PYG{n}{amass}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{CG}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{n}{Alap}\PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Preconditionner}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}} \PYG{n}{u}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{w} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{Alap}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{u}\PYG{p}{;} \PYG{c+c1}{//warning: no return of local array variable}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{int} \PYG{n}{conv}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{conv} \PYG{o}{=} \PYG{n+nf}{NLCG}\PYG{p}{(}\PYG{n}{dJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{C}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{k+kp}{eps}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{conv}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}

        \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Alap} \PYG{o}{=} \PYG{n}{alap}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{factorize}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Restart with new preconditionner }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{conv} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, eps =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solution with NLCG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{sss}\PYG{o}{=} \PYG{n}{df}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{plot} \PYG{p}{(}\PYG{n}{sss}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{nerr}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Algorithms1}.png}
\caption{Result \sphinxcode{\sphinxupquote{u}}}\label{\detokenize{examples/algorithms-and-optimizations:id1}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{Algorithms2}.png}
\caption{\sphinxcode{\sphinxupquote{df(dx(u)*dx(u) + dy(u)*dy(u))}}}\label{\detokenize{examples/algorithms-and-optimizations:id2}}\end{subfigure}
\caption{Algorithms}

\end{figure}



\subsection{CMAES variational inequality}
\label{\detokenize{examples/algorithms-and-optimizations:cmaes-variational-inequality}}\label{\detokenize{examples/algorithms-and-optimizations:examplecmaesvariationalinequality}}\label{\detokenize{examples/algorithms-and-optimizations:Algorithms}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mf}{1000.}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ou1}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loops}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}  \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
    \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

    \PYG{c+c1}{// Function which creates a vector of the search space type from}
    \PYG{c+c1}{// two finite element functions}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{FEFToSSP} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Splits a vector from the search space and fills}
    \PYG{c+c1}{// two finite element functions with it}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{SSPToFEF} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{.}\PYG{k+kr}{l2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
        \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
        \PYG{n}{val} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{pena} \PYG{o}{*} \PYG{n}{IneqC}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{iter}\PYG{o}{\PYGZpc{}}\PYG{l+m+mi}{200} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{199}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{val} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{al} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
        \PYG{n}{start}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
        \PYG{n}{FEFToSSP}\PYG{p}{(}\PYG{n}{ou1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{n+nf}{cmaes}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{stopMaxFunEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopTolX}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}3}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialStdDev}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.025}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{n}{al}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
    \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{best1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ou1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
    \PYG{n}{ou2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{CMAESVariationalInequality}.png}
\caption{Results}\label{\detokenize{examples/algorithms-and-optimizations:id3}}\end{figure}


\subsection{IPOPT minimal surface \& volume}
\label{\detokenize{examples/algorithms-and-optimizations:ipopt-minimal-surface-volume}}\label{\detokenize{examples/algorithms-and-optimizations:exampleipoptminimalsurfacevolume}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msh3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ff\PYGZhy{}Ipopt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{0.9}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{np} \PYG{o}{=} \PYG{l+m+mi}{30}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{regtest}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{shapeswitch} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{sigma} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{40.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{treshold} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{e} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{r0} \PYG{o}{=} \PYG{l+m+mf}{0.25}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{rr} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{n}{r0}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{E} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{e}\PYG{o}{*}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{RR} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{rr}\PYG{o}{*}\PYG{n}{rr}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{p}{,} \PYG{n}{np}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//Initial shape definition}
\PYG{c+c1}{//outside of the mesh adaptation loop to initialize with the previous optimial shape found on further iterations}
\PYG{n}{Vh} \PYG{n}{startshape} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{n}{lz} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}

\PYG{c+c1}{// Mesh adaptation loop}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{lm} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{kkk} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{iter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{sin2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// A function which transform Th in 3d mesh (r=rho)}
    \PYG{c+c1}{//a point (theta,phi) of Th becomes ( r(theta,phi)*cos(theta)*sin(phi) , r(theta,phi)*sin(theta)*sin(phi) , r(theta,phi)*cos(phi) )}
    \PYG{c+c1}{//then displays the resulting mesh with medit}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{Plot3D} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kt}{string} \PYG{k+kp}{cmm}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{ffplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rhoo}\PYG{p}{;}
        \PYG{n}{rhoo}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rho}\PYG{p}{;}
        \PYG{c+c1}{//mesh sTh = square(np, np/2, [2*pi*x, pi*y]);}
        \PYG{c+c1}{//fespace sVh(sTh, P1);}
        \PYG{c+c1}{//Vh rhoplot = rhoo;}
        \PYG{k}{try}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{mesh3} \PYG{n}{Sphere} \PYG{o}{=} \PYG{n+nf}{movemesh23}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{transfo}\PYG{o}{=}\PYG{p}{[}\PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rhoo}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{ffplot}\PYG{p}{)}
                \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{else}
                \PYG{n+nf}{medit}\PYG{p}{(}\PYG{k+kp}{cmm}\PYG{p}{,} \PYG{n}{Sphere}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{PLOT ERROR}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Surface computation}
    \PYG{c+c1}{//Maybe is it possible to use movemesh23 to have the surface function less complicated}
    \PYG{c+c1}{//However, it would not simplify the gradient and the hessian}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Area} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho4} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho4}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{square}\PYG{p}{(}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rho(theta,phi) on [0,2pi]x[0,pi] \PYGZhy{} S=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{res}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
            \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{shape\PYGZus{}evolution}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{rho2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{alpha}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{alpha} \PYG{o}{=} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{varf} \PYG{n}{dArea} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}\PYG{n}{alpha}\PYG{o}{*}\PYG{n}{v} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{)}
            \PYG{p}{;}

        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dArea}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{matrix} \PYG{n}{hessianA}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianArea} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{,} \PYG{n}{rho2}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{rho2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{sqrtPsi}\PYG{p}{,} \PYG{n}{sqrtPsi3}\PYG{p}{,} \PYG{n}{C00}\PYG{p}{,} \PYG{n}{C01}\PYG{p}{,} \PYG{n}{C02}\PYG{p}{,} \PYG{n}{C11}\PYG{p}{,} \PYG{n}{C12}\PYG{p}{,} \PYG{n}{C22}\PYG{p}{,} \PYG{k+kp}{A}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{Vh} \PYG{n}{C0}\PYG{p}{,} \PYG{n}{C1}\PYG{p}{,} \PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{Vh} \PYG{n}{dxrho2} \PYG{o}{=} \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dyrho2} \PYG{o}{=} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{sqrtPsi3} \PYG{o}{=} \PYG{p}{(}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sqrtPsi}\PYG{p}{;}
            \PYG{n}{C0} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
            \PYG{n}{C1} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C2} \PYG{o}{=} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C00} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C0}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C01} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C1}\PYG{p}{;}
            \PYG{n}{C02} \PYG{o}{=} \PYG{n}{C0}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{C11} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C1}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{C12} \PYG{o}{=} \PYG{n}{C1}\PYG{o}{*}\PYG{n}{C2}\PYG{p}{;}
            \PYG{n}{C22} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{C2}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{6.}\PYG{o}{*}\PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2} \PYG{o}{+} \PYG{n}{dxrho2} \PYG{o}{+} \PYG{n}{dyrho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k+kt}{varf} \PYG{n}{d2Area} \PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
            \PYG{o}{=}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
                \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi} \PYG{o}{*} \PYG{p}{(}
                      \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{rho}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{rho2}\PYG{o}{*}\PYG{n}{sin2}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{p}{)}
                \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{sqrtPsi3} \PYG{o}{*} \PYG{p}{(}
                      \PYG{n}{C00}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C01}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}
                    \PYG{o}{+} \PYG{n}{C02}\PYG{o}{*}\PYG{n}{w}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C11}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C12}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                    \PYG{o}{+} \PYG{n}{C22}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
                \PYG{p}{)}
            \PYG{p}{)}
            \PYG{p}{;}
        \PYG{n}{hessianA} \PYG{o}{=} \PYG{n}{d2Area}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{hessianA}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Volume computation}
    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Volume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{n}{Vh} \PYG{n}{rho3} \PYG{o}{=} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{res} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho3}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{GradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n+nf}{dVolume}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{grad} \PYG{o}{=} \PYG{n}{dVolume}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{grad}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{hessianV}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{HessianVolume}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{rho}\PYG{p}{;}
        \PYG{n}{rho}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{;}
        \PYG{k+kt}{varf} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{rho}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n}{v}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{hessianV} \PYG{o}{=} \PYG{n}{d2Volume}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{hessianV}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//if we want to use the volume as a constraint function}
    \PYG{c+c1}{//we must wrap it in some freefem functions returning the appropriate type}
    \PYG{c+c1}{//The lagrangian hessian also have to be wrapped since the Volume is not linear with}
    \PYG{c+c1}{//respect to rho, it will constribbute to the hessian.}
    \PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ipVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{vol} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Volume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{k}{return} \PYG{n}{vol}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{mdV}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipGradVolume} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dvol}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{n}{GradVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;} \PYG{n}{mdV} \PYG{o}{=} \PYG{n}{dvol}\PYG{p}{;} \PYG{k}{return} \PYG{n}{mdV}\PYG{p}{;} \PYG{p}{\PYGZcb{}}
    \PYG{k+kt}{matrix} \PYG{n}{HLagrangian}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{k+kt}{matrix} \PYG{n+nf}{ipHessianLag} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{objfact}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{lambda}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{HLagrangian} \PYG{o}{=} \PYG{n}{objfact}\PYG{o}{*}\PYG{n}{HessianArea}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)} \PYG{o}{+} \PYG{n}{lambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{HessianVolume}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{HLagrangian}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//building struct for GradVolume}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{gvi}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{)}\PYG{p}{,} \PYG{n}{gvj}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{gvi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{rc} \PYG{o}{=} \PYG{n}{startshape}\PYG{p}{;} \PYG{c+c1}{//the starting value}
    \PYG{n}{Vh} \PYG{n}{ub} \PYG{o}{=} \PYG{l+m+mf}{1.e19}\PYG{p}{;} \PYG{c+c1}{//bounds definition}
    \PYG{n}{Vh} \PYG{n}{lb} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{Gaussian} \PYG{p}{(}\PYG{k+kt}{real} \PYG{n}{X}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{Y}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{theta}\PYG{p}{,} \PYG{k+kt}{real} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real} \PYG{n}{deltax2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{n}{X}\PYG{o}{\PYGZhy{}}\PYG{n}{theta}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{n}{Y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{deltay2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{Y}\PYG{o}{\PYGZhy{}}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{p}{(}\PYG{n}{deltax2} \PYG{o}{+} \PYG{n}{deltay2}\PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{k+kp}{sigma}\PYG{o}{*}\PYG{k+kp}{sigma}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{n}{disc1} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{0.1}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{func} \PYG{n}{disc2} \PYG{o}{=} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n}{RR}\PYG{o}{+}\PYG{p}{(}\PYG{n}{E}\PYG{o}{\PYGZhy{}}\PYG{n}{RR}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n}{sin2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{lb} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{q} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{q} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{q}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{q}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{o}{+}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{5.}\PYG{p}{,} \PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{n}{rr}\PYG{o}{*}\PYG{n}{Gaussian}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{,} \PYG{k+kr}{pi}\PYG{o}{/}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{lb} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{disc1}\PYG{p}{,} \PYG{n}{disc2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{Vobj} \PYG{o}{=} \PYG{n}{Volume}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real} \PYG{n}{Vnvc} \PYG{o}{=} \PYG{l+m+mf}{4.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{object\PYGZus{}inside}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{clb} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{n}{cub} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{alpha}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Vobj} \PYG{o}{+} \PYG{n}{alpha}\PYG{o}{*}\PYG{n}{Vnvc}\PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Call IPOPT}
    \PYG{k+kt}{int} \PYG{n}{res} \PYG{o}{=} \PYG{n}{IPOPT}\PYG{p}{(}\PYG{n}{Area}\PYG{p}{,} \PYG{n}{GradArea}\PYG{p}{,} \PYG{n}{ipHessianLag}\PYG{p}{,} \PYG{n}{ipVolume}\PYG{p}{,} \PYG{n}{ipGradVolume}\PYG{p}{,}
            \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ub}\PYG{o}{=}\PYG{n}{ub}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lb}\PYG{o}{=}\PYG{n}{lb}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{clb}\PYG{o}{=}\PYG{n}{clb}\PYG{p}{,} \PYG{n}{cub}\PYG{o}{=}\PYG{n}{cub}\PYG{p}{,} \PYG{n}{checkindex}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{maxiter}\PYG{o}{=}\PYG{n}{kkk}\PYG{o}{\PYGZlt{}}\PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{?} \PYG{l+m+mi}{40}\PYG{o}{:}\PYG{l+m+mi}{150}\PYG{p}{,}
            \PYG{n}{warmstart}\PYG{o}{=}\PYG{n}{kkk}\PYG{p}{,} \PYG{n}{lm}\PYG{o}{=}\PYG{n}{lm}\PYG{p}{,} \PYG{n}{uz}\PYG{o}{=}\PYG{n}{uz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{lz}\PYG{o}{=}\PYG{n}{lz}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{tol}\PYG{o}{=}\PYG{l+m+mf}{0.00001}\PYG{p}{,} \PYG{n}{structjacc}\PYG{o}{=}\PYG{p}{[}\PYG{n}{gvi}\PYG{p}{,}\PYG{n}{gvj}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{IPOPT: res =}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{res} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Shape\PYGZus{}at\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{kkk}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Plot3D}\PYG{p}{(}\PYG{n}{GradArea}\PYG{p}{(}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ShapeGradient}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{kkk} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,} \PYG{n}{rc}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{,}
            \PYG{k+kp}{nbvx}\PYG{o}{=}\PYG{l+m+mi}{50000}\PYG{p}{,} \PYG{k+kp}{periodic}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{startshape} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{;}
        \PYG{n}{uz} \PYG{o}{=} \PYG{n}{uz}\PYG{p}{;}
        \PYG{n}{lz} \PYG{o}{=} \PYG{n}{lz}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{regtest} \PYG{o}{=} \PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{rc}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{IPOPTMinimalSurfaceVolume}.png}
\caption{Mesh}\label{\detokenize{examples/algorithms-and-optimizations:id4}}\end{figure}


\subsection{CMAES MPI variational inequality}
\label{\detokenize{examples/algorithms-and-optimizations:cmaes-mpi-variational-inequality}}\label{\detokenize{examples/algorithms-and-optimizations:examplecmaesmpivariationalinequality}}
\sphinxAtStartPar
Command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{4} CMAESMPIVariationalInequality.edp \PYGZhy{}glut ffglut
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mpi\PYGZhy{}cmaes}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{NN} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f2} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g1} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{g2} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nadapt} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{starttol} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{bctol} \PYG{o}{=} \PYG{l+m+mf}{6.e\PYGZhy{}12}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{pena} \PYG{o}{=} \PYG{l+m+mi}{1000}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{NN}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ou1}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{;}

\PYG{c+c1}{// Mehs adaptation loop}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{al} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{al} \PYG{o}{\PYGZlt{}} \PYG{n}{nadapt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{al}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{varf} \PYG{n}{BVF} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
        \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
              \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
            \PYG{o}{+} \PYG{l+m+mf}{0.5}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF1} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f1}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{varf} \PYG{n+nf}{LVF2} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{f2}\PYG{o}{*}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{BVF}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b1} \PYG{o}{=} \PYG{n}{LVF1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b2} \PYG{o}{=} \PYG{n}{LVF2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{varf} \PYG{n+nf}{Vbord} \PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{v}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{Vh} \PYG{n}{In}\PYG{p}{,} \PYG{n}{Bord}\PYG{p}{;}
    \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Vbord}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{In}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Bord}\PYG{p}{[}\PYG{p}{]} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{gh1} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g1}\PYG{p}{,} \PYG{n}{gh2} \PYG{o}{=} \PYG{n}{Bord}\PYG{o}{*}\PYG{n}{g2}\PYG{p}{;}

    \PYG{c+c1}{//Function which create a vector of the search space type from}
    \PYG{c+c1}{//two finite element functions}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{FEFToSSP} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//Function spliting a vector from the search space and fills}
    \PYG{c+c1}{//two finite element functions with it}
    \PYG{k+kt}{func} \PYG{k+kt}{int} \PYG{n+nf}{SSPToFEF} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef1}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{fef2}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ssp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{kX} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{Vh}\PYG{p}{.}\PYG{k+kr}{ndof}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ssp}\PYG{p}{[}\PYG{n}{kX}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
                \PYG{o}{+}\PYG{o}{+}\PYG{n}{kX}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}\PYG{p}{\PYGZob{}}
                \PYG{n}{fef1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
                \PYG{n}{fef2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gh2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{IneqC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{constraints}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{X}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{]}\PYG{p}{;}
            \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{constraints}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{return} \PYG{n}{constraints}\PYG{p}{.}\PYG{k+kr}{l2}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{J} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{X}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{Vh} \PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{;}
        \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Au1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Au2} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Au1} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b1}\PYG{p}{;}
        \PYG{n}{Au2} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{b2}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{val} \PYG{o}{=} \PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au1} \PYG{o}{+} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Au2}\PYG{p}{;}
        \PYG{n}{val} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{pena} \PYG{o}{*} \PYG{n}{IneqC}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{adapt level }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{al}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} iteration }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} J = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{val}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{n}{val} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// Solve}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{al}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{start}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
        \PYG{n}{start}\PYG{p}{(}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{In}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{sum}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
        \PYG{n}{FEFToSSP}\PYG{p}{(}\PYG{n}{ou1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ou2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real} \PYG{n}{mini} \PYG{o}{=} \PYG{n}{cmaesMPI}\PYG{p}{(}\PYG{n}{J}\PYG{p}{,} \PYG{n}{start}\PYG{p}{,} \PYG{n}{stopMaxFunEval}\PYG{o}{=}\PYG{l+m+mi}{10000}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{stopTolX}\PYG{o}{=}\PYG{l+m+mf}{1.e\PYGZhy{}4}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{al}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{initialStdDev}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.025}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{pow}\PYG{p}{(}\PYG{l+m+mf}{100.}\PYG{p}{,}\PYG{n}{al}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Vh} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{;}
    \PYG{n}{SSPToFEF}\PYG{p}{(}\PYG{n}{best1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{start}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Mesh adaptation}
    \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{adaptmesh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n}{best1}\PYG{p}{,} \PYG{n}{best2}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{ou1} \PYG{o}{=} \PYG{n}{best1}\PYG{p}{;}
    \PYG{n}{ou2} \PYG{o}{=} \PYG{n}{best2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{CMAESMPIVariationalInequality}.png}
\caption{Result}\label{\detokenize{examples/algorithms-and-optimizations:id5}}\end{figure}


\section{Parallelization}
\label{\detokenize{examples/parallelization:parallelization}}\label{\detokenize{examples/parallelization:exampleparallelization}}\label{\detokenize{examples/parallelization::doc}}

\subsection{MPI\sphinxhyphen{}GMRES 2D}
\label{\detokenize{examples/parallelization:mpi-gmres-2d}}\label{\detokenize{examples/parallelization:examplempigmres2d}}
\sphinxAtStartPar
To launch this script, use for example:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}mpirun \PYGZhy{}np \PYG{l+m}{12} MPIGMRES2D.edp \PYGZhy{}d \PYG{l+m}{1} \PYGZhy{}k \PYG{l+m}{1} \PYGZhy{}gmres \PYG{l+m}{2} \PYGZhy{}n \PYG{l+m}{50}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{//usage :}
\PYG{c+c1}{//ff\PYGZhy{}mpirun [mpi parameter] MPIGMRES2d.edp [\PYGZhy{}glut ffglut] [\PYGZhy{}n N] [\PYGZhy{}k K] [\PYGZhy{}d D] [\PYGZhy{}ns] [\PYGZhy{}gmres [0|1]}
\PYG{c+c1}{//arguments:}
\PYG{c+c1}{//\PYGZhy{}glut ffglut : to see graphicaly the process}
\PYG{c+c1}{//\PYGZhy{}n N: set the mesh cube split NxNxN}
\PYG{c+c1}{//\PYGZhy{}d D: set debug flag D must be one for mpiplot}
\PYG{c+c1}{//\PYGZhy{}k K: to refined by K all element}
\PYG{c+c1}{//\PYGZhy{}ns: remove script dump}
\PYG{c+c1}{//\PYGZhy{}gmres}
\PYG{c+c1}{//0: use iterative schwarz algo.}
\PYG{c+c1}{//1: Algo GMRES on residu of schwarz algo}
\PYG{c+c1}{//2: DDM GMRES}
\PYG{c+c1}{//3: DDM GMRES with coarse grid preconditionner (Good one)}

\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPICG}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{medit}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{metis}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIplot.idp}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MPIGMRESmacro.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kr}{searchMethod} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//more safe seach algo (warning can be very expensive in case of lot of ouside point)}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kr}{version} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mf}{3.11}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//need at least v3.11}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ttt}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ittt}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{settt} \PYG{p}{\PYGZob{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{mpiWtime}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}

\PYG{c+c1}{// Arguments}
\PYG{k+kr}{verbosity} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}vv}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{vdebug} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{ksplit} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}k}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nloc} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sff} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}p}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{gmres} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}gmres}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{dplot} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{nC} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}N}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{nloc}\PYG{o}{/}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{verbosity}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ARGV: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if}\PYG{p}{(}\PYG{k+kr}{mpirank}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{k+kr}{verbosity}\PYG{p}{)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ vdebug: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vdebug} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, kspilt }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nloc }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, sff }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{withplot} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{withmetis} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{bool} \PYG{n}{RAS} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kt}{string} \PYG{n}{sPk} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{P2\PYGZhy{}2gd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Pk} \PYG{o}{=} \PYG{n+nc}{P2}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{sizeoverlaps} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//size of overlap}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{l111} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//mesh labels}

\PYG{c+c1}{// MPI function}
\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{plotMPIall}\PYG{p}{(}\PYG{k+kt}{mesh} \PYG{o}{\PYGZam{}}\PYG{n}{Th}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{u}\PYG{p}{,} \PYG{k+kt}{string} \PYG{n}{cm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
        \PYG{n}{PLOTMPIALL}\PYG{p}{(}\PYG{k+kt}{mesh}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{,} \PYG{n}{Th}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kp}{cmm}\PYG{o}{=}\PYG{n}{cm}\PYG{p}{,} \PYG{k+kp}{nbiso}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// MPI}
\PYG{k+kt}{mpiComm} \PYG{n+nf}{comm}\PYG{p}{(}\PYG{k+kr}{mpiCommWorld}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//trick : make a no split mpiWorld}

\PYG{k+kt}{int} \PYG{n}{npart} \PYG{o}{=} \PYG{n+nf}{mpiSize}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//total number of partion}
\PYG{k+kt}{int} \PYG{n}{ipart} \PYG{o}{=} \PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//current partition number}

\PYG{k+kt}{int} \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//Number of part with intersection (a jpart) with ipart without ipart}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{jpart}\PYG{p}{(}\PYG{n}{npart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//list of jpart}
\PYG{k}{if}\PYG{p}{(}\PYG{n}{ipart}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Final N = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit}\PYG{o}{*}\PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, nloc = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, split = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{settt}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Thg} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nloc}\PYG{p}{,} \PYG{n}{nloc}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l111}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{ThC} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nC}\PYG{p}{,} \PYG{n}{nC}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{n}{l111}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{// Coarse mesh}

\PYG{k+kt}{mesh} \PYG{n}{Thi}\PYG{p}{,} \PYG{n}{Thin}\PYG{p}{;} \PYG{c+c1}{//with overlap, without olverlap}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Phg}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Phg} \PYG{n}{part}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Vhg}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vhg} \PYG{n}{unssd}\PYG{p}{;} \PYG{c+c1}{//boolean function: 1 in the subdomain, 0 elswhere}

\PYG{k+kt}{fespace} \PYG{n+nf}{VhC}\PYG{p}{(}\PYG{n}{ThC}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// of the coarse problem}

\PYG{c+c1}{// Partitioning}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{nupart}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{.}\PYG{k+kr}{nt}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{nupart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{npart} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{metisdual}\PYG{p}{(}\PYG{n}{nupart}\PYG{p}{,} \PYG{n}{Thg}\PYG{p}{,} \PYG{n}{npart}\PYG{p}{)}\PYG{p}{;}

    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nupart}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{nupart}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{part}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{nupart}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{withplot} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{part}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dual}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Overlapping partition}
\PYG{n}{Phg} \PYG{n}{suppi} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{part}\PYG{o}{\PYGZhy{}}\PYG{n}{ipart}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.1}\PYG{p}{;}

\PYG{n}{Thin} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{suppi}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// non\PYGZhy{}overlapping mesh, interfaces have label 10}
\PYG{k+kt}{int} \PYG{n}{nnn} \PYG{o}{=} \PYG{n}{sizeoverlaps}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{c+c1}{// to be sure}
\PYG{n}{AddLayers}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{suppi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nnn}\PYG{p}{,} \PYG{n}{unssd}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//see above! suppi and unssd are modified}
\PYG{n}{unssd}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{n}{nnn}\PYG{p}{;} \PYG{c+c1}{//to put value nnn a 0}
\PYG{k+kt}{real} \PYG{n}{nnn0} \PYG{o}{=} \PYG{n}{nnn} \PYG{o}{\PYGZhy{}} \PYG{n}{sizeoverlaps} \PYG{o}{+} \PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{n}{Thi} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{unssd}\PYG{o}{\PYGZgt{}}\PYG{n}{nnn0}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//overlapping mesh, interfaces have label 10}

\PYG{n}{settt}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n}{Vhi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{npij} \PYG{o}{=} \PYG{n}{npart}\PYG{p}{;}
\PYG{n}{Vhi}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{pij}\PYG{p}{(}\PYG{n}{npij}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//local partition of unit + pii}
\PYG{n}{Vhi} \PYG{n}{pii}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{n}{nnn1} \PYG{o}{=} \PYG{o}{+}\PYG{l+m+mf}{0.001}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    construction of the partition of the unit,}
\PYG{c+cm}{    let phi\PYGZus{}i P1 FE function 1 on Thin and zero ouside of Thi and positive}
\PYG{c+cm}{    the partition is build with}
\PYG{c+cm}{    p\PYGZus{}i = phi\PYGZus{}i/ \PYGZbs{}sum phi\PYGZus{}i}

\PYG{c+cm}{    to build the partition of one domain i}
\PYG{c+cm}{    we nned to find all j such that supp(phi\PYGZus{}j) \PYGZbs{}cap supp(phi\PYGZus{}j) is not empty}
\PYG{c+cm}{    \PYGZlt{}=\PYGZgt{} int phi\PYGZus{}j}
\PYG{c+cm}{    */}
    \PYG{c+c1}{//build a local mesh of thii such that all computation of the unit partition are}
    \PYG{c+c1}{//exact in thii}
    \PYG{k+kt}{mesh} \PYG{n}{Thii} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thg}\PYG{p}{,} \PYG{n}{unssd}\PYG{o}{\PYGZgt{}}\PYG{n}{nnn1}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//overlapping mesh, interfaces have label 10}

    \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//find all j mes (supp(p\PYGZus{}j) cap supp(p\PYGZus{}i)) \PYGZgt{}0}
        \PYG{c+c1}{//compute all phi\PYGZus{}j on Thii}
        \PYG{c+c1}{//remark: supp p\PYGZus{}i include in Thi}

        \PYG{c+c1}{// Fespace}
        \PYG{k+kt}{fespace} \PYG{n}{Phii}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n+nc}{P0}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{fespace} \PYG{n+nf}{Vhii}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{Vhi} \PYG{n}{sumphi} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{Vhii} \PYG{n}{phii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

        \PYG{n}{jpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{n}{njpart} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{nlayer} \PYG{o}{=} \PYG{n}{RAS} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n}{sizeoverlaps}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nlayer = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nlayer} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n}{pii} \PYG{o}{=} \PYG{k+kr}{max}\PYG{p}{(}\PYG{n}{unssd}\PYG{o}{\PYGZhy{}}\PYG{n}{nnn}\PYG{o}{+}\PYG{n}{nlayer}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{o}{/}\PYG{n}{nlayer}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pii}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ 0000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ summ 0000}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{n}{epsmes} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{o}{*}\PYG{n}{Thii}\PYG{p}{.}\PYG{k+kr}{area}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{npart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{!}\PYG{o}{=} \PYG{n}{ipart}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n}{Phii} \PYG{n}{suppii} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{part}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{suppii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                \PYG{n}{AddLayers}\PYG{p}{(}\PYG{n}{Thii}\PYG{p}{,} \PYG{n}{suppii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nlayer}\PYG{p}{,} \PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
                \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{k+kt}{real} \PYG{n}{interij} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{interij} \PYG{o}{\PYGZgt{}} \PYG{n}{epsmes}\PYG{p}{)}\PYG{p}{\PYGZob{}}
                    \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{phii}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
                        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ***** }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{phii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
                    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
                        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ j = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{njpart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
                        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ sum j = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{+} \PYG{n}{i} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
                    \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{njpart}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dplot}\PYG{p}{)}
            \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{dim}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum }\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{fill}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{jpart}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ number of jpart }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{njpart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
                \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
            \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}6} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{sumphi}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//Thii is remove here}
\PYG{c+c1}{// end of the construction of the local partition of the unity ...}
\PYG{c+c1}{// on Thi}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build partition}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Computation of number of intersection}
\PYG{c+c1}{//here pii and the pij is the local partition of the unit on}
\PYG{c+c1}{//Thi (mesh with overlap)}
\PYG{k}{if} \PYG{p}{(} \PYG{n}{dplot}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{pij}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ j=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{j}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Partition of the unity on Thi}
\PYG{c+c1}{//computation of message}
\PYG{c+c1}{//all j \PYGZgt{} we have to receive}
\PYG{c+c1}{//data on intersection of the support of pij[0] and pij[j]}
\PYG{n}{settt}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
    \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pi\PYGZus{}i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{mesh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aThij}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{Pii}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M of send to j}
\PYG{k+kt}{matrix}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{rMj}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//M to recv from j}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whi}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{Thi}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Whij}\PYG{p}{(}\PYG{n}{Thij}\PYG{p}{,} \PYG{n}{Pk}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//}

\PYG{c+c1}{//construction of the mesh intersect i,j part}
\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{pij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{k+kr}{label}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//mesh of the supp of pij}

\PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}
    \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{ksplit}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Thi} \PYG{o}{=} \PYG{n+nf}{trunc}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{split}\PYG{o}{=}\PYG{n}{ksplit}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{settt}

\PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build mesh intersection}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Construction of transfert matrix}
\PYG{p}{\PYGZob{}}
    \PYG{n}{Whi} \PYG{n}{wpii} \PYG{o}{=} \PYG{n}{pii}\PYG{p}{;}
    \PYG{n}{Pii} \PYG{o}{=} \PYG{n}{wpii}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{jp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{jp} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{jp}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{n}{jpart}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{Thij} \PYG{o}{=} \PYG{n}{aThij}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{matrix} \PYG{n}{I} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whji \PYGZlt{}\PYGZhy{} Whi}
        \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n}{I}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;} \PYG{c+c1}{//Whi \PYGZhy{}\PYGZgt{} s Whij}
        \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//Whji \PYGZhy{}\PYGZgt{} Whi}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{p}{\PYGZob{}}\PYG{n}{Whi} \PYG{n}{uuu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{Whij} \PYG{n}{vvv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{I}\PYG{o}{*}\PYG{n}{uuu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZpc{}\PYGZpc{}\PYGZpc{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZob{}}\PYG{n}{Whi} \PYG{n}{uuu}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{Whij} \PYG{n}{vvv}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{rMj}\PYG{p}{[}\PYG{n}{jp}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{uuu}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jp} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZsh{}\PYGZsh{}\PYGZsh{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{vvv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End build transfert matrix}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Allocate array of send and recv data}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{)} \PYG{c+c1}{//initU(n, Vh, Th, aTh, U)}
\PYG{n}{InitU}\PYG{p}{(}\PYG{n}{njpart}\PYG{p}{,} \PYG{n}{Whij}\PYG{p}{,} \PYG{n}{Thij}\PYG{p}{,} \PYG{n}{aThij}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{End init data for send/revc}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{Whi} \PYG{n}{ui}\PYG{p}{,} \PYG{n}{vi}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{Update}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{ui}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{vi}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n}{Usend}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{n}{SendRecvUV}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{,} \PYG{n}{jpart}\PYG{p}{,} \PYG{n}{Usend}\PYG{p}{,} \PYG{n}{Vrecv}\PYG{p}{)}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n}{Pii}\PYG{o}{*}\PYG{n}{ui}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{njpart}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{n}{vi} \PYG{o}{+}\PYG{o}{=} \PYG{n}{rMj}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Vrecv}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{return} \PYG{k+kr}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Definition of the Problem}
\PYG{k+kt}{func} \PYG{n}{G} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mf}{0.1}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{F} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{varf} \PYG{n}{vBC} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPb} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{F}\PYG{o}{*}\PYG{n}{V}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{n}{G}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbC} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{ThC}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbon} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{varf} \PYG{n+nf}{vPbon10only} \PYG{p}{(}\PYG{n}{U}\PYG{p}{,} \PYG{n}{V}\PYG{p}{)} \PYG{o}{=} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{U}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//remark the order is important we want 0 part on 10 and 1}

\PYG{k+kt}{matrix} \PYG{n}{Ai} \PYG{o}{=} \PYG{n}{vPb}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix} \PYG{n}{AC}\PYG{p}{,} \PYG{n}{Rci}\PYG{p}{,} \PYG{n}{Pci}\PYG{p}{;}

\PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{AC} \PYG{o}{=} \PYG{n}{vPbC}\PYG{p}{(}\PYG{n}{VhC}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Pci} \PYG{o}{=} \PYG{n+nf}{interpolate}\PYG{p}{(}\PYG{n}{Whi}\PYG{p}{,} \PYG{n}{VhC}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Rci} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{Pii}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG10} \PYG{o}{=} \PYG{n}{vPbon10only}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{onG} \PYG{o}{=} \PYG{n}{vPbon}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Bi}\PYG{o}{=}\PYG{n}{vPb}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n}{kiter} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{bool} \PYG{n+nf}{CoarseSolve}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{V}\PYG{p}{,} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{,} \PYG{k+kt}{mpiComm} \PYG{o}{\PYGZam{}}\PYG{n}{comm}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//solving the coarse probleme}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Uc}\PYG{p}{(}\PYG{n}{Rci}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{Rci}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n+nf}{mpiReduce}\PYG{p}{(}\PYG{n}{Uc}\PYG{p}{,} \PYG{n}{Bc}\PYG{p}{,} \PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{k+kr}{mpiSUM}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{mpiRank}\PYG{p}{(}\PYG{n}{comm}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Uc} \PYG{o}{=} \PYG{n}{AC}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{Bc}\PYG{p}{;}
    \PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Uc}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Pci}\PYG{o}{*}\PYG{n}{Uc}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.}\PYG{o}{:} \PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//remove internal boundary}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJ} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{PDJC} \PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{CoarseSolve}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//\PYGZhy{}C2*Uo}
    \PYG{n}{U} \PYG{o}{+}\PYG{o}{=} \PYG{n}{Ai}\PYG{o}{*}\PYG{n}{V}\PYG{p}{;} \PYG{c+c1}{//U = (I\PYGZhy{}A C2) Uo}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG10} \PYG{o}{?} \PYG{l+m+mf}{0.} \PYG{o}{:} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{U} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;} \PYG{c+c1}{// (C1( I \PYGZhy{}A C2) Uo}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{U} \PYG{o}{\PYGZhy{}}\PYG{n}{V}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{U}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{DJ0}\PYG{p}{(}\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{o}{\PYGZam{}}\PYG{n}{U}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{o}{+}\PYG{o}{+}\PYG{n}{kiter}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{V}\PYG{p}{(}\PYG{n}{U}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{U}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{U}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{V}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Whi} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{p}{\PYGZob{}} \PYG{c+c1}{//verification}
    \PYG{n}{Whi} \PYG{n}{u} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{settt}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{vBC}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Whi}\PYG{p}{,} \PYG{k+kp}{tgv}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set u with tgv BC value}

\PYG{k+kt}{real} \PYG{n}{epss} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{;}
\PYG{k+kt}{int} \PYG{n}{rgmres} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPIAffineGMRES}\PYG{p}{(}\PYG{n}{DJ0}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi}\PYG{p}{;}
    \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJ}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{gmres} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
    \PYG{n}{rgmres} \PYG{o}{=} \PYG{n}{MPILinearGMRES}\PYG{p}{(}\PYG{n}{DJ}\PYG{p}{,} \PYG{k+kp}{precon}\PYG{o}{=}\PYG{n}{PDJC}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Bi}\PYG{p}{,} \PYG{k+kp}{veps}\PYG{o}{=}\PYG{n}{epss}\PYG{p}{,} \PYG{k+kp}{nbiter}\PYG{o}{=}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{n}{comm}\PYG{o}{=}\PYG{n}{comm}\PYG{p}{,} \PYG{n+nf}{dimKrylov}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{k+kr}{verbosity}\PYG{o}{=}\PYG{n}{ipart} \PYG{o}{?} \PYG{l+m+mi}{0}\PYG{o}{:} \PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else} \PYG{c+c1}{//algo Shwarz for demo}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iter} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{p}{.}\PYG{o}{*} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{b} \PYG{o}{=} \PYG{n}{onG} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{Bi} \PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Ai}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

        \PYG{n}{Update}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
            \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

        \PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{;}
        \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aa} \PYG{o}{=} \PYG{p}{[}\PYG{k+kp}{err}\PYG{p}{,} \PYG{n}{umax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{k+kp}{errg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
        \PYG{k+kt}{real} \PYG{n}{umaxg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipart} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{errg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ u. max }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{umaxg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{k+kp}{errg} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{vdebug}\PYG{p}{)}
    \PYG{n}{plotMPIall}\PYG{p}{(}\PYG{n}{Thi}\PYG{p}{,} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u\PYGZhy{}final}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{settt}

\PYG{k+kt}{real} \PYG{k+kp}{errg} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{umaxg}\PYG{p}{;}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{umax} \PYG{o}{=} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{,} \PYG{n}{umaxg}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{aa} \PYG{o}{=} \PYG{p}{[}\PYG{n}{umax}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{mpiAllReduce}\PYG{p}{(}\PYG{n}{aa}\PYG{p}{,} \PYG{k+kp}{bb}\PYG{p}{,} \PYG{n}{comm}\PYG{p}{,} \PYG{k+kr}{mpiMAX}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{errg} \PYG{o}{=} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipart} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{umax global = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{bb}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Wtime = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{ittt}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{sff} \PYG{o}{!}\PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{ff}\PYG{p}{(}\PYG{n}{sff}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ++++ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{o}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ k=}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ n= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sizeoverlaps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ it= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ittt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{epss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+cm}{/*}
\PYG{c+cm}{    1 mpirank}
\PYG{c+cm}{    2 mpisize}
\PYG{c+cm}{    3 ksplit}
\PYG{c+cm}{    4 nloc}
\PYG{c+cm}{    5 sizeoverlaps}
\PYG{c+cm}{    6 kiter}
\PYG{c+cm}{    7 mesh \PYGZam{} part build}
\PYG{c+cm}{    8 build the partion}
\PYG{c+cm}{    9 build mesh, transfere , and the fine mesh ..}
\PYG{c+cm}{    10 build the matrix, the trans matrix, factorizatioon}
\PYG{c+cm}{    11 GMRES}
\PYG{c+cm}{    */}

    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpirank} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{mpisize} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sPk} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ksplit} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nloc} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{sizeoverlaps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{kiter}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{ittt}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
        \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ttt}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{n}{ff} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{epss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{n}{nbcoef} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{Ai}\PYG{p}{.}\PYG{k+kr}{n} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{gmres} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{MPIGMRES2D}.png}
\caption{Results}\label{\detokenize{examples/parallelization:id4}}\end{figure}


\subsection{MPI\sphinxhyphen{}GMRES 3D}
\label{\detokenize{examples/parallelization:mpi-gmres-3d}}\label{\detokenize{examples/parallelization:examplempigmres3d}}
\begin{sphinxadmonition}{note}{\label{\detokenize{examples/parallelization:id1}}Todo:}
\sphinxAtStartPar
todo
\end{sphinxadmonition}


\subsection{Direct solvers}
\label{\detokenize{examples/parallelization:direct-solvers}}\label{\detokenize{examples/parallelization:exampledirectsolvers}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}SuperLU\PYGZus{}DIST\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{k+kr}{default} \PYG{k+kp}{solver}\PYG{o}{:} \PYG{k+kt}{real}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{SuperLU\PYGZus{}DIST}\PYG{p}{,} \PYG{k+kt}{complex} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{MUMPS}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{real\PYGZus{}pastix\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} pastix, complex \PYGZhy{}\PYGZgt{} MUMPS}

\PYG{c+c1}{// Solving with pastix}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffpastix\PYGZus{}iparm\PYGZus{}dparm.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with SuperLU\PYGZus{}DIST}
\PYG{n}{realdefaulttoSuperLUdist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} SuperLU\PYGZus{}DIST, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffsuperlu\PYGZus{}dist\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{k+kt}{solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Solving with MUMPS}
\PYG{n}{defaulttoMUMPS}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//default solver: real\PYGZhy{}\PYGZgt{} MUMPS, complex \PYGZhy{}\PYGZgt{} MUMPS}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10} \PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{]}\PYG{p}{,}
        \PYG{p}{[} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{solving solution}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx} \PYG{o}{\PYGZhy{}} \PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Solver MUMPS}
\label{\detokenize{examples/parallelization:solver-mumps}}\label{\detokenize{examples/parallelization:examplesolvermumps}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MUMPS\PYGZus{}FreeFem}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ICNTL}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//declaration of ICNTL parameter for MUMPS}

\PYG{c+c1}{//get value of ICNTL from file}
\PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{n}{ff}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{string} \PYG{n}{line}\PYG{p}{;}
    \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{iii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{iii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{n}{iii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{n}{ff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ICNTL}\PYG{p}{[}\PYG{n}{iii}\PYG{p}{]}\PYG{p}{;}
        \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{line}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n+nf}{broadcast}\PYG{p}{(}\PYG{n+nf}{processor}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{ICNTL}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Given data of MUMPS solver in array lparams(SYM, PAR, ICNTL)}
\PYG{c+c1}{// There is no symmetric storage for a matrix associated with a sparse solver.}
\PYG{c+c1}{// Therefore, the matrix will be considered unsymmetric for parallel sparse solver even if symmetric.}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{int} \PYG{n}{SYM} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{PAR} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}
        \PYG{p}{]}\PYG{p}{;}

    \PYG{c+c1}{// Construction of integer parameter for MUMPS}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{MumpsLParams}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{SYM}\PYG{p}{;}
    \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{PAR}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ii} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{ii} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{40}\PYG{p}{;} \PYG{n}{ii}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{MumpsLParams}\PYG{p}{[}\PYG{n}{ii}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{ICNTL}\PYG{p}{[}\PYG{n}{ii}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//ICNTL begin with index 0 here}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{lparams}\PYG{o}{=}\PYG{n}{MumpsLParams}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//we take the default value for CNTL MUMPS parameter}

    \PYG{c+c1}{// Solve}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Read parameter of MUMPS solver in file ffmumps\PYGZus{}fileparam.txt}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Problem}
    \PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=}
        \PYG{p}{[}
            \PYG{p}{[}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
            \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{22}\PYG{p}{]}
        \PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{xx} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{32}\PYG{p}{,} \PYG{l+m+mi}{45}\PYG{p}{,} \PYG{l+m+mi}{7000}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{k+kr}{x}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{di}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{xx}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nf}{set}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{,} \PYG{k+kp}{datafilename}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ffmumps\PYGZus{}fileparam.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Solve}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{x} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{x} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{di} \PYG{o}{=} \PYG{n}{xx}\PYG{o}{\PYGZhy{}}\PYG{k+kr}{x}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{k+kr}{mpirank} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x\PYGZhy{}xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Linf = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, L2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{di}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Solver superLU\_DIST}
\label{\detokenize{examples/parallelization:solver-superlu-dist}}\label{\detokenize{examples/parallelization:examplesolversuperludist}}
\begin{sphinxadmonition}{note}{\label{\detokenize{examples/parallelization:id2}}Todo:}
\sphinxAtStartPar
write code (SuperLU\_DIST seems to have a bug)
\end{sphinxadmonition}


\subsection{Solver PaStiX}
\label{\detokenize{examples/parallelization:solver-pastix}}\label{\detokenize{examples/parallelization:examplesolverpastix}}
\begin{sphinxadmonition}{note}{\label{\detokenize{examples/parallelization:id3}}Todo:}
\sphinxAtStartPar
write code (PaStiX seems to have a bug)
\end{sphinxadmonition}


\section{Developers}
\label{\detokenize{examples/developers:developers}}\label{\detokenize{examples/developers:exampledevelopers}}\label{\detokenize{examples/developers::doc}}

\subsection{FFT}
\label{\detokenize{examples/developers:fft}}\label{\detokenize{examples/developers:examplefft}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{n+nf}{dfft}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nx} \PYG{o}{=} \PYG{l+m+mi}{32}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ny} \PYG{o}{=} \PYG{l+m+mi}{16}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kr}{N} \PYG{o}{=} \PYG{n}{nx}\PYG{o}{*}\PYG{n}{ny}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f1} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{c+c1}{//warning: the fourier space is not exactly the unit square due to periodic condition}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{n}{nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{/}\PYG{n}{nx}\PYG{p}{,} \PYG{p}{(}\PYG{n}{ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{k+kr}{y}\PYG{o}{/}\PYG{n}{ny}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//warning: the numbering of the vertices (x,y) is}
\PYG{c+c1}{//given by i = x/nx + nx*y/ny}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,}\PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{u} \PYG{o}{=} \PYG{n}{f1}\PYG{p}{,} \PYG{n}{v}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{w} \PYG{o}{=} \PYG{n}{f1}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{ur}\PYG{p}{,} \PYG{n}{ui}\PYG{p}{;}

\PYG{c+c1}{// FFT}
\PYG{c+c1}{//in dfft the matrix n, m is in row\PYGZhy{}major order and array n, m is}
\PYG{c+c1}{//store j + m*i (the transpose of the square numbering)}
\PYG{n}{v}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{||u||\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{infty }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{*}\PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{k+kr}{N}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{||u||\PYGZus{}}\PYG{l+s}{\PYGZbs{}}\PYG{l+s}{infty }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{ur} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{ur}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{u}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{w} \PYG{o}{\PYGZhy{}} \PYG{n}{u}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{diff = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{norm}\PYG{p}{(}\PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}10}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Other example}
\PYG{c+c1}{//FFT Lapacian}
\PYG{c+c1}{//\PYGZhy{}\PYGZbs{}Delta u = f with biperiodic condition}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{ue} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{13.}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the exact solution}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{ff} \PYG{o}{=} \PYG{n}{f}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{fhat}\PYG{p}{;}
\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{wij}\PYG{p}{;}

\PYG{c+c1}{// FFT}
\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//warning in fact we take mode between \PYGZhy{}nx/2, nx/2 and \PYGZhy{}ny/2, ny/2}
\PYG{c+c1}{//thanks to the operator ?:}
\PYG{n}{wij} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(} \PYG{k+kr}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{o}{?}\PYG{k+kr}{x}\PYG{o}{*}\PYG{n+nl}{nx}\PYG{o}{:}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{nx}\PYG{p}{)}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{square}\PYG{p}{(}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{0.5}\PYG{o}{?}\PYG{k+kr}{y}\PYG{o}{*}\PYG{n+nl}{ny}\PYG{o}{:}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n}{ny}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;} \PYG{c+c1}{//to remove div / 0}
\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]} \PYG{p}{.}\PYG{o}{/} \PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n+nf}{dfft}\PYG{p}{(}\PYG{n}{fhat}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{u}\PYG{p}{[}\PYG{p}{]} \PYG{o}{/}\PYG{o}{=} \PYG{k+kt}{complex}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{ur} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the solution}
\PYG{n}{w} \PYG{o}{=} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{ue}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//the exact solution}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{ur}\PYG{p}{,} \PYG{k+kp}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ue}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Error}
\PYG{n}{w}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{n}{ur}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{k+kp}{err} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{min}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{err = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{err} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{assert}\PYG{p}{(}\PYG{k+kp}{err} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{fftwplan} \PYG{n}{p1} \PYG{o}{=} \PYG{n}{plandfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{fftwplan} \PYG{n}{p2} \PYG{o}{=} \PYG{n}{plandfft}\PYG{p}{(}\PYG{n}{u}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{v}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{ccc} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ny = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ny} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n}{map}\PYG{p}{(}\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ny}\PYG{p}{,} \PYG{n}{ccc}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{+}\PYG{k+kr}{y}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{wij}\PYG{p}{[}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{wij}\PYG{p}{,} \PYG{k+kp}{cmm}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{wij}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Complex}
\label{\detokenize{examples/developers:complex}}\label{\detokenize{examples/developers:examplecomplex}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{2.45}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{5.33}\PYG{p}{;}
\PYG{k+kt}{complex} \PYG{n}{z1} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{,} \PYG{n}{z2} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{;}

\PYG{k+kt}{func} \PYG{k+kt}{string} \PYG{n+nf}{pc}\PYG{p}{(}\PYG{k+kt}{complex} \PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{string} \PYG{n}{r} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{k+kt}{real}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{imag}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{n}{r} \PYG{o}{=} \PYG{n}{r} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{return} \PYG{n}{r} \PYG{o}{+} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{k+kr}{z}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{func} \PYG{k+kt}{string} \PYG{n+nf}{toPolar}\PYG{p}{(}\PYG{k+kt}{complex} \PYG{k+kr}{z}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{c+c1}{//abs(z) + \PYGZdq{}*(cos(\PYGZdq{} + arg(z) + \PYGZdq{})+i*sin(\PYGZdq{} + arg(z) + \PYGZdq{}))\PYGZdq{};}
\PYG{p}{\PYGZcb{}}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Standard output of the complex }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ is the pair: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{z1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ + }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ * }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{*}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ / }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{/}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Real part of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kt}{real}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Imaginary part of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{imag}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abs(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Polar coordinates of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{toPolar}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{de Moivre formula: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZca{}3 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{toPolar}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ and polar(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n+nf}{polar}\PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{arg}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Conjugate of }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n+nf}{conj}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZca{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{pc}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{\PYGZca{}}\PYG{n}{z2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Standard output of the complex \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} is the pair: \PYG{o}{(}\PYG{l+m}{2}.45,5.33\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} + \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{4}.9+6.74421i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYGZhy{} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{0}+3.91579i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} * \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYGZhy{}1.53526+16.5233i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} / \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{1}.692+1.19883i\PYG{o}{)}
Real part of \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{2}.45
Imaginary part of \PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}.33
abs\PYG{o}{(}\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{5}.86612
Polar coordinates of \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=}
de Moivre formula: \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)}\PYGZca{}3 \PYG{o}{=}
 and polar\PYG{o}{(}\PYG{l+m}{2}.82887, \PYG{l+m}{0}.523509\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)}
Conjugate of \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{2}.45\PYGZhy{}1.41421i\PYG{o}{)}
\PYG{o}{(}\PYG{l+m}{2}.45+5.33i\PYG{o}{)} \PYGZca{} \PYG{o}{(}\PYG{l+m}{2}.45+1.41421i\PYG{o}{)} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{8}.37072\PYGZhy{}12.7078i\PYG{o}{)}
\end{sphinxVerbatim}


\subsection{String}
\label{\detokenize{examples/developers:string}}\label{\detokenize{examples/developers:examplestring}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Concatenation}
\PYG{k+kt}{string} \PYG{n}{tt} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto1}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} 77}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Append}
\PYG{k+kt}{string} \PYG{n}{t1} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0123456789}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{t1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdefghijk\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

\PYG{c+c1}{// Sub string}
\PYG{k+kt}{string} \PYG{n}{t55} \PYG{o}{=} \PYG{n}{t1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{14}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.find(abc) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.rfind(abc) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{rfind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.find(abc, 10) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{find}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.ffind(abc, 10) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{rfind}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t1.length = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t1}\PYG{p}{.}\PYG{k+kr}{length} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{t55 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{t55} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{tt} \PYG{o}{=} toto11 \PYGZhy{}\PYGZhy{} \PYG{l+m}{77}
\PYG{n+nv}{t1} \PYG{o}{=} 0123abcdefghijk\PYGZhy{}456789
t1.find\PYG{o}{(}abc\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.rfind\PYG{o}{(}abc\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.find\PYG{o}{(}abc, \PYG{l+m}{10}\PYG{o}{)} \PYG{o}{=} \PYGZhy{}1
t1.ffind\PYG{o}{(}abc, \PYG{l+m}{10}\PYG{o}{)} \PYG{o}{=} \PYG{l+m}{4}
t1.length \PYG{o}{=} \PYG{l+m}{22}
\PYG{n+nv}{t55} \PYG{o}{=} abcdefghijk
\end{sphinxVerbatim}


\subsection{Elementary function}
\label{\detokenize{examples/developers:elementary-function}}\label{\detokenize{examples/developers:exampleelementaryfunction}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n}{b}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{phix}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{func} \PYG{k+kt}{real} \PYG{n+nf}{phiy}\PYG{p}{(}\PYG{k+kt}{real} \PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{o}{*}\PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{n}{b}\PYG{p}{)}\PYG{o}{/}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{border} \PYG{n+nf}{C}\PYG{p}{(}\PYG{k+kp}{t}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{pi}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{k+kr}{x}\PYG{o}{=}\PYG{n}{phix}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;} \PYG{k+kr}{y}\PYG{o}{=}\PYG{n}{phiy}\PYG{p}{(}\PYG{k+kp}{t}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{buildmesh}\PYG{p}{(}\PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.500\linewidth]{{ElementaryFunction}.png}
\caption{Mesh}\label{\detokenize{examples/developers:id1}}\end{figure}


\subsection{Array}
\label{\detokenize{examples/developers:array}}\label{\detokenize{examples/developers:examplearray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{tab}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{n}{tab1}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2 array of 10 real}
\PYG{c+c1}{//real[int] tab2; //bug: array with no size}

\PYG{n}{tab} \PYG{o}{=} \PYG{l+m+mf}{1.03}\PYG{p}{;} \PYG{c+c1}{//set all the array to 1.03}
\PYG{n}{tab}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{2.15}\PYG{p}{;}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tab: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{tab}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//change the size of array tab to 12 with preserving first value}
\PYG{n}{tab}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{:}\PYG{l+m+mi}{11}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mf}{3.14}\PYG{p}{;} \PYG{c+c1}{//set values 10 \PYGZam{} 11}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{resized tab: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{n}{tab}\PYG{p}{.}\PYG{n+nf}{sort} \PYG{p}{;} \PYG{c+c1}{//sort the array tab}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sorted tab:}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tab} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{tt}\PYG{p}{;} \PYG{c+c1}{//array with string index}
\PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{tt[}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{o}{+}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{tt}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{o}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{d}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{n}{c} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1 : d[i] = a[i] ? b[i] : c[i]}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ d = ( a ? b : c ) is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{n}{c} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? 1 : c[i]}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{n+nl}{b} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? b[i] : 0}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{p}{(} \PYG{n}{a} \PYG{o}{?} \PYG{l+m+mi}{1} \PYG{o}{:} \PYG{l+m+mi}{0} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for i = 0, n\PYGZhy{}1: d[i] = a[i] ? 0 : 1}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{ii}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{n+nf}{d}\PYG{p}{.}\PYG{k+kr}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//set array ii to 0, 1, ..., d.n\PYGZhy{}1}
\PYG{n+nf}{d} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//set d to \PYGZhy{}1, \PYGZhy{}2, ..., \PYGZhy{}5}

\PYG{n+nf}{sort}\PYG{p}{(}\PYG{n+nf}{d}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//sort array d and ii in parallel}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{d: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{d} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ii: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}


\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A1(2:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A2(2:3:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{A1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1:2:5 =\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{:}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A1(2:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A2(2:3:10): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{A1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{:}\PYG{l+m+mf}{0.5}\PYG{o}{:}\PYG{l+m+mf}{3.999}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.:0.5:3.999 =\PYGZgt{} }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n+nl}{i}\PYG{o}{:}\PYG{l+m+mf}{10.}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 3, 4, 5, 6, 7, 8, 9, 10}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{A2}\PYG{p}{(}\PYG{l+m+mf}{2.}\PYG{o}{:}\PYG{l+m+mf}{3.}\PYG{o}{:}\PYG{l+m+mf}{10.}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//2, 5, 8}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1(2.+0i:10.+0i): }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A2(2.:3.:10.)= }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{A2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1.re real part array: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1}\PYG{p}{.}\PYG{k+kr}{re} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
    \PYG{c+c1}{// he real part array of the complex array}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ A1.im imag part array: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1}\PYG{p}{.}\PYG{k+kr}{im} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl} \PYG{p}{;}
    \PYG{c+c1}{//the imaginary part array of the complex array}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Integer array operators}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{4}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{o}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a + a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b += a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b += 2*a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{/}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ b /= 2: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{.}\PYG{o}{*}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{// same as b = b .* a}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b .*= a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{b} \PYG{p}{.}\PYG{o}{/}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//same as b = b ./ a}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b ./= a: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a + b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = 2*a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a + 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a \PYGZhy{} 4b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = \PYGZhy{}a \PYGZhy{}b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{p}{.}\PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a .* b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{p}{.}\PYG{o}{/} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = a ./ b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{b}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = 2 * b: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{n}{b} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c = b * 2: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//this operator do not exist}
    \PYG{c+c1}{//c = b/2;}
    \PYG{c+c1}{//cout \PYGZlt{}\PYGZlt{} \PYGZdq{}c = b / 2: \PYGZdq{} \PYGZlt{}\PYGZlt{} c \PYGZlt{}\PYGZlt{} endl;}

    \PYG{c+c1}{//Array methods}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{||a||\PYGZus{}1 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{l1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{||a||\PYGZus{}2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{l2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{||a||\PYGZus{}infty = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{linfty} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{sum a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{sum} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{max a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a[ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imax} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{min a\PYGZus{}i = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ a[ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imin} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ ] = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{[}\PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a\PYGZsq{} * a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{a}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a quantile 0.2 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a}\PYG{p}{.}\PYG{k+kr}{quantile}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//Array mapping}
    \PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{c} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} b.n; i++) if (I[i] \PYGZgt{}= 0) b[i] = a[I[i]];}
    \PYG{n}{c}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} I.n; i++) if (I[i] \PYGZgt{}= 0) C(I[i]) = a[i];}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a(I) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c(I) = a }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{c}\PYG{p}{(}\PYG{n}{I}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{n}{a}\PYG{p}{;} \PYG{c+c1}{//for (i = 0; i \PYGZlt{} I.n; i++) if (I[i] \PYGZgt{}= 0) C(I[i]) += a[i];}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = a(I) : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c(I) = a }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{c} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Array versus matrix}
    \PYG{k+kt}{int} \PYG{k+kr}{N} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}

    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{)}\PYG{p}{,} \PYG{n}{c}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
    \PYG{n}{c} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{k+kr}{N}\PYG{p}{,} \PYG{n}{M}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{complex}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{cb} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cc} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{10}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{30}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{40}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{b} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{J} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}

    \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//set all the matrix}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{:}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;} \PYG{c+c1}{//the full line 2}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{o}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;} \PYG{c+c1}{//the full column 1}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{k+kr}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{c+c1}{//set the column 2}
    \PYG{k+kp}{A}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{c+c1}{//set the line 1 from 0 to 2}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//outer product}
    \PYG{n}{C} \PYG{o}{=} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{C} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{3} \PYG{o}{*} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{n}{C} \PYG{o}{\PYGZhy{}}\PYG{o}{=} \PYG{l+m+mi}{5}\PYG{n}{i} \PYG{o}{*} \PYG{n}{cb} \PYG{o}{*} \PYG{n}{cc}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{C} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//this transforms an array into a sparse matrix}
    \PYG{k+kt}{matrix} \PYG{k+kp}{B}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B(i, j) = A(I(i), J(j))}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//B(I(i), J(j)) = A(i,j)}

    \PYG{c+c1}{//outer product}
    \PYG{k+kp}{A} \PYG{o}{=} \PYG{l+m+mf}{2.} \PYG{o}{*} \PYG{n}{b} \PYG{o}{*} \PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(i)*c(j)}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(i)*c(j)}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//outer product B(i, j) = b(I(i))*c(J(j))}
    \PYG{k+kp}{B} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mf}{3.}\PYG{o}{*}\PYG{n}{b}\PYG{o}{*}\PYG{n}{c}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{(}\PYG{n}{I}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{J}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//outer product B(I(i), J(j)) = b(i)*c(j)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{B = (3.*b*c\PYGZsq{})(I\PYGZca{}\PYGZhy{}1,J\PYGZca{}\PYGZhy{}1) = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//row and column of the maximal coefficient of A}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{,} \PYG{n}{jj}\PYG{p}{;}
    \PYG{n}{ijmax}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{ii}\PYG{p}{,} \PYG{n}{jj}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{i} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{imax}\PYG{p}{;}
    \PYG{n}{j} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{jmax}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Max }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{//row and column of the minimal coefficient of A}
    \PYG{n}{ijmin}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ii} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{imin}\PYG{p}{;}
    \PYG{n}{jj} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{n}{jmin}\PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Min }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ii} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{jj} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{min} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output os this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
tab: \PYG{l+m}{10}
    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03

min: \PYG{l+m}{1}.03
max: \PYG{l+m}{2}.15
sum: \PYG{l+m}{11}.42
resized tab: \PYG{l+m}{12}
    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{3}.14    \PYG{l+m}{3}.14
sorted tab:12
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03
    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{1}.03    \PYG{l+m}{2}.15
    \PYG{l+m}{3}.14    \PYG{l+m}{3}.14
tt\PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}a\PYGZdq{}}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{0}
tt\PYG{o}{[}\PYG{l+s+s2}{\PYGZdq{}+\PYGZdq{}}\PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}.5
 \PYG{n+nv}{d} \PYG{o}{=} \PYG{o}{(} a ? b : c \PYG{o}{)} is \PYG{l+m}{5}
      \PYG{l+m}{2}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{2}   \PYG{l+m}{2}

d: \PYG{l+m}{5}
     \PYGZhy{}5  \PYGZhy{}4  \PYGZhy{}3  \PYGZhy{}2  \PYGZhy{}1

ii: \PYG{l+m}{5}
      \PYG{l+m}{4}   \PYG{l+m}{3}   \PYG{l+m}{2}   \PYG{l+m}{1}   \PYG{l+m}{0}

A1\PYG{o}{(}\PYG{l+m}{2}:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
A2\PYG{o}{(}\PYG{l+m}{2}:3:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
\PYG{l+m}{1}:2:5 \PYG{o}{=}\PYGZgt{} \PYG{l+m}{3}
      \PYG{l+m}{1}   \PYG{l+m}{3}   \PYG{l+m}{5}
A1\PYG{o}{(}\PYG{l+m}{2}:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
A2\PYG{o}{(}\PYG{l+m}{2}:3:10\PYG{o}{)}: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
\PYG{l+m}{1}.:0.5:3.999 \PYG{o}{=}\PYGZgt{} \PYG{l+m}{6}
      \PYG{l+m}{1} \PYG{l+m}{1}.5   \PYG{l+m}{2} \PYG{l+m}{2}.5   \PYG{l+m}{3}
    \PYG{l+m}{3}.5
 A1\PYG{o}{(}\PYG{l+m}{2}.+0i:10.+0i\PYG{o}{)}: \PYG{l+m}{9}
    \PYG{o}{(}\PYG{l+m}{2},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{3},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{4},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{5},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{6},0\PYG{o}{)}
    \PYG{o}{(}\PYG{l+m}{7},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{8},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{9},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{10},0\PYG{o}{)}
 A2\PYG{o}{(}\PYG{l+m}{2}.:3.:10.\PYG{o}{)}\PYG{o}{=} \PYG{l+m}{3}
    \PYG{o}{(}\PYG{l+m}{2},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{5},0\PYG{o}{)}   \PYG{o}{(}\PYG{l+m}{8},0\PYG{o}{)}
 A1.re real part array: \PYG{l+m}{9}
      \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{6}
      \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}
 A1.im imag part array: \PYG{l+m}{9}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
a: \PYG{l+m}{5}
      \PYG{l+m}{2}   \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{4}

\PYG{n+nv}{b} \PYG{o}{=} a + a: \PYG{l+m}{5}
      \PYG{l+m}{4}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{8}   \PYG{l+m}{8}

\PYG{n+nv}{b} \PYG{o}{+=} a: \PYG{l+m}{5}
      \PYG{l+m}{6}   \PYG{l+m}{3}   \PYG{l+m}{6}  \PYG{l+m}{12}  \PYG{l+m}{12}

\PYG{n+nv}{b} \PYG{o}{+=} \PYG{l+m}{2}*a: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

 b /\PYG{o}{=} \PYG{l+m}{2}: \PYG{l+m}{5}
      \PYG{l+m}{5} \PYG{l+m}{2}.5   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{10}

b .*\PYG{o}{=} a: \PYG{l+m}{5}
     \PYG{l+m}{10} \PYG{l+m}{2}.5  \PYG{l+m}{10}  \PYG{l+m}{40}  \PYG{l+m}{40}

b ./\PYG{o}{=} a: \PYG{l+m}{5}
      \PYG{l+m}{5} \PYG{l+m}{2}.5   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{10}

\PYG{n+nv}{c} \PYG{o}{=} a + b: \PYG{l+m}{5}
      \PYG{l+m}{7} \PYG{l+m}{3}.5   \PYG{l+m}{7}  \PYG{l+m}{14}  \PYG{l+m}{14}

\PYG{n+nv}{c} \PYG{o}{=} \PYG{l+m}{2}*a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{24}  \PYG{l+m}{12}  \PYG{l+m}{24}  \PYG{l+m}{48}  \PYG{l+m}{48}

\PYG{n+nv}{c} \PYG{o}{=} a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{22}  \PYG{l+m}{11}  \PYG{l+m}{22}  \PYG{l+m}{44}  \PYG{l+m}{44}

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a + 4b: \PYG{l+m}{5}
     \PYG{l+m}{18}   \PYG{l+m}{9}  \PYG{l+m}{18}  \PYG{l+m}{36}  \PYG{l+m}{36}

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a \PYGZhy{} 4b: \PYG{l+m}{5}
    \PYGZhy{}22 \PYGZhy{}11 \PYGZhy{}22 \PYGZhy{}44 \PYGZhy{}44

\PYG{n+nv}{c} \PYG{o}{=} \PYGZhy{}a \PYGZhy{}b: \PYG{l+m}{5}
     \PYGZhy{}7 \PYGZhy{}3.5     \PYGZhy{}7 \PYGZhy{}14 \PYGZhy{}14

\PYG{n+nv}{c} \PYG{o}{=} a .* b: \PYG{l+m}{5}
     \PYG{l+m}{10} \PYG{l+m}{2}.5  \PYG{l+m}{10}  \PYG{l+m}{40}  \PYG{l+m}{40}

\PYG{n+nv}{c} \PYG{o}{=} a ./ b: \PYG{l+m}{5}
    \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4 \PYG{l+m}{0}.4

\PYG{n+nv}{c} \PYG{o}{=} \PYG{l+m}{2} * b: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

\PYG{n+nv}{c} \PYG{o}{=} b * \PYG{l+m}{2}: \PYG{l+m}{5}
     \PYG{l+m}{10}   \PYG{l+m}{5}  \PYG{l+m}{10}  \PYG{l+m}{20}  \PYG{l+m}{20}

\PYG{o}{||}a\PYG{o}{||}\PYG{n+nv}{\PYGZus{}1} \PYG{o}{=} \PYG{l+m}{13}
\PYG{o}{||}a\PYG{o}{||}\PYG{n+nv}{\PYGZus{}2} \PYG{o}{=} \PYG{l+m}{6}.40312
\PYG{o}{||}a\PYG{o}{||}\PYG{n+nv}{\PYGZus{}infty} \PYG{o}{=} \PYG{l+m}{4}
sum \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{13}
max \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{4} a\PYG{o}{[} \PYG{l+m}{3} \PYG{o}{]} \PYG{o}{=} \PYG{l+m}{4}
min \PYG{n+nv}{a\PYGZus{}i} \PYG{o}{=} \PYG{l+m}{1} a\PYG{o}{[} \PYG{l+m}{1} \PYG{o}{]} \PYG{o}{=} \PYG{l+m}{1}
a\PYG{l+s+s1}{\PYGZsq{} * a = 41}
\PYG{l+s+s1}{a quantile 0.2 = 2}
\PYG{l+s+s1}{b = a(I) : 5}
\PYG{l+s+s1}{      2   4   4  \PYGZhy{}3   4}

\PYG{l+s+s1}{c(I) = a 5}
\PYG{l+s+s1}{     \PYGZhy{}3  \PYGZhy{}3   2   4   2}

\PYG{l+s+s1}{b = a(I) : 5}
\PYG{l+s+s1}{      2   4   4  \PYGZhy{}3   4}

\PYG{l+s+s1}{c(I) = a 5}
\PYG{l+s+s1}{     \PYGZhy{}3  \PYGZhy{}3   4   9   4}

\PYG{l+s+s1}{A = 3 4}
\PYG{l+s+s1}{       1   5   2   1}
\PYG{l+s+s1}{       3   3   3   1}
\PYG{l+s+s1}{       4   5   2   4}

\PYG{l+s+s1}{C = 3 4}
\PYG{l+s+s1}{     (\PYGZhy{}50,\PYGZhy{}40) (\PYGZhy{}100,\PYGZhy{}80) (\PYGZhy{}150,\PYGZhy{}120) (\PYGZhy{}200,\PYGZhy{}160)}
\PYG{l+s+s1}{     (\PYGZhy{}100,\PYGZhy{}80) (\PYGZhy{}200,\PYGZhy{}160) (\PYGZhy{}300,\PYGZhy{}240) (\PYGZhy{}400,\PYGZhy{}320)}
\PYG{l+s+s1}{     (\PYGZhy{}150,\PYGZhy{}120) (\PYGZhy{}300,\PYGZhy{}240) (\PYGZhy{}450,\PYGZhy{}360) (\PYGZhy{}600,\PYGZhy{}480)}

\PYG{l+s+s1}{A = 3 4}
\PYG{l+s+s1}{       8  10  12  14}
\PYG{l+s+s1}{      16  20  24  28}
\PYG{l+s+s1}{      24  30  36  42}

\PYG{l+s+s1}{B = (3.*b*c\PYGZsq{}}\PYG{o}{)}\PYG{o}{(}I\PYGZca{}\PYGZhy{}1,J\PYGZca{}\PYGZhy{}1\PYG{o}{)} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{3} \PYG{l+m}{4} \PYG{l+m}{0}  \PYG{l+m}{12}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{10}
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYG{l+m}{12}
        \PYG{l+m}{1}         \PYG{l+m}{3} \PYG{l+m}{8}
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYG{l+m}{14}
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{l+m}{15}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{18}
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{l+m}{12}
        \PYG{l+m}{2}         \PYG{l+m}{4} \PYG{l+m}{21}
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYG{l+m}{5}
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{l+m}{6}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{4}
        \PYG{l+m}{3}         \PYG{l+m}{4} \PYG{l+m}{7}
\end{sphinxVerbatim}


\subsection{Block matrix}
\label{\detokenize{examples/developers:block-matrix}}\label{\detokenize{examples/developers:exampleblockmatrix}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{real} \PYG{n}{f1} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{f2} \PYG{o}{=} \PYG{l+m+mf}{1.5}\PYG{p}{;}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th1} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{mesh} \PYG{n}{Th2} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{x}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n}{Th2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Uh1}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh1} \PYG{n}{u1}\PYG{p}{;}

\PYG{k+kt}{fespace} \PYG{n+nf}{Uh2}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{,} \PYG{n+nc}{P2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Uh2} \PYG{n}{u2}\PYG{p}{;}

\PYG{c+c1}{// Macro}
\PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n}{vPoisson1} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th1}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f1} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{vPoisson2} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{\PYGZhy{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th2}\PYG{p}{)}\PYG{p}{(}
          \PYG{n}{f1} \PYG{o}{*} \PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Poisson1} \PYG{o}{=} \PYG{n}{vPoisson1}\PYG{p}{(}\PYG{n}{Uh1}\PYG{p}{,} \PYG{n}{Uh1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Poisson1b} \PYG{o}{=} \PYG{n}{vPoisson1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uh1}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{Poisson2} \PYG{o}{=} \PYG{n}{vPoisson2}\PYG{p}{(}\PYG{n}{Uh2}\PYG{p}{,} \PYG{n}{Uh2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Poisson2b} \PYG{o}{=} \PYG{n}{vPoisson2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Uh2}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//block matrix}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{real}\PYG{o}{\PYGZgt{}} \PYG{n}{G} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n}{Poisson1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Poisson2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{;}
\PYG{n+nf}{set}\PYG{p}{(}\PYG{n}{G}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{sparsesolver}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{//block right hand side}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{Gb} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Poisson1b}\PYG{p}{,} \PYG{n}{Poisson2b}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Solve}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{sol} \PYG{o}{=} \PYG{n}{G}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{n}{Gb}\PYG{p}{;}

\PYG{c+c1}{// Dispatch}
\PYG{p}{[}\PYG{n}{u1}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{[}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{sol}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,} \PYG{n}{u2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.700\linewidth]{{BlockMatrix}.png}
\caption{Result}\label{\detokenize{examples/developers:id2}}\end{figure}


\subsection{Matrix operations}
\label{\detokenize{examples/developers:matrix-operations}}\label{\detokenize{examples/developers:examplematrixoperations}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{f}\PYG{p}{,} \PYG{n}{g}\PYG{p}{;}
\PYG{n}{f} \PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{n}{g} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vh}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{ff}\PYG{p}{,} \PYG{n}{gg}\PYG{p}{;} \PYG{c+c1}{//a complex valued finite element function}
\PYG{n}{ff}\PYG{o}{=} \PYG{k+kr}{x}\PYG{o}{*}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gg} \PYG{o}{=} \PYG{n+nf}{exp}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{varf} \PYG{n+nf}{mat} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{varf} \PYG{n+nf}{mati} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
         \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{n}{i}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{l+m+mi}{4}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{mat}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{matrix}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{complex}\PYG{o}{\PYGZgt{}} \PYG{n}{AA} \PYG{o}{=} \PYG{n}{mati}\PYG{p}{(}\PYG{n}{Vh}\PYG{p}{,} \PYG{n}{Vh}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//a complex sparse matrix}

\PYG{c+c1}{// Operations}
\PYG{n}{Vh} \PYG{n}{m0}\PYG{p}{;} \PYG{n}{m0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{*}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m01}\PYG{p}{;} \PYG{n}{m01}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m1}\PYG{p}{;} \PYG{n}{m1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{m2}\PYG{p}{;} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{o}{/}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{p}{;}

\PYG{c+c1}{// Display}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{g = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m0 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m0}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m01 = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m01}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m1 = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m1}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{m2 = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dot Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hermitien Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{gg}\PYG{p}{[}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{outer Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k+kp}{A}\PYG{o}{=}\PYG{n}{f}\PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n}{g}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hermitien outer Product = }\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{n}{AA}\PYG{o}{=}\PYG{n}{ff}\PYG{p}{[}\PYG{p}{]}\PYG{o}{*}\PYG{n}{gg}\PYG{p}{[}\PYG{p}{]}\PYG{o}{\PYGZsq{}}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Diagonal}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{diagofA}\PYG{p}{(}\PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{diagofA} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag}\PYG{p}{;} \PYG{c+c1}{//get the diagonal of the matrix}
\PYG{k+kp}{A}\PYG{p}{.}\PYG{k+kr}{diag} \PYG{o}{=} \PYG{n}{diagofA} \PYG{p}{;} \PYG{c+c1}{//set the diagonal of the matrix}

\PYG{c+c1}{// Sparse matrix set}
\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{I}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{J}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{C}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]} \PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{;} \PYG{c+c1}{//get the sparse term of the matrix A (the array are resized)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{I} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{J = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{J} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{C} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kp}{A} \PYG{o}{=} \PYG{p}{[}\PYG{n}{I}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{C}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set a new matrix}
\PYG{k+kt}{matrix} \PYG{n}{D} \PYG{o}{=} \PYG{p}{[}\PYG{n}{diagofA}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{//set a diagonal matrix D from the array diagofA}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{D} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{f} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0} \PYG{l+m}{0}.5
      \PYG{l+m}{1}
\PYG{n+nv}{g} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{1} \PYG{l+m}{1}.224646799e\PYGZhy{}16   \PYG{l+m}{0}   \PYG{l+m}{1}
    \PYG{l+m}{1}.224646799e\PYGZhy{}16
\PYG{n+nv}{A} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{24}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYG{l+m}{0}
        \PYG{l+m}{1}         \PYG{l+m}{5} \PYGZhy{}2.5
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{l+m}{0}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{2}         \PYG{l+m}{5} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{2}         \PYG{l+m}{6} \PYGZhy{}2.5
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{l+m}{0}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{3}         \PYG{l+m}{6} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{4}         \PYG{l+m}{1} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{4}         \PYG{l+m}{4} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{4}         \PYG{l+m}{5} \PYG{l+m}{0}
        \PYG{l+m}{5}         \PYG{l+m}{1} \PYGZhy{}2.5
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{l+m}{0}.49999999999999977796
        \PYG{l+m}{5}         \PYG{l+m}{4} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{1}.0000000000000000199e+30
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{l+m}{0}
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYGZhy{}2.5
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{l+m}{0}
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{l+m}{0}.49999999999999994449
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.0000000000000000199e+30

\PYG{n+nv}{m0} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}1.25   \PYGZhy{}2.25   \PYG{l+m}{0}.5   \PYG{l+m}{0} 5e+29
    1e+30
\PYG{n+nv}{m01} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}1.25   \PYGZhy{}2.25     \PYG{l+m}{0} \PYG{l+m}{0}.25    5e+29
    1e+30
\PYG{n+nv}{m1} \PYG{o}{=} \PYG{l+m}{6}
      \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0} \PYG{l+m}{0}.5
    \PYG{l+m}{1}.224646799e\PYGZhy{}16
\PYG{n+nv}{m2} \PYG{o}{=} \PYG{l+m}{6}
    \PYGZhy{}nan      \PYG{l+m}{0}   \PYG{l+m}{0} \PYGZhy{}nan    \PYG{l+m}{0}.5
    \PYG{l+m}{8}.165619677e+15
dot \PYG{n+nv}{Product} \PYG{o}{=} \PYG{l+m}{0}.5
hermitien \PYG{n+nv}{Product} \PYG{o}{=} \PYG{o}{(}\PYG{l+m}{1}.11022e\PYGZhy{}16,2.5\PYG{o}{)}
outer \PYG{n+nv}{Product} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{8}
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{l+m}{0}.5
        \PYG{l+m}{5}         \PYG{l+m}{3} \PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{0}.5
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYG{l+m}{1}
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{l+m}{1}
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16

hermitien outer \PYG{n+nv}{Product} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{0}  \PYG{l+m}{24}
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0},0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{0}.5,3.0616169978683830179e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYG{o}{(}\PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17,\PYGZhy{}0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0},0.5\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{0}.5,3.0616169978683830179e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{2}         \PYG{l+m}{6} \PYG{o}{(}\PYG{l+m}{6}.1232339957367660359e\PYGZhy{}17,\PYGZhy{}0.5\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0},1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{1},6.1232339957367660359e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{o}{(}\PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16,\PYGZhy{}1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0},1\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{1},6.1232339957367660359e\PYGZhy{}17\PYG{o}{)}
        \PYG{l+m}{3}         \PYG{l+m}{6} \PYG{o}{(}\PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16,\PYGZhy{}1\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{0}.5,0.5\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{0}.5,\PYGZhy{}0.49999999999999994449\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{3} \PYG{o}{(}\PYGZhy{}0.49999999999999994449,\PYGZhy{}0.50000000000000011102\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{0}.5,0.5\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{0}.5,\PYGZhy{}0.49999999999999994449\PYG{o}{)}
        \PYG{l+m}{5}         \PYG{l+m}{6} \PYG{o}{(}\PYGZhy{}0.49999999999999994449,\PYGZhy{}0.50000000000000011102\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{1} \PYG{o}{(}\PYG{l+m}{1},1\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{2} \PYG{o}{(}\PYG{l+m}{1},\PYGZhy{}0.99999999999999988898\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{3} \PYG{o}{(}\PYGZhy{}0.99999999999999988898,\PYGZhy{}1.000000000000000222\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{4} \PYG{o}{(}\PYG{l+m}{1},1\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{5} \PYG{o}{(}\PYG{l+m}{1},\PYGZhy{}0.99999999999999988898\PYG{o}{)}
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{o}{(}\PYGZhy{}0.99999999999999988898,\PYGZhy{}1.000000000000000222\PYG{o}{)}

\PYG{n+nv}{I} \PYG{o}{=} \PYG{l+m}{8}
      \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{4}   \PYG{l+m}{5}
      \PYG{l+m}{5}   \PYG{l+m}{5}   \PYG{l+m}{5}
\PYG{n+nv}{J} \PYG{o}{=} \PYG{l+m}{8}
      \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{5}   \PYG{l+m}{1}
      \PYG{l+m}{2}   \PYG{l+m}{4}   \PYG{l+m}{5}
\PYG{n+nv}{C} \PYG{o}{=} \PYG{l+m}{8}
    \PYG{l+m}{0}.5 \PYG{l+m}{6}.123233996e\PYGZhy{}17 \PYG{l+m}{0}.5 \PYG{l+m}{6}.123233996e\PYGZhy{}17   \PYG{l+m}{1}
    \PYG{l+m}{1}.224646799e\PYGZhy{}16   \PYG{l+m}{1} \PYG{l+m}{1}.224646799e\PYGZhy{}16
  \PYGZhy{}\PYGZhy{} Raw Matrix    \PYG{n+nv}{nxm}  \PYG{o}{=}6x6 nb  none zero coef. \PYG{l+m}{8}
  \PYGZhy{}\PYGZhy{} Raw Matrix    \PYG{n+nv}{nxm}  \PYG{o}{=}6x6 nb  none zero coef. \PYG{l+m}{6}
\PYG{n+nv}{D} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{6} \PYG{l+m}{6} \PYG{l+m}{1}  \PYG{l+m}{6}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYG{l+m}{0}
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYG{l+m}{0}
        \PYG{l+m}{3}         \PYG{l+m}{3} \PYG{l+m}{0}
        \PYG{l+m}{4}         \PYG{l+m}{4} \PYG{l+m}{0}
        \PYG{l+m}{5}         \PYG{l+m}{5} \PYG{l+m}{0}.5
        \PYG{l+m}{6}         \PYG{l+m}{6} \PYG{l+m}{1}.2246467991473532072e\PYGZhy{}16
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Due to \sphinxcode{\sphinxupquote{Fortran}} indices starting at one, the output of a diagonal matrix \sphinxcode{\sphinxupquote{D}} is indexed from 1. but in \sphinxstylestrong{FreeFEM}, the indices start from 0.
\end{sphinxadmonition}


\subsection{Matrix inversion}
\label{\detokenize{examples/developers:matrix-inversion}}\label{\detokenize{examples/developers:examplematrixinversion}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{lapack}\PYG{l+s}{\PYGZdq{}}
\PYG{c+cp}{load} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fflapack}\PYG{l+s}{\PYGZdq{}}

\PYG{c+c1}{// Matrix}
\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{k+kp}{A}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{A1}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,} \PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{,} \PYG{k+kp}{B}\PYG{p}{(}\PYG{k+kr}{n}\PYG{p}{,}\PYG{k+kr}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{=} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=}\PYG{o}{=} \PYG{n}{j}\PYG{p}{)} \PYG{o}{?} \PYG{k+kr}{n}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Inversion (lapack)}
\PYG{k+kp}{A1} \PYG{o}{=} \PYG{k+kp}{A}\PYG{o}{\PYGZca{}}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//def in \PYGZdq{}lapack\PYGZdq{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kp}{B} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{k} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{k} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{n}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{k}\PYG{p}{)}
            \PYG{k+kp}{B}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{)} \PYG{o}{+}\PYG{o}{=} \PYG{k+kp}{A}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}\PYG{o}{*}\PYG{k+kp}{A1}\PYG{p}{(}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{B} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Inversion (fflapack)}
\PYG{n}{inv}\PYG{p}{(}\PYG{k+kp}{A1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//def in \PYGZdq{}fflapack\PYGZdq{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}

\PYG{l+m}{5} \PYG{l+m}{5}
     \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18 \PYGZhy{}0.02
     \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYGZhy{}0.02 \PYG{l+m}{0}.18

\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{1} \PYG{l+m}{1}.040834086e\PYGZhy{}17 \PYG{l+m}{1}.040834086e\PYGZhy{}17 \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{3}.469446952e\PYGZhy{}18   \PYG{l+m}{1} \PYGZhy{}1.734723476e\PYGZhy{}17 \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{2}.428612866e\PYGZhy{}17 \PYGZhy{}3.122502257e\PYGZhy{}17   \PYG{l+m}{1} \PYG{l+m}{1}.734723476e\PYGZhy{}17 \PYG{l+m}{2}.775557562e\PYGZhy{}17
     \PYG{l+m}{2}.081668171e\PYGZhy{}17 \PYGZhy{}6.938893904e\PYGZhy{}17 \PYGZhy{}3.469446952e\PYGZhy{}17   \PYG{l+m}{1}   \PYG{l+m}{0}
     \PYG{l+m}{2}.775557562e\PYGZhy{}17 \PYGZhy{}4.163336342e\PYGZhy{}17 \PYGZhy{}2.775557562e\PYGZhy{}17   \PYG{l+m}{0}   \PYG{l+m}{1}

\PYG{l+m}{5} \PYG{l+m}{5}
       \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}   \PYG{l+m}{1}
       \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{1}   \PYG{l+m}{6}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{tip}{Tip:}
\sphinxAtStartPar
To compile \sphinxcode{\sphinxupquote{lapack.cpp}} and \sphinxcode{\sphinxupquote{fflapack.cpp}}, you must have the \sphinxcode{\sphinxupquote{lapack}} library on your system and compile the plugin with the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
ff\PYGZhy{}c++ lapack.cpp \PYGZhy{}llapack     ff\PYGZhy{}c++ fflapack.cpp \PYGZhy{}llapack
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{FE array}
\label{\detokenize{examples/developers:fe-array}}\label{\detokenize{examples/developers:examplefearray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{,} \PYG{n}{f}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{problem} \PYG{n+nf}{Poisson} \PYG{p}{(}\PYG{n}{u}\PYG{p}{,} \PYG{n}{v}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{v}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{on}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{u}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{p}{;}

\PYG{n}{Vh}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{uu}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//an array of FE function}
\PYG{c+c1}{// Solve problem 1}
\PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 2}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{sin}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{x}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{cos}\PYG{p}{(}\PYG{k+kr}{pi}\PYG{o}{*}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}
\PYG{c+c1}{// Solve problem 3}
\PYG{n}{f} \PYG{o}{=} \PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{x}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{k+kr}{y}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Poisson}\PYG{p}{;}
\PYG{n}{uu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{u}\PYG{p}{;}

\PYG{c+c1}{// Plot}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{3}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uu}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{k+kp}{wait}\PYG{o}{=}\PYG{k+kr}{true}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{figure}
\centering
\capstart
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray1}.png}
\caption{First result}\label{\detokenize{examples/developers:id3}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray2}.png}
\caption{Second result}\label{\detokenize{examples/developers:id4}}\end{subfigure}
\begin{subfigure}[t]{0.49\linewidth}
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.950\linewidth]{{FEArray3}.png}
\caption{Third result}\label{\detokenize{examples/developers:id5}}\end{subfigure}
\caption{Finite element array}

\end{figure}



\subsection{Loop}
\label{\detokenize{examples/developers:loop}}\label{\detokenize{examples/developers:exampleloop}}\label{\detokenize{examples/developers:FEArray}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{;} \PYG{n}{i}\PYG{o}{=}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{real} \PYG{k+kp}{eps} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{p}{;}
\PYG{k}{while} \PYG{p}{(}\PYG{k+kp}{eps} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}5}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k+kp}{eps} \PYG{o}{=} \PYG{k+kp}{eps}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{100}\PYG{p}{)}
        \PYG{k}{break}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{eps} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{20}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{k}{continue}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{j = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Implicit loop}
\label{\detokenize{examples/developers:implicit-loop}}\label{\detokenize{examples/developers:exampleimplicitloop}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{b}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{bi} \PYG{o}{:} \PYG{n}{b}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{n}{bi} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{n}{a}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{n}{aij} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{p}{(}\PYG{n+nf}{abs}\PYG{p}{(}\PYG{n}{aij}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2}\PYG{p}{)} \PYG{n}{aij} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{matrix} \PYG{k+kp}{A} \PYG{o}{=} \PYG{n}{a}\PYG{p}{;}
\PYG{k+kt}{string}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{ss}\PYG{p}{;} \PYG{c+c1}{//a map}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{ss}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{bi} \PYG{o}{:} \PYG{n}{ss}\PYG{p}{]}
    \PYG{n}{bi} \PYG{o}{=} \PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{6} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}dddd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ss = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ss} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{p}{[}\PYG{k+kt}{string}\PYG{p}{]} \PYG{n}{si}\PYG{p}{;}
\PYG{n}{si}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{si}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n+nl}{vi} \PYG{o}{:} \PYG{n}{si}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ i }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{setw}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{setw}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{vi} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{vi} \PYG{o}{=} \PYG{n+nf}{atoi}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{si = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{si} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n+nl}{aij} \PYG{o}{:} \PYG{k+kp}{A}\PYG{p}{]}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{aij} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{aij} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{aij}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{A} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{0} \PYG{l+m}{1}
\PYG{l+m}{1} \PYG{l+m}{2}
\PYG{l+m}{2} \PYG{l+m}{3}
\PYG{l+m}{3} \PYG{l+m}{4}
\PYG{l+m}{4} \PYG{l+m}{5}
\PYG{l+m}{5} \PYG{l+m}{6}
\PYG{l+m}{6} \PYG{l+m}{7}
\PYG{l+m}{7} \PYG{l+m}{8}
\PYG{l+m}{8} \PYG{l+m}{9}
\PYG{l+m}{9} \PYG{l+m}{10}
\PYG{n+nv}{b} \PYG{o}{=} \PYG{l+m}{10}
      \PYG{l+m}{1}   \PYG{l+m}{2}   \PYG{l+m}{3}   \PYG{l+m}{4}   \PYG{l+m}{5}
      \PYG{l+m}{6}   \PYG{l+m}{7}   \PYG{l+m}{8}   \PYG{l+m}{9}  \PYG{l+m}{10}

\PYG{n+nv}{a} \PYG{o}{=} \PYG{l+m}{10} \PYG{l+m}{10}
     \PYG{l+m}{0}.5 \PYG{l+m}{0}.3333333333 \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.3333333333 \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.25 \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
     \PYG{l+m}{0}.2   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}
       \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}   \PYG{l+m}{0}

\PYG{n+nv}{ss} \PYG{o}{=} \PYG{l+m}{1} \PYG{l+m}{1}
\PYG{l+m}{2} \PYG{l+m}{2}
\PYG{l+m}{3} \PYG{l+m}{5}

 i   \PYG{l+m}{1}          \PYG{l+m}{2}
 i  \PYG{l+m}{50}          \PYG{l+m}{1}
\PYG{n+nv}{si} \PYG{o}{=} \PYG{l+m}{1} \PYG{l+m}{2}
\PYG{l+m}{50} \PYG{l+m}{100}

\PYG{l+m}{0} \PYG{l+m}{0} \PYG{l+m}{0}.5
\PYG{l+m}{0} \PYG{l+m}{1} \PYG{l+m}{0}.333333
\PYG{l+m}{0} \PYG{l+m}{2} \PYG{l+m}{0}.25
\PYG{l+m}{0} \PYG{l+m}{3} \PYG{l+m}{0}.2
\PYG{l+m}{1} \PYG{l+m}{0} \PYG{l+m}{0}.333333
\PYG{l+m}{1} \PYG{l+m}{1} \PYG{l+m}{0}.25
\PYG{l+m}{1} \PYG{l+m}{2} \PYG{l+m}{0}.2
\PYG{l+m}{2} \PYG{l+m}{0} \PYG{l+m}{0}.25
\PYG{l+m}{2} \PYG{l+m}{1} \PYG{l+m}{0}.2
\PYG{l+m}{3} \PYG{l+m}{0} \PYG{l+m}{0}.2
\PYG{c+c1}{\PYGZsh{} Sparse Matrix (Morse)}
\PYG{c+c1}{\PYGZsh{} first line: n m (is symmetic) nbcoef}
\PYG{c+c1}{\PYGZsh{} after for each nonzero coefficient:   i j a\PYGZus{}ij where (i,j) \PYGZbs{}in  \PYGZob{}1,...,n\PYGZcb{}x\PYGZob{}1,...,m\PYGZcb{}}
\PYG{l+m}{10} \PYG{l+m}{10} \PYG{l+m}{0}  \PYG{l+m}{10}
        \PYG{l+m}{1}         \PYG{l+m}{1} \PYGZhy{}0.5
        \PYG{l+m}{1}         \PYG{l+m}{2} \PYGZhy{}0.33333333333333331483
        \PYG{l+m}{1}         \PYG{l+m}{3} \PYGZhy{}0.25
        \PYG{l+m}{1}         \PYG{l+m}{4} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{2}         \PYG{l+m}{1} \PYGZhy{}0.33333333333333331483
        \PYG{l+m}{2}         \PYG{l+m}{2} \PYGZhy{}0.25
        \PYG{l+m}{2}         \PYG{l+m}{3} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{3}         \PYG{l+m}{1} \PYGZhy{}0.25
        \PYG{l+m}{3}         \PYG{l+m}{2} \PYGZhy{}0.2000000000000000111
        \PYG{l+m}{4}         \PYG{l+m}{1} \PYGZhy{}0.2000000000000000111
\end{sphinxVerbatim}


\subsection{I/O}
\label{\detokenize{examples/developers:i-o}}\label{\detokenize{examples/developers:exampleio}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{std\PYGZhy{}out}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ enter i = ?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{k+kr}{cin} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//close the file f because the variable f is delete}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ifstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{f} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{i}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{n}{f}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{toto.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{append}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{//to append to the existing file \PYGZdq{}toto.txt\PYGZdq{}}
    \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{hello world\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}} \PYG{c+c1}{//close the file f because the variable f is delete}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{File stream}
\label{\detokenize{examples/developers:file-stream}}\label{\detokenize{examples/developers:examplefilestream}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{int} \PYG{n}{where}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{f} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{g}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{ofstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{precision}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{f} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{where} \PYG{o}{=} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{tellp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.1} \PYG{p}{;}

    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where in file }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{where} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZsh{} comment bla bla ... 0.3 }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{0.2} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{flush}\PYG{p}{;} \PYG{c+c1}{//to flush the buffer of file}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//Function to skip comment starting with \PYGZsh{} in a file}
\PYG{k+kt}{func} \PYG{k+kt}{ifstream} \PYG{n}{skipcomment}\PYG{p}{(}\PYG{k+kt}{ifstream} \PYG{o}{\PYGZam{}}\PYG{n}{ff}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{while}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{where} \PYG{o}{=} \PYG{n}{ff}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//store file position}
        \PYG{k+kt}{string} \PYG{n}{comment}\PYG{p}{;}
        \PYG{n}{ff} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{comment}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{ff}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{comment}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{o}{:}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{o}{=}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZsh{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{\PYGZob{}}
            \PYG{n+nf}{getline}\PYG{p}{(}\PYG{n}{ff}\PYG{p}{,} \PYG{n}{comment}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ \PYGZhy{}\PYGZhy{} \PYGZsh{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{comment} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}\PYG{p}{\PYGZob{}}
            \PYG{n}{ff}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{where}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//restore file position}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{ff}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kt}{ifstream} \PYG{k+kp}{file}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{f.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kr}{binary}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{n}{where}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ xx = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{xx} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ good ? }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{xx} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{skipcomment}\PYG{p}{(}\PYG{k+kp}{file}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{xx}\PYG{p}{;}
    \PYG{n+nf}{assert}\PYG{p}{(}\PYG{n}{xx} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mf}{0.2}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{seekg}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//rewind}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Where }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{n+nf}{tellg}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kp}{file}\PYG{p}{.}\PYG{k+kr}{good}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{k+kp}{file} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{g}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Command line arguments}
\label{\detokenize{examples/developers:command-line-arguments}}\label{\detokenize{examples/developers:examplecommandlinearguments}}
\sphinxAtStartPar
When using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ script.edp arg1 arg2
\end{sphinxVerbatim}

\sphinxAtStartPar
The arguments can be used in the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{.}\PYG{k+kr}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{ARGV}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
When using the command:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
FreeFem++ script.edp \PYGZhy{}n \PYG{l+m}{10} \PYGZhy{}a \PYG{l+m}{1}. \PYGZhy{}d \PYG{l+m}{42}.
\end{sphinxVerbatim}

\sphinxAtStartPar
The arguments can be used in the script with:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+cp}{include} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{getARGV.idp}\PYG{l+s}{\PYGZdq{}}

\PYG{k+kt}{int} \PYG{k+kr}{n} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n}{a} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{real} \PYG{n+nf}{d} \PYG{o}{=} \PYG{n+nf}{getARGV}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Macro}
\label{\detokenize{examples/developers:macro}}\label{\detokenize{examples/developers:examplemacro}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Macro without parameters}
\PYG{k+kt}{macro} \PYG{n+nf}{xxx}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}

\PYG{n}{xxx}

\PYG{c+c1}{// Macro with parameters}
\PYG{k+kt}{macro} \PYG{n}{toto}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{n}{i} \PYG{c+c1}{//}

\PYG{n}{toto}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{// Macro as parameter of a macro}
\PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n+nf}{VIL6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VIL3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}
    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{k+kt}{macro} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,} \PYG{n}{vv}\PYG{p}{)} \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}

\PYG{k+kt}{func} \PYG{n}{C5x5} \PYG{o}{=} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{VIL6}\PYG{p}{,} \PYG{n}{CC}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{E5x2} \PYG{o}{=} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{VIL3}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{Eps} \PYG{o}{=} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{VIL3}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Macro concatenation}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{Ux}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}

\PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{V}\PYG{p}{)} \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{div}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// Verify the quoting}
\PYG{k+kt}{macro} \PYG{n+nf}{foo}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)} \PYG{n}{i} \PYG{n}{j} \PYG{n}{k} \PYG{c+c1}{//}
\PYG{n}{foo}\PYG{p}{(}\PYG{p}{,} \PYG{p}{,} \PYG{p}{)}
\PYG{n}{foo}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{k+kt}{int}\PYG{p}{[}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{p}{)}\PYG{p}{;}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

\PYG{c+c1}{//NewMacro \PYGZhy{} EndMacro}
\PYG{k+kt}{NewMacro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]} \PYG{k+kt}{EndMacro}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}\PYG{n}{grad}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{o}{\PYGZsq{}} \PYG{o}{*} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+c1}{// IFMACRO \PYGZhy{} ENDIFMACRO}
\PYG{k+kt}{macro} \PYG{n}{AA} \PYG{n}{CAS1} \PYG{c+c1}{//}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,}\PYG{n}{CAS1} \PYG{p}{)}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AA = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{k+kt}{macro} \PYG{n}{CASE} \PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{c+cp}{ENDIFMACRO}
\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{AA}\PYG{p}{,} \PYG{n}{CAS2}\PYG{p}{)}
\PYG{k+kt}{macro} \PYG{n}{CASE} \PYG{n}{file2}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{c+cp}{ENDIFMACRO}

\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CASE = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

\PYG{c+cp}{IFMACRO}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)}
\PYG{c+cp}{include} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{CASE}\PYG{p}{)}
\PYG{c+cp}{ENDIFMACRO}

\PYG{c+c1}{// FILE \PYGZhy{} LINE}
\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{FILE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, line }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{LINE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output script generated with macros is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{c+c1}{// Macro without parameters}
\PYG{l+m+mi}{2} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{xxx} \PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{3} \PYG{o}{:}     \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{4} \PYG{o}{:}     \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{5} \PYG{o}{:}     \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{6} \PYG{o}{:} \PYG{p}{\PYGZcb{}}\PYG{c+c1}{//}
\PYG{l+m+mi}{7} \PYG{o}{:}
\PYG{l+m+mi}{8} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}
\PYG{l+m+mi}{4} \PYG{o}{:}  \PYG{p}{\PYGZob{}}
\PYG{l+m+mi}{1} \PYG{o}{:}     \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}     \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{l+m+mi}{3} \PYG{o}{:}     \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{4} \PYG{o}{:} \PYG{p}{\PYGZcb{}}
\PYG{l+m+mi}{9} \PYG{o}{:}
\PYG{l+m+mi}{10} \PYG{o}{:} \PYG{c+c1}{// Macro with parameters}
\PYG{l+m+mi}{11} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{toto}\PYG{p}{(}\PYG{n}{i} \PYG{p}{)}   \PYG{n}{i} \PYG{c+c1}{//}
\PYG{l+m+mi}{12} \PYG{o}{:}
\PYG{l+m+mi}{13} \PYG{o}{:}                    \PYG{k+kt}{real} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kt}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{j} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{14} \PYG{o}{:}
\PYG{l+m+mi}{15} \PYG{o}{:} \PYG{c+c1}{// Macro as parameter of a macro}
\PYG{l+m+mi}{16} \PYG{o}{:} \PYG{k+kt}{real}\PYG{p}{[}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{17} \PYG{o}{:}
\PYG{l+m+mi}{18} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VIL6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{i} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{19} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VIL3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{i} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{20} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VV6}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vv} \PYG{p}{)}   \PYG{p}{[}
\PYG{l+m+mi}{21} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mi}{22} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}
\PYG{l+m+mi}{23} \PYG{o}{:}    \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{24} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{VV3}\PYG{p}{(}\PYG{n}{v}\PYG{p}{,}\PYG{n}{vv} \PYG{p}{)}   \PYG{p}{[}\PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{v}\PYG{p}{(}\PYG{n}{vv}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{//}
\PYG{l+m+mi}{25} \PYG{o}{:}
\PYG{l+m+mi}{26} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{C5x5} \PYG{o}{=}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}       \PYG{p}{[}
\PYG{l+m+mi}{1} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}         \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{2} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}         \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{3} \PYG{o}{:}             \PYG{p}{[} \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{CC}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{27} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{E5x2} \PYG{o}{=}
\PYG{l+m+mi}{1} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{3} \PYG{o}{:}       \PYG{p}{[}
\PYG{l+m+mi}{1} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{2} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}
\PYG{l+m+mi}{3} \PYG{o}{:}          \PYG{p}{[} \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EE}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{28} \PYG{o}{:} \PYG{k+kt}{func} \PYG{n}{Eps} \PYG{o}{=}      \PYG{p}{[}     \PYG{p}{[} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]} \PYG{p}{,}      \PYG{p}{[} \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}  \PYG{n}{EEps}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{]} \PYG{p}{]} \PYG{p}{;}
\PYG{l+m+mi}{29} \PYG{o}{:}
\PYG{l+m+mi}{30} \PYG{o}{:} \PYG{c+c1}{// Macro concatenation}
\PYG{l+m+mi}{31} \PYG{o}{:} \PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{32} \PYG{o}{:} \PYG{k+kt}{fespace} \PYG{n}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{33} \PYG{o}{:} \PYG{n}{Vh} \PYG{n}{Ux}\PYG{o}{=}\PYG{k+kr}{x}\PYG{p}{,} \PYG{n}{Uy}\PYG{o}{=}\PYG{k+kr}{y}\PYG{p}{;}
\PYG{l+m+mi}{34} \PYG{o}{:}
\PYG{l+m+mi}{35} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{div}\PYG{p}{(}\PYG{n}{V} \PYG{p}{)}   \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{V}\PYG{o}{\PYGZsh{}}\PYG{k+kr}{y}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{//}
\PYG{l+m+mi}{36} \PYG{o}{:}
\PYG{l+m+mi}{37} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}     \PYG{p}{(}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)} \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{)} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{38} \PYG{o}{:}
\PYG{l+m+mi}{39} \PYG{o}{:} \PYG{c+c1}{// Verify the quoting}
\PYG{l+m+mi}{40} \PYG{o}{:}    \PYG{k+kt}{macro} \PYG{n}{foo}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k} \PYG{p}{)}   \PYG{n}{i} \PYG{n}{j} \PYG{n}{k} \PYG{c+c1}{//}
\PYG{l+m+mi}{41} \PYG{o}{:}
\PYG{l+m+mi}{42} \PYG{o}{:}         \PYG{k+kt}{int}\PYG{p}{[} \PYG{k+kt}{int}\PYG{p}{]} \PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{p}{)}\PYG{p}{;}
\PYG{l+m+mi}{43} \PYG{o}{:}
\PYG{l+m+mi}{44} \PYG{o}{:} \PYG{c+c1}{//NewMacro \PYGZhy{} EndMacro}
\PYG{l+m+mi}{45} \PYG{o}{:}  \PYG{k+kt}{macro} \PYG{n}{grad}\PYG{p}{(}\PYG{n}{u} \PYG{p}{)}   \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{]}
\PYG{l+m+mi}{46} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}    \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Ux}\PYG{p}{)}\PYG{p}{]} \PYG{o}{\PYGZsq{}} \PYG{o}{*}     \PYG{p}{[}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{,} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{Uy}\PYG{p}{)}\PYG{p}{]} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{47} \PYG{o}{:}
\PYG{l+m+mi}{48} \PYG{o}{:} \PYG{c+c1}{// IFMACRO \PYGZhy{} ENDIFMACRO}
\PYG{l+m+mi}{49} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{AACAS1} \PYG{c+c1}{//}
\PYG{l+m+mi}{50} \PYG{o}{:}
\PYG{l+m+mi}{51} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AA = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(} \PYG{n}{CAS1} \PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}   \PYG{k+kt}{macro} \PYG{n}{CASEfile1}\PYG{p}{.}\PYG{n}{edp}\PYG{c+c1}{//}
\PYG{l+m+mi}{3} \PYG{o}{:}
\PYG{l+m+mi}{52} \PYG{o}{:}
\PYG{l+m+mi}{53} \PYG{o}{:}
\PYG{l+m+mi}{54} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{CASE = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{55} \PYG{o}{:}
\PYG{l+m+mi}{56} \PYG{o}{:}
\PYG{l+m+mi}{1} \PYG{o}{:} \PYG{c+cp}{include} \PYG{n+nf}{Stringification}\PYG{p}{(}\PYG{n}{file1}\PYG{p}{.}\PYG{n}{edp}\PYG{p}{)}\PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is the file 1}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{2} \PYG{o}{:}
\PYG{l+m+mi}{57} \PYG{o}{:}
\PYG{l+m+mi}{58} \PYG{o}{:} \PYG{c+c1}{// FILE \PYGZhy{} LINE}
\PYG{l+m+mi}{59} \PYG{o}{:} \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{In }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{FILE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, line }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{LINE} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output os this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n+nv}{AA} \PYG{o}{=} CAS1
\PYG{n+nv}{CASE} \PYG{o}{=} file1.edp
This is the file \PYG{l+m}{1}
In Macro.edp, line \PYG{l+m}{59}
\end{sphinxVerbatim}


\subsection{Basic error handling}
\label{\detokenize{examples/developers:basic-error-handling}}\label{\detokenize{examples/developers:examplebasicerrorhandling}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kt}{real} \PYG{n}{a}\PYG{p}{;}
\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch} \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{c+c1}{//all exceptions can be caught}
\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Catch an ExecError}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
    \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mf}{0.}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+m}{1}/0 : d d d
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{3}
Exec error :  Div by \PYG{l+m}{0}
   \PYGZhy{}\PYGZhy{} number :1
Catch an ExecError
\end{sphinxVerbatim}


\subsection{Error handling}
\label{\detokenize{examples/developers:error-handling}}\label{\detokenize{examples/developers:exampleerrorhandling}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{c+c1}{// Parameters}
\PYG{k+kt}{int} \PYG{n}{nn} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{func} \PYG{n}{f} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{c+c1}{//right hand side function}
\PYG{k+kt}{func} \PYG{n}{g} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{c+c1}{//boundary condition function}

\PYG{c+c1}{// Mesh}
\PYG{k+kt}{mesh} \PYG{n}{Th} \PYG{o}{=} \PYG{n+nf}{square}\PYG{p}{(}\PYG{n}{nn}\PYG{p}{,} \PYG{n}{nn}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Fespace}
\PYG{k+kt}{fespace} \PYG{n+nf}{Vh}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{,} \PYG{n+nc}{P1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Vh} \PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{;}

\PYG{c+c1}{// Problem}
\PYG{k+kt}{real} \PYG{n}{cpu} \PYG{o}{=} \PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k+kt}{problem} \PYG{n+nf}{laplace} \PYG{p}{(}\PYG{n}{uh}\PYG{p}{,} \PYG{n}{vh}\PYG{p}{,} \PYG{k+kp}{solver}\PYG{o}{=}\PYG{k+kr}{Cholesky}\PYG{p}{,} \PYG{k+kp}{tolpivot}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}
    \PYG{o}{=} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
          \PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dx}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
        \PYG{o}{+} \PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{o}{*}\PYG{n+nf}{dy}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{o}{+} \PYG{n+nf}{int2d}\PYG{p}{(}\PYG{n}{Th}\PYG{p}{)}\PYG{p}{(}
        \PYG{o}{\PYGZhy{}} \PYG{n}{f}\PYG{o}{*}\PYG{n}{vh}
    \PYG{p}{)}
    \PYG{p}{;}

\PYG{k}{try}\PYG{p}{\PYGZob{}}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Try Cholesky}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}

    \PYG{c+c1}{// Solve}
    \PYG{n}{laplace}\PYG{p}{;}

    \PYG{c+c1}{// Plot}
    \PYG{n+nf}{plot}\PYG{p}{(}\PYG{n}{uh}\PYG{p}{)}\PYG{p}{;}

    \PYG{c+c1}{// Display}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{laplacian Cholesky }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nn} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, x\PYGZus{}}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{nn} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ : }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{\PYGZhy{}}\PYG{n}{cpu}\PYG{o}{+}\PYG{n+nf}{clock}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ s, max = }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{uh}\PYG{p}{[}\PYG{p}{]}\PYG{p}{.}\PYG{k+kr}{max} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k}{catch}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{//catch all error}
    \PYG{k+kr}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Catch cholesky PB }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k+kr}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The output of this script is:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Try Cholesky
ERREUR choleskypivot \PYG{o}{(}\PYG{l+m}{35}\PYG{o}{)}\PYG{o}{=} \PYGZhy{}6.43929e\PYGZhy{}15 \PYGZlt{} 1e\PYGZhy{}06
  current \PYG{n+nv}{line} \PYG{o}{=} \PYG{l+m}{29}
Exec error : FATAL ERREUR dans ./../femlib/MatriceCreuse\PYGZus{}tpl.hpp
cholesky line:
   \PYGZhy{}\PYGZhy{} number :688
 catch an erreur in  \PYG{n+nv}{solve}  \PYG{o}{=}\PYGZgt{}  \PYG{n+nb}{set}  \PYG{n+nv}{sol} \PYG{o}{=} \PYG{l+m}{0} !!!!!!!
 Catch cholesky PB
\end{sphinxVerbatim}

\begin{sphinxthebibliography}{HINTERMU}
\bibitem[PIRONNEAU1998]{bibliography:pironneau1998}
\sphinxAtStartPar
PIRONNEAU, Olivier and LUCQUIN\sphinxhyphen{}DESREUX, Brigitte. Introduction to scientific computing. Wiley, 1998.
\bibitem[WÄCHTER2006]{bibliography:wachter2006}
\sphinxAtStartPar
WÄCHTER, Andreas and BIEGLER, Lorenz T. On the implementation of an interior\sphinxhyphen{}point filter line\sphinxhyphen{}search algorithm for large\sphinxhyphen{}scale nonlinear programming. Mathematical programming, 2006, vol. 106, no 1, p. 25\sphinxhyphen{}57.
\bibitem[FORSGREN2002]{bibliography:forsgren2002}
\sphinxAtStartPar
FORSGREN, Anders, GILL, Philip E., and WRIGHT, Margaret H. Interior methods for nonlinear optimization. SIAM review, 2002, vol. 44, no 4, p. 525\sphinxhyphen{}597.
\bibitem[GEORGE1996]{bibliography:george1996}
\sphinxAtStartPar
GEORGE, P. L. and BOROUCHAKI, H. Automatic triangulation. 1996.
\bibitem[HECHT1998]{bibliography:hecht1998}
\sphinxAtStartPar
HECHT, F. The mesh adapting software: bamg. INRIA report, 1998, vol. 250, p. 252.
\bibitem[PREPARATA1985]{bibliography:preparata1985}
\sphinxAtStartPar
PREPARATA, F. P. and SHAMOS, M. I. Computational Geometry Springer\sphinxhyphen{}Verlag. New York, 1985.
\bibitem[STROUSTRUP2000]{bibliography:stroustrup2000}
\sphinxAtStartPar
STROUSTRUP, Bjarne. The C++ programming language. Pearson Education India, 2000.
\bibitem[HECHT2002]{bibliography:hecht2002}
\sphinxAtStartPar
HECHT, Frédéric. C++ Tools to construct our user\sphinxhyphen{}level language. ESAIM: Mathematical Modelling and Numerical Analysis, 2002, vol. 36, no 5, p. 809\sphinxhyphen{}836.
\bibitem[HANG2006]{bibliography:hang2006}
\sphinxAtStartPar
SI, Hang. TetGen Users’ guide: A quality tetrahedral mesh generator and three\sphinxhyphen{}dimensional delaunay triangulator. 2006
\bibitem[SHEWCHUK1998]{bibliography:shewchuk1998}
\sphinxAtStartPar
SHEWCHUK, Jonathan Richard. Tetrahedral mesh generation by Delaunay refinement. In : Proceedings of the fourteenth annual symposium on Computational geometry. ACM, 1998. p. 86\sphinxhyphen{}95.
\bibitem[HECHT1992]{bibliography:hecht1992}
\sphinxAtStartPar
HECHT, F. Outils et algorithmes pour la méthode des éléments finis. HdR, Université Pierre et Marie Curie, France, 1992.
\bibitem[HECHT1998\_2]{bibliography:hecht1998-2}
\sphinxAtStartPar
HECHT, Frédéric. BAMG: bidimensional anisotropic mesh generator. User Guide. INRIA, Rocquencourt, 1998.
\bibitem[KARYPIS1995]{bibliography:karypis1995}
\sphinxAtStartPar
KARYPIS, George and KUMAR, Vipin. METIS\textendash{}unstructured graph partitioning and sparse matrix ordering system, version 2.0. 1995.
\bibitem[CAI1989]{bibliography:cai1989}
\sphinxAtStartPar
CAI, Xiao\sphinxhyphen{}Chuan. Some domain decomposition algorithms for nonselfadjoint elliptic and parabolic partial differential equations. 1989.
\bibitem[SAAD2003]{bibliography:saad2003}
\sphinxAtStartPar
SAAD, Yousef. Iterative methods for sparse linear systems. siam, 2003.
\bibitem[SMITH1996]{bibliography:smith1996}
\sphinxAtStartPar
SMITH, B. P. Bj rstad and W. Gropp, Domain Decomposition. 1996.
\bibitem[OGDEN1984]{bibliography:ogden1984}
\sphinxAtStartPar
OGDEN, Ray W. Non\sphinxhyphen{}linear elastic deformations. 1984.
\bibitem[RAVIART1998]{bibliography:raviart1998}
\sphinxAtStartPar
RAVIART, Pierre\sphinxhyphen{}Arnaud, THOMAS, Jean\sphinxhyphen{}Marie, CIARLET, Philippe G., et al. Introduction à l’analyse numérique des équations aux dérivées partielles. Paris : Dunod, 1998.
\bibitem[HORGAN2004]{bibliography:horgan2004}
\sphinxAtStartPar
HORGAN, Cornelius O. and SACCOMANDI, Giuseppe. Constitutive models for compressible nonlinearly elastic materials with limiting chain extensibility. Journal of Elasticity, 2004, vol. 77, no 2, p. 123\sphinxhyphen{}138.
\bibitem[LEHOUCQ1998]{bibliography:lehoucq1998}
\sphinxAtStartPar
LEHOUCQ, Richard B., SORENSEN, Danny C., and YANG, Chao. ARPACK users’ guide: solution of large\sphinxhyphen{}scale eigenvalue problems with implicitly restarted Arnoldi methods. Siam, 1998.
\bibitem[NECAS2017]{bibliography:necas2017}
\sphinxAtStartPar
NECAS, Jindrich and HLAVÁCEK, Ivan. Mathematical theory of elastic and elasto\sphinxhyphen{}plastic bodies: an introduction. Elsevier, 2017.
\bibitem[OHTSUKA2000]{bibliography:ohtsuka2000}
\sphinxAtStartPar
OHTSUKA, K. Theoretical and Numerical analysis of energy release rate in 2D fracture. INFORMATION, 2000, vol. 3, p. 303\sphinxhyphen{}315.
\bibitem[TABATA1994]{bibliography:tabata1994}
\sphinxAtStartPar
TABATA, M. Numerical solutions of partial differential equations II. Iwanami Applied Math, 1994.
\bibitem[LUCQUIN1998]{bibliography:lucquin1998}
\sphinxAtStartPar
PIRONNEAU, O. and LUCQUIN\sphinxhyphen{}DESREUX, B. Introduction to scientific computing. Wiley, 1998.
\bibitem[WILMOTT1995]{bibliography:wilmott1995}
\sphinxAtStartPar
WILMOTT, Paul, HOWISON, Sam and DEWYNNE, Jeff. A student introduction to mathematical finance. 1995.
\bibitem[ACHDOU2005]{bibliography:achdou2005}
\sphinxAtStartPar
ACHDOU, Yves and PIRONNEAU, Olivier. Computational methods for option pricing. Siam, 2005.
\bibitem[TEMAM1977]{bibliography:temam1977}
\sphinxAtStartPar
TEMAM, Roger. Navier\sphinxhyphen{}Stokes equations: theory and numerical analysis. 1977.
\bibitem[ROBERTS1993]{bibliography:roberts1993}
\sphinxAtStartPar
ROBERTS, J. E. and THOMAS, J. M. Mixed and Hybrid Methods, Handbook of Numerical Anaysis, Vol. II. North\sphinxhyphen{}Holland, 1993, vol. 183, p. 184.
\bibitem[GLOWINSKI1979]{bibliography:glowinski1979}
\sphinxAtStartPar
GLOWINSKI, R. and PIRONNEAU, O. On numerical methods for the Stokes problem. In: Energy methods in finite element analysis.(A79\sphinxhyphen{}53076 24\sphinxhyphen{}39) Chichester, Sussex, England, Wiley\sphinxhyphen{}Interscience, 1979, p. 243\sphinxhyphen{}264., 1979, p. 243\sphinxhyphen{}264.
\bibitem[GLOWINSKI1985]{bibliography:glowinski1985}
\sphinxAtStartPar
GLOWINSKI, Roland and ODEN, J. Tinsley. Numerical methods for nonlinear variational problems. Journal of Applied Mechanics, 1985, vol. 52, p. 739.
\bibitem[GLOWINSKI2003]{bibliography:glowinski2003}
\sphinxAtStartPar
GLOWINSKI, Roland. Finite element methods for incompressible viscous flow. Handbook of numerical analysis, 2003, vol. 9, p. 3\sphinxhyphen{}1176.
\bibitem[ITO2003]{bibliography:ito2003}
\sphinxAtStartPar
ITO, Kazufumi and KUNISCH, Karl. Semi\textendash{}smooth Newton methods for variational inequalities of the first kind. ESAIM: Mathematical Modelling and Numerical Analysis, 2003, vol. 37, no 1, p. 41\sphinxhyphen{}62.
\bibitem[HINTERMULLER2002]{bibliography:hintermuller2002}
\sphinxAtStartPar
HINTERMÜLLER, Michael, ITO, Kazufumi, et KUNISCH, Karl. The primal\sphinxhyphen{}dual active set strategy as a semismooth Newton method. SIAM Journal on Optimization, 2002, vol. 13, no 3, p. 865\sphinxhyphen{}888.
\bibitem[OXBORROW2007]{bibliography:oxborrow2007}
\sphinxAtStartPar
OXBORROW, Mark. Traceable 2\sphinxhyphen{}D finite\sphinxhyphen{}element simulation of the whispering\sphinxhyphen{}gallery modes of axisymmetric electromagnetic resonators. IEEE Transactions on Microwave Theory and Techniques, 2007, vol. 55, no 6, p. 1209\sphinxhyphen{}1218.
\bibitem[GRUDININ2012]{bibliography:grudinin2012}
\sphinxAtStartPar
GRUDININ, Ivan S. and YU, Nan. Finite\sphinxhyphen{}element modeling of coupled optical microdisk resonators for displacement sensing. JOSA B, 2012, vol. 29, no 11, p. 3010\sphinxhyphen{}3014.
\bibitem[ERN2006]{bibliography:ern2006}
\sphinxAtStartPar
ERN, A. and GUERMOND, J. L. Discontinuous Galerkin methods for Friedrichs’ symmetric systems. I. General theory. SIAM J. Numer. Anal.
\bibitem[BERNADOU1980]{bibliography:bernadou1980}
\sphinxAtStartPar
BERNADOU, Michel, BOISSERIE, Jean\sphinxhyphen{}Marie and HASSAN, Kamal. Sur l’implémentation des éléments finis de Hsieh\sphinxhyphen{}Clough\sphinxhyphen{}Tocher complet et réduit. 1980. Thèse de doctorat. INRIA.
\bibitem[BERNARDI1985]{bibliography:bernardi1985}
\sphinxAtStartPar
BERNARDI, Christine and RAUGEL, Genevieve. Analysis of some finite elements for the Stokes problem. Mathematics of Computation, 1985, p. 71\sphinxhyphen{}79.
\bibitem[THOMASSET2012]{bibliography:thomasset2012}
\sphinxAtStartPar
THOMASSET, François. Implementation of finite element methods for Navier\sphinxhyphen{}Stokes equations. Springer Science \& Business Media, 2012.
\bibitem[CROUZEIX1984]{bibliography:crouzeix1984}
\sphinxAtStartPar
CROUZEIX, Michel and MIGNOT, Alain L. Analyse numérique des équations différentielles. Masson, 1984.
\bibitem[TAYLOR2005]{bibliography:taylor2005}
\sphinxAtStartPar
TAYLOR, Mark A., WINGATE, Beth A. and BOS, Len P. Several new quadrature formulas for polynomial integration in the triangle. arXiv preprint math/0501496, 2005.
\bibitem[CHOW1997]{bibliography:chow1997}
\sphinxAtStartPar
CHOW, Edmond and SAAD, Yousef. Parallel Approximate Inverse Preconditioners. In : PPSC. 1997.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}